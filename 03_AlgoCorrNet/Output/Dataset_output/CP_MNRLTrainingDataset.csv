,anchor,positive,negative
0,You are playing a game similar to Sokoban on an infinite number line The game is discrete so you only consider integer positions on the line You start on a position There are boxes the th box is on a position All positions of the boxes are distinct There are also special positions the th position is All the special positions are also distinct In one move you can go one position to the left or to the right If there is a box in the direction of your move then you push the box to the next position in that direction If the next position is taken by another box then that box is also pushed to the next position and so on You are allowed to perform any number of moves possibly zero Your goal is to place as many boxes on special positions as possible Note that some boxes can be initially placed on special positions ,Since you can only push boxes you can t bring boxes from negative positions to positive ones and vice versa Thus negative boxes special positions and positive boxes special positions are two separate tasks You can solve them independently with the same algorithm and add up the answers So we will only consider the positive boxes special positions case Notice that it never makes sense to move left Thus the only thing that determines the answer is the maximum position to the right you reach For a naive algorithm we could iterate over that position push all boxes that we have encountered on our way ahead of us and calculate the number of boxes that are on special positions That works in where is maximum coordinate To improve that solution we can notice that the positions that are the most optimal are actually the ones such that the first box is pushed to some special position Consider the case the first box isn t on a special position and there is a special position somewhere to the right of it There are two types of boxes the ones that are in the pile you would push if you move right and the remaining suffix What happens if you move one step to the right The number of boxes from the suffix on special positions doesn t change The number of boxes from the pile on special positions doesn t decrease This number changes depending on if there is a special position immediately to the right of the pile and underneath the first box Since we considered the case where there is no special position underneath the first box the number can t decrease So we managed to improve the solution to Still slow Let s now learn to maintain the answer while moving the boxes Precalculate the number of boxes from the th to the last one that are already on special positions That can be done with two pointers Now iterate over the special position under the first box in the increasing order Maintain the size of the pile and the number of special positions under the pile The first value is just the index of the first box not in a pile The second value is easier to obtain if you keep the index of the first special position after the pile or if there are none Also achievable with two pointers The answer is the number of special positions under the pile plus the suffix answer for the boxes after the pile Take the maximum of all options The constraints are pretty free so you could replace two pointers with binary searches if you wanted to Overall complexity per testcase ,If is even then each hour A and B are on the spots with different parity so they will never meet Otherwise let s look closely what happens At the start A in and B in But since we can form a cycle from spots then it means that and in reality are neighbors After that A and B starting from neighboring positions just go in opposite directions and meet each other in the opposite spot after exactly steps After meeting B jumps over A making extra step and the situation become practically the same A and B are neighbors and move in the opposite direction In other words each steps B makes one extra step so the answer if both and spots are indexed is 
1,You are given a tree consisting of vertices A number is written on each vertex the number on vertex is equal to Recall that a simple path is a path that visits each vertex at most once Let the of the path be the bitwise XOR of the values written on vertices it consists of Let s say that a tree is if no simple path has weight You can apply the following operation any number of times possibly zero select a vertex of the tree and replace the value written on it with an arbitrary positive integer What is the minimum number of times you have to apply this operation in order to make the tree ,To begin with we note that there are no restrictions on the values that can be written on the vertices so we can use numbers of the form for the th replacement Then if we replaced the value of a vertex then no path passing through this vertex has weight Let s root the tree at the vertex number We can use a greedy approach consider some vertex such that it is the LCA for two vertices and the path between which has XOR equal to Among such vertices pick one with the maximum distance from the root We need to change at least one vertex on the path It turns out that changing the vertex is always no worse than changing any other vertex on this path because all the remaining bad paths that pass through the vertex also pass through the vertex that s why we have chosen the deepest LCA This means that in order to solve the problem it is necessary to quickly find the deepest LCA of some bad path For the convenience of solving the problem let s denote the XOR on the path as where is XOR on the path from the root to the vertex For all vertices let s maintain a set of values such that belongs to the subtree of Let s use the small to large method to obtain such sets Also during the union of sets we can check if there is a bad path in this subtree i e if two values in the sets we merge have the same XOR as the value written on the current vertex because that s when the XOR on path is If such a path exists then we have to change the value of the vertex and mark that the vertices of this subtree cannot be the ends of a bad path anymore that means we just clear the set instead of pulling it up the tree This solution works in ,Note that whichever path you choose the total cost will be the same If you know that the cost is the same then it s not hard to calculate it It s equal to So the task is to check is equal to or not The constant cost may be proved by induction on for cost is For a fixed there are only two last steps you can make either from with cost the total cost is or from with cost the total cost is So whichever path you choose the total cost is the same 
2,You are given an array consisting of integers Indices of the array start from zero i e the first element is the second one is and so on You can reverse subarray continuous subsegment of this array Recall that the subarray of with borders and is Your task is to reverse such a subarray that the sum of elements on positions of the resulting array is i e the sum of elements for integer should be maximum possible You have to answer independent test cases ,Firstly we can notice that the reverse of of odd length subarray does nothing because it doesn t change parities of indices of affected elements Secondly we can consider the reverse of the subarray of length as reverses of subarrays of length i e it doesn t matter for us how exactly the subarray will be reversed we can only consider changing parities Now there are two ways the first one is smart and the second one is dynamic programming Consider the first way Calculate the initial sum of elements on even positions Then let s create two arrays and There is for all from to and is for all from to Elements of the first array deonte the profit if we reverse the subarray tarting from the even position and elemnts of the second array denote the profit if we reverse the subarray starting from the odd position Now we need to find the subarray with the maximum sum in both arrays this will maximize overall profit and add this value to to get the answer This problem can be solved easily consider the sum of the subarray as the difference of two prefix sums To maximize it consider all right borders and minimize the value Iterate over all positions of the array maintaining the current prefix sum and the minimum prefix sum we meet Update then update and then update the answer with the value And the second way is author s solution and it is dynamic programming This idea can be transformed to solve such problems in which you need to apply some function to some small number of subsegments of course under some constraints on functions State of our dynamic programming is where and denotes the answer on the prefix of length if we didn t start reversing the subarray denotes the answer if we started reversing the subarray but didn t end it and denotes the answer if we ended reversing the subarray Transitions are pretty easy The value is just a ternary if statement If is true then return otherwise return The answer is Time complexity with both approaches is ,One of the key observations to this problem is that after the first operations the first elements of the array are fixed and cannot be changed afterwards Also after the th operation the elements on positions from to are the same as they were before applying the operations This allows us to write the following dynamic programming the number of different prefixes our array can have if we have performed operations the th element is and the th element is The elements after are the same as in the original array and the elements before won t be changed anymore so we are interested only in these two elements Let s analyze the transitions in this dynamic programming We apply the operation to the elements and If we add to then we subtract it from so we transition into state Otherwise we transition into state The element we leave behind is either or and if these two transitions give us different prefixes But if we need to make only one of these transitions because adding or subtracting actually makes no difference Okay now we ve got a solution with dynamic programming in where is up to and is up to This is too slow But we can notice that the value of actually does not affect our transitions at all we can just discard it so our dynamic programming becomes which easily fits into TL Small implementation note elements can become negative and in order to store dynamic programming with negative states in an array we need to do something about that I don t recommend using maps neither ordered nor unordered you either get an extra log factor or make your solution susceptible to hacking Instead let s say that the value of where can be a negative number will be stored as in the array where is some constant which is greater than the maximum possible for example in this problem That way all array indices will be non negative Solution complexity 
3,You are given a multiset of powers of two More precisely for each from to exclusive you have elements equal to In one operation you can choose any one element and divide it into two elements You should perform queries Each query has one of two types assign calculate the minimum number of operations you need to make at least elements with value lower or equal to Note that all queries of the second type don t change the multiset that is you just calculate the minimum number of operations you don t perform them ,Several observations Generally we have two types of operations divide and either or If then in one division we ll get element so we can just keep track of the total possible number of these operations as If then if we decide to split whole to s then we get elements but in operations i e in one division we ll get elements So it s preferably to fully split than Also the less the more profitable each division As a result let s act greedy let s say we need more elements Let s iterate over in the increasing order If then let s fully split in in operations decrease increase a counter of operations and increase accordingly If then the situation becomes complicated We can either don t touch and try to use preserved operations with small if or split in two s Now we spent one operation and get two If then we don t need one of and can split further only one If then it s optimal to fully split one of and proceed further with only one and recalculated and In both cases we can solve optimal splitting of recursively in the same manner as Since in each step we lower then we need to check only cases per each query Note that we can treat situation in packs for several with equal so the first part also works in The resulting complexity is per query ,Let s consider a problem without queries of the second type Now we can try to solve the problem using Mo s algorithm Let s maintain array the number of occurrences of on the current segment and array array sorted in descending order Let s take a look at how we should handle adding an element equal to Surely we should increase by but now we should erase an element equal to from the array and insert an element is such a way that the array is still sorted Instead we can increase the leftmost element equal to by Similarly we can handle deleting an element decrease the rightmost element equal to by In order to quickly find the leftmost rightmost element equal to we can store the left and the right bounds of the array where all the numbers are equal to To answer the query of type we should find two elements in the array at distance whose absolute difference is minimal Since the size of the array without zero elements is we can t look at the whole array But using the fact that there are no more than different values in the array we can create an auxiliary array of pairs the value from the array and the number of occurrences of that value In such an array we need to find a subarray where the sum of the second elements in the pairs is at least and the absolute difference between the first elements in the pairs is minimal That can be solved using standard two pointers method in The total complexity of the solution is In fact we can use Mo s algorithm even with updates But its complexity is You can read the editorial of the problem 940F on Codeforces or the following blog to learn about processing updates in Mo https codeforces com blog entry 72690
4,Polycarp grew a tree from vertices We remind you that a tree of vertices is an undirected connected graph of vertices and edges that does not contain cycles He calls a set of vertices if there is such a path in the tree that passes through each vertex of this set without passing through any edge twice The path can visit other vertices not from this set In other words a set of vertices is called if there is a simple path that passes through all the vertices of this set and possibly some other For example for a tree below sets are and are not Polycarp asks you to answer queries Each query is a set of vertices For each query you need to determine whether the corresponding set of vertices is ,Recall that the path in the rooted tree ascends from one end to the least common ancestor of the ends and descends to the other end possibly by 0 Then our set is divided into two simple ways To check this you only need to count We will first calculate the depths as for solving an easy version of the problem We will go along the vertices according to the non growth of the depths if of the deepest vertex and the current one is equal to the current one then it is the ancestor of the deepest one we will mark it Next we will find the deepest unmarked vertex and do the same if there is no such vertex then the whole path goes down and the answer is If there are unmarked vertices then there are vertices outside of those two ascents and the answer is Now we need to check that the two ascents do not intersect or intersect only at the of ends for this we just make sure that is not deeper than the shallowest vertex of the set ,This problem has an easy constructive solution We can find lower and upper bounds on the value of for the given If the given does not belong to this segment then the answer is Otherwise the answer is for any in this segment How to construct it Let s start from the chain The answer for the chain is the upper bound of and it is Then let s try to decrease the answer by in one move Let s take some leaf the vertex without children with the smallest depth that is not and try to move it up The definition of badness will be below To do this let s find such vertex that its depth is less than the depth of by and it has less than children If we found such vertex then let s make the child of and decrease the answer by one If we didn t find such vertex I claim that the vertex has the minimum possible depth it can have and we should not consider it in the future Let s mark this vertex as and continue our algorithm If at some moment we cannot find any not leaf then the answer is Otherwise the answer is Time complexity 
5,Suppose you have a special counter This counter can store some value as a decimal number at first the counter has value The counter performs the following algorithm it prints its lowest digit and after that adds either or to its value So all sequences this counter generates are starting from For example a counter can act as follows it prints and adds to its value so the current value is and the output is it prints and adds to its value so the current value is and the output is it prints and adds to its value so the current value is and the output is it prints and adds to its value so the current value is and the output is it prints and adds to its value so the current value is and the output is This is only one of the possible outputs for example the same counter could generate as the output if we chose to add during each step You wrote down a printed sequence from one of such counters But the sequence was corrupted and several elements from the sequence could be erased Now you d like to recover data you ve lost but you don t even know the type of the counter you used You have a decimal string the remaining data of the sequence For all calculate the minimum number of digits you have to insert in the string to make it a possible output of the counter Note that you can t change the order of digits in string or erase any of them only insertions are allowed ,All you need to know to solve this task is the minimal number of steps to move from any digit to any digit for fixed and let s denote it as Shortest path BFS Floyd Of course you can use it but you can think a little harder and save nerves and time Since order of choosing operations and doesn t matter for transferring from to so only number of s and s are matter Let s denote them as and Since adding any fixed value times are meaningless so Now you can for each for each for each iterate over all possible and Digit you d move to is equal to Just relax value of by Now you can for each and calculate the answer by iterating over string by summing number of inserted values is less by one than number of steps But it will work only in C since the language is fast and basic operations are executed in less than 0 5 second But the model solution is written in Kotlin How is it The string can be long but there are only different neighbouring digits so you can just one time precalculate the number of such that and And calculate the answer not by iterating over but by multiplying by The result complexity is where But will pass on fast languages like C P S There are no real problem with I O both Python and Kotlin read one string up to in less than 0 5 seconds ,To solve this problem we just need to find the first occurrence of the digit let s denote it as Now if then answer is otherwise 
6,You are given a permutation Recall that sequence of integers is called a if it contains all integers from to exactly once Find three indices and such that and Or say that there are no such indices ,A solution in iterate on check that there exists an element lower than to the left of it and check that there exists an element lower than to the right of it Can be optimized to with prefix suffix minima A solution in note that if there is some answer we can find an index such that and if there is no such triple the array descends to some point and ascends after that so there is no answer So we only have to check consecutive triples ,Let s look at our arrays and Note that for any position such that we can always fix it by swapping positions from to In that case contribution from all won t change contribution of pair will decrease and contribution from all won t change again since we swapped all of them It means that we already can use the following algorithm while exists such that just swap all from to This solution works for per test that should be enough But we can optimize our approach by realizing that we can instead of searching each time just go from to and fix pairs one by one if then swap with next if then swap with and so on In such way solution works in 
7,Recently you ve discovered a new shooter They say it has realistic game mechanics Your character has a gun with magazine size equal to and should exterminate waves of monsters The th wave consists of monsters and happens from the th moment of time up to the th moments of time All monsters spawn at moment and you have to exterminate all of them before the moment ends you can kill monsters right at moment For every two consecutive waves the second wave starts not earlier than the first wave ends though the second wave can start at the same moment when the first wave ends formally the condition holds Take a look at the notes for the examples to understand the process better You are confident in yours and your character s skills so you can assume that aiming and shooting are instant and you need exactly one bullet to kill one monster But reloading takes exactly unit of time One of the realistic mechanics is a mechanic of reloading when you reload you throw away the old magazine with all remaining bullets in it That s why constant reloads may cost you excessive amounts of spent bullets You ve taken a liking to this mechanic so now you are wondering what is the minimum possible number of bullets you need to spend both used and thrown to exterminate all waves Note that you don t throw the remaining bullets away after eradicating all monsters and you start with a full magazine ,Note some observations if we meet a new wave and start shooting it s optimal to shoot monsters in the wave using full magazines while we can and there are no reasons to take breaks between shooting monsters from one wave That s why we can track only moments when waves start and the number of remaining bullets in magazine we have at these moments Moreover since the next wave starts not earlier than the previous ends we can think that when we start dealing with one wave we ve already dealt with the previous one Also instead of keeping track of the remaining bullets let s just look only at such indices of waves when we reloaded and threw remaining bullets before reaching them So we can write the next dp is the minimum number of bullets we spend dealing with the first waves and now we standing at the moment with full magazine Obviously Now with fixed we can iterate over the index of a wave before which we ll reload throwing away remaining bullets And for waves we need to check that we are able to exterminate all these waves without throwing away any bullets We can check it with several formulas If it s possible for segment then the possibility for the segment is just checking that we can exterminate the th wave having bullets in the start in no more than reloads plus checking that we have at least one unit before for a reload As a result the time complexity of the solution is ,Note that each unit of damage dealt by explosions save us from using one more basic spell In other words the more the damage from explosions the better So the answer will be equal to Note that in order to kill all remaining monsters with the last spell the array should have the following structure there is a monster we cast the spell onto it and is strictly increasing in and strictly decreasing in ignoring prefix and suffix of s Let s focus on the left part of array segment since solving the right part is exactly the same Maximizing the total damage is equivalent to maximizing the sum of right before the final spell Note that we can use the straight greedy strategy to kill the chosen monster we should use Explosion spell of power exactly it s not optimal to make it either more or less powerful After that monster will create an explosion of power If we must decrease it to exactly to continue the chain of explosions of maximum total damage If we also decrease it to exactly and so on The general formula is This series will stop either if or or there are no monsters left or we met the monster with The two first cases are easy to check in constant time so let s look at the last case Suppose that monster position is equal to then or That monster is interesting to us because after death it creates an explosion of damage that already doesn t depend on and next calculation is practically the same task what chain of explosion we can have if we start from That idea drives us to dp let be the maximum damage of chaining explosion we can deal if we start from and move to the left For simplicity let s include into that total damage Calculating is next let s find the first such that If there are no such or if that is too far from i e we will set Now we know that on interval the damage dealt is the arithmetic progression for it s for it s for it s In total And if such exists and not too far away we increase by as well The last question is finding for each the closest such that Note that if we define we need just need to find last and that s quite standard task that can be solved with stack Let s iterate over and maintain a stack of previous When we need to find for the current let s just look at the top of the stack if we found we wanted otherwise just pop it and check the new top again and so on until either we find or stack becomes empty that would mean that there are no After processing the th element push on top of the stack Why it works Consider some The element on top of the stack is firstly it s but we are talking about general case If we found what we want Otherwise but it also means that previous elements that was popped on previous iteration was greater than So is bigger than as well and there were no need to even consider them i e popping them out earlier doesn t break anything Since each element is pushed in the stack once and popped out once then the complexity is for all for to or amortized The answer for the chosen position then is where is dp we discussed above is the same dp but on reversed array and because we included into both and Both and are calculated in so the total comlpexity is 
8,You are given an array of length The elements of the array are numbered from to You have to process queries to this array In the th query you will be given an integer To process the query you should do the following for every do the following if the th element was already swapped with some other element skip it otherwise swap and after that print the maximum sum over all contiguous subsegments of the array including the empty subsegment For example if the array is and the query is processed as follows the st element wasn t swapped yet so we swap it with the rd element the nd element wasn t swapped yet so we swap it with the th element the rd element was swapped already the th element was swapped already the th element wasn t swapped yet so we swap it with the th element the th element wasn t swapped yet so we swap it with the th element So the array becomes The subsegment with the maximum sum is and the answer to the query is Note that the queries actually i e after a query is performed the array does not return to its original state and the next query will be applied to the modified array ,Let s carefully analyze the operation denoted in the query Since the length of the array is always divisible by every element will be swapped with some other element The elements can be split into two groups the ones whose positions increase by and the ones whose positions decrease by Let s find some trait of the elements which will allow us to distinguish the elements of one group from the elements of the other group The first elements will be shifted to the right the next elements will be shifted to the left the next elements will be shifted to the right etc If we look at the binary representations of integers then we can see that the first elements have in the th bit the next elements have in the th bit the next elements have in the th bit and so on So if we consider the positions of elements as indexed then the operation can be described as follows Let the position of the element be If the th bit in is gets increased by otherwise gets decreased by What does it look like Actually it is just where denotes XOR So each query can be represented as swap with for some integer The combination of two queries can also be represented with a single query in fact the state of the array can be denoted as the XOR of all from the previous queries Now let s try to solve the following problem for every calculate the maximum sum of subsegment if every element is swapped with To solve this problem we can use a segment tree First of all we need to understand how to solve the problem of finding the maximum sum on subsegment using a segment tree To do this we should store the following four values in each vertex of the segment tree the sum of elements on the segment denoted by the vertex the maximum sum of elements on the prefix of the segment denoted by the vertex the maximum sum of elements on the suffix of the segment denoted by the vertex the answer on the segment If some vertex of the segment tree has two children these values for it can be easily calculated using the values from the children So we can glue two segments represented by the vertices together creating a new vertex representing the concatenation of these segments Okay but how do we apply XOR to this For every vertex of the segment tree let s create several versions the th version of the vertex represents the segment corresponding to this vertex if we apply swapping query with to it For a vertex representing the segment of length we can use the following relation to get all its versions here we denote as the th version of and and as the children of if then else The function here denotes the glueing together of two vertices we described above Now let s try to analyze how many versions of each vertex we need For the root we will need all versions For its children we need only versions For the children of the children of the root we need only versions and so on so overall the total number of versions is only and each version can be constructed in so the solution works in ,Alice wants to choose such a segment that is maximum possible There is a well known problem where you have to find a segment with maximum That problem is solved with Kadane algorithm Let s learn how to reduce our problem to that one Notice that the values in the array are unusually small Let s iterate over the maximum value on segment Let be the current value If we make all such that equal to then it will never be optimal to take them in a segment Find the maximum sum subarray in that modified array and update the answer with its Notice that you can ignore the fact if there is a value exactly equal to on the maximum sum segment If there isn t then you ll update the answer with a smaller value than the actual one Let the actual maximum on the maximum sum segment be some You can see that for any value between and the maximum sum segment will always be that chosen one Thus when you reach you ll update the answer with the correct value Overall complexity 
9,Let s call an array if there is an element in the array that equals to the sum of all other elements For example the array is good because there is the element which equals to the sum You are given an array consisting of integers Your task is to print all indices of this array such that after removing the th element from the array it will be let s call such indices For example if the indices are and if you remove the array will look like and it is if you remove the array will look like and it is You have to consider all removals i e remove the element check if the resulting array is and return the element into the array ,The first part calculate the sum of the whole array be careful it can be The second part let s maintain an array of size where will be equal to the number of elements in the given array equals to The third part iterate over the array let the current position be Set make If is even and then the index is otherwise it doesn t And after all make and set ,Suppose If then the answer is because is the overall maximum among all three integers and and it appears in two pairs so it should appear at most twice among and Otherwise the answer exists and it can be and it is easy to see that this triple fits well 
10,You are given a array for each index condition holds and an integer You are asked to divide this array into non empty consecutive subarrays Every element in the array should be included in exactly one subarray Let be equal to the maximum in the th subarray and be equal to the minimum in the th subarray The cost of division is equal to For example if and we divide it into subarrays in the following way then the cost of division is equal to Calculate the minimum cost you can obtain by dividing the array into non empty consecutive subarrays ,Let s carefully look at the coefficients with which the elements of the array will be included in the answer If pair of adjacent elements a i and a i 1 belong to different subarrays then element a i will be included in the answer with coefficient 1 and element a i 1 with coefficient 1 So they add value a i a i 1 to the answer If element belongs to subarray with length 1 then it will be included in the sum with coefficient 0 because it will be included with coefficient 1 and 1 simultaneously Elements at positions 1 and n will be included with coefficients 1 and 1 respectively So initially our answer is a n a 1 All we have to do is consider n 1 values a 1 a 2 a 2 a 3 dots a n 1 a n and add up the k 1 minimal ones to the answer ,The problem is solved by the dynamic programming Let be the answer for the prefix of the array starting at it contains the indices If then Otherwise let s go over the position with which the next good array begins Then we need to select positions among positions which will be elements of the array The number of ways to choose an unordered set of items from of different objects is calculated using the formula Thus the dynamics is as follows The basis of dynamics is the value 
11, There are kids each of them is reading a unique book At the end of any day the th kid will give his book to the th kid in case of the kid will give his book to himself It is guaranteed that all values of are distinct integers from to i e is a permutation The sequence doesn t change from day to day it is fixed For example if and then at the end of the first day the book of the st kid will belong to the th kid the nd kid will belong to the th kid and so on At the end of the second day the book of the st kid will belong to the th kid the nd kid will belong to the th kid and so on Your task is to determine the number of the day the book of the th child is returned back to him for the first time for every from to Consider the following example The book of the st kid will be passed to the following kids after the st day it will belong to the th kid after the nd day it will belong to the rd kid after the rd day it will belong to the nd kid after the th day it will belong to the st kid So after the fourth day the book of the first kid will return to its owner The book of the fourth kid will return to him for the first time after exactly one day You have to answer independent queries ,In this problem we can notice that when we calculate the answer for the kid we also calculate the answer for kids and so on So we can a little bit modify the pseudocode from the easy version to calculate answers faster pos p i ans 1cycle i while pos i cycle append pos ans 1 pos p pos for el in cycle res el ansAnd of course we don t need to run this while for all elements for which we already calculated the answer Total time complexity is because you ll process each element exactly once ,You need to implement what is given in the statement for example you can use an if statement to output if and otherwise 
12,The th grade student Gabriel noticed a caterpillar on a tree when walking around in a forest after the classes The caterpillar was on the height cm from the ground On the height cm on the same tree hung an apple and the caterpillar was crawling to the apple Gabriel is interested when the caterpillar gets the apple He noted that the caterpillar goes up by cm per hour by day and slips down by cm per hour by night In how many days Gabriel should return to the forest to see the caterpillar get the apple You can consider that the day starts at am and finishes at pm Gabriel s classes finish at pm You can consider that Gabriel noticed the caterpillar just after the classes at pm Note that the forest is magic so the caterpillar can slip down under the ground and then lift to the apple ,Let s consider three cases in this case the caterpillar will get the apple on the same day so the answer is The first condition is false and in this case the caterpillar will never get the apple because it can t do that on the first day and after each night it will be lower than one day before If the first two conditions are false easy to see that the answer equals to ,If Nura can buy k gadgets in x days then she can do that in x 1 days So the function of answer is monotonic So we can find the minimal day with binary search Denote lf 0 the left bound of binary search and rg n 1 the right one We will maintain the invariant that in left bound we can t buy k gadgets and in right bound we can do that Denote function f d equals to 1 if we can buy k gadgets in d days and 0 otherwise As usual in binary search we will choose If f d 1 then we should move the right bound rg d and the left bound lf d in other case If binary search found the value lf n 1 then the answer is 1 otherwise the answer is lf Before binary search we can create two arrays of gadgets which are selling for dollars and pounds and sort them Easy to see that we should buy gadgets for dollars on day i d when dollar costs as small as possible and j d when pounds costs as small as possible Let now we want to buy x gadgets for dollars and k x gadgets for pounds Of course we will buy the least cheap of them we already sort the arrays for that Let s iterate over x from 0 to k and maintain the sum of gadgets for dollars s1 and the sum of gadgets for pounds s2 For x 0 we can calculate the sums in O k For other x s we can recalculate the sums in O 1 time from the sums for x 1 by adding gadget for dollars and removing gadget for pounds Complexity O klogn 
13,Consider rows of the seats in a bus rows of the seats on the left and rows of the seats on the right Each row can be filled by two people So the total capacity of the bus is Consider that people occupy the seats in the bus The passengers entering the bus are numbered from to in the order of their entering the bus The pattern of the seat occupation is as below st row left window seat st row right window seat nd row left window seat nd row right window seat th row left window seat th row right window seat After occupying all the window seats for the non window seats are occupied st row left non window seat st row right non window seat th row left non window seat th row right non window seat All the passengers go to a single final destination In the final destination the passengers get off in the given order st row left non window seat st row left window seat st row right non window seat st row right window seat th row left non window seat th row left window seat th row right non window seat th row right window seat You are given the values and Output numbers from to the order in which the passengers will get off the bus ,In this problem you should simply do what was written in the problem statement There are no tricks ,First of all let s rewrite the answer using expectation linearity The expected number of students who read their respective messages is equal to where is a random value which is if the th student reads the message and if the th student doesn t do it Let s analyze the expected value of Suppose Monocarp pins the messages There are three cases if then the th student won t read the message so if and then the th student will definitely read the message so if and then If we iterate on the number of messages we pin we can calculate the sum of for each message considering that we pin it sort all of the messages and pick best of them So we have a solution working in The only thing we need to improve this solution sufficiently is the fact that we don t have to consider the case Since every is not greater than the sum of for a message in the case is the same as this sum of in the case but multiplied by the coefficient and we pick best values their sum multiplied by is not greater than the sum of best values The same holds for and greater 
14,You have two variables and Consider the following sequence of actions performed with these variables If or end the process Otherwise go to step If then set the value of to and repeat step Otherwise go to step If then set the value of to and repeat step Otherwise end the process Initially the values of and are positive integers and so the process will be finite You have to determine the values of and after the process ends ,The answer can be calculated very easy by Euclid algorithm which is described in the problem statement but all subtractions will be replaced by taking by modulo ,Let s look at the slow solution first which will lead us to the full one Let s iterate over the number from to Given a number we want to find a from to such that is divisible by Since must be divisible by the following conclusion can be drawn must be divisible by Let s denote this number as Now our task is to check if there is a multiple of between and The problem can be solved in many ways you can simply consider the largest multiple of that does not exceed it is equal to We compare this number with and if it matches then we have found a suitable pair Now let s note that we do not need to iterate over all the values of because from the number we are only interested in and this is one of the divisors of Even though the product can be large we can still consider all divisors of this number since and themselves are up to Let s find the divisors of and separately then notice that any divisor of is where is some divisor and is some divisor Let s calculate the running time We need to factorize the numbers and into prime factors this can be done in Next you need to iterate over pairs of divisors and Recall the estimate for the number of divisors of a number https oeis org A066150 the number up to has no more than divisors Therefore we can sort through the pairs for We learned how to find the optimal for We get that for each test case we have learned to solve the problem in 
15,In BerSoft programmers work the programmer is characterized by a skill A programmer can be a mentor of a programmer if and only if the skill of the programmer is strictly greater than the skill of the programmer and programmers and are not in a quarrel You are given the skills of each programmers and a list of pairs of the programmers which are in a quarrel pairs are unordered For each programmer find the number of programmers for which the programmer can be a mentor ,Firstly we should sort all programmers in non decreasing order of their skills Also we need to store initially numbers of the programmers we can user array of pairs skill and initial number of the programmer We will iterate through the programmers from the left to the right The current programmer can be a mentor of all programmers to the left of him after sort and with who he are not in a quarrel Let the number of programmers to the left is Subtract from the number of already considered programmers who skill equals to the skill of the current programmer it can be done for example with help of Also lets brute all programmers with who the current programmer in a quarrel we can initially save for each programmer the vector of programmers with who he in a quarell by analogy with the stoe of graphs and if the skill of the current programmer more than the skill of a programmers with which he in a quarrel we should decrease on one because this programmer is to the left of the current after sort and has been counted in We should store by a number of the current programmer the value as answer for him ,The problem can be solved in the following dynamic programming manner Let be the smallest number of hours Ivan can spend in university in the first days while having lessons skipped To calculate it we can store minimal number of hours Ivan is required to spend in the th day so that he attends lessons Then we can iterate over all lengths from to and update with Precalc works in and dp can be processed in 
16,Consider a following game between two players There is an array consisting of positive integers Initially a chip is placed into the first cell of the array and is decreased by Players move in turns Each turn the current player has to do the following if the index of the cell where the chip is currently placed is then he or she has to choose an index such that move the chip to the cell and decrease by If it s impossible to make a valid move the current player loses the game Your task is the following you are given an array consisting of positive integers and queries to it There are two types of queries for every increase by tell who is the winner of the game that is played on the subarray of from index to index inclusive Assume both players choose an optimal strategy ,Suppose there is only one query i e we are given some array and we want to know who is the winner if the game is played on this array One of the obvious solutions is will the current player win if the chip is currently in the cell and the number in cell is We can already see that we don t need to know the exact value of we only want to know whether it s odd if there is a cell such that we can go from to and is a state where current player will lose then we should go to this cell since our opponent will enter a losing state of the game Otherwise we want to force our opponent to move out of cell and we can do so only if is odd So we found a dynamic programming solution with states but what is more important is that we can take all the elements in our array modulo Okay now let s solve the problem when there are only queries of type no modifications Since when calculating the values we are interested only in next cells and there are only variants of whether these cells are winning or losing we may consider each element of the array as a function that maps a mask of next states into a new mask of states if we pushed our new element into the front For example if the th element is even and states are winning losing losing winning and losing respectively and then we may consider a mask of next states as and then we can check if th state is winning and push a bit to the front of this mask discarding the last bit since new state is winning we will get a mask of It allows us to denote two functions and what will be the resulting mask of next states if current mask is and we push an even or odd element to the front Okay what about pushing more than one element We can just take the composition of their functions Since a function can be stored as an array of integers and the composition needs only time to be calculated then we can build a segment tree over the elements of the array and store a composition of all functions on the segment in each node This allows us to answer queries of type in The only thing that s left is additions on segment Adding an even number is easy just ignore this query To be able an odd number let s store another function in each node of the segment tree which would be the composition of all functions on the segment if we would add to all elements on the segment so the elements which were odd become even and vice versa This allows us to use lazy propagation if the query affects the whole node we may just swap two functions in it and push the query to the children of this node Overall complexity is It turns out we didn t think about it before the contest but some contestants submitted such solutions that it can be reduced to if we will use the distance to closest losing state instead of a mask of winning and losing states ,If our friend is the strongest boxer he wins without any bribing Otherwise we have to bribe the strongest boxer and he can defeat some other boxers directly or indirectly Suppose we chose the boxers he will defeat then there is another strongest boxer If our friend is the strongest now we don t need to bribe anyone otherwise we will bribe the strongest remaining boxer again and he can defeat other boxers and so on The only thing that s unclear is which boxers should be defeated by the ones we bribe We may use dynamic programming to bribe them is the minimum cost to bribe boxers so that all boxers among strongest ones are either bribed or defeated by some bribed boxer For each value of we know the maximum amount of boxers that are defeated by bribed boxers so the transitions in this dynamic programming are the following if we can t defeat the next boxer for free our bribed boxers have already defeated as many opponents as they could we have to bribe him otherwise we either bribe him or consider him defeated by some other boxer Overall complexity is 
17,Casimir has a rectangular piece of paper with a checkered field of size Initially all cells of the field are white Let us denote the cell with coordinates vertically and horizontally by The upper left cell will be referred to as and the lower right cell as Casimir draws of different sizes on the field A tick of size with its center in cell is drawn as follows First the center cell is painted black Then exactly cells on the top left diagonally to the center and exactly cells on the top right diagonally to the center are also painted black That is all the cells with coordinates for all between and are painted In particular a tick consists of black cells An already painted cell will remain black if painted again Below you can find an example of the box with two ticks of sizes and You are given a description of a checkered field of size Casimir claims that this field came about after he drew some possibly ticks on it The ticks could be of different sizes but the size of each tick is at least that is for all the ticks Determine whether this field can indeed be obtained by drawing some possibly none ticks of sizes or not ,For each painted cell we will determine whether it can be part of some tick of the allowed size If some of the cells cannot be a part of any tick the answer is obviously Otherwise let s match each colored cell with an arbitrary valid entirely contained in the field under consideration and of size tick containing it Let s draw all such ticks then the following holds no empty white cell of the field will be painted since only ticks that do not contradict the field in question have been considered every colored cell of the field will be covered by at least one drawn tick at least the one we matched it with Basically this process gives us a field in which the set of painted cells matches the data in the input which means that the field given in the input could have been obtained in particular in the way described above and the answer is In order to check that all painted cells are parts of some ticks let s go through all possible ticks of size and for each tick mark all the cells included in it If there is at least one unmarked painted cell in the end it can t be a part of any valid tick and the answer is To consider all possible ticks we can iterate through all their possible center cells that is all the painted cells Since smaller ticks are subsets of larger ticks with the same center cell it is sufficient to find the maximal size tick that can be constructed from that center cell So for each painted cell we aim to find the maximal possible size of a tick with its center in this very cell Let us now consider a painted cell as a possible center of some tick By the definition of a tick this cell can be a center of a tick of size if for all from to both cells and exist are not out of bounds and are painted Let s iterate through from to and stop when the described condition is no longer satisfied The largest for which the condition is still satisfied gives us the maximum possible size of a tick with its center in Now if then such a tick is valid and all the cells included in it should be marked Otherwise it could not have been drawn and none of its cells should be marked After a complete check of all possible ticks in a given field either there will be no unchecked painted cells and then the answer is or at least one painted cell is not covered by any valid checkbox and then the answer is The time complexity is ,At first glance it seems like a graph problem And indeed this problem can be solved by explicitly building a graph considering cells as the vertices and checking that there is a safe path from start to finish via DFS BFS DSU any other graph algorithm or data structure you know But there s a much simpler solution Since there are only two rows in a matrix it s possible to move from any cell in the column to any cell in column if they are both safe of course It means that as long as there is at least one safe cell in each column it is possible to reach any column of the matrix and the cell as well It s easy to see that if this condition is not met there exists a column with two unsafe cells and this also means that this column and columns to the right of it are unreachable So the problem is reduced to checking if there is a column without any unsafe cells To implement this you can read both rows of the matrix as strings let these strings be and and check that there is a position such that both and are equal to 
18,Polycarp is sad New Year is coming in few days but there is still no snow in his city To bring himself New Year mood he decided to decorate his house with some garlands The local store introduced a new service this year called Build your own garland So you can buy some red green and blue lamps provide them and the store workers will solder a single garland of them The resulting garland will have all the lamps you provided put in a line Moreover no pair of lamps of the same color will be adjacent to each other in this garland For example if you provide red green and blue lamps the resulting garland can look like this being the red green and blue color respectively Note that it s ok to have lamps of the same color on the ends of the garland However if you provide say red green and blue lamps then the store workers won t be able to build any garland of them Any garland consisting of these lamps will have at least one pair of lamps of the same color adjacent to each other Note that the store workers should use all the lamps you provided So Polycarp has bought some sets of lamps and now he wants to know if the store workers can build a garland from each of them ,Let r le g le b if it is not the case do some swaps If b r g 1 then at least two blue lamps will be adjacent so there is no solution Otherwise the answer can be easily constucted Place all blue lamps in a row Then place red lamps one between the first and the second blue lamp one between the second and the third and so on Then place all green lamps one between the b 1 th blue lamp and the b th one between the blue lamps with numbers b 2 and b 1 and so on Since r g ge b 1 there is at least one non blue lamp between each pair of blue lamps If g b we didn t place all green lamps we can place the remaining one before all other lamps the same with r b So if we swap l g and b in such a way that r le g le b we only have to check that b le r g 1 ,Let s maintain the current availability of colors and the amounts of cars of each color Firstly color is never available When car of some color goes you check if the number of cars of color past before this one isn t smaller than the number of cars of color Only after that increment the amount by one If it was less then set its availability to false If car of color goes then simply increment its amount In the end iterate over all colors and check if it s both available and has higher or equal amount than the amount of cars of color Okay why this works As all the amounts cannot decrease color will become not available at some moment when car of color goes And this will be encountered either when the new car of color goes or in the end of the sequence Amount of cars of color doesn t update between this periods And if there was point when there became more cars of color than of color then this inequality will hold until the next moment we will check Overall complexity 
19,Monocarp plays Rage of Empires II Definitive Edition a strategic computer game Right now he s planning to attack his opponent in the game but Monocarp s forces cannot enter the opponent s territory since the opponent has built a wall The wall consists of sections aligned in a row The th section initially has durability If durability of some section becomes or less this section is considered broken To attack the opponent Monocarp needs to break at least two sections of the wall any two sections possibly adjacent possibly not To do this he plans to use an onager a special siege weapon The onager can be used to shoot any section of the wall the shot deals damage to the target section and damage to adjacent sections In other words if the onager shoots at the section then the durability of the section decreases by and the durability of the sections and if they exist decreases by each Monocarp can shoot at any sections any number of times Monocarp wants to calculate the minimum number of onager shots needed to break at least two sections Help him ,Let s analyze three cases based on the distance between two sections we are going to break break two neighboring sections and break two sections with another section between them and break two sections with more than one section between them Why exactly these cases Because the damage from the shots and the possibility to hit both sections with the same shot depends on the distance between them If there is more than one section between the two we want to break then any shot hits only one of these sections so each shot should be aimed at one of those sections and we break them independently Let s pick two sections with minimum durability and calculate the number of shots required to break them if these sections are and then the required number of shots is It actually does not matter if the distance between them is less than if it is so these sections will be analyzed in one of the other cases Okay now let s deal with two sections having exactly one section between them We can iterate on all combinations of these sections iterate on from to and pick sections and Let s analyze how can we damage them If we shoot at the section between them we deal damage to both sections if we shoot at one of those sections we deal damage to it and damage to the other section So each shot distributes damage between these two sections the way we want to distribute it and the number of shots required to break these two sections is The case when we try to break two adjacent sections is the trickiest one Let s say that these sections are and and If we target one of these sections we deal damage to it and damage to the other section Let s try to run the following algorithm shoot at the section with higher durability until both of them break It can be slow but we can see that after the first shots the durabilities of the sections become equal and each pair of shots after that deals damage to both sections So we can model the first shots subtract from and from and then we ll need shots The only case when this doesn t work is if we break both sections before we equalize their durabilities it means that and we need to do only shots ,At first let s prove that in optimal solution all spells of 1 st type are assigned to single creature By contradiction let s optimal answer contains indices where and If using spells of 1 st type is meaningless Otherwise if in general case then Contradiction So we can check for each creature maximal damage with its health multiplied At second if we sort all creatures in order by decreasing using spells on first creatures gives best answer So calculating answer for chosen creature invokes 2 cases if chosen creature is belong to first creatures then subtract from its contribution calculate new value and add it to otherwise we need one spell of second type which is optimal to take from th creature so along with replacing old value of chosen one we need to replace in contribution of th creature Result complexity is 
20,You are given a matrix consisting of rows and columns Each cell of the matrix is either free or taken A free cell is reachable from a free cell if at least one of these conditions hold and share a side there exists a free cell such that is reachable from and is reachable from A connected component is a set of free cells of the matrix such that all cells in it are reachable from one another but adding any other free cell to the set violates this rule You are asked queries about the matrix Each query is the following count the number of connected components of the matrix consisting of columns from to of the matrix inclusive Print the answers to all queries ,Consider the naive approach to the problem Cut off the columns directly and count the connected components There are two main solutions to this problem either DFS or BFS or DSU I personally found the DSU method easier to adjust to the full problem So to count connected components with DSU you should do the following Initialize the structure without edges every free cell is its own connected component Then add edges one by one Each edge connects two cells either vertically or horizontally When an edge connects different components they merge and the number of components decreases by one Thus the number of components on a range of columns is the number of free cells on it minus the number of meaningful edges on it the ones that will merge components if the algorithm is performed only on these columns the spanning forest edges Let s try to adjust this algorithm to the full problem It would be great if we could just calculate the spanning forest of the entire matrix and then print the number of free cells minus the number of its edges on the segment Unfortunately it s not as easy as that For components that lie fully in the segment it works However if a component is split by a border of a segment it can both stay connected or fall apart If we determine its outcome we can fix the answer There are probably a lot of ways to adjust for that but I ll tell you the one I found the neatest to code Let s add the edges into DSU in the following order Go column by column left to right First add all vertical edges in any order then all horizontal edges to the previous column in any order If you start this algorithm at the first column you will be able to answer all queries with Since the algorithm adds columns iteratively the spanning forest it s building is correct after every column So the answer for each query is indeed the number of cells minus the number of edges on the range Let s investigate the difference between starting at the first column and an arbitrary column Look at the column If it contains or free cells or that are adjacent then the cells are always in the same component regardless of what has been before column If there are no free cells nothing to the left matters too This tells us that the spanning forest that the first algorithm has built is correct for any queries that start in this The only non trivial case is when only rows and of the th column contain a free cell Then we can t tell if the algorithm is correct or not because these two cells can be in the same component already or not Let s call this a column Imagine you started processing from the leftmost column of the query left to right to the rightmost column Our previous observations tell us that once we encounter a column that is not a the algorithm onwards will be correct Until then we only have some columns to deal with We can add the part from the first non column onwards to the answer the number of cells minus the number of edges And then handle the prefix with some easy casework if the leftmost column is not then add nothing if all columns in the query are then the answer is if the first non column is then add nothing since the s get merged into the component of this column if the first non column is or then add components since neither row nor row is merged anywhere otherwise add component The number of free cells and edges on a segment can be precalculated with some prefix sums The closest non column can also be precalculated with a linear algorithm Overall complexity ,Let s see how the water can flow when it meets the pipe of type or and in the other case When the water meets the pipe of type or we cannot do anything but let it flow to the right of the current cell Otherwise if the current pipe is curved then there are two cases if the pipe on the same position but in the other row is not curved then the answer is because the water has to change the row but we cannot turn the next pipe to allow it to move to the right or to the left So the current pipe is curved and the pipe on the same position in the other row is also curved let s change the row and move to the right it is obvious that we never need to move to the left So the answer and the sequence of pipes is uniquely defined by types of pipes If after iterating over all positions we didn t meet the case of and the current row is second then the answer is 
21,You are given an array of integer numbers Let be the sum of all numbers on positions from to non inclusive th element is counted th element is not counted For indices and holds Indices in array are numbered from For example if then and for each from to Choose the indices of three delimiters and divide the array in such a way that the value of is maximal Note that some of the expressions can correspond to empty segments if for some segment ,Imagine the same task but without the first term in sum As the sum of the array is fixed the best second segment should be the one with the greatest sum This can be solved in with partial sums When recalcing the best segment to end at position you should take minimal prefix sum from to inclusive from the whole sum you want to subtract the lowest number Now let s just iterate over all possible ends of the first segment and solve the task above on the array without this segment Oveall complexity ,Let s take a look at a naive approach at first That approach is greedy Let s find such an interval which starts to the left or at and ends as much to the right as possible Set to its right border Continue until either no interval can be found or is reached The proof basically goes like this Let there be some smaller set of intervals which cover the query these can be sorted by left border obviously their left borders are pairwise distinct Compare that set to the greedy one take a look at the first position where best set s interval has his less than the greedy set s You can see that choosing interval greedily will still allow to have the rest of best set intervals making the greedy choice optimal Let s implement it in For each position from to you can precalculate the index of such an interval that it starts to the left or at this position and ends as much to the right as possible To do this sort all intervals by their left border then iterate over positions while maintaining the maximum right border achieved by intervals starting to the left or at the current position The query is now straightforward Now there are two main ways to optimize it You can do it binary lifting style for each interval or position precalculate the index of the interval taken last after taking intervals greedily and use this data to answer queries in You can also do it path compression style Let s process the queries in the increasing order of their right borders Now do greedy algorithm but for each interval you use remember the index of the last reached interval Now the part with answering queries is in total because each interval will be jumped from no more than once Overall complexity 
22,Consider a grid of size The rows are numbered top to bottom from to the columns are numbered left to right from to The robot is positioned in a cell It can perform two types of moves move one cell down move one cell right The robot is not allowed to move outside the grid You are given a sequence of moves the initial path of the robot This path doesn t lead the robot outside the grid You are allowed to perform an arbitrary number of modifications to it possibly zero With one modification you can duplicate one move in the sequence That is replace a single occurrence of with or a single occurrence of with Count the number of cells such that there exists at least one sequence of modifications that the robot visits this cell on the modified path and doesn t move outside the grid ,First get rid of the corner cases If the string doesn t contain either of the letters the answer is The general solution to the problem is to consider every single way to modify the path then find the union of them Well every single path is too much let s learn to reduce the number of different sequences of modifications that we have to consider The main observation is that all cells that the robot can visit are enclosed in the space formed by the following two paths the first R is duplicated the maximum number of times then the last D is duplicated the maximum number of times the first D is duplicated the maximum number of times then the last R is duplicated the maximum number of times You can realize that by drawing the visited cells for some large test To show that more formally you can consider the visited cells row by row Let s show that for every two different visited cells in the same row all cells in between them can also be visited In general case we want to show that we can take the prefix of the path to the left one of these cells and duplicate any R on it to reach the right cell The suffixes of the paths will remain the same as in the initial path If there exists an R on the prefix then we are good Otherwise the reason that it doesn t exist is that we duplicated D too many times Reduce that and there will be R immediately after reaching the cell or earlier We should also show that the number of R s on the path to the left cell won t reach the maximum allowed amount until reaching the right cell Use the fact that the number of D s on both prefixes of the paths is the same The other non obvious part is that you can t reach cells outside this space However that can also be shown by analyzing each row independently Finally about the way to calculate the area of this space The main idea is to calculate the total number of cells outside this area and subtract it from Notice that non visited cells form two separate parts the one above the first path and the one to the left of the second path These are pretty similar to each other Moreover you can calculate them with a same function If we replace all D s in the string with R and vice versa then these parts swap places So we can calculate the upper part swap them and calculate it again I think the algorithm is best described with a picture Consider test for example First there are some rows that only have one cell visited Then the first R in the string appears Since we duplicate it the maximum amount of times it produces a long row of visited cells The remaining part of the part becomes the outline of the area Note that the row that marks the end of the string always ends at the last column Thus only at most first rows matter To be exact the amount of rows that matter is equal to the number of letters D in the string For each letter D let s calculate the number of non visited cells in a row it goes down to I found the most convenient way is to go over the string backwards We start from the row corresponding to the number of letters D in the string It has zero non visited cells We can maintain the number of non visited cells in the current row If we encounter an R in the string we add to this number If we encounter a D we add the number to the answer We have to stop after the first R in the string The later well earlier since we are going backwards part corresponds to the prefix of letters D the starting column on the picture Each of these rows have visited cell so non visited So we can easily calculate this part as well Overall complexity per testcase ,The only observation we need is that we don t need to jump left at all This only decreases our position so we have less freedom after the jump to the left Then to minimize we only need to jump between the closest cells So if we build the array where is the position of the th cell from left to right indexed then the answer is Time complexity 
23, ants are on a circle of length An ant travels one unit of distance per one unit of time Initially the ant number is located at the position and is facing in the direction which is either or Positions are numbered in counterclockwise order starting from some point Positions of the all ants are distinct All the ants move simultaneously and whenever two ants touch they will both switch their directions Note that it is possible for an ant to move in some direction for a half of a unit of time and in opposite direction for another half of a unit of time Print the positions of the ants after time units ,The first observation if all the ants are indistinguishable we can consider that there are no collisions and all the ants are passing one through another So we can easily determine the final positions of all the ants but we can t say which ant will be in which position The second observation the relative order of the ants will be the same all the time So to solve the problem we should only find the position of one ant after seconds Let s solve that problem in the following way Consider the positions of all the ants after time units Easy to see that by the first observation all the positions of the ants will left the same but the order will be different we will have some cyclic shift of the ants If we find that cyclic shift we can apply it times After that we will have only time units So the problem now is to model the process for the one ant with and time units Note that in that time interval the fixed ant will have no more than two collisions with each other ant So if we model the process with ignoring all collisions except the ones that include the fixed ant we will have no more than collisions Let s model that process with two queues for the ants going to the left and to the right Each time we should take the first ant in the queue with opposite direction process the collision and add that ant to the end of the other queue Hint you will have a problem when the fixed ant can be in two different positions at the end but it s easy to fix with doing the same with the next ant ,This problem has a very easy idea but requires terrible implementation Firstly let s place all platforms as rightmost as we can Thus we will have the array in which the first elements are zeros and other elements are Now let s start the algorithm Firstly we need to jump to the position or less If we could jump to the position then we don t need to jump to some position to the left from But if we cannot do it let s take the leftmost platform to the right from the position and move it in such a way that its left border will be at the position Now we can jump to the position and then jump by right to reach the position Let s repeat the same algorithm and continue jumping If after some move we can jump to the position at least then we are done Time complexity but I m sure it can be implemented in or 
24,There s a chessboard of size rooks are placed on it in such a way that no two rooks occupy the same cell no two rooks attack each other A rook attacks all cells that are in its row or column Is it possible to move rook you can choose which one to move into a different cell so that no two rooks still attack each other A rook can move into any cell in its row or column if no other rook stands on its path ,First note that is always less than or equal to If there were at least rooks on the board at least two of them would share a row or a column by pigeonhole principle If then there is always at least one free row and at least one free column You can move any rook into that row or column Otherwise all rows and columns are taken so any move will make two rooks share a row or a column which is prohibited Thus if then it s Otherwise it s Overall complexity per testcase Alternatively you could check every rook and every possible move Overall complexity per testcase ,I ve seen a lot of data structures solutions for this problem but author s solution doesn t use them and works in Firstly let s change our matrix to a string because it will be easier to work with a string than with a matrix The order of characters will be from top to bottom from left to right i e the outer cycle by columns and the inner by rows Then let s calculate the number of icons on the desktop the number of in Then the answer will be obviously the number of dots on the prefix of of size Now let s deal with queries It can be shown that one query changes our answer by no more than Let be the position of the cell that is being changed in zero indexed Then if there are two cases If is then we have one more icon on our prefix so the answer decreases by one because we filled one empty space in the good desktop Otherwise it increases by one because this icon is outside our prefix Then let s change the corresponding character by the opposite After that we should move our right border accordingly to the new number of icons Note that this border is exclusive If becomes then we will increase the variable But before that if is then there should be an icon and it is not here yet so the answer increases Otherwise our border will decrease Then if is then the answer decreases because there was a place for an icon and now it is not needed anymore Time complexity 
25,Vasya goes to visit his classmate Petya Vasya knows that Petya s apartment number is There is only one entrance in Petya s house and the distribution of apartments is the following the first floor contains apartments every other floor contains apartments each Apartments are numbered starting from one from the first floor I e apartments on the first floor have numbers and apartments on the second floor have numbers from to apartments on the third floor have numbers from to and so on Your task is to find the number of floor on which Petya lives Assume that the house is always high enough to fit at least apartments You have to answer independent test cases ,If then the answer is Otherwise you can remove the first floor and then the answer is ,Consider the naive approach to the problem Cut off the columns directly and count the connected components There are two main solutions to this problem either DFS or BFS or DSU I personally found the DSU method easier to adjust to the full problem So to count connected components with DSU you should do the following Initialize the structure without edges every free cell is its own connected component Then add edges one by one Each edge connects two cells either vertically or horizontally When an edge connects different components they merge and the number of components decreases by one Thus the number of components on a range of columns is the number of free cells on it minus the number of meaningful edges on it the ones that will merge components if the algorithm is performed only on these columns the spanning forest edges Let s try to adjust this algorithm to the full problem It would be great if we could just calculate the spanning forest of the entire matrix and then print the number of free cells minus the number of its edges on the segment Unfortunately it s not as easy as that For components that lie fully in the segment it works However if a component is split by a border of a segment it can both stay connected or fall apart If we determine its outcome we can fix the answer There are probably a lot of ways to adjust for that but I ll tell you the one I found the neatest to code Let s add the edges into DSU in the following order Go column by column left to right First add all vertical edges in any order then all horizontal edges to the previous column in any order If you start this algorithm at the first column you will be able to answer all queries with Since the algorithm adds columns iteratively the spanning forest it s building is correct after every column So the answer for each query is indeed the number of cells minus the number of edges on the range Let s investigate the difference between starting at the first column and an arbitrary column Look at the column If it contains or free cells or that are adjacent then the cells are always in the same component regardless of what has been before column If there are no free cells nothing to the left matters too This tells us that the spanning forest that the first algorithm has built is correct for any queries that start in this The only non trivial case is when only rows and of the th column contain a free cell Then we can t tell if the algorithm is correct or not because these two cells can be in the same component already or not Let s call this a column Imagine you started processing from the leftmost column of the query left to right to the rightmost column Our previous observations tell us that once we encounter a column that is not a the algorithm onwards will be correct Until then we only have some columns to deal with We can add the part from the first non column onwards to the answer the number of cells minus the number of edges And then handle the prefix with some easy casework if the leftmost column is not then add nothing if all columns in the query are then the answer is if the first non column is then add nothing since the s get merged into the component of this column if the first non column is or then add components since neither row nor row is merged anywhere otherwise add component The number of free cells and edges on a segment can be precalculated with some prefix sums The closest non column can also be precalculated with a linear algorithm Overall complexity 
26,A chess tournament will be held soon where chess players will take part Every participant will play one game against every other participant Each game ends in either a win for one player and a loss for another player or a draw for both players Each of the players has their own expectations about the tournament they can be one of two types a player wants not to lose any game i e finish the tournament with a player wants to win at least one game You have to determine if there exists an outcome for all the matches such that all the players meet their expectations If there are several possible outcomes print any of them If there are none report that it s impossible ,Since the chess players of the first type should not lose a single game each game between two chess players of the first type should end in a draw so that none of them gets defeated And a game between a chess player of the first type and the second type should end either with a victory of the first or a draw Therefore for convenience we will say that all games with a chess player of the first type end in a draw Now there are only games between chess players of the second type left If there are only or such players then there is no answer Otherwise we can choose the following method the th chess player of the second type wins against the th chess player of the second type and the last one wins against the first all remaining games are drawn ,It is easier to determine the case when the players with the maximum skills will not meet in the finals It means that they met in the semifinals and in the other semifinals both players are weaker It s easy to check this case with the following formula or 
27,You ve got a job in a game studio that developed an online shooter and your first big task is to help to balance weapons The game has weapons the th gun has an integer fire rate and an integer damage per bullet The th gun s total firepower is equal to You have to modify the values of some guns in such a way that the new values will still be integers and the firepower of all guns will become balanced Given an integer the guns are said to be if Since gamers that play your game don t like big changes you need to change the values for the minimum possible number of guns What is the minimum number of guns for which you have to change these values to make the guns balanced Note that the new values must be integers greater than ,Note that the answer n is always possible for example we can set d i frac prod f j f i then p 1 dots p n prod f j and max p i min p i 0 If the answer is less than n then there is at least one gun id we won t change It means that all other guns firepower should be around p id i e p i p id le k So we can look at segment p id k p id k and for each gun i find what values d i we should set to get into this segment After that we can rephrase our task into the next one we should choose segment l l k subset p id k p id k such that each gun occurs in l l k at least once and the number of corresponding d i that are equal to d i is maximum possible It can be solved with two pointers technique Note that there are at most three interesting values d i we should consider v 1 left lfloor frac p id f i right rfloor v 2 v 1 1 and v 3 d i For each value v j such that v j cdot f i in p id k p id k we can add an event i c j in position v j f i where c j is 1 if v j d i or 0 otherwise Now with two pointers technique we can iterate over all subsegments of length k 1 of segment p id k p id k To get the desired answer we should maintain the number of unique i from events that are present in the subsegment and the sum s of c j from that events Since there is only one c j 1 for each gun i then the sum s of c j we have is equal exactly to the number of guns we change Then we take the maximum mx over sums s of all subsegments where all guns occur and the answer for a fixed p id is n mx Let s iterate over all fixed id and take the minimum from all n mx that will be the answer for the initial task Checking answer for a fixed id involves creating 3 n events and two pointers over segment p id k p id k so it takes O n k time and O n k space So the total complexity is O n 2 n k time and O n k space ,The answer is always Let s understand why it is so Let Then let Bob take the pile with candies and Alice take the pile with candies Then because of we can see that Bob s pile always can reach size of Alice s pile and remaining candies can be divided between them fairly except one candy if is odd 
28,Given an array of length and an integer you are tasked to find any two numbers and such that For each appears in at least times i e or more array elements are equal to The value is maximized If no numbers satisfy the conditions output For example if and then for the first condition fails because does not appear at least times for the first condition holds because occurs at least times in and occurs at least times in for the first condition holds because occurs at least times in A pair of and for which the first condition holds and is maximal is ,Let s call a value if it appears at least times For example if and then good values are So we need to find the longest subarray of this array in which all values are consecutive For example the subarray is the answer because all values are good and the length of the array is longest There are many ways to do this For example we can see when the difference between two elements is more than and then break the array into parts based on that For instance You can also iterate from left to right and keep track of the size of the current array Time complexity ,Firstly let s sort the initial array Then it s obvious that the best way to remove elements is from smallest to biggest And if there is at least one such that and then the answer is because we have no way to remove Otherwise the answer is 
29,You have sticks of the given lengths Your task is to choose exactly four of them in such a way that they can form a rectangle No sticks can be cut to pieces each side of the rectangle must be formed by a single stick No stick can be chosen multiple times It is guaranteed that it is always possible to choose such sticks Let be the area of the rectangle and be the perimeter of the rectangle The chosen rectangle should have the value minimal possible The value is taken without any rounding If there are multiple answers print any of them Each testcase contains several lists of sticks for each of them you are required to solve the problem separately ,Let s work with the formula a bit Let then the formula becomes Considering thus is strictly increasing and has its minimum at So the solution will be to sort the list extract the pairs of sticks of equal length and check only neighbouring pairs in sorted order for the answer Overall complexity ,Firstly let s prove that the size of the answer is not greater than Suppose that the answer equals to Let be coordinates of the points in the answer and Let and Then because of the condition It means that Conditions must hold for a triple too Now it is easy to see that if then that is not a power of two So the size of the answer is not greater than Firstly let s check if the answer is Iterate over all middle elements of the answer and over all powers of two from to inclusively Let be the middle element of the answer and the current power of two Then if there are elements and in the array then the answer is Now check if the answer is Do the same as in the previous solution but now we have left point and right point If we did not find answer of lengths or then print any element of the array The solution above have time complexity because of we can check if the element is in the array with some data structure in 
30,A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters 1 and between the original characters of the sequence For example bracket sequences are regular the resulting expressions are 1 1 1 1 1 and and are not You are given bracket sequences Calculate the number of pairs such that the bracket sequence is a regular bracket sequence Operation means concatenation i e If and are regular bracket sequences and then both pairs and must be counted in the answer Also if is a regular bracket sequence the pair must be counted in the answer ,Let be the mirror reflection of the string For example Let string be good if it does not have a prefix which have more closing brackets than opening ones For example are good and are not The balance of the string is the difference between number of opening and closing brackets in For example 1 0 Let be the number of good strings with a balance The answer to the problem is ,There are just a few general cases in the task to consider If the password is already valid nothing has to be changed just print Try to change exactly one character iterate over all positions in and all three options for character any digit any lowercase or uppercase Latin letter After the replacement the string is checked for the validity and printed if it turned out to be valid We weren t able to replace a substring of length 0 or 1 then the answer is at least 2 We can obtain it in a following manner replace the first two characters to if the third character is an uppercase Latin letter to if the third character is a lowercase Latin letter and to if the third character is a digit 
31,Vlad found two positive numbers and He discovered that where means the bitwise exclusive OR and division is performed without rounding Since it is easier to remember one number than two Vlad remembered only let s denote this number as Help him find any suitable and or tell him that they do not exist ,Consider the answer by bits We know that if the th bit of the number is zero then these bits are the same for and otherwise they differ Then let s first make Note that is already equal to but is not yet So we need to dial another with matching bits we will add them to both integers greedily going from the highest bit to the lowest skipping those bits that are already one in If after this algorithm and do not satisfy the conditions then the answer is In total this solution works for You can see that in the solution above we actually just added to both numbers which could only be done with one set of bits so if the answer exists the pair ,Let s iterate over all pairs of digits in the number Let the first digit in the pair be at position and the second at position Let s place these digits to the last two positions in the number The first greedily goes to the last position and then the second goes to the position next to that Now the number can contain a leading zero Find the leftmost non zero digit and move it to the first position Then if the current number is divisible by try to update the answer with the number of swaps It is easy to show that the number of swaps is minimal in this algorithm The only difference we can introduce is the number of times digit digit and the leftmost non zero digit swap among themselves And that is minimized You can also notice that the order of swaps doesn t matter and you can rearrange them in such a way that no leading zero appears on any step This solution has time complexity You can also solve this problem with complexity because you have to check only four options of the two last digits It is always optimal to choose both rightmost occurrences of the corresponding digits You can show that even if you are required to swap the chosen ones there will be no other pair with smaller total amount of moves 
32,The knight is standing in front of a long and narrow hallway A princess is waiting at the end of it In a hallway there are three doors a red door a green door and a blue door The doors are placed one after another however possibly in a different order To proceed to the next door the knight must first open the door before Each door can be only opened with a key of the corresponding color So three keys a red key a green key and a blue key are also placed somewhere in the hallway To open the door the knight should first pick up the key of its color The knight has a map of the hallway It can be transcribed as a string consisting of six characters denoting red green and blue doors respectively denoting red green and blue keys respectively Each of these six characters appears in the string exactly once The knight is standing at the beginning of the hallway on the left on the map Given a map of the hallway determine if the knight can open all doors and meet the princess at the end of the hallway ,The necessary and sufficient condition is the following for each color the key should appear before the door Necessary is easy to show if there is a key after a door this door can t be opened Sufficient can be shown the following way If there are no closed doors left the knight has reached the princess Otherwise consider the first door the knight encounters He has a key for this door so he opens it We remove both the key and the door from the string and proceed to the case with one less door Overall complexity ,How can we solve this problem Firstly let s sort the initial array but maintain the initial order of the elements in the array to restore the answer Then let s just distribute all the colors Let s color the first element in the first color the second one in the second the th element in the th color the th in the first color and so on So we color the th element in the color is just modulo operation We can see that the answer is if there is an element with frequency at least in the array by pigeonhole principle Otherwise our solution builds the correct answer So we can try to find such element in the array naively using counting sort or many other approaches Time complexity or 
33,String can be called if it consists of characters and and there are no redundant leading zeroes Here are some examples You are given a string You can perform two different operations on this string swap any pair of adjacent characters for example replace with for example Let be such a number that is its binary representation string is less than some other string iff Your task is to find the minimum string that you can obtain from the given one using the operations described above You can use these operations any number of times in any order or even use no operations at all ,If then the answer is equal to Otherwise answer will be equal to where is the count of the zeroes in the given string i e the answer is the binary string of length in which the first character is one and the other characters are zeroes ,Consider case separately and print the sting of zeros or ones correspondingly Now our string has at least one pair or Let s form the pattern of length So all substrings with the sum are satisfied Now let s insert zeros before the first zero in this way we satisfy the substrings with the sum And then just insert ones before the first one in this way we satisfy the substrings with the sum 
34,You are given two integers and You can perform a sequence of operations during the first operation you choose one of these numbers and increase it by during the second operation you choose one of these numbers and increase it by and so on You choose the number of these operations yourself For example if and you can perform the following sequence of three operations add to then and add to then and add to then and Calculate the minimum number of operations required to make and equal ,Assume that Let s denote the minimum number of operations required to make and equal as There are two restrictions on At first because if then will be greater than after applying all operations Secondly integers and must have the same parity because if they have different parity then and will have different parity after applying all operations It turns out that we always can make integers and equal after applying operations It s true because we have to add to and the rest to And we can get any integer from to as a sum of subset of set ,Firstly if the array already has an odd sum the answer is Otherwise we need to change the parity of the sum so we need to change the parity of some number We can do in only when we have at least one even number and at least one odd number Otherwise the answer is 
35,There are heroes fighting in the arena Initially the th hero has health points The fight in the arena takes place in several rounds At the beginning of each round each alive hero deals damage to all other heroes Hits of all heroes occur simultaneously Heroes whose health is less than at the end of the round are considered killed If exactly hero remains alive after a certain round then he is declared the winner Otherwise there is no winner Your task is to calculate the number of ways to choose the initial health points for each hero where so that there is no winner of the fight The number of ways can be very large so print it modulo Two ways are considered different if at least one hero has a different amount of health For example and are different ,Let s calculate the following dynamic programming the number of ways to choose the initial health if there are heroes still alive and they already received damage Let s iterate over the number of heroes that will survive after the next round Then we have to make a transition to the state where the minimum of the maximum allowed health and plus the damage done in this round It remains to understand with what coefficient we should make this transition in dynamic programming This coefficient is equal to the number of ways to choose which of the living heroes will die in this round multiplied by the number of ways to choose health for these heroes because their health is greater than so that they are still alive at the moment but not more than so that they are guaranteed to die in this round Of course we don t make any transitions from the states where since they represent the fights that have already finished The answer is the sum of all for every ,Let s represent spells as points on cartesian plane If we consider three spells and such that and is above on the cartesian plane or belongs to it then we don t need to use spell because we can replace it with a linear combination of spells and without any additional mana cost We can maintain the lower boundary of the convex hull of all points from type queries and the point Then to process type query we have to find the intersection of aforementioned lower boundary and the line our average damage in this fight has to be at least this value If there is no intersection then the answer is because even with infinite mana Vova s character can t deal that much damage before dying If there is an intersection we have to check that it is not higher than the line to ensure that we have enough mana to kill the monster in given time Model solution uses only integral calculations but it seems that precision is enough Time complexity 
36,There s a table of cells rows and columns The value of is even A domino is a figure that consists of two cells having a common side It may be horizontal one of the cells is to the right of the other or vertical one of the cells is above the other You need to place dominoes on the table so that exactly of them are horizontal and all the other dominoes are vertical The dominoes cannot overlap and must fill the whole table ,Suppose and are even A necessary and sufficient condition of existence of the answer is that is even Let s prove the sufficient condition If the count of the horizontal dominoes is even then we can combine them and vertical dominoes to blocks of size the number of the vertical dominoes is even too if is even If and are even we can fill the table with these blocks The description of the locations of the dominoes may be printed as follows consider the table is a chessboard where a cell is a block of two dominoes Consider the leftmost topmost cell of the board is black If a cell of the board is black let s mark one of the dominoes of the block with the letter and the other one with the letter If a cell of the board is white let s mark one of the dominoes of the block with the letter and the other one with the letter There will be no situation that some two cells of the table are marked with one letter but belong to different dominoes Let s prove the necessary condition The number of cells in a column is even so the number of cells that belong to vertical dominoes is even because cells of each vertical domino may be either belong to the column or not belong at the same time So the number of cells that belong to horizontal dominoes is even Let s cross out all cells that belong to vertical dominoes and let s find the leftmost column having cells that haven t been crossed out It s the leftmost column with such cells so the pairwise cells of the non crossed out cells belong to the column to the right of the found one The number of such cells in the right column is equal to the number of found cells so it s even and the number of found horizontal dominoes is even too Let s cross out the found cells and the pairwise cells The number of non crossed out cells in the right column will be even The number of crossed out horizontal dominoes will be even too Let s repeat this procedure until all the dominoes will be crossed out In every step we have crossed out the even number of horizontal dominoes hence the total count of horizontal dominoes is even Suppose is odd hence is even In this case every column contains an odd number of cells whereas the number of cells that belong to vertical dominoes is even So the number of cells that belong to horizontal dominoes is odd Consider the leftmost column and find a cell of it that belongs to a horizontal domino it must be found because the number of such cells is odd so it isn t equal to Let s find the pairwise cell and cross out both cells Currently the two columns will have an even number of non crossed out cells Let s repeat the procedure until all columns will have even non crossed out cells We will cross out cells and dominoes So the necessary condition is that the number of horizontal dominoes is at least Let s extend the necessary condition with the following condition the value of is even Consider the table that we ve become after the previous procedure where each column has exactly one crossed out cell Let s start the procedure we ve done in the case of even both and The procedure can be started on our table because each column of the table has an even number of non crossed out cells As a result of the procedure we will cross out an even count of horizontal dominoes so the value of is even Let s build an answer if the conditions and is even are met Let s place in the topmost row horizontal dominoes and mark their cells as follows the first domino will be marked with the second one with the third one with and so on As the result the region of rows and columns will be unfilled Both values are even and the value of is even too So let s fill the region as if it s a separate table having even numbers of rows and columns As it was proved above it s possible to do The set of letters used for the region and set of the letters used for the topmost row don t have common elements so there will be no cells that are marked with one letter but belong to different dominoes The case of odd hence is even is similar to the previous one let s transpose the table it will have rows and columns swap the values of and solve the case above and transpose the table back to have rows and columns , which can be proved by induction If the partition exists it has the form since the area of the rectangle with another partition will be greater than We will cut the rectangles in the order Denote the coordinates of the colored cell at the step as If and then there is no partition since the square at any location overlaps the colored cell Cut off the square from the right or left edge depending on the location of the colored cell that is or Suppose that it was advantageous to cut it not from the edge then it is necessary to cut the rectangles and where using the set Then will not enter the partition but so We came to a contradiction 
37,There are teleporters on a straight line located in points It s possible to teleport from point to point if there are teleporters in of those points and it costs energy You want to install some additional teleporters so that it is possible to get from the point to the point possibly through some other teleporters spending than energy in total Each teleporter you install must be located in an What is the minimum number of teleporters you have to install ,Initial portals divide the path from to into separate sections If we place a new portal between two given ones it only affects the section between these two portals Let s suppose we want to place new portals into a section of length This will divide it into sections and it s quite easy to prove that these sections should be roughly equal in size to prove it we can show that if the sizes of two sections differ by more than the longer one can be shortened and the shorter one can be elongated so the sum of squares of their lengths decreases So a section of length should be divided into sections of length and sections of length Let s denote the total energy cost of a section of length divided by new portals as since we divide it in roughly equal parts it s easy to see thatThe key observation that we need to make now is that i e if we add more portals to the same section the energy cost change from adding a new portal doesn t go up Unfortunately we can t give a simple strict proof of this fact but we have faith and stress this would be easy to prove if it was possible to place portals in non integer points we could just analyze the derivative but in integer case it s way more difficult Okay what should we do with the fact that for a section of length The main idea of the solution is binary search over the value of i e we use binary search to find the minimum possible change that a new portal would give us Let s say that we want to check that using the portals that give the cost change is enough then for each section we want to find the number of new portals such that but we can use another binary search to do that For a fixed integer we can calculate not only the number of new portals that we can add if the cost change for each portal should be at least but also the total cost of the path after these changes let s denote as the total cost of the path if we place new portals until the cost change is less than and is the number of portals we will place in that case We have to find the minimum value of such that Now it looks like is the answer but this solution gives WA on one of the sample tests The key observation we are missing is that for the value we don t have to add all of the portals that change the answer by we might need only some of them To calculate the answer let s compute four values If we place portals and add new portals one by one until the total cost becomes not greater than the cost change from each new portal will be equal to or just if we consider the fact that we start using the portals which change the cost by So we can easily calculate how many more additional portals we need to add if we start from portals and cost The total complexity of our solution is we have a binary search over the cost change for each new portal and for a fixed cost change to determine the number of portals we place in each section we run another binary search in every section separately ,Note that all are positive which means that the amount on the prefix only increases This allows us to use binary search to find the answer for the vertex It remains only to learn how to quickly find the sum of on the path prefix Let s run a depth first search and store the prefix sums of the current path in stack going to the vertex add the sum to the end of the path and delete it when exiting 
38,You are playing yet another game where you kill monsters using magic spells There are cells in the row numbered from to Initially the th cell contains the th monster with health You have a basic spell that costs MP and deals damage to the monster you choose You can cast it any number of times Also you have a special scroll with Explosion spell you can use only once You want to finish killing monsters with explosion that s why you firstly cast the basic spell several times possibly zero and then after that you cast one Explosion How does Explosion spell work Firstly you choose the power of the spell if you pour MP into it Explosion will deal damage Secondly you choose some monster which will be targeted by the spell That s what happens next if its health then he stays alive with health decreased by if the th monster dies with an explosion that deals damage to monsters in the neighboring cells and if these cells exist and monsters inside are still alive if the damage dealt by the explosion is enough to kill the monster or i e the current or then that monster also dies creating a secondary explosion of power or that may deals damage to their neighbors and so on until the explosions end Your goal is to kill all the remaining monsters with those chaining explosions that s why you need a basic spell to decrease of some monsters or even kill them beforehand monsters die when their current health becomes less or equal to zero Note that monsters don t move between cells so for example monsters and will never become neighbors What is the minimum total MP you need to kill all monsters in the way you want The total MP is counted as the sum of the number of basic spells you cast and the power of explosion scroll you ve chosen ,Note that each unit of damage dealt by explosions save us from using one more basic spell In other words the more the damage from explosions the better So the answer will be equal to Note that in order to kill all remaining monsters with the last spell the array should have the following structure there is a monster we cast the spell onto it and is strictly increasing in and strictly decreasing in ignoring prefix and suffix of s Let s focus on the left part of array segment since solving the right part is exactly the same Maximizing the total damage is equivalent to maximizing the sum of right before the final spell Note that we can use the straight greedy strategy to kill the chosen monster we should use Explosion spell of power exactly it s not optimal to make it either more or less powerful After that monster will create an explosion of power If we must decrease it to exactly to continue the chain of explosions of maximum total damage If we also decrease it to exactly and so on The general formula is This series will stop either if or or there are no monsters left or we met the monster with The two first cases are easy to check in constant time so let s look at the last case Suppose that monster position is equal to then or That monster is interesting to us because after death it creates an explosion of damage that already doesn t depend on and next calculation is practically the same task what chain of explosion we can have if we start from That idea drives us to dp let be the maximum damage of chaining explosion we can deal if we start from and move to the left For simplicity let s include into that total damage Calculating is next let s find the first such that If there are no such or if that is too far from i e we will set Now we know that on interval the damage dealt is the arithmetic progression for it s for it s for it s In total And if such exists and not too far away we increase by as well The last question is finding for each the closest such that Note that if we define we need just need to find last and that s quite standard task that can be solved with stack Let s iterate over and maintain a stack of previous When we need to find for the current let s just look at the top of the stack if we found we wanted otherwise just pop it and check the new top again and so on until either we find or stack becomes empty that would mean that there are no After processing the th element push on top of the stack Why it works Consider some The element on top of the stack is firstly it s but we are talking about general case If we found what we want Otherwise but it also means that previous elements that was popped on previous iteration was greater than So is bigger than as well and there were no need to even consider them i e popping them out earlier doesn t break anything Since each element is pushed in the stack once and popped out once then the complexity is for all for to or amortized The answer for the chosen position then is where is dp we discussed above is the same dp but on reversed array and because we included into both and Both and are calculated in so the total comlpexity is ,Let s consider two cases If then the answer is because we can make opposite moves to the Slavik s moves and it always will reduce durability of some door so at some point we will reach the state when all doors will have durability Otherwise and we have to realize the optimal strategy for us If we have some door with durability then let s break it immediately why shouldn t we do this If we don t do it then Slavik will repair this door during his move So what Slavik will do now He will repair some door Which door he has to repair Of course the one with durability because otherwise we will break it during our next move So we can realize that doors with durability are not interesting for us because Slavik will make opposite moves to our moves And what is the answer if the number of doors with durability equals to It is 
39,Vasya has two arrays and of lengths and respectively He can perform the following operation arbitrary number of times possibly zero he takes some consecutive subsegment of the array and replaces it with a single element equal to the sum of all elements on this subsegment For example from the array Vasya can obtain array and from array Vasya can obtain array Two arrays and are considered equal if and only if they have the same length and for each valid Vasya wants to perform some of these operations on array some on array in such a way that arrays and become equal Moreover the lengths of the resulting arrays should be maximal possible Help Vasya to determine the maximum length of the arrays that he can achieve or output that it is impossible to make arrays and equal ,Let s prove that next greedy solution works each step we will find prefixes of minimal length of arrays such that its sums are equal and we will cut them forming next block If we will get valid partition in result so it is an optimal solution otherwise there is no solution Since length of prefix proportional to its sum so prefixes are minimal since its sums are minimal Let s prove this algorithm let optimal solution have alternative partition Since our solution cuts minimal possible prefixes so at some step optimal solution cuts prefix with greater sum and greater length But this prefixes in optimal solutions contain smaller prefixes found by greedy solution so it can be divided on two parts contradiction So we can keep prefixes and increase one which have smaller sum Result complexity is ,This task can be done by one array traversal Maintain current minimum value position of the last occurrence of current minumum distance between two occurrences of Now for each if then do For do In the end will be the global minimum of array and will keep the closest its occurrences Overall complexity 
40,You are given a set of integer points on a Cartesian plane Points are numbered from to inclusive Let be the th point The coordinate of the point equals The coordinate of the point equals zero initially Thus initially The given points are vertices of a plot of a piecewise function The th piece of the function is the segment In one move you can increase the coordinate of any point with odd coordinate i e such points are by Note that the corresponding segments also change For example the following plot shows a function for i e number of points is in which we increased the coordinate of the point three times and coordinate of the point one time Let the area of the plot be the area below this plot and above the coordinate axis OX For example the area of the plot on the picture above is 4 the light blue area on the picture above is the area of the plot drawn on it Let the height of the plot be the maximum coordinate among all initial points in the plot i e points The height of the plot on the picture above is 3 Your problem is to say which minimum possible height can have the plot consisting of vertices and having an area equal to Note that it is unnecessary to minimize the number of moves It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding ,It is easy to see that the area of the plot is the sum of areas of all triangles in this plot Each move increases area by one We cannot obtain the answer less than but we always can obtain such an answer ,This is easy dynamic programming problem It is easy to understand that we don t need to go down at all otherwise your solution will be Dijkstra s algorithm not dynamic programming Let be the minimum required time to reach the floor if we not in the elevator right now and be the minimum required time to reach the floor if we in the elevator right now Initially all values are except and Transitions are pretty easy we was not in the elevator and going to the next floor using stairs we was in the elevator and going to the next floor using stairs we was not in the elevator and going to the next floor using elevator we was in the elevator and going to the next floor using elevator The answer for the th floor is Time complexity 
41,Let s denote the Manhattan distance between two points with coordinates and with coordinates as For example the distance between two points with coordinates and is You are given two points and The point has coordinates the point has coordinates Your goal is to find a point such that both coordinates of are non negative integers without any rounding without any rounding Find any point that meets these constraints or report that no such point exists ,There is a solution in but in fact a solution that checks all points with coordinate from to and coordinate from to is fast enough There s no need to check any other points since implies that point is on one of the shortest paths between and ,Notice that the square covers the point if and only if Using this fact let s reformulate the problem the following way we have to find the segment such that the sum of the segments fully covered by it is maximal Let s build a segment tree the th of its leaves stores the sum of the segments covered by the segment Initially it s built for some such that it is to the right of all segments Other nodes store the maximum in them Now let s iterate over the values of in descending order Let there be some segment starting in with the cost All the answers for won t change because they don t cover that new segment And the values on the suffix from the position will increase by The only thing left is to learn how to handle the subtraction of the length of the side That term is and the thing we are looking for is Rewrite it in form and you ll see that you can just subtract from the value of the th leaf of the segment tree at the beginning to get the correct result Surely you ll need to add that after you ask the maximum of all the segtree to obtain the answer You ll probably need to compress the coordinates leave only such positions that there is at least one or Implicit segtree might work but neither ML nor TL are not friendly to it Also be careful with the case with all points being negative 
42,Your friend Ivan asked you to help him rearrange his desktop The desktop can be represented as a rectangle matrix of size consisting of characters empty cell of the desktop and an icon The desktop is called if all its icons are occupying some prefix of full columns and possibly the prefix of the next column and there are no icons outside this figure In other words some amount of first columns will be filled with icons and possibly some amount of first cells of the next after the last full column column will be also filled with icons and all the icons on the desktop belong to this figure This is pretty much the same as the real life icons arrangement In one move you can take one icon and move it to any empty cell in the desktop Ivan loves to add some icons to his desktop and remove them from it so he is asking you to answer queries what is the number of moves required to make the desktop after adding removing one icon Note that and change the state of the desktop ,I ve seen a lot of data structures solutions for this problem but author s solution doesn t use them and works in Firstly let s change our matrix to a string because it will be easier to work with a string than with a matrix The order of characters will be from top to bottom from left to right i e the outer cycle by columns and the inner by rows Then let s calculate the number of icons on the desktop the number of in Then the answer will be obviously the number of dots on the prefix of of size Now let s deal with queries It can be shown that one query changes our answer by no more than Let be the position of the cell that is being changed in zero indexed Then if there are two cases If is then we have one more icon on our prefix so the answer decreases by one because we filled one empty space in the good desktop Otherwise it increases by one because this icon is outside our prefix Then let s change the corresponding character by the opposite After that we should move our right border accordingly to the new number of icons Note that this border is exclusive If becomes then we will increase the variable But before that if is then there should be an icon and it is not here yet so the answer increases Otherwise our border will decrease Then if is then the answer decreases because there was a place for an icon and now it is not needed anymore Time complexity ,Let s see how the water can flow when it meets the pipe of type or and in the other case When the water meets the pipe of type or we cannot do anything but let it flow to the right of the current cell Otherwise if the current pipe is curved then there are two cases if the pipe on the same position but in the other row is not curved then the answer is because the water has to change the row but we cannot turn the next pipe to allow it to move to the right or to the left So the current pipe is curved and the pipe on the same position in the other row is also curved let s change the row and move to the right it is obvious that we never need to move to the left So the answer and the sequence of pipes is uniquely defined by types of pipes If after iterating over all positions we didn t meet the case of and the current row is second then the answer is 
43,You are given a forest an undirected graph with vertices such that each its connected component is a tree The diameter aka longest shortest path of a connected undirected graph is the maximum number of edges in the path between any pair of its vertices You task is to add some edges possibly zero to the graph so that it becomes a tree and the diameter of the tree is minimal possible If there are multiple correct answers print any of them ,Let s start with the solution and then proceed to the proof For each tree in a forest find such a vertex that the maximal distance from it to any vertex is minimal possible a center of a tree Tree may include two centers take any of them in that case Find the the tree with the maximum diameter Connect the centers of other trees with its center Overall complexity is the complexity of looking for a diameter or The center is the best vertex in a tree to connect to The diameter of merging two trees and by in and in with being the maximum shortest path from to any other vertex in being the same for in is Thus minimizing both and will produce the best result The most optimal structure is a star The center tree will be connected directly to any other tree The other trees will be connected through a single vertex among each other which leads to the answer no more than 1 worse than connecting them directly And building the answer the other way will exceed this difference as some tree will be connected to the center tree of the star through one vertex as well The previous fact implies that the center tree of the star should have the maximal diameter among all trees ,Let s start by choosing a vertex naively Iterate over all vertices and try each of them Root the tree by and observe what the conditions become for each is just the depth of each vertex Well then the only case when the connected subgraph of vertices of the same color has all values of distinct is when they form a vertical path in the tree So the problem becomes the following Split the tree into some vertical paths in such a way that the shortest path is as long as possible Let s try greedy I guess Start the paths from the leaves and propagate them up Consider some vertex with at least two children All children have some paths leading up to them We d love to continue them all with but we can t do that We can only continue one path and cut the rest Pretty easy to see that the path to continue is the shortest path available It s at least as optimal as any other path Do that from the lowest vertices up and you got yourself a working greedy Also don t forget to stop all paths in root since you can t continue any of them further up Let s make this greedy more formal Every time we update the answer is with a path that is the shortest in every vertex lower than the current one not the shortest in the current one So we want to propagate the shortest child up and update the answer with the remaining children Updating the answer means just taking the minimum of values Thus we can actually ignore all children except the second shortest in each vertex Just don t forget to treat the root properly Now we can actually solve the problem in for a fixed You can just find two minimums in each vertex Well now that we can solve the problem for a single root let s try rerooting to solve for all of them There are solutions in but I found the solution in the neatest The constraints are low enough to allow it For each vertex maintain a multiset of lengths of vertical paths from its children I chose to store nothing in the leaves that only makes the implementation cleaner In order to update the vertex from its child you can take the minimum element in the child s set and add to it If it s empty the child is a leaf return Additionally store a multiset of the second minimums of all vertices that have at least two children In order to update the answer with the current root find the minimum of that multiset and the shortest path from the root To achieve you will probably have to either store prefix and suffix second minimums over children of each vertex or store three shortest paths in it It is kind of messy but it should still perform better Overall complexity or per testcase 
44,You are given an array consisting of integers it is guaranteed that is even i e divisible by All does not exceed some integer Your task is to replace the number of elements replacement is the following operation choose some index from to and replace with some integer in range to satisfy the following conditions after all replacements all are positive integers not greater than for all from to the following equation is true where should be for all pairs of elements You have to answer independent test cases ,It is obvious that if we fix the value of x then there are three cases for the pair of elements We don t need to change anything in this pair we can replace one element to fix this pair we need to replace both elements to fix this pair The first part can be calculated easily in O n k we just need to create the array of frequencies cnt where cnt x is the number of such pairs a i a n i 1 that a i a n i 1 x The second part is a bit tricky but still doable in O n k For each pair let s understand the minimum and the maximum sum we can obtain using at most one replacement For the i th pair all such sums belong to the segment min a i a n i 1 1 max a i a n i 1 k Let s make 1 on this segment using prefix sums make 1 in the left border 1 in the right border plus one and then just compute prefix sums on this array Let this array be pref Then the value pref x tells the number of such pairs that we need to replace element in this pair to make it sum equals x And the last part can be calculated as frac n 2 pref x So for the sum x the answer is pref x cnt x frac n 2 pref x cdot 2 We just need to take the minimum such value among all possible sums from 2 to 2k There is another one solution that uses scanline not depends on k and works in O n log n but it has no cool ideas to explain it here anyway the main idea is almost the same as in the solution above ,Let s consider a problem without queries of the second type Now we can try to solve the problem using Mo s algorithm Let s maintain array the number of occurrences of on the current segment and array array sorted in descending order Let s take a look at how we should handle adding an element equal to Surely we should increase by but now we should erase an element equal to from the array and insert an element is such a way that the array is still sorted Instead we can increase the leftmost element equal to by Similarly we can handle deleting an element decrease the rightmost element equal to by In order to quickly find the leftmost rightmost element equal to we can store the left and the right bounds of the array where all the numbers are equal to To answer the query of type we should find two elements in the array at distance whose absolute difference is minimal Since the size of the array without zero elements is we can t look at the whole array But using the fact that there are no more than different values in the array we can create an auxiliary array of pairs the value from the array and the number of occurrences of that value In such an array we need to find a subarray where the sum of the second elements in the pairs is at least and the absolute difference between the first elements in the pairs is minimal That can be solved using standard two pointers method in The total complexity of the solution is In fact we can use Mo s algorithm even with updates But its complexity is You can read the editorial of the problem 940F on Codeforces or the following blog to learn about processing updates in Mo https codeforces com blog entry 72690
45,A bracket sequence is a string containing only characters and A regular bracket sequence or shortly an RBS is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and bracket sequences and are not Let s denote the concatenation of two strings and as For example You are given bracket sequences You can rearrange them in any order you can rearrange only the strings themselves but not the characters in them Your task is to rearrange the strings in such a way that the string has as many non empty prefixes that are RBS as possible ,The constraint is a clear hint that we need some exponential solution Of course we cannot try all permutations Let s instead try to design a solution with bitmask dynamic programming A string is an RBS if its balance the difference between the number of opening and closing brackets is and the balance of its each prefix is non negative So let s introduce the following dynamic programming is the greatest number of RBS prefixes of a string if we considered a mask of strings the current balance of the prefix is and is a flag that denotes whether there already has been a prefix with negative balance We can already get rid of one of the states the current balance is uniquely determined by the mask So this dynamic programming will have states To perform transitions we need to find a way to recalculate the value of and the answer if we append a new string at the end of the current one Unfortunately it s too slow to simply simulate the process Instead for every string let s precalculate the value how does the flag and the answer change if the current flag is and the current balance is The resulting flag will be in one of the following two cases it is already the string we append creates a new prefix with non positive balance The second case can be checked as follows let s precalculate the minimum balance of a prefix of let it be If the flag will be Calculating how the answer changes is a bit trickier If the current flag is already the answer doesn t change But if it is the answer will increase by the number of new RBS prefixes If the balance before adding the string is then we get a new RBS prefix for every prefix of such that its balance is exactly to compensate the balance we already have there is no prefix with balance in before this prefix To quickly get the number of prefixes meeting these constraints we can create a data structure that stores the following information for every balance store a sorted vector of positions in with balance equal to Then to calculate the number of prefixes meeting the constraints we can find the first position in with balance equal to by looking at the beginning of the vector for and then get the number of elements less than this one from the vector for balance by binary search These optimizations yield a solution in although it s possible to improve to if you precalculate each value of for every string ,I m almost sure this problem can be solved faster and with greater constraints but this version is fine for the last problem Consider both strings indexed and let s do the dynamic programming It means the maximum number of occurrences of if we considered first characters of did moves and the number of characters is The answer to the problem is Initially all states are and is What about transitions There are essentially three types of them don t change the current character change the current character to and change the current character to Let s create three additional variables to make our life easier if that were true is if and otherwise is if and otherwise and is if and otherwise Now let s make and describe our transitions Don t change the th character The expression is just ternary if statement if is true return otherwise return So the number of characters increases if equals and the answer increases if the th character equals because we added all occurrences that end in the th character Change the th character to possible only when The number of characters always increases and the answer increases if equals by the same reason as in the previous transition Change the th character to possible only when The number of characters increases only if and the answer always increases Note that we always increase the number of moves in the second and the third transitions even when equals or because this case is handled in the first transition so we don t care Time complexity There are also some greedy approaches which work in with pretty small constant and can be optimized even further 
46,A rectangle with its opposite corners in and and sides parallel to the axes is drawn on a plane You are given a list of lattice points such that each point lies on a side of a rectangle but not in its corner Also there are at least two points on every side of a rectangle Your task is to choose three points in such a way that exactly two of them belong to the same side of a rectangle the area of a triangle formed by them is maximum possible Print the doubled area of this triangle It can be shown that the doubled area of any triangle formed by lattice points is always an integer ,The area of a triangle is equal to its base multiplied by its height divided by Let the two points that have to be on the same side of a rectangle form its base To maximize it let s choose such two points that are the most apart from each other the first and the last in the list Then the height will be determined by the distance from that side to the remaining point Since there are points on all sides the points on the opposite side are the furthest Thus the height is always one of or depending on whether we picked the horizontal or the vertical side So we have to check four options to pick the side and choose the best answer among them ,Firstly note that if we want to buy as many packs as possible then it s optimal to buy the cheapest packs In other words if we sort all packs we ll always buy a prefix of array Next note that each day we buy some number of packs so instead of iterating through the days we can iterate through the number of packs and for each calculate the number of days we ll buy exactly packs Since the prices increasing and at day the price is then exists last day such that as days we could buy packs and at days we can t And we can find as maximum possible integer solution to inequation or We can calculate all using prefix sums in linear time As a result we buy packs in days in total packs in days in total packs in days in total and so on The resulting complexity is because of sort 
47,Polycarp is wondering about buying a new computer which costs tugriks To do this he wants to get a job as a programmer in a big company There are positions in Polycarp s company numbered starting from one An employee in position earns tugriks every day The higher the position number the more tugriks the employee receives Initially Polycarp gets a position with the number and has tugriks Each day Polycarp can do one of two things If Polycarp is in the position of then he can earn tugriks If Polycarp is in the position of and has at least tugriks then he can spend tugriks on an online course and move to the position For example if then Polycarp can act like this On the first day Polycarp is in the st position and earns tugrik Now he has tugrik On the second day Polycarp is in the st position and move to the nd position Now he has tugriks On the third day Polycarp is in the nd position and earns tugriks Now he has tugriks On the fourth day Polycarp is in the nd position and is transferred to the rd position Now he has tugriks On the fifth day Polycarp is in the rd position and earns tugriks Now he has tugriks On the sixth day Polycarp is in the rd position and earns tugriks Now he has tugriks Six days later Polycarp can buy himself a new computer Find the minimum number of days after which Polycarp will be able to buy himself a new computer ,Since the array a does not decrease if we want to get the position x at some point it is best to get it as early as possible because if we get it earlier we will earn no less money Therefore the solution looks like this rise to some position and earn money on it for a laptop Let s go through the number of the position and use simple formulas to calculate the number of days it takes to raise to this position and the number of days it takes to buy a laptop From all the options choose the minimum one ,Despite the fact that statement sounds like some dp or flow the actual solution is pretty greedy Let s iterate over all minutes Adilbek has to water at and maintain the cheapest liters he can obtain to this minute Let this be some structure which stores data in form price for 1 liter total volume Adilbek can buy for this price Pairs will be sorted by the price of a liter The most convenient structure for that might be a C map for example When moving to the next minute pop the cheapest liter out of this structure and add it to the answer If that minute some friend comes then push his water to the structure if the total updated volume in the structure is greater than then pop the most expensive left overs out of it so that the structure holds no more than liters total That prevents out solution to fill the watering system over its capacity The main idea for why this greedy strategy works is that it s never optimal to take not the cheapest liter because a liter of that price or cheaper will still be available in the future minutes Note that between each pairs of adjacent coming friends basically nothing happens Thus you can find the time between them and pop that number of cheapest liters right away instead of iterating minute by minute Overall complexity per query 
48,You are given three strings and consisting of lowercase Latin letters You may perform any number possibly zero operations on these strings During each operation you choose any character from erase it from and insert it into string you may insert this character anywhere you want in the beginning of in the end or between any two consecutive characters For example if is and is then the following outcomes are possible the character we erase from and insert into is highlighted Your goal is to perform several maybe zero operations so that becomes equal to Please determine whether it is possible Note that you have to answer independent queries ,If the answer exists then each element of string matches with some element of string Thereby string must be a subsequence of string Let equal to the number of occurrences of the letter in the string Then for any letter condition must be hold So the answer to the query is if following conditions hold string is subsequence of string for any Latin latter ,Let s analyze when the string is good Suppose it is The cyclic shifts of this string are and We get the following constraints for a good string If the string has odd length then all characters should be equal to each other otherwise all characters on odd positions should be equal and all characters on even positions should be equal Now since there are only different types of characters we can brute force all possible combinations of the first and the second character of the string we want to obtain there are only of them and for each combination greedily construct the longest possible subsequence of beginning with those characters in 
49,You are given a permutation of length Recall that the permutation is an array consisting of distinct integers from to in arbitrary order For example is a permutation but is not a permutation appears twice in the array and is also not a permutation but there is in the array You can perform at most operations with the given permutation it is possible that you don t perform any operations at all The th operation allows you to swap elements of the given permutation on positions and The operations can be performed in arbitrary order Your task is to find the lexicographically minimum possible permutation obtained by performing some of the given operations in some order You can see the definition of the lexicographical order in the notes section You have to answer independent test cases For example let s consider the permutation The minimum possible permutation we can obtain is and we can do it in the following way perform the second operation swap the second and the third elements and obtain the permutation perform the fourth operation swap the fourth and the fifth elements and obtain the permutation perform the third operation swap the third and the fourth elements and obtain the permutation perform the first operation swap the first and the second elements and obtain the permutation Another example is The minimum possible permutation we can obtain is by performing the third operation swap the third and the fourth elements ,The following greedy solution works let s take the minimum element and move it to the leftmost position we can With this algorithm all forbidden operations are form the prefix of operations and so on So we can carry the position of the leftmost operation we can perform Initially it is We repeat the algorithm until Let s find the position of the minimum element among elements Let this position be If then let s increase and continue the algorithm Otherwise we need to move the element from the position to the position and then set Time complexity ,Let s consider some subsequence with the length the empty subsequences we will count separately by adding the valye at the end and count the number of sequences that contains it We should do that accurately to not count the same sequence multiple times Let be the fixed subsequence In the original sequence before the element can be some other elements but none of them can be equal to because we want to count the subsequence exactly one time So we have variants for each of the elements before Similarly between elements and can be other elements and we have choices for each of them And so on After the element can be some elements suppose there are such elements with no additional constraints so we have choices for each of them We fixed the number of elements at the end so we should distribute numbers between numbers before between and ldots between and Easy to see that we have choices to do that it s simply binomial coefficient with allowed repititions The number of sequences equals to So the answer is Easy to transform the last sum to the sum Note the last inner sum can be calculating using the formula for parallel summing So the answer equals to Also we can get the closed formula for the last sum to get logarithmic solution but it is not required in the problem 
50,Monocarp is playing a computer game He s going to kill monsters the th of them has health Monocarp s character has two spells either of which he can cast an arbitrary number of times possibly zero and in an arbitrary order choose exactly two alive monsters and decrease their health by choose a single monster and kill it When a monster s health becomes it dies What s the minimum number of spell casts Monocarp should perform in order to kill all monsters ,The first spell looks pretty weak compared to the second spell Feels like you almost always replace one with another Let s show that you can totally avoid casting the spell of the first type twice or more on one monster Let the two first spell casts be and for some monsters and You can replace them by a cast of the second spell on and a cast of the first spell on That would deal even more damage to and the same amount to and The number of casts doesn t change Thus it only makes sense to use the first spell on monsters with health Calculate the number of them kill the full pairs of them with the first spell and use the second spell on the remaining monsters Overall complexity per testcase ,Note some observations if we meet a new wave and start shooting it s optimal to shoot monsters in the wave using full magazines while we can and there are no reasons to take breaks between shooting monsters from one wave That s why we can track only moments when waves start and the number of remaining bullets in magazine we have at these moments Moreover since the next wave starts not earlier than the previous ends we can think that when we start dealing with one wave we ve already dealt with the previous one Also instead of keeping track of the remaining bullets let s just look only at such indices of waves when we reloaded and threw remaining bullets before reaching them So we can write the next dp is the minimum number of bullets we spend dealing with the first waves and now we standing at the moment with full magazine Obviously Now with fixed we can iterate over the index of a wave before which we ll reload throwing away remaining bullets And for waves we need to check that we are able to exterminate all these waves without throwing away any bullets We can check it with several formulas If it s possible for segment then the possibility for the segment is just checking that we can exterminate the th wave having bullets in the start in no more than reloads plus checking that we have at least one unit before for a reload As a result the time complexity of the solution is 
51,In an ICPC contest balloons are distributed as follows Whenever a team solves a problem that team gets a balloon The first team to solve a problem gets an additional balloon A contest has 26 problems labelled You are given the order of solved problems in the contest denoted as a string where the th character indicates that the problem has been solved by some team No team will solve the same problem twice Determine the total number of balloons that the teams received Note that some problems may be solved by none of the teams ,Let s keep an array of booleans denoting whether or not some team has solved the th problem already Now we can iterate through the string from left to right and keep a running total If is true the th problem has already been solved increase by otherwise increase by and set to true The time complexity is Bonus the answer is always Can you see why ,For the first conversation let s choose two people and with maximal values of sociability Note that after this conversation takes place we move on to a similar problem but in which and are decreased by After decreasing and by we repeat the choice of the two people with the maximum values of sociability Let us repeat such iterations while at least two people with positive sociability parameters remain Let us prove that this solution leads to the optimal answer Let s denote the sum by and consider two fundamentally different cases The maximal element is greater than or equal to the sum of all remaining elements That is there exists such that In this case note that the th person can not possibly have more than conversations because by that point all other people already reached their sociability limits and left the meeting Thus if the answer cannot be more than Note that this estimation is accurate since an example exists in which th person talks to all other people as many times as possible that is times with th person for all And the algorithm described above will just choose the th person as one of the participants of a conversation every time because for every conversation both and decrease by exactly so the inequality holds and it follows that Otherwise we can prove that the maximum number of conversations is always Obviously it is impossible to get more than this number since each conversation requires exactly two units of sociability one from two people while a larger answer would mean that which is obviously wrong Let us prove that this answer is achieved by the described algorithm Let s look at the last conversation held If there are at least two more people left in the meeting after it we can hold another conversation which means there is a more optimal answer If there are zero people left in the meeting then an estimate of of conversations has been achieved And if there is one person with a remaining sociability then an estimate of of conversations has been achieved If there is exactly one remaining person with a sociability residual then we can guarantee that this person has participated in all previous conversations Indeed let s look at the last conversation it was held between two people with the maximum parameters of the remaining sociability But the th person has at least sociability remaining so it couldn t have been the other two people with residuals of who left right after that Thus analyzing all conversations in reverse order we can prove that at any time which means that it is in fact the case considered above We have proven that the described greedy algorithm works This algorithm can be implemented by using any balanced search tree such as By storing pairs of elements in it we could for each time choose the next two people to talk to and update the sociability values The time complexity is 
52,Try guessing the statement from this picture You are given a non negative integer You have to find two non negative real numbers and such that and ,To solve this problem we need to use some math and solve the equation on the paper If then and transforms to or Then where So if then or if there is no answer Since values are small calculating answer in was enough all we need to do is just output answer with sufficient number of digits after the decimal point ,Denote the answer to the problem Note that or what is the same where equals to one if is a magic number otherwise equals to zero Let s solve the problem for the segment Here is described the standard technique for this kind of problems sometimes it is called dynamic programming by digits It can be realized in a two ways The first way is to iterate over the length of the common prefix with number Next digit should be less than corresponding digit in and other digits can be arbitrary Below is the description of the second approach Let be the number of magic prefixes of length with remainder modulo If than the prefix should be less than the corresponding prefix in and if than the prefix should be equal to the prefix of it can not be greater Let s do forward dynamic programming Let s iterate over digit in position We should check that if the position is even than should be equal to otherwise it cannot be equal to Also we should check for should be not greater than corresponding digit in Now let s see what will be the next state Of course By Horner scheme Easy to see that To update the next state we should increase it Of course all calculations should be done modulo 
53,You are given a graph consisting of vertices and directed arcs The th arc goes from the vertex to the vertex has capacity and weight No arc goes into the vertex and no arc goes from the vertex There are no cycles of negative weight in the graph it is impossible to travel from any vertex to itself in such a way that the total weight of all arcs you go through is negative You have to assign each arc a flow an integer between and its capacity inclusive For every vertex the total flow on the arcs going to this vertex must be equal to the total flow on the arcs going from that vertex Let the flow on the th arc be then the cost of the flow is equal to You have to find a flow which the cost Sounds classical right Well we have some additional constraints on the flow on every edge if is even must be even if is odd must be odd Can you solve this problem ,This problem is solved using minimum cost flows duh Suppose all arcs have even capacity Then we can just divide each arc s capacity by and solve a usual minimum cost flow problem However when we have arcs with odd capacity it s not that simple We will deal with them as follows split an arc with capacity into two arcs one with capacity the other with capacity and somehow enforce that the second arc must be saturated We cannot divide all arcs by now because that would lead to non integer capacities instead we will exclude these arcs with capacity and somehow handle the fact that they must be saturated and only then divide all capacities by Okay how do we handle the edges we deleted For each vertex let s check if the number of such arcs connected to it is even If it is not the total flow for this vertex cannot be so it s impossible to find the answer the only case when it might be possible is if this vertex is the source or the sink in this case we need to check that both of these vertices have an odd number of arcs we want to delete connected to them and consider an additional arc with capacity and weight to make it even If for each vertex the number of odd arcs connected to it is even let s consider how much excess flow these arcs bring into the vertices For example if a vertex has ingoing odd arcs it has units of flow going into it which will be lost if we remove the edges we want to ignore To handle this add a new source and a new sink to our network let s call them and and process excess flow going into the vertex using an arc from to that vertex in the previous example we can add an arc from to the vertex with capacity not since we divide all capacities by Similarly excess flow going outside the vertex can be processed with an arc from that vertex to We need to make sure that all these edges must be saturated Okay what about actually running the flow from to We can do it as in flow with lower bounds problem by adding an arc with infinite capacity Wait a minute this may cause a negative cycle to appear If your implementation of mincost flow handles them you can use this approach but if you don t want to mess with negative cycles instead do the following add an arc and an arc both with infinite capacities to make sure that flow can go from to since these arcs don t have to be saturated but other arcs going from or into must be saturated set the costs of these other arcs to Okay that s it we just need to find the minimum cost flow in the resulting network The constraints are low enough so any minimum cost flow algorith can pass ,Let s observe what does the maximum weight of some fixed length path look like Among the edges on that path the last one has the maximum weight If it wasn t then the better total weight could be achieved by choosing a bigger weight edge earlier and going back and forth on it for the same number of steps It actually helps us arrive to a conclusion that all optimal paths look like that some simple path to an edge and then back and forth movement on it Any simple path in the graph has its length at most Let s separate the queries into two parts will be handled in a straightforward manner Let be the maximum weight of a path that ends in and has exactly edges in it That s pretty easy to calculate in You can also think of this as some kind of Ford Bellman algorithm let on the th step be the maximum weight of the path to of length Iterate over all edges and try to update and for each edge that s what I do in my solution if you refer to it Now for There was a very common assumption that after a bit more steps some edge will become the most optimal and will stay the most optimal until the end of time However that a bit cut off is in fact too high to rely on it must be somewhere around So the best path of length exactly ending in each vertex is Let the maximum weight adjacent edge to vertex be So the path of length will have weight Treat it like a line with coefficients and How do determine which line is the best for some Sure experienced participants will immediately answer convex hull Build a lower envelope of the convex hull of these lines If was a little smaller than we could query with binary search for each the same how convex hull is usually used We have to examine the hull further Each line in it becomes the best in some point then stays the best for some interval and then never appears the best again What are these line changing points Well it s just the intersection point of the adjacent lines in the hull So having these points and the parameters of the line we can calculate its contribution to the answer with a sum of arithmetic progression formula There were just lines in the hull so you can build the hull in any complexity I think I saw up to performances in the participants codes There is a cool solution that involves some kind of Divide Conquer on these lines I personally thought of it in a sense of traversing a Li Chao tree without actually building it If anyone wants to explain this solution feel free to do it in comments Overall complexity 
54,Polycarp had an array of integers He wrote out the sums of all non empty subsequences of this array sorted them in non decreasing order and got an array of integers For example if then Polycarp wrote out After sorting he got an array Unfortunately Polycarp lost the array He only has the array left Help him to restore the array ,The order of elements in doesn t matter If there is at least one correct array then we can sort it and get the answer in which Therefore we can always find a sorted array Suppose that Then We can find as ,Notice that we can keep solved tasks and then submit all at once So the solution goes down to this you should find the first moment of time that the site works at that moment and Also it s convinient that the intervals are already sorted in increasing order Let s sum up all elements of array and write it to some variable The answer is obtained this way if the sum lies in the current interval then the answer is the sum Otherwise there are two cases If there exists some interval that then the answer is In other case the answer is 1 
55,Consider a game with cards is even Each card has a number written on it between and All numbers on the cards are different We say that a card with number is stronger than a card with number if Two players Alex and Boris play this game In the beginning each of them receives exactly cards so each card belongs to exactly one player Then they take turns Alex goes first then Boris then Alex again and so on On a player s turn he must play of his cards Then if the opponent doesn t have any cards than the card played the opponent loses and the game ends Otherwise the opponent has to play a stronger card exactly one card as well These two cards are removed from the game and the turn ends If there are no cards left the game ends in a draw otherwise it s the opponent s turn Consider all possible ways to distribute the cards between two players so that each of them receives exactly half of the cards You have to calculate three numbers the number of ways to distribute the cards so that Alex wins the number of ways to distribute the cards so that Boris wins the number of ways to distribute the cards so that the game ends in a draw You may assume that both players play optimally i e if a player can win no matter how his opponent plays he wins Two ways to distribute the cards are different if there is at least one card such that in one of these ways it is given to Alex and in the other way it is given to Boris For example suppose Alex receives the cards and Boris receives the cards Then the game may go as follows if Alex plays the card then Boris has to respond with the card Then Alex s turn ends and Boris turn starts Boris has only one card left which is he plays it and Alex responds with the card So the game ends in a draw if Alex plays the card then Boris has to respond with the card Then Alex s turn ends and Boris turn starts Boris has only one card left which is he plays it and Alex responds with the card So the game ends in a draw So in this case the game ends in a draw ,The example tests suggest that there is only one possible distribution with a draw Let s find out why it is so We will use a process similar to induction recursion to distribute the cards between the two players so that the game ends in a draw suppose Alex receives the card Then he wins since he can play it immediately So for the game to result in a draw Boris must receive the card suppose Boris receives the card Then he wins since he also has the card he can use it to answer any first move of Alex and then win the game by playing So for the game to result in a draw Alex must receive the card suppose Boris receives the card Then he wins since he also has the card if Alex plays the card Boris responds with and then plays if Alex plays some other card Boris responds with and the plays So for the game to result in a draw Alex must receive the card and so on In fact if Alex receives the card and Boris receives the card Alex must play the card or something equivalent to it on the first move and Boris must respond with the card so we can consider the game without these two cards with the roles swapped So if we consider the distribution of cards as a string with characters and where denotes the card belonging to Alex and denotes the card belonging to Boris and the th character of the string represents the card the only possible distribution for the draw is But there s more to this string representation of the distribution of cards the first character that is different from this pattern denotes the winner if the first different character is in the draw distribution and in the distribution we consider the winner is Boris otherwise the winner is Alex This may lead us to the following ways to count the number of possible distributions which win lose for Alex we can use dynamic programming of the form where is the number of characters we used is the number of characters we used and is or depending on whether our string coincides with the draw string differs from it in a way that Alex wins or differs from it in a way that Boris wins the actual value of must be the number of ways to reach this state of dynamic programming The answer then is stored in the states of the form or we can use combinatorics let s iterate on the length of the prefix that is common in the draw string and in the string representing the distribution of cards and then count the number of ways to distribute the remaining characters with a binomial coefficient To calculate the binomial coefficients we can use one of the following methods Pascal s triangle precalculating factorials and modular inverses to then or calculating factorials with big integers in Java or Python ,Denote as the number of teams that can be winners in the th game The answer to the problem is If the th game is played between the winners of games and then if if if So we can calculate all values of for the initial string Note that the result of no more than other games depends on the result of any game So if we change it will change no more than values of and we can recalculate all of them For convenience you can renumerate the games so that the playoff looks like a segment tree i e the final has the number the semifinals have numbers and etc 
56,There are participants in a competition participant having a strength of Every participant wonders how much of an advantage they have over the other best participant In other words each participant wants to know the difference between and where is the strongest participant in the competition not counting a difference can be negative So they ask you for your help For each output the difference between and the maximum strength of any participant other than participant ,Make a copy of the array s call it t Sort t in non decreasing order so that t 1 is the maximum strength and t 2 the second maximum strength Then for everyone but the best person they should compare with the best person who has strength t 1 So for all i such that s i neq t 1 we should output s i t 1 Otherwise output s i t 2 the second highest strength which is the next best person ,Since there are only five days we can iterate over the two of them that will be the answer Now we have fixed a pair of days and and want to check if it can be the answer All students can be divided into four groups marked neither of days and marked only day marked only day and marked both days Obviously if the first group is non empty days and can t be the answer Let s call the number of students who only marked day and the number of students who only marked day If either of or exceed then days and can t be the answer as well Otherwise we can always choose students from the ones who marked both days and send them to day The rest of the students can go to day 
57, New gamemode Huh is that it Slightly disappointed you boot up the game and click on the new gamemode It says There are platforms numbered from to placed one after another There are colors available in the game numbered from to The th platform is colored You start on the platform and want to reach platform In one move you can jump from some platform to platforms or All platforms are initially deactivated including platforms and For each color you can pay coins to activate all platforms of that color You want to activate some platforms so that you could start on an activated platform jump through some activated platforms and reach an activated platform What s the smallest amount of coins you can spend to achieve that ,Imagine we bought some subset of colors How to check if there exists a path from 1 to n Well we could write an easy dp However it s not immediately obvious where to proceed from that You can t really implement buying colors inside the dp because you should somehow know if you bought the current color before and that s not really viable without storing a lot of information Let s find another approach Let s try to deduce when the subset is bad the path doesn t exist Trivial cases c 1 or c n aren t bought Now if there are two consecutive platforms such that their colors aren t bought the path doesn t exist Otherwise if there are no such platforms you can show that the path always exists In particular that implies that among all pairs of consecutive platforms at least one color of the pair have to be bought If the colors of the pair are the same then it s just that this color have to be bought The next step is probably hard to get without prior experience Notice how the condition is similar to a well known graph problem called vertex cover That problem is about finding a set of vertices in an undirected graph such that all graph edges have at least one of their endpoints in the set In particular our problem would be to find a vertex cover of minimum cost That problem is known to be NP hard thus the constraints We can t solve it in polynomial time but we ll attempt to it faster than the naive approach in O 2 m cdot m 2 Let s start with this approach anyway We can iterate over a mask of taken vertices and check if that mask is ok In order to do that we iterate over edges and check if at least vertex is taken for each of them Again having a bit of prior experience one could tell from the constraints that the intended solution involves meet in the middle technique Let s iterate over the mask of taken vertices among vertices from 1 to frac m 2 Then over the mask of taken vertices from frac m 2 1 to m The conditions on edges split them into three groups the edges that are completely in mathit mask 1 the edges that are completely in mathit mask 2 and the edges that have one endpoint in mathit mask 1 and another endpoint in mathit mask 2 First two types are easy to check but how to force the third type to be all good Consider the vertices that are not taken into mathit mask 1 All edges that have them as one of the endpoints will turn out bad if we don t take their other endpoints into mathit mask 2 That gives us a minimal set of constraints for each mathit mask 1 a mask mathit con that includes all vertices from the second half that have edges to at least one of non taken vertex in mathit mask 1 Then mathit mask 2 is good if it has mathit con as its submask Thus we would want to update the answer with the mathit mask 1 of the minimum cost such that its mathit con is a submask of mathit mask 2 Finally let mathit dp mathit mask store the minimum cost of some mathit mask 1 such that its mathit con is a submask of mathit mask Initialize the mathit dp with the exact mathit con for each mathit mask 1 Then push the values of mathit dp up by adding any new non taken bit to each mask When iterating over mathit mask 2 check if it s good for edges of the second kind and update the answer with mathit dp mathit mask 2 Overall complexity O 2 m 2 cdot m 2 ,Formally the problem is to paint tree edges in minimal number of colors in such a way the the number of improper vertices doesn t exceed A vertex is improper if it has at least two incident edges of the same color It is easy to show that colors is always enough to paint a tree in such a way that all the vertices are proper where is the maximum vertex degree Actually it is always the truth do any bipartite graph Indeed if number of colors is less than the maximum degree such vertices will have at least two edges of the same color Dirichlet s principle If equals the maximum degree you can use just depth first search tree traversal to paint edges in different colors In this problem you can have up to improper vertices so just choose such minimal that number of vertices of degree greater than is at most In an alternative solution you can use a binary search to find such but it makes the implementation harder and the solution becomes slower by factor After it paint edges with colors each time choosing the next color skip color if it equals with the color of the traversal incoming edge 
58,Vasya s house is situated in a forest and there is a mushroom glade near it The glade consists of two rows each of which can be divided into consecutive cells For each cell Vasya knows how fast the mushrooms grow in this cell more formally how many grams of mushrooms grow in this cell each minute Vasya spends exactly one minute to move to some adjacent cell Vasya cannot leave the glade Two cells are considered adjacent if they share a common side When Vasya enters some cell he instantly collects all the mushrooms growing there Vasya begins his journey in the left upper cell Every minute Vasya must move to some adjacent cell he cannot wait for the mushrooms to grow He wants to visit all the cells and maximize the total weight of the collected mushrooms Initially all mushrooms have a weight of Note that Vasya doesn t need to return to the starting cell Help Vasya Calculate the maximum total weight of mushrooms he can collect ,A route visiting each cell exactly once can always be denoted as follows several possibly zero first columns of the glade are visited in a zigzag pattern then Vasya goes to the right until the end of the glade makes one step up or down and goes left until he visits all remaining cells There are such routes To calculate the weight of collected mushrooms quickly we will precompute three arrays for the first row of the glade and will be used to compute the weight of mushrooms collected when Vasya moves to the right until the last column of the glade when Vasya moves to the left from the last column and to handle the growth of mushrooms Also we have to compute the same arrays for the second row of the glade Let s iterate on the number of columns Vasya will pass in a zigzag pattern and maintain the weight of mushrooms he will collect while doing so Then we have to add the weight of the mushrooms Vasya will gather while moving to the right and then while moving to the left The first can be handled by arrays and the second by arrays and ,Any experienced contestant can easily guess that the problem can be solved with dynamic programming Coordinates are not really large so you can precalculate the array where is a boolean value if there exists some segment of rain to cover the segment between positions and and otherwise This can be done in with the most straightforward algorithm You can also precalculate another array where is the index of the umbrella of minimal weight at position or if there is no such umbrella Now let be the minimal total fatigue you can take if you are holding umbrella number on the end of the walk up to position If then you hold no umbrella Initially all the values are and is You can either hold your umbrella drop it or pick up the best one lying there and drop the current one if any when going from some position to So here are the transitions for these cases if if if The answer is equal to If it is then there is no answer So you have states and all the transitions are Overall complexity There is also a solution in with Convex Hull Trick using Li Chao tree You can probably even achieve with some coordinate compression Obviously this wasn t required for the problem as the constraints are small enough 
59,You are given two huge binary integer numbers and of lengths and respectively You will repeat the following process if then add to the answer the value and divide by rounding down i e remove the last digit of and repeat the process again otherwise stop the process The value means bitwise of and Your task is to calculate the answer modulo Note that you should add the value to the answer in decimal notation not in binary So your task is to calculate the answer in decimal notation For example if and then the value will be equal to not to ,To solve this problem let s take a look which powers of in will be affected by powers of in Firstly let s reverse numbers Let s carry the current power of let it be the current sum of powers of in from the position to the current position inclusive let it be and the answer is Initially and Let s iterate over all bits of from to Let the current bit in have the number Firstly if and then set in other words we add to the sum of powers of in the current power of If then this bit will add to the answer all the powers of in from to inclusive in other words so if it is then set And after all we can set and go on to And don t forget to take all values modulo to avoid overflow ,Let s calculate the prefix sums for all numbers and store it in array and for numbers with letter B and store it in array Now we can find the sum of all numbers in any segment in time and the sum of numbers with letter B Let s iterate over prefix or suffix to flip and calculate the sum in that case by formulas for prefixes and for suffixes 
60,A permutation of length is an array which contains every integer from to inclusive exactly once For example is a permutation of length You are given three integers and where is an even number Print any permutation of length that the minimum among equals and the maximum among equals Print if no such permutation exists ,There are many different constructions that give the correct answer if it exists In my opinion one of the most elegant is the following one should always be present in the left half and should be present in the right half but the exact order of elements in each half doesn t matter So it will never be wrong to put in the first position and in the second position As for the remaining elements we want elements of the left half to be as big as possible since they shouldn t be less than and elements of the right half as small as possible since they shouldn t be greater than Let s put the elements excluding and on positions respectively so the elements in the left half are as big as possible and the elements in the right half are as small as possible After constructing a permutation according to these rules we should check if it meets the constraints and print it if it does ,Consider some permutation q Let s build by it the oriented graph with edges i qi Easy to see and easy to prove that this graph is the set of disjoint cycles Now let s see what would be with that graph when the permutation will be multiplied by itself all the cycles of odd length would remain so only the order of vertices will change they will be alternated but the cycles of even length will be split to the two cycles of the same length So to get the square root from the permutation we should simply alternate in reverse order all cycles of the odd length and group all the cycles of the same even length to pairs and merge cycles in each pair If it s impossible to group all even cycles to pairs then the answer doesn t exist Complexity O n 
61,You are given two bracket sequences not necessarily regular and consisting only of characters and You want to construct the shortest bracket sequence that contains both given bracket sequences as not necessarily contiguous Recall what is the regular bracket sequence is the regular bracket sequence if is the regular bracket sequence then is a regular bracket sequence if and regular bracket sequences then concatenation of and is a regular bracket sequence Recall that the subsequence of the string is such string that can be obtained from by removing some possibly zero amount of characters For example and are subsequences of but and are not ,Firstly notice that the length of the answer cannot exceed copies of Now we can do some kind of simple dynamic programming Let be the minimum possible length of the prefix of the regular bracket sequence if we are processed first characters of the first sequence first characters of the second sequence and the current balance is Each dimension of this dp should have a size nearby The base of this dp is all other values Transitions are very easy if we want to place the opening bracket then we increase if the th character of exists and equals the same with the second sequence and the balance increases by one and the length of the answer increases by one If we want to place the closing bracket then we increase if the th character of exists and equals the same with the second sequence and the balance decreases by one and the length of the answer increases by one Don t forget to maintain parents in this dp to restore the actual answer The last problem that can be unresolved is how to write this dp The easiest way is bfs because every single transition increases our answer by one Then we can restore answer from the state You can write it recursively but I don t sure this will look good And you also can write it just with nested loops if you are careful enough Time complexity If you know the faster solution please share it ,The problem asks us to maintain the bounding box while inserting the character of one of types between every adjacent characters in Of course we can do it but do we really to do it in such way Let s think a little Inserting W or S doesn t affect the width of the bounding box and A or D doesn t affect the height So they are absolutely independent And we can divide our WASD string on WS string and AD string Moreover inserting W or S in WS string and A or D in AD string is almost same thing so we don t even need to write different code for different string How to handle only WS string Let s replace W as and S as and suppose that we started in position Then the position where we go after commands is just prefix sum of first elements Then the length of the bounding box is maximum position minimum position 1 The maximum minimum position is a maximum minimum element in array of prefix sums What the inserted value do It add to suffix of Let s choose for example The can t decrease the maximum but can increase the minimum so we need to place it somewhere before all minimums in or before the first minimum But if we place it before any of maximum elements then we will increase it and prevent decreasing the length of bounding box So we need to place somewhere after all maximums on or after the last maximum And here goes the solution find position of the first minimum in and position of the last maximum If then we can insert and decrease the length of bounding box but since we insert command that move robot we can t achieve bounding box of length What to do with Just multiply by and now we can insert instead of in absolutely same manner What to do with AD string Denote A as and D as and everything is absolutely the same 
62,A bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters and into this sequence For example sequences and are regular while and are not Let s call a regular bracket sequence RBS You are given a sequence of characters and or in this sequence You have to replace every character with either or different characters can be replaced with different brackets Determine if it is possible to obtain an RBS after these replacements ,There are two solutions to this problem casework and greedy The greedy solution goes as follows the number of opening brackets in an RBS should be exactly and if there is a closing bracket before an opening bracket it s optimal to swap them if possible So we should replace the first question marks with opening brackets other question marks with closing brackets and if the answer exists this method will find it All that s left is to check that the resulting sequence is an RBS The casework solution goes as follows first of all each RBS should have an even length so if is odd there is no answer Furthermore an RBS always begins with an opening bracket and always ends with a closing bracket so if the first character is a closing bracket or the last character is an opening bracket there is no answer Since there is at most one opening bracket and at most one closing bracket in the original sequence these three constraints are enough if the opening bracket is before the closing bracket then they balance out and all other characters can be replaced in such a way that they form an RBS of length If the opening bracket is after the closing bracket then the first and the last characters are question marks since the first character is not a closing bracket and the last one is not an opening bracket We should replace the first character with an opening bracket the last character with a closing bracket so we get four characters two opening and two closing brackets which balance themselves out All other question marks can be replaced in such a way that they form an RBS of length So all we have to check is that is even the first character is not a closing bracket and the last character is not an opening bracket ,Let s turn the problem around we ll look for the longest suffix that will make Polycarp happy since it s the same thing Let s create an array in which we will mark the numbers already encountered Let s go along from right to left and check if does not occur to the right in this case it is marked in if it occurs to the right then removing any prefix that does not include we get an array where occurs twice so we have to delete prefix of length 
63,The busses in Berland are equipped with a video surveillance system The system records information about changes in the number of passengers in a bus after stops If is the number of passengers in a bus just before the current bus stop and is the number of passengers in the bus just after current bus stop the system records the number So the system records show how number of passengers changed The test run was made for single bus and bus stops Thus the system recorded the sequence of integers exactly one number for each bus stop where is the record for the bus stop The bus stops are numbered from to in chronological order Determine the number of possible ways how many people could be in the bus before the first bus stop if the bus has a capacity equals to that is at any time in the bus there should be from to passengers inclusive ,Firstly we should find the minimum and maximum numbers of passengers which could be in a bus if initially it was empty Let We should iterate through the bus stops For the th bus stop we add to and update with a value of the minimum number of passengers and the maximum number of passengers If it is an invalid case and we should print because the maximum number of passengers should be less or equal to Let is a minimum possible number of passengers in the bus before the first stop and maximum possible If then in the bus initially were at least passengers Because we should make else If then else After that we should compare and If print In the other case print because each of those values is correct ,There are two important observations to make The first one is that you can calculate the answers for each university independently of each other and sum them up to obtain the true answer The second one is that if there are students in an university then that university can only contribute to answers for from to So if we learn to calculate the contribution of the th university for some fixed in then we will be able to iterate over all possible for each university and get the solution in where is the number of students in the th university To achieve it you have to gather the sum of the maximum number of students that can form full teams of size That must be the highest number less than or equal to that is divisible by so Sort the students of each university precalculate partial sums and now you are free to add the prefix sum of that number of students to the answer for Overall complexity per testcase 
64,A running competition is going to be held soon The stadium where the competition will be held can be represented by several segments on the coordinate plane two horizontal segments one connecting the points and the other connecting the points and vertical segments numbered from to The th segment connects the points and For example here is a picture of the stadium with and A is a route that goes along the segments starts and finishes at the same point and never intersects itself the only two points of a lap that coincide are its starting point and ending point The length of a lap is a total distance travelled around it For example the red route in the picture representing the stadium is a lap of length The competition will be held in stages The th stage has length and the organizers want to choose a lap for each stage such that the length of the lap is a The organizers don t want to choose short laps for the stages so for each stage they want to find the maximum possible length of a suitable lap Help the organizers to calculate the maximum possible lengths of the laps for the stages In other words for every find the maximum possible integer such that and there exists a lap of length If it is impossible to choose such a lap then print ,First of all let s find all possible lengths of the laps after doing that we can just check every divisor of to find the maximum possible length of a lap for a given query A lap is always a rectangle you can t construct a lap without using any vertical segments or using an odd number of vertical segments and if you try to use or more vertical segments you can t go back to the point where you started because both horizontal segments are already partially visited So a lap is a rectangle bounded by two vertical segments and if we use vertical segments and the perimeter of this rectangle is Let s find all values that can be represented as A naive approach will be too slow we have to speed it up somehow Let s build an array of numbers where is some integer greater than Each number that can be represented as can also be represented as so we have to find all possible sums of two elements belonging to different arrays The key observation here is that if and are small we can treat each array as a polynomial let and similarly Let s look at the product of that polynomials The coefficient for is non zero if and only if there exist and such that so finding all possible sums and all possible differences can be reduced to multiplying two polynomials which can be done faster than using Karatsuba s algorithm or FFT ,In this problem all you need is to check for each point from to if it cannot belongs to any segment It can be done in by two nested loops or in by easy prefix sums calculation Both solutions are below 
65,You are given a string consisting only of characters and A substring of is a string and its length equals to A substring is called if the number of zeroes equals to the number of ones in this substring You have to determine the length of the longest substring of ,Let be the number of zeroes and the number of ones on prefix of length also let The interesting property of is that the substring is balanced iff That leads to a solution for each value of maintain the minimum where this is obtained let it be called and for each index in the string update answer with ,Let s solve the task as if there are no updates This can be done with a pretty straightforward dp is the number of pairs such that the result of the strange addition of and is the prefix of of length From each state you can add a single digit to and to at the same time You can either go to and multiply the answer by the number of pairs of digits than sum up to Or go to and multiply the answer by the number of pairs of digits than sum up to Note that no pair of digits can sum up to a three digit value so it makes no sense to go further Let s optimize this dp with some data structure Segment tree will work well Let the node store the number of ways to split the segment into blocks of size or so that both the leftmost character and the rightmost character are not taken into any block the leftmost character is taken into some block and the rightmost character is not taken into any block the leftmost character is not taken into any block and the rightmost character is taken into some block both the leftmost and the rightmost characters are taken into some blocks This structure makes the merge pretty manageable You should glue up the segments in such a way that all the middle characters are taken into some block either in separate blocks in their own segments or into the same block of length The answer will be in the root of the tree in a value such that both characters are taken The update in the segment tree will still work in Overall complexity 
66,Polycarp takes part in a math show He is given tasks each consists of subtasks numbered through It takes him minutes to solve the th subtask of any task Thus time required to solve a subtask depends only on its index but not on the task itself Polycarp can solve subtasks in any order By solving subtask of arbitrary problem he earns one point Thus the number of points for task is equal to the number of solved subtasks in it Moreover if Polycarp solves the task solves all of its subtasks he recieves one extra point Thus total number of points he recieves for the complete solution of the task is Polycarp has minutes of time What is the maximum number of points he can earn ,Constraints tell us that we can avoid making any weird assumptions for any greedy solutions You can easily count the answer for some fixed amount of tasks completed Just sort all left subtasks but the longest to solve in each uncompleted task and take the easiest till the time is over Now you can iterate from to tasks completed and take maximum over all options Overall complexity ,The simplest solution go through the problem because of which the teacher might have suspicions Now you can find the first day when Polycarp solved this problem and the last such day Between these two days all problems should be the same If this is not the case the answer is 
67,In this problem you will have to help Berland army with organizing their command delivery system There are officers in Berland army The first officer is the commander of the army and he does not have any superiors Every other officer has exactly one direct superior If officer is the direct superior of officer then we also can say that officer is a direct subordinate of officer Officer is considered to be a subordinate direct or indirect of officer if one of the following conditions holds officer is the direct superior of officer the direct superior of officer is a subordinate of officer For example on the picture below the subordinates of the officer are The structure of Berland army is organized in such a way that every officer except for the commander is a subordinate of the commander of the army Formally let s represent Berland army as a tree consisting of vertices in which vertex corresponds to officer The parent of vertex corresponds to the direct superior of officer The root which has index corresponds to the commander of the army Berland War Ministry has ordered you to give answers on queries the th query is given as where is some officer and is a positive integer To process the th query imagine how a command from spreads to the subordinates of Typical DFS depth first search algorithm is used here Suppose the current officer is and he spreads a command Officer chooses one of his direct subordinates i e a child in the tree who has not received this command yet If there are many such direct subordinates then chooses the one having minimal index Officer gives a command to officer Afterwards uses exactly the same algorithm to spread the command to its subtree After finishes spreading the command officer chooses the next direct subordinate again using the same strategy When officer cannot choose any direct subordinate who still hasn t received this command officer finishes spreading the command Let s look at the following example If officer spreads a command officers receive it in the following order If officer spreads a command officers receive it in the following order If officer spreads a command officers receive it in the following order If officer spreads a command officers receive it in the following order To answer the th query construct a sequence which describes the order in which officers will receive the command if the th officer spreads it Return the th element of the constructed list or if there are fewer than elements in it You should process queries independently A query doesn t affect the following queries ,Let s form the following vector we run DFS from the first vertex and push the vertex to the vector when entering this vertex Let be the position of the vertex in the vector the size of the vector in moment we call DFS from the vertex and be the position of the first vertex pushed to the vector after leaving the vertex the size of the vector in moment when we return from DFS from the vertex Then it is obvious that the subtree of the vertex lies in half interval After running such DFS we can answer the queries Let answering the th query If is greater than or equal to then answer to the th query is We need to check if the vertex lies in the subtree of the vertex The vertex is in the subtree of the vertex if and only if If the vertex is not in the subtree of the vertex then answer is Otherwise the answer is Overall complexity is ,To solve this problem we can use a data structure which allows to add some value on segment and get a value from some point Fenwick tree segment tree or anything you are familliar with Let s run DFS from the root while maintaining current depth When entering a vertex on depth let s consider all queries having and for each such query add on segment Then for current vertex the answer is the value in point When leaving vertex we need to rollback everything we have done for all queries having subtract on segment 
68,Polycarp has a string of length consisting of decimal digits Polycarp performs the following operation with the string i e he can perform operation or time Polycarp selects two numbers and and removes characters from the string at the positions i e removes substring More formally Polycarp turns the string into the string For example the string Polycarp can turn into strings in this case or in this case in this case other operations are also possible only a few of them are listed above Polycarp likes the string very much so he is wondering if it is possible to turn the string into a string in no more than one operation Note that you can perform zero operations ,Let s see how the deleted substring t should look so that after deleting it the string s turns into the string The length of the string t must be n 4 Then we can iterate over all substrings of the string s of length n 4 there are no more than five such substrings and look at the string obtained after deleting the substring That is we need to check that one of the following character sequence matches the 2 0 2 0 s 1 s 2 s 3 s 4 s 1 s 2 s 3 s n s 1 s 2 s n 1 s n s 1 s n 2 s n 1 s n s n 3 s n 2 s n 1 s n ,Let s try to estimate the maximum possible answer Best case you will be able to remove either all zeros or all ones from the entire string Whichever has the least occurrences can be the answer If the amounts of zeros and ones in the string are different this bound is actually easy to reach just choose the substring that is the entire string If the amounts are the same the bound is impossible to reach Choosing the entire string will do nothing and asking a smaller substring will decrease the answer The smallest we can decrease the answer by is If you choose the substring that is the string without the last character you will decrease one of the amounts by one That will make the amounts different and the bound will be reached Overall complexity per testcase 
69,You are given an graph consisting of vertices and edges It is guaranteed that the given graph is i e it is possible to reach any vertex from any other vertex and there are no self loops and multiple edges in the graph Your task is to calculate the number of of length in the given graph Note that paths that differ only by their direction are considered the same i e you have to calculate the number of paths For example paths and are considered the same You have to answer independent test cases Recall that a path in the graph is a sequence of vertices such that each pair of adjacent consecutive vertices in this sequence is connected by an edge The length of the path is the number of edges in it A is such a path that all vertices in it are distinct ,Because our graph is just a tree with an additional edge consider it as a cycle with trees hanged on cycle vertices Consider some tree hung on a vertex v on a cycle There is only one path between each pair of its vertices including the root which is a vertex v So if the tree has cnt v vertices then frac cnt v cnt v 1 2 paths are added to the answer What about paths that go out of a tree Let s assume that there are cnt v cdot n cnt v such paths yeah we counted only a half of actual paths from this component but this is fine When we consider other trees we will take into account the other half of paths This information can lead us to the conclusion that the only information we need to know about trees hanged on cycle vertices is the number of vertices in these trees So if we know cnt v for each vertex on a cycle we can just calculate the answer as sum limits v in cycle frac cnt v cnt v 1 2 cnt v cdot n cnt v So how to find values cnt v Of course there is a simple and straight forward solution just extract and mark all cycle vertices and run dfs from every vertex of a cycle but there is another approach without any graph algorithms that works very well for such kind of graphs Initially let cnt v 1 for each v from 1 to n Let s create a queue containing all leafs of the graph Let s take the leaf x get its parent p add cnt p cnt p cnt x and remove the vertex x with all edges incident to it After that if p became a leaf let s add it to the queue We can see that after processing all leafs only cycle vertices remain in the graph and cnt v is exactly the number of the vertices in a tree and we can just calculate the answer using the formula above This approach can be implemented in O n log n or in O n there is almost no difference but O n log n one can be written a bit simpler than a linear one ,At first let s realize that the tree structure doesn t matter that much What we actually need is the array such that it stores the number of white vertices on depth Initially and all other are zero If you take a chain and attach it to some vertex on depth then the number of vertices on depth decreases by Also the added vertices update some other counts So far it s extremely unclear what to begin with Let s start by introducing some greedy ideas For each let s find the most optimal tree using exactly chains and update the answer with each of them First it s always optimal to attach a chain with its middle vertex Just consider the changes in the white vertices counts Second for each it s always optimal to take the longest chains to use If not the longest are used then you can replace any of them and there will be more white vertices It would be nice if we were able to just add another chain to the tree for to get the tree for However that s not always the case But we can still attempt it and show that the optimal answer was achieved somewhere in the process Let s show that it s always optimal to attach a new chain to the closest white vertex So there are basically two cases there is not enough white vertices yet and there is enough What happens if there is not enough vertices and we pick the closest one to attach a chain to If there are still not enough vertices then we ll just continue Otherwise we ll have to show that the answer can t get any smaller by rearranging something Consider what the answer actually is Build a prefix sum array over then the answer is the shortest prefix such that its prefix sum is greater or equal to So we put the th chain to the closest white vertex at depth It decreases by and increases and further by or Every chain we have put to this point was attached to a vertex at depth less or equal to the answer otherwise we could ve rearranged it and obtain the answer before The optimal answer can be neither nor also because we could ve rearranged Thus the answer is at least and every single chain we have put was packed as tightly as possible below that depth The second case works similarly We could ve obtained the optimal answer before So the answer is below and we can do nothing about that Or the optimal answer is ahead of us so putting the chain at can decrease it as much or stronger as any other choice Thus updating the answer on every iteration will give us the optimal result Now we are done with the greedy time to implement it I chose the most straightforward way We basically have to maintain a data structure that can add on range get the value of a cell and find the shortest prefix with sum at least That can be easily done with segtree Overall complexity 
70,You are given a string and strings All strings consist of lowercase Latin letters Let be the number of occurences of string in string For example and Calculate the value of where is the concatenation of strings and Note that if there are two pairs and such that you should include both and in answer ,Let s look at any occurrence of arbitrary pair There is exactly one special split position where the ends and starts So instead of counting occurrences for each pair we can iterate over the position of split and count the number of pairs This transformation is convenient since any which ends in split position can be paired with any which starts here So all we need is to calculate for each suffix the number of strings which starts here and for each prefix the number of strings which ends here But calculating the prefixes can be transformed to calculating suffixes by reversing both and all Now we need for each position calculate the number of strings which occur from It can be done by Aho Corasick Suffix Array Suffix Automaton Suffix Tree but do we really need them since constrains are pretty low The answer is NO We can use sqrt heuristic Let s divide all in two groups short and long The is short if There are no more than long strings and for each such string we can find all its occurrences with z function or prefix function It will cost as What to do with short strings Let s add them to trie The trie will have vertices but only depth So we can for each move down through the trie while counting the occurrences using only substring It will cost us So if we choose we can acquire complexity using only basic string structures ,There are two ways to solve this problem greedy approach and dynamic programming The first apprroach Considerr some segment of consecutive equal characters Let be the length of that segment Easy to see that we should change at least characters in the segment to remove all the pairs of equal consecutive letters On the other hand we can simply change the second the fourth etc symbols to letter that is not equal to the letters before and after the segment 
71,You are given an undirected graph consisting of vertices A number is written on each vertex the number on vertex is Initially there are no edges in the graph You may add some edges to this graph but you have to pay for them The cost of adding an edge between vertices and is coins There are also special offers each of them is denoted by three numbers and and means that you can add an edge connecting vertices and and pay coins for it You don t have to use special offers if there is a pair of vertices and that has a special offer associated with it you still may connect these two vertices paying coins for it What is the minimum number of coins you have to spend to make the graph connected Recall that a graph is connected if it s possible to get from any vertex to any other vertex using only the edges belonging to this graph ,Suppose we have found all the edges of the graph explicitly sorted them and start running Kruskal on the sorted list of edges Each time we add some edge to MST it is either a special edge given in the input or an edge which was generated with cost whichever costs less Let s try to analyze how can we find the cheapest edge of each type that connects two components For special edges we may just maintain the number of special edges we already added or skipped and when choosing a new edge we skip some more possibly zero special edges that don t connect anything until we find an edge that connects something And for the other type of edges we may find two components having minimum numbers on the vertices in those components as small as possible and just connect the minimum vertex in the first component with the minimum vertex in the second component We may simulate this by maintaining a data structure for example a multiset where for each component we will store the vertex having minimum in this component and pick two minimums from this set We also have to be able to check if two vertices are connected this can be done with DSU and merge two components But this solution can be made easier Every time we add a non special edge one of the ends of this edge is the vertex with minimum So we may just find this vertex generate all edges connecting this vertex to all other vertices merge this set of edges with the set of special edges and run any MST algorithm on the resulting set of edges If there are multiple minimums in the array then we may pick any of them because in Kruskal algorithm it doesn t matter which of the edges with equal costs we try to add first ,Note that in any shortest path we cannot return to the previous vertex Since if the current vertex the previous The current distance the shortest distance to vertex the shortest distance to vertex Then if we return to the vertex the shortest distance from it to is If we add to the current distance we get Thus we get a path at least longer than the shortest one Thus our answer consists of only simple paths If the answer consists only of simple paths then we will simply add vertices to the queue when traversing bfs twice on the first visit and on the next visit when the distance to the vertex is equal to the shortest And we will also count the number of ways to get to that vertex Then we can output the answer as soon as we get to the vertex the second time for processing After that we can terminate the loop The asymptotic will be since we only need bfs 
72,Alice and Bob play 5 in a row game They have a playing field of size In turns they put either crosses or noughts one at a time Alice puts crosses and Bob puts noughts In current match they have made some turns and now it s Alice s turn She wonders if she can put cross in such empty cell that she wins immediately Alice wins if some crosses in the field form line of length This line can be horizontal vertical and diagonal ,This one is a pure implementation task Just check every possible line of length If the current one contains crosses and empty cell then the answer is ,Let s see how the water can flow when it meets the pipe of type or and in the other case When the water meets the pipe of type or we cannot do anything but let it flow to the right of the current cell Otherwise if the current pipe is curved then there are two cases if the pipe on the same position but in the other row is not curved then the answer is because the water has to change the row but we cannot turn the next pipe to allow it to move to the right or to the left So the current pipe is curved and the pipe on the same position in the other row is also curved let s change the row and move to the right it is obvious that we never need to move to the left So the answer and the sequence of pipes is uniquely defined by types of pipes If after iterating over all positions we didn t meet the case of and the current row is second then the answer is 
73,Recently Norge found a string consisting of lowercase Latin letters As an exercise to improve his typing speed he decided to type all substrings of the string Yes all of them A substring of is a non empty string For example and are substrings of Shortly after the start of the exercise Norge realized that his keyboard was broken namely he could use only Latin letters out of After that Norge became interested in how many substrings of the string he could still type using his broken keyboard Help him to find this number ,Let s replace all characters of with zeros and ones zero if the character is unavailable and one otherwise Then we have the binary string and we have to calculate the number of contiguous segments of this string consisting only of ones It can be done with two pointers approach If we are staying at the position and its value is zero just skip it Otherwise let s find the leftmost position such that and the th value is zero Then we have to add to the answer the value and set Time complexity ,Let s use a trie to store the given words Now let s imagine a procedure that checks if some string of length can be represented as a concatenation of some of these words If the words were prefix independent no word was a prefix of another word that task would be solvable with a greedy algorithm We could iterate over a string and maintain the current vertex of the trie we are in Append a current letter If there is no such transition in a trie it can t be represented If the vertex we go to is a terminal jump to the root of the trie Otherwise just go to that vertex However since the words aren t prefix independent we have a terminal on a path to other terminals Thus we can t immediately decide if we should jump to the root or just go Let s handle this with dynamic programming can we put letters in such a way that the vertex of a trie we are in is Is building a chainword letter by letter that different from this process Apparently it isn t Consider how many ways are there to put letters in a string so that the first hint is in a vertex and the second hint is in a vertex For the transition we can try all letters to put and jump to the corresponding vertices That obviously is too slow The intuition tells us that this dp should be calculated with some kind of matrix exponentiation since That dp can be rewritten as a matrix pretty easily However its size is up to the maximum number of vertices in a trie squared Some say that there is a way to compute the th power of such a huge matrix fast enough with Berlekamp Massey but I unfortunately am not familiar with it Thus we ll have to reduce the size of our matrix First notice that the only reachable states are such that the word that is written on a path from the root to is a suffix of a word that is written on a path from the root to or vice versa Look at it the other way if we build a trie on the reversed words then one of the vertices will be an ancestor of another one Now it s easy to estimate the number of states as the sum of depths of all vertices However since we look at ordered pairs of we should more or less double that amount That should be states at max This can probably pass with an optimal enough implementation We can do better though Let s merge the states and into one state The intuition is basically that you can swap the hints at will That makes the pairs unordered now there are up to pairs That surely will work fast enough The way to generate all the possible states is the following run a dfs bfs starting from that makes all valid transition and record all the states that can be visited While preparing the tests I only managed to get up to states and I would really love to hear an approach to either prove a tighter bound or to generate a test closer to the bound of 
74,You are given a chessboard consisting of rows and columns Rows are numbered from bottom to top from to Columns are numbered from left to right from to The cell at the intersection of the th column and the th row is denoted as Furthermore the th column is a special column Initially the board is empty There are changes to the board During the th change one pawn is added or removed from the board The current board is good if we can move all pawns to the special column by the followings rules Pawn in the cell can be moved to the cell or You can make as many such moves as you like Pawns can not be moved outside the chessboard Each cell can not contain more than one pawn The current board may not always be good To fix it you can add new rows to the board New rows are added at the top i e they will have numbers After each of changes print one integer the minimum number of rows which you have to add to make the board good ,For each pawn with initial position there exists a minimum index of row such that the pawn can reach the cell but cannot reach the cell It s easy to see that In the resulting configuration this pawn can occupy the cell or any other cell having Suppose the board consists of rows For each row the number of rows above it should be not less than the number of pawns that occupy the cells above it that is having greater than the index of that row because if this condition is not fulfilled we can t assign each pawn a unique cell If we denote the number of pawns that should go strictly above the th row as then for every row the condition must be met To prove that this condition is sufficient we may for example use Hall s theorem Okay now what about finding the minimum satisfying it Let s initially set to and for each row maintain the value of the minimum number of rows we have to add to our board so that the condition for the row is met we also have to maintain this value for auxiliary rows from to since some pawns cannot fit in the initial board at all Finding the minimum value we have to add to equals finding the maximum of all these values on some prefix we don t need to look at the values on some rows with large indices if there are no pawns after them so we need a maximum query on the segment where is the maximum index among all pawns and when a pawn is added or removed we should add or to all values on some suffix A segment tree with lazy propagation will do the trick solving the problem for us in ,Suppose and are even A necessary and sufficient condition of existence of the answer is that is even Let s prove the sufficient condition If the count of the horizontal dominoes is even then we can combine them and vertical dominoes to blocks of size the number of the vertical dominoes is even too if is even If and are even we can fill the table with these blocks The description of the locations of the dominoes may be printed as follows consider the table is a chessboard where a cell is a block of two dominoes Consider the leftmost topmost cell of the board is black If a cell of the board is black let s mark one of the dominoes of the block with the letter and the other one with the letter If a cell of the board is white let s mark one of the dominoes of the block with the letter and the other one with the letter There will be no situation that some two cells of the table are marked with one letter but belong to different dominoes Let s prove the necessary condition The number of cells in a column is even so the number of cells that belong to vertical dominoes is even because cells of each vertical domino may be either belong to the column or not belong at the same time So the number of cells that belong to horizontal dominoes is even Let s cross out all cells that belong to vertical dominoes and let s find the leftmost column having cells that haven t been crossed out It s the leftmost column with such cells so the pairwise cells of the non crossed out cells belong to the column to the right of the found one The number of such cells in the right column is equal to the number of found cells so it s even and the number of found horizontal dominoes is even too Let s cross out the found cells and the pairwise cells The number of non crossed out cells in the right column will be even The number of crossed out horizontal dominoes will be even too Let s repeat this procedure until all the dominoes will be crossed out In every step we have crossed out the even number of horizontal dominoes hence the total count of horizontal dominoes is even Suppose is odd hence is even In this case every column contains an odd number of cells whereas the number of cells that belong to vertical dominoes is even So the number of cells that belong to horizontal dominoes is odd Consider the leftmost column and find a cell of it that belongs to a horizontal domino it must be found because the number of such cells is odd so it isn t equal to Let s find the pairwise cell and cross out both cells Currently the two columns will have an even number of non crossed out cells Let s repeat the procedure until all columns will have even non crossed out cells We will cross out cells and dominoes So the necessary condition is that the number of horizontal dominoes is at least Let s extend the necessary condition with the following condition the value of is even Consider the table that we ve become after the previous procedure where each column has exactly one crossed out cell Let s start the procedure we ve done in the case of even both and The procedure can be started on our table because each column of the table has an even number of non crossed out cells As a result of the procedure we will cross out an even count of horizontal dominoes so the value of is even Let s build an answer if the conditions and is even are met Let s place in the topmost row horizontal dominoes and mark their cells as follows the first domino will be marked with the second one with the third one with and so on As the result the region of rows and columns will be unfilled Both values are even and the value of is even too So let s fill the region as if it s a separate table having even numbers of rows and columns As it was proved above it s possible to do The set of letters used for the region and set of the letters used for the topmost row don t have common elements so there will be no cells that are marked with one letter but belong to different dominoes The case of odd hence is even is similar to the previous one let s transpose the table it will have rows and columns swap the values of and solve the case above and transpose the table back to have rows and columns 
75,We will call a non empty string if it contains the same number of plus and minus signs For example strings and are balanced and strings and are not balanced We will call a string if the string can be made balanced by several possibly zero uses of the following operation replace two minus signs with one plus sign In particular every balanced string is promising However the converse is not true not every promising string is balanced For example the string is promising because you can replace two adjacent minuses with plus and get a balanced string or get another balanced string How many non empty substrings of the given string are promising Each non empty promising substring must be counted in the answer as many times as it occurs in string Recall that a substring is a sequence of consecutive characters of the string For example for string its substring are the string is a substring of itself and some others But the following strings are not its substring ,Note the fact that if the number of minus signs is greater than the number of plus signs by at least then there is sure to be a pair of standing next to minus signs according to the Dirichlet principle When we apply the operation of replacing two adjacent minus signs with a plus sign the balance the difference of plus signs and minus signs increases by Then we need to find the number of subsections such that the balance on them is a multiple of and non positive then we can apply the operations until the balance is The balance value on the segment equals the balance value on the right boundary minus the balance value on the left boundary i e we can find by prefix sums ,Let s iterate over the length of the first segment of the split Having fixed it we actually fixed the sum that needs to be collected on all other segments Since each element must belong to exactly one segment we can build other segments greedily If we have found a solution we will remember the length of the longest segment in it and try to update the answer We have possible lengths of the first segment for each of which we greedily built the answer for Thus the asymptotics of the solution will be 
76,Vasya wants to buy himself a nice new car Unfortunately he lacks some money Currently he has exactly burles However the local bank has credit offers Each offer can be described with three numbers and Offers are numbered from to If Vasya takes the th offer then the bank gives him burles at the beginning of the month and then Vasya pays bank burles at the end of each month for the next months including the month he activated the offer Several credits can be active at the same time It implies that Vasya pays bank the sum of over all the of active credits at the end of each month Vasya wants to buy a car in the middle of some month He just takes all the money he currently has and buys the car of that exact price Vasya don t really care what he ll have to pay the bank back after he buys a car He just goes out of the country on his car so that the bank can t find him anymore What is the maximum price that car can have ,Notice that if we take offer exactly months before we buy the car it will provide us with money at the time of the car purchase Moreover the only values of that make sense are This means we can immediately solve the problem via an algorithm for the assignment problem such as min cost flow or the Hungarian algorithm This has a runtime of or which manages to fit under the time limit with a good implementation Code 49033783 The better solution is to notice that for all offers where we don t use up all months it s best to sort them by so that the highest values of have the lowest values of This leads to a very nice DP solution 49035446 ,Let be the number of boxes with candies modulo Firstly the number of of boxes we can obtain using two boxes with remainder modulo is Secondly if is even then we also can obtain of boxes using two boxes with remainder modulo and its number is And for any other remainder from to the number of pairs of boxes is So if we sum up all these values the answer is this sum multiplied by two because we have to print the number of boxes not pairs 
77,Vova likes pictures with kittens The news feed in the social network he uses can be represented as an array of consecutive pictures with kittens of course Vova likes all these pictures but some are more beautiful than the others the th picture has beauty Vova wants to repost exactly pictures in such a way that each segment of the news feed of at least consecutive pictures has at least one picture reposted by Vova the sum of beauty values of reposted pictures is maximum possible For example if then Vova has to repost all the pictures in the news feed If then Vova can skip some pictures but between every pair of consecutive pictures Vova has to repost at least one of them Your task is to calculate the maximum possible sum of values of reposted pictures if Vova follows conditions described above or say that there is no way to satisfy all conditions ,Let s use dynamic programming described in the previous tutorial to solve this problem too But its complexity is so we have to improve some part of the solution Let s see how we do transitions in this dp for What can we do to optimize it is the constant and we have to take the maximum value among You will say segment tree I say no Not a segment tree Not a sparse table Not a cartesian tree or some other logarithmic data structures If you want to spend a lot of time to fit such solution in time and memory limits okay it is your choice I prefer the queue with supporting the maximum on it The last part of this tutorial will be a small guide about how to write and use the queue with supporting the maximum on it The first part of understanding this data structure is the stack with the maximum How do we support the stack with the maximum on it That s pretty easy let s maintain the stack of pairs when the first value of pair is the value in the stack and the second one is the maximum on the stack if this element will be the topmost Then when we push some value in it the first element of pair will be and the second one will be if is our stack and is the topmost element When we pop the element we don t need any special hacks to do it Just pop it And the maximum on the stack is always Okay the second part of understanding this data structure is the queue on two stacks Let s maintain two stacks and and try to implement the queue using it We will push elements only to and pop elements only from Then how to maintain the queue using such stacks The push is pretty easy just push it in The main problem is pop If is not empty then we have to pop it from But what do we do if is empty No problems let s just transfer elements of to pop from push to in order from top to bottom And don t forget to pop the element after this transfer Okay if we will join these two data structures we can see that we obtain exactly what we want Just two stacks with maximums That s pretty easy to understand and implement it The last part of the initial solution is pretty easy just apply this data structure in fact data structures to do transitions in our dynamic programming The implementation of this structure can be found in the authors solution Total complexity of the solution is ,Note the fact that if the number of minus signs is greater than the number of plus signs by at least then there is sure to be a pair of standing next to minus signs according to the Dirichlet principle When we apply the operation of replacing two adjacent minus signs with a plus sign the balance the difference of plus signs and minus signs increases by Then we need to find the number of subsections such that the balance on them is a multiple of and non positive then we can apply the operations until the balance is The balance value on the segment equals the balance value on the right boundary minus the balance value on the left boundary i e we can find by prefix sums 
78,You are given an integer Your task is to find a sequence of integers such that each is strictly greater than i e the product of this sequence is is divisible by for each from to is the possible i e the length of this sequence is the possible If there are several such sequences any of them is acceptable It can be proven that at least one valid sequence always exists for any integer You have to answer independent test cases ,Consider n in this canonical form p 1 a 1 cdot p 2 a 2 cdot ldots cdot p k a k just find the prime factorization of n Let i be such an index that a i is the maximum among all values of a Then the answer length can not exceed a i This is because if the answer has greater length then some number doesn t have p i in its representation thus there will be problems with divisibility because we are considering primes So let s create the answer of length a i consisting of p i Then let s just multiply the last element by all other primes in their degrees So we satisfied the divisibility rule and the length of the answer is the maximum possible ,Firstly we can understand that during each full cycle of from to we can fix each remainder only once Notice that when we add some then we fix the remainder and we don t need to fix elements which are already divisible by So let be the number of such elements for which the condition holds i e the number of such elements that we can fix if we add the value to them We can count this using some logarithmic data structure like in C So what s the number of full cycles It equals to the amount of most frequent element in minus one So the answer is at least And there can be one last cycle which will be incomplete So what is the remanining number of moves It equals to the maximum possible among all So if is the maximum such that then the answer is Time complexity 
79,Not so long ago Vlad had a birthday for which he was presented with a package of candies There were types of candies there are candies of the type Vlad decided to eat exactly one candy every time choosing any of the candies of a type that is currently the most frequent if there are several such types he can choose of them To get the maximum pleasure from eating Vlad to eat two candies of the same type in a row Help him figure out if he can eat all the candies without eating two identical candies in a row ,There will be three cases in total let s consider them on two types of candies then we will eat candies in this order then we will eat a candy of the type and then we will eat in this order almost as in the case above then we will eat a candy of the type but there will still be more of them than candies of the type and we will have to eat a candy of the type again So the answer is Now we prove that it is enough to check these conditions on two maximums of the array If the third condition is true the answer is obvious Otherwise we will by turns eat candies of the two maximum types until their number is equal to the third maximum after which we will by turns eat candies of these three types and so on ,First of all let s find out how to calculate This can be done greedily let s iterate from the higher denominations to the lower ones the number of banknotes of th type is equal to the value of here changes to reflect that we have already taken some banknotes that is we subtract from each time which is the same as taking modulo We can see that after we process the th type of banknotes the condition holds which means that the number of banknotes of th type does not exceed except in the case of Now we can find the minimum number such that Let be the number of banknotes that still remains to take initially equal to because we want to be at least Let s iterate from the lower denominations to the highest ones the number of banknotes of th type we take should be equal to the minimum of how many we need to take and how many we are allowed to take so as not to break the minimality of the function 
80,You are given an array consisting of integers Each is one of the six following numbers Your task is to remove the minimum number of elements to make this array An array of length is called if is divisible by and it is possible to split it into Examples of good arrays the whole array is a required sequence the first sequence is formed from first second fourth fifth seventh and tenth elements and the second one is formed from remaining elements Examples of bad arrays the order of elements should be exactly the length of the array is not divisible by the first sequence can be formed from first six elements but the remaining array cannot form the required sequence ,Let be the number of subsequences be the number of subsequences the number of subsequences and so on and is the number of completed subsequences Let s iterate over all elements of in order from left to right If the current element is then let s increase by one we staring the new subsequence Otherwise it is always better to continue some existing subsequence just because why not If the current element is then we can continue some subsequence if it is then we can continue some subsequence and the same for remaining numbers Let be the indexed position of the current element of in list Then the case is described above and in other case if then let s set and we continue some of existing subsequences The answer can be calculated as after all iterations ,Suppose we want to move an element from the prefix to the suffix if we need to move an element from the suffix to the prefix we can just reverse the array and do the same thing Suppose the resulting prefix will contain elements Then we need to check that the prefix with elements contains an element such that the sum of this prefix without this element is equal to the half of the sum of the whole array and then we can move this element to the suffix To check all the prefixes we can scan the array from left to right while maintaining the set of elements on the prefix and the sum of these elements 
81,Polycarp is a frequent user of the very popular messenger He s chatting with his friends all the time He has friends numbered from to Recall that a permutation of size is an array of size such that each integer from to occurs exactly once in this array So his recent chat list can be represented with a permutation of size is the most recent friend Polycarp talked to is the second most recent and so on Initially Polycarp s recent chat list looks like in other words it is an identity permutation After that he receives messages the th message comes from the friend And that causes friend to move to the first position in a permutation shifting everyone between the first position and the current position of by Note that if the friend is in the first position already then nothing happens For example let the recent chat list be if he gets messaged by friend then becomes if he gets messaged by friend then doesn t change if he gets messaged by friend then becomes For each friend consider all position he has been at in the beginning and after receiving each message Polycarp wants to know what were the minimum and the maximum positions ,So I have two slightly different approaches to the problem There is a straightforward no brain one and a bit smarter one The minimum place is the same in both solutions For the th friend it s just if he never moves and otherwise Obtaining the maximum place is trickier For the first approach take a look what happens with some friend after he gets moved to the first position Or what s more useful what happens after he gets moved to the first position and before he gets moved again afterwards or the queries end Notice how every other friend is to the right of him initially Thus if anyone sends a message then the position of the friend increases by one However if that friend moves again nothing changes That should remind of a well known problem already You are just required to count the number of distinct values on some segments The constraints allow you to do whatever you want segtree with vectors in nodes Mo persistent segtree I hope ML is not too tight for that Unfortunately for each friend we have missed the part before his first move In that case for each you need to count the number of distinct values greater than as only friends with greater index will matter Luckily you can do it in a single BIT Let th its value be set to zero if the friend hasn t sent messages and one otherwise Let s process messages from left to right If the friend sends a message for the first time then update the BIT with in his index and update his answer with the suffix sum of values greater than his index Finally there are also friends who haven t sent messages at all As we have built the BIT already the only thing left is to iterate over these friends and update the answers for them with a suffix sum Overall complexity The attached solutions are and The second solution requires a small observation to be made Notice that for each friend you can only check his position right before his moves and at the end of the messages That works because the position can decrease only by his move so it s either increases or stays the same between the moves So let s learn to simulate the process quickly The process we are given requires us to move someone to the first position and then shift some friends Let s not shift And let s also reverse the list it s more convenient to append instead of prepending So initially the list is and the message moves a friend to the end of the list Allocate positions in a BIT for example Initially the first positions are taken the rest are free mark them with ones and zeroes respectively For each friend his position in this BIT is known initially they are because we reversed the list On the th message sent count the number of taken positions to the right of set in update and set in And don t forget to update each friend s maximum after all the messages are sent that is the number of taken positions to the right of his final one as well Overall complexity ,Let s presume that x ge y Then there are two cases in the problem If a a le b then we have to x y times perform the first operation So the answer is x y cdot a If a a b then we have to y times perform the second operation and pass the remaining distance by performing the first operation So the answer is y cdot b x y cdot a 
82,You have a multiset containing several integers Initially it contains elements equal to elements equal to elements equal to You may apply two types of operations choose two integers and then remove one occurrence of one occurrence of one occurrence of from the multiset This operation can be applied only if each number from to occurs at least once in the multiset choose two integers and then remove occurrences of from the multiset This operation can be applied only if the multiset contains at least occurrences of What is the minimum number of operations required to delete all elements from the multiset ,Notice that we can reorder the operations in any way we want without affecting the result So let s do all of the first type operations before the second type operations Then it s clear that the number of second type operations we ll need is the number of nonzero elements left over after the first type operations So we just want to choose first type operations to minimize the number of first type operations plus the number of nonzero elements left after we re done Let s say we have an array where is the minimum value if there is a tie you can pick any tied index I only have a messy proof for this at the moment but it turns out we only need to consider two options either take all second type operations or use first type operations on the entire array and then recursively solve and separately This leads to a simple solution 90999997 Note that by using RMQ we can improve this to or even The idea is very similar to the solution to problem G here ,At first let s reverse arrays and Now array is sorted in descending order Now let s find minimum index such that If there is no such index or if then the answer is because minimum on any prefix of array will never be equal to Otherwise let s find the minimum index such that If there is no such index or if then the answer is Also let s find the minimum index such that it can t be greater than The first subarray starts in position and ends in any position because if it ends in position or further then the minimum in the first subarray is greater than So there are ways to split subarrays and A similar approach can be used to calculate the number of ways to split the second and third subarrays and so on After all you have to check that minimum in the last subarray is equal to otherwise the answer is 
83,Polycarp found on the street an array of elements Polycarp invented his criterion for the beauty of an array He calls an array beautiful if at least one of the following conditions must be met is divisible by or is divisible by For example if and then the array is not beautiful for and none of the conditions above is met and then the array is beautiful and then the array is not beautiful for and none of the conditions above is met Ugly arrays upset Polycarp so he wants to remove some elements from the array so that it becomes beautiful Help Polycarp determine the smallest number of elements to remove to make the array beautiful ,Let s calculate for each number how many times it occurs in the array Let s denote this number as Let s use the dynamic programming method Let be equal to the maximum number of numbers not greater than such that for each pair of them one of the conditions above is satisfied More formally if then there exists numbers from the array such that for all one of the conditions above is satisfied Then to calculate you can use the following formula Note that to calculate you need to go through the list of divisors of For this we use the sieve of Eratosthenes ,Firstly if the array already has an odd sum the answer is Otherwise we need to change the parity of the sum so we need to change the parity of some number We can do in only when we have at least one even number and at least one odd number Otherwise the answer is 
84,The math faculty of Berland State University has suffered the sudden drop in the math skills of enrolling students This year the highest grade on the entrance math test was 8 Out of 100 Thus the decision was made to make the test easier Future students will be asked just a single question They are given a sequence of integer numbers each number is from to and for each valid The th number represents a type of the th figure circle isosceles triangle with the length of height equal to the length of base square The figures of the given sequence are placed somewhere on a Cartesian plane in such a way that th figure is inscribed into the th one each triangle base is parallel to OX the triangle is oriented in such a way that the vertex opposite to its base is at the top each square sides are parallel to the axes for each from to figure has the maximum possible length of side for triangle and square and maximum radius for circle The task is to calculate the number of points not necessarily with integer coordinates where figures touch The trick is however that the number is sometimes infinite But that won t make the task difficult for you will it So can you pass the math test and enroll into Berland State University ,Firstly let s find out when the answer is infinite Obviously any point of intersection is produced by at least a pair of consecutive figures Take a look at every possible pair and you ll see that only square inscribed in triangle and vice verse produce infinite number of points in intersection The other cases are finite From now we assume that initial sequence has no 2 and 3 next to each other Basically it s all triangles and squares separated by circles If the task was to count all pairs of intersecting figures the solution will be the following Square next to circle gives 4 points triangle next to circle gives 3 points Unfortunately the task asked for distinct points Notice that there is a single subsegment which can produce coinciding points square circle triangle So you have to find each triplet 3 1 2 and subtract their count from the sum Overall complexity ,We are going to calculate the answer as follows for every point let be the number of points such that i e the number of points that are to the right of and have distance at most from it Then the number of beautiful triples where is the leftmost point is We can sum these values over all points to get the answer so the solution should somehow maintain and update the sum of these values efficiently Let s see what happens when we add a new point or remove an existing point For all points to the left of it with distance no more than the value of increases or decreases by So we need some sort of data structure that allows adding subtracting on segment and maintains the sum of This looks like a lazy segment tree but updating the sum of can be tricky One way to do this is to notice that So maybe we can maintain the sum of and the sum of on the segment It turns out we can The model solution does this as follows the leaf of the segment tree corresponding to the position stores a vector with three values The inner nodes store the sums of these vectors in the subtree We can find a matrix which when multiplied by gets the vector and the inverse matrix to it Then adding to on segment means multiplying all vectors on segment by that matrix and subtracting means multiplying by the inverse matrix and since matrix multiplication is both associative and distributive the segment tree can handle these queries Okay there s only one small issue left right now our structure can store the sum of and over all possible points we build it on segment for example but we only need the sum over points One way to handle it is to use a flag for each leaf of the segment tree and pull the value up from the leaf only if this flag is true We will need a function that changes the value of this flag for a single leaf but it s not very different from a function that changes one value in a lazy segment tree Time complexity of the solution is where is the maximum coordinate of the point although the constant factor of the described approach is fairly large since it involves matrix multiplications You can improve the constant factor by getting rid of the matrices as mentioned earlier 
85,Sho has an array consisting of integers An operation consists of choosing two distinct indices and and removing and from the array For example for the array Sho can choose to remove indices and After this operation the array becomes Note that after any operation the length of the array is reduced by two After he made some operations Sho has an array that has only elements In addition he made operations such that the resulting array is the possible More formally the array after Sho has made his operations respects these criteria No pairs such that and exist The length of is maximized Output the length of the final array ,Note that the size of the array doesn t change parity since it always decreases by Let s count the number of distinct elements call it If is the same parity as the length of the array then we can make sure all of these distinct elements stay in the array by removing two elements at a time Otherwise isn t the same parity as Then is the same parity as and we can make sure distinct elements stay in the array by removing two elements at a time So the answer is if and have the same parity and otherwise For example has So and have the same parity and we can get all distinct numbers by removing Time complexity or depending on the implementation ,Let s notice that if we multiply the numbers then the power of two of the product is equal to the sum of the powers of two in each of the numbers Let s calculate the initial sum of the powers of twos in the product This can be done as follows let s take the element and divide it by as long as we can while remembering to increase our counter by the number of occurrences of a power of two Now let s move on to operations and note that choosing the index will increase the degree of occurrence of two by a fixed number that is it does not matter when to apply this operation Choosing an index will increment the counter by a number such that is divisible by but not by you can find this again by dividing by while we can Since we want to minimize the number of operations used at each moment of time we will try to use an index that increases the counter by the largest number To do this it is enough to sort the indices by this index of increase and take them greedily from the largest increase to the smallest We get the solution in 
86,You are given positive integer number You should create such sequence of positive numbers that their sum is equal to and greatest common divisor is maximal Greatest common divisor of sequence is maximum of such numbers that every element of sequence is divisible by them If there is no possible sequence then output ,Notice that GCD of the resulting sequence is always a divisor of Now let s iterate over all divisors up to Current divisor is One of the ways to retrieve resulting sequence is to take their sum is The last number is You should check if is the sum of arithmetic progression its equal to Don t forget that you should consider and if you check divisors up to Take maximum of possible divisors or output if there were no such divisors Overall complexity ,The problem consists of two parts what do we want to calculate and how to calculate it What do we want to calculate There are several ways to figure it out At first you could have met this problem before and all you need is to remember a solution At second you can come up with the solution in a purely theoretical way Hasse diagram can help with it greatly Let s define as the number of primes in prime factorization of For example and If you look at Hasse diagram of you can see that all divisors with lies on level If is divisible by then so all divisors on the same level don t divide each other Moreover the diagram somehow symmetrical about its middle level and sizes of levels are increasing while moving to the middle It gives us an idea that the answer is the size of the middle level i e the number of divisors with The final way is just to brute force the answers for small s and find the sequence in OEIS with name A096825 where the needed formulas are described The second step is to calculate the number of divisors with Suppose we have distinct primes and the number of occurences of is equal to Then we need to calculate pretty standard knapsack problem where you need to calculate number of ways to choose subset of size where you can take each up to times Or formally number of vectors with and Calculating the answer using will lead to time limit so we need to make the following transformation Let s build for each a polynomial Now the answer is just a coefficient before in product Note that the product has degree so we can multiply polynomials efficiently with integer FFT in the special order to acquire time complexity There several ways to choose the order of multiplications At first you can at each step choose two polynomials with the lowest degree and multiply them At second you can use the divide and conquer technique by dividing the current segment in two with pretty same total degrees At third you can also use D n C but divide the segment at halves and it seems still to be in total What about the proof of the solution Thanks to tyrion for the link at the article https pure tue nl ws files 4373475 597494 pdf The result complexity is time and space if carefully written Note that the hidden constant in integer FFT is pretty high and highly depends on the implementation so it s possible for poor implementations not to pass the time limit 
87,Recently Vasya decided to improve his pistol shooting skills Today his coach offered him the following exercise He placed cans in a row on a table Cans are numbered from left to right from to Vasya has to knock down each can exactly once to finish the exercise He is allowed to choose in which he will knock the cans down Vasya knows that the of the th can is It means that if Vasya has already knocked cans down and is now about to start shooting the th one he will need shots to knock it down You can assume that if Vasya starts shooting the th can he will be shooting it until he knocks it down Your task is to choose such an order of shooting so that the number of shots required to knock each of the given cans down exactly once is minimum possible ,We can see that because the multiplier in the formula is the position of the number and we want to minimize the sum of such formulas the following greedy solution comes up to mind because we want to count greater values as earlier as possible let s sort the array in non increasing order saving initial indices of elements calculate the answer and print the permutation of indices in order from left to right ,This tutorial is based on the previous problem easy version tutorial At first I want to say I know that this problem and this approach can be implemented in with segment tree So we iterate over all supposed maximums in the array and trying to apply all segments not covering our current element How do we can calculate the answer for element if this element is the supposed maximum Let s divide all segments we apply into two parts the first part consists of segments such that their right endpoints is less than the current position and the second part consists of segments such that their left endpoints is greater than the current position Then let s independently calculate answers for the left and for the right parts and merge them to obtain the answer I will consider only first part of the solution first part of segments because the second part is absolutely symmetric with it Let s maintain the minimum value on prefix of the array let it be and initially it equals to maintain the array of length initially its values are and means the answer if the th element of the array will be supposed maximum and the array of length where will be the value for which we decrease the th element in other words the number of segments we apply to the th element What do we do for the current position Firstly let s update the answer for it with the value in other words set Then let s apply all segments with right endpoints equals to the current position straight forward and update the value with each new value of covered elements Just iterate over all positions of each segment ends in the current position make and set And don t forget to update the value with the value after all changes because we need to update this value with each element not covered by segments too So then let s do the same from right to left and then will mean the answer if the th element is the supposed maximum in the resulting array Then we can find any position of the maximum in the array and apply all segments which don t cover this position What is time complexity of the solution above We iterate over all elements in the array this is and apply each segment in so the final time complexity is 
88,You are given a tree consisting of vertices A tree is a connected undirected graph with edges Each vertex of this tree has a color assigned to it if the vertex is white and if the vertex is black You have to solve the following problem for each vertex what is the maximum difference between the number of white and the number of black vertices you can obtain if you choose some subtree of the given tree that the vertex The subtree of the tree is the connected subgraph of the given tree More formally if you choose the subtree that contains white vertices and black vertices you have to maximize ,This problem is about the rerooting technique Firstly let s calculate the answer for some fixed root How can we do this Let be the maximum possible difference between the number of white and black vertices in some subtree of yes the subtree of the rooted tree i e and all its direct and indirect children that the vertex We can calculate this dynamic programming by simple dfs for the vertex it will look like this Okay we can store the answer for the root somewhere What s next Let s try to change the root from the vertex to some adjacent to it vertex Which states of dynamic programming will change Only and Firstly we need to remove the child from the subtree of the vertex Then we need to attach the vertex and make it a child of the vertex Then we need to run this process recursively from store the answer reroot the tree and so on and when it ends we need to rollback our changes Now is the root again and we can try the next child of as the root Time complexity ,For each vertex we will build the following structure for its children the segment for the second child is nested in the segment for the first child the nested for the third child is nested in the segment for the second child and so on and the children of different vertices do not intersect at all Let s solve the problem recursively for each of the children create a set of segments with endpoints from to where is the size of the subtree After that combine them To do this you can use small to large technique and change the coordinates of the segments or use the necessary offset in the function call for the next child After that it remains to cross children s segments with the segment of the vertex itself To do this you can move the right ends of all segments of the children by to the right and add a segment that starts before the first one and ends immediately after the last one 
89,Vasya has a grid with rows and columns He colours each cell red green or blue Vasya is colourblind and can t distinguish green from blue Determine if Vasya will consider the two rows of the grid to be coloured the same ,Here are two solutions Iterate through the string character by character If then otherwise if or then or If the statement is false for any the answer is Otherwise it is Replace all with since they are the same anyway Then just check if the two strings are equal In either case the complexity is per testcase ,Consider case separately and print the sting of zeros or ones correspondingly Now our string has at least one pair or Let s form the pattern of length So all substrings with the sum are satisfied Now let s insert zeros before the first zero in this way we satisfy the substrings with the sum And then just insert ones before the first one in this way we satisfy the substrings with the sum 
90,You are given two positive integers and In one move you can in the following way Choose any positive integer and replace with choose any positive integer and replace with You can perform as many such operations as you want You can choose the same numbers and in different moves Your task is to find the minimum number of moves required to obtain from It is guaranteed that you can always obtain from You have to answer independent test cases ,If then the answer is Otherwise if and is even or and is odd then the answer is Otherwise the answer is you can always make case in one move ,It s not hard to come up with a solution if you just imagine how gon looks when is even The solution is to rotate gon in such way that several its sides are parallel to sides of the square And the answer is equal to the distance from center to any side multiplied by two or 
91,You are given an undirected complete graph on vertices A complete graph is a graph where each pair of vertices is connected by an edge You have to paint the edges of the graph into two colors red and blue each edge will have one color A set of vertices is if for every pair of vertices such that and there exists a path from to that goes only through red edges and vertices from Similarly a set of vertices is if for every pair of vertices such that and there exists a path from to that goes only through blue edges and vertices from You have to paint the graph in such a way that there is at least one red edge there is at least one blue edge for each set of vertices such that is either red connected or blue connected but Calculate the number of ways to paint the graph and print it modulo , Okay we need more definitions Here they come This way we can transform the formula for to the following Or even this since This is almost the convolution of the sequences and with a bit extra additional operations after the convolution so to compute the sequence we just need to compute the sequences and and then calculate their convolution with NTT All that s left is to multiply every element by the corresponding factorial But wait that s not so easy In order to calculate and we need to know Note that we can ignore the fact that and appear in the formula for since they are multiplied by so at least we don t have a dependency cycle Unfortunately we cannot just straightforwardly use convolution if we don t know the sequences and The model solution handles it using the following approach Let s generate and in parallel on the th iteration calculate then calculate and using it And we will calculate the convolution of the sequences and Suppose we want to calculate and the last time we calculated the convolution of and was after the iteration Back then we knew all elements from to and from to So the th term in the convolution of and contained the sum of over all such that and So in order to calculate we have to pick this value from the convolution and then add the sum of over all such that or and there are such values Suppose we compute the convolution every iterations Then the maximum value of is and every value of is calculated in We also make convolutions so the total complexity of this solution will be which can be transformed into if we pick ,Let s work with the formula a bit Let then the formula becomes Considering thus is strictly increasing and has its minimum at So the solution will be to sort the list extract the pairs of sticks of equal length and check only neighbouring pairs in sorted order for the answer Overall complexity 
92,There are boxes with different quantities of candies in each of them The th box has candies inside You also have friends that you want to give the candies to so you decided to give each friend a box of candies But you don t want any friends to get upset so you decided to eat some possibly none candies from each box so that all boxes have the same quantity of candies in them Note that you may eat a different number of candies from different boxes and you cannot add candies to any of the boxes What s the minimum total number of candies you have to eat to satisfy the requirements ,Because we can only eat candies from boxes The only way to make all boxes have the same quantity of candies in them would be to make all candies contain a number of candies equal to the minimum quantity of candies a box initially has So we should find this minimum number let s denote it as and then for each box there should be eaten candies So the answer would be the sum of over all s ,There will be three cases in total let s consider them on two types of candies then we will eat candies in this order then we will eat a candy of the type and then we will eat in this order almost as in the case above then we will eat a candy of the type but there will still be more of them than candies of the type and we will have to eat a candy of the type again So the answer is Now we prove that it is enough to check these conditions on two maximums of the array If the third condition is true the answer is obvious Otherwise we will by turns eat candies of the two maximum types until their number is equal to the third maximum after which we will by turns eat candies of these three types and so on 
93,You want to perform the combo on your opponent in one popular fighting game The combo is the string consisting of lowercase Latin letters To perform the combo you have to press all buttons in the order they appear in I e if then you have to press then and again You know that you will spend wrong tries to perform the combo and during the th try you will make a mistake right after th button i e you will press first buttons right and start performing the combo from the beginning It is guaranteed that during the th try you press all buttons right and finally perform the combo I e if and then the sequence of pressed buttons will be you re making a mistake and start performing the combo from the beginning you re making a mistake and start performing the combo from the beginning Your task is to calculate for each button letter the number of times you ll press it You have to answer independent test cases ,We can consider all tries independently During the th try we press first buttons so it makes on the prefix of length So the th character of the string will be pressed the number of plus times We can use sorting and some kind of binary search to find this number for each character but we also can build suffix sums to find all required numbers We can build suffix sums using the following code vector int cnt n for int i 0 i m i cnt p i for int i n 1 i 0 i cnt i 1 cnt i So as you can see the th element of will add in each position from to So we got what we need After that we can calculate the answer for each character in the following way vector int ans 26 for int i 0 i n i ans s i a cnt i 1 Time complexity or ,Since it does not take time to place your hand over the first letter you need to calculate the sum of the distances between the keyboard keys corresponding to each pair of adjacent letters of the word that is where is the position of the keyboard key corresponding to the letter In order to calculate this sum let s just iterate through the word with the loop and find the differences between the positions of and on the keyboard To find the position of a character on the keyboard you could either use the built in strings functions such as in Python or in C or precalculate each letter s position on the keyboard into a separate array using another loop over a keyboard 
94,In Berland different types of banknotes are used Banknotes of the th type have denomination burles burles are the currency used in Berland the denomination of banknotes of the first type is exactly Let s denote as the minimum number of banknotes required to represent exactly burles For example if the denominations of banknotes used in Berland are and then banknotes with denomination of burle and banknotes with denomination of burles can be used to represent exactly burles and there s no way to do it with fewer banknotes For a given integer find the minimum positive number of burles that cannot be represented with or fewer banknotes that is ,First of all let s find out how to calculate This can be done greedily let s iterate from the higher denominations to the lower ones the number of banknotes of th type is equal to the value of here changes to reflect that we have already taken some banknotes that is we subtract from each time which is the same as taking modulo We can see that after we process the th type of banknotes the condition holds which means that the number of banknotes of th type does not exceed except in the case of Now we can find the minimum number such that Let be the number of banknotes that still remains to take initially equal to because we want to be at least Let s iterate from the lower denominations to the highest ones the number of banknotes of th type we take should be equal to the minimum of how many we need to take and how many we are allowed to take so as not to break the minimality of the function ,Let s consider the optimal answer Suppose we take items of weight Let be the least common multiple of all weights that is Then we may represent as where Let s do the following trick we will take items of weight and all the remaining items of this weight can be merged into some items of weight Then we can write a brute force solution that picks less than items of each weight transforms the remaining ones into items of weight as much as possible and when we fix the whole subset adds maximum possible number of items of weight to the answer This works in something like operations which is too much How can we speed it up Rewrite it using dynamic programming When we have fixed the number of items we take from first sets the only two things that matter now are the current total weight of taken items and the number of items of weight we can use and it s obvious that the more items of weight we can use the better So let s write the following dynamic programming solution maximum number of items of weight we can have if we processed first types of items and current total weight is Note that the second dimension should have size 
95,Recently you found a bot to play Rock paper scissors with Unfortunately the bot uses quite a simple algorithm to play he has a string of length where each letter is either or While initializing the bot is choosing a starting index and then it can play any number of rounds In the first round he chooses Rock Scissors or Paper based on the value of if is equal to the bot chooses Rock if is equal to the bot chooses Scissors if is equal to the bot chooses Paper In the second round the bot s choice is based on the value of In the third round on and so on After the bot returns to and continues his game You plan to play rounds and you ve already figured out the string but still don t know what is the starting index But since the bot s tactic is so boring you ve decided to find choices to each round to maximize the average number of wins In other words let s suggest your choices are and if the bot starts from index then you ll win in rounds Find such that is maximum possible ,Let s look at the contribution of each choice to the total number of wins we can look at total instead of average since average is equal to total divided by For example let s look at the first choice in we compare with in with in with and so on In the result we compare with all once So to maximize the total sum we need to choose that beats the maximum number of or in other words let s find the most frequent character in and choose that beats it Okay we found the optimal But if we look at the contribution of any other we can note that we compare any with all once So we can choose all equal to which is equal to the choice that beats the most frequent choice in ,1278F CardsFirst of all I would like to thank Errichto for his awesome lecture on expected value part 1 part 2 This problem was invented after I learned the concept of estimating the square of expected value from that lecture and the editorial uses some ideas that were introduced there Okay now for the editorial itself We call a number as good if and the th shuffle of the deck resulted in a joker on top from our problem is the number of such good numbers We can represent as the number of pairs such that every element of the pair is a good number as the number of triples and so on is the number of tuples such that each element of a tuple is a good number So we can rewrite the expected value of as the expected number of such tuples or the sum of over all tuples where is the probability that consists of good numbers How to calculate the probability that is a good tuple Since all shuffles of the deck result in a joker with probability should be equal to but that is true only if all elements in are unique How to deal with tuples with repeating elements Since all occurences of the same element are either good or bad with probability of being good the correct formula for is where is the number of distinct elements in the tuple Okay then for each we have to calculate the number of tuples with exactly distinct elements To do that we use dynamic programming let be the number of tuples with exactly distinct elements Each transition in this dynamic programming solution models adding an element to the tuple if we want to compute the transitions leading from we either add a new element to the tuple there are ways to choose it and we enter the state or we add an already existing element there are ways to choose it and we enter the state Overall complexity is or depending on your implementation 
96,Tanya has candies numbered from to The th candy has the weight She plans to eat exactly candies and give the remaining candy to her dad Tanya eats candies in order of increasing their numbers Your task is to find the number of such candies let s call these candies that if dad gets the th candy then the sum of weights of candies Tanya eats in even days will be equal to the sum of weights of candies Tanya eats in odd days Note that at first she will give the candy after it she will eat the remaining candies one by one For example and weights are Consider all possible cases to give a candy to dad Tanya gives the st candy to dad the remaining candies are She will eat in the first day in the second day in the third day So in odd days she will eat and in even days she will eat Since this case shouldn t be counted to the answer this candy isn t Tanya gives the nd candy to dad the remaining candies are She will eat in the first day in the second day in the third day So in odd days she will eat and in even days she will eat Since this case shouldn t be counted to the answer this candy isn t Tanya gives the rd candy to dad the remaining candies are She will eat in the first day in the second day in the third day So in odd days she will eat and in even days she will eat Since this case to the answer this candy is Tanya gives the th candy to dad the remaining candies are She will eat in the first day in the second day in the third day So in odd days she will eat and in even days she will eat Since this case to the answer this candy is In total there cases which should counted these candies are so the answer is ,Let s maintain four variables and which will mean the sum of with odd on prefix even on prefix odd on suffix and even on suffix Initially and are equals to the sum of with odd in a whole array and equals to the sum of with even in a whole array Let s iterate from left to right over all elements of the array Let s consider the current element If is even then set otherwise let s set Then let s consider we give the current candy to dad Then we have to increase the answer if and Then if is even then let s set otherwise let s set ,Consider a naive solution Iterate over all pairs and apply all operations The complexity is The constraints obviously imply that it s too much What can we cut from it Well surely will still remain there Both of and also should So we can probably only hope to turn this into Let s try that Notice that no matter what operations are applied never changes You can also peek at the examples and see that the patterns are suspiciously diagonal shaped in the matrix Let s try to solve the problem by fixing and calculating the answer for all values of I will call the fixed variable Consider case where and Here all can fit into both and so we can avoid caring about one restriction on the operations We ll think what to do with large volumes later If there are no operations the answer for each initial is for all from to Now consider an operation for some For nothing changes Actually for all the result of the operation is the same as for Hmm but if the result is the same it will remain the same until the end Same from the other side The answers for and also get merged together To me it kind of looks like a primitive form of DSU on these volume states you merge some prefix of the answers together and merge some suffix of the answers together If the state was merged to either or then it s easy to calculate the actual answer for that state What happens to the remaining states Well since they weren t merged anywhere the operation for them was applied fully if was requested all was poured How to deal with multiple operations then I propose the following idea When applying an operation we only want to know which of the previously non merged states become merged Basically we can squish all previous operations into one just sum up the signed amounts of water Since they all were applied fully to the non merged states it s completely valid After the squish check for the new merges You can actually study the structure of the answers and see that they go like that for some values of and such that It isn t that important but it makes the code easier You can basically calculate the length of the merged prefix the length of the merged suffix then calculate the answer at the end of the prefix in and restore all answers from it We neglected larger values of earlier time to return to them Another kind of limit to each operation is added when extra water doesn t fit in another tank Well it doesn t change that much It only makes more prefix suffix merges To come up with the exact formulas I followed these points Something merges on an operation when any of these holds not enough water in the first tank not enough space in the second tank not enough water in the second tank not enough space in the first tank Replace all with and you get the constraints for prefix and suffix merges Overall complexity 
97,The array with integers is given Let s call the sequence of one or more consecutive elements in Also let s call the segment if it contains no more than different values Find any longest good segment As the input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,This problem is given because on the Codeforces pages we often see questions like What is the method of the two pointers This problem is a typical problem that can be solved using two pointers technique Let s find for each left end the maximal right end that is a good segment Note if is a good segment then is also a good segment So the search of the maximal right end for we can start from the maximal right end for The only thing that we should do is to maintain in the array for each number the number of it s occurrences in the current segment and the number of different numbers in We should move the right end until the segment became bad and then move the left end Each of the ends will be moved exactly times ,Let s fix the length of the first block iterate through i from 0 to n 3 Let s also try to maximize the length of the third block using the second pointer So initially the length of the first block is 1 and the maximum in the block is a 0 after that its length will be 2 and the maximum will be max a 0 a 1 and so on Let s move the left border of the third block r while a r le a 0 and the second block have at least one element After we expanded the third block consider some cases if its maximum is less than a 0 then we don t need to consider this partition we expanded the third block as much as we can but didn t find the required maximum Otherwise its maximum fits our conditions Then let s find the minimum in the second block Let it be mn If mn mx this partition is also bad If mn mx this partition is good and we can just print it Otherwise mn mx and we need to fix the second block somehow I claim that we only need to expand it by at most one element Let s see why is it true Consider we want to expand it to the right the other case just uses the same logic If we expanded our block by one element to the right and the new value in it is less than mx then this partition is bad and we can not use it this is also the reason why we are trying to maximize the length of the third block Otherwise this value is always mx because the first and the third blocks didn t have values greater than mx There are some cases in the implementation we need to consider carefully first we need to find the minimum in the second block fast enough This can be done if we store it as a multiset set with repetitions Second we can remove the only maximum in the third or the first block by expanding the second one This can be handled easily if we just store all three blocks not only the second one as multisets And the last case is that we sometimes need to move the left border of the third block to the right This happens when we expand the first block and the second block becomes empty So this happens only O n times in total Total time complexity of this solution is O n log n There is also another solution from Gassa Let us start solving by asking the following question in which segments will the maximal values end up Consider the maximum value m in the whole array If there are at least three of them a valid answer is to pick any maximum except the first and the last as the middle segment For example m 3 can be partitioned as or as where the middle segment is marked with square brackets Otherwise all m should end up in the middle segment so that maximums to the left and to the right are less For example in we have to put both threes into the middle segment Let us now calculate the minimum value v on the middle segment considering the numbers between those equal to m For example in the value v min 3 1 3 1 All numbers greater than v should also go into the middle segment and everything between them which can result in v decreasing even more We have to expand the borders of the middle segment until the minimum value is such v that there are only values not greater than v left outside Continuing with the example we see that in the middle segment should be expanded to Conversely if the maximum m was unique then v m and we didn t have to expand the middle segment at this stage For example in the current state is If the maximums to the left and to the right are exactly v we found an answer Otherwise any possible middle segment contains the middle segment that we now got So we have to expand the middle segment either to the left or to the right As a result the value v may become smaller which can cause another expansion What s left is to decide where to expand when we have a choice We would like to do it greedily Indeed consider three values the minimum on middle segment v the maximum on left segment u and the maximum on right segment w When we expand the middle segment each of them can only decrease And if we find an answer the equation u v w will be satisfied So as we make the minimum of these three values smaller we have less and less opportunities to make them equal Thus we can pick the side of expansion after which the value min u v w is larger and if these are equal pick any For example in the state we have u 3 v 4 and w 3 If we expand to the left we get where u 1 v 3 and w 3 If we expand to the right we get where u 3 v 2 and w 3 Our algorithm will pick expanding to the right however there is no valid answer in this example anyway Implementation let us precalculate the maximums on all prefixes and all suffixes of the array Then we can expand the middle segment by one element in O 1 and the total running time is linear 
98,A tree is a connected undirected graph without cycles Note that in this problem we are talking about not rooted trees You are given four positive integers and Construct a tree such that it contains vertices numbered from to the distance length of the shortest path from vertex to vertex is distance from vertex to vertex is the distance from vertex to vertex is Output any tree that satisfies all the requirements above or determine that no such tree exists ,If the answer exists you can hang the tree by some vertex such that the distances and can be expressed through the sums of distances to vertices and Then from the system of equations we express the required values of distances to vertices and construct a suitable tree If the distance to a vertex is then that vertex is the root There cannot be two roots nor can there be negative distances If none of the vertices of is the root then make vertex the root Next we build the required tree add the required number of unique vertices on the path from the root to vertices Note also that if the sum of distances is greater than or equal to then we cannot build the tree either The remaining vertices can be simply joined to the root ,First of all we don t like the fact that importance values can be integers up to it is kinda hard to work with them Let s rephrase the problem The highest bit set to in the importance value denotes the maximum in the subtree rooted at the auxiliary lamp for the wire So we sort the wires according to the maximums in their subtrees To break ties we could consider the second maximum then the third maximum but that s not convenient We can use something much easier suppose there are two vertices with the same maximum in their subtrees these vertices belong to the path from the root to the maximum in their subtrees and the one which is closer to the root has the greater importance value So to get the order described in the problem statement we could sort the vertices according to the maximum in their subtrees and use depth as the tie breaker What does this imply All vertices of some prefix are ancestors of vertex so some prefix denotes the path from the root to excluding itself Then there are some values describing the path from some already visited vertex to if was not met before then to and so on How can we use this information to restore the original tree is the root obviously Then the sequence can be separated into several subsegments each representing a vertical path in the tree and each vertex is the parent of the next vertex in the sequence if they belong to the same subsegment How can we separate these vertices into subsegments and how to find the parents for vertices which did not appear in the sequence at all Suppose some vertex appears several times in our sequence The first time it appeared in the sequence it was in the middle of some vertical path so the previous vertex is its parent and every time this vertex appears again it means that we start a new path and that s how decomposition into paths is done Determining the parents of vertices that did not appear in the sequence is a bit harder but can also be done Let s recall that our sequence is decomposed into paths from root to from some visited vertex to from some visited vertex to and so on so each time the path changes it means that we have found the maximum vertex among unvisited ones So we should keep track of the maximum vertex that was not introduced in the sequence while we split it into paths and each time a path breaks it means that we found the vertex we were keeping track of Overall this solution can be implemented in 
99,For a sequence of integers between and inclusive denote as the number of distinct subsequences of including the empty subsequence You are given two positive integers and Let be the set of all sequences of length consisting of numbers from to Compute the sum over all in modulo ,Let s consider some subsequence with the length the empty subsequences we will count separately by adding the valye at the end and count the number of sequences that contains it We should do that accurately to not count the same sequence multiple times Let be the fixed subsequence In the original sequence before the element can be some other elements but none of them can be equal to because we want to count the subsequence exactly one time So we have variants for each of the elements before Similarly between elements and can be other elements and we have choices for each of them And so on After the element can be some elements suppose there are such elements with no additional constraints so we have choices for each of them We fixed the number of elements at the end so we should distribute numbers between numbers before between and ldots between and Easy to see that we have choices to do that it s simply binomial coefficient with allowed repititions The number of sequences equals to So the answer is Easy to transform the last sum to the sum Note the last inner sum can be calculating using the formula for parallel summing So the answer equals to Also we can get the closed formula for the last sum to get logarithmic solution but it is not required in the problem ,Firstly let s understand that the sum of the segment is zero if is zero in other words where is the sum of the first elements Let s iterate over elements from left to right and add all prefix sums in the set If we get the sum that is already in the set we get some segment with sum and we need to fix it somehow Let s insert some huge number before the current element in such a way that all prefix sums starting from the current element to the end will be significantly bigger than all prefix sums to the left In words of implementation we just get rid of all prefix sums to the left clear the set and continue doing the same process starting from the current element so we just cut off the prefix of the array This way is optimal because we remove all segments with sum ending at the current element using only one insertion and we need to use at least one insertion to do that Time complexity 
100,Sean is trying to save a large file to a USB flash drive He has USB flash drives with capacities equal to megabytes The file size is equal to megabytes Find the minimum number of USB flash drives needed to write Sean s file if he can split the file between drives ,Let s sort the array in nonincreasing order Now the answer is some of the first flash drives Let s iterate over array from left to right until the moment when we will have the sum at least m The number of elements we took is the answer to the problem Complexity O nlogn ,Let s calculate the value of how many times the number occurs in the array We will iterate over the value of and look for the minimum number of moves necessary for each number to appear in the array either times or times Note that if there is no such number that then such a value of will not give the minimum answer because we have removed unnecessary elements Then for a specific the answer is calculated as follows Since the number of candidates for the value of is no more than this method works in Then there are two ways to optimize our solution you can consider only unique values of there are no more than and get a solution in you can sort the values and use prefix sums this solution works for or for if you use counting sort 
101,There are quests If you complete the th quest you will gain coins You can only complete at most one quest per day However once you complete a quest you cannot do the same quest again for days For example if and you do quest on day then you cannot do it on day or but you can do it again on day You are given two integers and Find the maximum value of such that you can gain at least coins over days If no such exists output If can be arbitrarily large output ,Let s fix k and find the maximum number of coins we can get Here we can do a greedy solution at every step we should always take the most rewarding quest Intuitively it makes sense since doing more rewarding quests earlier allows us to do them again later If no quests are available we do nothing To implement this sort the quests in decreasing order and 0 index them On day i we should do quest i bmod k provided that this value is less than n This is because after every k days we cycle back to the first quest Thus we solved the problem for a fixed k in mathcal O d with mathcal O n log n precomputation to sort the array Now to solve the problem we can binary search on the answer since if some k works then all smaller k work The minimum value of k is 0 and the maximum value is n for larger k we won t be able to do the same quest multiple times anyways so it s useless to consider them If we find that k always goes towards the smaller end of our binary search and k 0 still fails we output If we find that k always goes towards the larger end of our binary search and k n still fails we output Otherwise just output k The overall time complexity is mathcal O n log n d log n It is not hard to improve the solution to mathcal O n log n Originally I proposed the problem this way but we ended up removing this part of the problem because the implementation of this solution was tricky enough ,When using th coupon the bar we get for free should have at least bars not cheaper than it So if we consider sorted in non decreasing order then we cannot get discount greater than On the other hand we can always get such a discount if we pick most expensive bars to buy using the th coupon 
102,There is a white sheet of paper lying on a rectangle table The sheet is a rectangle with its sides parallel to the sides of the table If you will take a look from above and assume that the bottom left corner of the table has coordinates and coordinate axes are left and bottom sides of the table then the bottom left corner of the white sheet has coordinates and the top right After that two black sheets of paper are placed on the table Sides of both black sheets are also parallel to the sides of the table Coordinates of the bottom left corner of the first black sheet are and the top right Coordinates of the bottom left corner of the second black sheet are and the top right Determine if some part of the white sheet can be seen from the above after the two black sheets are placed The part of the white sheet can be seen if there is at least one point lying the white sheet and of both black sheets ,There are at least two solution to the problem I ll describe both of them The first solution firstly let s notice that the point we search can have non integer coordinates but if the answer exists then there will be the answer such that its point has at most half integer coordinates So let s multiply all coordinates by two and solve the problem with integer coordinates The second thing is that for some there is only two points we need to check top point with this and bottom point with this The same for some So we can iterate over all possible values of and check if the point lies outside of both black rectangles The same with point Then do the same for points and should be in range and should be in range Time complexity is linear on size of the white rectangle The second solution is most tricky but has the better time complexity Let be the intersection of white rectangle and the first black rectangle the same but with the second black rectangle and be the intersection of and Then it is obvious that the answer exists if and doesn t cover the whole white rectangle Time complexity ,Let s set sections from left to right Note that for the th section all valid heights heights for which it s possible to choose heights for all sections meeting all rules and finishing with the height of equal to form a segment It s not hard to prove by induction For the first section the valid segment is The step of induction if the valid segment for is then valid s for is the segment since for each you can find at least one in which don t break the first rule If for any the correct segment is empty or if we can t fulfill the third rule then there is no answer otherwise at least one answer is always exist As a result to solve the problem you should just maintain the segment of valid using the formula above while iterating Complexity is 
103,You are given an array consisting of integers We denote the subarray as the array A subarray is considered if every integer that occurs in this subarray occurs there For example the array has three good subarrays Calculate the number of good subarrays of the given array ,Let s consider two solutions a non deterministic and a deterministic one The random solution goes like that Let s assign a random integer to each value from to to value not to a position Let the value of the subarray be the trit wise sum of the assigned integers of all values on it Trit wise is the analogue of bit wise sum xor but in ternary system So adding up the same integer three times trit wise is always equal to zero Thus if the value on a subarray is zero then each value appears on it a multiple of three times How to count the number of such subarrays Process the array from left to right and store the prefix trit wise sums in a map The number of the valid subarrays that end in the current position is the number of occurrences of the current prefix trit wise sum in a map The current sum should be added to the map afterwards However that s not what the problem asks us to find Let s consider another problem count the number of subarray such that each number appears no more than three times This can be done with two pointers Process the array from left to right and for each number store the positions it occurred on If some number appears at least four times than the left pointer should be moved to the next position after the fourth to last position The number of valid subarrays the end in the current position is the distance to the left pointer Let s combine these problems maintain the pointer to only the valid positions and remove the prefix trit wise sums from the map as you increase the pointer That way the map will only store the valid sums and they can be added to answer as they are Assume you use trits I guess the probability of the collision is the same as two vectors out of colliding in a dimensional space with their coordinates being from to That will be about when according to birthday paradox and way less if we increase Overall complexity The deterministic solution a k a the boring one goes like that Let s again process the array from left to right Let the current position be the right border of the segment Each number makes some constraints on where the left border might be More specifically it s two possible segments between its last occurrence and the current position and between its fourth to last occurrence and its third to last one Let s actually invert these segments Bad segments are from the beginning of the array to the fourth to last occurrence then from the second to last occurrence to the last one So the valid left borders are in such positions that are covered by zero bad segments Let s keep track of them in a segment tree Add on the bad subarrays Now you have to count the number of values in a segtree That s a pretty common problem As we know that no values can go below should be a minimum element on the segment So we can store a pair of minimum on segment number of minimums on segment At the end the second value is the number of zeros if the first value is zero Overall complexity ,Note that the numbers in the array are not important to us so initially we will calculate the values of Now applying a move for the number is equivalent to decreasing by and increasing by We will perform the following greedy algorithm while the array have no balanced remainders find any such that we apply the move for that is replace with and with It is easy to prove the correctness of this greedy algorithm by cyclically shifting the values and so that the first element is equal to the maximum of them 
104, You are given a sequence consisting of integers You are making a sequence of moves During each move you must take either the leftmost element of the sequence or the rightmost element of the sequence write it down and remove it from the sequence Your task is to write down a increasing sequence and among all such sequences you should take the longest the length of the sequence is the number of elements in it For example for the sequence the answer is you take and the sequence becomes then you take the rightmost element and the sequence becomes then you take and the sequence becomes and then you take and the sequence becomes the obtained increasing sequence is ,The solution of the previous problem works for this problem also Almost works What if the leftmost element is equal the rightmost element Which one should we choose Let s analyze it If we take the leftmost element then we will take any other element from the right and vice versa So we can t meet this case more than once because after meeting it once we can take only leftmost elements or only rightmost elements The only thing we should understand is which of these two cases is better take the leftmost element or take the rightmost element To do it we can just iterate from left to right and calculate the number of elements we can take if we will take the leftmost element each time If we cannot take the current element then just stop the cycle And do the same thing for the rightmost element and take the best case ,Let s process the array elements one by one For the first element it doesn t matter which side of the deque we add it to the result of its addition will be the same there will be a sequence of one element equal to the first array element in the deque Now let s consider adding the th element of an array into the deck First will be considered then and so on up to Let us describe the general algorithm for choosing the side of the dec for each step Note that if the elements now lie in the deck then all final sequences that can be obtained in the deck from the current state can be broken down into pairs of the form where the beginning and the end of the final sequences hidden behind are obtained by the same sequences of all the following choices and respectively coincide Note that since the prefix and suffix hidden behind the dots completely coincide in the two sequences under consideration as well as the set of numbers in the central part coincides the numbers of inversions also coincide inside the prefix and inside the suffix between elements of the prefix and elements of the suffix between elements of the prefix or suffix and elements of the central part The difference between the number of inversions in the first and second sequence consists only of the difference between the number of inversions in their central part So we can determine at the stage of adding to the deque which direction of its addition is guaranteed not to lead to the optimal answer and choose the opposite one If is added to the beginning of the deque the number of inversions in the central part will increase by the number of elements in the deque strictly smaller than and if we add it to the end of the deque it will increase by the number of elements in the deque strictly larger than Let us make a choice such that the number of inversions increases by the minimum of these two values To quickly find the number of elements smaller or larger than we will store all already processed array elements in a structure that supports the element order search operation such as Besides using this structure specifically you can write any balanced binary search tree such as a Cartesian tree sort all numbers in the input array and compress them to values preserving the relation then build a segment tree on them storing in the node the number of array numbers already processed by the deque with values between and Requests to update and get an order in such structures take time and the construction takes at worst so the time complexity of the algorithm is 
105,You are given a sequence consisting of digits from to You have to divide it into segments segment is a consecutive sequence of elements in other words you have to place separators between some digits of the sequence in such a way that and if the resulting division will be represented as an integer numbers sequence then each next element of this sequence will be than the previous one More formally if the resulting division of the sequence is where is the number of element in a division then for each from to the condition using comparing it means that the integer representations of strings are compared should be satisfied For example if then you can divide it into parts and it will be suitable division But if you will divide it into parts then it will be bad division because If then you can divide it into parts but not into parts Your task is to find suitable division for each of the independent queries ,Since we just want to make two numbers such that the first number is smaller than the second our best bet is to use only the first digit for the first number and the rest of the digits for the second number Note that since the numbers can have up to 300 digits we shouldn t actually evaluate the second number Instead since the digits only include 1 through 9 we can handle that case by checking the number of digits Code 49002957 ,Let s iterate over all pairs of digits in the number Let the first digit in the pair be at position and the second at position Let s place these digits to the last two positions in the number The first greedily goes to the last position and then the second goes to the position next to that Now the number can contain a leading zero Find the leftmost non zero digit and move it to the first position Then if the current number is divisible by try to update the answer with the number of swaps It is easy to show that the number of swaps is minimal in this algorithm The only difference we can introduce is the number of times digit digit and the leftmost non zero digit swap among themselves And that is minimized You can also notice that the order of swaps doesn t matter and you can rearrange them in such a way that no leading zero appears on any step This solution has time complexity You can also solve this problem with complexity because you have to check only four options of the two last digits It is always optimal to choose both rightmost occurrences of the corresponding digits You can show that even if you are required to swap the chosen ones there will be no other pair with smaller total amount of moves 
106,You and your friend are playing the game Mortal Kombat XI You are trying to pass a challenge tower There are bosses in this tower numbered from to The type of the th boss is If the th boss is easy then its type is otherwise this boss is hard and its type is During one session either you or your friend can kill bosses neither you nor your friend can skip the session so the minimum number of bosses killed during one session is at least one After your friend session your session begins then again your friend session begins your session begins and so on Your friend needs to get good because he can t actually kill hard bosses To kill them he uses skip points One skip point can be used to kill one hard boss Your task is to find the number of skip points your friend needs to use so you and your friend kill all bosses in the given order For example suppose Then the best course of action is the following your friend kills two first bosses using one skip point for the first boss you kill the third and the fourth bosses your friend kills the fifth boss you kill the sixth and the seventh bosses your friend kills the last boss using one skip point so the tower is completed using two skip points You have to answer independent test cases ,If then our friend always needs one skip point because he always has to kill the first boss Let s just remove this boss from our consideration and increase the answer if needed What about other skip points Firstly let s understand that we can always do our moves in such a way that the first hard boss will always be killed by us except the first one So if it s our friend turn now and there is only one easy boss before the hard our friend just kills this easy boss If there are two easy bosses he kills both If there are three friend kills the first we kill the second and he kills the third And so on So we can always assume that each segment of hard bosses starts with our move We can kill each such segment greedily we kill two bosses and our friend kills one If there are less than three bosses in the segment we just kill remaining and proceed So if the length of the current segment of hard bosses is then we need skip points Summing up these values over all segments we get the answer and don t forget that the first boss should be handled separately Segments of ones can be extracted using two pointers There are also dynamic programming solution but I found this one more clever ,One way to think about this problem is in game theory terms Imagine a following game Two players alternate moves The first players chooses a direction The second player chooses a different direction and moves a robot there The game ends when the robot reaches the lab and the first player wins Otherwise it s a draw What s the outcome of the game if both players play optimally as in the first player tries to win the second player tries to draw Does it sound easier Well it sure does if you ever dealt with solving games on arbitrary graphs You can skim through this article if that s unfamiliar to you The state of the game is a pair If a direction is not chosen denote it with it s the first player s move Otherwise it s the second player s move You can even implement it as is Or you can adjust a part of this algorithm for this particular problem Initially all the states are drawing only the state is winning What we basically need is a way to determine if a state is winning or not From game theory we can tell that the state is winning if there s a transition from it to a losing state The state is losing if all the transitions from it lead to winning states So is winning if any of are losing Promote that one step further The state is winning if there exists such a direction that all neighbouring free cells except in this direction are winning states Rephrase it The state is winning if it has at least one winning state neighbour and no more than one non winning state neighbour Let s store the number of non winning neighbouring states for each cell Initially it s the number of neighbouring free cells If some state becomes marked as winning decrease the value for each of its neighbours by If some state s value reaches or after this operation mark it as winning Since what this does is basically a traversal of a grid this can be done with a DFS BFS starting from the lab Overall complexity per testcase 
107,International Women s Day is coming soon Polycarp is preparing for the holiday There are candy boxes in the shop for sale The th box contains candies Polycarp wants to prepare the maximum number of gifts for girls Each gift will consist of boxes The girls should be able to share each gift equally so the total amount of candies in a gift in a pair of boxes should be divisible by In other words two boxes and can be combined as a gift if is divisible by How many boxes will Polycarp be able to give Of course each box can be a part of no more than one gift Polycarp cannot use boxes partially or redistribute candies between them ,Let be the number of boxes with candies modulo Firstly the number of of boxes we can obtain using two boxes with remainder modulo is Secondly if is even then we also can obtain of boxes using two boxes with remainder modulo and its number is And for any other remainder from to the number of pairs of boxes is So if we sum up all these values the answer is this sum multiplied by two because we have to print the number of boxes not pairs ,Consider a naive solution Iterate over all pairs and apply all operations The complexity is The constraints obviously imply that it s too much What can we cut from it Well surely will still remain there Both of and also should So we can probably only hope to turn this into Let s try that Notice that no matter what operations are applied never changes You can also peek at the examples and see that the patterns are suspiciously diagonal shaped in the matrix Let s try to solve the problem by fixing and calculating the answer for all values of I will call the fixed variable Consider case where and Here all can fit into both and so we can avoid caring about one restriction on the operations We ll think what to do with large volumes later If there are no operations the answer for each initial is for all from to Now consider an operation for some For nothing changes Actually for all the result of the operation is the same as for Hmm but if the result is the same it will remain the same until the end Same from the other side The answers for and also get merged together To me it kind of looks like a primitive form of DSU on these volume states you merge some prefix of the answers together and merge some suffix of the answers together If the state was merged to either or then it s easy to calculate the actual answer for that state What happens to the remaining states Well since they weren t merged anywhere the operation for them was applied fully if was requested all was poured How to deal with multiple operations then I propose the following idea When applying an operation we only want to know which of the previously non merged states become merged Basically we can squish all previous operations into one just sum up the signed amounts of water Since they all were applied fully to the non merged states it s completely valid After the squish check for the new merges You can actually study the structure of the answers and see that they go like that for some values of and such that It isn t that important but it makes the code easier You can basically calculate the length of the merged prefix the length of the merged suffix then calculate the answer at the end of the prefix in and restore all answers from it We neglected larger values of earlier time to return to them Another kind of limit to each operation is added when extra water doesn t fit in another tank Well it doesn t change that much It only makes more prefix suffix merges To come up with the exact formulas I followed these points Something merges on an operation when any of these holds not enough water in the first tank not enough space in the second tank not enough water in the second tank not enough space in the first tank Replace all with and you get the constraints for prefix and suffix merges Overall complexity 
108,There is a grid consisting of rows and columns The rows are numbered from to from bottom to top The columns are numbered from to from left to right The th column has the bottom cells blocked the cells in rows the remaining cells are unblocked A robot is travelling across this grid You can send it commands move up right down or left If a robot attempts to move into a blocked cell or outside the grid it explodes However the robot is broken it executes each received command times So if you tell it to move up for example it will move up times cells You can t send it commands while the robot executes the current one You are asked queries about the robot Each query has a start cell a finish cell and a value Can you send the robot an arbitrary number of commands possibly zero so that it reaches the finish cell from the start cell given that it executes each command times The robot must stop in the finish cell If it visits the finish cell while still executing commands it doesn t count ,What if there were no blocked cells Then the movement is easy From cell we can go to cells or Thus we can visit all cells that have the same remainder modulo over both dimensions The answer would be if and Let s choose the following path from start to finish Let be less or equal to If that isn t the case swap the cells First move up until the row is the same then move to the side until the column is the same What stops us from doing the same on a grid with blocked cells The first part of the part can remain the same we can always move up from the cell Only cells below the start cell can be blocked The second part is trickier If there is a column with too many blocked cells between the start and the finish column then we won t be able to pass through it Let s adjust the path for that Move up as high as possible to the highest cell with the same remainder modulo in this column Then move to the finish column and go down to the finish cell If there still exists a column with too many blocked cells then the answer is No matter what we do we won t be able to go around that column Otherwise the answer is Thus the solution is to check for remainders then find the largest number of blocked cells between the query columns and compare it to the highest row with the same remainder modulo as the start or the finish You can use any RMQ data structure you want Overall complexity with sparse table for RMQ for example ,To obtain a segment of cells of black color we need to paint all the white cells of the segment black Then go through all the segments of length there are only and choose such a segment among them that the number of white cells on it is minimal You can quickly find out the number of white cells in the segment by prefix sums 
109,You are given an array consisting of integers You are also given two integers and You have to perform the following operation exactly once add to the elements on positions and subtract from all the others For example if and we have picked the first element then after the operation the array Let be the maximum possible sum of a subarray of The subarray of is a contiguous part of the array i e the array for some An empty subarray should also be considered it has sum Let the array be the array after applying the aforementioned operation Apply the operation in such a way that is the maximum possible and print the maximum possible value of ,There are greedy and dynamic programming solutions We will describe dynamic programming solution The main task is to choose some segment that is the answer to the problem while choosing positions to increase by To do this we can use dynamic programming where is the number of positions that have already been considered from to is the number of elements that have already been increased by from to is the flag showing the current state whether we are before the chosen segment inside the segment or after the segment Transitions in such dynamic programming are quite simple we have a choice either to increase by then the value of the th element is or not to increase then the value of the th element is we can also change the state of the flag note that you can only switch from the current state to the subsequent ones i e for example you cannot switch from the state the segment has already ended to the state inside the segment If the current state of the flag is inside the segment then or depending on the selected transition should be added to the dynamic programming value itself So we got a solution in ,Firstly we can find answers for all points that are adjacent to at least one point not from the set The distance for such points is obviously and this is the smallest possible answer we can get On the next iteration we can set answers for all points that are adjacent to points with found answers because they don t have neighbors not from the set the distance for them is at least It doesn t matter which point we will take so if the point is adjacent to some point that have the answer we can set the answer for the point as the answer for the point We can repeat this process until we find answers for all points In terms of the code this can be done by breadth first search BFS In other words we set answers for the points that have the distance and then push these answers to all adjacent points from the set in order of the increasing distance until we find all the answers Time complexity 
110, Ivan plays a computer game that contains some microtransactions to make characters look cooler Since Ivan wants his character to be really cool he wants to use some of these microtransactions and he won t start playing until he gets all of them Each day during the Ivan earns exactly one burle There are types of microtransactions in the game Each microtransaction costs burles usually and burle if it is on sale Ivan has to order exactly microtransactions of the th type he orders microtransactions during the Ivan can order possibly zero number of microtransactions of types during any day of course If the microtransaction he wants to order is on sale then he can buy it for burle and otherwise he can buy it for burles There are also special offers in the game shop The th offer means that microtransactions of the th type are on sale during the th day Ivan wants to order all microtransactions as soon as possible Your task is to calculate the minimum day when he can buy all microtransactions he want and actually start playing ,Let s iterate over all possible answers Obviously this value is always in the range The first day when Ivan can order all microtransactions he wants will be the answer How to check if the current day is enough to order everything Ivan wants If we had several sale days for some type of microtransaction of course we can use only such days that are not greater than the fixed last day let s use the last one it is always not worse than some of the previous days Then let s iterate over all days from to and do the following firstly let s increase our balance by one burle Then let s try to order all microtransactions for which the current day is the last sale day and pay one burle per copy If we are out of money at some moment then just say that we should order all microtransactions that remain in this sale day during the last day for two burles per copy It is true because it does not matter which types will remain because this day is the last sale day for all of these types So after all we had some remaining microtransactions that we cannot buy during sales and the current balance And the current day is good if the number of such microtransactions multiplied by two is not greater than the remaining balance ,First of all let s find out how to calculate This can be done greedily let s iterate from the higher denominations to the lower ones the number of banknotes of th type is equal to the value of here changes to reflect that we have already taken some banknotes that is we subtract from each time which is the same as taking modulo We can see that after we process the th type of banknotes the condition holds which means that the number of banknotes of th type does not exceed except in the case of Now we can find the minimum number such that Let be the number of banknotes that still remains to take initially equal to because we want to be at least Let s iterate from the lower denominations to the highest ones the number of banknotes of th type we take should be equal to the minimum of how many we need to take and how many we are allowed to take so as not to break the minimality of the function 
111,There are monsters standing in a row numbered from to The th monster has health points hp You have your attack power equal to hp and your opponent has his attack power equal to hp You and your opponent are fighting these monsters Firstly you and your opponent go to the first monster and fight it till his death then you and your opponent go the second monster and fight it till his death and so on A monster is considered dead if its hp is less than or equal to The fight with a monster happens in turns You hit the monster by hp If it is dead after your hit and you both proceed to the next monster Your opponent hits the monster by hp If it is dead after his hit and you both proceed to the next monster You have some secret technique to force your opponent to skip his turn You can use this technique at most times for example if there are two monsters and then you can use the technique times on the first monster and time on the second monster but not times on the first monster and times on the second monster Your task is to determine the maximum number of points you can gain if you use the secret technique optimally ,Let s calculate the minimum number of secret technique uses we need to kill each of the monsters Let the current monster has hp Firstly it is obvious that we can take modulo except one case If it becomes zero let s rollback it by one pair of turns Then the number of uses of the secret technique we need is Let s sort all monsters by this value and take the cheapest set of monsters prefix of the sorted array with the sum of values less than or equal to Time complexity ,The first spell looks pretty weak compared to the second spell Feels like you almost always replace one with another Let s show that you can totally avoid casting the spell of the first type twice or more on one monster Let the two first spell casts be and for some monsters and You can replace them by a cast of the second spell on and a cast of the first spell on That would deal even more damage to and the same amount to and The number of casts doesn t change Thus it only makes sense to use the first spell on monsters with health Calculate the number of them kill the full pairs of them with the first spell and use the second spell on the remaining monsters Overall complexity per testcase 
112,Two integer sequences existed initially one of them was increasing and the other one decreasing Strictly increasing sequence is a sequence of integers And strictly decreasing sequence is a sequence of integers Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing They were merged into one sequence After that sequence got shuffled For example some of the possible resulting sequences for an increasing sequence and a decreasing sequence are sequences or This shuffled sequence is given in the input Your task is to find two suitable initial sequences One of them should be increasing and the other one decreasing Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing If there is a contradiction in the input and it is impossible to split the given sequence to increasing and decreasing sequences print ,Let s count the number of occurrences of each element in the Because the maximum possible element is it can be done without any data structures Then let s check if is greater than for some from to and if it is then the answer is because this element should occur at least twice in one of the sequences Now let s output the increasing sequence The number of elements in it is the number of elements such that Let s iterate from left to right print the suitable elements and decrease their The number of elements in the decreasing sequence is just the number of elements with non zero So let s iterate from right to left and just print suitable elements ,This is pretty standard dynamic programming problem Let be the maximum possible sum we can obtain if we are at the element right now we took elements in the row and our current remainder is Initially all states are except Transitions are standard because this is a knapsack problem we either take the element if or don t take it If the element is not the last element of the row then transitions look like that we don t take the current element we take the current element this transition is only possible if The transitions from the last element of the row are almost the same but the next element is and the new value of is always zero The answer is 
113,Given an array of positive integers with length determine if there exist three indices such that ends in the digit ,Since we only care about the last digit of the sum we can ignore all numbers other than the last digits of the elements of For example we can consider to be the same as Now note that if a number appears more than times in the array we can ignore all copies that occur more than times since our sum only involves three numbers For example we can consider to be the same as Using these observations note that there are only digits and each digit can occur at most times So we can always reduce the array to one of length Since is very small we can brute force all triples which runs quickly enough Time complexity ,Let is the greatest common divisor of all elements of the array You can find it by Euclidean algorithm or some standard library functions Then the answer is just the number of divisors of You can find this value in 
114,Timur s grandfather gifted him a chessboard to practice his chess skills This chessboard is a grid with rows and columns with each cell having a integer written on it Timur s challenge is to place a bishop on the board such that the sum of all cells attacked by the bishop is The bishop attacks in all directions diagonally and there is no limit to the distance which the bishop can attack Note that the cell on which the bishop is placed is also considered attacked Help him find the maximal sum he can get ,The solution is to check the sum over all diagonals for each cell For a cell we can iterate over all elements in all its diagonals This will be in total elements The complexity will be solutions involving precomputation are also possible but aren t needed ,We can see that the only information we need is the parity of the coordinate of each chip because we can move all chips that have the same parity to one coordinate for free So if the number of chips with odd coordinate is then the answer is 
115,You are given an array Calculate the number of tuples such that and ,We can rethink this as counting the number of equal pairs where To do this we loop over from right to left and make sure we have all pairs where counted in a map Then we simply iterate over and add up the number of occurrences of each in the map For implementation details note that we don t actually want to use a map and make our code slower We can just use an array of size and convert the pair to the number since the are in the range As a bonus even if the were larger than we could just compress them down to and repeat the solution above Code 91019003 ,The only fact required to solve this problem is just to notice that the answer array is just an arithmetic progression After that we can fix the first element fix the difference construct the array check if and are in this array and if yes update the answer with This is solution There are faster solutions though Other author s solution is but I didn t want to make this problem harder so I allowed solutions It is obvious that the difference of the progression is some divisor of Let it be Let s add some elements starting from to the left and so on and stop if we reach elements or the next element is less than If we didn t find among these elements just skip this difference it is useless for us Otherwise if we have less than elements let s add and so on until we get elements And then update the answer with the maximum element of the array There is also a solution in with some greedy observations 
116,Kolya got an integer array The array can contain both positive and negative integers but Kolya doesn t like so the array doesn t contain any zeros Kolya doesn t like that the sum of some subsegments of his array can be The subsegment is some consecutive segment of elements of the array You have to help Kolya and change his array in such a way that it doesn t contain any subsegments with the sum To reach this goal you can insert any integers between any pair of adjacent elements of the array integers can be really any positive negative any by absolute value even such a huge that they can t be represented in most standard programming languages Your task is to find the minimum number of integers you have to insert into Kolya s array in such a way that the resulting array doesn t contain any subsegments with the sum ,Firstly let s understand that the sum of the segment is zero if is zero in other words where is the sum of the first elements Let s iterate over elements from left to right and add all prefix sums in the set If we get the sum that is already in the set we get some segment with sum and we need to fix it somehow Let s insert some huge number before the current element in such a way that all prefix sums starting from the current element to the end will be significantly bigger than all prefix sums to the left In words of implementation we just get rid of all prefix sums to the left clear the set and continue doing the same process starting from the current element so we just cut off the prefix of the array This way is optimal because we remove all segments with sum ending at the current element using only one insertion and we need to use at least one insertion to do that Time complexity ,Let s say we remove applications with and applications with Obviously among all the applications with it was necessary to take maximum in memory so we will clear the most memory Let s split all the applications into two arrays with and and sort them Then you need to take a prefix from each array Let s iterate over which prefix we take from the first array For it we can uniquely find the second prefix we remove applications until the sum exceeds If we now increase the first prefix by taking a new application then we don t need to take any applications in the second array This means that when the first prefix is increased the second one can only decrease To solve the problem you can use the two pointer method 
117,Polycarp has spent the entire day preparing problems for you Now he has to sleep for at least minutes to feel refreshed So he has just fallen asleep and his first alarm goes off in minutes Every time Polycarp wakes up he decides if he wants to sleep for some more time or not If he s slept for less than minutes in total then he sets his alarm to go off in minutes after it is reset and spends minutes to fall asleep again Otherwise he gets out of his bed and proceeds with the day If the alarm goes off while Polycarp is falling asleep then he resets his alarm to go off in another minutes and tries to fall asleep for minutes again You just want to find out when will Polycarp get out of his bed or report that it will never happen ,Let s handle some cases Firstly if then Polycarp wakes up rested enough immediately so is the answer Otherwise what does Polycarp do He sets alarm to go off in minutes and falls asleep in minutes Thus he spends minutes sleeping Notice that if is non positive then Polycarp always resets his alarm without sleeping So for that case the answer is Finally if Polycarp resets his alarm times then he ends up with minutes of sleep in total and ends up spending minutes of time We know that should be greater or equal to and should be the smallest possible Thus the smallest possible integer is equal to And the answer is Overall complexity per testcase ,One can notice or actually derive using some maths that the answer is the sum of products of nested for loops iterations for every add command Let s learn to simulate that in linear complexity Maintain the stack of multipliers on for push the top of stack multiplied by to the stack on end pop the last value on add add the top of the stack to the answer The problem however is the values are really large Notice that once you add the value greater or equal to to the answer it immediately becomes OVERFLOW Thus let s push not the real multiplier to the stack but min multiplier That way the maximum value you can achieve is about which fits into the 64 bit integer Overall complexity 
118,You are given a string consisting only of characters or Let be the length of You are asked to choose some integer and find a sequence of length such that for all from to The characters at positions are removed the remaining characters are concatenated without changing the order So in other words the positions in the sequence should not be adjacent Let the resulting string be is called sorted if for all from to Does there exist such a sequence that the resulting string is sorted ,There are several different ways to solve this problem In my opinion the two easiest solutions are notice that in the sorted string there is a prefix of zeroes and a suffix of ones It means that we can iterate on the prefix from which we remove all ones and remove all zeroes from the suffix we obtain If we try to remove two adjacent characters then we cannot use this prefix if there is a substring before the substring in our string then from both of the substrings at least one character remains so if the first occurrence of is earlier than the last occurrence of there is no answer Otherwise the answer always exists ,It s easy to see that the FB string repeats every characters after processing every numbers we will get the same remainders modulo and as numbers ago and when we process consecutive numbers we get characters So This means that if we want to find a substring no longer than characters in the FB string we don t need to consider more than first characters of the FB string the substring of length starting with the th character ends with the th character and we don t need to consider substrings starting on positions greater than So the solution is to generate at least first characters of the FB string and then check if the substring occurs in the generated string using a standard function like 
119,You are given a positive greater than zero integer You have to represent as the sum of integers possibly negative consisting only of ones digits For example and Among all possible representations you have to find the one that uses the minimum number of ones in total ,Let s build the number from the lowest digit to the highest digit with the following dynamic programming the minimum number of ones if least significant digits are already fixed the carry to the next digit is can be negative there are positive numbers of the form of length greater than or equal to and negative numbers of length greater than or equal to First consider the transitions when we reduce the values of and or Such transitions correspond to the fact that in the optimal answer there were several numbers of length exactly and they should not be considered further If the value of matches the th least significant digit in then we can use transition to th state with the new value of and the number of ones in the answer increased by It remains to estimate what the maximum value of and we need The value of doesn t exceed the total number of numbers that we use in the answer Using at most numbers we can decrease the length of by at least Thus the maximum value of and is at most where n is the length of the number For the value of the condition should be met similarly for a negative value Thus we can assume that the absolute value of doesn t exceed The total complexity of this solution is yet with a high constant factor ,The only fact required to solve the problem if we start decreasing the number we are better to end decreasing it and only then decrease the other number So we can just consider two cases when we decrease first and after that and vice versa and just take the minimum product of these two results The rest is just implementation 
120,You are running through a rectangular field This field can be represented as a matrix with rows and columns denotes a cell belonging to th row and th column You start in and have to end your path in From the cell you may advance to only if or only if However there are obstacles blocking your path th obstacle is denoted by three integers and and it forbids entering any cell such that You have to calculate the number of different paths from to and print it modulo ,There is a simple dynamic programming solution that works in Let s try to improve it Firstly if there are no obstacles in some column and we have calculated the number of paths to every cell of the previous column then we may get the values in column by multiplying the vector of values in column by the following matrix Then we may use binary exponentiation to skip long segments without obstacles in where is the length of the segment Let s try to modify this matrix if we have to forbid some rows All we need to change is to set every value in th row to if th row is forbidden So we may skip long segments not only if they don t contain any obstacles but also if the set of forbidden rows doesn t change on this segment So the solution is the following divide the whole matrix into segments by the endpoints of the obstacles then in every segment the set of forbidden rows doesn t change so we can skip it using fast matrix exponentiation ,Let s consider each cell as a center of a cross and take the fastest one to paint Calculating each time naively will take overall which is too slow Notice how the answer for some cell can be represented as if is white else where is the number of white cells in row and is the same for column The first two terms can be precalculated beforehand Overall complexity per query 
121,There are railway stations in Berland They are connected to each other by railway sections The railway network is connected i e can be represented as an undirected tree You have a map of that network so for each railway section you know which stations it connects Each of the sections has some integer value of the However these values are not marked on the map and you don t know them All these values are from to inclusive You asked passengers some questions the th one told you three values his departure station his arrival station minimum scenery beauty along the path from to the train is moving along the shortest path from to You are planning to update the map and set some value on each railway section the The passengers answers should be consistent with these values Print any valid set of values which the passengers answer is consistent with or report that it doesn t exist ,Firstly let s precalculate arrays The array is the array of parents if we run dfs from the vertex So is the vertex that is the previous one before on the directed path This part can be precalculated in time and we need it just for convenience Initially all values beauties of the edges are zeros Let s consider queries in order of non decreasing For the current query let s consider the whole path and update the value for each on this path in the following way After processing all queries let s replace all values with This part works also in time And the last part of the solution is to check if the data we constructed isn t contradictory We can iterate over all paths and find the minimum value on this path We have to sure if it equals If it isn t true for at least one query then the answer is Otherwise we can print the resulting tree Time complexity but it can be done in at least I hope someone can explain this solution because I am too lazy to do it now ,Let s store for each vertex the minimum distance from it to the nearest one let s call it We will also store the global answer which for obvious reasons does not increase we will call it Let s now color the vertex let s set and run a depth first search from it This DFS will visit the vertices with Let us consider the vertex and its neighbour If we can relax through let s do it and start from Otherwise has a closer neighbour let s try to update the answer through it Also do not forget to update the answer via from all vertices that we visited The correctness of the algorithm is obvious let s evaluate its time complexity It is easy to notice that after the first operations We enter only the vertices from which firstly does not exceed and secondly was relaxed by the parent that is decreased by at least So we allowed ourselves a complete tree bypassing for the first operations and then amortized performed no more than operations The final asymptotics will be 
122,You are given two arrays and consisting of integers each Let s define a function as follows let s define an array of size where denotes bitwise XOR the value of the function is i e bitwise AND of the entire array Find the maximum value of the function if you can reorder the array in an arbitrary way leaving the initial order is also an option ,We will build the answer greedily from the highest significant bit to the lowest one Let s analyze how to check if the answer can have the highest bit equal to It means that every value in should have its highest bit equal to so for every exactly one of the numbers should have this bit equal to For both of the given arrays we can calculate how many elements have which value of this bit and then the number of elements with in this bit in the array should be equal to the number of elements with in the array and the same for elements with in and elements with in If these values are equal it means that the elements of and can be matched in such a way that in every pair the XOR of them has in this bit If it is so then the highest bit of the answer is otherwise it is Okay then let s proceed to the next bit Should we just do the same to check if this bit can be equal to in the answer Unfortunately that s not enough Let s look at the case We can get the value in the th bit or in the st bit but not in both So for the next bit we need to make sure that not only we can get in the result but we can also do this without transforming some of the s to s in the higher bits If it is impossible it doesn t matter if we can get in the current bit since it will be suboptimal so we have to use an ordering that gets in this bit In general case it means that we have to solve the following subproblem check if we can obtain in several bits of the answer let these bits be to are the bits that we have already checked is the new bit we are trying to check Let be the number that has in every bit and in every other bit The elements should be matched in such a way that If we group all numbers from and from according to the value of or then for every group of elements from there is a corresponding group in such that we can match the elements from the first group with the elements from the second group So if for every such group its size in is equal to the size of the corresponding group in then we can set all bits from to simultaneously Some implementation notes if the number of bits we need to check is big the number of groups can become too large to handle all of them since it is So to store the number of elements in each group we should use some associative data structure like for example in C If you use a map splitting elements into groups will be done in so in total you will get complexity of where is the maximum possible value in the input ,For each from to find all elements of the array that are congruent to modulo and store their indices in a list Also create a vector called and let be We have to cycle from to twice For each from to if there are in list too many i e elements congruent to modulo remove the extra elements from this list and add them to If instead there are too few i e elements congruent to modulo remove the last few elements from the vector For every removed index increase by After doing so after two passes we print the total increase and the updated array It is obvious that after the first iterations every list will have size at most and after more iterations all lists will have the same sizes It can be easily proved that this algorithm produces an optimal answer The time complexity is 
123, is a wooden toy in the form of a painted doll inside which you can put a similar doll of a smaller size A set of nesting dolls contains one or more nesting dolls their sizes are consecutive positive integers Thus a set of nesting dolls is described by two numbers the size of a smallest nesting doll in a set and the number of dolls in a set In other words the set contains sizes of for some integer and You had one or more sets of nesting dolls Recently you found that someone mixed all your sets in one and recorded a sequence of doll sizes integers You do not remember how many sets you had so you want to find the number of sets that you could initially have For example if a given sequence is Initially there could be sets the first set consisting of nesting dolls with sizes a second set consisting of nesting dolls with sizes According to a given sequence of sizes of nesting dolls determine the minimum number of nesting dolls that can make this sequence Each set is completely used so all its nesting dolls are used Each element of a given sequence must correspond to exactly one doll from some set ,First for each size let s count the number of dolls of this size Then let s create a set in which for each doll of size we add the numbers and This will allow you to process all the segments as well as the dimensions adjacent to them We will iterate over the set in ascending order of size Let be the number of matryoshkas of the current size of the previous one considered at the beginning If the numbers do not match then you need to close if or open if segments It is enough to add only the opening of the segments to the answer ,Let s code the following process Go one circle across the booths calculate the total cost of sweets bought and the number of sweets bought Now you can decrease you money down to and add to answer It represents that you went maximum number of such circles The later circles will have smaller cost Let s continue this process until becomes smaller than the minimum priced sweet The number of operations made is Let be the amount of money before some operation be the total cost of sweets bought on that operation and is actually smaller than that s how modulo works and smaller than that s also how modulo works And these inequalities imply that That leads to about steps to reach the minimal price Overall complexity 
124,You are given three integers and Your task is to construct an undirected tree on vertices with diameter and degree of each vertex at most or say that it is impossible An undirected tree is a connected undirected graph with edges Diameter of a tree is the maximum length of a simple path a path in which each vertex appears at most once between all pairs of vertices of this tree Degree of a vertex is the number of edges incident to this vertex i e for a vertex it is the number of edges that belong to the tree where is any other vertex of a tree ,Let s construct a tree by the following algorithm if d ge n let s print and terminate the program Otherwise let s keep the array deg of the length n which will represent degrees of vertices The first step is to construct the diameter of the tree Let first d 1 vertices form it Let s add d edges to the answer increase degrees of vertices corresponding to this edges and if some vertex has degree greater than k print and terminate the program The second and the last step is to attach the remaining n d 1 vertices to the tree Let s call the vertex if its degree is less than k Also let s keep all vertices forming the diameter in some data structure which allows us to take the vertex with the minimum maximal distance to any other vertex and remove such vertices It can be done by for example set of pairs dist v v where dist v is a maximum distance from the vertex v to any other vertex Now let s add all vertices from starting from the vertex d 1 0 indexed to the vertex n 1 let the current vertex be u We get the vertex with the minimum maximal distance to any other vertex let it be v Now we increase the degree of vertices u and v add the edge between they and if v still be return it to the data structure otherwise remove it The same with the vertex u it is obvious that its maximal distance to any other vertex will be equals dist v 1 If at any step our data structure will be empty or the minimum maximal distance will be equals d the answer is Otherwise we can print the answer See my solution to better understanding Overall complexity O n log n or O n depends on implementation ,Let s start with the solution and then proceed to the proof For each tree in a forest find such a vertex that the maximal distance from it to any vertex is minimal possible a center of a tree Tree may include two centers take any of them in that case Find the the tree with the maximum diameter Connect the centers of other trees with its center Overall complexity is the complexity of looking for a diameter or The center is the best vertex in a tree to connect to The diameter of merging two trees and by in and in with being the maximum shortest path from to any other vertex in being the same for in is Thus minimizing both and will produce the best result The most optimal structure is a star The center tree will be connected directly to any other tree The other trees will be connected through a single vertex among each other which leads to the answer no more than 1 worse than connecting them directly And building the answer the other way will exceed this difference as some tree will be connected to the center tree of the star through one vertex as well The previous fact implies that the center tree of the star should have the maximal diameter among all trees 
125,You are given an integer value and a string consisting of digits from to inclusive A substring of a string is a contiguous subsequence of that string Let be the sum of digits of a substring Let s call substring if there are no values such that is divisible by You are allowed to erase some characters from the string If you erase a character the two resulting parts of the string are concatenated without changing their order What is the minimum number of characters you should erase from the string so that there are no substrings in it If there are no substrings in the given string then print ,The key observation is that since is only up to 20 there can t be that many different prime strings total turns out there are only about 2400 for the worst case of So we can generate all of them and perform a DP where our state is represented by the longest prefix of any of the strings we currently match We can do this by building a trie of all of the prime strings We then need to be able to transition around in this trie it turns out this is exactly what Aho Corasick does for us In particular knowing which node of the Aho Corasick tree we are currently at gives us the full information we need to determine whether or not we will match one of the strings after adding more characters later This leads to a fairly simple DP 90977148 ,We can t model this process directly since the maximum string length reaches look at the second example from the statements To optimize this process you can store each row as a set of the following values Number of occurrences of in the string String length The first three characters of the string are The last three characters of the string are Then to process the second type of request and combine the two strings and into the string you need New occurrences may be added at the junction of two words However if the string length is less than then you need to handle this case carefully with your hands Similarly you need to process small strings separately 
126,You are given a permutation consisting of integers a permutation is an array where each element from to occurs exactly once Let s call an array if the following undirected graph is bipartite the graph consists of vertices two vertices and are connected by an edge if and Your task is to find a array of integers of size such that or or report that no such array exists If there are multiple answers print any of them ,To begin with let s understand that an array is bipartite if and only if there is no decreasing subsequence of length in the array Now we can write dynamic programming is there an array of length such that is the maximum last element of a decreasing subsequence of length and is the maximum last element of a subsequence of length Note that Let s consider all possible transitions from the state if we are trying to put the number on the th position where if then the new state will be if then the new state will be if then such a transition is not valid because a decreasing subsequence of length is formed in the array With a naive implementation such dynamic programming works in We can note that for fixed values of and and it is enough for us to store only the minimum available value of So we can write dynamic programming which is defined similarly to the above but now instead of being Boolean stores the minimum value of or infinity if the state is not valid We have speeded up our solution to but it is still too slow To speed up the solution even more we have to look at the transitions in dynamics and notice that for a fixed either or is always equal to So we can rewrite our dynamic programming in the following form Here the flag says which of the numbers and is equal to and the flag is responsible for the sign of and the minimum value of or is stored in the value itself depending on Thus we got a solution with a linear running time In fact this solution can be simplified if we see the following relation the number we use on position is not less than and not greater than This allows us to get rid of one of the states in our dynamic programming altogether so we get an easier solution This optimization wasn t required to get AC but the code becomes shorter ,We can transform the problem as follows Let We need to find an array so that the sum of elements in it is not greater than all elements are positive integers and the number of different elements is the maximum possible Suppose we need different elements in What can be the minimum possible sum of elements in It s easy to see that should have the following form This array contains exactly different elements these different elements are as small as possible so their sum is as small as possible and all duplicates are s So if the sum of this array is not greater than then it is possible to have the number of different elements in equal to The rest is simple We can iterate on find the maximum possible construct the difference array and then use it to construct the array itself 
127,Polycarp is a great fan of television He wrote down all the TV programs he is interested in for today His list contains shows th of them starts at moment and ends at moment Polycarp owns two TVs He can watch two different shows simultaneously with two TVs but he can only watch one show at any given moment on a single TV If one show ends at the same moment some other show starts then you can t watch them on a single TV Polycarp wants to check out all shows Are two TVs enough to do so ,Let s process all the segments on the line from left to right For each segment we should push events and into some array Sort this array of pair in increasing order usual less comparator for pairs Then we iterate over its elements and maintain the current amount of open segments we passed their left border and didn t pass their right border When we meet the event of the first type we increment the value of the second type decrement If in some moment then the answer is Overall complexity ,There is a solution in but in fact a solution that checks all points with coordinate from to and coordinate from to is fast enough There s no need to check any other points since implies that point is on one of the shortest paths between and 
128,You are given a range of positive integers from to Find such a pair of integers that and divides If there are multiple answers print any of them You are also asked to answer independent queries ,Print and Firstly the smallest value of you can have is and if any greater value fits then fits as well Secondly the absolute difference between and increases when you increase thus lessening the possibility of both numbers fitting into the range Overall complexity ,Let s notice that if we process the queries of type naively then each such query consumes time where is the size of the array So queries with large can be processed naively For queries with small we may notice two things there are only possible queries each number in the array affects only possible queries So for small we may maintain the exact answer for each query and modify it each time we modify an element in the array If we process naively all queries with and maintain the answers for all queries with we will obtain a solution having time complexity Note that as in most problems related to sqrt heuristics it may be optimal to choose the constant that is not exactly but something similar to it but most solutions should pass without tuning the constant 
129,You are given a matrix of size Each element of the matrix is either 1 or 0 You have to determine the number of connected components consisting of 1 s Two cells belong to the same component if they have a common border and both elements in these cells are 1 s ,The main idea is to read and process each row of the matrix separately To do this we will use DSU data structure The answer will be equal to the difference between the number of 1 s and the number of operations in DSU When processing the row we will keep the DSU for the previous row When processing a certain index in the row we will try to merge it with the element to the left of it and with the element to the top that s all we have to check here You also have to handle the fact that we cannot store the whole DSU since the number of components can be up to and it s impossible to store all required information for them So each time we process a row we have to renumerate all components in this row to ensure that every time we are operating with indices of components not greater than ,If then there is no suitable matrix The operation means xor Otherwise we can always construct a suitable matrix by the following method the first element of the first line will be equal to The second element of the first line is the third element is the last one is The first element of the second line will be the first element of the third line is the first element of the last line is The rest of the elements will be zero It is not difficult to verify that the matrix obtained satisfies all the restrictions 
130,Polycarp has a string consisting of lowercase Latin letters He encodes it using the following algorithm He goes through the letters of the string from left to right and for each letter Polycarp considers its number in the alphabet if the letter number is single digit number less than then just writes it out if the letter number is a two digit number greater than or equal to then it writes it out and adds the number after For example if the string is then Polycarp will encode this string as follows is the rd letter of the alphabet Consequently Polycarp adds to the code the code becomes equal to is the th letter of the alphabet Consequently Polycarp adds to the code and also the code becomes is the th letter of the alphabet Consequently Polycarp adds to the code the code becomes is the th letter of the alphabet Therefore Polycarp adds to the code the code becomes Thus code of string is You are given a string resulting from encoding the string Your task is to decode it get the original string by ,The idea is as follows we will go from the end of the string and get the original string Note that if the current digit is then a letter with a two digit number has been encoded Then we take a substring of length three from the end discard and get the number of the original letter Otherwise the current number then a letter with a one digit number was encoded We easily reconstruct the original letter Next discard the already processed characters and repeat the process until the encoded string is complete ,Let s iterate over all characters of the string from left to right excluding last character Suppose is a position of the current element of the string If increase answer by and increase by else just increase by 
131,You are given the string of length and the numbers Split the string to pieces of length and For example the string for can be split to the two strings and or to the two strings and Note it is allowed to split the string to the strings only of length or to the strings only of length see the second sample test ,Let s fix the number a of strings of length p and the number b of strings of length q If a p b q n we can build the answer by splitting the string s to a parts of the length p and b parts of the length q in order from left to right If we can t find any good pair a b then the answer doesn t exist Of course this problem can be solved in linear time but the constraints are small so you don t need linear solution Complexity O n2 ,Let s use a trie to store the given words Now let s imagine a procedure that checks if some string of length can be represented as a concatenation of some of these words If the words were prefix independent no word was a prefix of another word that task would be solvable with a greedy algorithm We could iterate over a string and maintain the current vertex of the trie we are in Append a current letter If there is no such transition in a trie it can t be represented If the vertex we go to is a terminal jump to the root of the trie Otherwise just go to that vertex However since the words aren t prefix independent we have a terminal on a path to other terminals Thus we can t immediately decide if we should jump to the root or just go Let s handle this with dynamic programming can we put letters in such a way that the vertex of a trie we are in is Is building a chainword letter by letter that different from this process Apparently it isn t Consider how many ways are there to put letters in a string so that the first hint is in a vertex and the second hint is in a vertex For the transition we can try all letters to put and jump to the corresponding vertices That obviously is too slow The intuition tells us that this dp should be calculated with some kind of matrix exponentiation since That dp can be rewritten as a matrix pretty easily However its size is up to the maximum number of vertices in a trie squared Some say that there is a way to compute the th power of such a huge matrix fast enough with Berlekamp Massey but I unfortunately am not familiar with it Thus we ll have to reduce the size of our matrix First notice that the only reachable states are such that the word that is written on a path from the root to is a suffix of a word that is written on a path from the root to or vice versa Look at it the other way if we build a trie on the reversed words then one of the vertices will be an ancestor of another one Now it s easy to estimate the number of states as the sum of depths of all vertices However since we look at ordered pairs of we should more or less double that amount That should be states at max This can probably pass with an optimal enough implementation We can do better though Let s merge the states and into one state The intuition is basically that you can swap the hints at will That makes the pairs unordered now there are up to pairs That surely will work fast enough The way to generate all the possible states is the following run a dfs bfs starting from that makes all valid transition and record all the states that can be visited While preparing the tests I only managed to get up to states and I would really love to hear an approach to either prove a tighter bound or to generate a test closer to the bound of 
132,You are given an integer and an undirected tree consisting of vertices The length of a simple path a path in which each vertex appears at most once between some pair of vertices is the number of edges in this path A diameter of a tree is the maximum length of a simple path between all pairs of vertices of this tree You are about to remove a set of edges from the tree The tree splits into multiple smaller trees when the edges are removed The set of edges is valid if all the resulting trees have diameter less than or equal to Two sets of edges are different if there is an edge such that it appears in only one of the sets Count the number of valid sets of edges modulo ,The task is obviously solved by dynamic programming so our first reaction should be to start looking for meaningful states for it Obviously one of the states is the vertex which subtree we are processing We can choose the root for the tree arbitrarily let it be vertex What can be the other helpful state Consider the method to find the diameter of the subtree of vertex The diameter can be one of the following paths either the longest path that is completely in some subtree of or the concatenation of the longest paths that start in vertex and end in different subtrees The diameter is the longest path Thus the diameter being less than or equal to means that all paths should have length less than or equal to If we can guarantee that no path that is completely in some subtree of have length greater than then we will only have to worry about not concatenating long paths from different subtrees Phrase it the other way around if we never concatenate the paths from the different subtrees in such a way that their total length is greater than then no diameter will be greater than Thus we can attempt to have the number of ways to cut some edges in the subtree of in such a way that there is no path of length greater than and the longest path starting at vertex has length Now for the transitions For the simplicity let vertex have exactly two children It s not too hard to merge their s Iterate over the length of the first child the length of the second child If then you can concatenate their longest paths and the longest path for will be of length You can also cut either of the edges from to the first child or to the second child The approach is good however it s not clear how to make it work on a larger number of children Also the complexity sounds pretty bad Instead of merging children to each other let s merge each child to the of one by one can store the current maximum length over all processed children When processing a new child you can choose to cut or not to cut the edge to it So you can iterate over the current longest path from and the longest path from that child So far the only way to estimate the complexity is to say that each child has to merge its dp to the parent in thus making the algorithm That s obviously too slow The trick that makes the solution fast is to iterate not to but to the height of the subtree of and the subtree of a child Surely that is allowed since the path just can t grow longer than that value Consider the even worse option not the height but the size of the subtree It s easy to see that the size is always greater or equal than the height Interpret the merge the following way enumerate the vertices inside all the subtrees of the processed children and the vertices inside the subtree of the new child Iterating up to the size of the subtree is the same number of moves as going over the vertices in it The merge will go over all the pairs of vertices such that the first vertex of the pair is in the first set and the second vertex is in the second set Thus each pair of vertices of the tree will be processed exactly once in lca of these vertices There are such pairs thus such s work in Overall complexity ,Let s calculate for each position position the closest greater from the right element to and add directed edge from to Then we will get oriented forest or tree if we d add fictive vertex where all edges are directed to some root So we can look at current subsegment we need to calculate the answer for as at a number of marked vertices in the tree Then the answer itself is a longest path up to the tree consisting only from marked vertices Key observation is next if and are marked and is an ancestor of then any vertex on path from to is also marked So the longest path up to the tree consisting only from marked vertices has length equal to a number of marked vertices on path to the root And we have three types of queries mark a vertex unmark a vertex and calculate maximum number of marked vertices among all paths to the root It can be done with Segment Tree on Euler Tour of the tree if we calculate and for each vertex in dfs order then marking unmarking is just adding to a segment and maximum among all paths is a maximum on the whole tree Result time complexity is and space complexity is 
133,You are given a rooted tree consisting of vertices numbered from to The root of the tree is a vertex number A tree is a connected undirected graph with edges You are given queries The th query consists of the set of distinct vertices Your task is to say if there is a path from the root to some vertex such that each of the given vertices is either belongs to this path or has the distance to some vertex of this path ,Firstly let s choose some deepest farthest from the root vertex in the query among all such vertices we can choose any It is obvious that every vertex in the query should either belong to the path from the root to or the distance to some vertex of this path should be at most one Now there are two ways write some LCA algorithms and other hard stuff which is unnecessary in this problem or write about lines of code and solve the problem Let s take every non root vertex except and replace it with its parent So what s next Now the answer is if vertex after transformation belongs to the path from root to Now we just need to check if it is true We can do this using the very standard technique firstly let s run dfs from the root and calculate for each vertex the first time we visited it and the last time we visited it We can do this using the following code void dfs int v int par 1 tin v T for auto to g v if to par continue dfs to v tout v T Initially equals zero Now we have a beautiful structure giving us so much information about the tree Consider all segments We can see that there is no pair of intersecting segments The pair of segments and is either non intersecting at all or one segment lies inside the other one The second beautiful fact is that for each vertex in the subtree of the segment lies inside the segment So we can check if one vertex is the parent of the other the vertex is the parent of the vertex if and only if and the vertex is the parent of itself How do we check if the vertex lies on the path from the root to the vertex It lies on this path if the root is the parent of it is always true and is the parent of This approach can be used for each path such a path from to that is either or Time complexity ,Let s construct a tree by the following algorithm if d ge n let s print and terminate the program Otherwise let s keep the array deg of the length n which will represent degrees of vertices The first step is to construct the diameter of the tree Let first d 1 vertices form it Let s add d edges to the answer increase degrees of vertices corresponding to this edges and if some vertex has degree greater than k print and terminate the program The second and the last step is to attach the remaining n d 1 vertices to the tree Let s call the vertex if its degree is less than k Also let s keep all vertices forming the diameter in some data structure which allows us to take the vertex with the minimum maximal distance to any other vertex and remove such vertices It can be done by for example set of pairs dist v v where dist v is a maximum distance from the vertex v to any other vertex Now let s add all vertices from starting from the vertex d 1 0 indexed to the vertex n 1 let the current vertex be u We get the vertex with the minimum maximal distance to any other vertex let it be v Now we increase the degree of vertices u and v add the edge between they and if v still be return it to the data structure otherwise remove it The same with the vertex u it is obvious that its maximal distance to any other vertex will be equals dist v 1 If at any step our data structure will be empty or the minimum maximal distance will be equals d the answer is Otherwise we can print the answer See my solution to better understanding Overall complexity O n log n or O n depends on implementation 
134,Polycarp is editing a complicated computer program First variable is declared and assigned to Then there are instructions of two types assign a value or spend burles to remove that instruction thus not reassign block execute instructions inside the block if the value of is and ignore the block otherwise blocks can contain instructions and other blocks inside them However when the value of gets assigned to the computer breaks and immediately catches fire Polycarp wants to prevent that from happening and spend as few burles as possible What is the minimum amount of burles he can spend on removing instructions to never assign to ,Consider the following dynamic programming the minimum cost to make have value after the th line The transitions here are pretty easy on set you just consider two options of skipping or not skipping the instructions and on if you either go to the next line or to the end of the block depending on the value There are a lot of possible values so that dp works in First let s notice that all the values that don t appear in the input won t matter so you can keep only the existing values in the dp Next let s consider the following modification to it What happens when you enter an if block It s actually the same dp but the only starting value is not with cost as in the beginning of the whole program but some value with some cost So let s calculate this dp separately from the outer one and just merge the values together Notice that if some value doesn t appear inside the if block then its cost can not decrease exiting out of it Thus it s enough to calculate the inner dp only for values that appear inside the if block Okay the transitions for if became easier The set transitions are still slow though Examine the nature of them All the values besides the written on the set instruction increase their cost by As for the its cost becomes equal to the cost of the cheapest value before the instruction Thus let s maintain the dp in some data structure that allows to add the same integer to all elements and take the minimum of its elements That can be done with a set and a single integer that stores the current shift that should be applied to all elements Surely you ll also need a map to retrieve the current cost of particular values The final part is fast merging of the if block dp and the outer one It might not appear obvious but if you do that in a straightforward manner of adding all the costs from if one by one it can become in total So we can apply small to large and swap these dp s based on their sizes Overall complexity ,Let s the same sum of blocks in the answer Obviously can be represented as a sum of some adjacent elements of i e for some and Iterate over all possible blocks in and for each sum store all the blocks You can use map int vector pair int int to store blocks grouped by a sum You can do it with the following code map int vector pair int int segs for int r 0 r n r int sum 0 for int l r l 0 l sum a l segs sum push back l r Note that blocks are sorted by the right end in each group After it you can independently try each group there are of them and find the maximal disjoint set of blocks of a group You can do it greedily each time taking into the answer segment with the smallest right end Since in each group they are ordered by the right end you can find the required maximal disjoint block set with one pass Let s assume is the current group of blocks they are ordered by the right end then the following code constructs the maximal disjoint set int cur 0 int r 1 vector pair int int now for auto seg pp if seg first r cur now push back seg r seg second Choose the maximum among maximal disjoint sets for the groups 
135,You wrote down all integers from to padding them with leading zeroes so their lengths are exactly For example if then you wrote out A block in an integer is a consecutive segment of equal digits that cannot be extended to the left or to the right For example in the integer there are three blocks of length one block of length and two blocks of length For all integers from to count the number of blocks of length among the written down integers Since these integers may be too large print them modulo ,Presume that we want to calculate the number of blocks of length Let s divide this blocks into two types blocks which first element is a first element of integer or blocks which last element is a last element of integer for example blocks and in integer other blocks At first let s calculate the number of blocks of first type We can choose positions of this block at the start of end of the integer Now we can choose digit for this block After that we can chose digits of adjacent block if these blocks contain the same digit then we length of blocks which we want calculate greater than so we have only variations of digit in adjacent block Finally the can chose the remaining digit ways So the total number of block of first type is Now let s calculate the number of blocks of second type We can choose positions of this block all position except the start and end of integer Now we can choose 10 digit for this block After that we can chose digits of adjacent block for block to the left and for block to the right Finally the can chose the remaining digit ways So the total number of block of second type is That s almost all We have one corner case If then we number of blocks is always ,Let s compute the answer to the array where is the digit at the position in the number we are looking for Let be the position of the last digit in number be the position of the last digit in number Then denote and consider the cases if then the sum of was exactly then if then the sum was greater than and we need to look at the next digit of the number If there isn t one we can t get the answer we ll output Otherwise we recalculate and reduce by one if now and then Otherwise we deduce since we cannot get more than when adding two digits and the cases where have already been considered before After considering the cases reduce and by one and repeat the checks as long as or In the situation where but we will still have uncheked digits of number so we will also output Otherwise we output an array with the answer without leading zeros 
136, You are given a string and a string both consisting only of lowercase Latin letters It is guaranteed that can be obtained from by removing some possibly zero number of characters not necessary contiguous from without changing order of remaining characters in other words it is guaranteed that is a subsequence of For example the strings and are subsequences of the string But the strings are not subsequences of the string You want to remove some substring contiguous subsequence from of such that after removing this substring will remain a subsequence of If you want to remove the substring then the string will be transformed to where is the length of Your task is to find the maximum possible length of the substring you can remove so that is still a subsequence of ,Let be such rightmost position in that the substring is the subsequence of We need values for all from to We can calculate it just iterating from right to left over all characters of and maintaining the pointer to the string as in easy version Then let s iterate over all positions from to and maintain the pointer as in the easy version which tells us the maximum length of the prefix of we can obtain using only the substring exclusively Suppose we want to remove the substring of starting from Then if then let be otherwise let be tells us the farthest rightmost character of the substring we can remove So we can update the answer with the value and go to the next position and don t forget to increase if needed ,There are at least two different approaches to this problem You can iterate over all substrings of of length and calculate for each of them the number of its occurrences in and try to update the result with the current substring Also you can iterate over all two grams in the alphabet and do the same as in the aforementioned solution 
137,Consider the infinite sequence of integers The sequence is built in the following way at first the number is written out then the numbers from to then the numbers from to then the numbers from to and so on Note that the sequence contains numbers not digits For example number first appears in the sequence in position the elements are numerated from one Find the number on the th position of the sequence ,Let s decrease by one Now let s determine the block with the th number To do that let s at first subtract from then subtract then subtract and so on until we got negative The number of subtractions will be the number of the block and the position in the block will be the last nonnegative number we will get ,Let s fix the length of the first block iterate through i from 0 to n 3 Let s also try to maximize the length of the third block using the second pointer So initially the length of the first block is 1 and the maximum in the block is a 0 after that its length will be 2 and the maximum will be max a 0 a 1 and so on Let s move the left border of the third block r while a r le a 0 and the second block have at least one element After we expanded the third block consider some cases if its maximum is less than a 0 then we don t need to consider this partition we expanded the third block as much as we can but didn t find the required maximum Otherwise its maximum fits our conditions Then let s find the minimum in the second block Let it be mn If mn mx this partition is also bad If mn mx this partition is good and we can just print it Otherwise mn mx and we need to fix the second block somehow I claim that we only need to expand it by at most one element Let s see why is it true Consider we want to expand it to the right the other case just uses the same logic If we expanded our block by one element to the right and the new value in it is less than mx then this partition is bad and we can not use it this is also the reason why we are trying to maximize the length of the third block Otherwise this value is always mx because the first and the third blocks didn t have values greater than mx There are some cases in the implementation we need to consider carefully first we need to find the minimum in the second block fast enough This can be done if we store it as a multiset set with repetitions Second we can remove the only maximum in the third or the first block by expanding the second one This can be handled easily if we just store all three blocks not only the second one as multisets And the last case is that we sometimes need to move the left border of the third block to the right This happens when we expand the first block and the second block becomes empty So this happens only O n times in total Total time complexity of this solution is O n log n There is also another solution from Gassa Let us start solving by asking the following question in which segments will the maximal values end up Consider the maximum value m in the whole array If there are at least three of them a valid answer is to pick any maximum except the first and the last as the middle segment For example m 3 can be partitioned as or as where the middle segment is marked with square brackets Otherwise all m should end up in the middle segment so that maximums to the left and to the right are less For example in we have to put both threes into the middle segment Let us now calculate the minimum value v on the middle segment considering the numbers between those equal to m For example in the value v min 3 1 3 1 All numbers greater than v should also go into the middle segment and everything between them which can result in v decreasing even more We have to expand the borders of the middle segment until the minimum value is such v that there are only values not greater than v left outside Continuing with the example we see that in the middle segment should be expanded to Conversely if the maximum m was unique then v m and we didn t have to expand the middle segment at this stage For example in the current state is If the maximums to the left and to the right are exactly v we found an answer Otherwise any possible middle segment contains the middle segment that we now got So we have to expand the middle segment either to the left or to the right As a result the value v may become smaller which can cause another expansion What s left is to decide where to expand when we have a choice We would like to do it greedily Indeed consider three values the minimum on middle segment v the maximum on left segment u and the maximum on right segment w When we expand the middle segment each of them can only decrease And if we find an answer the equation u v w will be satisfied So as we make the minimum of these three values smaller we have less and less opportunities to make them equal Thus we can pick the side of expansion after which the value min u v w is larger and if these are equal pick any For example in the state we have u 3 v 4 and w 3 If we expand to the left we get where u 1 v 3 and w 3 If we expand to the right we get where u 3 v 2 and w 3 Our algorithm will pick expanding to the right however there is no valid answer in this example anyway Implementation let us precalculate the maximums on all prefixes and all suffixes of the array Then we can expand the middle segment by one element in O 1 and the total running time is linear 
138,You are given an array consisting of positive integers It is known that in this array all the numbers except one are the same for example in the array all numbers except one are equal to Print the index of the element that does not equal others The numbers in the array are numbered from one ,To find a number that differs from the rest of the numbers in the array you need to iterate through the array maintaining two pairs of numbers x 1 c 1 and x 2 c 2 where x i is a number from the array c i is how many times the number x i occurs in the array Then to get an answer you need to find the position of the x i that occurs in the array exactly once i e c i 1 ,We will build the answer greedily from the highest significant bit to the lowest one Let s analyze how to check if the answer can have the highest bit equal to It means that every value in should have its highest bit equal to so for every exactly one of the numbers should have this bit equal to For both of the given arrays we can calculate how many elements have which value of this bit and then the number of elements with in this bit in the array should be equal to the number of elements with in the array and the same for elements with in and elements with in If these values are equal it means that the elements of and can be matched in such a way that in every pair the XOR of them has in this bit If it is so then the highest bit of the answer is otherwise it is Okay then let s proceed to the next bit Should we just do the same to check if this bit can be equal to in the answer Unfortunately that s not enough Let s look at the case We can get the value in the th bit or in the st bit but not in both So for the next bit we need to make sure that not only we can get in the result but we can also do this without transforming some of the s to s in the higher bits If it is impossible it doesn t matter if we can get in the current bit since it will be suboptimal so we have to use an ordering that gets in this bit In general case it means that we have to solve the following subproblem check if we can obtain in several bits of the answer let these bits be to are the bits that we have already checked is the new bit we are trying to check Let be the number that has in every bit and in every other bit The elements should be matched in such a way that If we group all numbers from and from according to the value of or then for every group of elements from there is a corresponding group in such that we can match the elements from the first group with the elements from the second group So if for every such group its size in is equal to the size of the corresponding group in then we can set all bits from to simultaneously Some implementation notes if the number of bits we need to check is big the number of groups can become too large to handle all of them since it is So to store the number of elements in each group we should use some associative data structure like for example in C If you use a map splitting elements into groups will be done in so in total you will get complexity of where is the maximum possible value in the input 
139,You are given integers For each find its and such that where is the greatest common divisor of and or say that there is no such pair ,Firstly for the fast factorization of given let s use Sieve of Eratosthenes let s for each value calculate its minimum prime divisor in the same manner as the sieve do Now we can factorize each in time by separating its prime divisors one by one using precalculated array Suppose we have a factorization If then any divisor of is divisible by so do the sum of divisors Obviously the answer is Otherwise we can divide all prime divisors into two non empty groups and and take and Any division is valid proof is below so for example we can take and Let s prove that if and then Let s look at any We can assume that and without loss of generality But it means that then In other words there are no prime divisor of which divides so the Time complexity is for the sieve and finding answers ,Let s denote for the maximum number of moves for which the numbers and can be made equal It is easy to understand that the number of moves is maximum when and each time we divided or by a prime number That is sum of exponents of prime divisors of sum of exponents of prime divisors of Let s denote by the minimum number of moves for which the numbers and can be made equal Consider a few cases If then If or then Otherwise then Then the answer is possible in the following cases and and or and 
140,You stumbled upon a new kind of chess puzzles The chessboard you are given is not necesserily but it still is Each square has some number written on it all the numbers are from to and all the numbers are pairwise distinct The th square in the th row has a number written on it In your chess set you have only three pieces a knight a bishop and a rook At first you put one of them on the square with the number you can choose which one Then you want to reach square possibly passing through some other squares in process then square and so on until you reach square In one step you are allowed to either make a valid move with the current piece or replace it with some other piece A knight can move to a square that is two squares away horizontally and one square vertically or two squares vertically and one square horizontally A bishop moves diagonally A rook moves horizontally or vertically The move should be performed to a different square from the one a piece is currently standing on You want to minimize the number of steps of the whole traversal Among all the paths to have the same number of steps you want to choose the one with the lowest number of piece replacements What is the path you should take to satisfy all conditions ,There are a lot of different solutions for the problem Most of them have the similar structure The first part is to find the shortest distance between the states and where and are the coordinates of the square and is the current piece This can be done with 0 1 bfs Floyd or Dijkstra Just represent the triple as a single integer by transforming it to and do everything on that graph The second part is to write some dp to go from th square with piece to th square with piece The value of this is a pair moves replacements It is easy to see that you can always choose the minimum of two such pairs while updating Overall complexity may vary We believe is achievable However the particular solution I coded works in ,First get rid of the corner cases If the string doesn t contain either of the letters the answer is The general solution to the problem is to consider every single way to modify the path then find the union of them Well every single path is too much let s learn to reduce the number of different sequences of modifications that we have to consider The main observation is that all cells that the robot can visit are enclosed in the space formed by the following two paths the first R is duplicated the maximum number of times then the last D is duplicated the maximum number of times the first D is duplicated the maximum number of times then the last R is duplicated the maximum number of times You can realize that by drawing the visited cells for some large test To show that more formally you can consider the visited cells row by row Let s show that for every two different visited cells in the same row all cells in between them can also be visited In general case we want to show that we can take the prefix of the path to the left one of these cells and duplicate any R on it to reach the right cell The suffixes of the paths will remain the same as in the initial path If there exists an R on the prefix then we are good Otherwise the reason that it doesn t exist is that we duplicated D too many times Reduce that and there will be R immediately after reaching the cell or earlier We should also show that the number of R s on the path to the left cell won t reach the maximum allowed amount until reaching the right cell Use the fact that the number of D s on both prefixes of the paths is the same The other non obvious part is that you can t reach cells outside this space However that can also be shown by analyzing each row independently Finally about the way to calculate the area of this space The main idea is to calculate the total number of cells outside this area and subtract it from Notice that non visited cells form two separate parts the one above the first path and the one to the left of the second path These are pretty similar to each other Moreover you can calculate them with a same function If we replace all D s in the string with R and vice versa then these parts swap places So we can calculate the upper part swap them and calculate it again I think the algorithm is best described with a picture Consider test for example First there are some rows that only have one cell visited Then the first R in the string appears Since we duplicate it the maximum amount of times it produces a long row of visited cells The remaining part of the part becomes the outline of the area Note that the row that marks the end of the string always ends at the last column Thus only at most first rows matter To be exact the amount of rows that matter is equal to the number of letters D in the string For each letter D let s calculate the number of non visited cells in a row it goes down to I found the most convenient way is to go over the string backwards We start from the row corresponding to the number of letters D in the string It has zero non visited cells We can maintain the number of non visited cells in the current row If we encounter an R in the string we add to this number If we encounter a D we add the number to the answer We have to stop after the first R in the string The later well earlier since we are going backwards part corresponds to the prefix of letters D the starting column on the picture Each of these rows have visited cell so non visited So we can easily calculate this part as well Overall complexity per testcase 
141,There are Christmas trees on an infinite number line The th tree grows at the position All are guaranteed to be distinct Each point can be either occupied by the Christmas tree by the human or not occupied at all Non integer points cannot be occupied by anything There are people who want to celebrate Christmas Let be the positions of people note that all values should be and all should be You want to find such an arrangement of people that the value is the minimum possible in other words the sum of distances to the nearest Christmas tree for all people should be minimized In other words let be the distance from the th human to the nearest Christmas tree Then you need to choose such positions that is the minimum possible ,In this problem we first need to consider all points adjacent to at least one Christmas tree then all points at the distance two from the nearby Christmas tree and so on What it looks like Yes well known multi source bfs Let s maintain a queue of positions and the set of used positions and the distance to each vertex of course In the first step we add all positions of the Christmas tree with a zero distance as initial vertices Let the current vertex is If this is the Christmas tree then just add and to the queue if these vertices aren t added already and continue Otherwise increase the answer by and add to the array of positions of people When the length of this array reaches interrupt bfs and print the answer Don t forget about some special cases as using in Java or using in C because this can lead to the quadratic complexity Time complexity ,It is easy to understand that the optimal answer is achieved in one of three cases Vasya is trying to visit page without visiting pages and Vasya first goes to the page and then to the page Vasya first goes to the page and then to the page In the first case Vasya can go directly to the page from the page if is divided by In the second case Vasya can get to page through page if is divided by The required number of actions will be equal to Similarly in the third case Vasya can go to the page through the page if is divided by The required number of actions will be equal to If none of the three options described above is appropriate then there is no answer 
142,There are candies put from left to right on a table The candies are numbered from left to right The th candy has weight Alice and Bob eat candies Alice can eat any number of candies from the left she can t skip candies she eats them in a row Bob can eat any number of candies from the right he can t skip candies he eats them in a row Of course if Alice ate a candy Bob can t eat it and vice versa They want to be fair Their goal is to eat the same total weight of candies What is the most number of candies they can eat in total ,We can solve the problem with a two pointers technique Let be the left pointer initially at and be the right pointer initially at Let s store Alice and Bob s current totals as and Let s iterate from the left to the right For each we should do the following Increase by Alice eats the th candy Move leftwards until Bob s total is at least Alice s total and update every time we move If the two pointers have crossed then both Alice and Bob took the same candy which is not possible So we should exit and output the current answer Otherwise if after this step we should update the current answer to be the value that is equal to Alice and Bob Both and move at most times in total so the solution runs in ,At first let s precalculate array pos such that pos a i i Now presume that we have to calculate answer for b i Then there are two cases let s denote lst max limits 1 le j i pos b j initially lst 1 if pos b i lst then we have to spend 1 2 cdot pos b i i 1 seconds on it second on the gift b i pos b i i 1 seconds on removing gifts above and pos b i i 1 seconds on pushing these gifts if pos b i lst then we can reorder gifts by previous actions such that gift b i be on the top of stack So we spend only second on it 
143,There is a matrix of size filled with integers For every Obviously every integer from occurs exactly once in this matrix You have traversed some path in this matrix Your path can be described as a sequence of visited cells denoting that you started in the cell containing the number then moved to the cell with the number and so on From the cell located in th line and th column we denote this cell as you can move into one of the following cells only if only if only if only if Notice that making a move requires you to go to an adjacent cell It is not allowed to stay in the same cell You don t know and exactly but you have to find any possible values for these numbers such that you could start in the cell containing the integer then move to the cell containing in one step then move to the cell containing also in one step and so on Can you choose and so that they don t contradict with your sequence of moves ,You can notice that moves of kind and are changing value to and Thus you can determine by checking adjacent nodes in the path The answer is if there are one or zero distinct values of differences not counting difference of You can also set to arbitrary big value it doesn t really matter until you can fit all values will work just fine Finally knowing and simulate the process and check that all moves are valid Overall complexity ,This is easy dynamic programming problem It is easy to understand that we don t need to go down at all otherwise your solution will be Dijkstra s algorithm not dynamic programming Let be the minimum required time to reach the floor if we not in the elevator right now and be the minimum required time to reach the floor if we in the elevator right now Initially all values are except and Transitions are pretty easy we was not in the elevator and going to the next floor using stairs we was in the elevator and going to the next floor using stairs we was not in the elevator and going to the next floor using elevator we was in the elevator and going to the next floor using elevator The answer for the th floor is Time complexity 
144,Santa has to send presents to the kids He has a large stack of presents numbered from to the topmost present has number the next present is and so on the bottom present has number All numbers are distinct Santa has a list of presents he has to send He will send them To send a present Santa has to find it in the stack by removing all presents above it taking this present and returning all removed presents on top of the stack So if there are presents above the present Santa wants to send it takes him seconds to do it Fortunately Santa can speed the whole process up when he returns the presents to the stack he may reorder them as he wishes only those which were above the present he wanted to take the presents below cannot be affected in any way What is the minimum time required to send all of the presents provided that Santa knows the whole list of presents he has to send and reorders the presents optimally Santa cannot change the order of presents or interact with the stack of presents in any other way Your program has to answer different test cases ,At first let s precalculate array pos such that pos a i i Now presume that we have to calculate answer for b i Then there are two cases let s denote lst max limits 1 le j i pos b j initially lst 1 if pos b i lst then we have to spend 1 2 cdot pos b i i 1 seconds on it second on the gift b i pos b i i 1 seconds on removing gifts above and pos b i i 1 seconds on pushing these gifts if pos b i lst then we can reorder gifts by previous actions such that gift b i be on the top of stack So we spend only second on it ,Note that if we cannot get joy then we cannot get and if we can get at least then we can get at least These facts allow us to use binary search to find the answer Now we need to understand how exactly we can recognize whether we can gain joy at least or not We can enter at most shops so we always need to take two gifts from some store which means there must be a store in which we can find two or more gifts with pleasure at least Also each friend should receive a gift which means that we should be able to buy each gift with pleasure at least It takes O nm to check that both of these conditions are met The total solution works in O nm log nm 
145,You are given a bracket sequence consisting of characters and or You perform several operations with it During one operation you choose the prefix of this string some amount of first characters of the string that is and remove it from the string The prefix is considered if one of the following two conditions is satisfied this prefix is a regular bracket sequence this prefix is a palindrome of length A bracket sequence is called regular if it is possible to obtain a correct arithmetic expression by inserting characters and into this sequence For example sequences and are regular while and are not The bracket sequence is called palindrome if it reads the same back and forth For example the bracket sequences and are palindromes while bracket sequences and are not palindromes You stop performing the operations when it s not possible to find a prefix Your task is to find the number of operations you will perform on the given string and the number of remaining characters in the string You have to answer independent test cases ,Consider the first character of the string If it is then we can remove the first two characters of the string and continue because the prefix of length will be either a palindrome or a regular bracket sequence If the first character of the string is then this is a bad case Of course the regular bracket sequence can t start with so this prefix should be a palindrome And what is the shortest palindrome we can get with the first character It is the closing bracket then some possibly zero amount of opening brackets and another one closing bracket We can see that we can t find a palindrome shorter than this one because we have to find a pair for the first character So if the first character of the string is then we just remove anything until the next character inclusive To not remove any characters explicitly we can just use pointers instead And the last thing is to carefully handle cases when we can t do any operations ,Note that means either or whereas means both and We can greedily solve this by starting out our string with all 1 s then marking and as 0 whenever we are forced to because Then we can simply check whether all of the conditions are valid to confirm Code 90915688 
146,You are given an array consisting of positive integers and queries to this array There are two types of queries for each index such that set find the minimum among such that We decided that this problem is too easy So the array is given in a compressed form there is an array consisting of elements and a number in the input and before all queries is equal to the concatenation of arrays so the size of is ,Most of the solutions used the fact that we can read all the queries compress them and process after the compression using simple segment tree But there is also an online solution Let s build a sparse table on array to answer queries on segments that are not modified in To process modification segments we will use implicit segment tree and lazy propagation technique We do not build the whole segment tree instead in the beginning we have only one node for segment and if some modification query accesses some node but does not modify the complete segment this node maintains only then we create the children of this node So the leaves of the segment tree are the nodes such that their segments are completely set to some value or not modified at all Since each modification query affects only nodes the resulting complexity will be ,Note the fact that if the number of minus signs is greater than the number of plus signs by at least then there is sure to be a pair of standing next to minus signs according to the Dirichlet principle When we apply the operation of replacing two adjacent minus signs with a plus sign the balance the difference of plus signs and minus signs increases by Then we need to find the number of subsections such that the balance on them is a multiple of and non positive then we can apply the operations until the balance is The balance value on the segment equals the balance value on the right boundary minus the balance value on the left boundary i e we can find by prefix sums 
147,Given three integers and find the medium number between all of them The medium number is the number that is neither the minimum nor the maximum of the given three numbers For example the median of is since the minimum is and the maximum is ,Here are two ways to implement what s given in the problem Take input as an array a 1 a 2 a 3 and sort it Output the middle element Write two if statements The first if a b text and a c text or a b text and a c output a Else if b a text and b c text or b a text and b c output b Else output c ,If we sort the students in order of non decreasing their skill we can see that the minimum cost of the team with the lowest skill let s call it the first team is equal to if is already sorted the cost of the second team is and so on So if we sort in non decreasing order then the answer is 
148,A ticket is a string consisting of six digits A ticket is considered lucky if the sum of the first three digits is equal to the sum of the last three digits Given a ticket output if it is lucky or not Note that a ticket can have leading zeroes ,We need to check if the sum of the first three digits is equal to the sum of the last three digits This is doable by scanning the input as a string then comparing the sum of the first three characters with the sum of the last three characters using the if statement and the addition operation ,The naive solution would be the number of sequences of allowed digits with length and sum We compute it for and for every possible and the answer is Let s speed this up Let s denote the following polynomial where if is an allowed digit otherwise It s easy to see that the coefficients of are equal to the values of Using mathematical induction we may prove that the coefficients of are equal to So now we need to compute There are two possible ways to do this that result in complexity The first option is to apply binary exponentiation with NTT polynomial multiplication The second option is to use the fact that if we apply NTT to a polynomial we get a set of its values in some points So if we exponentiate these values we get a set of values of exponentiated polynomial in the same points So we may apply NTT to treating it as a polynomial of degree raise each resulting value to the power of and apply inverse transformation 
149,Recently Luba bought a very interesting book She knows that it will take seconds to read the book Luba wants to finish reading as fast as she can But she has some work to do in each of next days The number of seconds that Luba has to spend working during th day is If some free time remains she can spend it on reading Help Luba to determine the minimum number of day when she finishes reading ,Let s read the book greedily On th day Luba will read for seconds Subtract value for each day from until becomes less or equal to zero That will be the day Luba finishes the book Overall complexity ,Suppose Let s try to minimize and maximize Let be the minimum divisor of greater than Then let be the minimum divisor of that isn t equal and If isn t equal and then the answer is otherwise the answer is Time complexity per query 
150,You are given a string consisting of lowercase Latin letters You have to remove i e zero or one character of this string in such a way that the string you obtain will be lexicographically smallest among all strings that can be obtained using this operation String is than string if and or there exists a number such that and and For example is smaller than is smaller than is smaller than ,By the definition of lexicographical comparing we can see that if we can remove one character we always have to do it Besides we have to remove the character from the leftmost position such that and or from the position if there is no such ,First of all let s think about how we should rearrange the two strings in such a way that if that is ever possible It s always optimal to arrange s characters increasingly in lexicographic order and s characters decreasingly Since initially both and contain a character the first time receives any other letter than the answer will always be because that character will always be lexicographically larger than s first character which should be In the other case we know that doesn t have any other characters than so we can compare the string with multiple characters and we know that will be smaller if and only if it s only formed of s and has a smaller size than 
151,You are given a sequence consisting of integers Let s call a group of consecutive elements a Each is characterized by two indices the index of its left end and the index of its right end Denote by a of the sequence with the left end in and the right end in i e For example if then are We split the given sequence into so that each element is in one the sums of elements for all are For example if then such a sequence can be split into three Each element belongs to exactly the sum of the elements of each is Let s define of split as the length of the longest For example the thickness of the split from the example above is Find the minimum thickness among all possible splits of the given sequence of into in the required way ,Let s iterate over the length of the first segment of the split Having fixed it we actually fixed the sum that needs to be collected on all other segments Since each element must belong to exactly one segment we can build other segments greedily If we have found a solution we will remember the length of the longest segment in it and try to update the answer We have possible lengths of the first segment for each of which we greedily built the answer for Thus the asymptotics of the solution will be ,We need to minimize the result of the bitwise operation so for convenience we represent the answer as a mask Firstly let s assume that this mask is composed entirely of ones Let s go from the most significant bit to the least significant one and try to reduce the answer To understand whether it is possible to remove the th bit remove it and check if the graph in which all the weights are submasks of the current answer is connected for this you can use depth first search or a disjoint sets union If the graph is connected then the bit can obviously be thrown out and if not it cannot and must be returned 
152,You are given an array and two integers and You can choose some subarray The cost of subarray is equal to where is the least integer greater than or equal to For example if and then the cost of some subarrays are Your task is to find the maximum cost of some subarray possibly empty of array ,At first let s solve this problem when m 1 and k 0 it is the problem of finding subarray with maximum sum For each position from 1 to n we want to know the value of maxl i max limits 1 le j le i 1 sum j i where sum l r sum limits k l k le r a k and sum x 1 x 0 We will calculate it the following way maxl i will be the maximum of two values 0 because we can take segments of length 0 a i maxl i 1 The maximum sum of some subarray is equal to max limits 1 le i le n maxl i So now we can calculate the values of best i max limits 0 le len i len cdot m ge 0 sum i len cdot m 1 i len k the same way best i is the maximum of two values 0 sum i m 1 i k best i m After calculating all values best i we can easily solve this problem At first let s iterate over the elements best i When we fix some element best i lets iterate over the value len 1 2 dots m and update the answer with value best i sum i len i 1 k ,The optimal strategy is to greedily take the highest bit we have enough operations to set in every array element To do this we maintain a count for each bit with the number of elements that have it set already The cost to set the th bit will be We go from the highest bit to the lowest If we have enough operations left we set the bit subtract its cost from the operations and move to the next lower bit If we don t have enough operations we move on to the next lower bit and don t modify the operations We stop once we processed bit The time complexity is 
153,You are given an array consisting of integer numbers You have to color this array in colors in such a way that Each element of the array should be colored in some color For each from to there should be element colored in the th color in the array For each from to all elements colored in the th color should be Obviously such coloring might be impossible In this case print Otherwise print and coloring i e numbers where and is the color of the th element of the given array satisfying the conditions above If there are multiple answers you can print ,How can we solve this problem Firstly let s sort the initial array but maintain the initial order of the elements in the array to restore the answer Then let s just distribute all the colors Let s color the first element in the first color the second one in the second the th element in the th color the th in the first color and so on So we color the th element in the color is just modulo operation We can see that the answer is if there is an element with frequency at least in the array by pigeonhole principle Otherwise our solution builds the correct answer So we can try to find such element in the array naively using counting sort or many other approaches Time complexity or ,Let s use the dynamic programming Let be the number of paths on the prefix of blocks of the same color To make transitions in such dynamics for the position we will iterate over the position in which the block started Denote as the number of the same elements as and between them then such a transition creates combinations This solution works in complexity 
154,You are given an array consisting of integers In one move you can choose two indices such that and set You can perform such moves any number of times possibly zero You can choose different indices in different operations The operation is the operation of assignment i e you choose and and replace with Your task is to say if it is possible to obtain an array with an odd not divisible by sum of elements You have to answer independent test cases ,Firstly if the array already has an odd sum the answer is Otherwise we need to change the parity of the sum so we need to change the parity of some number We can do in only when we have at least one even number and at least one odd number Otherwise the answer is ,Note is that after doing two operations of the same type they are cancelled out in terms of parity since we would change the parity of all elements once then change it back again So we know that we will do each operation exactly or time It is possible to check all possible cases just by simulating or we can notice that all elements on all indices of the same parity have the same parity and if they do we can always find an answer by doing just a single type of operation a single time in case the array doesn t already contain all elements of the same parity The time complexity is 
155,Nura wants to buy gadgets She has only burles for that She can buy each gadget for dollars or for pounds So each gadget is selling only for some type of currency The type of currency and the cost in that currency are not changing Nura can buy gadgets for days For each day you know the exchange rates of dollar and pound so you know the cost of conversion burles to dollars or to pounds Each day from to Nura can buy some gadgets by current exchange rate Each day she can buy any gadgets she wants but each gadget can be bought no more than once during days Help Nura to find the minimum day index when she will have gadgets Nura always pays with burles which are converted according to the exchange rate of the purchase day Nura can t buy dollars or pounds she always stores only burles Gadgets are numbered with integers from to in order of their appearing in input ,If Nura can buy k gadgets in x days then she can do that in x 1 days So the function of answer is monotonic So we can find the minimal day with binary search Denote lf 0 the left bound of binary search and rg n 1 the right one We will maintain the invariant that in left bound we can t buy k gadgets and in right bound we can do that Denote function f d equals to 1 if we can buy k gadgets in d days and 0 otherwise As usual in binary search we will choose If f d 1 then we should move the right bound rg d and the left bound lf d in other case If binary search found the value lf n 1 then the answer is 1 otherwise the answer is lf Before binary search we can create two arrays of gadgets which are selling for dollars and pounds and sort them Easy to see that we should buy gadgets for dollars on day i d when dollar costs as small as possible and j d when pounds costs as small as possible Let now we want to buy x gadgets for dollars and k x gadgets for pounds Of course we will buy the least cheap of them we already sort the arrays for that Let s iterate over x from 0 to k and maintain the sum of gadgets for dollars s1 and the sum of gadgets for pounds s2 For x 0 we can calculate the sums in O k For other x s we can recalculate the sums in O 1 time from the sums for x 1 by adding gadget for dollars and removing gadget for pounds Complexity O klogn ,There are many possible solutions to this problem The simplest one is to notice that using several flats of size and one flat of some size possibly also possibly not we can get any equal to or The only numbers that don t belong to these lists are and and it s easy to see that there is no answer for that numbers So the solution is to try all possible sizes of one flat and if the remaining number of windows is non negative and divisible by then take the required number of three room flats 
156,A sequence of round and square brackets is given You can change the sequence by performing the following operations change the direction of a bracket from opening to closing and vice versa without changing the form of the bracket i e you can change to and to you can change to and to The operation costs burles change any bracket to bracket having the same direction i e you can change to but from to similarly you can change to but from to The operation costs burle The operations can be performed in any order any number of times You are given a string of the length and queries of the type where For every substring find the minimum cost to pay to make it a correct bracket sequence It is guaranteed that the substring has an even length The queries must be processed independently i e the changes made in the string for the answer to a question don t affect the queries In other words for every query the substring is given from the initially given string A correct bracket sequence is a sequence that can be built according the following rules an empty sequence is a correct bracket sequence if is a correct bracket sequence the sequences and are correct bracket sequences if and are correct bracket sequences the sequence the concatenation of the sequences is a correct bracket sequence E g the sequences and are correct bracket sequences whereas and are not ,Consider a substring Let s call square brackets located in odd positions in the substring brackets and square brackets located in even positions brackets Let be the number of odd brackets be the number of even brackets be the number of all square brackets Let s prove that the string can be turned into a correct bracket sequence for burles if and only if Let s prove the necessary condition Suppose the initial substring has been turned into a correct bracket sequence Since we have paid burles there s no bracket which form has been changed Therefore for the new sequence is the same as for the initial sequence the similar situation happens with Let s say that two square brackets form a pair if the left one is an opening bracket and the right one is a closing bracket and the substring between them is a correct bracket sequence A pair can be formed only by one odd bracket and one even bracket because between them is placed an even number of brackets since it s a correct bracket sequence so the difference between their indices is odd In a correct bracket sequence each square bracket has a pairwise bracket Therefore a correct bracket sequence contains pairs of brackets so Let s prove the sufficient condition Suppose the initial substring contains equal numbers of odd and even brackets Let s prove by induction that the substring may be turned into a correct bracket sequence for burles Suppose So the initial substring contains only round brackets Let s make the first brackets opening and the other brackets closing The resulting sequence is a correct bracket sequence whereas we haven t changed the form of any bracket so the cost is equal to A correct bracket sequence has two important properties after deleting its substring being a correct bracket sequence the resulting string is a correct bracket sequence after inserting at any place any correct bracket sequence the resulting string is a correct bracket sequence These properties can be applied to an incorrect bracket sequence too after deleting a substring being a correct bracket subsequence from an incorrect bracket sequence or inserting a correct bracket sequence into an incorrect one the resulting sequence is an incorrect bracket sequence Consider a substring such that Suppose we have proved before that each substring having decreased by can be turned into a correct bracket sequence for burles Let s find two square brackets such that one of them is odd and another one is even and there are no square brackets between them There s an even number of round brackets between them that can be turned into a correct bracket sequence for burles Let s make the left found bracket opening and the right one closing Then the substring starting at the left found bracket and ending at the right found bracket is a correct bracket sequence Let s remove it from The resulting string contains odd brackets and even brackets so by the assumption of induction it can be turned into a correct bracket sequence for burles Let s do it and then insert the removed string into its place Since we insert a correct bracket sequence into a correct bracket sequence the resulting string is a correct bracket sequence Actually the operations of inserting and removing are not allowed they have been used for clarity the string can be turned into a correct bracket sequence without these operations as follows let s turn the substring we have removed into a correct bracket sequence as it was described above then change the other brackets of the string the same way as it was done with the string that was the result after removing The resulting string is a correct bracket sequence Therefore the illegal operations of inserting and removing are not necessary all other operations cost burles so the substring can be turned into a correct bracket sequence for burles Therefore to turn a substring into a correct bracket sequence we need to get a sequence such that Suppose initiallly Let s pay burles to replace odd brackets with round brackets If let s replace even brackets with round brackets Anyway we must pay burles We cannot pay less than this value because for a correct bracket sequence But there s no need to pay more than this value because if we turn the initial substring into a sequence with we can turn it into a correct bracket sequence for free Therfore the answer for a given question is Since we must answer the queries fast let s use a concept of prefix sums If the given string contains brackets let s create arrays and with the length will contain the number of odd brackets on the prefix of the string with the length the same value for even brackets Let s initialize and then iterate from to Let s initialize and If the th bracket is round then the current values are correct Otherwise let s find out what bracket is it If is odd the bracket is odd so we must increase by If is even the bracket is even so we must increase by To get the answer for a current and let s calculate and is a number of odd brackets that belong to the prefix with the length but not to the prefix with the length so Similarly The remaining thing is to output ,Note that means either or whereas means both and We can greedily solve this by starting out our string with all 1 s then marking and as 0 whenever we are forced to because Then we can simply check whether all of the conditions are valid to confirm Code 90915688 
157,You are given two binary square matrices and of size A matrix is called binary if each of its elements is equal to or You can do the following operations on the matrix number of times 0 or more vertical You choose the number and for all do the following is the operation exclusive or horizontal You choose the number and for all do the following Note that the elements of the matrix change after each operation For example if and the matrix is Then the following sequence of operations shows an example of transformations vertical horizontal vertical Check if there is a sequence of operations such that the matrix becomes equal to the matrix ,It is clear that the order of operations does not affect the final result also it makes no sense to apply the same operation more than once by the property of the operation Let s construct a sequence of operations that will reduce the matrix to the matrix if the answer exists Let s try iterate over will we use the operation horizontal Now by the each element of the first line we can understand whether it is necessary to apply the operation vertical if Let s apply all necessary operations vertical It remains clear whether it is necessary to apply the operation horizontal for Let s look at each element of the first column by it you can understand whether it is necessary to apply the operation horizontal if ,Let s rotate the grid by and and mark all cells that map to each other under these rotations For example for and grids mirror grid must have the following patterns the same letters denoting equal values In general we can rotate the grid by and and see which cells need to have equal values by seeing the positions which each cell maps to Now to solve the problem we consider each equal value each of the letters in the above figures independently and consider the minimum number of moves to make them all or all The answer is the total across all values See the implementation for better understanding The time complexity is per testcase 
158,You are given a string consisting of characters and or You have to remove several possibly zero characters from the beginning of the string and then several possibly zero characters from the end of the string The cost of the removal is the of the following two values the number of characters left in the string the number of characters removed from the string What is the cost of removal you can achieve ,There are many different approaches to this problem dynamic programming binary search greedy two pointers anything you want The model solution uses an approach based on binary search so I ll describe it First of all why does binary search work Let s say that the number of s is If the cost of deletion is then we have deleted at most characters and have left at most characters Let s increase the number of characters we delete from the prefix of the string until the number of deleted s becomes if it s always possible So if we consider the segment of values the fact that we can get cost implies that we can get cost so we can use binary search on segment to find the minimum achievable cost Now how to check if we can obtain the cost of deletion equal to One possible way to do this is to form an array where is the position of the th character in the string and find the minimum value of in this array the string that should remain has to contain at least characters and the minimum value of is the minimum possible length of such string Then we can find the number of s in this string and check if it is greater than or not ,Let s introduce the slightly naive solution Iterate over all values for periods and check the possibility of each one being correct The conditions for some period can be formulated the following way is the total length of the string is the number of full periods of length Let s find at least one such pair and such that and the remainder part of the string can be filled with letters A and letters B By easy construction one can deduce that the conditions of and are enough Thus should be greater or equal to and In order to move to the faster solution one should also remember that both remainder parts and should be non negative Let s learn how to solve the problem for the whole range of lengths which all have the number of full periods equal to the same value Let this range be From the aforementioned formulas one can notice that the restrictions on both and don t depend on the length itself but only on value of To be more specific The lowest and the highest values for and will be the following It is claimed that every value between and exists if the values are valid and The full proof about the given conditions being sufficient and the existence of every value on that range is left to the reader Some kind of a hint might be the suggestion to check how the inequalities change on the transition from some period to Restrict the values by and to count each answer on exactly one range of lengths Finally the value of is added to the answer The number of ranges with the same is Overall complexity 
159,There are boxers the weight of the th boxer is Each of them can change the weight by no more than before the competition the weight cannot become equal to zero that is it must remain positive Weight is always an integer number It is necessary to choose the largest boxing team in terms of the number of people that all the boxers weights in the team are different i e unique Write a program that for given current values will find the maximum possible number of boxers in a team It is possible that after some change the weight of some boxer is but no more ,Let be the last weight of the boxer taken into the team Initially Let s sort all boxers in order of non increasing their weights and iterate over all boxers in order from left to right If the current boxer has the weight then let s try to take him with weight we can do it if If we cannot do it let s try to take him with weight And in case of fault let s try to take him with weight If we cannot take him even with weight then let s skip him And if we take him let s replace with him weight The answer is the number of boxers we took ,Make a copy of the array s call it t Sort t in non decreasing order so that t 1 is the maximum strength and t 2 the second maximum strength Then for everyone but the best person they should compare with the best person who has strength t 1 So for all i such that s i neq t 1 we should output s i t 1 Otherwise output s i t 2 the second highest strength which is the next best person 
160,You are given an array consisting of positive integers Initially you have an integer During one move you can do one of the following two operations Choose from to and increase by then increase by Just increase by The first operation can be applied to each from to Your task is to find the minimum number of moves required to obtain such an array that each its element is the value is given You have to answer independent test cases ,Firstly we can understand that during each full cycle of from to we can fix each remainder only once Notice that when we add some then we fix the remainder and we don t need to fix elements which are already divisible by So let be the number of such elements for which the condition holds i e the number of such elements that we can fix if we add the value to them We can count this using some logarithmic data structure like in C So what s the number of full cycles It equals to the amount of most frequent element in minus one So the answer is at least And there can be one last cycle which will be incomplete So what is the remanining number of moves It equals to the maximum possible among all So if is the maximum such that then the answer is Time complexity ,Note that we do not need to consider the numbers we are only interested in the remainder of the division of by and we simply add the value to the answer We get an array where Let s sort it and greedily type index pairs such that This can be done with two pointers Then add the number of matching pairs to the answer counter This will be the answer to the problem 
161,You are given three integers and such that of these two equations is true Output if the first equation is true and otherwise ,You need to implement what is given in the statement for example you can use an if statement to output if and otherwise ,Every time we process a plan let s count only the first warriors of some type When will the warrior on position be counted Of course he has to be present in the plan so But also he has to be among first warriors of his type in this plan Let s denote a function is the position of previous warrior of the same type before warrior that is the greatest such that and If there s no any then if It is easy to prove that the warrior will be among first warriors in some plan iff and So we can make a new array Then we build a segment tree on this array The node of the segment tree will store all values of from the segment corresponding to this node in sorted order Then to get answer to the plan we have to count the number of elements on segment that are less than Complexity is or if you use fractional cascading technique 
162,There are students standing in a row Two coaches are forming two teams the first coach chooses the first team and the second coach chooses the second team The th student has integer programming skill All programming skills are and between and inclusive Firstly the first coach will choose the student with maximum programming skill among all students not taken into any team closest students to the left of him and closest students to the right of him if there are less than students to the left or to the right all of them will be chosen All students that are chosen leave the row and join the first team Secondly the second coach will make the same move but all students chosen by him join the second team Then again the first coach will make such move and so on This repeats until the row becomes empty i e the process ends when each student becomes to some team Your problem is to determine which students will be taken into the first team and which students will be taken into the second team ,Let s maintain two data structures a queue with positions of students in order of decreasing their programming skill and a set note that we need exactly set with positions of students not taken in any team To construct the first data structure we need to sort pairs in decreasing order of the first element and after that push second elements in order from left to right The second data structure can be constructed even easier we just need to insert all values from into it Also let s maintain an array where if the th student belongs to the first team and otherwise and the variable to determine whose turn is now initially it is While our set is not empty let s repeat the following algorithm firstly while the head the first element of the queue is not in the set pop it out This is how we determine which student will be taken now Let his position be And don t forget to pop him out too Create the additional dynamic array which will contain all students we will add to the team during this turn Let s find the iterator to the student with the position Then make the following sequence of moves times add the element the current iterator is pointing at to the array then if the current iterator is pointing at the first element break the cycle otherwise go to the iterator pointing at the previous element Then let s find the iterator to the student next to the student with position And then let s make almost the same sequence of moves times if the current iterator is pointing to the end of the set break the cycle otherwise add the element the current iterator is pointing at to the array and advance to the iterator pointing at the next element Then let s remove all values from the array from the set and for each student we delete let s set And change the variable to if it is now and to otherwise Time complexity ,Sort the weights now choosing and will split the array into three consecutive segments Consider a naive solution to the problem You can iterate over the length of the first segment and the second segment The third segment will include everyone remaining Now you have to check if there exist some and that produce such segment can be equal to the first element of the second segment since only all elements of the first segment are smaller than it Similarly can be equal to the first element of the third segment However if the last element of some segment is equal to the first element of the next segment no or can split the array like that Otherwise you can split an array like that So you can iterate over the lengths check the correctness and choose the best answer Now let s optimize it using the condition about powers of two First iterate over the size of the middle division which is a power of two Then over the length of the first segment which can be not a power of two Check if the first segment is valid So we fixed the length of the first segment and some value which is greater or equal than the length of the second segment That value isn t necessarily equal to the length of the second segment because the produced segment might be invalid So there is a greedy idea that the second segment should be as long as possible under the constraint that it doesn t exceed the fixed value The intuition is the following Consider the longest possible valid segment Now take the last element away from it We will have to invite one more participant to the middle division And that element will also get added to the third segment increasing its length So potentially you can only increase the required number of participants to invite This can be implemented in the following fashion For each position precalculate the closest possible segment border from the left Iterate over the size of the middle division as a power of two Iterate over the length of the first segment Find the closest border to the left of Get the lengths of the second and the third segments Find the closest powers of two to each length and update the answer Overall complexity per testcase 
163,Monocarp is playing yet another computer game In this game his character has to kill a dragon The battle with the dragon lasts seconds during which Monocarp attacks the dragon with a poisoned dagger The th attack is performed at the beginning of the th second from the battle start The dagger itself does not deal damage but it applies a poison effect on the dragon which deals damage during each of the next seconds starting with the same second when the dragon was stabbed by the dagger However if the dragon has already been poisoned then the dagger updates the poison effect i e cancels the current poison effect and applies a new one For example suppose and Monocarp stabs the dragon during the seconds and Then the poison effect is applied at the start of the nd second and deals damage during the nd and rd seconds then at the beginning of the th second the poison effect is reapplied so it deals exactly damage during the seconds and then during the th second the poison effect is applied again and it deals damage during the seconds and In total the dragon receives damage Monocarp knows that the dragon has hit points and if he deals at least damage to the dragon during the battle he slays the dragon Monocarp has not decided on the strength of the poison he will use during the battle so he wants to find the minimum possible value of the number of seconds the poison effect lasts that is enough to deal at least damage to the dragon ,Let s find out the total damage for a fixed value of Since the effect of the poison from the th attack deals damage seconds for and seconds for then the total damage is We can see that the higher the value of the greater the total sum So we can do a binary search on and find the minimum value when the sum is greater than or equal to ,The first spell looks pretty weak compared to the second spell Feels like you almost always replace one with another Let s show that you can totally avoid casting the spell of the first type twice or more on one monster Let the two first spell casts be and for some monsters and You can replace them by a cast of the second spell on and a cast of the first spell on That would deal even more damage to and the same amount to and The number of casts doesn t change Thus it only makes sense to use the first spell on monsters with health Calculate the number of them kill the full pairs of them with the first spell and use the second spell on the remaining monsters Overall complexity per testcase 
164,There is an infinite pond that can be represented with a number line There are rocks in the pond numbered from to The th rock is located at an integer coordinate The coordinates of the rocks are pairwise distinct The rocks are numbered in the increasing order of the coordinate so A robot frog sits on the rock number The frog is programmable It has a base jumping distance parameter There also is a setting for the jumping distance range If the jumping distance range is set to some integer then the frog can jump from some rock to any rock at a distance from to inclusive in any direction The distance between two rocks is an absolute difference between their coordinates You are assigned a task to implement a feature for the frog Given two integers and determine if the frog can reach a rock number from a rock number performing a sequence of jumps with the jumping distance range set to The sequence can be arbitrarily long or empty You will be given testcases for that feature the th testcase consists of two integers and Print if the th rock is reachable and otherwise You can output and in any case for example strings and will be recognized as a positive answer ,Notice that increasing only increases the range of the jump distances in both directions So every rock that was reachable with some will be reachable with as well Thus let s try to find the smallest possible value of to reach each rock Let s imagine this problem as a graph one and consider the following algorithm For every pair of rocks make an edge of weight equal to the smallest required to jump from one to another For some rocks and that is How to check the reachability with these edges Well if the jump range value is then there should exist of path by edges of weight no more than So we can start with an empty graph first add the edges of the smallest weight then the second smallest and so on The first time a pair of vertices becomes reachable from each other is the minimum such weight An experienced reader can notice the resemblance with the Kruskal algorithm for finding the minimum spanning tree After the spanning tree is constructed the minimum is the maximum value on a path between the vertices The issue is that Kruskal requires to construct an MST for a complete graph Prim can make it which is still too much Thus the solution is to resort to Boruvka On each iteration of Boruvka we have to find the smallest weight edge from each component to some other one We can solve it the following way Maintain a sorted set of rocks coordinates The smallest weight edges are the ones that are the closest to distance from each rock So we could query a lower bound of and on each rock to find them Don t forget to look at the both sides of the lower bound result However the issue is that we can bump into the rocks from the same component Thus let s process components one by one When processing a component first remove all its vertices from the set Then query the edges for each vertex Then add the vertices back This way only the edges to other components will be considered That makes it an construction with one log from the number of Boruvka iterations and another from finding the edges That should pass if coded carefully enough and that is basically the intended solution Still there exists a construction That will require a algorithm for finding the edges So there are four possible edges for each rock the closest to from the left from the right and the same for Let s consider only the first case the rest will be similar The coordinates are sorted beforehand and we are processing the rocks from left to right We can maintain a pointer to the latest encountered rock to the left of The issue with it being from the same component is still there Let s go around it by also storing the second latest encountered rock such that it s from the different component from the actual latest one This can be updated in the same manner one calculates the second maximum of the array Now you just have to do that for all four cases This two pointers approach makes it for each iteration thus making the construction Since the queries ask for a path from some fixed vertex to a certain vertex it s the same as calculating the maximum edge on a path from the root of the tree to each vertex Can be done with a simple dfs The only thing left is to check if the minimum possible is less than or equal to the one provided in the query Overall complexity or ,To get the answer for some we can build the following network connect the source to every vertex of the first part with edge with capacity where is the degree of vertex then transform every edge of the original graph into a directed edge with capacity and then connect each vertex from the second part to the sink with capacity Then edges saturated by the maxflow are not present in the answer and all other edges are in the answer To solve it fastly we might just iterate on from its greatest value to and each time augment the flow we found on previous iteration Since maxflow in the network is at most and we will do not more than searches that don t augment the flow this solution is 
165,An array consisting of integers is if For example the arrays are strictly increasing the arrays are not For a strictly increasing array of elements let s denote the as the number of different elements in the array For example the characteristic of the array is since the array contains different elements and You are given two integers and Construct an increasing array of integers from to with characteristic ,We can transform the problem as follows Let We need to find an array so that the sum of elements in it is not greater than all elements are positive integers and the number of different elements is the maximum possible Suppose we need different elements in What can be the minimum possible sum of elements in It s easy to see that should have the following form This array contains exactly different elements these different elements are as small as possible so their sum is as small as possible and all duplicates are s So if the sum of this array is not greater than then it is possible to have the number of different elements in equal to The rest is simple We can iterate on find the maximum possible construct the difference array and then use it to construct the array itself ,You can always show that the answer is equal to the amount of boxes of the size appearing the most in array Result can be easily obtained by constructive algorithm take these most appearing boxes put smaller boxes in decreasing order of their size into free ones there always be space and put resulting boxes into the larger ones in increasing order Overall complexity 
166,You are given an array of zeroes and ones only Note that in this problem unlike the others the array indexes are numbered from zero not from one In one step the array is replaced by another array of length according to the following rules First a new array is defined as a cyclic shift of the array to the right by cells The elements of this array can be defined as where is the remainder of integer division of by It means that the whole array can be represented as a sequence Then each element of the array is replaced by where is a logical AND operator For example if and then and the value of after the first step will be that is The process ends when the array stops changing For a given array determine whether it will consist of only zeros at the end of the process If yes also find the number of steps the process will take before it finishes ,We ll consider an arbitrary index of the array and see what changes happen to during several steps of the described algorithm Let s denote by the value of the array after steps of the algorithm and prove by induction that is the logical AND of elements of the array starting from with step to the left that is Base of induction for the element of the original array is For clarity we can also show that the statement is true for during the first step is replaced by by the definition of cyclic shift by to the right For simplicity we will omit the operation in the following formulas but will keep it in mind implicitly That is will imply Induction step let the above statement be true for let us prove it for By the definition of cyclic shift And by the induction assumption these two numbers are equal to Since the logical AND is an idempotent operation that is it does not change its result when repeatedly applied to any argument then that is equal to their logical AND is also equal to which is what we wanted to prove It follows from this formula that turns to zero after the th step if and only if and Up to the th step all elements will be equal to and so their logical AND will also be equal to As soon as appears in the sequence in question the logical AND will also become zero Thus we reduced the problem to finding the maximal block of elements equal to of the pattern Note that by shifts of the array splits into cyclic sequences of this kind each of length Let s look at these cyclic sequences independently from each other and iterate over each of them in linear time complexity to find the maximal block of consecutive elements equal to this will be the answer to the problem Remember to check that if at least one of these sequences consists entirely of elements equal to its elements will never zero out and the answer in such case is The time complexity is ,Let s carefully look at the coefficients with which the elements of the array will be included in the answer If pair of adjacent elements a i and a i 1 belong to different subarrays then element a i will be included in the answer with coefficient 1 and element a i 1 with coefficient 1 So they add value a i a i 1 to the answer If element belongs to subarray with length 1 then it will be included in the sum with coefficient 0 because it will be included with coefficient 1 and 1 simultaneously Elements at positions 1 and n will be included with coefficients 1 and 1 respectively So initially our answer is a n a 1 All we have to do is consider n 1 values a 1 a 2 a 2 a 3 dots a n 1 a n and add up the k 1 minimal ones to the answer 
167,You have a fence consisting of vertical boards The width of each board is The height of the th board is You think that the fence is if there is no pair of adjacent boards having the same height More formally the fence is great if and only if for all indices from to the condition holds Unfortunately it is possible that now your fence is not great But you can change it You can increase the length of the th board by but you have to pay rubles for it The length of each board can be increased any number of times possibly zero Calculate the minimum number of rubles you have to spend to make the fence great again You have to answer independent queries ,Let s notice that in optimal answer all boards will be increased by no more than two It is true because if it is beneficial to increase the length of some board by three or more denote its length as then increasing to the length or is cheaper and one of these boards is not equal to any of its adjacent boards Noticing this we can write a solution based on dynamic programming Let s is minimum amount of money for making fence great moreover the last board with index we increase by Then value can be calculated as follows ,Let s call a set of cells being filled from the topmost row to the leftmost column a E g the st layer consists of the single number the nd layer consists of the numbers and the rd layer consists of the numbers and etc The number of cells in layers forms an arithmetic progression The first layer consists of cells the th layer consists of cells The minimum number in the th layer is equal to the sum of sizes of all layers from the st to the th plus Suppose that belongs to the th layer Consider the value of Polycarp fills exactly cells on the th layer before he starts filling the cells from the right to the left i e while he goes down Therefore if the number belongs to the th row and the th column Otherwise the number belongs to the th row and the th column Consider a way to find the coordinates of a given number Let s iterate by the layer number to which given the number belongs calculating the values of and going to the next layer let s calculate the next layer parameters as follows The iteration must be stopped if the layer number is such that Using the values of and we can calculate the given number s coordinates in the described way in The total time of calculating the coodrinates for one given is where is the number of the layer to which the given belongs Let s represent the value of as hence Therefore the coordinates of one number may be calculated in At the same time as it follows from the formulas the layer number can be calculated as follows the square root of rounded up To avoid accuracy problems you can calculate the value using a loop 
168,Alice and Bob play a game There is a paper strip which is divided into cells numbered from left to right starting from There is a chip placed in the th cell the last one Players take turns Alice is first Each player during his or her turn has to move the chip or cells to the left so if the chip is currently in the cell the player can move it into cell or The chip should not leave the borders of the paper strip it is impossible for example to move it cells to the left if the current cell has number The player who can t make a move loses the game Who wins if both participants play optimally Alice and Bob would like to play several games so you should determine the winner in each game ,Let s determine for each cell whether it s winning or losing position we can do it since the game is symmetric and doesn t depend on a player The th cell is obviously losing the st and nd ones is both winning since we can move to the th cell and put our opponent in the losing position here comes criterion the position is winning if and only if there is a move to the losing position If is large enough then the th rd th th are losing So here comes divisibility by If then this move doesn t change anything since if then so it s not the move to the losing position so doesn t become the winning one Otherwise if then the th positions becomes winning but the th cell is losing all moves are to th th or st cells and all of them are winning The th and th cells are winning and so on In the end we came up with cycle of length where position divisible by except are losing All we need to do is small case work ,The most tricky part of the problem is how to check if some set of cards allows us to build a deck with the required power not taking the levels of cards into account Suppose we have not more than one card with magic number if there are multiple cards with this magic number then we obviously can use only one of these Then two cards may conflict only if one of them has an odd magic number and another has an even magic number otherwise their sum is even and not less than so it s not a prime number This allows us to solve this problem as follows Construct a bipartite graph each vertex represents a card and two vertices are connected by an edge if the corresponding pair of cards can t be put in a deck Then we have to find the maximum weight of independent set in this graph This can be solved using maximum flow algorithm construct a network where source is connected with every odd vertex a vertex that represents a card with an odd magic number by an edge with capacity equal to the power of this card then connect every odd vertex to all even vertices that are conflicting with this vertex by edges with infinite capacities and then connect every even vertex to the sink by an edge with capacity equal to the power of the card all edges have to be directed Then the maximum power of the deck is equal to where is the sum of all powers and is the minimum cut value between the source and the sink which is equal to the maximum flow This allows us to check if we can build a deck of required power using only some set of cards for example only cards with level less than or equal to some 
169,You are given a rooted tree consisting of vertices The vertices are numbered from to the root is the vertex You can perform the following operation times choose an edge of the tree such that is a parent of remove the edge add an edge i e make with its subtree a child of the root of a tree is the maximum depth of its vertices and the depth of a vertex is the number of edges on the path from the root to it For example the depth of vertex is since it s the root and the depth of all its children is What s the smallest height of the tree that can be achieved ,Start with the following Let s look at the input format and consider what the operation actually does to it Since it only changes the parent of some vertex it modifies only one value in it Moreover it just assigns it to Thus the goal is to assign at most values of parents to to minimize the resulting height of the tree In particular that implies that we can freely rearrange the operations since the assignments don t depend on each other One more conclusion Imagine we have already built some answer One by one we moved some subtrees to be children of the root It could happen that we first moved some subtree of a vertex and then applied the operation to an edge inside the subtree of Let s show that it s always possible to rearrange the operations in the answer to avoid that Just apply the operations in order of decreasing the depth of the vertex If we knew what height we want to get we could have been making sure that cut subtree has height at most since it gets increased by when glueing it to the root then pretending that that subtree doesn t exist anymore Moreover it s always required to cut subtrees with height at most If you cut a higher subtree then the answer can t be smaller than since we rearranged the operation to not touch that subtree anymore Well let s fix that height if we wanted that Let s try the solve the opposite problem How many operations will it require to make the tree height at most Obviously the values for this problem are non increasing the greater we allow the height to be the less operations it will require Thus we will be able to apply binary search to it to find the smallest height we can achieve with at most operations Now we want to be choosing the subtrees of height at most repeatedly and cutting them off until the height of the tree becomes at most Let s think greedily If the height of the tree is not at most yet then there exists a vertex with the depth greater than Let s look at the deepest of them That leaf has to be cut in some subtree Otherwise the tree won t become any less higher What subtree is the best for it What options do we have That vertex itself and all its parents up until above It s always optimal to cut the highest of them the st parent since it will remove at least all the vertices of any other cut and some other vertices along with them It s also always possible to remove the st parent since it will always have height exactly The vertex we are looking at is the deepest in the entire tree there are no deeper vertices in the subtree of the st parent Thus the strategy is to keep cutting the st parent of the deepest vertex until the tree becomes at most height Now about the implementation details First we can process the vertices from the deepest upwards in their order in the original tree The operation only removes some vertices but doesn t change the depth of the remaining ones For example you can do a bfs from the root to find the order Now the st parent Let s find it for each vertex before starting the process Run a dfs and maintain the stack of the ascendants When going down the child append it to the stack What exiting pop from the stack Now you can just look at the st element from the top of the stack To be able to do that simulate the stack with a vector C or a list Python Finally we would have to determine if the current vertex in the order is removed or not For that we could maintain a boolean array for the removed vertices Once you apply the operation run the dfs from the removed vertex and mark all the newly removed descendants of it in If you don t go into already marked vertices there will be no more than calls of the dfs The number of cut vertices is the answer for the fixed height Overall complexity per testcase ,This problem has an easy constructive solution We can find lower and upper bounds on the value of for the given If the given does not belong to this segment then the answer is Otherwise the answer is for any in this segment How to construct it Let s start from the chain The answer for the chain is the upper bound of and it is Then let s try to decrease the answer by in one move Let s take some leaf the vertex without children with the smallest depth that is not and try to move it up The definition of badness will be below To do this let s find such vertex that its depth is less than the depth of by and it has less than children If we found such vertex then let s make the child of and decrease the answer by one If we didn t find such vertex I claim that the vertex has the minimum possible depth it can have and we should not consider it in the future Let s mark this vertex as and continue our algorithm If at some moment we cannot find any not leaf then the answer is Otherwise the answer is Time complexity 
170,The Red Kingdom is attacked by the White King and the Black King The Kingdom is guarded by castles the th castle is defended by soldiers To conquer the Red Kingdom the Kings have to eliminate all the defenders Each day the White King launches an attack on one of the castles Then at night the forces of the Black King attack a castle possibly the same one Then the White King attacks a castle then the Black King and so on The first attack is performed by the White King Each attack must target a castle with alive defender in it There are three types of attacks a decreases the number of defenders in the targeted castle by or sets it to if there are already less than defenders an decreases the number of defenders in the targeted castle by or sets it to if there are already less than defenders a decreases the number of defenders in the targeted castle by or sets it to if there are already less than defenders The can be launched at any valid target at any castle with at least one soldier However the cannot be launched if the had the same type no matter when and by whom it was launched The same applies to the A castle that was not attacked at all can be targeted by any type of attack The King who launches the last attack will be glorified as the conqueror of the Red Kingdom so both Kings want to launch the last attack and they are wise enough to find a strategy that allows them to do it no matter what are the actions of their opponent if such strategy exists The White King is leading his first attack and you are responsible for planning it Can you calculate the number of possible options for the first attack that allow the White King to launch the last attack Each option for the first attack is represented by the targeted castle and the type of attack and two options are different if the targeted castles or the types of attack are different ,This problem seems like a version of Nim with some forbidden moves so let s try to apply Sprague Grundy theory to it First of all we may treat each castle as a separate game compute its Grundy value and then XOR them to determine who is the winner of the game When analyzing the state of a castle we have to know two things the number of remaining soldiers in it and the type of the last attack performed on it So the state of the game can be treated as a pair We can compute Grundy values for each state in a straightforward way but the constraints are too large to do it Instead we should try to search for a period five consecutive rows by row we mean a vector of Grundy values for the same number of remaining soldiers but different types of last attacks of Grundy values determine all of the values after them so as soon as we get the same five rows of Grundy values that we already met we can determine the period There are values stored in these five rows so the period can be up to but that s a really generous upper bound Some intuition can help us to prove something like or as an upper bound but it is better to check all cases with brute force and find out that the period is at most After we ve found the period of Grundy values it s easy to get them in for any castle To count the number of winning moves for the first player we can compute the XOR sum of all castles and for each castle check what happens if we make some type of attack on it if the XOR sum becomes then this move is winning ,The maximum number of rounds Alice can win is pretty easy to calculate greedily What about the minimum number of rounds It can be shown that if we started using some combination we are better to end it before using the other one There are six possible combinations to not win the round and and and and and and We can iterate over all permutations of these combinations there are possible permutations and greedily apply them Use the first while it is possible then the second and so on and find the best answer It is also possible that the order of these combinations does not matter but we didn t prove that fact Time complexity 
171, students attended the first meeting of the Berland SU programming course is even All students will be divided into two groups Each group will be attending exactly one lesson each week during one of the five working days Monday Tuesday Wednesday Thursday and Friday and the days chosen for the groups must be different Furthermore both groups should contain the same number of students Each student has filled a survey in which they told which days of the week are convenient for them to attend a lesson and which are not Your task is to determine if it is possible to choose two different week days to schedule the lessons for the group the first group will attend the lesson on the first chosen day the second group will attend the lesson on the second chosen day and divide the students into two groups so the groups have equal sizes and for each student the chosen lesson day for their group is convenient ,Since there are only five days we can iterate over the two of them that will be the answer Now we have fixed a pair of days and and want to check if it can be the answer All students can be divided into four groups marked neither of days and marked only day marked only day and marked both days Obviously if the first group is non empty days and can t be the answer Let s call the number of students who only marked day and the number of students who only marked day If either of or exceed then days and can t be the answer as well Otherwise we can always choose students from the ones who marked both days and send them to day The rest of the students can go to day ,Imagine there were no constraints of the second or the third types Then it would be possible to solve the problem with some greedy algorithm Unfortunately when both these constraints are present it s not immediately clear how to adapt the greedy Dynamic programming is probably also out of question because you can t maintain all possible cuts between equal values on each prefix Thus let s try to make a graph problem out of this Who knows maybe a flow or something else could work Create nodes for each position Let the th of them on the th position represent the condition of kind is equal to Then all constraints can be described as edges on this graph Binary variables restrictive edges Surely this is 2 SAT Connect the pairs of values that satisfy each constraint Add the edges between the adjacent positions to enforce the restriction on the non decreasing order Prohibit each position to be assigned to multiple values Force each position to be assigned at least one value Huh it s not that easy That s where the 2 SAT idea fails We want the conditions of form But that is not allowed since 2 SAT has to have two variables in a clause That s where the main idea of the problem comes up Instead of making our nodes represent let s make them and try building the graph again If then all nodes for will be true and the rest will be false So if is false then is false That will enforce the validity of the nodes themselves First the order If is true then is true The first type of constraints is basically the same as or For our conditions it s rather not or The second type of constraints Let be greater than or equal to some Then for this constraint to hold should be no greater than Thus if is true then should be false Same for and swapped The third type of constraints is similar Let be less than or equal to some Then for this constraint to hold should be greater than or equal to Thus if is false then should be true Same for and swapped And that s it Solve the 2 SAT and restore the answer I can advise making not but actually nodes for and force the values to be between and That will simplify the checks while adding the constraints Overall complexity 
172,Vova decided to clean his room The room can be represented as the coordinate axis There are piles of trash in the room coordinate of the th pile is the integer All piles have coordinates Let s define a as the following process The goal of this process is to collect the piles in different coordinates To achieve this goal Vova can do several possibly zero moves During one move he can choose some and move from to or using his broom Note that he can t choose how many piles he will move Also there are two types of queries remove a pile of trash from the coordinate It is guaranteed that there is a pile in the coordinate at this moment add a pile of trash to the coordinate It is guaranteed that there is no pile in the coordinate at this moment Note that it is possible that there are zero piles of trash in the room at some moment Vova wants to know the number of moves he can spend if he wants to do a before any queries He also wants to know this number of moves after applying each query Queries are applied in the given order Note that the doesn t actually happen and doesn t change the state of piles It is only used to calculate the number of moves For better understanding please read the section below to see an explanation for the first example ,First let s understand that if we choose some subset of points then it does not matter to which point we move it inside the segment because the minimum number of moves will always be the same and it is equal to Okay we need to split all points into two subsets and collect all points of the first subset in some point inside it and the same with the second subset What can we notice If we sort the points it s always optimal to choose these subsets as segments I e if the maximum point of the first subset is the minimum point of the second subset is and we can swap them and decrease answers for both subsets So we need to cover all the points with two segments with the minimum total length What is this length It is is the maximum distance between two consecutive points i e So we can solve the problem in without queries But how to deal with queries Let s maintain the set which contains all points and the multiset set with repetitions that maintains all gaps between two adjacent points So the answer is maximum in the set of points minus minimum in the set of points minus maximum in the multiset of lengths How do we recalculate these sets between queries If some point is removed let s find the maximum point less than let it be and the minimum point greater than let it be in the current set of points Both these points can be found in a logarithmic time Then we need to remove with from the multiset and add to the multiset and of course remove from the set If some point is added then we need to remove from the multiset and add with to the multiset and add to the set So we can process every query in time and the total time complexity is ,I wanted to give this problem a lot of time ago I thought it is very standard problem but I underestimated its difficulty Let s write down the equation describing the problem So we have linear Diofant equation with two variables The solution has the form where the last equation can be solved by extended Euclid algorithm and is any integral number The variable should satisfy two conditions and The values and are fixed so we can get the segment of possible values for the values The length of the segment is the answer for the problem 
173,You are given a bipartite graph the first part of this graph contains vertices the second part contains vertices and there are edges Initially each edge is colorless For each edge you may either leave it uncolored it is free paint it red it costs coins or paint it blue it costs coins No edge can be painted red and blue simultaneously There are three types of vertices in this graph colorless red and blue Colored vertices impose additional constraints on edges colours for each red vertex the number of red edges indicent to it should be than the number of blue edges incident to it for each blue vertex the number of blue edges indicent to it should be than the number of red edges incident to it Colorless vertices impose no additional constraints Your goal is to paint some possibly none edges so that all constraints are met and among all ways to do so you should choose the one with minimum total cost ,A lot of things in this problem may tell us that we should try thinking about a flow solution Okay let s try to model the problem as a flow network First of all our network will consist of vertices and edges of the original graph We somehow have to denote red blue and colorless edges we will do it as follows each edge of the original graph corresponds to a bidirectional edge with capacity in the network if the flow goes from the left part to the right part along the edge it is red if the flow goes from right to left it is a blue edge and if there is no flow along the edge it is colorless Okay we need to impose some constraints on the vertices Consider some vertex from the left part Each red edge incident to it transfers one unit of flow from it to some other vertex and each blue edge incident to it does the opposite So the difference between the number of blue and red edges incident to is the amount of excess flow that has to be transfered somewhere else If is colorless there are no constraints on the colors of edges so this amount of excess flow does not matter to model it we can add a directed edge from source to with infinite capacity and a directed edge from to sink with infinite capacity What if is red At least one unit of flow should be transfered to it so we add a directed edge from the source to with infinite capacity And if is blue we need to transfer at least one unit of excess flow from it so we add a directed edge from to the sink with infinite capacity such that there is at least one unit of flow along it The colors of the vertices in the right part can be modeled symmetrically How to deal with edges such that there should be some flow along them You may use classic flows with demands approach from here https cp algorithms com graph flow with demands html Or you can model it with the help of the costs if the flow along the edge should be between and we can add two edges one with capacity and cost where is a negative number with sufficiently large absolute value for example and another with capacity and cost Okay now we know how to find at least one painting How about finding the cheapest painting that meets all the constraints One of the simplest ways to do it is to impose costs on the edges of the original graph we can treat each edge of the original graph as a pair of directed edges one going from left to right with capacity and cost and another going from right to left with capacity and cost ,We prove that the answer always always exists by constructing it Graph for is a single vertex Graph for is a clique of vertices Graph for some is obtained from the graph by adding vertices initially connected to nothing and vertices connected to all previously mentioned ones The vertices connected to nothing got degrees the vertices from the previous step increased their degrees by and finally there appeared vertices of degree The number is vertices is as needed 
174,Petya sometimes has to water his field To water the field Petya needs a tank with exactly ml of water Petya has got tanks th of them initially containing ml of water The tanks are really large any of them can contain any amount of water no matter how large this amount is Also Petya has got a scoop that can contain up to ml of water initially the scoop is empty This scoop can be used to get some water from some tank and after that pour it all into some tank it is impossible to get water from multiple tanks without pouring it or leave some water in the scoop when pouring it When Petya tries to get some water from a tank he gets water where is the current volume of water in the tank Is it possible to obtain a tank with exactly ml of water using these operations If it is possible print a sequence of operations that allows to do it If there are multiple ways to obtain needed amount of water in some tank print any of them ,Eliminate the obvious corner case when we don t have enough water Now we don t consider it in editorial Let s fix some set of tanks and let be the total amount of water in the set If and have the same remainders modulo then we can transfer all water from to one tank transfer all water from to another tank and then using some number of operations transfer required amount of water from to or from to So we have a solution when we have some set of tanks such that What if we don t have such set In this case it is impossible to solve the problem since we cannot obtain a tank with water such that and obviously we cannot obtain a tank with exactly water To find this set we may use some sort of knapsack dynamic programming ,We can solve the problem with a two pointers technique Let be the left pointer initially at and be the right pointer initially at Let s store Alice and Bob s current totals as and Let s iterate from the left to the right For each we should do the following Increase by Alice eats the th candy Move leftwards until Bob s total is at least Alice s total and update every time we move If the two pointers have crossed then both Alice and Bob took the same candy which is not possible So we should exit and output the current answer Otherwise if after this step we should update the current answer to be the value that is equal to Alice and Bob Both and move at most times in total so the solution runs in 
175,You are given a picture consisting of rows and columns Rows are numbered from to from the top to the bottom columns are numbered from to from the left to the right Each cell is painted either black or white You think that this picture is not interesting enough You consider a picture to be interesting if there is at least one in it A cross is represented by a pair of numbers and where and such that in row and in column are painted black For examples each of these pictures contain crosses The fourth picture contains 4 crosses at and Following images don t contain crosses You have a brush and a can of black paint so you can make this picture interesting Each minute you may choose a white cell and paint it black What is the minimum number of minutes you have to spend so the resulting picture contains at least one cross You are also asked to answer multiple independent queries ,Let s consider each cell as a center of a cross and take the fastest one to paint Calculating each time naively will take overall which is too slow Notice how the answer for some cell can be represented as if is white else where is the number of white cells in row and is the same for column The first two terms can be precalculated beforehand Overall complexity per query ,Suppose and are even A necessary and sufficient condition of existence of the answer is that is even Let s prove the sufficient condition If the count of the horizontal dominoes is even then we can combine them and vertical dominoes to blocks of size the number of the vertical dominoes is even too if is even If and are even we can fill the table with these blocks The description of the locations of the dominoes may be printed as follows consider the table is a chessboard where a cell is a block of two dominoes Consider the leftmost topmost cell of the board is black If a cell of the board is black let s mark one of the dominoes of the block with the letter and the other one with the letter If a cell of the board is white let s mark one of the dominoes of the block with the letter and the other one with the letter There will be no situation that some two cells of the table are marked with one letter but belong to different dominoes Let s prove the necessary condition The number of cells in a column is even so the number of cells that belong to vertical dominoes is even because cells of each vertical domino may be either belong to the column or not belong at the same time So the number of cells that belong to horizontal dominoes is even Let s cross out all cells that belong to vertical dominoes and let s find the leftmost column having cells that haven t been crossed out It s the leftmost column with such cells so the pairwise cells of the non crossed out cells belong to the column to the right of the found one The number of such cells in the right column is equal to the number of found cells so it s even and the number of found horizontal dominoes is even too Let s cross out the found cells and the pairwise cells The number of non crossed out cells in the right column will be even The number of crossed out horizontal dominoes will be even too Let s repeat this procedure until all the dominoes will be crossed out In every step we have crossed out the even number of horizontal dominoes hence the total count of horizontal dominoes is even Suppose is odd hence is even In this case every column contains an odd number of cells whereas the number of cells that belong to vertical dominoes is even So the number of cells that belong to horizontal dominoes is odd Consider the leftmost column and find a cell of it that belongs to a horizontal domino it must be found because the number of such cells is odd so it isn t equal to Let s find the pairwise cell and cross out both cells Currently the two columns will have an even number of non crossed out cells Let s repeat the procedure until all columns will have even non crossed out cells We will cross out cells and dominoes So the necessary condition is that the number of horizontal dominoes is at least Let s extend the necessary condition with the following condition the value of is even Consider the table that we ve become after the previous procedure where each column has exactly one crossed out cell Let s start the procedure we ve done in the case of even both and The procedure can be started on our table because each column of the table has an even number of non crossed out cells As a result of the procedure we will cross out an even count of horizontal dominoes so the value of is even Let s build an answer if the conditions and is even are met Let s place in the topmost row horizontal dominoes and mark their cells as follows the first domino will be marked with the second one with the third one with and so on As the result the region of rows and columns will be unfilled Both values are even and the value of is even too So let s fill the region as if it s a separate table having even numbers of rows and columns As it was proved above it s possible to do The set of letters used for the region and set of the letters used for the topmost row don t have common elements so there will be no cells that are marked with one letter but belong to different dominoes The case of odd hence is even is similar to the previous one let s transpose the table it will have rows and columns swap the values of and solve the case above and transpose the table back to have rows and columns 
176,You are given points on a plane All the points are distinct and no three of them lie on the same line Find the number of parallelograms with the vertices at the given points ,It s known that the diagonals of a parallelogram split each other in the middle Let s iterate over the pairs of points and consider the middle of the segment Let s calculate the value for each middle is the number of segments with the middle Easy to see that the answer is ,Firstly we obviously don t need coordinates at all because we can place both platforms at Let s sort all coordinates in non decreasing order Calculate for each point two values and where is the number of points to the left from the point including that are not further than from the th point i e the number of such points that And is the number of points to the right from the point including that are not further than from the th point Both these parts can be done in using two pointers Then let s build suffix maximum array on and prefix maximum array on For just iterate over all from to and do For just iterate over all from to and do The question is what What did we do We did the following thing the answer always can be represented as two non intersecting segments of length such that at least one endpoint of each segment is some input point Now let s fix this border between segments Iterate over all from to and update the answer with So we took segment that starts at some point to the left from including and goes to the left and took some segment that starts further than including and goes to the right With this model we considered all optimal answers that can exist Time complexity 
177,There are chests The th chest contains coins You need to open all chests There are two types of keys you can use to open a chest a good key which costs coins to use a bad key which does not cost any coins but will halve all the coins in each unopened chest The halving operation to the nearest integer for each chest halved In other words using a bad key to open chest will do any key both good and bad breaks after a usage that is it is a one time use You need to use in total keys one for each chest Initially you have no coins and no keys If you want to use a good key then you need to buy it During the process you are allowed to go into debt for example if you have coin you are allowed to buy a good key worth coins and your balance will become coins Find the maximum number of coins you can have after opening all chests in order from chest to chest ,We will prove it is always optimal to use good keys for a prefix then only use bad keys Consider we have used a bad key then a good key by doing this we obtain coins If we switch and use a good key first the a bad key then we obtain this number is clearly bigger so we will never encounter a bad key before a good key in an optimal solution thus we will use a prefix of good keys then move on to using bad keys For every possible prefix of good keys we will calculate the coins we get at the end We do this by maintaining a variable with the prefix sum where we use the good keys and then calculate what we will get from the chests where we use bad keys Notice that because we halve all the chests when we use a bad key we only need to verify the next chests all chests after it will go to coins Final complexity ,First of all to maximize the number of candies in the gift we can use the following greedy algorithm let s iterate on the number of candies of some type we take from to backwards For fixed let s try to find any suitable type of candies A type is suitable if there are at least candies of this type in the box If there exists at least one such type that wasn t used previously let s pick any such type and take exactly candies of this type and decrease It does not matter which type we pick if we only want to maximize the number of candies we take Okay let s now modify this solution to maximize the number of candies having We initially could pick any type that has at least candies but now we should choose a type depending on the number of candies with in this type For example if we have two types having and candies with respectively and we want to pick candies from one type and candies from another type and and it s better to pick candies of the first type and candies of the second type In this case we have candies with in the other case it s And if and then So when we want to pick a type of candies such that we will take exactly candies of this type it s optimal to choose a type that wasn t used yet contains at least candies and has maximum possible number of candies with This best type can be maintained with a multiset or a set of pairs 
178,You are given a string consisting of lowercase Latin letters Some indices in this string are marked as You want to find a string such that the value of is maximum possible where is the number of occurences of in such that these occurences end in non forbidden indices So for example if is is and index is forbidden then because there are three occurences of in starting in indices and but one of them starting in index ends in a forbidden index Calculate the maximum possible value of you can get ,This problem can be solved with different suffix structures Model solution uses suffix array First of all let s reverse so for we will count only occurences that start in non forbidden indices Then if there is at least one non forbidden index there are two cases then the best option to choose is to use a suffix which begins in the leftmost after reversing non forbidden index then is the longest common prefix of some two suffixes of Let s build a suffix array then calculate the LCP array Then recall the fact that a LCP of two suffixes is the minimum on the segment of LCP array between these two suffixes so we can use a common stack algorithm that will for each LCP find the segment of suffixes such that this LCP is a prefix of these suffixes to do this for each element of LCP array we find the largest segment such that this element is minimal on that segment and then we can use prefix sums to find the number of non forbidden suffixes such that chosen LCP is a prefix of this suffix and so calculate easily for each LCP ,Note that no matter which action is chosen after this action is performed one letter is erased from the string two letters in total are erased from the string Let s denote the length of the string by If is odd then described turns can not erase all the characters from the strings because if he is deleting two letters on each turn the length will always remain odd For example if the original length of the string is then after one turn it will be equal to and after two moves it will be equal to in which case the next turn is impossible Thus if the length of the row is odd the answer is If is even it will take exactly steps to erase all characters from the string Since each action removes exactly one letter from the string the string can become empty only if there are exactly letters Let us show that this condition is sufficient that is if a string has exactly half of the letters equal to then there always exists a sequence of actions leading to an empty string Indeed if a string of length has exactly letters exactly letters and exactly letters then Then Casimir can make moves of the first type each time removing the first occurrence of and the first occurrence of and moves of the second type each time removing the first occurrence of and the first occurrence of After such moves the string will become empty Thus checking that the number of letters in the string is exactly half of its length was enough to solve the problem 
179,Polycarp wants to train before another programming competition During the first day of his training he should solve exactly problem during the second day exactly problems during the third day exactly problems and so on During the th day he should solve problems Polycarp has a list of contests the th contest consists of problems During each day Polycarp has to choose of the contests he didn t solve yet and solve it He solves Other problems are discarded from it If there are no contests consisting of at least problems that Polycarp didn t solve yet during the th day then Polycarp stops his training How many days Polycarp can train if he chooses the contests optimally ,After sorting the array we can maintain the last day Polycarp can train in the variable Initially it is Let s iterate over all elements of the sorted array in non decreasing order and if the current element then let s increase by one The answer will be ,You only need to write an if statement and check if any of these are true 
180,There are boxes with colored balls on the table Colors are numbered from to th box contains balls all of which have color You have to write a program that will divide all balls into sets such that each ball belongs to exactly one of the sets there are no empty sets there is no set containing two or more balls of different colors each set contains only balls of one color there are no two sets such that the difference between their sizes is greater than Print the minimum possible number of sets ,If we want to divide all balls from some box into sets with sizes and and there are balls in this box then either or So the solution will be like that Iterate over the possible sizes of sets from to or to some constant in our solution it s and check if we can divide all balls into sets with sizes and Then iterate over the number of sets calculate the sizes of sets if we want to divide the first box exactly into sets and try to divide balls from all other boxes into sets of these sizes If we want to divide balls from the same box into sets then the sizes will be and but if then we also have to check if sizes can be and If we fix sizes and and we want to check whether we can divide a box with balls into sets with these sizes and to get the minimum possible number of such sets then the best option will be to take sets If then such division is possible If not then it s impossible to divide balls into sets of and balls Time complexity of this solution is ,Let s look at some facts At first the answer is the sum of weights taken with some coefficients So it s enough to calculate those coefficients Then can be calculated by iterating on the size of the subset containing th element where is the number of partitions of set with elements into nonempty subsets with one subset of fixed size where belongs This solution is still quite slow so the next fact is if two elements and belong to the same subset then increases the coefficient before So for each element we can iterate over all elements which will lie in one subset with In other words is the number of ways to divide set with elements into subsets in such a way that elements and wil lie in one subset can be calculated using Stirling numbers of the second kind let be the number of partitions of set with elements into non empty subsets If then else we just merge and into one element and let Final formula is And the answer is Counting Stirling numbers can be done with inclusion exclusion principle or by searching Wiki Resulting complexity is 
181,A number is if it contains only digits and For example the following numbers are ternary You are given a long ternary number The first leftmost digit of is guaranteed to be the other digits of can be or Let s define the ternary XOR operation of two ternary numbers and both of length as a number of length where where is modulo operation In other words add the corresponding digits and take the remainders of the sums when divided by For example Your task is to find such ternary numbers and both of length and both without leading zeros that and is the minimum possible You have to answer independent test cases ,Let s iterate from left to right over the digits of If the current digit is either or then we can set or correspondingly There are no better choices And if the current digit is then the optimal choise is to set and What happens after the first occurrence of Because of this choice is greater than even if all remaining digits in are So for each set and and print the answer The case without is even easier and in fact we handle it automatically ,If all digits from to are initially present in the number then the answer is Each time we will increase the number by If the last digit is less than then only it will change Otherwise all digits equal to at the end will become equal to and the previous one will increase by or a new digit equal to will be added if all digits were equal to For a operation the last digit will run through all possible values However we can get all the numbers earlier We will solve the problem using binary search sorting through the number of operations We can have 2 options whether was at the end or not Depending on this one or two subsegments of the segment a subsegment in the middle or a prefix and a suffix remained uncovered by the last digit of the number They need to be completely covered with numbers that were already in positions except for the last one these are the original numbers and in case there was at the end the number into which the transfer was made There are at most of them 
182,The main city magazine offers its readers an opportunity to publish their ads The format of the ad should be like this There are space separated non empty words of lowercase and uppercase Latin letters There are hyphen characters in some words their positions set word wrapping points Word can include more than one hyphen It is guaranteed that there are no adjacent spaces and no adjacent hyphens No hyphen is adjacent to space There are no spaces and no hyphens before the first word and after the last word When the word is wrapped the part of the word before hyphen and the hyphen itself stay on current line and the next part of the word is put on the next line You can also put line break between two words in that case the space stays on current line Check notes for better understanding The ad can occupy no more that lines and should have minimal width The width of the ad is the maximal length of string letters spaces and hyphens are counted in it You should write a program that will find minimal width of the ad ,Firstly notice that there is no difference between space and hyphen you can replace them with the same character if you want Let s run binary search on answer Fix width and greedily construct ad wrap word only if you don t option to continue on the same line Then check if number of lines doesn t exceed Overall complexity ,Notice that the order of letters doesn t matter at all depends only on amount of each letter Let be the possibility that string will occur in at least times after replacing all signs and after some swaps If is true then is also true That leads to binary search over the answer Let be the amount of letters in and the amount of letters in is the number of signs is true if If some letter appears in less times than needed then replace some signs with it Answer can be restored greedily by replacing signs with the letters needed Overall complexity where is the size of the alphabet 
183,Polycarp is reading a book consisting of pages numbered from to Every time he finishes the page with the number divisible by he writes down the last digit of this page number For example if and pages divisible by are Their last digits are correspondingly their sum is Your task is to calculate the sum of all digits Polycarp has written down You have to answer independent queries ,Let be the number of integers from to divisible by We can notice that because we write down only the last digit of each number divisible by then the length of the cycle of digits does not exceed In fact we can always suppose that it is because for all from to So let for all from to Then the answer is ,If is divisible by just print Otherwise we need exactly moves to make zero remainder of modulo is modulo operation 
184,You are organizing a boxing tournament where boxers will participate is a power of and your friend is one of them All boxers have different strength from to and boxer wins in the match against boxer if and only if is stronger than The tournament will be organized as follows boxers will be divided into pairs the loser in each pair leaves the tournament and winners advance to the next stage where they are divided into pairs again and the winners in all pairs advance to the next stage and so on until only one boxer remains who is declared the winner Your friend really wants to win the tournament but he may be not the strongest boxer To help your friend win the tournament you may bribe his opponents if your friend is fighting with a boxer you have bribed your friend wins even if his strength is lower Furthermore during each stage you distribute the boxers into pairs as you wish The boxer with strength can be bribed if you pay him dollars What is the minimum number of dollars you have to spend to make your friend win the tournament provided that you arrange the boxers into pairs during each stage as you wish ,If our friend is the strongest boxer he wins without any bribing Otherwise we have to bribe the strongest boxer and he can defeat some other boxers directly or indirectly Suppose we chose the boxers he will defeat then there is another strongest boxer If our friend is the strongest now we don t need to bribe anyone otherwise we will bribe the strongest remaining boxer again and he can defeat other boxers and so on The only thing that s unclear is which boxers should be defeated by the ones we bribe We may use dynamic programming to bribe them is the minimum cost to bribe boxers so that all boxers among strongest ones are either bribed or defeated by some bribed boxer For each value of we know the maximum amount of boxers that are defeated by bribed boxers so the transitions in this dynamic programming are the following if we can t defeat the next boxer for free our bribed boxers have already defeated as many opponents as they could we have to bribe him otherwise we either bribe him or consider him defeated by some other boxer Overall complexity is ,Note that it makes no sense to use the first type of operation if it does not lead to an instant win because the opponent can return the previous state of the array with their next move So the winner is the one who has time to color their elements in blue first Let s denote as the number of elements that only the first player needs to color as the number of elements only the second player needs to color both players needs to color To win the first player needs to have time to paint elements and they have no more than moves to do it because otherwise the second player can prevent the win of the first player So the winning condition for the first player is Similarly for the second player with the only difference that they have move less because they go second which means the condition is If none of these conditions are met then neither player has a winning strategy which means they will both reduce the game to a draw 
185,Vova s family is building the Great Vova Wall named by Vova himself Vova s parents grandparents grand grandparents contributed to it Now it s totally up to Vova to put the finishing touches The current state of the wall can be respresented by a sequence of integers with being the height of the th part of the wall Vova can only use bricks to put in the wall he has infinite supply of them however Vova can put bricks on the neighbouring parts of the wall of equal height It means that if for some the current height of part is the same as for part then Vova can put a brick there and thus increase both heights by 1 Obviously Vova can t put bricks in such a way that its parts turn out to be off the borders to the left of part of the wall or to the right of part of it Vova is a perfectionist so he considers the wall completed when all parts of the wall has the same height the wall has no empty spaces inside it Can Vova complete the wall using any amount of bricks possibly zero ,Fairly enough solutions of both versions of the problem are pretty similar Read the second part of the previous tutorial first This problem can also be implemented in the strightforward manner The greedy solution now is searching for the first minimum in array and putting a brick in there If it s impossible then the answer is This can also be simulated with sets a bit more tedious but still ok and also Now back to the stack approach Here you can t go to parities of the numbers like tests and lead to different results You push the number itself However you will also need an extra condition on the stack You can t push to it the number greater than the current topmost element The only problem with this are maximums of array Obviously the resulting wall if the answer exists will be of height equal to the maximum initial height And it means that you shouldn t care about the ability to match all maximums in stack They way I suggest to take around the issue is to process separately each segment between two consecutive maximums One can easily prove the correctness of it by construction Overall complexity ,Let s estimate the smallest possible achievable answer Let the number of the arrays of size greater than or equal to i be g i The answer is maximum lceil frac g i c i rceil over all i from 1 to k You can prove that you can t fit g i arrays in less than lceil frac g i c i rceil testcases with the pigeonhole principle Let that be called ans Ok let s now construct the solution for that estimate Sort arrays in the increasing or decreasing order and assign the i th array 0 indexed in that order to the i mod ans testcase It s easy to see that for any i the number of arrays of size greater than or equal to i is always restricted by lceil frac g i c i rceil Overall complexity O n log n k or O n k if you care enough to do counting sort 
186,Monocarp has just learned a new card trick and can t wait to present it to you He shows you the entire deck of cards You see that the values of cards from the topmost to the bottommost are integers and all values are different Then he asks you to shuffle the deck times With the th shuffle you should take topmost cards and move them under the remaining cards without changing the order And then using some magic Monocarp tells you the topmost card of the deck However you are not really buying that magic You tell him that you know the topmost card yourself Can you surprise Monocarp and tell him the topmost card before he shows it ,The easiest way to solve to problem is probably to see the resemblense of a shuffle operation to an std rotate function So you can obtain the final deck by applying cyclic shifts of the deck by then and so on Since the shifts are cyclic it doesn t matter if you shift by or by or by for any non negative The result will be the same Thus you can calculate the sum of rotations you apply and subtract until it becomes less than That is taking it modulo Finally after rotating a sequence by some the th element of it indexed becomes the first one Thus you just want to print the th element of Overall complexity per testcase ,We just need to find the position of the in the array and then check if the sequence is going counterclockwise or clockwise from the position or correspondingly We can do this by two cycles Total complexity 
187,You have a string consisting of characters Each character is either or You can perform operations on the string Each operation consists of two steps select an integer from to the length of the string then delete the character the string length gets reduced by the indices of characters to the right of the deleted one also get reduced by if the string is not empty delete the maximum length prefix consisting of the same characters the indices of the remaining characters and the string length get reduced by the length of the deleted prefix Note that both steps are mandatory in each operation and their order cannot be changed For example if you have a string the first operation can be one of the following select we ll get select we ll get select we ll get select we ll get select we ll get select we ll get You finish performing operations when the string becomes empty What is the maximum number of operations you can perform ,Suppose the string consists of characters and each character is different from the adjacent ones so the string looks like or It s easy to see that we can t make more than operations each operation deletes at least two characters except for the case when the string consists of only one character And there is an easy way to perform exactly operations always choose the last character and delete it Okay what about the case when some adjacent characters in the string are equal It s never optimal to delete a character that s different from both adjacent characters since the second part of each operation always deletes the left block of equal characters this action merges two blocks so they will be deleted in one second part of the operation which decreases the total number of operations So we should always delete a character from a block with at least two equal characters From which of the blocks if there are more than one It s easy to see that we should choose a character from the leftmost such block since that block is the earliest to be deleted and if we want to make the same action later we might be unable to do it So the solution is greedy during each action we have to find the leftmost block consisting of at least equal characters and delete a character from it or the last character of the string if there are no such blocks Since the length of the string is up to and the number of operations is up to we should do it efficiently for example by storing the eligible blocks in some data structure ,There are several ways to solve this problem The model solution does it as follows Restore the characters of from left to right The first character is restored by query For each of the next characters let s ask if this character is new by querying and comparing the result with the number of different characters on the segment If it s new ask to obtain the th character there will be at most such queries Otherwise we can find the previous occurrence of the th character with binary search Let be the number of different characters from position to position If we want to find the previous occurrence of the th character we need to find the last index such that Since the value does not decrease when we increase we can find the last such that with binary search Unfortunately the number of queries of type will be too large if we just use binary search over the whole segment To decrease the number of queries we can use the fact that the value of we are interested in is the last occurrence of some character we already met there are at most such values and binary search among them will need only iterations 
188,You are given some text and a set of strings In one step you can choose any occurrence of any string in the text and color the corresponding characters of the text in red For example if and you can get or in one step You want to color all the letters of the text in red When you color a letter in red again it stays red In the example above three steps are enough Let s color in red we get Let s color in red we get Let s color in red we get Each string can be applied any number of times or not at all Occurrences for coloring can intersect arbitrarily Determine the minimum number of steps needed to color all letters in red and how to do it If it is impossible to color all letters of the text in red output ,The first step is to find the word that covers the maximum length prefix If there is no such word we cannot color the string Then go through the positions inside the found prefix and find the next word which is a tweak of has the maximal length and ends not earlier than the previous found word and not later than the text If there is no such word it is impossible to color After the second word is found similarly continue looking for the next ones ,Let s get rid of the queries for deleting a string There are no strings that will be added two times so we can calculate the answer for the added but not deleted strings and for the deleted separately and subtract the second from the first to get the answer So we can consider that there are no queries of deletion Now let s use Aho Corasik algorithm The only difficulty is that the strings are adding in online mode but Aho Corasik algorithm works only after adding all the strings Note that the answer for the given set of strings equal to the answer for any part of the set plus the answer for the remaining part Let s use the trick with converting the static data structure Aho Corasik in this case to the dynamic one For the set of strings let s maintain a set of no more than sets of the strings with sizes of different powers of two After adding new string we should move the sets from the lowest powers of two to the largest until we got an invariant set of sets Easy to see that each string will be moved no more than times so we can process each query in time 
189,Find the minimum area of a land on which you can place two identical rectangular houses The sides of the houses should be parallel to the sides of the desired square land Formally You are given two identical rectangles with side lengths and positive integers you are given just the sizes but their positions Find the square of the minimum area that contains both given rectangles Rectangles can be rotated both or just one moved but the sides of the rectangles should be parallel to the sides of the desired square Two rectangles can touch each other side or corner but cannot intersect Rectangles can also touch the sides of the square but must be completely inside it You can rotate the rectangles Take a look at the examples for a better understanding ,Obviously that both rectangles should completely touch by one of the sides Otherwise you can move them closer to each other so that the total height or total width decreases and the other dimension does not change Thus there are only two options The rectangles touch by width we get the side of the square equal to The rectangles touch by height we get the side of the square equal to Thus the minimum side of the square is equal to the minimum of these two options Then the answer is ,Consider the naive approach to the problem Cut off the columns directly and count the connected components There are two main solutions to this problem either DFS or BFS or DSU I personally found the DSU method easier to adjust to the full problem So to count connected components with DSU you should do the following Initialize the structure without edges every free cell is its own connected component Then add edges one by one Each edge connects two cells either vertically or horizontally When an edge connects different components they merge and the number of components decreases by one Thus the number of components on a range of columns is the number of free cells on it minus the number of meaningful edges on it the ones that will merge components if the algorithm is performed only on these columns the spanning forest edges Let s try to adjust this algorithm to the full problem It would be great if we could just calculate the spanning forest of the entire matrix and then print the number of free cells minus the number of its edges on the segment Unfortunately it s not as easy as that For components that lie fully in the segment it works However if a component is split by a border of a segment it can both stay connected or fall apart If we determine its outcome we can fix the answer There are probably a lot of ways to adjust for that but I ll tell you the one I found the neatest to code Let s add the edges into DSU in the following order Go column by column left to right First add all vertical edges in any order then all horizontal edges to the previous column in any order If you start this algorithm at the first column you will be able to answer all queries with Since the algorithm adds columns iteratively the spanning forest it s building is correct after every column So the answer for each query is indeed the number of cells minus the number of edges on the range Let s investigate the difference between starting at the first column and an arbitrary column Look at the column If it contains or free cells or that are adjacent then the cells are always in the same component regardless of what has been before column If there are no free cells nothing to the left matters too This tells us that the spanning forest that the first algorithm has built is correct for any queries that start in this The only non trivial case is when only rows and of the th column contain a free cell Then we can t tell if the algorithm is correct or not because these two cells can be in the same component already or not Let s call this a column Imagine you started processing from the leftmost column of the query left to right to the rightmost column Our previous observations tell us that once we encounter a column that is not a the algorithm onwards will be correct Until then we only have some columns to deal with We can add the part from the first non column onwards to the answer the number of cells minus the number of edges And then handle the prefix with some easy casework if the leftmost column is not then add nothing if all columns in the query are then the answer is if the first non column is then add nothing since the s get merged into the component of this column if the first non column is or then add components since neither row nor row is merged anywhere otherwise add component The number of free cells and edges on a segment can be precalculated with some prefix sums The closest non column can also be precalculated with a linear algorithm Overall complexity 
190,You are given an angle The Jury asks You to find such gon regular polygon with vertices that it has three vertices and they can be non consecutive with or report that there is no such gon If there are several answers print the one It is guarantied that if answer exists then it doesn t exceed ,At first let prove that all possible angles in the regular gon equal to where To prove it we can build circumscribed circle around gon Then the circle will be divided on equal arcs with lengths Any possible angle in the gon is a inscribed angle in the circle and equal to half of central angle Any central angle in turn equals to sum of some consecitive arcs In result any angle equal to The maximal possible angle is reached from three consecutive vertices and equal by properties of regular polygons to So we need to find minimal integer such that where is integer and Its equivalent to find minimal integer solution of Let then we can divide both parts on In result Since then must divide Analogically must divide Then solution is next and We are finding the minimal solution so is almost always except cases where here we must take since we have restricition on The picture for the futher visibility ,There are many different approaches We will describe a pretty optimal one Let s solve the problem recursively Let s say we need to process segment If we don t need to do anything Otherwise Let s find the minimum such that The chosen is convenient because it allows making equal to in two divisions and it s the minimum number of divisions to get rid of Now we can firstly make all equal to in one step by division on and then make equal to with two divisions on As a result we ve spent operations and can solve our task recursively for In total we will spend and since the segments are like There will be at most segments and operations are enough for 
191,You are given an array consisting of integers You can perform the following operations arbitrary number of times possibly zero Choose a pair of indices such that indices and are adjacent and set Choose a pair of indices such that indices and are adjacent and set The value means the absolute value of For example Your task is to find the minimum number of operations required to obtain the array of equal elements and print the order of operations to do it ,Let s find the most frequent element in the array using the array of frequencies of course Let this element be If we will see the operations more carefully we can see that the part of these operations means if then this operation is otherwise it is Now let s consider the number of operations in the optimal answer It is obvious that we need at least operations to equalize all the elements And it is also obvious that we can always do it with such operations we have How to restore the answer There is an easy way to do it find the first occurrence of Let it be Then let s go from to and set each element to the next element element at the position to to and so on And don t forget to print right type of operation Then let s go from left to right from to and if the th element don t equal to then set it to th element using right operation ,This is the solution that doesn t involve masks Let s reverse the process and try to get all zeroes from the array since all we can start from maximum The key idea since then there should be no more than one position such that and we should decrease it by Now we can decrease by and repeat the same process If at any step there are at least two or as result we won t get array filled with then there is no way to build the array 
192,On March 14 the day of the number is celebrated all over the world This is a very important mathematical constant equal to the ratio of the circumference of a circle to its diameter Polycarp was told at school that the number is irrational therefore it has an infinite number of digits in decimal notation He wanted to prepare for the Day of the number by memorizing this number as accurately as possible Polycarp wrote out all the digits that he managed to remember For example if Polycarp remembered as he wrote out Polycarp was in a hurry and could have made a mistake so you decided to check how many first digits of the number Polycarp actually remembers correctly ,In the problem you had to find the largest common prefix LCP of the first characters of the number and the string To do this we will go from the beginning and compare the characters until we find a non matching one or until the string ends ,Let s analyze which values can the function have It can be proven that the value of is equal to where is the number of zero digits at the end of the number because is the same number as except for the fact that it doesn t have any trailing zeroes Okay now let s analyze when we reach the new value of is the first value of such that is the first value of such that is the first value of such that and so on We have to calculate the maximum number that has the form and is not greater than and the answer is exactly It can be done with a mathematical solution but the most simple way to do it is read as a string instead and calculate its length 
193,You are given an array of integers Find the number of pairs where the sum of is greater than or equal to and less than or equal to that is For example if and then two pairs are suitable and and ,The problem can be divided into two classic ones Count the number of pairs Count the number of pairs Let be the answer to the first problem and be the answer to the second problem Then is the answer to the original problem The new problem can be solved by binary search Iterate over the first element of the pair Then you need to count the number of elements such that If you sort the array this value can be calculated by running a single binary search ,Firstly let s notice that for the fixed value of our problem is reduced to the following we are given numbers We need to choose such values that And among all such values we need to choose values in a way to minimize And the sum of is Of course for the fixed value the minimum sum of can be only one Let s start with It is obvious that if the maximum value in the array is the value equals for Assume that each from to has some divisor Then if we multiply by and divide each by the answer will only become better How to calculate this value of fast We can see that this value equals to And it can be proven that this value of is always optimal and we can easily determine for such Time complexity 
194,Calculate the number of ways to place rooks on chessboard so that both following conditions are met each empty cell is under attack exactly pairs of rooks attack each other An empty cell is under attack if there is at least one rook in the same row or at least one rook in the same column Two rooks attack each other if they share the same row or column For example there are only two pairs of rooks that attack each other in the following picture Two ways to place the rooks are considered different if there exists at least one cell which is empty in one of the ways but contains a rook in another way The answer might be large so print it modulo ,If we want to place n rooks on an n times n chessboard so all empty cells are under attack then either each row or each column should contain at least one rook Let s suppose that each row contains at least one rook and multiply the answer by 2 in the end How to ensure that there are exactly k pairs of rooks attacking each other Since each row contains exactly one rook only the rooks in the same column attack each other moreover if there are x rooks in a non empty column they create x 1 pairs So our goal is to distribute n rooks to n k columns so that each column contains at least one rook How to calculate the number of ways to distribute the rooks into c columns One of the options is to choose the columns we use the number of ways to do this is n choose c and then use inclusion exclusion to ensure that we are counting only the ways where each column contains at least one rook The formula we will get is something like sum limits i 0 c 1 i c choose i c i n we want to fix the number of columns that will not contain rooks that is i which are these columns that is c choose i and how many are there ways to distribute the rooks among remaining columns that is c i n Are we done Almost We wanted to multiply the answer by 2 to count the ways where each column contains at least one rook but we should not do it if k 0 because in this case each placement of the rooks has exactly one rook in each row and exactly one rook in each column , which can be proved by induction If the partition exists it has the form since the area of the rectangle with another partition will be greater than We will cut the rectangles in the order Denote the coordinates of the colored cell at the step as If and then there is no partition since the square at any location overlaps the colored cell Cut off the square from the right or left edge depending on the location of the colored cell that is or Suppose that it was advantageous to cut it not from the edge then it is necessary to cut the rectangles and where using the set Then will not enter the partition but so We came to a contradiction 
195,Petya has a rectangular Board of size Initially chips are placed on the board th chip is located in the cell at the intersection of th row and th column In one action Petya can move to the left right down or up by cell If the chip was in the cell then after the operation left its coordinates will be right its coordinates will be down its coordinates will be up its coordinates will be If the chip is located by the wall of the board and the action chosen by Petya moves it towards the wall then the chip remains in its current position For each chip Petya chose the position which it should visit Note that it s not necessary for a chip to end up in this position Since Petya does not have a lot of free time he is ready to do no more than actions You have to find out what actions Petya should do so that each chip visits the position that Petya selected for it at least once Or determine that it is not possible to do this in actions ,Note that is a fairly large number of operations Therefore we can first collect all the chips in one cell and then go around the entire board Let s calculate the required number of operations First let s collect all the chips in the cell To do this let s do operations so that all the chips are in the first row then do operations After such operations wherever the chip is initially located it will end up in the cell After that we need to go around the entire board Let s do it in such a way that the rows with odd numbers are be bypassed from left to right and the even ones from right to left We also need operations to move from one row to the next one In total we got operations which is completely suitable for us ,The first step is to notice that beauty doesn t exceed because the minimum difference between two elements is at least and the maximum difference does not exceed the difference between the maximum element and the minimum element At first finding a matrix with maximum beauty seems to be a quite difficult task So let s try to find an array of elements of maximum beauty In this case it is not difficult to come up with an array of the form In such an array there are all possible differences from to So we found an array with the maximum possible beauty It remains to find a way to convert the array to the matrix i e to find such a sequence of matrix cells that each two adjacent cells in it are side adjacent One of the ways is the following traverse the first row of the matrix from left to right go down to the second row traverse it from right to left go down to the third row traverse it from left to right and so on Thus we constructed a matrix with the maximum possible beauty 
196,Vlad and Nastya live in a city consisting of houses and road From each house you can get to the other by moving only along the roads That is the city is a tree Vlad lives in a house with index and Nastya lives in a house with index Vlad decided to visit Nastya However he remembered that he had postponed for later things that he has to do before coming to Nastya To do the th thing he needs to come to the th house things can be done in any order In minute he can walk from one house to another if they are connected by a road Vlad does not really like walking so he is interested what is the minimum number of minutes he has to spend on the road to do all things and then come to Nastya Houses he can visit in any order He can visit any house multiple times if he wants ,To begin with we will hang the tree by the vertex In fact we want to go from the root to the top of going off this path to do things and coming back At one vertex of the path it is advantageous to get off it in all the necessary directions and follow it further So we will go once for each edge leading to and times for each edge leading to some of the cases but not leading to Let s match each vertex with an edge to its ancestor If the edge of a vertex leads to then is in the subtree of this vertex similarly with vertices with cases It is necessary for each vertex to determine whether there is a vertex in its subtree and whether there is a vertex from the array this can be done using a depth first search then we will calculate the answer according to the rules described above ,First of all let s try to find a simple way to evaluate the difficulty of a given set of towers I claim that the difficulty is equal to the number of pairs of discs that belong to different towers during each operation we can merge at most one such pair if we move discs to the tower with disk on top of it only the pair can be affected we can always take the first several discs belonging to the same tower and move them to the tower containing disc thus merging exactly one pair in exactly one operation After that there are two main approaches LCA and small to large merging The model solution uses LCA so I ll describe it For each pair we have to find the first moment these discs belong to the same tower To do so let s build a rooted tree on vertices The vertices to will be the leaves of the tree and will represent the original towers The vertex will represent the tower created during the th query and will have two children the vertices representing the towers we merge during the th query The vertex is the root Now if some vertex is an ancestor of vertex it means that the tower represented by vertex contains all the discs from the tower represented by vertex So to find the first tower containing two discs and we have to find the lowest common ancestor of the vertices representing the towers and The easiest way to do it is to implement something like binary lifting which allows us to solve the problem in 
197,Monocarp is playing a tower defense game A level in the game can be represented as an OX axis where each lattice point from to contains a tower in it The tower in the th point has mana capacity and mana regeneration rate In the beginning before the th second each tower has full mana If at the end of some second the th tower has mana then it becomes mana for the next second There are monsters spawning on a level The th monster spawns at point at the beginning of th second and it has health Every monster is moving point per second in the direction of increasing coordinate When a monster passes the tower the tower deals damage to it where is the current health of the monster and is the current mana amount of the tower This amount gets subtracted from both monster s health and tower s mana Unfortunately sometimes some monsters can pass all towers and remain alive Monocarp wants to know what will be the total health of the monsters after they pass all towers ,Let s start thinking about the problem from the easy cases How to solve the problem fast if all towers have full mana We can store prefix sums of their capacities and find the first tower that doesn t get drained completely with a binary search Let s try the opposite How to solve the problem fast if all towers were drained completely in the previous second It s the same but the prefix sums are calculated over regeneration rates What if all towers were drained at the same second earlier than the previous second and no tower is fully restored yet It s also the same but the regeneration rates are multiplied by the time passed since the drain What if we drop the condition about the towers not being fully restored How would a data structure that can answer prefix sum queries work It should store the total mana capacity of all towers that are full Then mana regeneration rates for all towers that aren t If these are kept separately then it s easy to obtain the prefix sum by providing the time passed This will be total capacity plus total regeneration rate multiplied by the time passed How to determine if the tower is fully restored since the drain or not That s easy For each tower we can calculate the number of seconds it takes it to get restored from zero That is Thus all towers that have this value smaller than the time passed won t get restored All the rest will Unfortunately in the actual problem not all towers were last drained at the same time However it s possible to reduce the problem to that Store the segments of towers that were drained at same time There are also towers that weren t drained completely but they can be stored as segments of length too When a monster comes it drains some prefix of the towers completely and possibly one more tower partially In terms of segments it removes some prefix of the them and possibly cuts one Then it creates a segment that covers the prefix and possibly a segment of length with a partially drained tower So each monster creates segments and removes no more segments than were created Thus if we were to process each creation and removal in some then the complexity will be All towers on each segment have the same time passed since the drain We want to query the sum on the entire segment If it is greater than the remaining health of the monster we want to find the largest prefix of this segment that has a smaller or equal sum than the monster health Given time passed let s learn to query the range sum If we knew the queries beforehand it would be easy Initialize a segment tree as if all towers are completely restored Then make events of two kinds a tower with restore time and a query with time Sort them in the decreasing order and start processing one by one When a tower event happens update a single position in the segment tree from capacity to regeneration rate When a query event happens find the sum Since the queries are not known beforehand make that segment tree persistent and ask specific versions of it If a segment of towers was last drained at time and the query is at time then you should query the segment tree in version Obviously you can store not all versions but only ones that have some tower change Moreover it s more convenient to make one version responsible for one tower update Then you can lower bound the array of sorted to find the version you want to ask at To determine the largest prefix of this segment that has a smaller or equal sum than the monster health you can either binary search for or traverse the segment tree for The time limit might be a little tight for the first approach but it can still pass Overall complexity ,The first thing we need to do is to find the occurrences of in the sequence these are the monsters that have to remain Since both spells Fireball and Berserk affect consecutive monsters we should treat each subsegment of monsters we have to delete separately Consider a segment with monsters we have to delete such that the last monster before it has power the first monster after the segment has power and the strongest monster on the segment has power If then we have to use Berserk at least times Let s make the strongest monster on segment kill some other monster If then the strongest monster should also be killed by one of the monsters bounding the segment so if and there is no solution Okay now the number of monsters is divisible by If it is more profitable to use Fireball we use the required number of Fireballs to kill all of them Otherwise we have to kill the maximum possible number of monsters with Berserk and finish the remaining ones with Fireball If or then one of the monsters just outside the segment can kill all the monsters inside the segment otherwise the strongest monster should kill adjacent monsters until exactly remain and those monsters are finished with a single Fireball Now we know what we need to consider when processing a single segment all that s left is to sum the minimum required mana over all such segments Since the total length of these segments is at most and we can process each segment in linear time we have a solution with complexity 
198,You are given a string such that each its character is either or You have to choose the shortest contiguous substring of such that it contains each of these three characters at least once A contiguous substring of string is a string that can be obtained from by removing some possibly zero characters from the beginning of and some possibly zero characters from the end of ,There are multiple solutions involving advanced methods such as binary search or two pointers but I ll try to describe a simpler one The main idea of my solution is that the answer should look like one character of type a block of characters of type and one character of type If we find all blocks of consecutive equal characters in our string each candidate for the answer can be obtained by expanding a block to the left and to the right by exactly one character So the total length of all candidates is and we can check them all Why does the answer look like If the first character of the substring appears somewhere else in it it can be deleted The same applies for the last character So the first and the last characters should be different and should not appear anywhere else within the string Since there are only three types of characters the answer always looks like ,Consider deleting characters with numbers and as well as characters with numbers and In the first case the symbol with the number remains in the second Symbols with numbers less than or more than remain in both cases Therefore the same strings will be obtained if the characters with the numbers and match Therefore we just need to count the number of and subtract this value from 
199,Alice and Bob play a game Alice has got treasure chests the th of which contains coins and keys the th of which she can sell Bob for coins Firstly Alice puts some locks on the chests There are types of locks the locks of the th type can only be opened with the th key To put a lock of type on the th chest Alice has to pay dollars Alice can put any number of different types of locks on each chest possibly zero Then Bob buys some of the keys from Alice possibly none possibly all of them and opens each chest he can he can open a chest if he has the keys for all of the locks on this chest Bob s profit is the difference between the total number of coins in the opened chests and the total number of coins he spends buying keys from Alice If Bob s profit is greater than zero he wins the game Otherwise Alice wins the game Alice wants to put some locks on some chests so no matter which keys Bob buys she always wins Bob cannot get positive profit Of course she wants to spend the minimum possible number of dollars on buying the locks Help her to determine whether she can win the game at all and if she can how many dollars she has to spend on the locks ,Firstly let s try to find some naive solution for this problem Let s iterate on the subset of locks Alice puts on the chests After choosing the subset of locks how to check whether Bob can gain positive profit We can iterate on the subset of keys he can buy as well but in fact this problem has a polynomial solution Construct a flow network as follows each chest and each key represents a vertex there are arcs from the source to the vertices representing the chests each having capacity arcs from the vertices representing the keys to the sink each having capacity and for each chosen lock an arc from the respective chest vertex to the respective key vertex with infinite capacity If we find the minimum cut from the source to the sink then Bob s profit is The reasoning behind this solution is the following one if Bob takes all the chests and all the keys belonging to the first part of the cut his profit is equal to the total cost of all chests he has taken minus the total cost of all keys he has taken minus infinity if he takes a chest he can t open And the value of the cut is equal to the total cost of chests he doesn t take plus the total cost of keys he takes plus infinity if he can t open some chest he takes since the arc from this chest vertex to one of the key vertices belongs to the cut So Bob s profit is and by minimizing the cut value we maximize his profit A minimum cut can be easily found using any maxflow algorithm Unfortunately even iterating through all subsets of locks is too slow To improve this solution we should look at the minimum cut and its usage a bit more in detail Notice that Bob can always take no keys and open no chests to get a profit of zero so Alice s goal is to ensure that it is the best Bob s option If Bob takes no chests and no keys it means that the cut divides the network into two parts the source and all other vertices And in terms of flows it means that the maximum flow in this network I highlighted it because it is the key idea of the solution Here the constraints on and come in handy We can use a dynamic programming with the flow over all arcs going from the source as one of the states One of the ways to implement it is to have as the state where through are the values of the flow going from the arcs from the source is the current vertex in the left part we consider is the current vertex in the right part we consider and is the flow we already pushed through the arc connecting vertex of the right part to the sink and the value we store for this state is the minimum cost Alice has pay to reach this state There are two basic types of transitions in this dynamic programming we either skip the arc from to or pick it and transfer some flow through it and no matter what we ve chosen we move to the next vertex of the left part or to and increase by if we are already considering the th vertex of the left part The constraints were loose enough to implement this dp basically in any form there was no need to compress the states into single integers for example which was what the most participants of the round did ,Firstly we obviously need to take at least coins of value If we cannot do it the answer it Otherwise we always can obtain the required sum if 
200,You are given array Find the subsegment with maximum arithmetic mean in floating point numbers i e without any rounding If there are many such subsegments find the one ,There is a property of arithmetic mean and the equality holds when Obviously we can always gain maximum arithmetic mean equal to by taking single maximum element from Considering the property above we need to take only maximum elements in our subsegment that s why we need to find the longest subsegment consisting only of maximum elements ,Unfortunately my solution for this problem had overflow bug It was fixed on contest Even so I hope you enjoyed the problem because I think it s very interesting Let s transform the sum Note that the last sum can be accumulated to only value because for all the values will be equal to Note in the last sum either or Let s carefully accumulate both cases The first sum can be simply calculated by iterating over all We will accumulate the second sum independently for all different values Firstly we should determine for which values we will have the value Easy to see that for the values from the interval Also we can note that the sum of the second factors in with fixed first factor can be calculaed in constant time it s simply a sum of arithmetic progression So we have solution with complexity 
201,You are given an array consisting of integers numbered from to Initially all elements of are zero You have to process two types of queries to this array increase by compute where is the set of all integers from to which have remainder modulo Can you process all the queries ,Let s notice that if we process the queries of type naively then each such query consumes time where is the size of the array So queries with large can be processed naively For queries with small we may notice two things there are only possible queries each number in the array affects only possible queries So for small we may maintain the exact answer for each query and modify it each time we modify an element in the array If we process naively all queries with and maintain the answers for all queries with we will obtain a solution having time complexity Note that as in most problems related to sqrt heuristics it may be optimal to choose the constant that is not exactly but something similar to it but most solutions should pass without tuning the constant ,Let s define some functions at first indicator function if is true and otherwise is a number of that and Good observation Another observation Now it s time to transform what we d like to calculate Since transformation of the second sum was standard we ll look at the first sum So we can iterate over and we d like to calculate this two sums fast enough So more transformations So while iterating over we need to make queries of two types set value in position and calculate It can be done by BIT with coordinate compression can be calculated in the same way iterating over in reverse order Result complexity is 
202,There is a city that can be represented as a square grid with corner points in and The city has vertical and horizontal streets that goes across the whole city i e the th vertical streets goes from to and the th horizontal street goes from to All streets are bidirectional Borders of the city are streets as well There are persons staying the th person at point so either equal to some or equal to some or both Let s say that a pair of persons form an if the shortest path from one person to another going only by streets is than the Manhattan distance between them Calculate the number of inconvenient pairs of persons pairs and are the same pair Let s recall that Manhattan distance between points and is ,Firstly let s look at some point Let s find closest to it vertical and horizontal lines We will name the closest vertical lines from left and right as and and and as closest horizontal lines So and we can also note that either or Now let s note that if for some other point either or then to reach from we must go reach either or or or so the shortest distance will be strictly greater than the Manhattan distance If neither nor then we can show that it s always possible to find the shortest path equal to the Manhattan distance As a result for each point we should find the number of points such that and or The exception here is when lies on the same line as so we should not count such points We can note that since either or there is no such point that and simultaneously so we can calculate the pairs by and coordinates independently Let s focus on coordinates to calculate for coordinates we can just swap all coordinates Let s sort all points by coordinate To get rid of the case when points and lies on the same vertical street we can group them by coordinate and process by group since we sorted by groups are just segments There are no problems with the case when points lie on the same horizontal street since then and there are no other with If we store for each horizontal line the number of point inside the interval then when we need for point calculate the number of points with and we can just ask for value assigned to because and are consecutive elements in the array So we go through each group two times first collecting answer then updating values in appropriate s Note that we can calculate and with binary search using built in functions The resulting complexity is ,Intersection of some segments is If this segment has its left bound greater than its right bound then the intersection is empty Removing some segment makes the original sequence equal to That can be split up to a prefix of length and a suffix of length Intersections for them can be precalced separately and stored in some partial sum like arrays Finally you have to iterate over the position of the removed segment and calculate the intersection of prefix and suffix without this segment Overall complexity 
203,Vasya has got a robot which is situated on an infinite Cartesian plane initially in the cell Robot can perform the following four kinds of operations move from to move from to move from to move from to Vasya also has got a sequence of operations Vasya wants to modify this sequence so after performing it the robot will end up in Vasya wants to change the sequence so the length of changed subsegment is minimum possible This length can be calculated as follows where is the maximum index of a changed operation and is the minimum index of a changed operation For example if Vasya changes to then the operations with indices and are changed so the length of changed subsegment is Another example if Vasya changes to then the length of changed subsegment is Help Vasya Tell him the minimum length of subsegment that he needs to change so that the robot will go from to or tell him that it s impossible ,Denote If then the answer is 1 since the robot will not have the time to reach cell in steps Also if and have different parity then the answer is also 1 as in one move the robot changes the parity of the sum of its coordinates In all other cases the answer exists Let s use binary search to solve this problem Consider all segments of length For a fixed length of the segment let s iterate over the position of the beginning of the segment At the same time we will maintain the cell that the robot will stop at if it execute all commands except commands with indices We denote this position as We also calculate the distances from the cell to the cell the value If there is at least one position of the beginning of the segment for which then we can change the segment of length so that the robot comes to the cell otherwise it can t ,A route visiting each cell exactly once can always be denoted as follows several possibly zero first columns of the glade are visited in a zigzag pattern then Vasya goes to the right until the end of the glade makes one step up or down and goes left until he visits all remaining cells There are such routes To calculate the weight of collected mushrooms quickly we will precompute three arrays for the first row of the glade and will be used to compute the weight of mushrooms collected when Vasya moves to the right until the last column of the glade when Vasya moves to the left from the last column and to handle the growth of mushrooms Also we have to compute the same arrays for the second row of the glade Let s iterate on the number of columns Vasya will pass in a zigzag pattern and maintain the weight of mushrooms he will collect while doing so Then we have to add the weight of the mushrooms Vasya will gather while moving to the right and then while moving to the left The first can be handled by arrays and the second by arrays and 
204,Suppose you have boxes The th box contains infinitely many balls of color Sometimes you need to get a ball with some specific color but you re too lazy to do it yourself You have bought two robots to retrieve the balls for you Now you have to program them In order to program the robots you have to construct two lists and where the list represents the boxes assigned to the first robot and the list represents the boxes assigned to the second robot When you request a ball with color the robots work as follows Each robot looks through the boxes that were assigned to that robot in the order they appear in the list The first robot spends seconds analyzing the contents of a box the second robot spends As soon as one of the robots finds the box with balls of color and analyzes its contents the search ends The search time is the number of seconds from the beginning of the search until one of the robots finishes analyzing the contents of the th box If a robot analyzes the contents of all boxes assigned to it it stops searching For example suppose If you request a ball with color the following happens initially the first robot starts analyzing the box and the second robot starts analyzing the box at the end of the nd second the first robot finishes analyzing the box It is not the box you need so the robot continues with the box at the end of the rd second the second robot finishes analyzing the box It is not the box you need so the robot continues with the box at the end of the th second the first robot finishes analyzing the box It is not the box you need so the robot continues with the box at the end of the th second the first robot finishes analyzing the box It is not the box you need so the robot continues with the box At the same time the second robot finishes analyzing the box It is not the box you need and the second robot has analyzed all the boxes in its list so that robot stops searching at the end of the th second the first robot finishes analyzing the box It is the box you need so the search ends so the search time is seconds You know that you are going to request a ball of color times a ball of color times and so on You want to construct the lists and for the robots in such a way that the total search time over all requests is the minimum possible ,If the ball of color x is present in the first list on position i then it takes i cdot t 1 seconds to find it The same for the second list if color x is on position j it takes j cdot t 2 seconds to find it So for each position we have a coefficient which will be multiplied by the number of times it is requested and the total search time is the sum of these products for all positions There is a classical problem of the form you are given two arrays a i and b i both of length m consisting of non negative integers permute the elements of a in such a way that sum limits i 1 m a i cdot b i is the minimum possible To solve this problem you have to pair the maximum element of a with the minimum element of b the second maximum of a with the second minimum element of b and so on We can reduce our problem to this one For each of 2n positions in the lists there is a coefficient you have to assign the boxes from 1 to n to the positions so that the sum of r i multiplied by the coefficients for the positions is the minimum possible This looks similar but there are 2n positions and only n boxes To resolve this issue we can try a lot of different approaches I believe the easiest one is the following initially both lists are empty and when want to add an element to one of these two lists we choose the list such that the coefficient for the new position which is s i cdot 1 cnt i where cnt i is the number of elements we already added to the i th list is smaller If for both lists adding a new element has the same coefficient it doesn t matter which one we choose This greedy approach works because every time we add an element to the list next time we ll add another one into the same list the coefficient for that element will be greater So the problem can be solved in O n log n first we sort the boxes by the number of times they are requested in non ascending order and then we put them into the two lists greedily every time choosing the list such that the coefficient for the next element is smaller ,Let s maintain the current availability of colors and the amounts of cars of each color Firstly color is never available When car of some color goes you check if the number of cars of color past before this one isn t smaller than the number of cars of color Only after that increment the amount by one If it was less then set its availability to false If car of color goes then simply increment its amount In the end iterate over all colors and check if it s both available and has higher or equal amount than the amount of cars of color Okay why this works As all the amounts cannot decrease color will become not available at some moment when car of color goes And this will be encountered either when the new car of color goes or in the end of the sequence Amount of cars of color doesn t update between this periods And if there was point when there became more cars of color than of color then this inequality will hold until the next moment we will check Overall complexity 
205,You are given a permutation of length of numbers Count the number of subsegments of this permutation such that of is the smallest non negative integer that does not occur in For example of the set is the median of the set i e the element that after sorting the elements in non decreasing order will be at position number array elements are numbered starting from and here denotes rounding down For example A sequence of numbers is called a permutation if it contains all the numbers from to exactly once ,Let s learn how to count the number of subsegments where for a fixed value of Let s understand on which subsegments has such a value We understand that the numbers should be in this subsegment the number should not and then does not matter Let be the index of the left most occurrence of the numbers and the right most occurrence Also let be the index of the number If then there is no subsegment with the given otherwise let s think about how many numbers can be in a subsegment It is stated that if the length of a segment is then on it otherwise it is not true Indeed if the length of a segment is then simply by the definition of the median it will be among the first numbers On the other hand if the length of the segment becomes longer then according to the same definition of the median it will no longer be among the first numbers which are equal to It turns out that we need to count the number of subsegments of length that contain the subsegment inside themselves but not This of course can be done with large formulas and the like but one more useful fact can be noticed If we iterate over in ascending order and at the same time maintain and then let s see what happens with a fixed and a position of for convenience let s assume that since the second case is similar In fact you can simply iterate over the left border of our segment from to and then use a simpler formula to calculate the number of good subsegments with such fixed values Why can this left boundary be iterated for each if correspondingly if it were then we would iterate over the right boundary Let s remember that after this step becomes equal to That is if we iterate over an element then we move the corresponding border And we can only move it times ,The intended solution for this problem uses time and memory Firstly let s calculate for each from to where is the number of occurrences of in This part can be done in Then let s iterate over all segments of of length at least maintaining the sum of the current segment We can notice that we don t need sums greater than because all elements do not exceed So if the current sum does not exceed then add to the answer and set to prevent counting the same elements several times This part can be done in 
206,You are given a sequence of pairs of integers This sequence is called bad if it is sorted in non descending order by first elements or if it is sorted in non descending order by second elements Otherwise the sequence is good There are examples of good and bad sequences is bad because the sequence of first elements is sorted is bad because the sequence of second elements is sorted is bad because both sequences the sequence of first elements and the sequence of second elements are sorted is good because neither the sequence of first elements nor the sequence of second elements is sorted Calculate the number of permutations of size such that after applying this permutation to the sequence it turns into a good sequence A permutation of size is a sequence consisting of distinct integers from to If you apply permutation to the sequence you get the sequence For example if and then turns into ,Let s suppose that all permutation are good We counted the permutations giving the sequences where the first elements are sorted we denote the number of such permutations as and the permutations giving the sequences where the second elements are sorted we denote the number of such permutations as Then the answer is right No because we subtracted the number of sequences where first and second elements are sorted simultaneously we denote this number as twice So the answer is How can we calculate the value of It s easy to understand that the elements having equal can be arranged in any order So where is the number of elements equal to among can be calculated the same way How can we calculate the value of First of all there is a case where it is impossible to arrange the elements of the sequence so that the first elements and the second elements are sorted To check that we may sort the given sequence comparing two elements by and if are equal by If the sequence of second elements in the resulting sequence is not sorted then Otherwise equal elements of the given sequence can be arranged in any order So where are the elements that appear in the given sequence of pairs at least once ,We just need to find the position of the in the array and then check if the sequence is going counterclockwise or clockwise from the position or correspondingly We can do this by two cycles Total complexity 
207,Inflation has occurred in Berlandia so the store needs to change the price of goods The current price of good is given It is allowed to increase the price of the good by times with k is an integer Output the roundest possible new price of the good That is the one that has the maximum number of zeros at the end For example the number is more round than the number three zeros at the end of and only one at the end of If there are several possible variants output the one in which the new price is maximal If it is impossible to get a rounder price output that is the maximum possible price ,The answer is First count two numbers which denote the degree of occurrence of and in the number respectively that is Where is not divisible by either or Now while we will increase the corresponding value For example if then as long as and at that we will increase by and multiply by times That way we can get the most round number possible by spending the least possible Now we either have or or Then in the first case we will multiply the number by as long as we can That is until Now in either case we have Then Then we multiply by times and get our desired answer In the last step we can no longer get a rounder number but just find the maximal possible number ,Note that we do not need to consider the numbers we are only interested in the remainder of the division of by and we simply add the value to the answer We get an array where Let s sort it and greedily type index pairs such that This can be done with two pointers Then add the number of matching pairs to the answer counter This will be the answer to the problem 
208,There are candies in a candy box The type of the th candy is You have to prepare a gift using some of these candies with the following restriction the numbers of candies of each type presented in a gift should be all distinct i e for example a gift having two candies of type and two candies of type is bad It is also possible that of some types will be taken to a gift Your task is to find out the possible size of the single gift you can prepare using the candies you have You have to answer independent queries ,Let s calculate the array where is the number of candies of the th type Let s sort it in non ascending order Obviously now we can take because this is the maximum number of candies of some type in the array Let be the last number of candies we take Initially it equals and the answer is initially the same number Then let s iterate over all values of in order from left to right If the current number is greater than or equal to the last taken number of candies then we cannot take more candies than because we iterating over values of in non ascending order so let s increase answer by and set Otherwise and we can take all candies of this type increase the answer by and set ,Firstly we obviously need to take at least coins of value If we cannot do it the answer it Otherwise we always can obtain the required sum if 
209,There is a chip on the coordinate line Initially the chip is located at the point You can perform any number of moves each move increases the coordinate of the chip by some positive integer which is called The length of the first move you make should be divisible by the length of the second move by the third by and so on For example if then the sequence of moves may look like this because is divisible by is divisible by is divisible by is divisible by You are given two positive integers and Your task is to count the number of ways to reach the point starting from for every The number of ways can be very large so print it modulo Two ways are considered different if they differ as sets of visited positions ,Let s calculate dynamic programming the number of ways to achieve in moves From the state you can make a transition to the states where and is divisible by Let s try to estimate the maximum number of moves because it seems that there can t be very many of them For moves the minimum distance by which a chip can be moved is or From here one can see that the maximum number of transitions does not exceed maximum at So it remains to make transitions in dynamic programming faster than from a single state for a fast enough solution Let s use the fact that Let s iterate over the value of and maintain the sum of dynamic programming values with smaller indices for each remainder modulo in a separate array The final complexity of such a solution is It remains to solve the memory problem because with the existing limits it is impossible to save the entire matrix of size However this is easy to solve if you notice that only the previous layer is used for transitions in dp i e it is enough to store to calculate ,Let s iterate over all possible values of from to It is obvious that cannot be bigger than else we can just move to Then let s iterate over all possible multiples of from to Let this number be Then we can find as the nearest number to that is divisible by we can check two nearest numbers to be sure These numbers are and Then we can update the answer with the found triple Note that the only condition you need to check is that Time complexity because of the sum of the harmonic series 
210,For an array of integers let s define as the number of elements in it Let s denote two functions is a function that takes an array of integers and a positive integer The result of this function is the array containing first elements of the array that you get by replacing each element of with exactly copies of that element For example is calculated as follows first you replace each element of the array with copies of it so you obtain Then you take the first elements of the array you obtained so the result of the function is is a function that takes an array of integers and two integers and The result of this function is the array with every element equal to replaced by and every element equal to replaced by For example An array is a of the array if either there exists a positive integer such that or there exist two different integers and such that An array is an of the array if there exists a finite sequence of arrays such that is is and for every is a parent of You are given two integers and Your goal is to construct a sequence of arrays in such a way that every array contains exactly elements and all elements are integers from to for every array consisting of exactly integers from to the sequence contains at least one array such that is an ancestor of Print the minimum number of arrays in such sequence ,First of all since the second operation changes all occurrences of some number to other number and vice versa then by using it we can convert an array into another array if there exists a bijection between elements in the first array and elements in the second array It can also be shown that so we can consider that if we want to transform an array into another array then we first apply the function then the function Another relation that helps us is that it means that every time we apply the function we can easily rollback the changes Considering that we have already shown that a sequence of transformations can be reordered so that we apply only after we ve made all operations with the function let s try to rollback the second part of transformations i e for each array find some which can be obtained by using the function Since applying the second operation several times is equal to applying some bijective function to the array we can treat each array as a partition of the set into several subsets So if we are not allowed to perform the first operation the answer to the problem is equal to where is the number of ways to partition a set of objects into non empty sets these are known as There are many ways to calculate Stirling numbers of the second kind but in this problem we will have to use some FFT related approach which allows getting all Stirling numbers for some value of in time For example you can use the following relation If we substitute and we can see that the sequence of Stirling numbers for some fixed is just the convolution of sequences and For simplicity in the following formulas let s denote We now know that this value can be calculated in Okay now back to the original problem Unfortunately we didn t take the operation into account Let s analyze it The result of function consists of several blocks of equal elements and it s easy to see that the lengths of these blocks except for maybe the last one should be divisible by The opposite is also true if the lengths of all blocks except maybe for the last one are divisible by some integer then the array can be produced as for some array What does it mean If the greatest common divisor of the lengths of the blocks except for the last one is not the array that we consider can be obtained by applying the function to some other array Otherwise it cannot be obtained in such a way Now inclusion exclusion principle comes to the rescue Let s define as the number of arrays that we consider which have the lengths of all their blocks except maybe for the last one divisible by It s easy to see that we can compress every consecutive elements into one Then using inclusion exclusion principle we can see that the answer is where is the Mobius function Using this formula we can calculate the answer in This inclusion exclusion principle handles the arrays according to the GCD of the blocks that they consist of except for the last one But what if the array consists only of one block These arrays can be counted wrongly so we should exclude them i e use instead of just and count the arrays consisting of the same element if we need any of them in the answer separately Depending on the way you implement this or or both may be a corner case ,A lot of solutions which were written during the contest use Berlekamp Messey or some other algorithms related to analyzing linear recurrences but the model solution is based on other principles First of all if the number of inversions is at most it means that most elements of the permutation will stay at their own places and those which don t stay at their places can t be too far away from them Let s denote a block in a permutation as a segment of indices such that all elements less than are to the left of the block all elements greater than are to the right of the block all elements from belong to the block Let s say that a block is non trivial if it contains at least two elements Suppose we split a permutation into the maximum number of blocks Then for each block we can see that if its length is it has at least inversions to prove it you can use the fact that the number of inversions is equal to the number of swaps of adjacent elements required to sort the permutation and if we cannot split the block into other blocks it means that we have to swap each pair of adjacent elements in it at least once to sort it if the block is non trivial it has at least one such that From these two facts we can see that there will be at most non trivial blocks there will be at most elements in total belonging to non trivial blocks the maximum possible length of a block is The main idea of the solution is to calculate the following dynamic programming is the number of ways to split elements into non trivial blocks such that there are exactly inversions in them and exactly pairs Then to get the answer for the test case we can iterate on the number of non trivial blocks and the number of elements in them and choose the elements belonging to that blocks with a binomial coefficient The only thing that s left is how to calculate this dynamic programming efficiently There are a few ways to do it but the model solution uses a table the number of different non trivial blocks of length with elements and inversions to handle transitions This table is not very big so you can run an exhaustive search for minutes to calculate it and then just paste its results into the source code of your program Note that you have to make sure that you consider only the blocks which cannot be split any further 
211, You are given an sequence of form which consist of blocks of all consecutive positive integers written one after another The first block consists of all numbers from to the second one from to the third one from to the th block consists of all numbers from to So the first elements of the sequence are Elements of the sequence are numbered from one For example the st element of the sequence is the rd element of the sequence is the th element of the sequence is the th element is the th element of the sequence is Your task is to answer independent queries In the th query you are given one integer Calculate the digit at the position of the sequence ,This problem idea is not very hard Now can be up to so we need to find the number of block faster Let s do binary search on it Now using some pretty formulas we can determine if the total sum of lengths of blocks from to is greater than or equal to or not And more about these formulas let s iterate over all possible length of numbers from to and carry the sum of lengths of numbers with length less than the current length We know that the number of numbers he he of length is exactly for Let s add to the total sum of lengths and increase by What does means This formula means that we have exactly blocks ending with numbers of length and we need to add sum of lengths of all numbers with length less than exactly times And what does means It is the sum sums of lengths of all numbers of length i e previously we added sum of lengths of numbers with length less than and now we add sum of sums of lengths of numbers with length When we found the number of block let s decrease by the total length of all blocks from to and continue solving the problem This part was pretty hard to understand And the easiest part when we determined the number of block we can easily determine the number from to such that our answer lies in the number Let s iterate over all lengths from to here we go again and for the current length let for And now all we need is to increase the sum of lengths by After determining decrease by sum of lengths of numbers from to and print Time complexity ,Let s denote as the largest of the terms of the sum and is the smaller one Consider cases or If then So we need to find two consecutive substrings of length such that if we convert these substrings into integers their sum is equal to If let be the largest common prefix of and if we consider them as strings Then or So it is necessary to check only these two cases and whether goes before or after in the string Thus we have reduced the number of variants where the substrings for and are located to It remains to consider how to quickly check whether the selected substrings are suitable To do this you can use hashes preferably with several random modules 
212,You are going to the beach with the idea to build the greatest sand castle ever in your head The beach is not as three dimensional as you could have imagined it can be decribed as a line of spots to pile up sand pillars Spots are numbered through infinity from left to right Obviously there is not enough sand on the beach so you brought packs of sand with you Let height of the sand pillar on some spot be the number of sand packs you spent on it There is a fence of height equal to the height of pillar with sand packs to the left of the first spot and you should prevent sand from going over it Finally you ended up with the following conditions to building the castle no sand from the leftmost spot should go over the fence For any large difference in heights of two neighboring pillars can lead sand to fall down from the higher one to the lower you really don t want this to happen you want to spend all the sand you brought with you As you have infinite spots to build it is always possible to come up with some valid castle structure Though you want the castle to be as compact as possible Your task is to calculate the minimum number of spots you can occupy so that all the aforementioned conditions hold ,Let s consider the optimal answer to always look like will be the leftmost position of a pillar with maximum height We will heavily use the fact that all integers from to appear in this sequence to the right of If you are able to construct any answer it is easy to rearrange it to this pattern select the leftmost maximum sort in non decreasing order and in non increasing order Sorted sequence will also be valid Let a pyramid of height be such a valid castle that it occupies exactly consecutive spots and Exactly sand packs are required to build it At first let s solve the problem without even touching the fence This won t always give the minimal answer but it ll help us further Given some you can build the pyramid of height and get sand packs left over This can fit in exactly pillars you can place any pillar of height next to some pillar of the same height That way we see that This function is non increasing let s show that for any from to is non positive Now we can show that it is always optimal to push the initial pyramid to the left as far as possible probably removing some pillars on positions less than That way the leftmost pillar will have height The total number of sand packs required to build it is This pattern will also include all the integers from to and will have the minimal width you can achieve Monotonicity of this function can be proven in the similar manner Finally the answer can be calculated using the following algorithm Find the maximum such that where Solve the equation or just do the binary search Output the width of resulting truncated pyramid plus the minimal number of additional pillars it will take to distribute leftover sand packs You should also take into consideration the upper bound on to avoid multiplying huge numbers It s about so bit integer type will be enough for all the calculations Overall complexity or ,The solution is to check the sum over all diagonals for each cell For a cell we can iterate over all elements in all its diagonals This will be in total elements The complexity will be solutions involving precomputation are also possible but aren t needed 
213,You are given a tree consisting of vertices A number is written on each vertex the number on vertex is equal to Let s denote the function as the greatest common divisor of the numbers written on the vertices belonging to the simple path from vertex to vertex including these two vertices For every integer from to you have to count the number of pairs such that is equal to this number ,Firstly for every we can calculate the number of paths such that is divisible by We can do it as follows generate all divisors of numbers numbers not exceeding have at most divisors so this will be fast enough and then for every analyze the graph containing the vertices that have as its divisor Each component of this graph gives us paths if its size is and this is the only formula we need to calculate the number of paths where is divisible by let this be How can we get the answer if we know the values of We can use inclusion exclusion with Mobius function for example to prove that and then if we want to apply the same technique for finding with any possible we could divide all numbers by and do the same thing But it might be too slow so it s better to rewrite this formula as because we will do exactly the same when dividing all numbers by In fact most contestants have written a much easier version of this solution so this might be a bit too complicated This problem can also be solved with centroid decomposition ,Let s initialize variables and by the same value of Then we need to gather additionally the remainder of dividing by If the remainder is equal to we don t need to gather anything else because the variables and have been already set to the correct answer because and no absolute value can be less than Otherwise because and in this case but that s impossible if isn t divisible by 3 If the remainder is equal to then we need to gather additionally burle using one coin of burle so let s increase by In this case hence this value cannot be less than as it was proved above If the remainder is equal to then we need to gather additionally burles using one coin of burles so let s increase by In this case hence this value cannot be less than There are no other remainders of dividing by so these cases cover the whole solution 
214,Recently Vlad has been carried away by spanning trees so his friends without hesitation gave him a connected weighted undirected graph of vertices and edges for his birthday Vlad defined the of a spanning tree as the bitwise OR of all its weights and now he is interested in what is the minimum possible that can be achieved by choosing a certain spanning tree A spanning tree is a connected subgraph of a given graph that does not contain cycles In other words you want to keep edges so that the graph remains connected and the bitwise OR weights of the edges are as small as possible You have to find the minimum bitwise OR itself ,We need to minimize the result of the bitwise operation so for convenience we represent the answer as a mask Firstly let s assume that this mask is composed entirely of ones Let s go from the most significant bit to the least significant one and try to reduce the answer To understand whether it is possible to remove the th bit remove it and check if the graph in which all the weights are submasks of the current answer is connected for this you can use depth first search or a disjoint sets union If the graph is connected then the bit can obviously be thrown out and if not it cannot and must be returned ,Let s say we remove applications with and applications with Obviously among all the applications with it was necessary to take maximum in memory so we will clear the most memory Let s split all the applications into two arrays with and and sort them Then you need to take a prefix from each array Let s iterate over which prefix we take from the first array For it we can uniquely find the second prefix we remove applications until the sum exceeds If we now increase the first prefix by taking a new application then we don t need to take any applications in the second array This means that when the first prefix is increased the second one can only decrease To solve the problem you can use the two pointer method 
215,You are given a pair of integers and an integer You can change the pair in two different ways set assign set assign where is the absolute difference between and The pair is called magic if is obtainable either as or as using only the given operations i e the pair is magic if or after some number of operations applied You can apply the operations any number of times even zero Your task is to find out if the pair is magic or not You have to answer independent test cases ,This problem has a GCD based solution Firstly lets try to solve it naively Always suppose that If this is not true let s swap and Firstly if let s do Okay now let s subtract from until again and repeat this algorithm till or If after some step we get or we are done and the answer is If or and we didn t get then the answer is Okay we can see that we always subtract the minimum possible from and trying to maintain this condition It can be proven that this algorithm yields all possible integers that are obtainable by any sequence of the operations from the problem statement either in or in Now we have to speed up this solution somehow Obviously most operations are redundant for us in this particular problem The first thing is that we can skip all operations till becomes greater than The number of such operations is And the second thing is that we can skip all operations till we get in The number of such operations is For simplicity this part can be also written as This doesn t affect the time complexity much but the formula for the final number of operations we can skip will be simpler This number equals in fact we take the minimum between two values written above because we don t want to skip any of these two cases So we can transform the pair to the pair and continue this algorithm There are also simpler approaches using the same idea but in a cooler way Time complexity per test case ,In this problem we need to find and such that and Since and are positive and are also positive Hence Therefore the number can be iterated from to Since in all tests then For each you can find by the formula This is a positive number It remains to check that is an integer 
216,Berland crossword is a puzzle that is solved on a square grid with rows and columns Initially all the cells are white To solve the puzzle one has to color some cells on the border of the grid black in such a way that exactly cells in the top row are black exactly cells in the rightmost column are black exactly cells in the bottom row are black exactly cells in the leftmost column are black Note that you can color zero cells black and leave every cell white Your task is to check if there exists a solution to the given puzzle ,Consider some corner of the picture If it s colored black then it contributes to counts to both of the adjacent sides Otherwise it contributes to none All the remaining cells can contribute only to the side they are on There are of such cells on each side So let s try all options of coloring the corners After fixing the colors of the corners we can calculate the number of cells that have to be colored on each side That is calculated by taking the initial requirement and subtracting the adjacent colored corners from it If any of the numbers is below or above then that corner coloring doesn t work Otherwise you can always color the cells in some way Overall complexity per testcase ,There are many ways to solve the problem One way is to look for the following pattern There can only be one such pattern if there is one bishop and it s not on the edge of the board We can iterate through all cells and see if we can match this pattern and if we can we output the centre cell You can also look at the positions of the two diagonals and intersect them but it requires more implementation Time complexity per testcase 
217,Monocarp is playing chess on one popular website He has opponents he can play with The th opponent has rating equal to Monocarp s initial rating is Monocarp wants to raise his rating to the value When Monocarp is playing against one of the opponents he will win if his rating is bigger or equal to the opponent s rating If Monocarp wins his rating is increased by otherwise it is decreased by The rating of his opponent does not change Monocarp wants to gain rating playing as few games as possible But he can t just grind it playing against weak opponents The website has a rule that you should play against all opponents as evenly as possible Speaking formally if Monocarp wants to play against an opponent there should be no other opponent such that Monocarp has played more games against than against Calculate the minimum possible number of games Monocarp needs to gain rating or say it s impossible Note that ratings of Monocarp s opponents change while Monocarp s rating does change ,After parsing the statement you can understand that Monocarp plays cyclically in one cycle he chooses some order of opponents and play with them in that order Then repeats again and again until he gains desired rating at some moment So firstly let s prove that in one cycle it s optimal to play against opponents in Suppose you play with opponents in some order and there is a position where if you swap and you won t lose anything and may even gain extra wins It means that the total gain after playing one cycle in increasing order in greater or equal than playing in any other order In other words we can sort array and play against them cyclically in that order Monocarp s list of games will look like several full cycles and some prefix The problem is that there can be many cycles and we need to skip them in a fast way How one cycle looks Monocarp starts with some wins first games and then loses all other games games where The maximum rating he gains is and the resulting rating after all games is We can already find several conditions of leaving a cycle if then Monocarp gets what he wants and stops otherwise if or he will never gain the desired rating since in the next cycle the number of wins since his starting rating Otherwise if and he will start one more cycle with rating and will gain the desired rating eventually So how to find the number of games he will win for a starting rating Let s calculate two values for a given sorted skill array for each let s calculate the minimum rating Monocarp need to win opponent and all opponent before and the rating he ll get after winning the th opponent We can calculate these values in one iteration we ll use indexation then for each if then and otherwise and Now knowing values it s easy to find the number of wins for a starting rating is equal to minimum such that don t forget indexation Or the first position in array with value strictly greater than We can search it with standard function since array is sorted Okay we found the number of wins for the current Let s just calculate how many cycles Monocarp will make with exactly wins There are only two conditions that should be met in order to break this cycle either Monocarp reaches rating it can be written as inequality or the number of wins increases starting rating becomes greater or equal than i e From the first inequality we get minimum and from the second one As a result we can claim that Monocarp will repeat the current cycle exactly times and either finish in the next turn or the number of wins will change So we can skip these equal cycles we can increase answer by and current rating by Since we skip equal cycles then at each step we either finish with success or or the number of wins increases Since is bounded by we will make no more than skips and total complexity is because of initial sorting and calls of ,Firstly let s prove that the order of characters in s is interchangeable Suppose we have a tournament of four teams with skills a b c and d such that a b c d and this tournament has the form 01 or 10 It s easy to see that a and d cannot be winners since a will be eliminated in the round with type 1 and d will be eliminated in the round with type 0 However it s easy to show that both with s 10 and with s 01 b and c can be winners Using this argument to matches that go during phases i and i 1 a group of two matches during phase i and a match during phase i 1 between the winners of those matches can be considered a tournament with n 2 we can show that swapping s i and s i 1 does not affect the possible winners of the tournament So suppose all phases of type 1 happen before phases of type 0 there are x phases of type 1 and y phases of type 0 x y n 2 x y 2 y teams will be eliminated in the first part phases of type 1 and the team with the lowest skill that wasn t eliminated in the first half will win the second half It s easy to see that the teams with skills 1 2 x 1 cannot pass through the first part of the tournament since to pass the first part a team has to be the strongest in its subtree of size 2 x Furthermore since the minimum of 2 y teams passing through the first half wins the winner should have skill not greater than 2 x y 2 y 1 the winner should have lower skill than at least 2 y 1 teams so teams with skills higher than 2 x y 2 y 1 cannot win Okay now all possible winners belong to the segment 2 x 2 n 2 y 1 Let s show that any integer from this segment can be winning Suppose k in 2 x 2 n 2 y 1 let s construct the tournament in such a way that only team with skill k and 2 y 1 teams with the highest skill pass through the first part of the tournament obviously then team k wins There are 2 y independent tournaments of size 2 x in the first part let s assign teams with skills from 1 to 2 x 1 and also the team k to one of those tournaments for all other 2 y 1 tournaments let s assign the teams in such a way that exactly one team from the 2 y 1 highest ones competes in each of them It s easy to see that the team k will win its tournament and every team from the 2 y 1 highest ones will win its tournament as well so the second half will contain only teams with skills k and 2 n 2 y 2 2 n and obviously k will be the winner of this tournament So the answer to the problem is the segment of integers 2 x 2 n 2 y 1 
218,There are two water tanks the first one fits liters of water the second one fits liters of water The first tank has liters of water initially the second tank has liters of water initially You want to perform operations on them The th operation is specified by a single non zero integer If then you try to pour liters of water from the first tank into the second one If you try to pour liters of water from the second tank to the first one When you try to pour liters of water from the tank that has liters currently available to the tank that can fit more liters of water the operation only moves liters of water For all pairs of the initial volumes of water such that and calculate the volume of water in the first tank after all operations are performed ,Consider a naive solution Iterate over all pairs and apply all operations The complexity is The constraints obviously imply that it s too much What can we cut from it Well surely will still remain there Both of and also should So we can probably only hope to turn this into Let s try that Notice that no matter what operations are applied never changes You can also peek at the examples and see that the patterns are suspiciously diagonal shaped in the matrix Let s try to solve the problem by fixing and calculating the answer for all values of I will call the fixed variable Consider case where and Here all can fit into both and so we can avoid caring about one restriction on the operations We ll think what to do with large volumes later If there are no operations the answer for each initial is for all from to Now consider an operation for some For nothing changes Actually for all the result of the operation is the same as for Hmm but if the result is the same it will remain the same until the end Same from the other side The answers for and also get merged together To me it kind of looks like a primitive form of DSU on these volume states you merge some prefix of the answers together and merge some suffix of the answers together If the state was merged to either or then it s easy to calculate the actual answer for that state What happens to the remaining states Well since they weren t merged anywhere the operation for them was applied fully if was requested all was poured How to deal with multiple operations then I propose the following idea When applying an operation we only want to know which of the previously non merged states become merged Basically we can squish all previous operations into one just sum up the signed amounts of water Since they all were applied fully to the non merged states it s completely valid After the squish check for the new merges You can actually study the structure of the answers and see that they go like that for some values of and such that It isn t that important but it makes the code easier You can basically calculate the length of the merged prefix the length of the merged suffix then calculate the answer at the end of the prefix in and restore all answers from it We neglected larger values of earlier time to return to them Another kind of limit to each operation is added when extra water doesn t fit in another tank Well it doesn t change that much It only makes more prefix suffix merges To come up with the exact formulas I followed these points Something merges on an operation when any of these holds not enough water in the first tank not enough space in the second tank not enough water in the second tank not enough space in the first tank Replace all with and you get the constraints for prefix and suffix merges Overall complexity ,This is just an implementation problem and it can be solved in time but we didn t ask for such solutions so you could solve it in or maybe even in I ll describe solution anyway Firstly we need to maintain several variables initially the number of moves passed the position of the leftmost remaining candy initially the position of the rightmost remaining candy initially the sum of candies eaten by Alice initially the sum of candied eaten by Bob initially the sum of candies eaten by Alice during her last move initially and the sum of candies eaten by Bob during his last move initially So let s just simulate the following process while if the number of moves is even then now is Alice s move and we need to maintain the sum of candies Alice eats during this move How to calculate it While and let s eat the leftmost candy so variables will change like this After all let s add to replace with assign and increase by If the number of moves is odd then the process is the same but from the Bob s side I ll also add a simply implemented solution written by Gassa below 
219,You are playing a computer game In this game you have to fight monsters To defend from monsters you need a shield Each shield has two parameters its current durability and its defence rating Each monster has only one parameter its strength When you fight a monster with strength while having a shield with current durability and defence there are three possible outcomes if then you receive damage if and you receive no damage but the current durability of the shield decreases by if and nothing happens The th monster has strength and you will fight each of the monsters exactly once in some random order all orders are equiprobable You have to consider different shields the th shield has initial durability and defence rating For each shield calculate the expected amount of damage you will receive if you take this shield and fight the given monsters in random order ,First of all let s find a solution in We will use the lineriality of expectation the answer for some shield is equal to where is the probability that the monster will deal damage if we use the th shield Let s see how to calculate Consider a monster such that To deal damage he should be preceded by at least other monsters having We can write a complicated formula with binomial coefficients to calculate the probability of this happening and then simplify it but a much easier solution is to consider the order of these strong monsters Suppose there are of them then there are strong monsters that will deal damage Since all orderings are equiprobable the probability that our fixed monster will deal damage is since it is the probability that it will take one of the last places in the order Okay what about weak monsters It turns out that we can use the same approach to deal damage a weak monster should be preceded by at least strong monsters Consider the relative order of strong monsters and that weak monster we are analyzing There are positions where the weak monster will deal damage so the probability of weak monster dealing damage is Okay we got a solution in How to make it faster Whenever we consider a shield all monsters are split into two types strong and weak and we may sort the monsters beforehand so the number of strong monsters and their total strength can be found with binary search Since the probabilities for all strong monsters are the same we can multiply their total strength by the probability that one fixed strong monster will deal damage we already described how to calculate it The same applies for the weak monsters so the total complexity is ,Let s calculate the minimum number of secret technique uses we need to kill each of the monsters Let the current monster has hp Firstly it is obvious that we can take modulo except one case If it becomes zero let s rollback it by one pair of turns Then the number of uses of the secret technique we need is Let s sort all monsters by this value and take the cheapest set of monsters prefix of the sorted array with the sum of values less than or equal to Time complexity 
220,You are given three positive integers and You have to construct a string of length consisting of lowercase Latin letters such that of length has distinct letters It is guaranteed that the answer exists You have to answer independent test cases Recall that the substring is the string and its length is In this problem you are only interested in substrings of length ,If we represent letters with digits then the answer can be represented as There is no substring containing more than distinct characters and each substring of length contains exactly distinct characters because of the condition Time complexity ,Note that in the beautiful string s i neq s i 1 because it is a palindrome of length 2 and s i neq s i 2 because it is a palindrome of length 3 This means s i s i 3 i e a beautiful string has the form up to the permutation of the letters and For each permutation of the letters and we will construct a string t of the form of length n Let s define an array a of length n as follows a i 0 if s i t i i e the character at the i th position does not need to be changed and a i 1 otherwise Let s build an array pr of prefix sums of the array a Now you can process a query of the number of positions that need to be replaced for the current line t in O 1 
221,You are given strings all of them have the same length The strings consist of lowercase English letters Find any string of length such that each of the given strings differs from in at most one position Formally for each given string there is no more than one position such that Note that the desired string may be equal to one of the given strings or it may differ from all the given strings For example if you have the strings and then the answer to the problem might be the string which differs from the first only by the last character and from the second only by the first ,Consider all strings that differ from the first one in no more than one position this is either the first string or the first string with one character changed We will go through all such strings and see if they can be the answer To do this go through all the strings and calculate the number of positions where they differ ,The answer is when in string there is a character that is not in string Otherwise let s precalculate the following array minimum index from to such that if there is no such index then Now we can solve this problem by simple greed Presume that now and last taken symbol in is Then there are two options if then if then and is equal to initially 
222,Polycarp was dismantling his attic and found an old floppy drive on it A round disc was inserted into the drive with integers written on it Polycarp wrote the numbers from the disk into the array It turned out that the drive works according to the following algorithm the drive takes one positive number as input and puts a pointer to the first element of the array after that the drive starts rotating the disk every second moving the pointer to the next element counting the sum of all the elements that have been under the pointer Since the disk is round in the array the last element is again followed by the first one as soon as the sum is at least the drive will shut down Polycarp wants to learn more about the operation of the drive but he has absolutely no free time So he asked you questions To answer the th of them you need to find how many seconds the drive will work if you give it as input Please note that in some cases the drive can work infinitely For example if and then the answers to the questions are as follows the answer to the first query is because the drive initially points to the first item and the initial sum is the answer to the second query is the drive will spin the disk completely twice and the amount becomes the answer to the third query is the amount is ,Let s denote for the sum of all the elements of the array and for the array of its prefix sums If the drive runs for seconds the sum is This formula immediately shows that if and then the disk will run indefinitely Otherwise the answer exists The disk cannot make less than full spins otherwise the required amount simply will not be achived The disk can t make more spins either because when it reaches the position of the maximum prefix sum will already be achived So we know how to determine the number of full spins of the disk Let s make these spins Now we have a new problem given find the first position in the array such that This problem can be solved using binary search If is not sorted into the array that is there is such that then can simply be thrown out of the array the answer will never be reached on it ,Let be the number such that after some sequence of moves there will be at least elements in the array We can see that there is always possible candidates because all values are among all possible values of for some from to So we need to check each candidate separately and try to update the answer with it How to do this Let the current number we trying to obtain is Then let s iterate over all in any order Let be the current value of Let s divide it by while its value is greater than and carry the number of divisions we made If after all divisions then let s remember the value of in some array If after iterating over all elements of the size of is greater than or equal to then let s sort it and update the answer with the sum of smallest values of Time complexity or depends on sorting method 
223,You are given two integers and You have a chessboard of size with the top left cell at the cell is painted Your task is to find a connected component on this chessboard that contains exactly black cells and exactly white cells Two cells are called connected if they share a side i e for the cell there are at most four connected cells A set of cells is called a connected component if for every pair of cells and from this set there exists a sequence of cells such that all from to are belong to this set of cells and for every cells and are connected Obviously it can be impossible to find such component In this case print Otherwise print and suitable connected component You have to answer independent queries ,I ll consider the case when the other case is symmetric and the answer I construct is the same but shifted by to the right Consider the given field as a matrix where is the number of row and is the number of column Firstly let s build the line of length from the cell to the cell Then will decrease by and will become Then we have two black cells to the left and to the right and and black cells to the up all cells for all from to and black cells to the down all cells for all from to Let s add the required number of cells to the answer If even after adding all these cells still be greater than then the answer is maybe there will be a proof why it is so but you can read it already from other participants Otherwise the answer is and we constructed the required component ,It is clear that the order of operations does not affect the final result also it makes no sense to apply the same operation more than once by the property of the operation Let s construct a sequence of operations that will reduce the matrix to the matrix if the answer exists Let s try iterate over will we use the operation horizontal Now by the each element of the first line we can understand whether it is necessary to apply the operation vertical if Let s apply all necessary operations vertical It remains clear whether it is necessary to apply the operation horizontal for Let s look at each element of the first column by it you can understand whether it is necessary to apply the operation horizontal if 
224,Alice and Bob are playing a game They have a tree consisting of vertices Initially Bob has chips the th chip is located in the vertex all these vertices are unique Before the game starts Alice will place a chip into one of the vertices of the tree The game consists of turns Each turn the following events happen sequentially exactly in the following order Alice either moves her chip to an adjacent vertex or doesn t move it for each Bob s chip he either moves it to an adjacent vertex or doesn t move it Note that this choice is done independently for each chip The game ends when Alice s chip shares the same vertex with one or multiple of Bob s chips Note that Bob s chips may share the same vertex even though they are in different vertices at the beginning of the game Alice wants to maximize the number of turns Bob wants to minimize it If the game ends in the middle of some turn Alice moves her chip to a vertex that contains one or multiple Bob s chips this turn is counted For each vertex calculate the number of turns the game will last if Alice places her chip in that vertex ,This task was inspired by an older edu task and another task proposed by RockyB Let s learn to solve the problem for at least one starting vertex for Alice Let this vertex be In general Alice s strategy is basically this run to some vertex as fast as possible and stay in it until Bob reaches Hesitation on a way to this vertex won t be optimal Visiting the same vertex multiple times won t as well I guess that can be proven more formally by analyzing the set of possible solutions after each move What properties should vertex have for Alice to be able to escape to it There shouldn t be a way for Bob to catch her midway However it s not necessary to check any midway intersections If Bob can catch her anywhere on a path she can also follow her to the end by moving the same path and catch her at the destination Thus this vertex should be further from any Bob s chips than from So you can precalculate the distance to the closest Bob s chip to each vertex Just push all chips to a queue and run a bfs We ve learned to solve the problem in for each vertex Just iterate over all vertices and take the maximum of over such of them that have greater than the distance from to Now the solution can go two ways You can stop thinking here and obtain an one or think more and get an The first one goes like that Notice that the function if the Alice can make at least moves from vertex is monotonous in regard to So we can binary search the answer The check query transforms to the following Consider all vertices with distance less or equal to from There should exist at least one vertex with value for the check to return true So at least the maximum value of them should be greater than That is basically a centroid exercise Let each centroid store such an array that is the maximum value of over all such that belong to this centroid s subgraph and are no further than distance from the centroid That array can be constructed in for all centroids in total You can easily see that the length of this array doesn t exceed the number of vertices in the subgraph of the corresponding centroid that is be definition For the query iterate over all centroids belongs to and check the value from some cell of each one s array For the second solution let s reverse the problem Consider the vertex Alice escapes to If there is a starting vertex no further than from it then the answer for can be updated with So we can update the subgraph of vertices with distance no more than with the maximum of their current answer and The solution will be almost the same centroid Iterate over all centroids belongs to and write into the cell of each one s array where is the distance from to this centroid Then build an array of prefix maximums over this array Finally for each collect the best answer over all centroids belongs to Overall complexity or ,Obviously you can always obtain the optimal answer without using west or south moves So the shortest path consists of east moves and north moves Let s estimate the lower bound of the answer Take a look at these constructions and let question mark be any command different from the used one That s the tightest you can put east or north moves in So the answer is at least For you can put them just as in the construction and fill the rest of question marks with a stay in place move case works differently though You can do it only in moves by taking alternating moves Overall complexity per testcase 
225,Petya recieved a gift of a string with length up to characters for his birthday He took two more empty strings and and decided to play a game This game has two possible moves Extract the character of and append with this character Extract the character of and append with this character Petya wants to get strings and empty and string lexicographically minimal You should write a program that will help Petya win the game ,On every step you should maintain minimal alphabetic letter in current string this can be done by keeping array of 26 cells with number of times each letter appear in string nd updating it on every step Let s call string a stack and use its terms Now you extract letters from one by one Put the letter to the top of the stack Pop letters from the top of stack and push them to answer while they are less or equal than any letter left in string After string becomes empty push all the letters from stack to answer The answer will be lexicographically minimal It is obvious if we consider the case when current top of stack is strictly greater than any character from the remaining string or there is a character in that is strictly less than current top If current top is equal to some character then appending answer with the letter from top won t make answer worse Overall complexity where is the length of the alpabet in our case ,This problem has a simple solution described by participants in the comments My solution is a little harder Let s solve it using dynamic programming Let be the smallest amount of time needed to get letters a Let s consider transitions the transition for adding one letter a can be simply done Let s process transitions for multiplying by two and subtraction by one simultaneously let s decrease the number times by one right after getting it Easy to see that such updates never include each other so we can store them in queue by adding the new update at the tail of the queue and taking the best update from the head The solution is hard to describe but it is very simple in the code so please check it to understand the idea 
226,Berland annual chess tournament is coming Organizers have gathered chess players who should be divided into two teams with people each The first team is sponsored by BerOil and the second team is sponsored by BerMobile Obviously organizers should guarantee the win for the team of BerOil Thus organizers should divide all players into two teams with people each in such a way that the first team always wins Every chess player has its rating It is known that chess player with the greater rating always wins the player with the lower rating If their ratings are equal then any of the players can win After teams assignment there will come a drawing to form pairs of opponents in each pair there is a player from the first team and a player from the second team Every chess player should be in exactly one pair Every pair plays once The drawing is totally random Is it possible to divide all players into two teams with people each so that the player from the first team in every pair wins of the results of the drawing ,Let s sort the input array in non decreasing order Now we should take the first players to the first team and the last players to the second team That will guarantee that every member of the first team has greater or equal rating than every member of the second team Now the only thing left is to check if all ratings in the first teams differ from all the ratings in the second team if some are equal then in sorted order ,Note that if Bob has increased some element then Alice can t remove it on the next stages Obviously it is more profitable for Bob to prohibit the smallest element of the array Using this fact we can iterate over the value of and then simulate the game process To simulate the game we can maintain the set of elements that Alice can remove On the th stage Alice removes the maximum element such that if there are no such elements then Alice lost Bob always removes the minimum element of the set Thus the complexity of the solution is for each test case There is another possible solution we can notice that if Alice wins Bob will prohibit the elements on positions of the sorted array So Alice has to delete the next elements So if the segment of the sorted array can be deleted by Alice during the game phases she wins with this value of 
227,Couple Cover a wildly popular luck based game is about to begin Two players must work together to construct a rectangle A bag with balls each with an integer written on it is placed on the table The first player reaches in and grabs a ball randomly all balls have equal probability of being chosen the number written on this ball is the rectangle s width in meters This ball is not returned to the bag and the second player reaches into the bag and grabs another ball the number written on this ball is the rectangle s height in meters If the area of the rectangle is greater than or equal some threshold square meters the players win Otherwise they lose The organizers of the game are trying to select an appropriate value for so that the probability of a couple winning is not too high and not too low but they are slow at counting so they have hired you to answer some questions for them You are given a list of the numbers written on the balls the organizers would like to know how many winning pairs of balls exist for different values of Note that two pairs are different if either the first or the second ball is different between the two in pair and two different balls with the same number are considered different ,Let s count the number of pairs with multiple less than To get the number of not less pairs we should sumply subtract from the number of less pairs Let be the number of values in equal to and be the number of pairs from with the multiple equal to To calculate the values from we can use something like Eratosthenes sieve let s iterate over the first multiplier and the multiple of it and increment by the value After calculating the array we should calculate the array of its partial sums and find the number of less pairs in time ,Let s look at a group of it s easy to see that each such a group is equal to the same number Now let s look at how these groups are distributed on the circle If there are no then all are just equal to each other It s okay If there is exactly one then from one side all of them are still in one group so they should be equal but from the other side one pair should have different values It s contradiction If there are more than one then all numbers are divided in several groups with different values It s okay As a result array exists as long as the number of isn t 
228,A frog is currently at the point on a coordinate axis It jumps by the following algorithm the first jump is units to the right the second jump is units to the left the third jump is units to the right the fourth jump is units to the left and so on Formally if the frog has jumped an even number of times before the current jump it jumps from its current position to position otherwise it jumps from its current position to position Your task is to calculate the position of the frog after jumps But One more thing You are watching different frogs so you have to answer independent queries ,With each pair of jumps of kind to the right to the left the frog jumps So the answer is almost Almost because there can be one more jump to the right So if is odd then we have to add to the answer ,To solve the hard version let s modify the simple version solution Note that the parameter can be discarded since we only need paths of maximum length on each prefix Now as we denote a pair of the number of maximum paths and the number of blocks in them For the position we will find the position closest to the left from which we can start a block and so we will find out what is the maximum for We will update until the maximum of the position being sorted is suitable for us 
229,Consider all binary strings of length A binary string is a string that consists of the characters and only For example is a binary string and is not Obviously there are exactly such strings in total The string is lexicographically smaller than the string both have the same length if in the first position from the left in which they differ we have This is exactly the way strings are compared in dictionaries and in most modern programming languages when comparing them in a standard way For example the string is lexicographically smaller than the string because the first two characters are the same and the third character in the first string is less than that in the second We remove from this set binary strings each of length Thus the set will have strings Sort all strings of the resulting set in lexicographical ascending order as in the dictionary We number all the strings after sorting from to Print the string whose index is such an element is called where is the rounding of the number down to the nearest integer For example if and then after removing the strings and sorting the result will take the form Thus the desired median is ,If we did not delete the strings then the median would be equal to the binary notation of After deleting strings the median cannot change numerically by more than Let s start with the median and each time decrease it by one if there are fewer not deleted smaller numbers than not deleted large numbers Similarly you need to increase the median by one otherwise The algorithm stops when the result is the median of the current set All these steps will run at most times ,Let s see the representation of in the ternary numeral system If it has no twos then the answer is Otherwise let be the maximum position of in the ternary representation Then we obviously need to replace it with and add some power of three to the right from it Let be the leftmost position of to the right from We can add and replace all digits from the position to the position with Then the resulting number will be because we replaced all twos with zeros and the minimum because in fact we added only one power of three and this power is the minimum one we could add Time complexity is per query 
230,You have a long fence which consists of sections Unfortunately it is not painted so you decided to hire painters to paint it th painter will paint all sections such that Unfortunately you are on a tight budget so you may hire only painters Obviously only painters you hire will do their work You want to maximize the number of painted sections if you choose painters optimally A section is considered painted if at least one painter paints it ,Let be the number of painters that are painting the th section Let s fix the first painter denote his index as we won t take and decrease the numbers of array in the range which he paints Then we may new array such that is equal to if and only if and otherwise This array corresponds to segments that are painted by only one painter After that we build prefix sum array on array This should be done in Now for each remaining painter we can count the number of sections that are painted only by him For painter it will be equal to Let s denote it as Finally find an painter with the minimum value of denote it as The answer if we choose painter as one of two that won t be hired will be equal to where is the number of elements greater than in the array after removing the painter And of course we should do the same for all painters ,To begin with we will learn how to find the optimal place for the exam that we want to move Let s imagine that it is not in the schedule in this case we have two options Put the exam at the end of the session so that there are days before it Put it in the middle of the largest break between exams let its length be so that between it and the nearest one there is because this is no worse than putting it in any part of any other break That is the answer for such an arrangement is the minimum of the larger of these options and the minimum break in schedule without the moved exam Now note that the minimum break in most variants is the same minimum in the initial schedule So in order to reduce you need to move exactly one of the two exams that form it and you need to check which of the two options is better 
231,A positive number of length in base is written on the blackboard The number is given as a sequence the digits of in order from left to right most significant to least significant Dmitry is very fond of all the digits of this number system so he wants to see each of them at least once In one operation he can take any number written on the board increase it by and write the new value on the board For example and Initially the board contains the digits and Dmitry increases the number by and writes down the number On the board there are digits Dmitry increases the number by and writes down the number Now the board contains all the digits from to Your task is to determine the minimum number of operations required to make all the digits from to appear on the board at least once ,If all digits from to are initially present in the number then the answer is Each time we will increase the number by If the last digit is less than then only it will change Otherwise all digits equal to at the end will become equal to and the previous one will increase by or a new digit equal to will be added if all digits were equal to For a operation the last digit will run through all possible values However we can get all the numbers earlier We will solve the problem using binary search sorting through the number of operations We can have 2 options whether was at the end or not Depending on this one or two subsegments of the segment a subsegment in the middle or a prefix and a suffix remained uncovered by the last digit of the number They need to be completely covered with numbers that were already in positions except for the last one these are the original numbers and in case there was at the end the number into which the transfer was made There are at most of them ,Since we just want to make two numbers such that the first number is smaller than the second our best bet is to use only the first digit for the first number and the rest of the digits for the second number Note that since the numbers can have up to 300 digits we shouldn t actually evaluate the second number Instead since the digits only include 1 through 9 we can handle that case by checking the number of digits Code 49002957 
232,You are given a string of length consisting only of lowercase Latin letters A substring of a string is a contiguous subsequence of that string So string is substring of string but string is not Your task is to calculate the number of ways to remove one substring from this string in such a way that remaining characters are the number of distinct characters either zero or one It is guaranteed that there is different characters in Note that you remove the whole string and it is correct Also note that you should Since the answer can be rather large not very large though print it modulo ,Firstly let s calculate the length of the prefix of equal letters let it be and the length of the suffix of equal letters let it be It can be done with two cycles with breaks It is obvious that this prefix and suffix wouldn t overlap Then let s consider two cases the first one is when and the second one is when In the first case we can only remain either prefix or suffix of consisting only of equal letters Then the answer is because we can remain from to letters on the prefix from to on the suffix or empty string In the second case we can remain from to letters on the prefix and from to letters on the suffix But now because we can combine these ways so the answer is And the bonus this case is not belong to the given problem if all letters in the string are equal then then answer is because we can choose any substring of of length at least and any substring of length ,In this problem we can just iterate over all possible substrings and try to remove each of them After removing the substring we can check if remains the subsequence of in linear time Let we remove the substring Let s maintain a pointer the initial value of the pointer is and iterate over all possible from to If and let s increase by one If after all iterations then let s update the answer with the length of the current substring 
233,You are given an undirected unweighted tree consisting of vertices An undirected tree is a connected undirected graph with edges Your task is to choose two pairs of vertices of this tree all the chosen vertices and in such a way that neither nor belong to the simple path from to and vice versa neither nor should not belong to the simple path from to Among all possible ways to choose such pairs you have to choose one with the between paths from to and from to And among all such pairs you have to choose one with the of these two paths The length of the path is the number of edges in it The simple path is the path that visits each vertex at most once ,Firstly let s call a path from to if is a leaf is a vertex of degree at least the number of their neighbors is at least and there are no other vertices of degree at least on this path expect the vertex The first step of the solution is to remove all the paths from to but we should not remove the vertex and remember for each vertex the sum of two maximum lengths of paths which end in the vertex Let this value for the vertex be For example if for some vertex there are good paths with end in it of lengths and correspondingly then will be Okay it is easy to see that the maximum intersection of two paths in the answer will be equal to the length of the diameter of the obtained tree But we can not take diameter of this tree and call it the answer because of the second constraint we need to find some diameter from to such that the sum is maximum possible How do we do that There is such an awesome and well known fact that the center of a tree belongs to all diameters of this tree Let s root the tree by the center of a tree if the length of the diameter is odd the center of a tree is an edge then let s root the tree by any end of this edge it does not matter There is one case when the length of the diameter is but it is pretty trivial to handle it Now our problem is to find two neighbors of the root of the new tree such that in their subtrees are vertices which form some diameter of this tree and the sum of values of these vertices is maximum possible Let s calculate the vertex with the maximum distance from a root and with the maximum possible for equals distances by simple for each neighbor of a root It can be done in and the last part is to find two maximums of this list it also can be done in or depends on implementation ,The first idea is the following it is always profitable to add the edges from the vertex to any other vertex The proof is the following if we will add two edges and then the distance to the vertex will be the distance to the vertex will be But we can add edges and and this will be better in fact you cannot obtain the less answer by adding two edges in the other way The main idea is the following Let s carry all vertices of the tree with the distance more than in the set Let the vertex with the maximum distance be What we will obtain if we will add the edge The distance to the vertex will be and the distance to the vertex where is the parent of the vertex if we will root the tree by the vertex will be So we will make reachable at most two vertices if the vertex is already reachable then it will be not counted in the answer Now what we will obtain if we will add the edge We will make reachable all the vertices adjacent to the vertex and the vertex the number of such vertices is not less than so this move won t make the answer greater instead of any other way to add the edge After adding such edge let s remove the vertex and all vertices adjacent to it from the set We need to repeat this algorithm until the set will not become empty Time complexity is I sure that there exists the solution with the dynamic programming in the linear time I will be very happy if someone will explain it to other participants 
234,You are given a string of length Each character is one of the first lowercase Latin letters You are also given a matrix with binary values of size This matrix is symmetric means that the string can have the th and th letters of Latin alphabet adjacent Let s call the string if in it can be adjacent have 1 in the corresponding cell of matrix You are allowed to do the following move Choose any letter remove and join the remaining parts of the string without changing their order For example removing letter a from abacaba will yield bcb The string you are given is The string should remain You are allowed to do arbitrary number of moves possible zero What is the shortest resulting string you can obtain ,Each state of the string can be denoted as the set of characters we deleted from it and each such set can be represented as a bit binary mask where th bit is equal to if th character of the alphabet is already deleted and otherwise Let s call a mask if the string formed by this mask is not crisp Let s also say that a pair of characters forbids mask if is a pair of characters that should not be adjacent but they are adjacent in the string formed by mask If we somehow find all bad masks then the solution would be writing simple bitmask dp to find the best mask that is not bad and reachable from the initial mask the one having all bits set to So let s focus on finding all bad masks Obviously if some pair of characters forbids a mask then it s bad and vice versa Let s pick some pair of characters and find all masks forbidden by it we will do the same for every pair of characters that cannot be adjacent Let s check every occurence of in the initial string For each occurence we will find the closest occurence of to the right of it If there s no any or if there s another between them let s ignore the occurence of we have chosen and move to the next one Otherwise let s find all characters that occur at least once between the fixed occurences of and If all those characters are deleted then these occurences of and will be adjacent so pair forbids any mask that has bits representing and set to bits representing every character occuring in between to and all other bits to any values Let s mark all these masks as forbidden as follows we will write a recursive function that marks mask and every its submask that has bits and set to as forbidden This function should check if is not forbidden if not then mark it as forbidden iterate on the bit we may remove from and call recursively but only if is set to in mask and if and If we implement it in such a way then for each pair it will take operations to mark all masks forbidden by this pair of characters so overall complexity will be or depending on your implementation ,Let s turn the problem around we ll look for the longest suffix that will make Polycarp happy since it s the same thing Let s create an array in which we will mark the numbers already encountered Let s go along from right to left and check if does not occur to the right in this case it is marked in if it occurs to the right then removing any prefix that does not include we get an array where occurs twice so we have to delete prefix of length 
235,Now Dmitry has a session and he has to pass exams The session starts on day and lasts days The th exam will take place on the day of all are different For the session schedule Dmitry considers a special value the smallest of the rest times before the exam for all exams For example for the image above In other words for the schedule he counts exactly numbers how many days he rests between the exam and for between the start of the session and the exam Then it finds the minimum among these numbers Dmitry believes that he can improve the schedule of the session He may ask to change the date of one exam change one arbitrary value of Help him change the date so that all remain different and the value of is as large as possible For example for the schedule above it is most advantageous for Dmitry to move the second exam to the very end of the session The new schedule will take the form Dmitry can leave the proposed schedule unchanged if there is no way to move one exam so that it will lead to an improvement in the situation ,To begin with we will learn how to find the optimal place for the exam that we want to move Let s imagine that it is not in the schedule in this case we have two options Put the exam at the end of the session so that there are days before it Put it in the middle of the largest break between exams let its length be so that between it and the nearest one there is because this is no worse than putting it in any part of any other break That is the answer for such an arrangement is the minimum of the larger of these options and the minimum break in schedule without the moved exam Now note that the minimum break in most variants is the same minimum in the initial schedule So in order to reduce you need to move exactly one of the two exams that form it and you need to check which of the two options is better ,This is just an implementation problem Firstly let s fix it can be in range find the maximum number of boats we can obtain with this and choose the maximum among all found values To find the number of pairs let s iterate over the smallest weight in the team in range Let this weight be Then because the sum of weights is the biggest weight is And the number of pairs we can obtain with such two weights and the total weight is where is the number of occurrences of in And the additional case if is even we need to add Don t forget that there is a case so you need to assume that these values are zeros 
236,You are a coach at your local university There are students under your supervision the programming skill of the th student is You have to create a team for a new programming competition As you know the more students some team has the more probable its victory is So you have to create a team with the maximum number of students But you also know that a team should be It means that the programming skill of each pair of students in a created team should differ by no more than Your task is to report the maximum possible number of students in a team ,Let s sort all values in non decreasing order Then we can use two pointers to calculate for each student the maximum number of students such that This is pretty standard approach We also can use binary search to do it or we can store for each programming skill the number of students with this skill and just iterate from some skill to and sum up all numbers of students ,To solve the problem we will use the dictionary Each station will be matched with a pair of integers the indices of its first and last entries in the route Then we will sequentially process queries If at least one of the stations or is missing in the dictionary the answer is Otherwise check If the index of the first entry of station in the route is strictly less than the index of the last entry of station in the route the answer is Otherwise the answer is 
237,The array is given Its element is called special if there exists a pair of indices and such that In other words an element is called special if it can be represented as the sum of of an array no matter if they are special or not Print the number of special elements of the given array For example if and then the answer is is a special element since is a special element since is a special element since is a special element since is a special element since Please note that some of the elements of the array may be equal if several elements are equal and special then all of them should be counted in the answer ,The intended solution for this problem uses time and memory Firstly let s calculate for each from to where is the number of occurrences of in This part can be done in Then let s iterate over all segments of of length at least maintaining the sum of the current segment We can notice that we don t need sums greater than because all elements do not exceed So if the current sum does not exceed then add to the answer and set to prevent counting the same elements several times This part can be done in ,The model solution is where but it seems that there are faster ones I ll explain the model solution nevertheless It s easy to see using simple Nim theory that the answer for a query is iff the xor of for all chips such that is equal to Let s calculate this xor for every query This number contains at most bits and we will process these bits differently we will choose some number and use one solution to calculate lowest bits and another solution to compute highest bits One idea is common in both solutions we split each query into two queries a query can be represented as a combination of two queries and where is the xor of all numbers such that After converting the queries for every store each query of the form in some sort of vector or any other data structure We will use an approach similar to sweep line iterate on and solve the queries for the current These ideas will be used both for the solution calculating lowest bits and for the solution calculating highest bits How to find lowest bits in each query Iterate on from to and maintain the number of occurrences of each number we met so far Then at a moment we want to calculate simply iterate on all of the values of and process each value in if the number of occurrences of some value is odd update the current answer to the query by xoring the number with otherwise just skip it And since we are interested only in lowest bits for each we need only the remainder so the number of different values is Thus this part of the solution runs in Okay what about highest bits in each query We can see that for every number the highest bits of don t change too often when we iterate on there will be about segments where the highest bits of have different values We can build a data structure that allows use to process two queries xor all numbers on a segment with some value and get the value in some position Fenwick trees and segment trees can do it Then we again iterate on from to When we want to process a number we find the segments where the highest bits of have the same value and perform updates on these segments in our data structure When we process a query of the form we simply get the value in the position from our data structure This part of the solution works in By choosing optimally we can combine these two parts into a solution with complexity of 
238,There are points on a coordinate axis The th point is located at the integer point and has a speed It is guaranteed that no two points occupy the same coordinate All points move with the constant speed the coordinate of the th point at the moment is calculated as Consider two points and Let be the minimum possible distance between these two points over any possible moments of time even It means that if two points and coincide at some moment the value will be Your task is to calculate the value the sum of minimum distances over all pairs of points ,Let s understand when two points and coincide Let Then they are coincide when Otherwise these two points will never coincide and the distance between them will only increase So we need to consider only the initial positions of points Let s sort all points by and consider them one by one from left to right Let the th point be the rightmost in the pair of points that we want to add to the answer We need to find the number of points such that and and the sum of for such points as well We can do this using two BITs Fenwick trees if we compress coordinates all values and do some kind of scanline by values Let the number of such points be and the sum of coordinates of such points be Then we can increase the answer by and add our current point to the Fenwick trees add to the position in the first tree and to the position in the second tree When we want to find the number of required points and the sum of its coordinates we just need to find the sum on the prefix two times in Fenwick trees Note that you can use any online logarithmic data structure you like in this solution such as treap and segment tree There is also another solution that uses pbds Let s do the same thing but there is one problem Such data structure does not have sum on prefix function so we have to replace it somehow To do this let s calculate only part when we go from left to right Then let s clear our structure go among all points again but from right to left and calculate the same thing but with the opposite sign find the number of points such that and When we go from right to left we need to decrease the answer by It is some kind of contribution to the sum technique Time complexity ,Firstly we obviously don t need coordinates at all because we can place both platforms at Let s sort all coordinates in non decreasing order Calculate for each point two values and where is the number of points to the left from the point including that are not further than from the th point i e the number of such points that And is the number of points to the right from the point including that are not further than from the th point Both these parts can be done in using two pointers Then let s build suffix maximum array on and prefix maximum array on For just iterate over all from to and do For just iterate over all from to and do The question is what What did we do We did the following thing the answer always can be represented as two non intersecting segments of length such that at least one endpoint of each segment is some input point Now let s fix this border between segments Iterate over all from to and update the answer with So we took segment that starts at some point to the left from including and goes to the left and took some segment that starts further than including and goes to the right With this model we considered all optimal answers that can exist Time complexity 
239,There is a special offer in Vasya s favourite supermarket if the customer buys chocolate bars he or she may take additional bars for free This special offer can be used any number of times Vasya currently has roubles and he wants to get as many chocolate bars for free Each chocolate bar costs roubles Help Vasya to calculate the maximum possible number of chocolate bars he can get ,Number of chocolate bars Vasya can buy without offer is Number of bundles with bars Then number of additional bars In result total number of bars is ,Let s fix number of plates to have pieces of the first cake plates left for the other cake Obviously the most optimal way to distribute pieces to plates will lead to the minimum of pieces on a plate Now try every possible and take maximum of Overall complexity 
240,You found a map of a weirdly shaped labyrinth The map is a grid consisting of rows and columns The rows of the grid are numbered from to from bottom to top The columns of the grid are numbered from to from left to right The labyrinth has layers The first layer is the bottom left corner cell The second layer consists of all cells that are in the grid and adjacent to the first layer by a side or a corner The third layer consists of all cells that are in the grid and adjacent to the second layer by a side or a corner And so on The labyrinth with layers for example is shaped as follows The layers are separated from one another with walls However there are doors in these walls Each layer except for layer has exactly two doors to the next layer One door is placed on the top wall of the layer and another door is placed on the right wall of the layer For each layer from to you are given positions of these two doors The doors can be passed in both directions either from layer to layer or from layer to layer If you are standing in some cell you can move to an adjacent by a side cell if a wall doesn t block your move e g you can t move to a cell in another layer if there is no door between the cells Now you have queries of sort what s the minimum number of moves one has to make to go from cell to cell ,WLOG assume all queries ask to move from a lower layer to a higher layer The first thing to notice in the problem is that it is always optimal to never go down a layer You have an optimal path that is going down some layers and then returning to the same layer So it leaves a layer in some its cell and returns to it in some other cell or the same one The best distance it can achieve is the Manhattan distance between these two cells However we can also achieve the Manhattan distance by just going along this layer and the answer will be at least as optimal If the query asks about the cells of the same layer just answer with the Manhattan distance Otherwise we can describe the path as follows go from the first cell to some door on its layer enter the door and go to another door on the next layer so on until the layer of the second cell where you go from a door to the second cell Thus we could potentially write the shortest distance from the start to the th door of the th layer Initialize both doors of the first layer take the best answer from the both doors of the last layer That would be per query which is too slow Let s optimize it with some precalculations In particular we want to know the shortest distance between one door of some layer and one door of another layer We can use the technique similar to binary lifting Calculate the distance between a pair of doors on layers which are apart for all up to Let be the distance from door of layer to door of layer can be initialized straightforwardly Then to calculate we can use the values for and for some intermediate door on layer To obtain the answer use jumps to reach the layer one before the last one Then iterate over the last door Alternatively you could pack this dynamic programming into a segment tree use divide and conquer on queries or do square root decomposition Overall complexity ,It s easy to see that it s optimal to only move right or to use a portal once we are at it We can notice that when we teleport back the problem is independent of the previous choices We still are at point and have some portals left Thus we can just find out the individual cost of each portal sort portals by individual costs and take them from smallest to largest by cost as long as we can The cost of portal is since we pay to use it and need moves to get to it 
241,You are given a simple undirected graph consisting of vertices and edges The vertices are numbered from to The th vertex has a value written on it You will be removing vertices from that graph You are allowed to remove vertex only if its degree is equal to When a vertex is removed all edges incident to it are also removed thus decreasing the degree of adjacent non removed vertices A valid sequence of removals is a permutation such that the th vertex to be removed is and every removal is allowed A pair of vertices is if there exist two valid sequences of removals such that is removed before in one of them and is removed before in the other one Count the number of pairs such that ,Let s consider what the sequence of removals looks like in general We will base some intuition on a fact that at least one valid sequence is guaranteed to exist Remove all vertices that have their degree correct from the start at once There surely be such vertices since a valid sequence would have to start with some of them Notice that there can t be any adjacent vertices among them If there were we wouldn t be able to remove such a pair regardless of the order we choose since removing one of them makes another one s degree too low Now remove the vertices that just got their degrees correct from removing the first layer Once again these must exist if the graph is not empty yet because otherwise any valid sequence would get stuck Process until nothing is left This algorithm is basically a bfs and you can implement it like one Note that each vertex becomes available to be removed only after a certain subset of its neighbours is removed No matter what order you choose to remove the vertices in these vertices will always be the same Huh so for each vertex some of its neighbours have to be removed before it and the rest have to be removed after it since otherwise the degree of that vertex will become too low That actually means that our graph is not as undirected as it seemed We can direct each edge from a vertex that is removed before the other This makes a valid sequence of removals just a topological sort of that directed graph So a pair is nice if there exist two topological orders such that and go one before another in them We can make a bold but perfectly reasonable guess about all nice pairs A pair is nice if neither of and are reachable from each other The necessity of this condition is obvious Let s show sufficiency Let s show the construction such that goes before To remove we first have to remove all vertices that have edges to To remove them we have to remove vertices with edge to them And so on Basically to remove we have to remove all vertices that are reachable from on the transposed directed graph Since is not reachable from it doesn t have to be removed before So we can first remove all the required vertices then remove then continue removing vertices until we are able to remove By switching and in the description of that construction we can obtain the construction for before Thus we reduced the problem to a rather well known one Calculate the number of reachable pairs of vertices in a directed graph As far as I know it s not known to be solvable in sub quadratic time And we are not given a specific graph Yes it s obviously acyclic but turns out every acyclic graph can be made into a test for this problem You just have to make equal to the number of the outgoing edges for each Somehow we are still given vertices and edges If you are more familiar with that problem you might know that you can use bitset to solve it In particular let be a bitset such that if if reachable from Then you can initialize for all vertices and propagate the knowledge in reverse topological order by applying for all edges Unfortunately that requires memory and bits is over a gigabyte Let s use of my favorite tricks to make a solution with memory and the same complexity Man I love that trick Process vertices in batches of Let s calculate which vertices can reach vertices from to The algorithm is basically the same For each vertex store a smaller bitset of size also known as an unsigned long long Initialize the bitset for vertices from the batch and propagate the same way for all vertices Now just add up the number of ones in each bitset builtin popcountll Proceed to the next batch That makes it iterations of a algorithm This might require some constant optimizations In particular I suggest not to use dfs inside the iteration since the recursion makes it really slow You might iterate over a vertex in reverse topological order and its outgoing edges Or which is way faster unroll that graph into a list of edges and iterate over it directly ,Firstly let s run bfs on the given graph and calculate distances for all vertices In fact we don t need distances we need their parities The second part is to find all vertices with an even distance all vertices with and odd distance and print the smallest by size part Why is it always true Firstly it is obvious that at least one of these sizes will not exceed And secondly because we are checking just parities of distances it is obvious that each vertex of some parity is connected with at least one vertex of the opposite parity because it has this parity from some vertex of the opposite parity 
242,You are given two arrays and Array is sorted in ascending order for each from to You have to divide the array into consecutive subarrays so that for each from to the minimum on the th subarray is equal to Note that each element belongs to exactly one subarray and they are formed in such a way the first several elements of compose the first subarray the next several elements of compose the second subarray and so on For example if and then there are two good partitions of array You have to calculate the number of ways to divide the array Since the number can be pretty large print it modulo ,At first let s reverse arrays and Now array is sorted in descending order Now let s find minimum index such that If there is no such index or if then the answer is because minimum on any prefix of array will never be equal to Otherwise let s find the minimum index such that If there is no such index or if then the answer is Also let s find the minimum index such that it can t be greater than The first subarray starts in position and ends in any position because if it ends in position or further then the minimum in the first subarray is greater than So there are ways to split subarrays and A similar approach can be used to calculate the number of ways to split the second and third subarrays and so on After all you have to check that minimum in the last subarray is equal to otherwise the answer is ,First we can always get a product value equal to if we remove all elements of the array Then we need to know what maximal value of the product we can get Consequently the remaining array after removing the corresponding prefix and suffix should have no elements We can find maxima in all sections between zeros Now we are left with a set of nonzero numbers If the value of the product on the current segment is positive it makes no sense to remove any more elements Otherwise the product is negative then we must remove one negative number from the product either to the left or to the right Compare the values of the product on the prefix and suffix to the nearest negative value and remove either the suffix or the prefix respectively 
243,You are given a permutation of elements A permutation of elements is an array of length containing each integer from to exactly once For example and are permutations but and are not permutations You should perform queries There are two types of queries swap and print the number that will become if we assign times ,Let s compute an array of integers answers to all possible second type queries with Now if we have to perform any second type query we can split it into at most queries with and at most queries with Let s also compute an array of integers reverse permutation If then To perform any first type query we should recompute and We can swap and in the array and and in the array No more than elements will be changed in the array These are elements with indexes elements and elements We can recompute and then assign and times Similarly for Time complexity ,Notice that you need to check just two numbers the closest one less or equal to and the closest one greater than Distances to them are and respectively Now you should multiply the first result by the second result by and compare the products Overall complexity 
244,Alica and Bob are playing a game Initially they have a binary string consisting of only characters and Alice and Bob make alternating moves Alice makes the first move Bob makes the second move Alice makes the third one and so on During each move the current player must choose two characters of string and delete them For example if then the following moves are possible delete and delete and delete and delete and If a player can t make any move they lose Both players play optimally You have to determine if Alice can win ,If there is at least one character and at least one character then current player can always make a move After the move the number of character decreases by one and the number of character decreases by one too So the number of moves is always where is the number of characters in string and is the number of characters in string So if is odd then Alice wins otherwise Bob wins ,First of all let s understand how to solve the problem without upgrades To do this it is enough to compare two numbers and the number of attacks that the character needs to kill the monster and the number of attacks that the monster needs to kill the character respectively So if the first number is not greater than the second number then the character wins Note that the number of coins is not very large which means we can iterate over the number of coins that we will spend on weapon upgrades and the remaining coins will be spent on armor upgrades After that we can use the formula described above to check whether the character will win The complexity of the solution is 
245,Masha has types of tiles of size Each cell of the tile contains one integer Masha has an of tiles of each type Masha decides to construct the square of size consisting of the given tiles This square also has to be a and each cell of this square has to be covered with exactly one tile cell and also sides of tiles should be parallel to the sides of the square All placed tiles cannot intersect with each other Also each tile should lie inside the square See the picture in Notes section for better understanding Symmetric with respect to the main diagonal matrix is such a square that for each pair the condition holds I e it is true that the element written in the row and th column equals to the element written in the th row and th column Your task is to determine if Masha can construct a square of size which is a symmetric matrix and consists of tiles she has Masha can use any number of tiles of each type she has to construct the square Note that she rotate tiles she can only place them in the orientation they have in the input You have to answer independent test cases ,Firstly if is odd then the answer is by obvious reasons Otherwise we can notice that the top left and the bottom right values of the tile do not matter since we can place tiles symmetrically So we only need to check that there is some tile that its top right value equals its bottom left value because this is how we get main diagonal symmetry ,It is intuitive and provable that the best strategy is to move each figure to the center cell Now with some paperwork or easy observations we can notice that we have exactly cells with the shortest distance cells with the shortest distance cells with the shortest distance and so on So we have cells with the shortest distance So the answer is It can be rewritten as so we can just calculate the sum of squares of all integers from to using loop or formula and multiply the answer by Time complexity or 
246,Let s call a non empty sequence of positive integers if the greatest common divisor of all elements of this sequence is equal to Given an array consisting of positive integers find the number of its subsequences Since the answer may be very large print it modulo Note that two subsequences are considered different if chosen indices are different For example in the array there are different subsequences and ,This problem can be solved using inclusion exclusion Let be the number of subsequences such that all elements of the subsequence are divisible by We can calculate which is the number of elements divisible by by factorizing all elements of the sequence and generating their divisors and Then we can apply the inclusion exclusion principle and get the resulting formula where is the M bius function ,It s always optimal to divide by whenever it s possible since dividing by equivalent to decreasing by The only problem is that it s too slow to just subtract from each time since in the worst case we can make operations Consider case and But if we d look closer then we can just replace times of subtract with one subtraction of And to make is divisible by we should make subtractions 
247,There are three sticks with integer lengths and You are asked to break exactly one of them into two pieces in such a way that both pieces have positive strictly greater than length the total length of the pieces is equal to the original length of the stick it s possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides A square is also considered a rectangle Determine if it s possible to do that ,First the condition about being able to construct a rectangle is the same as having two pairs of sticks of equal length Let s fix the stick that we are going to break into two parts Now there are two cases The remaining two sticks can be the same In that case you can break the chosen stick into equal parts to make the second equal pair of sticks Note however that the stick should have an even length because otherwise the length of the resulting parts won t be integer The remaining two sticks can be different In that case the chosen stick should have the length equal to their total length because the only way to make two pairs of equal sticks is to produce the same two sticks as the remaining ones Overall complexity per testcase ,Let s rotate the grid by and and mark all cells that map to each other under these rotations For example for and grids mirror grid must have the following patterns the same letters denoting equal values In general we can rotate the grid by and and see which cells need to have equal values by seeing the positions which each cell maps to Now to solve the problem we consider each equal value each of the letters in the above figures independently and consider the minimum number of moves to make them all or all The answer is the total across all values See the implementation for better understanding The time complexity is per testcase 
248,Monocarp is playing a computer game Now he wants to complete the first level of this game A level is a rectangular grid of rows and columns Monocarp controls a character which starts in cell at the intersection of the st row and the st column Monocarp s character can move from one cell to another in one step if the cells are adjacent by side and or corner Formally it is possible to move from cell to cell in one step if and Obviously it is prohibited to go outside the grid There are traps in some cells If Monocarp s character finds himself in such a cell he dies and the game ends To complete a level Monocarp s character should reach cell at the intersection of row and column Help Monocarp determine if it is possible to complete the level ,At first glance it seems like a graph problem And indeed this problem can be solved by explicitly building a graph considering cells as the vertices and checking that there is a safe path from start to finish via DFS BFS DSU any other graph algorithm or data structure you know But there s a much simpler solution Since there are only two rows in a matrix it s possible to move from any cell in the column to any cell in column if they are both safe of course It means that as long as there is at least one safe cell in each column it is possible to reach any column of the matrix and the cell as well It s easy to see that if this condition is not met there exists a column with two unsafe cells and this also means that this column and columns to the right of it are unreachable So the problem is reduced to checking if there is a column without any unsafe cells To implement this you can read both rows of the matrix as strings let these strings be and and check that there is a position such that both and are equal to ,The problem is mainly a tricky implementation problem Let s denote the of an L shape as the square in the middle the one that is side adjacent to two other squares Every elbow is part of exactly one L shape and every L shape has exactly one elbow Iterate through the grid and count the number of side adjacent neighbors they have If there is a cell with more than 2 or if there is a cell with exactly two neighbors on opposite sides then the answer is Otherwise if there are exactly 2 neighbors this cell is an elbow Mark all three cells of this L shape with a unique number say mark the first one you find with the second with and so on If you ever remark a cell that already has a number then two elbows are adjacent and you can output After all elbows are marked check if all shaded cells have a number If some don t then they are not part of an L shape so you can output Finally we should check that L shapes don t share edge or corner Just check for each number if it is only diagonally adjacent to other numbers equal to it or unshaded cells If it is diagonally adjacent to other unequal numbers then the answer is because two L shapes share an edge or corner then Otherwise the answer is There are many other solutions all of which are various ways to check the conditions The complexity is per testcase 
249,A sequence of numbers is called if it contains all integers from to exactly once For example the sequences and are permutations but and are not Kristina had a permutation of elements She wrote it on the whiteboard times in such a way that while writing the permutation at the th time she skipped the element So she wrote in total sequences of length each For example suppose Kristina had a permutation of length Then she did the following Wrote the sequence skipping the element from the original permutation Wrote the sequence skipping the element from the original permutation Wrote the sequence skipping the element from the original permutation Wrote the sequence skipping the element from the original permutation You know all of sequences that have been written on the whiteboard but you do not know the order in which they were written They are given in Reconstruct the original permutation from them For example if you know the sequences then the original permutation will be ,When Kristina writes sequences on the whiteboard she removes an element with each index exactly once Thus the first element of the permutation will be deleted only once on the first step All sequences except one will start with itTo solve the problem find a sequence such that it starts with some element all sequences other than this one begin with some element Then this permutation will describe the sequence of numbers remaining after removing the th element and the first element itself will be equal to the number The initial permutation will look like ,At first let s represent permutations in the next form We assign to all numbers from to random 128 bit strings so the th number gets the string Then the permutation of length can be hashed as where is bitwise exclusive OR for example This representation is convenient because if we have two sets of numbers with a total number of elements equal to let s represent them as and we can easily check whether their union is a permutation of length condition must be hold Let s denote as Now let s iterate over position such that and calculate the number of permutations that contain this element To do it let s iterate over the right boundary and suppose that maximum element of permutation and its length at the same time is one of positions If it s true then the subpermutation should be on the positions And to check that this segment is a subpermutation we should just compare and Thus we will calculate all permutations in which the position of the maximum is to the right of the position of the To calculate all permutations we need to reverse array and repeat this algorithm and then add the number of ones in the array 
250,A chainword is a special type of crossword As most of the crosswords do it has cells that you put the letters in and some sort of hints to what these letters should be The letter cells in a chainword are put in a single row We will consider chainwords of length in this task A hint to a chainword is a sequence of segments such that the segments don t intersect with each other and cover all letter cells Each segment contains a description of the word in the corresponding cells The twist is that there are actually two hints one sequence is the row above the letter cells and the other sequence is the row below the letter cells When the sequences are different they provide a way to resolve the ambiguity in the answers You are provided with a dictionary of words each word consists of lowercase Latin letters All words are pairwise distinct An instance of a chainword is the following triple a string of lowercase Latin letters the first hint a sequence of segments such that the letters that correspond to each segment spell a word from the dictionary the second hint another sequence of segments such that the letters that correspond to each segment spell a word from the dictionary Note that the sequences of segments don t necessarily have to be distinct Two instances of chainwords are considered different if they have different strings different first hints different second hints Count the number of different instances of chainwords Since the number might be pretty large output it modulo ,Let s use a trie to store the given words Now let s imagine a procedure that checks if some string of length can be represented as a concatenation of some of these words If the words were prefix independent no word was a prefix of another word that task would be solvable with a greedy algorithm We could iterate over a string and maintain the current vertex of the trie we are in Append a current letter If there is no such transition in a trie it can t be represented If the vertex we go to is a terminal jump to the root of the trie Otherwise just go to that vertex However since the words aren t prefix independent we have a terminal on a path to other terminals Thus we can t immediately decide if we should jump to the root or just go Let s handle this with dynamic programming can we put letters in such a way that the vertex of a trie we are in is Is building a chainword letter by letter that different from this process Apparently it isn t Consider how many ways are there to put letters in a string so that the first hint is in a vertex and the second hint is in a vertex For the transition we can try all letters to put and jump to the corresponding vertices That obviously is too slow The intuition tells us that this dp should be calculated with some kind of matrix exponentiation since That dp can be rewritten as a matrix pretty easily However its size is up to the maximum number of vertices in a trie squared Some say that there is a way to compute the th power of such a huge matrix fast enough with Berlekamp Massey but I unfortunately am not familiar with it Thus we ll have to reduce the size of our matrix First notice that the only reachable states are such that the word that is written on a path from the root to is a suffix of a word that is written on a path from the root to or vice versa Look at it the other way if we build a trie on the reversed words then one of the vertices will be an ancestor of another one Now it s easy to estimate the number of states as the sum of depths of all vertices However since we look at ordered pairs of we should more or less double that amount That should be states at max This can probably pass with an optimal enough implementation We can do better though Let s merge the states and into one state The intuition is basically that you can swap the hints at will That makes the pairs unordered now there are up to pairs That surely will work fast enough The way to generate all the possible states is the following run a dfs bfs starting from that makes all valid transition and record all the states that can be visited While preparing the tests I only managed to get up to states and I would really love to hear an approach to either prove a tighter bound or to generate a test closer to the bound of ,There are several more or less complicated combinatorial solutions to this problem but I will describe a dynamic programming one which I think is way easier to understand and to implement Suppose we have fixed the positions of and that compose the subsequence let these positions be and How many strings contain the required subsequence on these positions Obviously if some of these characters is already not a question mark and does not match the expected character on that position the number of strings containing the subsequence on that position is Otherwise since we have fixed three characters all question marks on other positions can be anything we want so the number of such strings is where is the number of question marks on positions other than and It allows us to write an solution by iterating on and and for every such triple calculating the number of strings containing the required subsequence on those positions But that s too slow Let s notice that for every such subsequence the number of strings containing it is where is the number of positions from that contain a question mark So for each integer from to let s calculate the number of subsequences matching that contain exactly question marks and that will allow us to solve the problem faster How can we calculate the required number of subsequences for every In my opinion the simplest way is dynamic programming let be the number of subsequences of that end up in position match first characters of and contain question marks The transitions in this dynamic programming are quadratic since we have to iterate on the next previous position from the subsequence but can be sped up to linear if we rewrite as the number of subsequences of that end up in position match first characters of and contain question marks Each transition is either to take the current character or to skip it so they can be modeled in and overall this dynamic programming solution works in 
251,Polycarp wrote on a whiteboard an array of length which is a permutation of numbers from to In other words in each number from to occurs exactly once He also prepared a resulting array which is initially empty that is it has a length of After that he did exactly Each looked like this Look at the leftmost and rightmost elements of and pick the smaller of the two If you picked the leftmost element of append it to the left of otherwise if you picked the rightmost element of append it to the right of The picked element is erased from Note that on the last step has a length of and its minimum element is both leftmost and rightmost In this case Polycarp can choose what role the minimum element plays In other words this element can be added to both on the left and on the right at the discretion of Polycarp Let s look at an example Let Initially Then During the first step the minimum is on the right with a value of so after this step and he added the value to the right During the second step the minimum is on the left with a value of so after this step and he added the value to the left During the third step the minimum is on the left with a value of so after this step and he added the value to the left During the fourth step the minimum is both left and right this value is Let s say Polycarp chose the right option After this step and he added the value to the right Thus a possible value of after steps could be You are given the final value of the resulting array Find possible initial value for that can result the given or determine that there is no solution ,The maximum element is always added last so if it is not in the first or last position then there is no answer Let us prove that if the permutation has its maximum element in the first or last position then after actions we can get an expanded permutation Indeed the maximum element will be added last at the desired end and all the others will be added in reverse order Then if the answer exists it is sufficient to simply unfold the permutation ,Let s fix the first element and then try to restore permutation using this information One interesting fact if such permutation exists with this first element then it can be restored uniquely Let s remove the first element from all segments containing it we can use some logarithmic data structure for it Then we just have a smaller problem but with one important condition there is a segment consisting of one element again if such permutation exists So if the number of segments of length 1 is zero or more than one by some reason then there is no answer for this first element Otherwise let s place this segment a single element in second place remove it from all segments containing it and just solve a smaller problem again If we succeed with restoring the permutation then we need to check if this permutation really satisfies the given input segments see the first test case of the example to understand why this case appears Let s just iterate over all i from 2 to n and then over all j from i 1 to 1 If the segment a j a j 1 dots a i is in the list remove it and go to the next i If we can t find the segment for some i then this permutation is wrong Time complexity O n 3 log n or less maybe 
252,Ivan is going to sleep now and wants to set his alarm clock There will be many necessary events tomorrow the th of them will start during the th minute Ivan doesn t want to skip any of the events so he has to set his alarm clock in such a way that it rings during minutes so he will be awake during each of these minutes Ivan can choose two properties for the alarm clock the first minute it will ring let s denote it as and the interval between two consecutive signals let s denote it by After the clock is set it will ring during minutes and so on Ivan can choose minute as the first one but he cannot choose any arbitrary value of He has to pick it among the given values his phone does not support any other options for this setting So Ivan has to choose the first minute when the alarm clock should start ringing and the interval between two consecutive signals in such a way that it will ring during all given minutes and it does not matter if his alarm clock will ring in any other minutes Your task is to tell the first minute and the index such that if Ivan sets his alarm clock with properties and it will ring during all given minutes or say that it is impossible to choose such values of the given properties If there are multiple answers you can print any ,It is obvious that we can always take as But we don t know which value of we can take Let be for all from to The value of should be divisor of value of The maximum possible divisor of each is greatest common divisor And then it is obvious that the value of should be the divisor of So we have to find divisor of among all values If there is no such value then the answer is Time complexity ,In this problem we need to find and such that and Since and are positive and are also positive Hence Therefore the number can be iterated from to Since in all tests then For each you can find by the formula This is a positive number It remains to check that is an integer 
253,There are warriors in a row The power of the th warrior is All powers are pairwise distinct You have two types of spells which you may cast Fireball you spend mana and destroy consecutive warriors Berserk you spend mana choose two consecutive warriors and the warrior with greater power destroys the warrior with smaller power For example let the powers of warriors be and If you cast Berserk on warriors with powers and the resulting sequence of powers becomes Then for example if you cast Fireball on consecutive warriors with powers the resulting sequence of powers becomes You want to turn the current sequence of warriors powers into Calculate the minimum amount of mana you need to spend on it ,The first thing we need to do is to find the occurrences of in the sequence these are the monsters that have to remain Since both spells Fireball and Berserk affect consecutive monsters we should treat each subsegment of monsters we have to delete separately Consider a segment with monsters we have to delete such that the last monster before it has power the first monster after the segment has power and the strongest monster on the segment has power If then we have to use Berserk at least times Let s make the strongest monster on segment kill some other monster If then the strongest monster should also be killed by one of the monsters bounding the segment so if and there is no solution Okay now the number of monsters is divisible by If it is more profitable to use Fireball we use the required number of Fireballs to kill all of them Otherwise we have to kill the maximum possible number of monsters with Berserk and finish the remaining ones with Fireball If or then one of the monsters just outside the segment can kill all the monsters inside the segment otherwise the strongest monster should kill adjacent monsters until exactly remain and those monsters are finished with a single Fireball Now we know what we need to consider when processing a single segment all that s left is to sum the minimum required mana over all such segments Since the total length of these segments is at most and we can process each segment in linear time we have a solution with complexity ,Let s start thinking about the problem from the easy cases How to solve the problem fast if all towers have full mana We can store prefix sums of their capacities and find the first tower that doesn t get drained completely with a binary search Let s try the opposite How to solve the problem fast if all towers were drained completely in the previous second It s the same but the prefix sums are calculated over regeneration rates What if all towers were drained at the same second earlier than the previous second and no tower is fully restored yet It s also the same but the regeneration rates are multiplied by the time passed since the drain What if we drop the condition about the towers not being fully restored How would a data structure that can answer prefix sum queries work It should store the total mana capacity of all towers that are full Then mana regeneration rates for all towers that aren t If these are kept separately then it s easy to obtain the prefix sum by providing the time passed This will be total capacity plus total regeneration rate multiplied by the time passed How to determine if the tower is fully restored since the drain or not That s easy For each tower we can calculate the number of seconds it takes it to get restored from zero That is Thus all towers that have this value smaller than the time passed won t get restored All the rest will Unfortunately in the actual problem not all towers were last drained at the same time However it s possible to reduce the problem to that Store the segments of towers that were drained at same time There are also towers that weren t drained completely but they can be stored as segments of length too When a monster comes it drains some prefix of the towers completely and possibly one more tower partially In terms of segments it removes some prefix of the them and possibly cuts one Then it creates a segment that covers the prefix and possibly a segment of length with a partially drained tower So each monster creates segments and removes no more segments than were created Thus if we were to process each creation and removal in some then the complexity will be All towers on each segment have the same time passed since the drain We want to query the sum on the entire segment If it is greater than the remaining health of the monster we want to find the largest prefix of this segment that has a smaller or equal sum than the monster health Given time passed let s learn to query the range sum If we knew the queries beforehand it would be easy Initialize a segment tree as if all towers are completely restored Then make events of two kinds a tower with restore time and a query with time Sort them in the decreasing order and start processing one by one When a tower event happens update a single position in the segment tree from capacity to regeneration rate When a query event happens find the sum Since the queries are not known beforehand make that segment tree persistent and ask specific versions of it If a segment of towers was last drained at time and the query is at time then you should query the segment tree in version Obviously you can store not all versions but only ones that have some tower change Moreover it s more convenient to make one version responsible for one tower update Then you can lower bound the array of sorted to find the version you want to ask at To determine the largest prefix of this segment that has a smaller or equal sum than the monster health you can either binary search for or traverse the segment tree for The time limit might be a little tight for the first approach but it can still pass Overall complexity 
254,Polycarp doesn t like integers that are divisible by or end with the digit in their decimal representation Integers that meet both conditions are disliked by Polycarp too Polycarp starts to write out the positive greater than integers which he likes Output the th element of this sequence the elements are numbered from ,The solution is simple let s create an integer variable initially set to that will contain the number of considered liked integers Let s iterate over all positive integers starting with Let s increase the variable only when the considered number is liked If the variable is equal to let s stop the iteration and output the last considered number Since the answer for is the count of considered numbers is at most so the solution will work on the specified limitations fast enough ,For each from to find all elements of the array that are congruent to modulo and store their indices in a list Also create a vector called and let be We have to cycle from to twice For each from to if there are in list too many i e elements congruent to modulo remove the extra elements from this list and add them to If instead there are too few i e elements congruent to modulo remove the last few elements from the vector For every removed index increase by After doing so after two passes we print the total increase and the updated array It is obvious that after the first iterations every list will have size at most and after more iterations all lists will have the same sizes It can be easily proved that this algorithm produces an optimal answer The time complexity is 
255,Polycarp must pay burles at the checkout He has coins of two nominal values burle and burles Polycarp likes both kinds of coins equally So he doesn t want to pay with more coins of one type than with the other Thus Polycarp wants to minimize the difference between the count of coins of burle and burles being used Help him by determining two non negative integer values and which are the number of coins of burle and burles respectively so that the total value of that number of coins is i e and the absolute value of the difference between and is as little as possible i e you must minimize ,Let s initialize variables and by the same value of Then we need to gather additionally the remainder of dividing by If the remainder is equal to we don t need to gather anything else because the variables and have been already set to the correct answer because and no absolute value can be less than Otherwise because and in this case but that s impossible if isn t divisible by 3 If the remainder is equal to then we need to gather additionally burle using one coin of burle so let s increase by In this case hence this value cannot be less than as it was proved above If the remainder is equal to then we need to gather additionally burles using one coin of burles so let s increase by In this case hence this value cannot be less than There are no other remainders of dividing by so these cases cover the whole solution ,This problem has a GCD based solution Firstly lets try to solve it naively Always suppose that If this is not true let s swap and Firstly if let s do Okay now let s subtract from until again and repeat this algorithm till or If after some step we get or we are done and the answer is If or and we didn t get then the answer is Okay we can see that we always subtract the minimum possible from and trying to maintain this condition It can be proven that this algorithm yields all possible integers that are obtainable by any sequence of the operations from the problem statement either in or in Now we have to speed up this solution somehow Obviously most operations are redundant for us in this particular problem The first thing is that we can skip all operations till becomes greater than The number of such operations is And the second thing is that we can skip all operations till we get in The number of such operations is For simplicity this part can be also written as This doesn t affect the time complexity much but the formula for the final number of operations we can skip will be simpler This number equals in fact we take the minimum between two values written above because we don t want to skip any of these two cases So we can transform the pair to the pair and continue this algorithm There are also simpler approaches using the same idea but in a cooler way Time complexity per test case 
256,Monocarp had a tree which consisted of vertices and was rooted at vertex He decided to study BFS Breadth first search so he ran BFS on his tree starting from the root BFS can be described by the following pseudocode Monocarp was fascinated by BFS so much that in the end he lost his tree Fortunately he still has a sequence of vertices in which order vertices were visited by the BFS algorithm the array from the pseudocode Monocarp knows that each vertex was visited exactly once since they were put and taken from the queue exactly once Also he knows that all children of each vertex were viewed Monocarp knows that there are many trees in the general case with the same visiting order so he doesn t hope to restore his tree Monocarp is okay with any tree that of a tree is the maximum depth of the tree s vertices and the depth of a vertex is the number of edges in the path from the root to it For example the depth of vertex is since it s the root and the depth of all root s children are Help Monocarp to find any tree with given visiting order and minimum height ,Due to the nature of BFS the visiting order consists of several segments first goes root has depth then all vertices with depth then all vertices with depth and so on Since any vertex of depth is a child of vertex of depth then it s optimal to make the number of vertices with depth as many as possible then make the number of vertices with depth as many as possible and so on Since children of a vertex are viewed in ascending order and form a segment in visiting order then an arbitrary segment of visiting order can be children of the same vertex iff elements in the segments are in ascending order These two observations lead us to a greedy strategy then let s find the maximum that segment is in ascending order they will be the children of and the only vertices of depth Next search the maximum such that segment is in ascending order they will be the children of and so on It s easy to see that this strategy maximizes the number of vertices of each depth level so minimize the height of the tree ,Let be the set of unvisited vertices To store it we will use some data structure that allows us to do the following insert some value into the set delete from the set find the smallest integer from the set such that For example from allows us to do all these operations fastly Also we can use this structure to store the adjacency lists We will use a modified version of depth first search When we are entering a vertex with we erase it from the set of unvisited vertices The trick is that in we will iterate over the set of unvisited vertices using its function And we will make not more than iterations overall because when we skip an unvisited vertex that means there is no edge from this vertex to the vertex we are currently traversing in so there will be no more than skips and each iteration we don t skip decreases the number of unvisited vertices 
257,The robot is located on a checkered rectangular board of size rows columns The rows in the board are numbered from to from top to bottom and the columns from to from left to right The robot is able to move from the current cell to one of the four cells adjacent by side Each cell has one of the symbols or written on it indicating the direction in which the robot will move when it gets in that cell left right down or up respectively The robot can start its movement in any cell He then moves to the adjacent square in the direction indicated on the current square in one move If the robot moves beyond the edge of the board it falls and breaks If the robot appears in the cell it already visited before it breaks it stops and doesn t move anymore Robot can choose any cell as the starting cell Its goal is to make the maximum number of steps before it breaks or stops Determine from which square the robot should start its movement in order to execute as many commands as possible A command is considered successfully completed if the robot has moved from the square on which that command was written it does not matter whether to another square or beyond the edge of the board ,Let s start moving from an arbitrary cell of the table for example from Movement from each cell is specified by the direction given in that cell so you can run a loop with a stopping condition exit from the board border or get to the already visited cell Create a separate array how many commands the robot will execute starting the movement from the cell we will also use it to check whether the cell has already been visited or not not visited if is not yet positive Finishing the movement from let s consider two cases Either we have gone beyond the boundary of the array then we can say for sure that for the th cell from the end of the sequence the answer is Or we came to the already visited cell let it be the th from the end in our path Then at the end of the path there is a cycle of length starting the movement at any cell of this cycle the robot will walk exactly steps until it arrives at the already visited cell Thus for distance will be equal to and for all others it will be as in the first case Let us run the same algorithm from the next cell which we have not yet considered There will be three cases of robot stopping the execution of the commands the first two repeat those already considered above and the third case is that the robot will come to the cell already visited on some of the previous iterations of our algorithm In this case we know that starting from the robot will make exactly steps so for the th cell from the end on the current path will hold The first two cases are handled completely in the same way as described above Each of the cases is eventually reduced to another iteration over the cells visited in the current path Let s visit all the cells in reverse and mark all values of Such algorithm is enough to repeat until each cell is processed after which for each cell of the table its will be known and we ll only have to choose the maximal value of among all ,For each person let s calculate how much the value will change if they turn around For example in the line if the th person turns around then the value of the line will change by respectively For instance if the second person turns around they see people before and person after so the value of the line changes by if they turn around Now note that if a person turns around it doesn t affect anyone else s value So the solution is a greedy one let s sort the array of values in increasing order Afterwards we should go from the left to the right and see if the value will increase if this person turns around if it does we should add it to the current total and continue The time complexity of this solution is per testcase 
258,You have an undirected graph consisting of vertices with weighted edges A simple cycle is a cycle of the graph without repeated vertices Let the of the cycle be the XOR of weights of edges it consists of Let s say the graph is if all its cycles have weight A graph is bad if it s not good Initially the graph is empty Then queries follow Each query has the next type add edge between vertices and of weight if it doesn t make the graph bad For each query print was the edge added or not ,Firstly let s prove that a good graph has one important property any two of its simple cycles intersect by at most one vertex i e there is no edge that belongs to more than one simple cycle cactus definition yeah Let s prove it by showing that if two simple cycles of weight k 0 intersects by edges then they will induce a simple cycle of weight neq k There are two cases if cycles intersect by a single path then we can create a new cycle by merging parts of cycles excluding the intersecting path it will be simple and will have weight k oplus k 0 neq k if cycles intersect by more than one path we can do the next transformation suppose the common paths are u 1 v 1 u 2 v 2 dots and they are ordered in the way how they lie on the first cycle Let s create a third cycle using two paths from v 1 to u 2 from the first cycle and from the second cycle It s easy to see that the third cycle is simple and more over it has only one common path with the second cycle So it s either the third cycle has weight not equal to k or the case 1 Okay let s analyze the edges we try to add Let s divide all edges in two types edges and all other edges we will name them edges Let s name an edge as a edge if it connects two different components at a moment when we are trying to add it in the graph It s obvious that we will add all tree edges in the graph since they can t make it bad since they don t induce new cycles But there is a more interesting observation when we try to add a cycle edge u v it should induce an only one simple cycle where all other edges are tree edges and these tree edges can t be used in any other cycle It induces at least one all tree edge cycle since u and v are already connected It can t induce more than one all tree edge cycle since it contradicts with definition and if it induces a cycle with some other cycle edge then we can replace that cycle edge with its own tree edge path our cycle will become all tree edge cycle but it will use already used tree edges In other words it s enough to consider only one all tree edge cycle induced by any cycle edge The final trick is to calculate the answer in two steps at the first step we will find only tree edges using DSU that will form a spanning forest in our graph The second step is for each cycle edge u v to calculate the operatorname XOR X on a path between u and v in our spanning forest check that X oplus text edge weight 1 and check that none of edges on the path from u to v are used in other cycle Calculating X is easy if we precalculate for each vertex v the operatorname XOR on path from v to root mathit xr v then X mathit xr u oplus mathit xr v Checking that none of the edges are used on the path from u to v is a bit tricky if we mark an edge by adding 1 to it then we should be able to take a sum on path and add on path There are structures that are capable of it like HLD and other but let s look closely Note that we mark each tree edge at most once so we can manually add 1 to each edge and only asking sum on path should be fast In other words we need a data structure DS that can add value at edge and take the sum on path and such DS is a Fenwick tree BIT built on Euler tour of tree it can add value at edge and ask a sum on path from v to root So we need to find LCA as well since sum of path u v is equal to sum u sum v 2 cdot sum LCA u v As a result complexity is O n m log n with quite a low constant from LCA and BIT ,If all districts belong to the same gang then the answer is Otherwise the answer is always yeah as in the previous problem How to construct it Let s choose the first root as the district and connect all such districts that to the district So all disconnected districts that remain are under control of the gang Let s find any district that and just connect all remaining districts of the gang to this district This district always exists because we have at least two different gangs and it is connected to the remaining structure because its gang is not So all conditions are satisfied 
259,You have a set of items each having some integer weight not greater than You denote that a subset of items is good if total weight of items in the subset does not exceed You want to calculate the maximum possible weight of a good subset of items Note that you have to consider the empty set and the original set when calculating the answer ,Let s consider the optimal answer Suppose we take items of weight Let be the least common multiple of all weights that is Then we may represent as where Let s do the following trick we will take items of weight and all the remaining items of this weight can be merged into some items of weight Then we can write a brute force solution that picks less than items of each weight transforms the remaining ones into items of weight as much as possible and when we fix the whole subset adds maximum possible number of items of weight to the answer This works in something like operations which is too much How can we speed it up Rewrite it using dynamic programming When we have fixed the number of items we take from first sets the only two things that matter now are the current total weight of taken items and the number of items of weight we can use and it s obvious that the more items of weight we can use the better So let s write the following dynamic programming solution maximum number of items of weight we can have if we processed first types of items and current total weight is Note that the second dimension should have size ,Let be the number of boxes with candies modulo Firstly the number of of boxes we can obtain using two boxes with remainder modulo is Secondly if is even then we also can obtain of boxes using two boxes with remainder modulo and its number is And for any other remainder from to the number of pairs of boxes is So if we sum up all these values the answer is this sum multiplied by two because we have to print the number of boxes not pairs 
260,Polycarp often uses his smartphone He has already installed applications on it Application with number takes up units of memory Polycarp wants to free at least units of memory by removing some applications Of course some applications are more important to Polycarp than others He came up with the following scoring system he assigned an integer to each application regular application important application According to this rating system his phone has convenience points Polycarp believes that if he removes applications with numbers then he will free units of memory and lose convenience points For example if then Polycarp can uninstall the following application sets not all options are listed below applications with numbers and In this case it will free units of memory and lose convenience points applications with numbers and In this case it will free units of memory and lose convenience points applications with numbers and In this case it will free memory units and lose convenience points Help Polycarp choose a set of applications such that if removing them will free at least units of memory and lose the minimum number of convenience points or indicate that such a set does not exist ,Let s say we remove applications with and applications with Obviously among all the applications with it was necessary to take maximum in memory so we will clear the most memory Let s split all the applications into two arrays with and and sort them Then you need to take a prefix from each array Let s iterate over which prefix we take from the first array For it we can uniquely find the second prefix we remove applications until the sum exceeds If we now increase the first prefix by taking a new application then we don t need to take any applications in the second array This means that when the first prefix is increased the second one can only decrease To solve the problem you can use the two pointer method ,Firstly let s understand that the sum of the segment is zero if is zero in other words where is the sum of the first elements Let s iterate over elements from left to right and add all prefix sums in the set If we get the sum that is already in the set we get some segment with sum and we need to fix it somehow Let s insert some huge number before the current element in such a way that all prefix sums starting from the current element to the end will be significantly bigger than all prefix sums to the left In words of implementation we just get rid of all prefix sums to the left clear the set and continue doing the same process starting from the current element so we just cut off the prefix of the array This way is optimal because we remove all segments with sum ending at the current element using only one insertion and we need to use at least one insertion to do that Time complexity 
261,A sequence of numbers is called a permutation if it contains all integers from to exactly once For example the sequences and are permutations but and are not Polycarp lost his favorite permutation and found only some of its elements the numbers He is sure that the sum of the lost elements equals Determine whether one or more numbers can be appended to the given sequence such that the sum of the added numbers equals and the resulting new array is a permutation ,Let us add to the sum of the elements of the array and try to find a suitable permutation To do this greedily add elements until their sum is less than And at the end we will check that the sum has matched Also check that the maximal element from and that the total elements in ,Let be the number such that after some sequence of moves there will be at least elements in the array We can see that there is always possible candidates because all values are among all possible values of for some from to So we need to check each candidate separately and try to update the answer with it How to do this Let the current number we trying to obtain is Then let s iterate over all in any order Let be the current value of Let s divide it by while its value is greater than and carry the number of divisions we made If after all divisions then let s remember the value of in some array If after iterating over all elements of the size of is greater than or equal to then let s sort it and update the answer with the sum of smallest values of Time complexity or depends on sorting method 
262,You are given two strings and consisting of lowercase English letters both of length The characters of both strings have indices from to inclusive You are allowed to do the following Choose any index and swap characters and Choose any index and swap characters and Choose any index and swap characters and Note that if is odd you are formally allowed to swap with and the same with the string but this move is useless Also you can swap two equal characters but this operation is useless as well You have to make these strings equal by applying any number of described above in any order But it is obvious that it may be impossible to make two strings equal by these swaps In one you can replace a character in with another character In other words in a single you can choose any index any character and set Your task is to find the minimum number of to apply in such a way that after them you can make strings and equal by applying some number of described in the list above Note that the number of you make after the does not matter Also note that you cannot apply to the string or make any after the first is made ,Let s divide all characters of both strings into groups in such a way that characters in each group can be swapped with each other with So there will be following groups and so on Since these groups don t affect each other we can calculate the number of in each group and then sum it up How to determine if a group does not need any preprocess moves For a group consisting of characters there will be one such group if is odd it will contain and that s easy if the characters in this group are equal the answer is otherwise it s To determine the required number of preprocess moves for a group consising of four characters we may use the following fact this group doesn t require preprocess moves iff the characters in this group can be divided into pairs So if the group contains four equal characters or two pairs of equal characters then the answer for this group is Otherwise we may check that replacing only one character of and will be enough if so then the answer is otherwise it s Overall complexity is ,Observation the product of odd numbers is odd so the condition for the length of is automatically completed Denote by the number of ones in binary representation of Let s enumerate the letters of the Latin alphabet from to Observation for each word it is enough to know the set of letters included in it and the evenness of their numbers There are only letters in the alphabet so it is convenient to store the word characteristic as a pair of masks The bit with the number in will be responsible for the availability of the letter in The bit with the number in will be responsible for the evenness of the number of letters in Observation strings creates if and only if Let s fix the number the index of the letter that will not be in Let s throw out all the words with the letter now we can look at the words in turn and look for a pair of them among those already considered It is easy to see that the condition follows from the condition if one letter is banned To count the number of pairs that include our word we need to count the number of words with the characteristic We can do this by bin searching through a sorted array of or using standard data structures We got the solution for 
263,You are given distinct points on a plane The coordinates of the th point are For each point find the nearest in terms of Manhattan distance point with that is not among the given points If there are multiple such points you can choose any of them The Manhattan distance between two points and is ,Firstly we can find answers for all points that are adjacent to at least one point not from the set The distance for such points is obviously and this is the smallest possible answer we can get On the next iteration we can set answers for all points that are adjacent to points with found answers because they don t have neighbors not from the set the distance for them is at least It doesn t matter which point we will take so if the point is adjacent to some point that have the answer we can set the answer for the point as the answer for the point We can repeat this process until we find answers for all points In terms of the code this can be done by breadth first search BFS In other words we set answers for the points that have the distance and then push these answers to all adjacent points from the set in order of the increasing distance until we find all the answers Time complexity ,This problem is a standard two dimensional problem that can be solved with one dimensional data structure In the same way a lot of other problems can be solved for example the of finding the maximal weighted chain of points so that both coordinates of each point are greater than the coordinates of the predecessing point Rewrite the problem formally for each we should count the number of indices so that the following conditions are hold and Let s sort all segments by the left ends from right to left and maintain some data structure Fenwick tree will be the best choice with the right ends of the processed segments To calculate the answer for the current segment we should simple take the prefix sum for the right end of the current segment So the condition is hold by sorting and iterating over the segments from the right to the left the first dimension of the problem The condition is hold by taking the prefix sum in data structure the second dimension 
264,Suppose you are living with two cats A and B There are napping spots where both cats usually sleep Your cats like to sleep and also like all these spots so they change napping spot each hour cyclically Cat A changes its napping place in order In other words at the first hour it s on the spot and then goes in decreasing order cyclically Cat B changes its napping place in order In other words at the first hour it s on the spot and then goes in increasing order cyclically The cat B is much younger so they have a strict hierarchy A and B don t lie together In other words if both cats d like to go in spot then the A takes this place and B moves to the next place in its order if then to but if then to Cat B follows his order so Calculate where cat B will be at hour ,If is even then each hour A and B are on the spots with different parity so they will never meet Otherwise let s look closely what happens At the start A in and B in But since we can form a cycle from spots then it means that and in reality are neighbors After that A and B starting from neighboring positions just go in opposite directions and meet each other in the opposite spot after exactly steps After meeting B jumps over A making extra step and the situation become practically the same A and B are neighbors and move in the opposite direction In other words each steps B makes one extra step so the answer if both and spots are indexed is ,This problem has a very easy idea but requires terrible implementation Firstly let s place all platforms as rightmost as we can Thus we will have the array in which the first elements are zeros and other elements are Now let s start the algorithm Firstly we need to jump to the position or less If we could jump to the position then we don t need to jump to some position to the left from But if we cannot do it let s take the leftmost platform to the right from the position and move it in such a way that its left border will be at the position Now we can jump to the position and then jump by right to reach the position Let s repeat the same algorithm and continue jumping If after some move we can jump to the position at least then we are done Time complexity but I m sure it can be implemented in or 
265,You are given a directed acyclic graph with vertices and edges There are no self loops or multiple edges between any pair of vertices Graph can be disconnected You should assign labels to all vertices in such a way that Labels form a valid permutation of length an integer sequence such that each integer from to appears exactly once in it If there exists an edge from vertex to vertex then should be smaller than Permutation should be lexicographically smallest among all suitable Find such sequence of labels to satisfy all the conditions ,This problem is usually called Topological labelling Though it s pretty common problem we decided that it might be educational to some of participants Let s set labels in descending order starting from label to label Look at first step Vertex with label should have out degree equal to zero Among all such vertices we should put the label on the one that has the largest index Ok but why will this produce the lexicographically smallest labelling We can prove this by contradiction Let this vertex be labeled Change it to and renumerate vertices with label to labels Labelling will come lexicographically smaller than it was this leads to contradiction So the algorithm comes as following On step we find vertices with out degree equal to zero select the one with the largest index set its label to and remove this vertex and all edges connected to it from the graph Current minimal out degree can be maintained with set for example Overall complexity ,Okay this solution is really complicated and I would like to hear nicer approaches from you in comments if you have any However I still feel like it s ok to have this problem in a contest specifically as a harder version of F1 Let s start with the following thing Root the tree by some vertex For each color take all vertices of this color and paint their lowest common ancestor the same color as them The purpose of that will come clear later Why can we do this The case with lca some vertex of that color is trivial Now take a look at the edges from lca to its subtrees At least two of them contain a vertex of that color You can t cut the edges to these subtrees because this will make vertices of the same color belong to different components Thus lca will always be in the same component as these vertices If lca is already painted the other color then the answer is 0 That s because lca once again make vertices of the same color belong to different components Now everything will be calculated in a single dfs Let return one of the following values if there is no colored vertex in the subtree of if there exists some color such that vertex has vertices of color in its subtree and vertex has ancestors of color not necesserily direct parent otherwise I claim that if there are multiple suitable colors for some vertex then the answer is 0 Let s take a look at any two of them and call them colors and For both colors take a path from arbitrary vertex of that color in subtree to arbitrary vertex of that color that is ancestor of You can t cut any edge on these paths because that will divide the vertices of the same color Now either path for color contains vertex of color or path for color contains vertex of color That vertex is the upper end of the corresponding path That means that component of one color includes the vertex of the other color which is impossible Moreover that s the last specific check for the answer being 0 The step with lca helped us to move to the ancestor instead of any vertex in the upper subtree of I truly believe that you can avoid lca in this solution however that will make both implementation and proof harder Now let s do the number of ways to cut some edges in the subtree of so that 0 the component with vertex has no colored vertices in it 1 has some colored vertices Generally the color itself for 1 doesn t matter If for some child of returned color then it must be color in that component otherwise the color doesn t matter For all vertices of each color presented in the subtree of are contained within the subtree of The transitions will be of form do we cut the edge from to or not for all children of That is the most tedious part so I m sorry if I mess up something the way I did with my author solution DHere from now I ll ignore the children that returned if I say all children I will mean all non zero returning children as they add nothing to the answer If there are no children then the vertices with will have and the other vertices will have Basically there are two main cases I would recommend to follow the code in attachment while reading this tbh and all children dfs returned Then for each edge to the child you can either cut it if there are colored vertices take or don t cut it if it has no colored vertices take So For to have some color you ll need to push that color from exactly one of the children You can t choose two subtrees because they are guaranteed to have different colors in them otherwise they wouldn t return So To calculate that fast enough you ll need to precalculate prefix and suffix products of or but some children returned the same value Then you are required to make the part of component with vertices of color That means that for that case For children who returned you don t cut their edge take For the other children you can either cut it if there are colored vertices take or don t cut it if it has no colored vertices take Thus The answer will be stored in after that Overall complexity but I m sure this can be rewritten in such a manner that it becomes 
266,You are given an undirected graph without self loops or multiple edges which consists of vertices and edges Also you are given three integers and Can you label each vertex with one of three numbers or in such way that Each vertex should be labeled by exactly one number or The total number of vertices with label should be equal to The total number of vertices with label should be equal to The total number of vertices with label should be equal to for each edge where is the label of vertex If there are multiple valid labelings print any of them ,Let s rephrase the fifth condition Each edge should connect two vertices with the numbers of different parity either to or to So the graph should actually be bipartite and the first partition should have only the odd numbers or and the second partition should have only the even numbers only Notice how and are completely interchangeable in the sense that if you have exactly vertices which should be assigned odd numbers then you can assign whichever of them to and the rest to you want So you can guess that the first step is to check if the given graph is bipartite If it isn t then the answer doesn t exist It can be done with a single dfs Actually the algorithm for that extracts the exact partitions which comes pretty handy If the graph was a single connected component then the problem would be easy Just check if either the first partition or the second one has size and assigned its vertices color If neither of them are of size then the answer obviously doesn t exist However the issue is that there might be multiple connected components and for each of them you can choose the partition to assign to independently Still each of the connected components should be bipartite for the answer to exist This can be done with a knapsack like dp Let the th connected component have partitions of sizes Then the state can be is true if connected components are processed and it s possible to assign to exactly vertices of these components As for transitions for the th component you can either take the partition with vertices or with vertices Thus if is true then both of and are also true If is false then there is no answer Otherwise you can always restore the answer through the dp The easiest way is probably to store not true false in but three values for false for the case the state is reached by taking the first partition of the th component and for the second partition Also you should store not only the sizes of the partitions but the vertices in each of them as well This way you can recover the answer by backtracking from the final state Overall complexity ,Note a few things There are exactly vertices in the flower since from each of the vertices of the main cycle comes another cycle of size in the flower all vertices have degree except for the vertices of the main cycle whose degrees are it follows that in flower edges The listed properties do not take into account only the connectivity of the graph and the sizes of our cycles To check connectivity we run a bfs or dfs from any vertex and check that all vertices have been visited To check the cycle lengths we cut out the edges of the main one and make sure that the graph has fell apart into components of size 
267,There are cities in Berland Some pairs of cities are connected by roads All roads are bidirectional Each road connects two different cities There is at most one road between a pair of cities The cities are numbered from to It is known that from the capital the city with the number you can reach any other city by moving along the roads The President of Berland plans to improve the country s road network The budget is enough to repair exactly roads The President plans to choose a set of roads such that it is possible to travel from the capital to any other city along the chosen roads if is the number of roads needed to travel from the capital to city moving only along the chosen roads then is minimized i e as minimal as possible In other words the set of roads should preserve the connectivity of the country and the sum of distances from city to all cities should be minimized where you can only use the chosen roads The president instructed the ministry to prepare possible options to choose roads so that both conditions above are met Write a program that will find possible ways to choose roads for repair If there are fewer than ways then the program should output all possible valid ways to choose roads ,Use BFS to precalculate an array the array of the shortest path lengths from the Capital The condition to minimize sum of distances in each tree is equal to the fact that each tree is a shortest path tree Let s think about them as about oriented outgoing from the Capital trees Moving along edges of such trees you always move by shortest paths An edge can be included into such a tree if and only if since original edges are bidirectional you should consider each of them twice as and as Let s focus only on edges for which Call them red edges To build a tree for each city except the Capital you should choose exactly one red edge finishing in this city That s why the number of suitable trees is a product of numbers of incoming edges over all vertices cities But we need to find only of such trees Let s start from some such tree and rebuild it on each step As initial tree you can choose the first incoming red edge into each vertex except the City Actually we will do exactly increment operation for number in a mixed radix notation To rebuild a tree iterate over vertices and if the current used red edge is not the last for the vertex use the next and stop algorithm Otherwise the last red edge is used use the first red edge for this vertex and go to the next vertex and continue with the next vertex Compare this algorithm with simple increment operation for long number ,You can use straightforward way and calculate answer with l r dp with But there is a easier claim it s optimal to split gon with diagonals coming from so answer is Proof let s look at the triange which contains edge Let s name it If we can delete this triangle and go to gon Otherwise Let s look at triangle It always exists and Finally if we change pair of triangles to answer will decrease since and that s why Note that triangle changes to and so repeating this step will eventually lead us to situation As a result we can morph any triangulation into one mentioned above and its weight won t increase 
268,You are given a string consisting of lowercase Latin letters It is guaranteed that for some integer The string is called if of the following three conditions is satisfied The length of is and it consists of the character i e The length of is greater than the first half of the string consists of only the character i e and the second half of the string i e the string is a string The length of is greater than the second half of the string consists of only the character i e and the first half of the string i e the string is a string For example is is In one move you can choose one index from to and replace with any lowercase Latin letter any character from to Your task is to find the minimum number of moves required to obtain an string from i e for It is guaranteed that the answer always exists You have to answer independent test cases Another example of an string is as follows Consider the string It is an string because the second half of the string consists of only the character the first half of the string is string because the second half of the string consists of only the character the first half of the string is string because the first half of the string consists of only the character the second half of the string is string ,Consider the problem in 0 indexation Define the function calc l r c which finds the minimum number of changes to make the string s l dots r Let mid frac l r 2 Then let cnt l frac r l 2 count s l dots mid c calc mid r c 1 and cnt r frac r l 2 count s mid dots r c calc l mid c 1 where count s c is the number of occurrences of the character c in s We can see that cnt l describes the second condition from the statement and cnt r describes the third one So calc l r c returns min cnt l cnt r except one case When r l 1 we need to return 1 if s l ne c and 0 otherwise This function works in O n log n each element of s belongs to exactly log n segments like segment tree You can get the answer if you run calc 0 n a ,In this problem we can just iterate over all possible substrings and try to remove each of them After removing the substring we can check if remains the subsequence of in linear time Let we remove the substring Let s maintain a pointer the initial value of the pointer is and iterate over all possible from to If and let s increase by one If after all iterations then let s update the answer with the length of the current substring 
269,You are given a complete undirected graph with vertices A number is assigned to each vertex and the weight of an edge between vertices and is equal to Calculate the weight of the minimum spanning tree in this graph ,We can use Boruvka s algorithm to solve this problem This algorithm usually works in initially MST is empty and then we run a number of iterations During each iteration we find connected components in the graph formed by already added edges and for each component we find the shortest edge that leads out of this component Then we add the edges we found to the MST but we should be careful to avoid adding edges that form cycles in MST The number of iterations is at most and each of iterations can be done in However in this problem we need to speed up this algorithm We can do each iteration in time using a binary trie We can store all values from in a trie When we need to find the shortest edge that connects some component with vertices outside of it we firstly remove all values contained in this component from the trie After that for each vertex in the component we can find the closest vertex outside the component in by descending the trie And then we insert the values of belonging to the component back into the trie Since for each vertex we descend the trie three times to remove it to find closest vertex and to add it back each iteration requries and the whole algorithm works in time ,It s quite obvious that we can place bosses only on the bridges of the given graph if an edge is not a bridge then removing it doesn t make the graph disconnected so there still exists a path between any pair of vertices And if we fix two vertices and and then find some simple path between them then we will place the bosses on all bridges belonging to this path since the set of bridges would stay the same no matter which simple path between and we choose If we find bridges in the given graph and compress all 2 edge connected components two vertices belong to the same 2 edge connected component iff there exists a path between these vertices such that there are no bridges on this path into single vertices we will obtain a special tree called bridge tree Every edge of a bridge tree corresponds to a bridge in the original graph and vice versa Since we want to find the path with maximum possible number of bridges we only need to find the diameter of the bridge tree and this will be the answer to the problem 
270,You are given an array of elements you must make it a co prime array in as few moves as possible In each move you can insert any positive integral number you want not greater than in any place in the array An array is co prime if any two adjacent numbers of it are co prime In the number theory two integers and are said to be co prime if the only positive integer that divides both of them is ,Note that we should insert some number between any adjacent not co prime elements On other hand we always can insert the number ,The key observation is that the number is divisible by if and only if its last two digits forms a number divisible by So to calculate the answer at first we should count the substrings of length one Now let s consider pairs of consecutive digits If they forms a two digit number that is divisible by we should increase the answer by the index of the right one 
271,You are given a string consisting only of lowercase Latin letters You can rearrange all letters of this string as you wish Your task is to obtain a string by rearranging the letters of the given string or report that it is impossible to do it Let s call a string if it is not a palindrome Palindrome is a string which is read from left to right the same as from right to left For example strings and are palindromes and strings are not You have to answer queries ,The only case when the answer is is when all letters of the string are equal Why is it so Because if we have at least two different letters we can place the first one at the first position of the string and the second one at the last position of the string Then it is clearly that the obtained string is We can implement this solution by the following way sort and if the first letter equals to the last one then the answer is otherwise the answer is ,The answer is when in string there is a character that is not in string Otherwise let s precalculate the following array minimum index from to such that if there is no such index then Now we can solve this problem by simple greed Presume that now and last taken symbol in is Then there are two options if then if then and is equal to initially 
272,Yelisey has an array of integers If has length strictly greater than then Yelisei can apply an operation called to it First Yelisei finds the minimal number in the array If there are several identical minima Yelisey can choose any of them Then the selected minimal element is removed from the array After that is subtracted from each remaining element Thus after each operation the length of the array is reduced by For example if then the minimum element in it is which means that after this operation the array will be equal to Since Yelisey likes big numbers he wants the numbers in the array to be as big as possible Formally speaking he wants to make the of the numbers in array to be i e he want to maximize a minimum To do this Yelisey can apply the operation to the array as many times as he wants possibly zero Note that the operation cannot be applied to an array of length Help him find what maximal value can the minimal element of the array have after applying several possibly zero operations to the array ,Note that the order of numbers in the array does not affect anything If you swap two elements in the original array the set of elements at each step will not change in any way Let s sort the original array and denote it by We denote by the state of array after applying operations of The minimum element in is so the elements of array will be equal to and therefore the minimum of them will be Constructing an array we can notice that its elements are equal to We know that the elements of are the difference between corresponding elements of the array and so Thus the elements of the array are the differences between elements of starting with third and the minimum of which is It is not difficult to show in a similar way for example by induction that the elements of are equal to the minimum of which is So the candidates for the answer are simply differences of adjacent elements of the array Indeed if we look at it will undergo changes as follows You can notice that the minimum elements starting with after the first operation are exactly and respectively Thus to solve the problem it was sufficient to sort the array in ascending order then take the maximum of the original first element and the differences of all adjacent elements ,Let s replace each number with the number of unique numbers less than For example the array will be replaced by Note that the values of the numbers themselves were not important to us only the order between them was important Let s sort such an array Let s see what maximum length of the segment from the array is already sorted it forms a subsequence This segment can be left in place and all other numbers can be moved either to the beginning or to the end That is the task came down to finding the maximum sorted subsequence in the array This problem can be solved with the help of simple dynamic programming Let be the maximum length of a subsequence ending in position To calculate it we will find the closest past position which also has the value and the position with value lower numbers cannot be used since must stand between them Any of these positions can be extended so we take the maximum out of them and add 1 It is necessary to separately consider the first numbers in the subsequence and the last since the first should include their suffix and the last should have their prefix 
273,Let s call a permutation of length if the condition holds for all Recall that the permutation is the array of length which contains each integer from to exactly once Your task is for a given number print anti Fibonacci permutations of length ,Let s consider one of the possible solutions Let s put the first element in the th permutation equal to and sort all the other elements in descending order Thus we get permutations of the form In such a construction for all and hence ,Since a sequence of swaps denotes some permutation let s try to restore the permutation that was used to transform into and then get by applying inverse permutation If was or less then we could get just by asking one query send a string where no character occurs twice and the resulting positions of characters uniquely determine the permutation Unfortunately may be greater than but we can ask more than one query The main idea is the following for each index we may choose a triple of characters so all triples are distinct There are different triples and that s greater than so each index can be uniquely determined Then after we choose a triple for each index ask three queries as follows in the first query the th character of the string is the first character in the triple representing index in the second query we use the second characters from all triples and in the third query the third characters Let and be the strings we sent and and be the strings we received as answers The permutation maps index to index if and only if and because if some other index is mapped to then at least one of the aforementioned equalities is false since all triples of characters are distinct Using this fact we may recover the permutation 
274,Victor has a 24 hour clock that shows the time in the format He looks at the clock every minutes and the clock is currently showing time How many palindromes will Victor see in total after looking at the clock every minutes the first time being at time For example if the clock starts out as and Victor looks at the clock every minutes i e every hours then he will see the times and the times will continue to repeat Here the time is the only palindrome he will ever see so the answer is A palindrome is a string that reads the same backward as forward For example the times are palindromes but are not ,Note that Victor looks at the clock forever but there are only at most different times the clock can show because there are different minutes in a day So we only have to check the first times Victor sees and count the palindromes you can check a few more just to be safe but they will repeat anyways Now we just have to implementing adding minutes to a clock There are several ways to do this One of the slower ways might be writing functions converting a number of minutes into a time for a clock or you can just compute all palindrome times in terms of minutes and that way you don t have to convert from clock time to number of minutes The complexity is per test case since you only have to check a constant number of times ,Let s handle some cases Firstly if then Polycarp wakes up rested enough immediately so is the answer Otherwise what does Polycarp do He sets alarm to go off in minutes and falls asleep in minutes Thus he spends minutes sleeping Notice that if is non positive then Polycarp always resets his alarm without sleeping So for that case the answer is Finally if Polycarp resets his alarm times then he ends up with minutes of sleep in total and ends up spending minutes of time We know that should be greater or equal to and should be the smallest possible Thus the smallest possible integer is equal to And the answer is Overall complexity per testcase 
275,You are given segments on the coordinate axis and the number The point is if it belongs to at least segments Find the smallest by the number of segments set of segments on the coordinate axis which contains all points and no others ,Let s create two events for each segment li is the time of the segment opening and ri is the time of the segment closing Let s sort all events by time if the times are equal let s sort them with priority to opening events In C it can be done with sorting by standard comparator of vector pair int int events where each element of events is the pair with event time and event type 1 for opening and 1 for closing Let s iterate over events and maintain the balance To do that we should simply decrease the balance by the value of the event type Now if the balance value equals to k and before updating it was k 1 then we are in the left end of some segment from the answer If the balance equals to k 1 and before updating it was k then we are in the right end of the segment from the answer Let s simply add segment left right to the answer So now we have disjoint set of segments contains all satisfied points in order from left to right Obviously it s the answer to the problem Complexity O nlogn ,The main idea of the solution is to calculate the following dynamic programming is the maximum prefix we can fully cover with first lanterns Let s look at how can we solve it in with this kind of dynamic programming First of all let s write it forward Which transitions from do we have iterate on the lantern facing left that will cover the lantern Let this lantern be It should cover all lanterns in so all lanterns from can be turned to the right and we need a max query to determine the new covered prefix if lantern is already covered we can just extend the prefix by turning the th lantern to the right Note that turning it to the right when it is not covered yet will be modeled by the first transition It is obviously how can we optimize it Let s write this dynamic programming backward The second transition is changed to backward dp easily what about the first one Suppose we want to turn some lantern to the left Let s iterate on the prefix that we will connect to it for this prefix should be at least and we update with the maximum of since it is covered by lantern and the result of max query on In fact we need only one such prefix the one with the minimum among those which have So we build a minimum segment tree where each pair is interpreted as the value of in position and with min query on the suffix from we find this optimal prefix from which we should update and to update we can use any DS that allows max queries on segment in my solution it s another segment tree 
276,The king of Berland organizes a ball pair are invited to the ball they are numbered from to Each pair consists of one man and one woman Each dancer either man or woman has a monochrome costume The color of each costume is represented by an integer from to inclusive Let be the color of the man s costume and be the color of the woman s costume in the th pair You have to choose a color for each dancer s costume i e values and in such a way that for every and are integers between and inclusive there are no two completely identical pairs i e no two indices such that and at the same time there is no pair such that the color of the man s costume is the same as the color of the woman s costume in this pair i e for every for each two consecutive adjacent pairs both man s costume colors and woman s costume colors differ i e for every from to the conditions and hold Let s take a look at the examples of bad and good color choosing for and man is the first in a pair and woman is the second Bad color choosing contradiction with the second rule there are equal pairs contradiction with the third rule there is a pair with costumes of the same color contradiction with the fourth rule there are two consecutive pairs such that colors of costumes of men women are the same Good color choosing You have to find suitable color choosing or say that no suitable choosing exists ,The first observation we cannot construct more than pairs at all due to second and third rules The second observation we always can construct an answer which will contain all pairs and get some prefix of this answer if we need less than pairs Ho do we do that Let man s costumes colors be in the following order and so on Now we have to set some colors to woman s costumes The first thing comes to mind is to use some cyclic shift of And it is the best thing we can do So let women s costumes colors be in the following order ans so on So we use each cyclic shift of in order from second to last The maximum number of pairs can be obtained when and the number of such pairs is So now we have to prove that second third and fourth rules are satisfied or write a stress test it is not so hard to do it The easiest way to prove all rules are satisfied is the following if some element in the left part has position let s consider all positions modulo then each element in the right part will have all positions expect in order you can see it from our placement Now we can see that all rules are satisfied because of such a placement ,Easy to see that we can paint with both colours only tiles with the numbers multiple of Obviously that tiles should be painted with more expensive colour So the answer equals to 
277,Let s call a positive integer if it has only one non zero digit For example are extremely round integers are not You are given an integer You have to calculate the number of extremely round integers such that ,There are many ways to solve this problem The most naive one iterating through all numbers from to in each test case and checking if they are extremely round fails since it is but you can optimize it by noticing that extremely round numbers are rare So for example we can iterate through all numbers from to once remember which ones are extremely round store them into an array and while answering the test case only check the numbers from the array we have created There is also a solution in per test case with a formula try to invent it yourself ,Let s rewrite the original equality a bit a j a i j i a j j a i i Let s replace each a i with b i a i i Then the answer is the number of pairs i j such that i j and b i b j To calculate this value you can use or sorting 
278,You are given an integer represented as a product of its divisors Let be the set of positive integer divisors of including and itself We call a set of integers if and only if there is no pair such that and divides Find a subset of with maximum possible size Since the answer can be large print the size of the subset modulo ,The problem consists of two parts what do we want to calculate and how to calculate it What do we want to calculate There are several ways to figure it out At first you could have met this problem before and all you need is to remember a solution At second you can come up with the solution in a purely theoretical way Hasse diagram can help with it greatly Let s define as the number of primes in prime factorization of For example and If you look at Hasse diagram of you can see that all divisors with lies on level If is divisible by then so all divisors on the same level don t divide each other Moreover the diagram somehow symmetrical about its middle level and sizes of levels are increasing while moving to the middle It gives us an idea that the answer is the size of the middle level i e the number of divisors with The final way is just to brute force the answers for small s and find the sequence in OEIS with name A096825 where the needed formulas are described The second step is to calculate the number of divisors with Suppose we have distinct primes and the number of occurences of is equal to Then we need to calculate pretty standard knapsack problem where you need to calculate number of ways to choose subset of size where you can take each up to times Or formally number of vectors with and Calculating the answer using will lead to time limit so we need to make the following transformation Let s build for each a polynomial Now the answer is just a coefficient before in product Note that the product has degree so we can multiply polynomials efficiently with integer FFT in the special order to acquire time complexity There several ways to choose the order of multiplications At first you can at each step choose two polynomials with the lowest degree and multiply them At second you can use the divide and conquer technique by dividing the current segment in two with pretty same total degrees At third you can also use D n C but divide the segment at halves and it seems still to be in total What about the proof of the solution Thanks to tyrion for the link at the article https pure tue nl ws files 4373475 597494 pdf The result complexity is time and space if carefully written Note that the hidden constant in integer FFT is pretty high and highly depends on the implementation so it s possible for poor implementations not to pass the time limit ,Let s iterate over all possible values of from to It is obvious that cannot be bigger than else we can just move to Then let s iterate over all possible multiples of from to Let this number be Then we can find as the nearest number to that is divisible by we can check two nearest numbers to be sure These numbers are and Then we can update the answer with the found triple Note that the only condition you need to check is that Time complexity because of the sum of the harmonic series 
279,You are given a string consisting of brackets of two types and A string is called a regular bracket sequence RBS if it s of one of the following types empty string RBS RBS RBS RBS where plus is a concatenation of two strings In one move you can choose a non empty subsequence of the string not necessarily consecutive that is an RBS remove it from the string and concatenate the remaining parts without changing the order What is the maximum number of moves you can perform ,Notice that it s never optimal to erase a subsequence of length greater than because every RBS of length above contains an RBS of length inside and removing it won t break the regular property of the outside one So the task can be solved for the round and the square brackets independently the answer will be the sum of both Let s solve the version for brackets and In general you just want to remove consecutive substring until there is no more left in the string That can be done by processing the string from left and right and maintaining a stack of current brackets If the top bracket in it is and the current bracket is then you can increment the answer and remove that bracket from the stack Otherwise you push the current bracket to the stack Overall complexity per testcase ,The key observation is that since is only up to 20 there can t be that many different prime strings total turns out there are only about 2400 for the worst case of So we can generate all of them and perform a DP where our state is represented by the longest prefix of any of the strings we currently match We can do this by building a trie of all of the prime strings We then need to be able to transition around in this trie it turns out this is exactly what Aho Corasick does for us In particular knowing which node of the Aho Corasick tree we are currently at gives us the full information we need to determine whether or not we will match one of the strings after adding more characters later This leads to a fairly simple DP 90977148 
280,A string is called if it does not contain any characters other than and A bracket sequence is called if it it is possible to obtain correct arithmetic expression by inserting characters and into this sequence For example and are regular bracket sequences and are bracket sequences but not regular ones and and are not bracket sequences at all You have a number of strings each string is a bracket sequence of length So overall you have strings strings strings and strings You want to write all these strings in some order one after another after that you will get a long bracket sequence of length You wonder is it possible to choose some order of the strings you have such that you will get a regular bracket sequence ,For bracket sequence to be regular it should have equal number of opening and closing brackets So if then it s impossible to construct any regular bracket sequence is completely irrelevant to us since inserting or removing a substring doesn t change the status of the string we get Almost the same applies to but we should have at least one substring before it So if but there is no solution In all other cases it is possible to order all strings as follows all strings then all strings then all strings then all strings ,On every step you should maintain minimal alphabetic letter in current string this can be done by keeping array of 26 cells with number of times each letter appear in string nd updating it on every step Let s call string a stack and use its terms Now you extract letters from one by one Put the letter to the top of the stack Pop letters from the top of stack and push them to answer while they are less or equal than any letter left in string After string becomes empty push all the letters from stack to answer The answer will be lexicographically minimal It is obvious if we consider the case when current top of stack is strictly greater than any character from the remaining string or there is a character in that is strictly less than current top If current top is equal to some character then appending answer with the letter from top won t make answer worse Overall complexity where is the length of the alpabet in our case 
281,There are block towers numbered from to The th tower consists of blocks In one move you can move one block from tower to tower but only if That move increases by and decreases by You can perform as many moves as you would like possibly zero What s the largest amount of blocks you can have on the tower after the moves ,Notice that it never makes sense to move blocks between the towers such that neither of them is tower 1 as that can only decrease the heights Moreover it never makes sense to move blocks away from the tower 1 Thus all operations will be moving blocks from some towers to tower 1 At the start which towers can move at least one block to tower 1 Well only such i that a i a 1 What happens after you move a block Tower 1 becomes higher some tower becomes lower Thus the set of towers that can share a block can t become larger Let s order the towers by the number of blocks in them At the start the towers that can share a block are at the end on some suffix in this order After one move is made the towers get reordered and the suffix can only shrink Ok but if that suffix shrinks what s the first tower that will become too low The leftmost one that was available before So regardless of what the move is the first tower that might become unavailable is the leftmost available tower Thus let s attempt using it until it s not too late The algorithm then is the following Find the lowest tower that can move the block to tower 1 move a block repeat When there are no more towers higher than tower 1 the process stops However the constraints don t allow us to do exactly that We ll have to make at most 10 9 moves per testcase Ok let s move the blocks in bulk every time Since the lowest available tower will remain the lowest until you can t use it anymore make all the moves from it at the same time If the current number of blocks in tower 1 is x and the current number of blocks in that tower is y lceil frac y x 2 rceil blocks can be moved You can also avoid maintaining the available towers by just iterating over the towers in the increasing order of their height Overall complexity O n log n per testcase ,The idea of this solution is the same as in the easy version but now we need to do the same sequence of moves faster We can notice that the smartphone screen works as a queue so let store it as a queue When the new message appears we have to check if the friend with this ID is in the queue already but we need to check it somehow fast Let s use some logarithmic structure that stores the same information as the queue but in other order to find add and remove elements fast In C this structure is So let s check if the current friend is in the queue and if no let s check if the size of the queue is If it is so then let s remove the first element of the queue from it and the same element from the set also Then add the current friend to the queue and to the set After processing all messages the reversed queue the queue from tail to head is the answer to the problem Time complexity And don t forget that and other standard hashmaps can work in linear time in the worst case so you need to redefine the hash function to use them You can read more about this issue here https codeforces com blog entry 62393 
282,You are given a matrix consisting of rows and columns Each cell contains an integer in it You can change the order of rows arbitrarily including leaving the initial order but you can t change the order of cells in a row After you pick some order of rows you traverse the whole matrix the following way firstly visit all cells of the first column from the top row to the bottom one then the same for the second column and so on During the traversal you write down the sequence of the numbers on the cells in the same order you visited them Let that sequence be The traversal is acceptable if for all Find the maximum integer such that there exists some order of rows of matrix that it produces a acceptable traversal ,Really low constraints choosing some permutation Surely this will be some dp on subsets At first let s get rid of For each two rows calculate the minimum difference between the elements of the same columns let s call this for some rows This will be used to put row right after row Let s also calculate the minimum difference between the elements of the column of row and column of row This will be used to put row as the last row and row as the first one Now let s think of choosing the permutation as choosing the traversal of the following graph Vertices are rows and the weights of edges between the vertices are stored in However you can t straight up do minimum weight Hamiltonian cycle search as the edge between the first vertex and the last one should be of weight from and not Let s fix some starting vertex and find minimum weight Hamiltonian paths from it to all vertices Finally update the answer with That will lead to approach minimum weight Hamiltonian path is a well known problem solved by That s completely fine and it s the most intended solution However there exist another solution that would have worked better if the edge weight were a bit smaller Let s do binary search each time checking if the answer is greater or equal to The check is simple enough Now the graph is binary edge exists if its weight is greater or equal to thus you should check for existence of Hamiltonian path not for the minimum weight one That can be done in leading to solution The key idea of that dp is storing the vertices where the path of the current mask could have ended as a mask itself Then it becomes with transitions Overall complexity or ,I am sorry that some solutions pass tests in this problem also I was supposed to increase constraints or decrease time limit The general idea of this problem is the same as in the previous problem But now we should do all what we were doing earlier faster The solution is divided by two parts The first part Let s calculate four matrices of size and will denote the distance to the nearest dot character to the top from the current position The same will denote the distance to the nearest dot character to the bottom from the current position to the left and to the right We can calculate all these matrices in using easy dynamic programming If we will iterate over all possible from to and from to we can easy see the next if the current character is dot then Otherwise if then and if then Rest two matrices can be calculated the as well as these two matrices but we should iterate over all from to and from to So this part of the solution works in After calculating all these matrices the maximum possible length of rays of the with center in position is The second part is to draw all in Let s calculate another two matrices of size and Let s iterate over all in our answer Let the center of the current is and its size is Let s increase by one and decrease by one if The same with the matrix Increase and decrease if Then let s iterate over all possible from to and from to If then set and if set How to know that the character at the position is asterisk character or dot character If either or greater than zero then the character at the position in our matrix will be the asterisk character Otherwise it is the dot character This part works also in Time complexity of the solution 
283,There are famous Russian nesting dolls named matryoshkas sold in one of the souvenir stores nearby and you d like to buy several of them The store has different matryoshkas Any matryoshka is a figure of volume with an empty space inside of volume of course You don t have much free space inside your bag but fortunately you know that matryoshkas can be nested one inside another Formally let s call a set of matryoshkas if we can rearrange dolls in such a way that the first doll can be nested inside the second one the second doll inside the third one and so on Matryoshka can be nested inside matryoshka if So only the last doll will take space inside your bag Let s call of a nested set of dolls as a total volume of empty space inside this structure Obviously it s equal to where are the indices of the chosen dolls in the order they are nested in each other Finally let s call a nested subset of the given sequence as if there isn t any doll from the sequence that can be added to the nested subset without breaking its nested property You want to buy many matryoshkas so you should choose a nested subset to buy it But you will be disappointed if too much space in your bag will be wasted so you want to choose a big enough subset so that its is minimum possible among all big enough subsets Now you wonder how many different nested subsets meet these conditions they are big enough and there is no big enough subset such that its extra space is less than the extra space of the chosen subset Two subsets are considered different if there exists at least one index such that one of the subsets contains the th doll and another subset doesn t Since the answer can be large print it modulo ,Let s at first sort all matryoshkas by increasing its inner volume in i Then each nested subset will appear as subsequence in its canonical order Now we ll write the DP with d i x y the minimum extra space x and number of such subsequences y among all nested subsets where the i th doll is Why minimal not maximal for example It s just easier transitions and easier proof There are two main cases If there isn t j such that out i le in j then we can t put the i th doll inside any other So d i in i 1 Otherwise we must put the i th doll inside other doll otherwise the subset won t be a big enough If we put the i th doll inside the j th doll then we extra space of such subset is equal to d j first out i in i Since we minimize the extra space then d i first min limits out i le in j d j first out i in i min limits out i le in j d j first out i in i Since we sorted all matryoshkas so there is a position pos such that forall j ge pos out i le in j and d i first min limits j pos n d j first out i in i The d i second is just a sum from all minimums As you can see we can store d i in Segment Tree with minimum number of minimums Why in the second transition we will build only subsets It s because not big enough subsets are not optimal in terms of minimality of extra space The result complexity is O n log n ,Let s divide all segments to four classes The first class contains segments which covers both minimum and maximum values the answer of the resulting array the second class contains segments which covers only minimum value of the resulting array the third class contains segments which covers only maximum value of the resulting array and the fourth class contains segments which covers neither maximum nor minimum of the resulting array We can easy see that we cannot increase the answer if we apply segments of first and third classes What is common in this two classes Right both of them are cover maximum value So we can came up with the solution in or depends on implementation Let s iterate over position of the supposed maximum value and apply all segments which not cover it It can be done in with straight forward implementation or in using prefix sums After we apply all needed segments we can try to update the answer with the value of the obtained array 
284,You are playing a computer game where you lead a party of soldiers Each soldier is characterised by his agility The level you are trying to get through can be represented as a straight line segment from point where you and your squad is initially located to point where the boss is located The level is filled with traps Each trap is represented by three numbers and is the location of the trap and is the danger level of the trap whenever a soldier with agility lower than steps on a trap that is moves to the point he gets instantly killed Fortunately you can disarm traps if you move to the point you disarm this trap and it no longer poses any danger to your soldiers Traps don t affect you only your soldiers You have seconds to complete the level that is to bring some soldiers from your squad to the boss Before the level starts you choose which soldiers will be coming with you and which soldiers won t be After that you have to bring to the boss To do so you may perform the following actions if your location is you may move to or This action consumes one second if your location is and the location of your squad is you may move to or to with your squad in one second You may not perform this action if it puts some soldier in danger i e the point your squad is moving into contains a non disarmed trap with greater than agility of some soldier from the squad This action consumes one second if your location is and there is a trap with you may disarm this trap This action is done instantly it consumes no time Note that after each action both your coordinate and the coordinate of your squad should be integers You have to choose the maximum number of soldiers such that they all can be brought from the point to the point where the boss waits in no more than seconds ,When we fix a set of soldiers we can determine a set of traps that may affect our squad these are the traps with danger level greater than the lowest agility value So we can use binary search on minimum possible agility of a soldier that we can choose How should we actually bring our soldiers to the boss Each trap that can affect our squad can be actually treated as a segment such that our squad cannot move to until we move to and disarm this trap We should walk through such segments for three times the first time we walk forwards without our squad to disarm the trap the second time we walk backwards to return to our squad and the third time we walk forwards with our squad So the total time we have to spend can be calculated as where is the number of unit segments belonging to at least one trap segment and it can be calculated with event processing algorithms or with segment union Time complexity is or but it is possible to write a solution in without binary search ,Mouse jumps on a cycle at some point no matter the starting vertex thus it s always the most profitable to set traps on cycles The structure of the graph implies that there are no intersecting cycles Moreover mouse will visit each vertex of the cycle so it s enough to set exactly one trap on each cycle The only thing left is to find the cheapest vertex of each cycle This can be done by a simple dfs Overall complexity 
285,You are given a simple weighted connected undirected graph consisting of vertices and edges A path in the graph of length is a sequence of vertices such that for each the edge is present in the graph A path from some vertex also has vertex Note that edges and vertices are allowed to be included in the path multiple times The weight of the path is the total weight of edges in it For each from to consider a path from vertex of length of the maximum weight What is the sum of weights of these paths Answer can be quite large so print it modulo ,Let s observe what does the maximum weight of some fixed length path look like Among the edges on that path the last one has the maximum weight If it wasn t then the better total weight could be achieved by choosing a bigger weight edge earlier and going back and forth on it for the same number of steps It actually helps us arrive to a conclusion that all optimal paths look like that some simple path to an edge and then back and forth movement on it Any simple path in the graph has its length at most Let s separate the queries into two parts will be handled in a straightforward manner Let be the maximum weight of a path that ends in and has exactly edges in it That s pretty easy to calculate in You can also think of this as some kind of Ford Bellman algorithm let on the th step be the maximum weight of the path to of length Iterate over all edges and try to update and for each edge that s what I do in my solution if you refer to it Now for There was a very common assumption that after a bit more steps some edge will become the most optimal and will stay the most optimal until the end of time However that a bit cut off is in fact too high to rely on it must be somewhere around So the best path of length exactly ending in each vertex is Let the maximum weight adjacent edge to vertex be So the path of length will have weight Treat it like a line with coefficients and How do determine which line is the best for some Sure experienced participants will immediately answer convex hull Build a lower envelope of the convex hull of these lines If was a little smaller than we could query with binary search for each the same how convex hull is usually used We have to examine the hull further Each line in it becomes the best in some point then stays the best for some interval and then never appears the best again What are these line changing points Well it s just the intersection point of the adjacent lines in the hull So having these points and the parameters of the line we can calculate its contribution to the answer with a sum of arithmetic progression formula There were just lines in the hull so you can build the hull in any complexity I think I saw up to performances in the participants codes There is a cool solution that involves some kind of Divide Conquer on these lines I personally thought of it in a sense of traversing a Li Chao tree without actually building it If anyone wants to explain this solution feel free to do it in comments Overall complexity ,At first when we read the problem a simple solution comes to our mind take a look at the LCA Lowest Common Ancestor of that starting and ending vertices of the path and then use combinatorics to calculate the number of the paths but after trying to implement this or solve this on paper it doesn t seem to be easy at all and it may even be impossible to implement this So lets try to solve this problem in a different way For calculating the answer we count the number of times each path starts or ends at every vertex and then divide them by to get the answer for each vertex For calculating the answer to the above it is easy to see that all vertices with the same height have the same number of paths going through them so if we calculate the number of paths going through one of them and then multiply it by the number of the vertices in that height let it be it gets equal to our answer We can calculate the answer for a certain height So to do that we divide the paths into two types paths that go only into the subtree of a vertex let s call it and paths that go up let s call it For the ones that are in the subtree it is easy to see if there are at least other vertices that go down we can go all paths going down let the number of them be and the answer for this part equals to For the ones that go up we use dynamic programming and we define the number of paths that start at a vertex with height and have length and do not use the leftmost edge exiting the vertex at height To update this either we go down on one of the paths and then we go through a path of length or we go up and get a path of length starting at a vertex from height so the answer for this one equals to Now And the final complexity of the solution will be but because of the large constant of the solution the time limit is higher 
286,A string is called if it contains consecutive adjacent letters of the Latin alphabet and each letter occurs exactly once For example the following strings are diverse and The following string are diverse and Note that the letters and are not adjacent Formally consider positions of all letters in the string in the alphabet These positions should form contiguous segment i e they should come one by one without any gaps And all letters in the string should be distinct duplicates are not allowed You are given a sequence of strings For each string if it is diverse print Otherwise print ,The string is diverse if it is a permutation of some substring of the Latin alphabet In other words the string is diverse if all letters in it are distinct we can check it using some structure like or array of used elements and if the number of letters between the letter with the maximum alphabet position and the letter with the minimum alphabet position plus one is exactly the length of the string For example the position in alphabet of letter is one the position of letter is six and so on ,The answer is when in string there is a character that is not in string Otherwise let s precalculate the following array minimum index from to such that if there is no such index then Now we can solve this problem by simple greed Presume that now and last taken symbol in is Then there are two options if then if then and is equal to initially 
287,You are given two integers and Your task is to find if can be represented as a sum of not divisible by integers or not You have to answer independent test cases ,First of all notice that the sum of the first odd integers is If then the answer obviously And if then the answer is also is modulo operation Otherwise the answer is always and it seems like this where It is obviously greater than because and it is obviously odd because the parity of and is the same ,Note that every ordinary number can be represented as Therefore to count all ordinary numbers among the numbers from to it is enough to count the number of pairs such that In the given constraints it is enough to iterate over from to and from to 
288,In Berland there are two types of coins having denominations of and burles Your task is to determine whether it is possible to represent burles in coins i e whether there exist non negative integers and such that ,Note that 2 coins with denomination k can be replaced with k coins with denomination 2 So if the answer exists then there is also such a set of coins where there is no more than one coin with denomination k Therefore it is enough to iterate through the number of coins with denomination k from 0 to 1 and check that the remaining number is non negative and even i e it can be represented as some number of coins with denomination 2 ,If Vasya has coins of burles then he can collect amounts of burls If Vasya does not have burles coins then he cannot collect the amount of burle If he has at least one coin in burl he can score odd amounts up to The following burl coins increase the maximum amount he can make If Vasya has coins for burle he can make up the amount of burles and not anymore 
289,Polycarp is very fond of playing the game Minesweeper Recently he found a similar game and there are such rules There are mines on the field for each the coordinates of its location are known Each mine has a lifetime in seconds after which it will explode After the explosion the mine also detonates all mines vertically and horizontally at a distance of two perpendicular lines As a result we get an explosion on the field in the form of a plus symbol Thus one explosion can cause new explosions and so on Also Polycarp can detonate anyone mine every second starting from zero seconds After that a chain reaction of explosions also takes place Mines explode and also detonate other mines according to the rules described above Polycarp wants to set a new record and asks you to help him calculate in what minimum number of seconds all mines can be detonated ,Our first task is to separate mines into components We will store in the hashmap at the coordinate all the coordinates where there is a mine Let s do the same with the hashmap Thus going through the available arrays in and we connect adjacent elements into one component if also with As a result we have components where if you detonate one mine in the s component then all the mines belonging to this component will also explode Further we find a mine with a minimum timer in each component Finding the minimum for each component we store it conditionally in the array Now we know at what minimum time some component will explode if it is left unaffected To answer it remains to find in the sorted array such a minimum index that is min And the general asymptotic behavior is ,Lets divide all dealing blows into two parts the last blow and others blows The last hit should be with maximum value of The others blows should be with the maximum value of So lets denote as and as Then if the we can beat Zmei Gorynich with one blow Otherwise if then we cannot defeat Zmei Gorynich Otherwise if and the answer is 
290,There are one cat mice and one hole on a coordinate line The cat is located at the point the hole is located at the point All mice are located between the cat and the hole the th mouse is located at the point At each point many mice can be located In one second the following happens First mouse moves to the right by If the mouse reaches the hole it hides i e the mouse will not any more move to any point and will not be eaten by the cat Then the mouse has finished its move the cat moves to the right by If at the new cat s position some mice are located the cat eats them they will not be able to move after that The actions are performed until any mouse hasn t been hidden or isn t eaten In other words the first move is made by a mouse If the mouse has reached the hole it s saved Then the cat makes a move The cat eats the mice located at the pointed the cat has reached if the cat has reached the hole it eats nobody Each second you can select a mouse that will make a move What is the maximum number of mice that can reach the hole without being eaten ,Let s solve the problem using a linear search Let be the number of mice we are trying to save Then it is more efficient to save mice such that they are the closest ones to the hole Let be the distance from the th mouse to the hole Denote Let s prove that these mice will be saved if and only if The necessary condition Suppose we can save the mice and Since only one mouse can be moved in one second the following will happen of mice will already be saved and one mouse will have to be saved When it s been seconds then the distance from the cat to the hole will be equal to and the distance from the mouse to the hole will be equal to since all other mice are already in the hole their distances to the hole are equal to so the sum of the distances from all mice to the hole at the current time is exactly equal to the distance to the hole from one remaining mouse Since the distance from the mouse to the hole is greater than or equal to the distance from the cat to the hole But this cannot be because both the mice and the cat move only to the right and all mice met by the cat are eaten So Sufficient condition Suppose If then all the mice are already in the hole i e they are saved Suppose Let s move any mouse then the cat Suppose the cat ate at least one of the mice This mouse is definitely not the one that was moved Then the distance from it to the eaten mouse was equal to i e the distance from it to the hole was equal to the distance from the eaten mouse to the hole plus The distance from the moved mouse to the hole was at least So where is the distance from the eaten mouse to the hole is the distance from the moved mouse to the hole So but it s false Therefore none of the mice will be eaten on the first move Then the distance from the cat to the hole will be equal to the total distance from the mice to the hole will be equal to i e now we have to solve a similar problem for smaller and So will be gradually decreased to while no mouse will be eaten So if all the mice will be saved Thus to solve the problem we need to find the maximum such that the sum of the distances from the nearest mice to the hole is less than ,We can add or subtract until the difference between and becomes less than And if it is not after all such moves we need one additional move Let is the absolute difference between and The final answer is plus one if This formula can be represented as divided by rounded up in other words 
291,Alice and Bob are playing a game The game involves splitting up game pieces into two teams There are pieces and the th piece has a strength The way to split up game pieces is split into several steps First Alice will split the pieces into two different groups and This can be seen as writing the assignment of teams of a piece in an character string where each character is or Bob will then choose an arbitrary prefix or suffix of the string and flip each character in that suffix i e change to and to He can do this step at most once Alice will get all the pieces marked and Bob will get all the pieces marked The strength of a player is then the sum of strengths of the pieces in the group Given Alice s initial split into two teams help Bob determine an optimal strategy Return the maximum strength he can achieve ,Let s calculate the prefix sums for all numbers and store it in array and for numbers with letter B and store it in array Now we can find the sum of all numbers in any segment in time and the sum of numbers with letter B Let s iterate over prefix or suffix to flip and calculate the sum in that case by formulas for prefixes and for suffixes ,Note that numbers of the same length are compared lexicographically That is until some index the numbers will match and then the digit in our number should be greater Let s write out the numbers until As soon as this condition is false or the line ends insert the digit We got the lexicographically maximum number which means just the maximum number 
292,You have red and blue beans You d like to distribute them among several maybe one packets in such a way that each packet has at least one red bean or the number of red beans has at least one blue bean or the number of blue beans the number of red and blue beans should differ in no more than or Can you distribute all beans ,Without loss of generality let s say otherwise we can swap them Note that you can t use more than packets at least one red bean in each packet so can t exceed at most blue beans in each packet So if then asnwer is Otherwise we can form exactly packets ,Every beautiful set can be represented as a sequence of its elements in sorted order Let these elements for some set be also let When the set is beautiful every is an integer greater than It s easy to see that if and belong to the whole set belongs to Since in order to maximize we need to choose and as small as possible So why don t we choose and every This will allow us to calculate the maximum possible size of a beautiful set let be this maximum possible size Okay what about counting those sets The claims and that every are no longer true by default However there are some constraints on Firstly every If we had some value of we could replace it with two values of and the size of the set would increase Secondly there is at most one If there are two values we could replace them with three and the size of the set would increase as well So the sequence contains at most one value and the rest of the values are We will divide the sets we want to count into two categories the ones with all and the ones with one value To count the sets in the first category we simply need to count the number of different minimum values in those sets Those minimum values have to be such that multiplying them by wouldn t make them greater than so these are all integers from the segment For every such integer there exists exactly one set of the first category To count the sets in the second category we do a similar thing The minimum value in the set should be from the segment but for every integer from this segment there are different sets of the second category since there are ways to choose which is equal to 
293,You are given an undirected unweighted connected graph consisting of vertices and edges It is guaranteed that there are no self loops or multiple edges in the given graph Your task is to find spanning tree of this graph such that the maximum degree over all vertices is maximum possible Recall that the degree of a vertex is the number of edges incident to it ,We can take vertex with the maximum degree and all its neighbours To implement it just run from vertex with the maximum degree See the authors solution for better understanding ,Let s denote a way to distribute numbers as a Let s also call the paintings that meet the constraints paintings and all other paintings are bad We can solve the problem for each connected component of the graph independently and multiply the answers Let s analyze a painting of some connected component If some vertex has an odd number written on it then we should write even numbers on all adjacent vertices and vice versa So in fact we need to check if the component is bipartite and if it is divide it into two parts The number of good paintings is where is the size of the first part and is the size of the second part because we write s into all vertices of one part and s or s into all vertices of another part 
294,You are playing the game Arranging The Sheep The goal of this game is to make the sheep line up The level in the game is described by a string of length consisting of the characters empty space and sheep In one move you can move any sheep one square to the left or one square to the right if the corresponding square The game ends as soon as the sheep are lined up that is there should be no empty cells between any sheep For example if and the level is described by the string then the following game scenario is possible the sheep at the position moves to the right the state of the level the sheep at the position moves to the right the state of the level the sheep at the position moves to the right the state of the level the sheep at the position moves to the right the state of the level the sheep at the position moves to the right the state of the level the sheep are lined up and the game ends For a given level determine the minimum number of moves you need to make to complete the level ,Let s denote by the number of sheep in the string and by their positions in the string Note that in the optimal solution the sheep with the number will not make moves This can be proved by considering the optimal solution in which the sheep with the number makes at least one move and come to the conclusion that this solution is not optimal Consider sheep with numbers from to Then the final position of the th sheep will be and the answer will be ,Let s take a look at a naive approach for each query you iterate over positions and check if Okay this is obviously Now we notice that there are only positions for to start from we can calculate if there is an occurrence of starting in this position beforehand in Thus we transition to solution Finally we calculate a partial sum array over this occurrence check array and answer each query in Overall complexity 
295,Polycarp was presented with some sequence of integers of length A sequence can make Polycarp happy only if it consists of numbers i e distinct numbers In order to make his sequence like this Polycarp is going to make some possibly zero number of moves In one move he can remove the first leftmost element of the sequence For example in one move the sequence will produce the sequence which consists of different numbers Determine the minimum number of moves he needs to make so that in the remaining sequence all elements are different In other words find the length of the smallest prefix of the given sequence after removing which all values in the sequence will be unique ,Let s turn the problem around we ll look for the longest suffix that will make Polycarp happy since it s the same thing Let s create an array in which we will mark the numbers already encountered Let s go along from right to left and check if does not occur to the right in this case it is marked in if it occurs to the right then removing any prefix that does not include we get an array where occurs twice so we have to delete prefix of length ,There are many different approaches to this problem dynamic programming binary search greedy two pointers anything you want The model solution uses an approach based on binary search so I ll describe it First of all why does binary search work Let s say that the number of s is If the cost of deletion is then we have deleted at most characters and have left at most characters Let s increase the number of characters we delete from the prefix of the string until the number of deleted s becomes if it s always possible So if we consider the segment of values the fact that we can get cost implies that we can get cost so we can use binary search on segment to find the minimum achievable cost Now how to check if we can obtain the cost of deletion equal to One possible way to do this is to form an array where is the position of the th character in the string and find the minimum value of in this array the string that should remain has to contain at least characters and the minimum value of is the minimum possible length of such string Then we can find the number of s in this string and check if it is greater than or not 
296,Polycarp has tasks Each task is designated by a capital letter of the Latin alphabet The teacher asked Polycarp to solve tasks in the following way if Polycarp began to solve some task then he must solve it to the end without being distracted by another task After switching to another task Polycarp cannot return to the previous task Polycarp can only solve one task during the day Every day he wrote down what task he solved Now the teacher wants to know if Polycarp followed his advice For example if Polycarp solved tasks in the following order then the teacher will see that on the third day Polycarp began to solve the task then on the fifth day he got distracted and began to solve the task on the eighth day Polycarp returned to the task Other examples of when the teacher is suspicious and If Polycarp solved the tasks as follows then the teacher cannot have any suspicions Please note that Polycarp is not obligated to solve all tasks Other examples of when the teacher doesn t have any suspicious and Help Polycarp find out if his teacher might be suspicious ,The simplest solution go through the problem because of which the teacher might have suspicions Now you can find the first day when Polycarp solved this problem and the last such day Between these two days all problems should be the same If this is not the case the answer is ,Let be the current number of computers with the update already installed initially it is Then in hour we can increase by From here we can see that the value of will double for the first few hours and then when it becomes greater than it will begin to increase by exactly The process when the number of computers doubles can be modeled using a loop because the number of doublings does not exceed And after that we have to increase the answer by to take the number of additions of into account Note that computing should be done without using fractional data types to calculate in integers you should divide by using integer division this will work provided that both and are non negative and If you use real numbers this may cause precision issues 
297,Consider the decimal presentation of an integer Let s call a number if digit appears in decimal presentation of the number on even positions and nowhere else For example the numbers are but are not On the other hand the number is is is and is Find the number of numbers in the segment that are multiple of Because the answer can be very huge you should only find its value modulo so you should find the remainder after dividing by ,Denote the answer to the problem Note that or what is the same where equals to one if is a magic number otherwise equals to zero Let s solve the problem for the segment Here is described the standard technique for this kind of problems sometimes it is called dynamic programming by digits It can be realized in a two ways The first way is to iterate over the length of the common prefix with number Next digit should be less than corresponding digit in and other digits can be arbitrary Below is the description of the second approach Let be the number of magic prefixes of length with remainder modulo If than the prefix should be less than the corresponding prefix in and if than the prefix should be equal to the prefix of it can not be greater Let s do forward dynamic programming Let s iterate over digit in position We should check that if the position is even than should be equal to otherwise it cannot be equal to Also we should check for should be not greater than corresponding digit in Now let s see what will be the next state Of course By Horner scheme Easy to see that To update the next state we should increase it Of course all calculations should be done modulo ,Note that the number and the nearest round number not exceeding have the same size consist of the same number of digits in the record Denote the size of by Then we can construct the nearest round number It will consist of one and zeros 
298,You are given two strings and and both consisting only of characters and Possible examples of strings and You have to find a string consisting of characters characters should be characters should be and characters should be and and should not occur in as substrings A substring of a string is a contiguous subsequence of that string So the strings and are substrings of the string but the strings and are not substrings of the string If there are multiple answers you can print any of them ,We can check the following solution by stress testing or maybe prove it somehow let s iterate over all possible permutations of the string Let the first character of the current permutation be the second one be and the third one be Then let s add the following two candidates to the answer the string consisting of copies of and exactly copies of then exactly copies of and exactly copies of Then the answer will be among these strings and we can check each of them naively ,The string is diverse if it is a permutation of some substring of the Latin alphabet In other words the string is diverse if all letters in it are distinct we can check it using some structure like or array of used elements and if the number of letters between the letter with the maximum alphabet position and the letter with the minimum alphabet position plus one is exactly the length of the string For example the position in alphabet of letter is one the position of letter is six and so on 
299,You are given a sequence consisting of integers and an integer Your task is to make the sequence sorted it is considered sorted if the condition holds To make the sequence sorted you may perform the following operation any number of times you want possibly zero choose an integer such that and and swap the values of and For example if the following sequence of operations is possible choose it is possible since then choose it is possible since then choose it is possible since then Calculate the minimum number of operations you have to perform so that becomes sorted or report that it is impossible ,The main fact that allows us to solve this problem is that the value of always increases after swaps and since the resulting sequence should be sorted the indices of elements we swap with also increase This observation is actually enough for us to implement a dynamic programming solution of the form dp i j is the minimum number of actions we have to perform to reach the following situation the last integer we swapped with was and the current value of is Depending on your implementation it works either in or in But there exists a much simpler to code greedy solution scan the array from left to right until it is sorted and find the first element such that we can apply the operation to it and apply that operation to it Implementing it in or even in is easy but proving it is a bit harder The key fact that is required to prove it is that if we can apply an operation to some position but don t do it and instead apply this operation to some position to the right of that one the elements on these two positions are no longer sorted if we can apply the operation to some position then but if we apply the operation to position instead then after it Since we can t go backward the resulting array cannot be sorted by any means that s why we can t skip elements in this greedy solution ,Let s present the following greedy approach The numbers will be restored in pairs and so on Thus we can have some limits on the values of the current pair satisfying the criteria about sort Initially and they are updated with Let be minimal possible in the answer Take and That way was chosen in such a way that both and are within the restrictions and is also minimal possible If was any greater than we would move both limit up and limit down leaving less freedom for later choices Overall complexity Funnily enough I coded some naive solution just to test main correct and with restriction of on numbers it passed all tests in 300 ms at max After I saw that I guessed why it worked in but it looked fun nonetheless 
300,You have a string of length consisting of only characters and You may do some operations with this string for each operation you have to choose some character that still remains in the string If you choose a character the character that comes right after it is deleted if the character you chose was the last one nothing happens If you choose a character the character that comes right before it is deleted if the character you chose was the first one nothing happens For example if we choose character in string the string will become to And if we choose character in string the string will become to The string is good if there is a sequence of operations such that after performing it only one character will remain in the string For example the strings are good you may remove any number of characters from the given string possibly none possibly up to but not the whole string You need to calculate the minimum number of characters to be deleted from string so that it becomes good ,A string is good when either its first character is or the last is Strings of type are not good as their first and last characters will never change and they will eventually come to the form So the answer is the minimum number of characters from the beginning of the string which must be removed so that the first symbol becomes or minimum number of characters from the end of the string which must be removed so that the last symbol becomes ,Let s look at the first and the last characters of Note that if where then is always equal to It can be proved for example by induction if consists of equal characters then if has a structure like or then Otherwise there is at least one character in the middle that equal to and So we can split string in and Both these string has by induction so our string also has As a result if then the answer is and we print the string untouched Otherwise we replace either or and get the desired string It also can be proved that if then 
301,Vasya came up with a password to register for a string The password in should be a string consisting of lowercase and uppercase Latin letters and digits But since takes care of the security of its users user passwords must contain at least one digit at least one uppercase Latin letter and at least one lowercase Latin letter For example the passwords and are valid and the passwords and are not A substring of string is a string is the length of the substring Note that the empty string is also considered a substring of it has the length Vasya s password however may come too weak for the security settings of He likes his password so he wants to replace some its substring with another string of the same length in order to satisfy the above conditions This operation should be performed once and ,There are just a few general cases in the task to consider If the password is already valid nothing has to be changed just print Try to change exactly one character iterate over all positions in and all three options for character any digit any lowercase or uppercase Latin letter After the replacement the string is checked for the validity and printed if it turned out to be valid We weren t able to replace a substring of length 0 or 1 then the answer is at least 2 We can obtain it in a following manner replace the first two characters to if the third character is an uppercase Latin letter to if the third character is a lowercase Latin letter and to if the third character is a digit ,Let be the mirror reflection of the string For example Let string be good if it does not have a prefix which have more closing brackets than opening ones For example are good and are not The balance of the string is the difference between number of opening and closing brackets in For example 1 0 Let be the number of good strings with a balance The answer to the problem is 
302,It is given a non negative integer the decimal representation of which contains digits You need to color its digit in red or black so that the number formed by the red digits is divisible by and the number formed by the black digits is divisible by digit must be colored in each of two colors Consider the count of digits colored in red is and the count of digits colored in black is Among all possible colorings of the given number you need to output any such that the value of is Note that the number and the numbers formed by digits of each color The figure above shows an example of painting the number of digits for and The red digits form the number which is divisible by and the black ones which is divisible by Note that the absolute value of the difference between the counts of red and black digits is it is impossible to achieve a smaller value ,The number is divisible by the number if and only if modulo To solve this problem let s use the concept of dynamic programming There will be four states the number of considered digits of the number the number of such considered digits that we have colored red the remainder from dividing the red number by and the black one by The value corresponding to the state will be described by three parameters the possibility of a situation described by the states the color of the last digit and the parent state Let s assume that the number that contains digits is equal to Initially let s mark the state in which digits are considered of which are red digits and both remainders are equal to as possible Next let s iterate over all states in the following order first by the number of considered digits then by the number of considered red digits then by the remainder of the division by and by From the current state if it is possible i e the corresponding mark is set you can make two transitions to new states At the first transition we paint the last digit in red at the second one in black We need also to store the current state in the new states as the previous one A solution exists if and only if some state in which exactly digits are considered of which at least and at most red digits and the remainders are equal to is marked as possible Let s find such a state Using the stored information about the color of the last digit and the previous state we can restore the colors of all digits of the number ,Let s iterate over all possible values of from to It is obvious that cannot be bigger than else we can just move to Then let s iterate over all possible multiples of from to Let this number be Then we can find as the nearest number to that is divisible by we can check two nearest numbers to be sure These numbers are and Then we can update the answer with the found triple Note that the only condition you need to check is that Time complexity because of the sum of the harmonic series 
303,You are given an integer You have to calculate the number of binary consisting of characters and or strings meeting the following constraints For every pair of integers such that an integer is given It imposes the following constraint on the string if all characters in should be the same if there should be at least two different characters in if there are no additional constraints on the string Count the number of binary strings of length meeting the aforementioned constraints Since the answer can be large print it modulo ,Suppose we build the string from left to right and when we place the i th character we ensure that all substrings are valid What do we need to know in order to calculate the number of different characters in the string ending with the i th character Suppose the character s i is Let s try going to the left of it The string from i to i will have the same characters but if there is at least one character before the i th position the string s 1 s 2 s 3 dots s i will have two different characters What about the strings in the middle The string s j s j 1 dots s i will contain different characters if and only if there is at least one in j i since s i is so we are actually interested in the position of the last character before i The same logic applies if the character s i is we are only interested in the position of the last before i and it is enough to check if all substrings ending with the i th character are violated What if when we choose the i th character we violate some substring that doesn t end in the i th position Well you could also check that or you could just ignore it Actually it doesn t matter if this happens because it means that the substring that is violated ends in some position k i and we will check it when placing the k th character So the solution can be formulated with the following dynamic programming let dp i j be the number of ways to choose the first i characters of the string so that the last character different from s i was s j or j 0 if there was no such character and all the constraints on the substrings ending no later than position i are satisfied The transitions are simple you either place the same character as the last one going from dp i j to dp i 1 j or a different character going from dp i j to dp i 1 i and when you place a character you check all the constraints on the substrings ending with the i th position Note that the state dp 1 0 is actually represented by two strings and This solution works in O n 3 although O n 4 or O n 2 implementations are also possible ,Let s iterate through the given string from the left to the right In a variable we will store the number of letters which were before the current letter in a row If the current letter does not equal to we should make In the other case the current letter equals to If we should increase by one In the other case we should add one to the answer because the current letter should be removed 
304,You are given an array consisting of integers You perform the sequence of operations on this array during the first operation you either add to and subtract from or add to and subtract from during the second operation you either add to and subtract from or add to and subtract from during the last operation you either add to and subtract from or add to and subtract from So during the th operation you add the value of to one of its neighbors and subtract it from the other neighbor For example if you have the array one of the possible sequences of operations is subtract from and add it to so the array becomes subtract from and add it to so the array becomes subtract from and add it to so the array becomes So the resulting array is An array is if it can be obtained by performing the aforementioned sequence of operations on You have to calculate the number of reachable arrays and print it modulo ,One of the key observations to this problem is that after the first operations the first elements of the array are fixed and cannot be changed afterwards Also after the th operation the elements on positions from to are the same as they were before applying the operations This allows us to write the following dynamic programming the number of different prefixes our array can have if we have performed operations the th element is and the th element is The elements after are the same as in the original array and the elements before won t be changed anymore so we are interested only in these two elements Let s analyze the transitions in this dynamic programming We apply the operation to the elements and If we add to then we subtract it from so we transition into state Otherwise we transition into state The element we leave behind is either or and if these two transitions give us different prefixes But if we need to make only one of these transitions because adding or subtracting actually makes no difference Okay now we ve got a solution with dynamic programming in where is up to and is up to This is too slow But we can notice that the value of actually does not affect our transitions at all we can just discard it so our dynamic programming becomes which easily fits into TL Small implementation note elements can become negative and in order to store dynamic programming with negative states in an array we need to do something about that I don t recommend using maps neither ordered nor unordered you either get an extra log factor or make your solution susceptible to hacking Instead let s say that the value of where can be a negative number will be stored as in the array where is some constant which is greater than the maximum possible for example in this problem That way all array indices will be non negative Solution complexity ,We ll consider an arbitrary index of the array and see what changes happen to during several steps of the described algorithm Let s denote by the value of the array after steps of the algorithm and prove by induction that is the logical AND of elements of the array starting from with step to the left that is Base of induction for the element of the original array is For clarity we can also show that the statement is true for during the first step is replaced by by the definition of cyclic shift by to the right For simplicity we will omit the operation in the following formulas but will keep it in mind implicitly That is will imply Induction step let the above statement be true for let us prove it for By the definition of cyclic shift And by the induction assumption these two numbers are equal to Since the logical AND is an idempotent operation that is it does not change its result when repeatedly applied to any argument then that is equal to their logical AND is also equal to which is what we wanted to prove It follows from this formula that turns to zero after the th step if and only if and Up to the th step all elements will be equal to and so their logical AND will also be equal to As soon as appears in the sequence in question the logical AND will also become zero Thus we reduced the problem to finding the maximal block of elements equal to of the pattern Note that by shifts of the array splits into cyclic sequences of this kind each of length Let s look at these cyclic sequences independently from each other and iterate over each of them in linear time complexity to find the maximal block of consecutive elements equal to this will be the answer to the problem Remember to check that if at least one of these sequences consists entirely of elements equal to its elements will never zero out and the answer in such case is The time complexity is 
305,Given an array you need to handle a total of updates and queries of two types for each index with update the value of to the sum of the digits of output ,Let denote the sum of the digits of The key observation is the following after the operation is applied to index thrice it won t change after any further operations The proof is provided at the bottom of the editorial So we only need to update if it s been updated at most times so far otherwise we can ignore it This allows us to do the following solution store the current active indices that is indices that have been updated times in a sorted list for example in C Then search for the smallest active index at least since the list is sorted we can do it in Afterwards update that index replace with remove it if it s no longer active and binary search for the next largest active index in the sorted list until we pass just output Although it looks like we take time for each update we actually only ever update each element of the array at most times so we will do no more than binary searches Therefore the time complexity is amortized To show this note that initially The maximum possible value of the sum of the digits of is achieved when So Now considering the numbers from to the one with maximum sum of digits is with Hence Finally considering the numbers from to the one with maximum sum of digits is so That is after three operations becomes a single digit Any further operations and it won t change any more ,Print and Firstly the smallest value of you can have is and if any greater value fits then fits as well Secondly the absolute difference between and increases when you increase thus lessening the possibility of both numbers fitting into the range Overall complexity 
306, Define a chain a chain of length is a single vertex a chain of length is a chain of length with a new vertex connected to the end of it with a single edge You are given chains of lengths You plan to build a tree using some of them Each vertex of the tree is either white or black The tree initially only has a white root vertex All chains initially consist only of white vertices You can take one of the chains and connect any of its vertices to any white vertex of the tree with an edge The chain becomes part of the tree Both endpoints of this edge become black Each chain can be used no more than once Some chains can be left unused The distance between two vertices of the tree is the number of edges on the shortest path between them If there is at least white vertices in the resulting tree then the value of the tree is the distance between the root and the th closest white vertex What s the minimum value of the tree you can obtain If there is no way to build a tree with at least white vertices then print ,At first let s realize that the tree structure doesn t matter that much What we actually need is the array such that it stores the number of white vertices on depth Initially and all other are zero If you take a chain and attach it to some vertex on depth then the number of vertices on depth decreases by Also the added vertices update some other counts So far it s extremely unclear what to begin with Let s start by introducing some greedy ideas For each let s find the most optimal tree using exactly chains and update the answer with each of them First it s always optimal to attach a chain with its middle vertex Just consider the changes in the white vertices counts Second for each it s always optimal to take the longest chains to use If not the longest are used then you can replace any of them and there will be more white vertices It would be nice if we were able to just add another chain to the tree for to get the tree for However that s not always the case But we can still attempt it and show that the optimal answer was achieved somewhere in the process Let s show that it s always optimal to attach a new chain to the closest white vertex So there are basically two cases there is not enough white vertices yet and there is enough What happens if there is not enough vertices and we pick the closest one to attach a chain to If there are still not enough vertices then we ll just continue Otherwise we ll have to show that the answer can t get any smaller by rearranging something Consider what the answer actually is Build a prefix sum array over then the answer is the shortest prefix such that its prefix sum is greater or equal to So we put the th chain to the closest white vertex at depth It decreases by and increases and further by or Every chain we have put to this point was attached to a vertex at depth less or equal to the answer otherwise we could ve rearranged it and obtain the answer before The optimal answer can be neither nor also because we could ve rearranged Thus the answer is at least and every single chain we have put was packed as tightly as possible below that depth The second case works similarly We could ve obtained the optimal answer before So the answer is below and we can do nothing about that Or the optimal answer is ahead of us so putting the chain at can decrease it as much or stronger as any other choice Thus updating the answer on every iteration will give us the optimal result Now we are done with the greedy time to implement it I chose the most straightforward way We basically have to maintain a data structure that can add on range get the value of a cell and find the shortest prefix with sum at least That can be easily done with segtree Overall complexity ,Let s start with the solution and then proceed to the proof For each tree in a forest find such a vertex that the maximal distance from it to any vertex is minimal possible a center of a tree Tree may include two centers take any of them in that case Find the the tree with the maximum diameter Connect the centers of other trees with its center Overall complexity is the complexity of looking for a diameter or The center is the best vertex in a tree to connect to The diameter of merging two trees and by in and in with being the maximum shortest path from to any other vertex in being the same for in is Thus minimizing both and will produce the best result The most optimal structure is a star The center tree will be connected directly to any other tree The other trees will be connected through a single vertex among each other which leads to the answer no more than 1 worse than connecting them directly And building the answer the other way will exceed this difference as some tree will be connected to the center tree of the star through one vertex as well The previous fact implies that the center tree of the star should have the maximal diameter among all trees 
307,A string is called if it consists of a concatenation joining of strings of length consisting of the same characters In other words a string is even if two conditions are satisfied its length is even for all odd is satisfied For example the following strings are even empty string and The following strings are not even and Given a string consisting of lowercase Latin letters Find the minimum number of characters to remove from the string to make it even The deleted characters do not have to be consecutive ,We will act greedily we will make an array consisting of elements in which we will mark if the letter is already encountered in the string and otherwise In the variable we will store the length of the even string that can be obtained from We will go through the string by executing the following algorithm if mark if then we already have a pair of repeating characters to add to an even string add to the number and clear the array Clearing is necessary because both characters that will make up the next pair must be in the string after the current character In other words if the last character in the current pair was then the first character in the new pair can be where Then we calculate the answer as ,Observation the product of odd numbers is odd so the condition for the length of is automatically completed Denote by the number of ones in binary representation of Let s enumerate the letters of the Latin alphabet from to Observation for each word it is enough to know the set of letters included in it and the evenness of their numbers There are only letters in the alphabet so it is convenient to store the word characteristic as a pair of masks The bit with the number in will be responsible for the availability of the letter in The bit with the number in will be responsible for the evenness of the number of letters in Observation strings creates if and only if Let s fix the number the index of the letter that will not be in Let s throw out all the words with the letter now we can look at the words in turn and look for a pair of them among those already considered It is easy to see that the condition follows from the condition if one letter is banned To count the number of pairs that include our word we need to count the number of words with the characteristic We can do this by bin searching through a sorted array of or using standard data structures We got the solution for 
308,You are a mayor of Berlyatov There are districts and two way roads between them The th road connects districts and The cost of travelling along this road is There is some path between each pair of districts so the city is connected There are delivery routes in Berlyatov The th route is going from the district to the district There is one courier on each route and the courier will always choose the minimum by total cost path from the district to the district to deliver products The route can go from the district to itself some couriers routes can coincide You can make at most one road to have cost zero i e you choose at most one road and change its cost with Let be the cheapest cost of travel between districts and Your task is to find the minimum total courier routes cost you can achieve if you optimally select the some road and change its cost with In other words you have to find the minimum possible value of after applying the operation described above optimally ,If we would naively solve the problem we would just try to replace each edge s cost with zero and run Dijkstra algorithm times to get the cheapest paths But this is too slow Let s try to replace each edge s cost with zero anyway but use some precalculations to improve the speed of the solution Let s firstly run Dijkstra times to calculate all cheapest pairwise paths Then let s fix which edge we remove There are three cases for the path this edge was not on the cheapest path before removing and is not on the cheapest path after removing Then the cost of this path is The second case is when this edge was not on the cheapest path before removing but it is on the cheapest path after removing Then the cost of this path is So we are just going from to using the cheapest path then going through the zero edge and then going from to using the cheapest path also or vice versa from to and from to And the third case is when this edge was already on the cheapest path between and but this case is essentially the same as the second one So if we fix the edge then the answer for this edge is Taking the minimum over all edges we will get the answer The precalculating part works in and the second part works in ,There is no point in using two transitions between portals because if you want to go from portal A to portal B and then from portal C to portal D then you can immediately go from portal A to portal D for less Then there are two possible paths First do not use portals Here it is enough to find the shortest path between two points The second use a single transition Let s choose a portal from which we should teleport Obviously this is a portal with a minimum distance to it and the cost of the transition Similarly the portal in which we should teleport is selected 
309,We had a string consisting of lowercase Latin letters We made copies of this string thus obtaining identical strings After that in each of these strings we swapped exactly two characters the characters we swapped could be identical but they had different indices in the string You are given strings and you have to restore any string so that it is possible to obtain these strings by performing aforementioned operations Note that the total length of the strings you are given doesn t exceed 5000 that is ,If we don t have two distinct strings then we just have to swap any pair of characters in any of the given strings and print it Otherwise we have to find two indices and such that Then let s store all positions such that in array If the number of those positions will exceed 4 then the answer will be 1 Otherwise we need to iterate over all positions in array try to swap with any other character of and check that current string can be the answer We also should try the same thing with string It is clear how we can check string to be the answer Let s iterate over all strings and for each string count the number of positions such that Let s call it If for any given string is not equal to 0 or 2 then string can t be the answer Otherwise if for any given string is equal to 0 and all characters in string are distinct then can t be the answer If there is no string that satisfies all aforementioned conditions then the answer will be 1 ,Consider the first character of the string If it is then we can remove the first two characters of the string and continue because the prefix of length will be either a palindrome or a regular bracket sequence If the first character of the string is then this is a bad case Of course the regular bracket sequence can t start with so this prefix should be a palindrome And what is the shortest palindrome we can get with the first character It is the closing bracket then some possibly zero amount of opening brackets and another one closing bracket We can see that we can t find a palindrome shorter than this one because we have to find a pair for the first character So if the first character of the string is then we just remove anything until the next character inclusive To not remove any characters explicitly we can just use pointers instead And the last thing is to carefully handle cases when we can t do any operations 
310,A Pythagorean triple is a triple of integer numbers such that it is possible to form a right triangle with the lengths of the first cathetus the second cathetus and the hypotenuse equal to and respectively An example of the Pythagorean triple is Vasya studies the properties of right triangles and he uses a formula that determines if some triple of integers is Pythagorean Unfortunately he has forgotten the exact formula he remembers only that the formula was some equation with squares So he came up with the following formula Obviously this is not the right formula to check if a triple of numbers is Pythagorean But to Vasya s surprise it actually worked on the triple so according to Vasya s formula it is a Pythagorean triple When Vasya found the right formula and understood that his formula is wrong he wondered how many are there triples of integers with such that they are Pythagorean both according to his formula and the real definition He asked you to count these triples ,We have to find the number of triples such that equations and are satisfied Let s subtract one equation from another and get that So we know that and after substituting we get that We can see that there is only one correct value of and for every odd value of greater than So we can iterate over the value of and check that the corresponding value of doesn t exceed This solution works in because but you can also solve it in ,Let s solve the problem from the end Let s maintain the array what number will become if we apply to it all the already considered queries of type If the current query is of the first type then we simply add to the resulting array If the current query is of the second type then we have to change the value of Since all occurrences of must be replaced with it is enough to assign Since we process each query in the final complexity is There is also an alternative solution Let s process queries in the direct order Let s store all its positions in an array for each number Then for the first query it is enough to put the index in the corresponding array of positions And for a query of the second type we have to move all the positions of the number into an array of positions of the number The naive implementation is obviously too slow but we can use the small to large method then the complexity of the solution will be 
311,A permutation of size is an array of size such that each integer from to occurs exactly once in this array An inversion in a permutation is a pair of indices such that and For example a permutation contains inversions You are given a permutation of size and queries to it Each query is represented by two indices and denoting that you have to reverse the segment of the permutation For example if and a query is applied then the resulting permutation is After each query you have to determine whether the number of inversions is odd or even ,Permutaion with one swap is called transposition Any permutation can be expressed as the composition product of transpositions Simpler you can get any permutation from any other one of the same length by doing some number of swaps The sign of the permutation is the number of transpositions needed to get it from the identity permutation Luckily not really this is pure math check out all proofs at wiki e g the sign can also tell us the parity of inversion count Now you can start with computing parity of inversion count of the original permutation naively check all pairs of indices Finally you can decompose queries into swaps any method will be ok Like you can swap and then and and so on this is swaps Then parity of inversion count of the resulting permutation will change if you applied odd number of swaps Overall complexity ,Let be the value of the variable after steps Note that should be less than for to be not equal to It means that does not exceed It turns out that for there is always a permutation such that is equal to The only thing left is to find out how to build such a permutation There are many suitable permutations let s consider one of the possible options For an even a suitable permutation is You can see that in such a permutation changes as follows For an odd there is a similar permutation where changes as follows 
312,Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online Now players from all over the world can try his level All levels in this game have two stats to them the number of plays and the number of clears So when a player attempts the level the number of plays increases by If he manages to finish the level successfully then the number of clears increases by as well so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears Polycarp is very excited about his level so he keeps peeking at the stats to know how hard his level turns out to be So he peeked at the stats times and wrote down pairs of integers where is the number of plays at the th moment of time and is the number of clears at the same moment of time i e the order of given pairs is exactly the same as Polycarp has written down Between two consecutive moments of time Polycarp peeked at the stats many players but possibly zero could attempt the level Finally Polycarp wonders if he hasn t messed up any records and all the pairs are correct If there could exist such a sequence of plays and clears respectively that the stats were exactly as Polycarp has written down then he considers his records correct Help him to check the correctness of his records For your convenience you have to answer multiple independent test cases ,Let s use the fact that initially the level has plays and clears Call the differences before the previous stats and the current ones and The stats are given in chronological order so neither the number of plays nor the number of clears should decrease i e and Finally should be greater or equal to It s easy to show that if players pass the level successfully and players just try the level then such deltas are achieved So in implementation it s enough to check these three conditions between the consecutive pieces of data including the initial Overall complexity ,The maximum number of rounds Alice can win is pretty easy to calculate greedily What about the minimum number of rounds It can be shown that if we started using some combination we are better to end it before using the other one There are six possible combinations to not win the round and and and and and and We can iterate over all permutations of these combinations there are possible permutations and greedily apply them Use the first while it is possible then the second and so on and find the best answer It is also possible that the order of these combinations does not matter but we didn t prove that fact Time complexity 
313,You are given a tree consisting of vertices Some of the vertices at least two are black all the other vertices are white You place a chip on one of the vertices of the tree and then perform the following operations let the current vertex where the chip is located is You choose a black vertex and then move the chip along the first edge on the simple path from to You are not allowed to choose the same black vertex in two operations in a row i e for every two consecutive operations the chosen black vertex should be different You end your operations when the chip moves to the black vertex if it is initially placed in a black vertex you don t perform the operations at all or when the number of performed operations exceeds For every vertex you have to determine if there exists a possibly empty sequence of operations that moves the chip to some black vertex if the chip is initially placed on the vertex ,I think there are some ways to solve this problem with casework but let s try to come up with an intuitive and easy to implement approach It s always possible to move closer to some black vertex no matter in which vertex you are currently and which black vertex was used in the previous operation However sometimes if you try to move along an edge you immediately get forced back Let s analyze when we can move without being forced back We can move along the edge so that our next action is not moving back if either is black there is no next action or if we remove the edge between and the number of black vertices in s component is at least we can use one of them to go from to and another one to continue our path Note that the cases and may be different sometimes it will be possible to move in one direction and impossible to move in the opposite direction Let s treat this possible move as an arc in a directed graph We can find all such arcs if we can answer the queries of the type count black vertices in a subtree of some vertex and this can be done by rooting the tree and calculating this information for each subtree with DFS Now if there is a way from some vertex to some black vertex along these arcs the answer for the vertex is How can we find all such vertices Let s transpose the graph change the direction of each arc to opposite now we need to find all vertices reachable from black ones which is easily done with multisource BFS or DFS The complexity of this solution is ,Suppose we want to minimize the number of traversed edges of the second type edges that connect odd vertices to each other or even vertices to each other and minimizing the length of the path has lower priority Then we exactly know the number of edges of the second type we will use to get from one vertex to another and when building a path we each time either jump from one tree to another using an edge of the first type or use the only edge of the second type that brings us closer to the vertex we want to reach So in this case problem can be solved either by binary lifting or by centroid decomposition The model solution uses the latter merge the graph into one tree vertices and of the original graph merge into vertex in the tree build its centroid decomposition and for each centroid and vertex of its centroid subtree calculate the length of the shortest path from and to and using dynamic programming Then the answer for each pair of vertices and may be calculated as follows find the deepest centroid controlling the both vertices and try either shortest path or shortest path But this solution won t work in the original problem because sometimes we want to choose an edge of the second type that leads us further from the vertex we want to reach in the merged tree but allows us to use a cheaper edge of the first type to jump from one tree to another Let s make this situation impossible We may change the weights of all edges of the second type so that the weight of edge between and becomes the length of the shortest path between and This can be done by solving a SSSP problem build a graph of vertices where each vertex from to represents the path between from and Add a directed edge with weight equal to going from vertex to vertex And finally for every pair such that and are connected by edge of weight and and are connected by edge of weight add an undirected edge connecting and in the new graph its weight should be Then the distance from to in this graph will be equal to the length of the shortest path from to in the original graph 
314,You are given two permutations and both of size A permutation of size is an array of elements where each integer from to appears exactly once The elements in each permutation are indexed from to You can perform the following operation any number of times choose an integer from to let be the integer such that Swap with let be the integer such that Swap with Your goal is to make both permutations i e the conditions and must be satisfied using Note that both permutations must be sorted after you perform the sequence of operations you have chosen ,The solution to this problem uses cyclic decomposition of permutations A cyclic decomposition of a permutation is formulated as follows you treat a permutation as a directed graph on vertices where each vertex has an outgoing arc This graph consists of several cycles and the properties of this graph can be helpful when solving permutation based problems First of all how does the cyclic decomposition of a sorted permutation look Every vertex belongs to its own cycle formed by a self loop going from that vertex to itself We will try to bring the cyclic decompositions of the given permutations to this form What does an operation with integer do to the cyclic decomposition of the permutation If is in its own separate cycle the operation does nothing so we swap an element with itself Otherwise let s suppose that is the element before in the same cycle and is the element after in the same cycle Note that this can be the same element When we apply an operation on we swap with so after the operation and So leaves the cycle and forms its separate cycle and becomes the next vertex in the cycle after So using the operation we exclude the vertex from the cycle Suppose we want to sort one permutation Then each cycle having length must be broken down for a cycle of length we need to exclude vertices from it to break it down The vertex we don t touch can be any vertex from the cycle and all other vertices from the cycle will be extracted using one operation directed at them It s easy to see now that if we want to sort a permutation we don t need to apply the same operation twice and the order of operations does not matter Okay then what about sorting two permutations in parallel Let s change the problem a bit instead of calculating the minimum number of operations we will try to maximize the number of integers such that we don t perform operations with them So an integer can be left untouched if it is the only untouched vertex in its cycles in both permutations Can you see where this is going Suppose we want to leave the vertex untouched It means that in its cycles in both permutations every other vertex has to be extracted with an operation So if two cycles from different permutations have a vertex in common we can leave this vertex untouched as long as there are no other vertices left untouched in both of these cycles Let s build a bipartite graph where each vertex in the left part represents a cycle in the first permutation and each vertex in the right part represents a cycle in the second permutation We will treat each integer as an edge between two respective vertices in the bipartite graph If the edge corresponding to is used is left untouched we cannot use any edges incident to the same vertex in left or right part So maximizing the number of untouched numbers is actually the same as finding the maximum matching in this bipartite graph After you find the maximum matching restoring the actual answer is easy Remember that the edges saturated by the matching correspond to the integers we don t touch with our operations the order of operations does not matter and each integer has to be used in an operation only once So the actual answer is the set of all integers without those which correspond to the edges from the matching This solution runs in even with a straightforward implementation of bipartite matching since the bipartite graph has at most vertices and edges ,The solution of the previous problem works for this problem also Almost works What if the leftmost element is equal the rightmost element Which one should we choose Let s analyze it If we take the leftmost element then we will take any other element from the right and vice versa So we can t meet this case more than once because after meeting it once we can take only leftmost elements or only rightmost elements The only thing we should understand is which of these two cases is better take the leftmost element or take the rightmost element To do it we can just iterate from left to right and calculate the number of elements we can take if we will take the leftmost element each time If we cannot take the current element then just stop the cycle And do the same thing for the rightmost element and take the best case 
315,You are given two strings and consisting of lowercase Latin letters Also you have a string which is initially empty You want string to be equal to string You can perform the following operation to achieve this append any subsequence of at the end of string A subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements For example if you may turn into following strings in one operation if we choose subsequence if we choose subsequence if we choose subsequence Note that after this operation string doesn t change Calculate the minimum number of such operations to turn string into string ,The answer is when in string there is a character that is not in string Otherwise let s precalculate the following array minimum index from to such that if there is no such index then Now we can solve this problem by simple greed Presume that now and last taken symbol in is Then there are two options if then if then and is equal to initially ,Let s analyze when the string is good Suppose it is The cyclic shifts of this string are and We get the following constraints for a good string If the string has odd length then all characters should be equal to each other otherwise all characters on odd positions should be equal and all characters on even positions should be equal Now since there are only different types of characters we can brute force all possible combinations of the first and the second character of the string we want to obtain there are only of them and for each combination greedily construct the longest possible subsequence of beginning with those characters in 
316,A telephone number is a sequence of digits such that its first digit is Vasya and Petya are playing a game Initially they have a string of length is odd consisting of digits Vasya makes the first move then players alternate turns In one move the player choose a character and erase it from the current string For example if the current string after the player s move it may be or The game ends when the length of string becomes If the resulting string is a telephone number Vasya wins otherwise Petya wins You have to determine if Vasya has a winning strategy that is if Vasya can win the game no matter which characters Petya chooses during his moves ,Let s understand how players should act Vasya needs to delete the first digit that is not equal to because the first digit of telephone number should be and the first digit not equal to is preventing it Petya needs to delete the first digit equal to for the same reasons So all that we need to do is delete first digits not equal to if they exist and first digits equal to again if they exist It s enough to stop when there is either no s left or no non s because the latter moves won t change the result of the game anyway Finally if first digit of resulting string is then Vasya wins otherwise Petya Overall complexity ,First of all let s understand that the answer to the problem should not contain zeros leading zeros are useless while others increase the number but do not change the sum It is also clear that the number we found should have the minimum possible length since the longer the numbers without leading zeros the larger they are Numbers of the same length are compared lexicographically that is first by the first digit then by the second and so on This means that the digits in the number must go in sorted order the order of the digits does not affect the sum but does affect the value Let s minimize the length of the number first We need to get the specified sum in as few digits as possible So we should use as large digits as possible Then let s start with the number 9 and add the digits from 8 to 1 to the beginning of the number in turn until the sum of the digits exceeds the specified sum Obviously you can t get an answer for fewer digits Now we minimize the number itself First we must minimize the first digit The first digit is uniquely determined as the difference between the sum of the remaining digits and the required sum So you need to maximize the sum of all digits except the first one which has already been done in the previous paragraph It only remains to correct the first digit and print the answer 
317,You have integers You have to redistribute these elements into pairs After that you choose pairs and take minimum elements from them and from the other pairs you take maximum elements Your goal is to obtain the set of numbers as the result of taking elements from the pairs What is the number of different s such that it s possible to obtain the set if for each you can choose how to distribute numbers into pairs and from which pairs choose minimum elements ,Let s prove that in the set minimum elements will be from pairs where we ll take minimums and analogically maximums will be from pairs where we ll take maximums By contradiction let s look at two pairs and where we will take maximum from and minimum from and if we swap elements and and get pair the result won t change but now minimum from pair will be less than maximum from So we can always make pairs in such a way that the chosen minimum from any pair will be less than the chosen maximum from any other pair Let s make set as all elements which are not in In the same way we can prove that minimums of are from pairs where we took maximums and maximums are from pairs where we took minimums Let s say and are sorted Now we ve proven that for a fixed we should pair with and with It s not hard to prove that it s optimal to pair and in the same way For a fixed we can just check that constructed pairs are valid But what happens if we move from to If for all was valid then for all pairs will be valid as well And on contrary if at least one pair wasn t valid then for the pair won t be valid as well Due to monotony we can find the maximum valid just checking only pairs and in the same way we can find maximum minimum such that all pairs are valid That s why all valid s form a segment and we need to find its borders We can find a maximum maximum with either binary search or with two pointers and print the length of the segment Time complexity is either or ,Let s take a look at a naive approach at first That approach is greedy Let s find such an interval which starts to the left or at and ends as much to the right as possible Set to its right border Continue until either no interval can be found or is reached The proof basically goes like this Let there be some smaller set of intervals which cover the query these can be sorted by left border obviously their left borders are pairwise distinct Compare that set to the greedy one take a look at the first position where best set s interval has his less than the greedy set s You can see that choosing interval greedily will still allow to have the rest of best set intervals making the greedy choice optimal Let s implement it in For each position from to you can precalculate the index of such an interval that it starts to the left or at this position and ends as much to the right as possible To do this sort all intervals by their left border then iterate over positions while maintaining the maximum right border achieved by intervals starting to the left or at the current position The query is now straightforward Now there are two main ways to optimize it You can do it binary lifting style for each interval or position precalculate the index of the interval taken last after taking intervals greedily and use this data to answer queries in You can also do it path compression style Let s process the queries in the increasing order of their right borders Now do greedy algorithm but for each interval you use remember the index of the last reached interval Now the part with answering queries is in total because each interval will be jumped from no more than once Overall complexity 
318,You are given a keyboard that consists of keys The keys are arranged sequentially in one row in a certain order Each key corresponds to a unique lowercase Latin letter You have to type the word on this keyboard It also consists only of lowercase Latin letters To type a word you need to type all its letters consecutively one by one To type each letter you must position your hand exactly over the corresponding key and press it Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys the keys are numbered from left to right No time is spent on pressing the keys and on placing your hand over the first letter of the word For example consider a keyboard where the letters from to are arranged in consecutive alphabetical order The letters and then are on the positions and respectively Therefore it will take units of time to type the word Determine how long it will take to print the word ,Since it does not take time to place your hand over the first letter you need to calculate the sum of the distances between the keyboard keys corresponding to each pair of adjacent letters of the word that is where is the position of the keyboard key corresponding to the letter In order to calculate this sum let s just iterate through the word with the loop and find the differences between the positions of and on the keyboard To find the position of a character on the keyboard you could either use the built in strings functions such as in Python or in C or precalculate each letter s position on the keyboard into a separate array using another loop over a keyboard ,For bracket sequence to be regular it should have equal number of opening and closing brackets So if then it s impossible to construct any regular bracket sequence is completely irrelevant to us since inserting or removing a substring doesn t change the status of the string we get Almost the same applies to but we should have at least one substring before it So if but there is no solution In all other cases it is possible to order all strings as follows all strings then all strings then all strings then all strings 
319,A student of school found a kind of sorting called sort The array with elements are sorted if two conditions hold for all even for all odd For example the arrays and are sorted while the array isn t sorted Can you make the array sorted ,Easy to see that we can sort any array Let be the number of even positions in We can assign to those positions maximal elements and distribute other elements to odd positions Obviously the resulting array is sorted ,Let the initial sum in the array the number of even numbers the number of odd numbers Let s see how these values change with each action In fact we can consider four main options Add an even number to all even numbers Then will increase by and the number of even and odd numbers will remain the same Add an odd number to all even numbers Then will increase by the number of even numbers will become all numbers will become odd so Add an even number to all odd numbers Then will increase by and the number of even and odd numbers will remain the same Add an odd number to all odd numbers Then will increase by the number of odd numbers will become all numbers will become even so 
320,You are given an undirected graph with weighted edges The length of some path between two vertices is the bitwise xor of weights of all edges belonging to this path if some edge is traversed more than once then it is included in bitwise xor the same number of times You have to find the minimum length of path between vertex and vertex ,Let s find some path from to Let its length be then the answer to the problem can be represented as where is the total length of some set of cycles in the graph they can be disconnected it doesn t matter because we can traverse the whole graph and return to the starting vertex with cost Let s treat each cycle s cost as a vector where is the th bit in binary representation of cycle s cost We can use Gaussian elimination to find the independent set of vectors that generates all these vectors To do this let s build any spanning tree of the graph and then for any edge not belonging to the spanning tree we can try to add to the independent set is the length of the path from the root to in the spanning tree When trying to add some vector we firstly need to check if it can be represented as a combination of some vectors from the set and only if it s impossible then we add it to the set The number of vectors in the set won t exceed so we can use Gaussian elimination to check if the vector is a combination of elements from the set Then after we found the basis let s build the answer greedily from the most significant bit to the least we will check if we can set the current bit so it is equal to the corresponding bit of while maintaining all the previous bit To check it we also can use Gaussian elimination ,Suppose we have found all the edges of the graph explicitly sorted them and start running Kruskal on the sorted list of edges Each time we add some edge to MST it is either a special edge given in the input or an edge which was generated with cost whichever costs less Let s try to analyze how can we find the cheapest edge of each type that connects two components For special edges we may just maintain the number of special edges we already added or skipped and when choosing a new edge we skip some more possibly zero special edges that don t connect anything until we find an edge that connects something And for the other type of edges we may find two components having minimum numbers on the vertices in those components as small as possible and just connect the minimum vertex in the first component with the minimum vertex in the second component We may simulate this by maintaining a data structure for example a multiset where for each component we will store the vertex having minimum in this component and pick two minimums from this set We also have to be able to check if two vertices are connected this can be done with DSU and merge two components But this solution can be made easier Every time we add a non special edge one of the ends of this edge is the vertex with minimum So we may just find this vertex generate all edges connecting this vertex to all other vertices merge this set of edges with the set of special edges and run any MST algorithm on the resulting set of edges If there are multiple minimums in the array then we may pick any of them because in Kruskal algorithm it doesn t matter which of the edges with equal costs we try to add first 
321,Vasya has a string of length consisting only of digits and Also he has an array of length Vasya performs the following operation until the string becomes empty choose some substring of erase it from the string and glue together the remaining parts any of them can be empty For example if he erases substring from string he will get the string Vasya gets points for erasing substring of length Vasya wants to maximize his total points so help him with this ,We set up a DP on start index end index number of consecutive digits matching our start index In other words the current string we are solving is the substring from start index to end index plus some number of additional digits all equal to S start added as a prefix to our substring We then have two choices from any given state Cash in on our consecutive digits at the start and recurse on Pick an index such that S start S i and collapse everything between those two indices in order to merge them together for an even larger prefix This results in a score of and we can loop over all to take the maximum The runtime is with a very good constant factor Code 49036191 Does anybody have ,Let s solve the problem using binary search by the answer It is easy to see that if we can construct the answer for some number of copies then we also can do it for The only thing we need is to write the function which will say can we cut off copies of some array from or not Let s imagine copies of string as a matrix of size Obviously each row of this matrix should be equal to each other row Let s fill not rows but columns of this matrix For some element of we can easy notice that we can take exactly columns containing this element where is the number of such elements in So overall number of columns we can fill in this matrix will be If this value is greater than or equal to then is true otherwise it is false It is easy to construct the answer using all things we described above Overall complexity is where is the size of the alphabet 
322,All bus tickets in Berland have their numbers A number consists of digits is even Only decimal digits can be used to form ticket numbers If is among these digits then numbers may have leading zeroes For example if and only digits and can be used then are valid ticket numbers and are not A ticket is lucky if the sum of first digits is equal to the sum of remaining digits Calculate the number of different lucky tickets in Berland Since the answer may be big print it modulo ,The naive solution would be the number of sequences of allowed digits with length and sum We compute it for and for every possible and the answer is Let s speed this up Let s denote the following polynomial where if is an allowed digit otherwise It s easy to see that the coefficients of are equal to the values of Using mathematical induction we may prove that the coefficients of are equal to So now we need to compute There are two possible ways to do this that result in complexity The first option is to apply binary exponentiation with NTT polynomial multiplication The second option is to use the fact that if we apply NTT to a polynomial we get a set of its values in some points So if we exponentiate these values we get a set of values of exponentiated polynomial in the same points So we may apply NTT to treating it as a polynomial of degree raise each resulting value to the power of and apply inverse transformation ,Let s fix an fraction such that Obviously each good fraction is equal to exactly one of such irreducible fractions So if we iterate on and check that and find the number of good fractions that are equal to we will solve the problem Okay suppose we fixed and Any good fraction can be represented as where is some positive integer Let s try all possible values of and for them check whether they correspond to a good fraction How do we try all values of without iterating on them Let s construct the decimal representation of from the least significant digit to the most As soon as we fix least significant digits of we know least significant digits of and So let s try to use digit DP to try all possible values of Which states do we have to consider Of course we need to know the number of digits we already placed so that will be the first state After we placed digits we know first digits of the numerator of the fraction but to get the value of digit knowing only the value of the corresponding digit in is not enough there could be some value carried over after multiplying already placed digits by For example if and we placed the first digit of and it is we know that the first least significant digit of is and we know that after fixing the second digit of we should add to it to get the value of this digit in since is carried over from the first digit So the second state of DP should represent the number that is carried over from the previous digit in the numerator and the third state should do the same for the denominator Okay in order to know whether the fraction is good we have to keep track of some digits in the numerator and denominator If and then we have to keep track of the digit representing in the numerator and the digit representing in the denominator So we have two additional states that represent the masks of interesting digits we met in the numerator and in the denominator The only thing that s left to check is that both and are not greater than Let s construct the decimal representation of and prepend it with some leading zeroes and keep constructing the numerator and the denominator until they have the same number of digits as the decimal representation as Then we can compare the representation of for example numerator with the representation of as strings Comparing can be done with the following technique let s keep a flag denoting whether the number represented by the least significant digits of the numerator is less or equal than the number represented by the same digits from When we place another digit of the numerator we can get the new value of this flag as follows if new digit of the numerator is not equal to the corresponding digit of then the value of the flag is defined by comparing this pair of digits otherwise the value of the flag is the same as it was without this new digit Of course we should do the same for the denominator Okay now we can actually start coding this DP is the number of possible ways to put least significant digits in in such a way that the value carried over to the next digit of the numerator is and for the denominator denotes whether the current numerator is less or equal to the number represented by least significant digits of does the same for the denominator denotes which interesting digits we already met in the numerator of course does the same for the denominator If you are feeling confident in your programming abilities you can just start implementing this DP on a seven dimensional array I was too afraid to do it but looking at participants solutions I realize that it sounds much more scary than it looks in the code so I decided to write the model solution using a structure representing each state and a map to store all these structures This is a common technique when a dynamic programming solution you come up with has some really complex states and transitions it is sometimes better to use some self implemented structures to define these states and store them in a map or a hashmap Some advantages of this technique are it s sometimes much easier to code the code may be longer than the same solution with regular DP stored in a multi dimensional array but it s easier to write and understand this code if most states are unreachable they won t even appear in our map so we skip them altogether it is easy to add some optimizations related to reducing the number of states For example the number of different values for and may be too much so we can use the following optimization as soon as we find some pair of numbers in and that can represent and we can change these masks to some values that will mark that they are finished and stop updating them at all 
323,There are cities in the country of Berland Some of them are connected by bidirectional roads in such a way that there exists path which visits each road no more than once between every pair of cities Each road has its own length Cities are numbered from to The travelling time between some cities and is the total length of the roads on the shortest path from to The two most important cities in Berland are cities and The Berland Ministry of Transport decided to build a single new road to decrease the traffic between the most important cities However lots of people are used to the current travelling time between the most important cities so the new road shouldn t change it too much The new road can only be built between such cities and that and and aren t already connected by some road They came up with possible projects Each project is just the length of the new road Polycarp works as a head analyst at the Berland Ministry of Transport and it s his job to deal with all those projects For the th project he is required to choose some cities and to build the new road of length between such that the travelling time between the most important cities is Unfortunately Polycarp is not a programmer and no analyst in the world is capable to process all projects using only pen and paper Thus he asks you to help him to calculate the maximal possible travelling time between the most important cities for each project Note that the choice of and can differ for different projects , editorial by PikMike Firtsly we can notice that we get the most profit by placing the edge in a same position no matter the query Moreover once you have calculated the minimum difference you can apply to the shortest path by adding edge of the weight you can answer the queries in each Let the current shortest distance between and be Then the answer to some query is Let s proceed to proofs of the following Consider any of the optimal positions for the edge of weight Then weight will add to the answer in this position if the path isn t already but that is trivial Let there be another position such that the answer in it is less than the current one That means that the answer for weight in it is less by which is smaller than the first one we got which leads to contradiction The second fact can deduced from the first one Then let me introduce the next bold statement We root the tree with vertex Then if there exists such a vertex in that it s not an ancestor of vertex and the number of vertices in its subtree inclusive is greater than then That is simple just put the edge between the parent of this vertex and any of vertices of the subtree there always be such that the edge doesn t exist yet That won t change the shortest path no matter which it is Then we have a graph of the following kind That is the simple path between and and some vetices on it have additional children leaves Finally let s proceed to the solution We want to choose such a pair of vertices that the sum of edge on a path between them which are also a part of the path between and plus the weights of the newly included to shortest path edges if any is minimal possible Let s precalc the sum of weights of edges from vertex to vertex and parent of vertex Let be the weight of an edge between and Then we end up with the four basic cases for these vertices and with having greater or equal number of edges on path to than each of the form whether belongs to the simple path between and whether belongs to it doesn t belong the answer is belongs doesn t both belongs Each of these formulas can be broken down to parts with exacly one of the vertices Let s call them and That means minimizing the result is be the same as minimizing each of the parts We run depth first search on vertices which belong to a simple path between and inclusive Maintain the minimum value of you have already passed by Try connecting each vertex with this and also parent of the parent of the current vertex using all the possible formulas and updating with the resulting value Finally after the precalc is finished asnwer the queries in with Overall complexity editorial by BledDest Let s denote the distance from vertex to vertex in the tree as Similarly denote the distance from to in the tree as Suppose we try to add a new edge between vertices and with length Then two new paths from to are formed one with length and another with length Then the new length of shortest path becomes So if we find two non adjacent vertices such that is maximum possible then it will always be optimal to add an edge between these two vertices How can we find this pair of vertices Firstly let s suppose that when we pick vertex we will try to pair it only with vertices corresponding to the aforementioned constraint This can be done by sorting vertices by the value of and then for each vertex pairing it only with vertices that are later than in the sorted order How do we find the best pair for The best pair could be just the vertex with maximum possible but it is not allowed to connect a vertex with itself or its neighbour To handle it we may maintain a set of possible vertices delete all neighbours of from it pick a vertex with maximum and then insert all neighbours of back into the set This solution works in time ,This problem is solved using minimum cost flows duh Suppose all arcs have even capacity Then we can just divide each arc s capacity by and solve a usual minimum cost flow problem However when we have arcs with odd capacity it s not that simple We will deal with them as follows split an arc with capacity into two arcs one with capacity the other with capacity and somehow enforce that the second arc must be saturated We cannot divide all arcs by now because that would lead to non integer capacities instead we will exclude these arcs with capacity and somehow handle the fact that they must be saturated and only then divide all capacities by Okay how do we handle the edges we deleted For each vertex let s check if the number of such arcs connected to it is even If it is not the total flow for this vertex cannot be so it s impossible to find the answer the only case when it might be possible is if this vertex is the source or the sink in this case we need to check that both of these vertices have an odd number of arcs we want to delete connected to them and consider an additional arc with capacity and weight to make it even If for each vertex the number of odd arcs connected to it is even let s consider how much excess flow these arcs bring into the vertices For example if a vertex has ingoing odd arcs it has units of flow going into it which will be lost if we remove the edges we want to ignore To handle this add a new source and a new sink to our network let s call them and and process excess flow going into the vertex using an arc from to that vertex in the previous example we can add an arc from to the vertex with capacity not since we divide all capacities by Similarly excess flow going outside the vertex can be processed with an arc from that vertex to We need to make sure that all these edges must be saturated Okay what about actually running the flow from to We can do it as in flow with lower bounds problem by adding an arc with infinite capacity Wait a minute this may cause a negative cycle to appear If your implementation of mincost flow handles them you can use this approach but if you don t want to mess with negative cycles instead do the following add an arc and an arc both with infinite capacities to make sure that flow can go from to since these arcs don t have to be saturated but other arcs going from or into must be saturated set the costs of these other arcs to Okay that s it we just need to find the minimum cost flow in the resulting network The constraints are low enough so any minimum cost flow algorith can pass 
324,Dmitry has an array of non negative integers In one operation Dmitry can choose any index and increase the value of the element by He can choose the same index multiple times For each from to determine whether Dmitry can make the of the array equal to exactly If it is possible then determine the minimum number of operations to do it The of the array is equal to the minimum non negative integer that is not in the array For example the of the array is equal to and the array is equal to ,First let s sort the array Then we will consider its elements in non decreasing order To make MEX equal to you need to increase all zeros To make MEX at least you first need to make MEX at least and then if the number is missing in the array you need to get it If there are no extra values less than then this and all subsequent MEX values cannot be obtained Otherwise you can use the maximum of the extra array values To do this you can use a data structure such as a stack If an element occurs more than once in the array put its extra occurrences on the stack ,This is the solution that doesn t involve masks Let s reverse the process and try to get all zeroes from the array since all we can start from maximum The key idea since then there should be no more than one position such that and we should decrease it by Now we can decrease by and repeat the same process If at any step there are at least two or as result we won t get array filled with then there is no way to build the array 
325,There are candies in a candy box The type of the th candy is You have to prepare a gift using some of these candies with the following restriction the numbers of candies of each type presented in a gift should be all distinct i e for example a gift having two candies of type and two candies of type is bad It is also possible that of some types will be taken to a gift You really like some of the candies and don t want to include them into the gift but you want to eat them yourself instead For each candy a number is given which is equal to if you really want to keep th candy for yourself or if you don t mind including it into your gift It is possible that two candies of the same type have different values of You want your gift to be as large as possible but you don t want to include too many of the candies you want to eat into the gift So you want to calculate the maximum possible number of candies that can be included into a gift and among all ways to choose maximum number of candies you want to maximize the number of candies having in your gift You have to answer independent queries ,First of all to maximize the number of candies in the gift we can use the following greedy algorithm let s iterate on the number of candies of some type we take from to backwards For fixed let s try to find any suitable type of candies A type is suitable if there are at least candies of this type in the box If there exists at least one such type that wasn t used previously let s pick any such type and take exactly candies of this type and decrease It does not matter which type we pick if we only want to maximize the number of candies we take Okay let s now modify this solution to maximize the number of candies having We initially could pick any type that has at least candies but now we should choose a type depending on the number of candies with in this type For example if we have two types having and candies with respectively and we want to pick candies from one type and candies from another type and and it s better to pick candies of the first type and candies of the second type In this case we have candies with in the other case it s And if and then So when we want to pick a type of candies such that we will take exactly candies of this type it s optimal to choose a type that wasn t used yet contains at least candies and has maximum possible number of candies with This best type can be maintained with a multiset or a set of pairs ,If then the answer is because the just can divide all boxes to size and then fill the bag Otherwise the answer is If the answer is let s calculate the minimum number of divisions Let s consider all boxes from small to large Presume that now we consider boxes of size Then there are three cases if in binary representation of the th bit is equal to then we don t need boxes of size and we can merge it into boxes of size if in binary representation of the th bit is equal to and we have at most one box of size then we have to put it box in the bag and then merge the remaining boxes of size into boxes of size if in binary representation of the th bit is equal to and we have not boxes of size then we have to divide the large box into box of size let s presume that it s box of size After that we just continue this algorithm with box of size 
326,A robot is placed in a cell of an infinite grid This robot has adjustable length legs Initially its legs have length Let the robot currently be in the cell and have legs of length In one move it can perform one of the following three actions jump into the cell jump into the cell increase the length of the legs by i e set it to What s the smallest number of moves robot has to make to reach a cell ,Let s fix the number of leg length increases we do Let the final length be k Notice that for all i from 1 to k there is some time when the length is exactly i Thus we can perform jumps of form x y rightarrow x i y or x y rightarrow x y i What s the jumping strategy then Obviously we can solve the problem independently for a and b Consider a We would love to just make jumps of length k as that s the maximum possible length Unfortunately that only works when a is divisible by k Otherwise we are left with some remainder which is smaller than k But we have already figured out how to jump to any value from 1 to k So that only adds another jump You can say that the total number of jumps is lceil frac a k rceil Same for b Finally for a fixed k the answer is lceil frac a k rceil lceil frac b k rceil k 1 The constraints tell us that we are not allowed to iterate over all k from 1 to max a b It feels like huge k will never be optimal but let s try to base our intuition on something Try to limit the options by studying the formula Let s simplify Assume a b and also get rid of the ceil Not like that changes the formula a lot Now it becomes 2 frac a k k 1 We can see that when we increase k 2 frac a k becomes smaller and k 1 becomes larger However we care more about how fast they become smaller and larger You can just guess or write down the derivative explicitly and figure out that the first term shrinks faster than the second term grows until around sqrt a cdot c for some constant c apparently c sqrt 2 Thus their sum decreases until then then increases Thus you can search for the best k around sqrt a or sqrt b or sqrt max a b It doesn t really matter since for implementation you can basically try all k until around 10 5 which is safely enough ,This problem can be solved using dynamic programming Let be the answer for first holes and mice If the constraints were smaller then we could calculate it in just trying to update by all values of where and calculating the cost to transport all mice from the segment to th hole To calculate this in we will use a deque maintaining the minimum or a queue implemented on two stacks for example We iterate on and update all the values of with the help of this deque for each index we insert a value in the deque equal to where is the total distance required to move first mice to hole Updating the value is just extracting the minimum and adding this to it Don t forget to delete values from the deque to ensure that we don t send too much mice to the hole Time complexity 
327,You are both a shop keeper and a shop assistant at a small nearby shop You have goods the th good costs coins You got tired of remembering the price of each product when customers ask for it thus you decided to simplify your life More precisely you decided to set the same price for all goods you have However you don t want to lose any money so you want to choose the price in such a way that the sum of new prices is not less than the sum of the initial prices It means that if you sell all goods for the new price you will receive at least the same or greater amount of money as if you sell them for their initial prices On the other hand you don t want to lose customers because of big prices so among all prices you can choose you need to choose the minimum one So you need to find the minimum possible equal price of all goods so if you sell them for this price you will receive at least the same or greater amount of money as if you sell them for their initial prices You have to answer independent queries ,In this problem we need to find the minimum possible such that where is the sum of all equals to where is divided by rounded up ,Let s code the following process Go one circle across the booths calculate the total cost of sweets bought and the number of sweets bought Now you can decrease you money down to and add to answer It represents that you went maximum number of such circles The later circles will have smaller cost Let s continue this process until becomes smaller than the minimum priced sweet The number of operations made is Let be the amount of money before some operation be the total cost of sweets bought on that operation and is actually smaller than that s how modulo works and smaller than that s also how modulo works And these inequalities imply that That leads to about steps to reach the minimal price Overall complexity 
328, You are given segments on the coordinate axis Segments can intersect lie inside each other and even coincide The th segment is and it covers all integer points such that The integer point is called if it is covered by than segments Your task is to remove the minimum number of segments so that there are no points at all ,In this problem the following greedy solution works let s find the leftmost point covered by more than segments We should fix it somehow How to do it Let s find some segment that was not removed already it covers this point and its rightmost end is maximum possible and remove this segment You can implement it in any time you want even in naively ,If the number of points is less than then the answer is obviously Else let s fix first points Check if there is a solution if st and nd points lie on the same line Just erase all points which lie on this line and check the remaining points if they belong to one line If we didn t find the answer let s check points and in the same way If its failed again then line which contains point can t contain points and so points and must lie on one line If we didn t succeed again then there is no way to do it so the answer is Checking that points and belong to the same line can be done by calculating 2d version of cross product It equals to if vectors and are collinear 
329,You work as a system administrator in a dormitory which has rooms one after another along a straight hallway Rooms are numbered from to You have to connect all rooms to the Internet You can connect each room to the Internet directly the cost of such connection for the th room is coins Some rooms also have a spot for a router The cost of placing a router in the th room is also coins You cannot place a router in a room which does not have a spot for it When you place a router in the room you connect all rooms with the numbers from to inclusive to the Internet where is the range of router The value of is the same for all routers Calculate the minimum total cost of connecting all rooms to the Internet You can assume that the number of rooms which have a spot for a router is not greater than the number of routers you have ,Firstly I know that this problem has very pretty linear solution and its author can describe it if he wants I ll describe my own solution without any data structures but Let be the total cost to connect all rooms from to to the Internet indexed Initially all other values are Let s iterate over all from to and make some transitions After all the answer will be The first transition is the easier update with just connect the current room directly To do other transitions let s carry two sets and and one array of vectors of length Set carries all values Initially it carries Set carries the minimum cost to cover some suffix of rooms that also covers the room Array of vectors helps us to carry the set efficiently First of all if then let s remove from Then let s remove all values of from Then if is not empty let s update with the minimum value of Then if then let be the minimum value of plus Update with and insert into Also let s add into if And after we make all we need with the current add the value to the set Time complexity It can be optimized to solution with some advanced data structures as a queue with minimums ,Let s find some path from to Let its length be then the answer to the problem can be represented as where is the total length of some set of cycles in the graph they can be disconnected it doesn t matter because we can traverse the whole graph and return to the starting vertex with cost Let s treat each cycle s cost as a vector where is the th bit in binary representation of cycle s cost We can use Gaussian elimination to find the independent set of vectors that generates all these vectors To do this let s build any spanning tree of the graph and then for any edge not belonging to the spanning tree we can try to add to the independent set is the length of the path from the root to in the spanning tree When trying to add some vector we firstly need to check if it can be represented as a combination of some vectors from the set and only if it s impossible then we add it to the set The number of vectors in the set won t exceed so we can use Gaussian elimination to check if the vector is a combination of elements from the set Then after we found the basis let s build the answer greedily from the most significant bit to the least we will check if we can set the current bit so it is equal to the corresponding bit of while maintaining all the previous bit To check it we also can use Gaussian elimination 
330,Vasya has an array consisting of positive integer numbers Vasya wants to divide this array into two non empty consecutive parts the prefix and the suffix so that the sum of all elements in the first part equals to the sum of elements in the second part It is not always possible so Vasya will move some element before dividing the array Vasya will erase some element and insert it into an arbitrary position Can Vasya divide the array after choosing the right element to move and its new position ,Suppose we want to move an element from the prefix to the suffix if we need to move an element from the suffix to the prefix we can just reverse the array and do the same thing Suppose the resulting prefix will contain elements Then we need to check that the prefix with elements contains an element such that the sum of this prefix without this element is equal to the half of the sum of the whole array and then we can move this element to the suffix To check all the prefixes we can scan the array from left to right while maintaining the set of elements on the prefix and the sum of these elements ,Let be the value of the variable after steps Note that should be less than for to be not equal to It means that does not exceed It turns out that for there is always a permutation such that is equal to The only thing left is to find out how to build such a permutation There are many suitable permutations let s consider one of the possible options For an even a suitable permutation is You can see that in such a permutation changes as follows For an odd there is a similar permutation where changes as follows 
331,You are given a sequence consisting of pairwise distinct positive integers Find different pairs of integers and such that and appear in doesn t appear in Note that some or can belong to multiple pairs denotes the floor function the largest integer less than or equal to denotes the remainder from dividing by If there are multiple solutions print any of them It can be shown that at least one solution always exists ,There is one important observation Thus you can obtain at least pair by choosing as the minimum number in the sequence and as anything else for any positive Overall complexity per testcase ,We should find minimal so Easy to see that To learn more about floor ceil functions I reccomend the book of authors Graham Knuth Patashnik Concrete Mathematics There is a chapter there about that functions and their properties 
332,There are two types of burgers in your restaurant hamburgers and chicken burgers To assemble a hamburger you need two buns and a beef patty To assemble a chicken burger you need two buns and a chicken cutlet You have buns beef patties and chicken cutlets in your restaurant You can sell one hamburger for dollars and one chicken burger for dollars Calculate the maximum profit you can achieve You have to answer independent queries ,In this task you just can iterate over the numbers of hamburgers and chicken burgers you want to assemble check that you have enough ingredients and update the answer If you want to sell hamburgers and chicken burgers then you need beef patties chicken cutlets and buns ,Since the number of days doesn t exceed let s iterate over this value from to So now we have to check somehow if the current number of days is enough to write a coursework Let the current number of days be The best way to distribute first cups of coffee for each day is to take maximums in the array Then we have to distribute second cups for each day Let s also take the next maximums in the remaining array and so on How do we can calculate such a thing easily Let s sort the array in the reversed order before iterating over all numbers of days then the following formula will work fine for the current number of days So if the value of the formula above is greater than or equal to then the current number of days is enough If there is no any suitable number of days the answer is 
333,You received a notebook which is called This notebook has infinite number of pages A rule is written on the last page huh of this notebook It says You have to write names in this notebook during consecutive days During the th day you have to write exactly names You got scared of course you got scared who wouldn t get scared if he just receive a notebook which is named with a some strange rule written in it Of course you decided to follow this rule When you calmed down you came up with a strategy how you will write names in the notebook You have calculated that each page of the notebook can contain exactly names You will start writing names from the first page You will write names on the current page as long as the limit on the number of names on this page is not exceeded When the current page is over you turn the page Note that you turn the page when it ends it doesn t matter if it is the last day or not If after some day the current page still can hold at least one name during the next day you will continue writing the names from the current page Now you are interested in the following question how many times will you turn the page during each day You are interested in the number of pages you will turn each day from to ,In this problem all we need is to maintain the variable which will represent the number of names written on the current page Initially this number equals zero The answer for the th day equals This value represents the number of full pages we will write during the th day After the answering we need to set where operation is taking modulo ,What is the number of lanterns Vova will see from to This number is Now we have to subtract the number of lanters in range from this number This number equals to So the answer is 
334,You are given two non empty strings and consisting of Latin letters In one move you can choose an occurrence of the string in the string and replace it with dots Your task is to remove all occurrences of the string in the string in the minimum number of moves and also calculate how many sequences of moves of the minimum length exist Two sequences of moves are considered different if the sets of indices at which the removed occurrences of the string in begin differ For example the sets and are considered different the sets and too but sets and not For example let the string and the string We can remove all occurrences of the string in moves by cutting out the occurrences of the string at the th and th positions In this case the string is an example of the form It is also possible to cut occurrences of the string at the th and th positions There are two different sequences of minimum length moves Since the answer can be large output it modulo ,First find all occurrences of in as substrings This can be done using the prefix function To find the minimum number of times we need to cut substrings consider all indexes of occurrences Having considered the index of the occurrence we cut out the rightmost occurrence that intersects with it After that we find the leftmost occurrence that does not intersect with the cut one If it doesn t we end the loop The number of optimal sequences of moves will be calculated using dynamic programming For each occurrence we can count how many ways we can cut out all occurrences of in the suffix starting with this occurrence in the minimum number of moves Considering the occurrence we find the leftmost occurrence that does not intersect with it and then iterate over the occurrences with which we can remove it ,I m feeling extremely amused by the power of Aho Corasick lately so I will describe two solutions of this problem with it Feel free to point out how cool you are solving the task with hashes or some suffix structure but Aho solutions will still be cooler I also want to mention I m quite proud of the name I came up with for that task First let s assume that the words in the dictionary are unique Build an Aho Corasick automaton on the dictionary Then build the tree of its suffix links For the first solution you can use the fact that there are not a lot of words in the dictionary that can end in each position To be exact at most one word per unique word length Thus that s bounded by the square root of the total length For that reason you can iterate over all the words that end in all positions of the queries in How to do that fast For each vertex of the automaton precalculate the closest vertex up the suffix link tree that s a terminal Feed the query word into the automaton and from each vertex you stay at just jump up the tree until you reach the root Take the maximum value over all the visited terminals The second solution actually involves an extra data structure on top of that No it s not HLD You are boring for using it Let s abuse the fact that you are allowed to solve the problem fully offline For each word you can save the list of pairs time value of the times the value of the word changed For each vertex of the automaton you can save all the times that vertex has been queried from Now traverse the tree with dfs When you enter the vertex you want to apply all the updates that are saved for the words that are terminals here What are the updates From the list we obtained for a word you can generate such triples that this word had value from query to query Don t forget the value from to the first update to this word Then ask all the queries Then go to children When you exit the vertex you want all the updates to be gone Well there is a trick for these kinds of operations it s called rollbacks Maintain a segment tree over the query times the th leaf should store the maximum value during the th query The update operation updates the range with the new possible maximum How to avoid using lazy propagation with such updates Well on point query you can collect all the values from the segtree nodes you visit on your way down That way you don t have to push the updates all the way to the leaves Not that it matters that much but the number of values to be saved for future rollbacks is decreased dramatically That solution works in 
335,Polycarp likes arithmetic progressions A sequence is called an arithmetic progression if for each the value is the same For example the sequences and are arithmetic progressions but and are not It follows from the definition that any sequence of length one or two is an arithmetic progression Polycarp found some sequence of positive integers He agrees to change each element by at most one In the other words for each element there are exactly three options an element can be decreased by an element can be increased by an element can be left unchanged Determine a minimum possible number of elements in which can be changed by exactly one so that the sequence becomes an arithmetic progression or report that it is impossible It is possible that the resulting sequence contains element equals ,If we can print because each such sequence is an arithmetic progression Note that an arithmetic progression is uniquely determined by the first two terms So we should brute from to the change of the first element of the given sequence and from to the change of the second element of the given sequence Then and Also we will store the number of changed elements in the sequence Initially Now we need to iterate through the sequence from the third element to th Let current element in the position It should be equals to If then such arithmetic progression is unreachable Else if we should increase on one After we considered all elements we should update the answer with the value of if for all it was true that ,The easiest way to solve to problem is probably to see the resemblense of a shuffle operation to an std rotate function So you can obtain the final deck by applying cyclic shifts of the deck by then and so on Since the shifts are cyclic it doesn t matter if you shift by or by or by for any non negative The result will be the same Thus you can calculate the sum of rotations you apply and subtract until it becomes less than That is taking it modulo Finally after rotating a sequence by some the th element of it indexed becomes the first one Thus you just want to print the th element of Overall complexity per testcase 
336,Polycarp plays a well known computer game we won t mention its name In this game he can craft tools of two types shovels and swords To craft a shovel Polycarp spends two sticks and one diamond to craft a sword Polycarp spends two diamonds and one stick Each tool can be sold for exactly one emerald How many emeralds can Polycarp earn if he has sticks and diamonds ,There are three constraints on the number of emeralds the number of emeralds can t be greater than the number of emeralds can t be greater than the number of emeralds can t be greater than So the answer is ,There are lots of different solutions for this problem We can iterate on the number of elements we will take in this editorial element is a souvenir with weight When fixing the number of elements let it be we want to know the best possible answer for the weight while taking into account only elements and elements To answer these queries we can precalculate the values triples where is the best possible answer for the weight and and is the number of elements and elements we are taking to get this answer Of course and we can update and using value of After precalculating for each possible we can iterate on the number of elements There are also several binary ternary search solutions 
337,You are given segments on a coordinate axis The th segment has borders All points for which holds belong to the th segment Your task is to choose the by size the number of segments subset of the given set of segments such that each pair of segments in this subset either non intersecting or one of them lies inside the other one Two segments and are non intersecting if they have For example segments and and are non intersecting while segments and and are intersecting The segment lies inside the segment if and For example segments and lie inside the segment while and are not You have to answer independent test cases ,Firstly let s compress the given borders of segments just renumerate them in such a way that the maximum value is the minimum possible and the relative order of integers doesn t change Pretty standard approach Now let s do recursive dynamic programming This state stores the answer for the segment not necessarily input segment How about transitions Firstly if there is a segment covering the whole segment why don t just take it It doesn t change anything for us The first transition is just skip the current left border and try to take the additional answer from the state The second transition is the following let s iterate over all possible segments starting at we can store all right borders of such segments in some array Let the current segment be If just skip it if then we can t take this segment into the answer because it s out of and if then we can t take it because we considered it already Then we can take two additional answers from and from Don t forger about some corner cases like when or and something like that You can get the answer if you run the calculation from the whole segment What is the time complexity of this solution We obviously have states And the number of transitions is also pretty easy to calculate Let s fix some right border For this right border we consider segments in total Summing up we get transitions So the time complexity is P S I am sorry about pretty tight ML yeah I saw Geothermal got some memory issues because of using map I really wanted to make it 512MB but just forgot to do that ,Let s solve the problem for a single query at first There are two possible types of collisions between two buildings and between a building and a ray Obviously if the collision of the second type happens then it s the building which is the closest to the bend point from either left or right The less obvious claim is that among all buildings collisions the closest is the biggest angle one Let s boil down some possibilities of colliding buildings Let two buildings be the same distance from the bend point Then they will collide and the collision point will Two buildings also collide if the left one is from and the right one is Then the point of collision is And for the opposite case the point of collision is also These points can be easily proven by checking the distances to upper corners of each building No other two buildings will collide Now that we know this we can transition to solving a problem of checking if there exists such a pair that the distances to from them differ by at most one Finding such a pair with minimal is enough Obviously this can be done with some sort of two pointers However that s not the intended solution Let s constuct bitset of 7000 positions to the left of the bend and to the right of the bend AND of these bitsets will give you the pairs such that the distance is the same for them However you can put 1 in points and for each building to the left and and for each building to the right This way AND will give you the exact pairs you need Use Find first to find the closest one Let collision happen on distance Then the collision of the first type will have angle and the collision of the second type will have angle The answer is the maximum of these two values Be careful with cases where How to process lots of queries Let s just move the bitsets to the right while going through queries in ascending order Bitsets can be updated in for each query and only buildings will be added to them in total Overall complexity 
338,We have a secret array You don t know this array and you have to restore it However you know some facts about this array The array consists of greater than integers The array contains two elements and these elements are for you such that If you sort the array in increasing order such that differences between all adjacent consecutive elements are equal i e It can be proven that such an array always exists under the constraints given below Among all possible arrays that satisfy the given conditions we ask you to restore one which has the maximum element In other words you have to minimize You have to answer independent test cases ,The only fact required to solve this problem is just to notice that the answer array is just an arithmetic progression After that we can fix the first element fix the difference construct the array check if and are in this array and if yes update the answer with This is solution There are faster solutions though Other author s solution is but I didn t want to make this problem harder so I allowed solutions It is obvious that the difference of the progression is some divisor of Let it be Let s add some elements starting from to the left and so on and stop if we reach elements or the next element is less than If we didn t find among these elements just skip this difference it is useless for us Otherwise if we have less than elements let s add and so on until we get elements And then update the answer with the maximum element of the array There is also a solution in with some greedy observations ,Let s notice that if we multiply the numbers then the power of two of the product is equal to the sum of the powers of two in each of the numbers Let s calculate the initial sum of the powers of twos in the product This can be done as follows let s take the element and divide it by as long as we can while remembering to increase our counter by the number of occurrences of a power of two Now let s move on to operations and note that choosing the index will increase the degree of occurrence of two by a fixed number that is it does not matter when to apply this operation Choosing an index will increment the counter by a number such that is divisible by but not by you can find this again by dividing by while we can Since we want to minimize the number of operations used at each moment of time we will try to use an index that increases the counter by the largest number To do this it is enough to sort the indices by this index of increase and take them greedily from the largest increase to the smallest We get the solution in 
339,Now elections are held in Berland and you want to win them More precisely you want everyone to vote for you There are voters and two ways to convince each of them to vote for you The first way to convince the th voter is to pay him coins The second way is to make other voters vote for you and the th voter will vote for free Moreover the process of such voting takes place in several steps For example if there are five voters with then you can buy the vote of the fifth voter and eventually everyone will vote for you Set of people voting for you will change as follows Calculate the minimum number of coins you have to spend so that everyone votes for you ,Denote the number of voters with as Also denote i e is equal to number of voters with Let s group all voters by value We ll consider all these group in decreasing value of Assume that now we consider group with Then there are two cases if then all these voters will vote for you for free is equal to the number of votes bought in previous steps if then we have to buy additional votes Moreover the value of this bought voter must be greater than or equal to Since these voters indistinguishable we have to buy cheapest voter with a minimal value of So all we have to do it maintain values not yet bought voters in some data structure for example in ,To solve the problem you need to understand two facts The answer can t be greater than If current distance between rivaling student if less then we always can increment this distance by one swap In means that answer is equal to 
340,You are given an array consisting of integers from to A subarray is good if the sum of elements of this subarray is equal to the length of this subarray For example if then there are good subarrays and Calculate the number of good subarrays of the array ,We use zero indexing in this solution We also use half closed interval so subarray is Let s precalculate the array where so if sum of first elements of Then subarray is good if so Thus we have to group all prefix by value for from to And if the have prefix with same value of then we have to add to the answer ,First we can always get a product value equal to if we remove all elements of the array Then we need to know what maximal value of the product we can get Consequently the remaining array after removing the corresponding prefix and suffix should have no elements We can find maxima in all sections between zeros Now we are left with a set of nonzero numbers If the value of the product on the current segment is positive it makes no sense to remove any more elements Otherwise the product is negative then we must remove one negative number from the product either to the left or to the right Compare the values of the product on the prefix and suffix to the nearest negative value and remove either the suffix or the prefix respectively 
341,Suppose you are given a sequence of pairs of integers You can perform the following operations on it Choose some position and by That can be performed only if there exists at least one such position that and The cost of this operation is Choose some position and by That can be performed only if there exists at least one such position that The cost of this operation is Each operation can be performed arbitrary number of times possibly zero Let be minimum possible such that there exists a sequence of operations with total cost after which all from are pairwise distinct You are given a sequence consisting of pairs of integers All are pairwise distinct Let be the sequence consisting of the first pairs of Your task is to calculate the values of ,Let s firstly try to come up with some naive solution Suppose we have a list and want to calculate for it Let s sort this list comparing the pairs by their values of and then process them one by one We will divide this list into some parts we will call them with the following process when processing the first pair in the sorted order let s iterate on the next pairs also in the sorted order and add them to the first pair s component until the following condition is met where is the index of the first pair we added and is the index of the pair we are currently trying to add to s component remember that we consider all these pairs in the sorted order What is the meaning of this condition means that the number of pairs between and including these two is not less that the number of integers in and while this condition is met we can use the first operation in order to make a pair having for every And the first time when the condition is met we obviously cannot expand the segment in such a way It means that the value of will always be greater than value of and won t belong to the same component with and will start creating its own component instead These components we form have one special property Suppose we expanded the component so that there are no two equal values of in it Then we may reorder the pairs in this component as we wish to do so we may contract the component using the second operation and then expand it again Of course the best course of action is to sort the pairs in the component by their values of in descending order After doing this for every component we will obtain an optimal configuration such that all values of are distinct and it s easy to calculate the answer Okay now we need to do it fast The following will help us DSU Some implicit logarithmic data structure the operations we need are count the sum of elements less than and count the number of elements greater than your implementation might use other operations Small to large merging DSU will help us maintain the components A data structre will be built for each component containing the values of in it it will help us to maintain the sum of where is the optimal index of in this component Depending on your implementation you may or may not need to store the minimum value of in the component When inserting some element having into some component the elements having don t change their position the new element will be added right after them and the remaining elements will be shifted to the right so the sum of can be maintained if we query the number of elements greater than and the sum of elements less than Okay but we still don t know how we create the components and how we determine if two components are to merge We will keep these components in expanded form that is when processing a pair let s find the leftmost unoccupied position after or if it is not occupied and occupy it with the new pair creating a new component for it If the newly occupied index is let s try to merge new component with components occupying and if there are any to merge two components do the required operations in DSU and unite the data structures built in these components with small to large method All this works in the most time consuming part is merging the data structures ,Let s iterate over the length of the first segment of the split Having fixed it we actually fixed the sum that needs to be collected on all other segments Since each element must belong to exactly one segment we can build other segments greedily If we have found a solution we will remember the length of the longest segment in it and try to update the answer We have possible lengths of the first segment for each of which we greedily built the answer for Thus the asymptotics of the solution will be 
342,You are given a sequence of integers of length and integer number You should print number in the range of i e such that exactly elements of given sequence are less than or equal to Note that the sequence can contain equal elements If there is no such print without quotes ,In this problem you can do the following thing firstly let s sort our array Let will be the answer Then you have two cases if then otherwise for 0 indexed array Then you need to calculate the number of the elements of the array that are less than or equal to Let it be Then if or then print otherwise print ,At first let s reverse arrays and Now array is sorted in descending order Now let s find minimum index such that If there is no such index or if then the answer is because minimum on any prefix of array will never be equal to Otherwise let s find the minimum index such that If there is no such index or if then the answer is Also let s find the minimum index such that it can t be greater than The first subarray starts in position and ends in any position because if it ends in position or further then the minimum in the first subarray is greater than So there are ways to split subarrays and A similar approach can be used to calculate the number of ways to split the second and third subarrays and so on After all you have to check that minimum in the last subarray is equal to otherwise the answer is 
343,You are given an array consisting of integer numbers Let of the array be the following value You have to remove element from this array to minimize of the resulting elements array Your task is to calculate the minimum possible ,It is easy to see that we always have to remove either minimum or maximum of the array So we can sort the array and the answer will be We also can do it without sort because two minimal and two maximal elements of the array can be found in linear time ,In this problem the following greedy solution works let s maintain the last element of the increasing sequence we got and on each turn choose the minimum element greater than this last element among the leftmost and the rightmost Such turns will maximize the answer You can find details of implementation in the authors solution 
344,You know it s hard to conduct a show with lots of participants and spectators at the same place nowadays Still you are not giving up on your dream to make a car crash showcase You decided to replace the real cars with remote controlled ones call the event Remote Control Kaboom Show and stream everything online For the preparation you arranged an arena an infinite 2D field You also bought remote controlled cars and set them up on the arena Unfortunately the cars you bought can only go forward without turning left right or around So you additionally put the cars in the direction you want them to go To be formal for each car you chose its initial position and a direction vector Moreover each car has a constant speed units per second So after car is launched it stars moving from in the direction with constant speed The goal of the show is to create a car collision as fast as possible You noted that launching every car at the beginning of the show often fails to produce any collisions at all Thus you plan to launch the th car at some moment Note that it s not necessary for to be integer and is allowed to be equal to for any The show starts at time The show ends when two cars and collide i e come to the same coordinate at the same time The duration of the show is the time between the start and the end What s the fastest crash you can arrange by choosing all If it s possible to arrange a crash then print the shortest possible duration of the show Otherwise report that it s impossible ,Let be true if it s possible to have a collision before time That function is monotonous thus let s binary search for For some fixed car can end up in any point from to units along the ray That makes it a segment So the collision can happen if some pair of segments intersects Let s learn how to find that out The general idea is to use sweep line So let s add the events that the th segment such that opens at and closes at There were no vertical segments so and are always different At every moment of time we want to maintain the segments ordered by their intersection with the line Note that if two segments change their order moving along the sweep line then they intersect So we can maintain a set with a custom comparator that returns if one segment intersects the current line lower than the other one When adding a segment to set you want to check it s intersections with the next segment in the order and the previous one When removing a segment you want to check the intersection between the next and the previous segment in the order If any check triggers then return true immediately It s easy to show that if the intersection happens between some pair of segments then the intersection between only these pairs of segment also happens Now for the implementation details Precision errors play a huge role here since we use binary search and also store some stuff dependant on floats in the set The solution I want to tell requires no epsilon comparisons thus it calculates the answer only with the precision of binary search So the first issue rises when we have to erase elements from the set Notice that we can make a mistake when we are adding the segment and there is a segment with almost the same intersection point That will not make the answer incorrect that s not trivial to show but it s possible if you consider some cases If you can find it later to remove then it s not an issue at all However that will probably mess up the lower bound in the set Thus let s save the pointer to each element in the set and remove it later by that pointer The second issue comes when you have to check the intersection of two segments The error might appear when one segment let the first point be the original and the second point be calculated depending on has it s intersection point with segment at exactly So the slightest miscalculations could matter a lot Let s learn to intersect in such a way that no epsilon comparisons are required Firstly we can store lines in the set instead of segments Second we can check the intersection of rays first and only then proceed to check the intersection of segments So two rays intersect if their lines intersect easy to check in integers the intersection point lies in the correct direction of both rays the intersection point is always a pair of fractions and you want to compare the signs of and Finally if all the checks hold then you can compare maximum of distances from and to the intersection point and If is greater or equal then they intersect in time There is no way to make that comparison in integers However it s precision only depends on the precision of as in the error here can t affect the answer greatly Overall complexity ,Let s solve the problem greedily Let s make the first segment by adding elements until the segment will be good After that let s make the second segment in the same way and so on If we couldn t make any good segment then the answer is Otherwise let s add all uncovered elements at the end to the last segment Easy to prove that our construction is optimal consider the first two segments of the optimal answer obviously we can extend the second segment until the first segment will be equal to the first segment in our construction 
345,Polycarp has three sisters Alice Barbara and Cerene They re collecting coins Currently Alice has coins Barbara has coins and Cerene has coins Recently Polycarp has returned from the trip around the world and brought coins He wants to distribute these coins between his sisters in such a way that the number of coins Alice has is equal to the number of coins Barbara has and is equal to the number of coins Cerene has In other words if Polycarp gives coins to Alice coins to Barbara and coins to Cerene then that A B or C the number of coins Polycarp gives to Alice Barbara and Cerene correspondingly can be 0 Your task is to find out if it is possible to distribute coins between sisters in a way described above You have to answer independent test cases ,Suppose If it isn t true then let s rearrange our variables Then we need at least coins to make and equal So if then the answer is Otherwise the answer if if the number is divisible by This is true because after making and equal we need to distribute all remaining candies between three sisters ,A little explanation this editorial will be based on the easy version editorial so I ll use some definitions from it Here we go the most beautiful problem of the contest is waiting us Well the key idea of this problem almost the same with the easy version idea Let s iterate over the number of elements in group we need to take the cheapest ones again If the number of elements we take from group is then we need to take elements from and groups But one more thing let s iterate over not from zero but from the smallest possible number which can give us any correct set of books the numeric value of the answer doesn t matter The value of can be calculated using and sizes of groups by formula or even simple loop If we can t find any suitable value of the answer is Let s call elements from group and elements from and groups we take Other elements of the whole set of books are but Let s create the set which contains all free elements and fill it beforehand So now we took some necessary elements but we need to take some free elements to complete our set Let s create the other set which contains free elements we take to the answer and maintain the variable describing the sum of elements of How do we recalculate Before the start of the first iteration our set is already filled with some elements let s update using them Update is such an operation function that tosses the elements between and It will do the following things repeatedly and stop when it cannot do anything While the size of is greater than needed so we take more than books in total let s remove the most expensive element from and add it to while the size of is less than needed so we take less than books in total let s remove the cheapest element from and add it to while the cheapest element from is cheaper than the most expensive element form let s swap them Note that during updates you need to recalculate as well So we go over all possible values updating before the first iteration and after each iteration The size of both sets changes pretty smooth if we go from to we need to remove at most one element from because we take one element from group during each iteration and we need to add at most two elements to and because we remove at most two elements from and groups during one iteration To restore the answer let s save such a value that the answer is minimum with this value let it be Then let s just run the same simulation once more from the beginning but stop when we reach Then will contain free elements we need to take to the answer describes the number of elements we need to take from group and describes which elements from and groups we need to take Of course there are some really tough technical things like case handling there is a lot of cases for example the size of can be negative at some moment and you need to carefully handle that and can be negative after some number of iterations and there are other cases because of that and so on Time complexity 
346, Polycarp is a very famous freelancer His current rating is units Some very rich customers asked him to complete some projects for their companies To complete the th project Polycarp needs to have at least units of rating after he completes this project his rating will change by his rating will increase or decrease by can be positive or negative Polycarp s rating should not fall below zero because then people won t trust such a low rated freelancer Polycarp can choose the order in which he completes projects Furthermore he can even skip some projects altogether To gain more experience and money of course Polycarp wants to choose the subset of projects and the order in which he will complete them so he has enough rating before starting each project and has non negative rating after completing each project Your task is to calculate the maximum possible size of such subset of projects ,To view the main idea of the problem read the editorial of easy version The only difference is that for non negative we don t need to print if we cannot take the project we just need to skip it because we cannot take it at all And for negative we need to write the knapsack dynamic programming to take the maximum possible number of projects we need to consider them in order of their sorting Dynamic programming is pretty easy means that we consider projects and our current rating is and the value of dp is the maximum number of negative projects we can take If the current project is the th negative project in order of sorting we can do two transitions and if then we can make the transition And then we just need to find the maximum value among all values of dp and add the number of positive projects we take to find the answer ,This is a pretty obvious binary search problem If we get banned after messages we also get banned after and so on messages and vice versa if we don t get banned after messages we also don t get banned after and so on messages For simplicity let s split the problem into two parts when we check if we re getting banned after messages let s handle cases and separately Recall that the sum of the arithmetic progression consisting of integers is Let it be The first case is pretty simple the number of emotes we send with messages when is which is So we only need to check if The second case is a bit harder but still can be done using arithmetic progression formulas Firstly we send all messages for the number of such messages is Then we need to add messages This number equals to i e we send all messages from to and subtract messages from to from this amount The final condition is Time complexity per test case 
347,Monocarp wrote down two numbers on a whiteboard Both numbers follow a specific format a positive integer with zeros appended to its end Now Monocarp asks you to compare these two numbers Can you help him ,First let s say that appending the number with zeros is the same as multiplying it by The given numbers are so large that they can t fit into any reasonable integer type Even if you use a language with unlimited length integers python for example or store the numbers in strings you should still face the time limit issue So let s learn to shrink the numbers a bit Note that the result of the comparison of two numbers doesn t change if you divide both numbers by the same positive number So we can keep dividing both numbers by until one of them is not divisible anymore Let s also ignore the trailing zeros in and and leave them as is If the first number is appended with zeros and the second numbers is appended with zeros we can subtract from both values effectively dividing both numbers by This way one of the numbers becomes short enough to fit into an integer type because it has and is only up to The other number might still be large enough However if it s really large we can instantly say that it s larger than another one Say if its is at least This number it at least and the other number is at most Otherwise we can calculate this number as well and compare the values normally Overall complexity per testcase ,Let denote the sum of the digits of The key observation is the following after the operation is applied to index thrice it won t change after any further operations The proof is provided at the bottom of the editorial So we only need to update if it s been updated at most times so far otherwise we can ignore it This allows us to do the following solution store the current active indices that is indices that have been updated times in a sorted list for example in C Then search for the smallest active index at least since the list is sorted we can do it in Afterwards update that index replace with remove it if it s no longer active and binary search for the next largest active index in the sorted list until we pass just output Although it looks like we take time for each update we actually only ever update each element of the array at most times so we will do no more than binary searches Therefore the time complexity is amortized To show this note that initially The maximum possible value of the sum of the digits of is achieved when So Now considering the numbers from to the one with maximum sum of digits is with Hence Finally considering the numbers from to the one with maximum sum of digits is so That is after three operations becomes a single digit Any further operations and it won t change any more 
348,Jack decides to invite Emma out for a dinner Jack is a modest student he doesn t want to go to an expensive restaurant Emma is a girl with high taste she prefers elite places Munhattan consists of streets and avenues There is exactly one restaurant on the intersection of each street and avenue The streets are numbered with integers from to and the avenues are numbered with integers from to The cost of dinner in the restaurant at the intersection of the th street and the th avenue is Jack and Emma decide to choose the restaurant in the following way Firstly Emma chooses the street to dinner and then Jack chooses the avenue Emma and Jack makes their choice optimally Emma wants to maximize the cost of the dinner Jack wants to minimize it Emma takes into account that Jack wants to minimize the cost of the dinner Find the cost of the dinner for the couple in love ,Firstly you should find the minimum value in each row and after that you should find the maximum value over that minimums It s corresponding to the strategy of Jack and Emma ,Since we know that every disliked song should have lower rating than every liked song we actually know which new ratings should belong to disliked songs and which should belong to the liked ones The disliked songs take ratings from to the number of zeros in The liked songs take ratings from the number of zeros in plus to Thus we have two independent tasks to solve Let the disliked songs have ratings Their new ratings should be We can show that if we sort the array then will be the lowest possible The general way to prove it is to show that if the order has any inversions we can always fix the leftmost of them swap two adjacent values and the cost doesn t increase So the solution can be to sort triples and restore from the order of in these Overall complexity per testcase 
349,You are given a binary string i e a string consisting of characters and or of length You can perform the following operation with the string choose a substring a contiguous subsequence of having characters in it and shuffle it reorder the characters in the substring as you wish Calculate the number of different strings which can be obtained from by performing this operation at most once ,We could iterate on the substrings we want to shuffle and try to count the number of ways to reorder their characters but unfortunately there s no easy way to take care of the fact that shuffling different substrings may yield the same result Instead we will iterate on the first and the last character that are changed Let these characters be and First of all let s check that they can belong to the same substring we can shuffle it is the case if the string contains at least characters and the substring from the th character to the th character contains at most characters Then after we ve fixed the first and the last characters that are changed we have to calculate the number of ways to shuffle the characters between them including them so that both of these characters are changed Let s calculate and the number of characters and respectively in the substring Then we need to modify these two values for example if the th character is then since it is the first changed character it should become so we need to put there and decrease by one The same for the th character Let and be the values of and after we take care of the fact that the th and the th character are fixed The remaining characters can be in any order so the number of ways to arrang them is We can add up these values for all pairs such that we can shuffle a substring containing these two characters We won t be counting any string twice because we ensure that is the first changed character and is the last changed character Don t forget to add to the answer the string we didn t count is the original one This solution works in but the problem is solvable in ,Let s find the first and the last position of characters denote them as and respectively Since the can t delete characters all characters between and will remain So we have to delete all characters between and 
350,Polycarp has a favorite sequence consisting of integers He wrote it out on the whiteboard as follows he wrote the number to the left side at the beginning of the whiteboard he wrote the number to the right side at the end of the whiteboard then as far to the left as possible but to the right from he wrote the number then as far to the right as possible but to the left from he wrote the number Polycarp continued to act as well until he wrote out the entire sequence on the whiteboard For example if and then Polycarp will write a sequence on the whiteboard You saw the sequence written on the whiteboard and now you want to restore Polycarp s favorite sequence ,In this problem you can implement an algorithm opposite to that given in the condition Let s maintain two pointers to the left most and right most unhandled element Then restoring the original array you put the left most unhandled item in the first position put the right most unhandled item in the second position put the left most unhandled item in the third position put the right most unhandled item in the fourth position That is in general you put the leftmost elements on all odd positions and the rightmost ones on all even positions After processing each element you either move the left pointer forward by one or the right one backward by one ,We will perform each move in reverse from the final sequence of the cypher move it increases the th digit by After applying the up move on it becomes move denoted by it decreases the th digit by After applying the down move on it becomes Now we just need to implement the two types of moves The time complexity is per test case 
351,You have gifts and you want to give all of them to children Of course you don t want to offend anyone so all gifts should be equal between each other The th gift consists of candies and oranges During one move you can choose some gift and do one of the following operations eat exactly from this gift decrease by one eat exactly from this gift decrease by one eat exactly and exactly from this gift decrease both and by one Of course you can not eat a candy or orange if it s not present in the gift so neither nor can become less than zero As said above all gifts should be equal This means that after some sequence of moves the following two conditions should be satisfied and and equals is Your task is to find the number of moves required to equalize all the given gifts You have to answer independent test cases ,At first consider the problems on candies and oranges independently Then it s pretty obvious that for candies the optimal way is to decrease all to the value we need obtain at least this value to equalize all the elements and there is no point to decrease elements further The same works for the array Then if we unite these two problems we need to take the maximum moves we need for each because we need exactly that amount of moves to decrease to and to simultaneously So the answer is ,The solution consists of several steps Let s find out does the first box contain stone or valuable gift using random Let s make queries to compare the weight of the first box with the weight of another random box If the first box is lighter than we found an answer otherwise the probability of the first box having stones is at least Let s compare the weights of the first box and the second one If they are equal then let s compare the weights of boxes and If they are equal then let s compare the boxes and and so on In other words let s find the minimum such that contains only boxes with stones but contain at least one box with a valuable gift It s easy to see that we d spend no more than queries We have segment with only stones and with at least one gift Let s just binary search the leftmost gift in the segment using boxes from as reference if we need to know does segment of boxes have at least one gift let s just compare it with segment which have only stones if is lighter then it has otherwise doesn t have This part also requires no more than queries 
352,You are given a connected undirected weighted graph consisting of vertices and edges You need to print the th smallest shortest path in this graph paths from the vertex to itself are not counted paths from to and from to are counted as one More formally if is the matrix of shortest paths where is the length of the shortest path between vertices and then you need to print the th element in the sorted array consisting of all where ,The main observation is that you don t need more than smallest by weight edges among all edges with the maximum weights you can choose any Maybe there will be a proof later but now I ask other participant to write it So you sort the initial edges and after that you can construct a graph consisting of no more than vertices and no more than edges You just can build the new graph consisting only on these vertices and edges and run Floyd Warshall algorithm to find the matrix of shortest paths Then sort all shorted distances and print the th element of this sorted array Time complexity I know that there are other approaches that can solve this problem with greater but to make this problem easily this solution is enough , editorial by PikMike Firtsly we can notice that we get the most profit by placing the edge in a same position no matter the query Moreover once you have calculated the minimum difference you can apply to the shortest path by adding edge of the weight you can answer the queries in each Let the current shortest distance between and be Then the answer to some query is Let s proceed to proofs of the following Consider any of the optimal positions for the edge of weight Then weight will add to the answer in this position if the path isn t already but that is trivial Let there be another position such that the answer in it is less than the current one That means that the answer for weight in it is less by which is smaller than the first one we got which leads to contradiction The second fact can deduced from the first one Then let me introduce the next bold statement We root the tree with vertex Then if there exists such a vertex in that it s not an ancestor of vertex and the number of vertices in its subtree inclusive is greater than then That is simple just put the edge between the parent of this vertex and any of vertices of the subtree there always be such that the edge doesn t exist yet That won t change the shortest path no matter which it is Then we have a graph of the following kind That is the simple path between and and some vetices on it have additional children leaves Finally let s proceed to the solution We want to choose such a pair of vertices that the sum of edge on a path between them which are also a part of the path between and plus the weights of the newly included to shortest path edges if any is minimal possible Let s precalc the sum of weights of edges from vertex to vertex and parent of vertex Let be the weight of an edge between and Then we end up with the four basic cases for these vertices and with having greater or equal number of edges on path to than each of the form whether belongs to the simple path between and whether belongs to it doesn t belong the answer is belongs doesn t both belongs Each of these formulas can be broken down to parts with exacly one of the vertices Let s call them and That means minimizing the result is be the same as minimizing each of the parts We run depth first search on vertices which belong to a simple path between and inclusive Maintain the minimum value of you have already passed by Try connecting each vertex with this and also parent of the parent of the current vertex using all the possible formulas and updating with the resulting value Finally after the precalc is finished asnwer the queries in with Overall complexity editorial by BledDest Let s denote the distance from vertex to vertex in the tree as Similarly denote the distance from to in the tree as Suppose we try to add a new edge between vertices and with length Then two new paths from to are formed one with length and another with length Then the new length of shortest path becomes So if we find two non adjacent vertices such that is maximum possible then it will always be optimal to add an edge between these two vertices How can we find this pair of vertices Firstly let s suppose that when we pick vertex we will try to pair it only with vertices corresponding to the aforementioned constraint This can be done by sorting vertices by the value of and then for each vertex pairing it only with vertices that are later than in the sorted order How do we find the best pair for The best pair could be just the vertex with maximum possible but it is not allowed to connect a vertex with itself or its neighbour To handle it we may maintain a set of possible vertices delete all neighbours of from it pick a vertex with maximum and then insert all neighbours of back into the set This solution works in time 
353,You are given an array consisting of integers In one move you can jump from the position to the position if or to the position if For each position from to you want to know the minimum the number of moves required to reach any position such that has the opposite parity from i e if is odd then has to be even and vice versa ,In this problem we have directed graph consisting of vertices indices of the array and at most edges Some vertices have the value some have the value Our problem is to find for every vertex the nearest vertex having the opposite parity Let s try to solve the problem for odd numbers and then just run the same algorithm with even numbers We have multiple odd vertices and we need to find the nearest even vertex for each of these vertices This problem can be solved with the standard and simple but pretty idea Let s inverse our graph and run a multi source breadth first search from all even vertices The only difference between standard bfs and multi source bfs is that the second one have many vertices at the first step vertices having zero distance Now we can notice that because of bfs every odd vertex of our graph has the distance equal to the minimum distance to some even vertex in the initial graph This is exactly what we need Then just run the same algorithm for even numbers and print the answer Time complexity ,Consider a naive solution using Kruskal s algorithm for finding MST Given some you arrange the edges in the increasing order of and process them one by one Look closely at the arrangements At the edges are sorted by How does the arrangement change when increases Well some edges swap places Consider a pair of edges with different weights and Edge will go before edge in the arrangement as long as is closer to than So for all up to edge goes before edge And for all from onwards edge goes before edge This tells us that every pair of edge with different weights will swap exactly once So there will be at most swaps Which is at most different arrangements Each of them corresponds to some range of s We can extract the ranges of s for all arrangements and calculate MST at the start of each range We can also find the arrangement that corresponds to some from a query with a binary search However only knowing the weight of the MST at the start of the range is not enough The weights of edges change later in the range and we can t predict how Some edges have their weight increasing some decreasing First let s add more ranges We want each edge to behave the same way on the entire range either increase all the way or decrease all the way If we also add for all into the MST calculation this will hold Second let s store another value for each range the number of edges that have their weight increasing on it With that we can easily recalculate the change in the cost of the spanning tree The TL should be free enough for you to sort the edges for each MST calculation resulting in solution You can also optimize the first part to 
354,Given integers You can perform the following operation on them select any element and divide it by round down In other words you can replace any selected element with the value where is round down the real number Output the minimum number of operations that must be done for a sequence of integers to become strictly increasing that is for the condition to be satisfied Or determine that it is impossible to obtain such a sequence Note that elements be swapped The only possible operation is described above For example let and a sequence of numbers be given Then it is enough to perform two operations on it Write the number instead of the number and get the sequence Then replace with and get the sequence The resulting sequence is strictly increasing because ,We will process the elements of the sequence starting from the end of the sequence Each element will be divided by until it is less than If at some point it turns out that it is impossible to obtain the desired sequence ,It is easy to show that if we choose k numbers from a permutation of length n then the minimum sum of k numbers is frac k k 1 2 the maximum sum is frac k 2n 1 k 2 and any sum between them is achievable that is you can choose exactly k numbers from n so that their sum is equal to the desired one This fact allows us to implement the following greedy solution Denote for low k sum limits i 1 k i frac k k 1 2 for high n k sum limits i n k 1 n i frac k 2n 1 k 2 and for k r l 1 We will consider the numbers i n n 1 ldots 1 and determine whether to put them in the segment l r or not If k 0 high i k ge s and s i ge low k 1 then put the number i in the segment l r decrease s by i decrease k by 1 Otherwise we will not put the number i in the segment l r In the end if s 0 then we have chosen r l 1 a number with the sum of s so the remaining number can be arranged in any order If at the end s 0 then there is no way to select r l 1 a number from 1 2 ldots n with the sum of s 
355, people gathered in a room with tables They want to play the Hat times Thus games will be played at each table Each player will play in games To do this they are distributed among the tables for each game During each game one player plays at exactly one table A player can play at different tables Players want to have the most fair schedule of games For this reason they are looking for a schedule table distribution for each game such that At any table in each game there are either people or people that is either rounded down or rounded up Different numbers of people can play different games at the same table Let s calculate for each player the value the number of times the th player played at a table with persons rounded up Any two values of must differ by no more than In other words for any two players and it must be true For example if and then at the request of the first item either two players or three players should play at each table Consider the following schedules First game are played at the first table and at the second one The second game at the first table they play and at the second This schedule is since the second player played twice at a big table and the fifth player did not play at a big table First game are played at the first table and at the second one The second game at the first table they play and at the second one This schedule is any two values of differ by no more than Find any fair game schedule for people if they play on the tables of games ,For each game we want to seat people at tables of them will be big and will sit at them and will be small Each round people will sit at the big tables Let s put people with numbers at large tables in the first round for convenience we index from zero and the rest for small ones in the second round we will seat people at large tables with numbers and so on We cycle through the players from to in blocks of Since no one person can be ahead of any other by 2 or more large tables ,This task is about pure implementation Maintain the number of current spectator and check if he doesn t win With knowledge of current winner and current spectator you can easily get the third player by formula just the sum of all numbers without the known ones Overall complexity 
356, You are given an array consisting of integers The value of the th element of the array is You are also given a set of segments The th segment is where You can choose some subset of the given set of segments and decrease values on each of the chosen segments by one For example if the initial array and the given segments are and then you can choose both of them and the array will become You have to choose some subset of the given segments in such a way that if you apply this subset of segments to the array and obtain the array then the value will be possible Note that If there are multiple answers you can print ,Let s divide all segments to four classes The first class contains segments which covers both minimum and maximum values the answer of the resulting array the second class contains segments which covers only minimum value of the resulting array the third class contains segments which covers only maximum value of the resulting array and the fourth class contains segments which covers neither maximum nor minimum of the resulting array We can easy see that we cannot increase the answer if we apply segments of first and third classes What is common in this two classes Right both of them are cover maximum value So we can came up with the solution in or depends on implementation Let s iterate over position of the supposed maximum value and apply all segments which not cover it It can be done in with straight forward implementation or in using prefix sums After we apply all needed segments we can try to update the answer with the value of the obtained array ,This task is very straight forward implementation problem So we can iterate over all segments of the given array calculate their sum and if the length of the current segment is not less than k try to update the answer with the mean of this segment Overall complexity is O n 2 
357,As you might remember from our previous rounds Vova really likes computer games Now he is playing a strategy game known as Rage of Empires In the game Vova can hire different warriors th warrior has the type Vova wants to create a army hiring some subset of warriors An army is called if for each type of warrior present in the game there are not more than warriors of this type in the army Of course Vova wants his army to be as large as possible To make things more complicated Vova has to consider different plans of creating his army th plan allows him to hire only warriors whose numbers are not less than and not greater than Help Vova to determine the largest size of a army for each plan ,Every time we process a plan let s count only the first warriors of some type When will the warrior on position be counted Of course he has to be present in the plan so But also he has to be among first warriors of his type in this plan Let s denote a function is the position of previous warrior of the same type before warrior that is the greatest such that and If there s no any then if It is easy to prove that the warrior will be among first warriors in some plan iff and So we can make a new array Then we build a segment tree on this array The node of the segment tree will store all values of from the segment corresponding to this node in sorted order Then to get answer to the plan we have to count the number of elements on segment that are less than Complexity is or if you use fractional cascading technique ,If necessary change the values of and so that is always true Consider two cases 1 Let Then This means that the set is at least times larger than and we can form teams of the form where one participant will be a programmer and three will be mathematicians 2 Let Then assume that Let s substitute this value into the inequality Then we compose commands of the form Since making such a command decreases the value of by 2 The new value The condition still holds Then make commands of the form The total number of commands is That s what we wanted to get 
358,You are given a connected undirected graph consisting of vertices and edges There are no self loops or multiple edges in the given graph You have to direct its edges in such a way that the obtained directed graph does not contain any paths of length two or greater where the length of path is denoted as the number of traversed edges ,What if the given graph will contain a cycle of odd length It will mean that some two consecutive edges of this cycle will be oriented in the same way and will form a path of length two What if there is no cycles of odd length in this graph Then it is bipartite Let s color it and see what we got We got some vertices in the left part some vertices in the right part and all edges connecting vertices from different parts Let s orient all edges such that them will go from the left part to the right part That s it ,We can use dynamic programming to solve this problem but we need to choose the states we maintain very carefully One of the approaches might be the number of ways to connect the vertices between and to vertices or if and are already connected so there is no possibility to connect any vertex between and to some vertex outside What values should we access if we for example try to connect th vertex to some vertex To get everything connected we then have to connect vertices from interval to these two and vertices from to or and connections to from the second interval are difficult to handle We need to somehow get rid of them and the solution is to And vice versa if we connect something to then we choose the index of vertex to be connected with directly But that s not all we have to handle Suppose we have four vertices and is already connected to One of the possibilities to finish it is to connect to and to but if we process current dynamic programming as it is we will count it twice if we choose to connect to firstly or if we connect to To get rid of this problem we will use a flag that will denote whether we can connect anything to vertex and if we choose to pick the first connection from then we don t connect anything to So the solution is the number of ways to connect the vertices from interval to and and denotes if we can connect anything to How to calculate it If then there is nothing left to connect Otherwise set If then iterate on vertex we connect to and add Iterate on vertex we connect to and add The answer is if vertices are indexed Vertex is actually vertex so don t forget to update the matrix for it 
359,There is a frog staying to the left of the string consisting of characters to be more precise the frog initially stays at the cell Each character of is either or It means that if the frog is staying at the th cell and the th character is the frog can jump only to the left If the frog is staying at the th cell and the th character is the frog can jump only to the right The frog wants to reach the th cell The frog chooses some value and cannot change it later and jumps by no more than cells at once I e if the th character is then the frog can jump to any cell in a range and if the th character is then the frog can jump to any cell in a range The frog doesn t want to jump far so your task is to find the minimum possible value of such that the frog can reach the cell from the cell if it can jump by no more than cells at once You have to answer independent test cases ,The only observation we need is that we don t need to jump left at all This only decreases our position so we have less freedom after the jump to the left Then to minimize we only need to jump between the closest cells So if we build the array where is the position of the th cell from left to right indexed then the answer is Time complexity ,The solution for this problem is very simple at first if or the answer is Otherwise let s do the following thing times let be we have to greedily decrease the remaining distance but we also should remember about the number of moves which we need to perform We have to walk to possible house which is located at distance from the current house also don t forget to subtract from The proof of the fact that we can always walk to the house at distance is very simple one of the possible answers which is obtained by the algorithm above will looks like several moves of distance possibly one move of random distance less than and several moves of distance The first part of the answer can be obtained if we are stay near the leftmost or the rightmost house second and third parts always can be obtained because distances we will walk in every of such moves is less than Time complexity is 
360,There are people who want to participate in a boat competition The weight of the th participant is Only teams consisting of people can participate in this competition As an organizer you think that it s fair to allow only teams with So if there are teams where is the weight of the first participant of the th team and is the weight of the second participant of the th team then the condition where is the total weight of team should be satisfied Your task is to choose such that the number of teams people can create is the possible Note that each participant can be in team You have to answer independent test cases ,This is just an implementation problem Firstly let s fix it can be in range find the maximum number of boats we can obtain with this and choose the maximum among all found values To find the number of pairs let s iterate over the smallest weight in the team in range Let this weight be Then because the sum of weights is the biggest weight is And the number of pairs we can obtain with such two weights and the total weight is where is the number of occurrences of in And the additional case if is even we need to add Don t forget that there is a case so you need to assume that these values are zeros ,Accordingly as it was said in the task we put all tasks into the queue in the order of their arrival then we fix the time at the beginning as So while there is a task in the queue we proceed as follows Take the task from the queue Take as time the maximum from the current and from the arrival time of the task We subtract the current time from the time when the task was done Replace the current time with the time the task was done If there is a task in the queue go to item 
361,There are athletes in front of you Athletes are numbered from to from left to right You know the strength of each athlete the athlete number has the strength You want to split all athletes into two teams Each team must have at least one athlete and each athlete must be exactly in one team You want the strongest athlete from the first team to differ as little as possible from the weakest athlete from the second team Formally you want to split the athletes into two teams and so that the value is as small as possible where is the maximum strength of an athlete from team and is the minimum strength of an athlete from team For example if and the strength of the athletes is then one of the possible split into teams is first team second team In this case the value will be equal to This example illustrates one of the ways of optimal split into two teams Print the minimum value ,Let s found two athletes with numbers and the strength of is not greater than the strength of which have the minimal modulus of the difference of their strength Obviously we cannot get an answer less than this Let s show how to get the partition with exactly this answer Sort all athletes by strength Our two athletes will stand in neighboring positions otherwise we can decrease the answer Let the first team contains all athletes who stand on positions not further than and the second team contains other athletes We got a partition in which the athlete with number has the maximal strength in the first team and the athlete with number has the minimal strength in the second team ,Sort the weights now choosing and will split the array into three consecutive segments Consider a naive solution to the problem You can iterate over the length of the first segment and the second segment The third segment will include everyone remaining Now you have to check if there exist some and that produce such segment can be equal to the first element of the second segment since only all elements of the first segment are smaller than it Similarly can be equal to the first element of the third segment However if the last element of some segment is equal to the first element of the next segment no or can split the array like that Otherwise you can split an array like that So you can iterate over the lengths check the correctness and choose the best answer Now let s optimize it using the condition about powers of two First iterate over the size of the middle division which is a power of two Then over the length of the first segment which can be not a power of two Check if the first segment is valid So we fixed the length of the first segment and some value which is greater or equal than the length of the second segment That value isn t necessarily equal to the length of the second segment because the produced segment might be invalid So there is a greedy idea that the second segment should be as long as possible under the constraint that it doesn t exceed the fixed value The intuition is the following Consider the longest possible valid segment Now take the last element away from it We will have to invite one more participant to the middle division And that element will also get added to the third segment increasing its length So potentially you can only increase the required number of participants to invite This can be implemented in the following fashion For each position precalculate the closest possible segment border from the left Iterate over the size of the middle division as a power of two Iterate over the length of the first segment Find the closest border to the left of Get the lengths of the second and the third segments Find the closest powers of two to each length and update the answer Overall complexity per testcase 
362,You are given an integer array and an integer You perform the following code with it Your task is to calculate the expected value of the variable after performing this code Note that the input is generated according to special rules see the input format section ,I think it s easier to approach this problem using combinatorics instead of probability theory methods so we ll calculate the answer as the sum of values of over all ways to choose the index on each iteration of the loop If a number is chosen on the iteration of the loop then it is reduced to the maximum number divisible by that doesn t exceed the initial value So if a number is divisible by all integers from to i e divisible by it won t be changed in the operation Furthermore if then the value of this element won t become less than It means that we can interpret each number as where and The part with will always be added to the variable when this element is chosen so let s add to the answer which is the contribution of over all ways to choose the indices in the operations and work with instead of Now all elements of the array are less than We can use this constraint by writing the following dynamic programming to solve the problem is the number of appearances of the integer in the array over all ways to choose the indices for the first iterations For is just the number of occurrences of each integer in the array The transitions from are the following ones if this element is chosen in the operation then it becomes and we transition to the state otherwise the element is unchanged and we transition to the state multiplying the current value by which is the number of ways to choose some other element in the operation How can we use this dynamic programming to get the answer On the th iteration the number of times we choose the integer is exactly and the number of ways to use the integers in the next operations is so we add to the answer for every such state This solution runs in time which may be too slow if not implemented carefully Fortunately we have an easy way to optimize it use instead of which divides by in the worst case scenario for our solution We can do this because even if an integer is changed on the th operation we are not interested in this change since this is the last operation , can be arbitrarily large if and only if all numbers in the array are the same In this case we can choose any number and subtract it from all the numbers for example exactly once Suppose we fix some Let be the number of subtractions of the number from the number In this case all numbers will be equal if and only if for any two numbers and from the array Let be the minimum of Then all numbers in the array become the same if for each index we subtract from not but times Then we will never subtract from the element This means that there is always an element in the array from which we can never subtract This element is the minimum on the array Then from we will subtract exactly times Thus with the current it is possible to make all elements equal if and only if for all elements the value where is the minimum on the array is divisible by So the maximum is the greatest common divisor of all values of 
363,Consider the function where is an array of integers which returns an array consisting of integers such that is equal to the sum of first elements of array You have an infinite sequence of arrays where is given in the input and for each Also you have a positive integer You have to find minimum possible such that contains a number which is larger or equal than ,Let s delete all zeroes from the beginning of the array they won t affect the answer Also we will return an array of elements when calculating prefix sums sum of zero elements becomes a zero in the beginning of the array and so has to be removed If the size of array is at least then we will get after calculating only a few prefix sums so we can use simple iteration So now we have to obtain the solution in case array has less than elements If we remove zeroes from the beginning of each array then where is a matrix if otherwise Then we can use matrix exponentiation to check whether contains a number which is equal to or greater than and we can use binary search to find the answer To avoid overflows each time we get a number greater than we can set it to ,Note that or Since there is no upper bound for the values of the case where for all always exists It remains to check if there are other ways To do this it is enough to check whether there is such a position that the change to doesn t result in a negative value of The reason for is that for no matter the plus or minus we choose the array doesn t change If you could change at least one sign to minus that would be another answer 
364,You are given a tree consisting of vertices Each edge has an integer value written on it Let be the number of values that appear on the edges of a simple path between vertices and Calculate the sum of over all pairs of vertices and such that ,Let s use contribution to the sum technique to simplify the problem Instead of counting the number of colors that occure only once for each path let s for each color count the number of paths that contain this color exactly once Now we can solve the problem independently for each color and sum up the answers The first intended solution was the following So we want to calculate the answer for some color Mark all edges of color as good the rest are bad Then we can calculate the number of paths up to vertex such that they contain either or good edges The transitions should be pretty easy and the answer should be updated when you consider gluing up paths from different children in each vertex Obviously this is per color so overall However we can only calculate this dynamic programming as easily on a virtual tree of vertices adjacent to all good edges How to calculate the dp for some vertex First push the paths from all virtual children to That was enough in the dp for the entire tree but now there are also removed vertices that could also have paths starting in them All these paths contain good edges otherwise they would have had virtual vertices on them Their amount is the following the size of the real subtree of minus the sizes of real subtrees of all its virtual children The rest is exactly the same as in the dp on the real tree A little fun trick Usually you want to add lca of adjacent vertices to the virtual tree But that s actually not needed here you can just add the root of the tree and link the vertices without a parent to them That won t change the result of the dp That solution works in or The second intended solution is slower complexity wise but not time wise In the first solution we wanted to leave only the good edges in the tree Here we want to remove only them Consider the resulting connected components What s the number of paths that contain only one of the good edges It s actually the product of sizes of the connected components this edge connects So we want to remove edges add edges and maintain the sizes of the connected components of the tree That s basically the same problem as dynamic connectivity The implementation works well enough ,Let s think about why we can t always make a perfect vertex cover such a vertex cover that each edge has exactly one endpoint in it Or why the answer can not exist at all Consider a bamboo It s always possible to find a perfect vertex cover Just choose every other vertex in it and account for parity Make a bamboo into a loop Now you can see that an even length loop has a perfect vertex cover An odd length doesn t That tells us that each odd length loop in a graph will have a bad edge on it Odd length loops should instantly make you think about bipartite colorings So we can see that a bipartite graph always has a perfect vertex cover Just choose one of the parts into a cover and each edge will have exactly one endpoint in it At the same time a non bipartite graph never has a perfect cover So our general goal is to remove basically mark as bad at most one edge in such a way that the remaining graph is bipartite Consider a dfs tree of the graph colored bipartitely Every edge in the tree is good has endpoints in different parts Every edge outside the tree can be either good or bad What happens to the tree if we remove an edge If we remove an edge outside the dfs tree then nothing happens to it So if there is no more than one bad edge outside the tree then we found the answer That was the easy part Now what happens if we remove an edge from the tree The back edges from the subtree of the edge can force the subtree to either remain colored the same or flip all its colors We don t really care if it remains the same because we already took care of it in the first part So let s pretend it always flips the colors Thus all edges that go from the subtree upwards above the removed edge have only one of their endpoints colors changed Good edges turn bad bad edges turn good All other edges don t change So you should choose such an edge to remove that all bad edges in the graph go from its subtree upwards above that edge and no good edges go from its subtree upwards above that edge That can be calculated with a dfs Since all non tree edges in the dfs tree are back edges you can simply increment a counter on the bottom vertex decrement the counter on the top vertex and collect sums from the bottom The sum in the vertex will tell you the number of edges that start below or in the vertex and end above the vertex Do this for both kinds of edge and check the conditions for all vertices Finally choose such a part to be a vertex cover that the removed edge has both ends in it if you choose the other part that edge won t be covered at all The solution is linear but the problem still requires a massive time and memory limit only because of recursion in the dfs Overall complexity per testcase 
365,A batch of goods an even number is brought to the store th of which has weight Before selling the goods they must be packed into packages After packing the following will be done There will be packages each package contains exactly two goods The weight of the package that contains goods with indices and is With this the cost of a package of weight is always burles rounded down where a fixed and given value Pack the goods to the packages so that the revenue from their sale is maximized In other words make such pairs of given goods that the sum of the values where is the weight of the package number is For example let weights of goods Let s pack them into the following packages In the first package we will put the third and sixth goods Its weight will be The cost of the package will be burles In the second package put the first and fifth goods the weight is The cost of the package is burles In the third package put the second and fourth goods the weight is The cost of the package is burle With this packing the total cost of all packs would be burles ,Note that we do not need to consider the numbers we are only interested in the remainder of the division of by and we simply add the value to the answer We get an array where Let s sort it and greedily type index pairs such that This can be done with two pointers Then add the number of matching pairs to the answer counter This will be the answer to the problem ,There are two cases in this problem If we try to maximize the answer we need to consider only two integers and Of course the first one is better we get rid of the existing remainder and trying to add to this number If it s too big then we can and need to take the second one this number is just the first one but decreased by The answer can be always found between these numbers Time complexity 
366,You are given a bipartite graph consisting of vertices in the first part vertices in the second part and edges numbered from to You have to color each edge into one of two colors red and blue You have to minimize the following value where is the set of vertices of the graph is the number of red edges incident to and is the number of blue edges incident to Sounds classical and easy right Well you have to process queries of the following format add a new edge connecting the vertex of the first part with the vertex of the second part This edge gets a new index as follows the first added edge gets the index the second and so on After adding the edge you have to print the of the current optimal coloring if there are multiple optimal colorings print the of any of them print the optimal coloring of the graph with the same you printed while processing the previous query The query of this type will only be asked after a query of type and there will be at most queries of this type If there are multiple optimal colorings corresponding to this print any of them Note that if an edge was red or blue in some coloring it may change its color in next colorings The of the coloring is calculated as follows let be the set of indices of red edges then the is Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query Use functions in and in languages after each writing in your program ,Let s split all edges of the graph into several paths and cycles each edge will belong to exactly one path or cycle Each path and each cycle will be colored in an alternating way the first edge will be red the second blue the third red and so on or vice versa Since the graph is bipartite each cycle can be colored in an alternating way The main idea of the solution is to add the edges one by one maintain the structure of cycles and paths and make sure that for each vertex at most one path starts ends in it If we are able to maintain this invariant then the value of for every vertex will be minimum possible each cycle going through a vertex covers an even number of edges incident to it half of them will be red half of them will be blue so if the degree of a vertex is odd one path will have this vertex as an endpoint and otherwise it won t be an endpoint of any path so Okay how do we maintain this structure Let s add edges one by one even the original edges of the graph and rebuild the structure in online mode For each vertex we will maintain the indices of the paths that have this vertex as an endpoint If some vertex has or more paths as its endpoints we can choose two of them and link them together Whenever we add an edge from to we just create a new path and check if we can link together some paths that have or as their endpoints How do we link the paths together If we try to link a path with itself it means that we try to close a cycle and when we do it we just forget about the resulting cycle its structure won t change in future queries When we link a path with some other path we might need to reverse and or repaint the paths before merging them into one There are at least two possible data structures we can use to do this either an implicit key treap that supports reversing and repainting or a deque with small to large merging whenever we try to link two paths together we repaint and or reverse the smaller one Both of those methods give a solution in or depending on your implementation The model solution uses deques and small to large merging ,Formally the problem is to paint tree edges in minimal number of colors in such a way the the number of improper vertices doesn t exceed A vertex is improper if it has at least two incident edges of the same color It is easy to show that colors is always enough to paint a tree in such a way that all the vertices are proper where is the maximum vertex degree Actually it is always the truth do any bipartite graph Indeed if number of colors is less than the maximum degree such vertices will have at least two edges of the same color Dirichlet s principle If equals the maximum degree you can use just depth first search tree traversal to paint edges in different colors In this problem you can have up to improper vertices so just choose such minimal that number of vertices of degree greater than is at most In an alternative solution you can use a binary search to find such but it makes the implementation harder and the solution becomes slower by factor After it paint edges with colors each time choosing the next color skip color if it equals with the color of the traversal incoming edge 
367,You are given a string consisting of lowercase Latin letters and and question marks Let the number of question marks in the string be Let s replace each question mark with one of the letters and Here we can obtain all possible strings consisting only of letters and For example if then we can obtain the following strings Your task is to count the total number of subsequences in all resulting strings Since the answer can be very large print it modulo A subsequence of the string is such a sequence that can be derived from the string after removing some possibly zero number of letters without changing the order of remaining letters For example the string contains two subsequences a subsequence consisting of letters at positions and a subsequence consisting of letters at positions ,There are several more or less complicated combinatorial solutions to this problem but I will describe a dynamic programming one which I think is way easier to understand and to implement Suppose we have fixed the positions of and that compose the subsequence let these positions be and How many strings contain the required subsequence on these positions Obviously if some of these characters is already not a question mark and does not match the expected character on that position the number of strings containing the subsequence on that position is Otherwise since we have fixed three characters all question marks on other positions can be anything we want so the number of such strings is where is the number of question marks on positions other than and It allows us to write an solution by iterating on and and for every such triple calculating the number of strings containing the required subsequence on those positions But that s too slow Let s notice that for every such subsequence the number of strings containing it is where is the number of positions from that contain a question mark So for each integer from to let s calculate the number of subsequences matching that contain exactly question marks and that will allow us to solve the problem faster How can we calculate the required number of subsequences for every In my opinion the simplest way is dynamic programming let be the number of subsequences of that end up in position match first characters of and contain question marks The transitions in this dynamic programming are quadratic since we have to iterate on the next previous position from the subsequence but can be sped up to linear if we rewrite as the number of subsequences of that end up in position match first characters of and contain question marks Each transition is either to take the current character or to skip it so they can be modeled in and overall this dynamic programming solution works in ,Let s try to find the position of the leftmost occurrence of iterate over all positions from to If then this is the required position of the leftmost occurrence of Then the position of rightmost occurrence is so we can print the answer Otherwise let s decrease by remove all strings which have the leftmost at the current position and proceed to the next position It is obvious that in such a way we consider all possible strings in lexicographic order 
368,You are given a chessboard of size It is guaranteed that The chessboard is painted like this Some cells of the board are occupied by the chess pieces Each cell contains no more than one chess piece It is known that the total number of pieces equals to In one step you can move one of the pieces one cell to the left or to the right You cannot move pieces beyond the borders of the board You also cannot move pieces to the cells that are already occupied Your task is to place all the pieces in the cells of the same color all the pieces must occupy only the black cells or only the white cells after all the moves are made ,Firstly let s sort our array pay the attention that there are elements in this array not Then for 0 indexed array answer will be equal to where is an absolute value of difference between and ,It is easy to see that for the odd elements there is no changes after applying the algorithm described in the problem statement and for the even elements there is only one change each of the even elements will be decreased by So we can iterate over all the elements of the array and print where is taking modulo Overall complexity is 
369,You are given an array and an array For one operation you can sort in non decreasing order any subarray of the array For example if and you choose subbarray then the array turns into You are asked to determine whether it is possible to obtain the array by applying this operation any number of times possibly zero to the array ,Let s reformulate this problem in next form we can sort only subarray of length 2 swap two consecutive elements and if It is simular tasks because we can sort any array by sorting subbarray of length 2 for example bubble sort does exactly that Now lets look at elements and If then we will solve this task for arrays and Otherwise lets look at minimum position such that if there is no such position then answer to the problem is We can move element to the beginning of array only if all elements greater then In other words any index such that must be greater then And if this condition holds then we just delete element and solve task for arrays and But instead of deleting this element we will change information about minimum index such that This index will be the minimum index such that and For do this we will maintain stacks such that for any element of stack condition holds and moreover all elements in stacks are sorted in ascending order the top element of stack is minimal For example if then For finding minimum element on top of stacks we can use some data structure for example segment tree ,Suppose the initial sum of is equal to If we perform the operation the new sum will be equal to We want the sum not to decrease or If we will get If we ll get analogically In other words array you need if sorted will have and so on And one of the variants and obviously an optimal one is just As a result since we just need to check if then we found an answer otherwise there is no counterexample 
370,You are given three positive greater than zero integers and You have to find the number of pairs of positive integers such that equality holds Where is the least common multiple of and and is the greatest common divisor of and ,Let s represent as and as where and By definition so we can represent as Now we can rewrite the equation from the statement as follows Since the left hand side is divisible by the right hand side should also be divisible So we can iterate over as divisors of If the right hand side of is not divisible by then we can skip such let s denote as If has some prime divisor then exactly one of and should be divisible by because and have no common divisors So there are pairs of and for current value of We can precalculate the minimum prime divisor for each number up to the maximum value of that you may need in using Eratosthenes sieve Now we can solve the problem in for each testcase but that s not fast enough To speed up this approach we can precalculate the number of prime divisors for each number up to Let s denote as the minimum prime divisor of and as the number of prime divisors of Then plus if Now to solve the problem we only need to iterate over the divisors of so the time complexity is per testcase ,Firstly for every we can calculate the number of paths such that is divisible by We can do it as follows generate all divisors of numbers numbers not exceeding have at most divisors so this will be fast enough and then for every analyze the graph containing the vertices that have as its divisor Each component of this graph gives us paths if its size is and this is the only formula we need to calculate the number of paths where is divisible by let this be How can we get the answer if we know the values of We can use inclusion exclusion with Mobius function for example to prove that and then if we want to apply the same technique for finding with any possible we could divide all numbers by and do the same thing But it might be too slow so it s better to rewrite this formula as because we will do exactly the same when dividing all numbers by In fact most contestants have written a much easier version of this solution so this might be a bit too complicated This problem can also be solved with centroid decomposition 
371,Let s call a triple of positive integers if the equality holds where is the concatenation of and and is the concatenation of and For the purpose of concatenation the integers are considered without leading zeroes For example if and then the triple is strange because But and is not strange because You are given three integers and Calculate the number of strange triples such that and ,Let be the length of number Then Let then and and we get Note that the right part is divisible by so the left part should as well Then we can see that should be divisible by since Let s say then divide both sides by We get Let s rearrange it and get the following Since is integer then should be integer In other words we can define such that is divisible by and is divisible by and is Since has a very special structure let s iterate over all lengths and all divisors of for a fixed Let s say and Then For a fixed and we know but don t know So let s just iterate over all possible and let s also iterate over all since is small since is a divisor of Next step is following let s look at previous equation but modulo Since then there is a solution to the previous module equation or Now we know exact value and so now the time to guess let s recall that Since we fixed then or Let s name the left border as and right border so inequality earlier is But we can make constrains even tighter note that but lately we said that or So or should be divisible by In total we can iterate in range with since we are interested only in divisible by Now we have enough variables to construct a triple we know and so If is already big we can skip that candidate Also we can calculate and check that pair is valid i e is really minimum possible We can understand it by checking that otherwise we can reduce by Value can be calculated from one of the formulas above as After that we calculate and check that is not too big Value can be calculated as At last we should check that the given triple satisfy all remaining assumptions we made is not too big is really and length of calculated is exactly we fixed If it s all fine then we found a correct triple It looks like thanks to all previous checks the triple we found is unique but just for safety let s push them all in one set to get rid of copies Calculating complexity is not trivial but let s note something the total number of divisors of for all is around For a fixed pair we iterate over all from to and for each we iterate from to but it s easy to prove that the total number of pairs is at most Now the last cycle iteration of with step where If we assume that is quite small then is proportional to and pairs are something like harmonic series with complexity In total the complexity is around ,Suppose the answer is just th positive integer which we should shift right by some number Each multiplier of shifts our answer by The number of such multipliers is where is divided by rounded down So the final answer is th positive integer with the required number of skipped integers multipliers of You can also use a binary search to solve this problem 
372,You are given an array of positive integers Make the product of all the numbers in the array that is divisible by You can perform the following operation as many times as you like select an arbitrary index and replace the value with You cannot apply the operation repeatedly to a single index In other words all selected values of must be different Find the smallest number of operations you need to perform to make the product of all the elements in the array divisible by Note that such a set of operations does not always exist ,Let s notice that if we multiply the numbers then the power of two of the product is equal to the sum of the powers of two in each of the numbers Let s calculate the initial sum of the powers of twos in the product This can be done as follows let s take the element and divide it by as long as we can while remembering to increase our counter by the number of occurrences of a power of two Now let s move on to operations and note that choosing the index will increase the degree of occurrence of two by a fixed number that is it does not matter when to apply this operation Choosing an index will increment the counter by a number such that is divisible by but not by you can find this again by dividing by while we can Since we want to minimize the number of operations used at each moment of time we will try to use an index that increases the counter by the largest number To do this it is enough to sort the indices by this index of increase and take them greedily from the largest increase to the smallest We get the solution in ,We can notice that by performing any number of operations the parity of the count of negative numbers won t ever change Thus if the number of negative numbers is initially even we can make it equal to by performing some operations So for an even count of negative numbers the answer is the sum of the absolute values of all numbers since we can make all of them positive And if the count of negative numbers is odd we must have one negative number at the end We will choose the one smallest by absolute value and keep the rest positive for simplicity we consider as a negative number 
373,You are given two arrays and both consisting of integers In one move you can choose two indices and and swap with and with You have to perform the swap in both arrays You are allowed to perform at most moves possibly zero Can you make both arrays sorted in a non decreasing order at the end If you can print any sequence of moves that makes both arrays sorted ,Imagine that all elements of are distinct This way sorting in increasing order will fix the order of If turns out sorted in a non decreasing order then the answer exists Otherwise it doesn t To obtain the sequence of swaps you can sort with any comparison based sorting algorithm you want even bubble sort will not exceed the allowed number of swaps What changes if has repeated elements Distinct elements are still ordered among themselves but now there are also blocks of equal elements For each block look into the corresponding values in Obviously these have to be sorted in a non decreasing order Rearrange them as they should be In fact this is exactly the same as sorting the sequence of pairs with a default comparator first by then by Since we fixed the wanted order we can proceed with the same steps we made in a distinct case Overall complexity or per testcase ,In this problem you can implement an algorithm opposite to that given in the condition Let s maintain two pointers to the left most and right most unhandled element Then restoring the original array you put the left most unhandled item in the first position put the right most unhandled item in the second position put the left most unhandled item in the third position put the right most unhandled item in the fourth position That is in general you put the leftmost elements on all odd positions and the rightmost ones on all even positions After processing each element you either move the left pointer forward by one or the right one backward by one 
374,You are given an undirected connected weighted graph consisting of vertices and edges Let s denote the length of the shortest path from vertex to vertex as You have to erase some edges of the graph so that at most edges remain Let s call a vertex if there still exists a path from to with length after erasing the edges Your goal is to erase the edges in such a way that the number of vertices is maximized ,Let s understand how many good vertices we may get if only edges remain This value is not greater than since an edge an add only one good vertex and for we have a good vertex with index This is an upper bound let s try to find a solution getting exactly good vertices or if all vertices of the graph will be good Let s run Dijkstra s algorithm from vertex and stop it as soon as we know the shortest paths to vertices including vertex The answer should contain the edges belonging to the shortest path tree built on these vertices ,Let s consider what the sequence of removals looks like in general We will base some intuition on a fact that at least one valid sequence is guaranteed to exist Remove all vertices that have their degree correct from the start at once There surely be such vertices since a valid sequence would have to start with some of them Notice that there can t be any adjacent vertices among them If there were we wouldn t be able to remove such a pair regardless of the order we choose since removing one of them makes another one s degree too low Now remove the vertices that just got their degrees correct from removing the first layer Once again these must exist if the graph is not empty yet because otherwise any valid sequence would get stuck Process until nothing is left This algorithm is basically a bfs and you can implement it like one Note that each vertex becomes available to be removed only after a certain subset of its neighbours is removed No matter what order you choose to remove the vertices in these vertices will always be the same Huh so for each vertex some of its neighbours have to be removed before it and the rest have to be removed after it since otherwise the degree of that vertex will become too low That actually means that our graph is not as undirected as it seemed We can direct each edge from a vertex that is removed before the other This makes a valid sequence of removals just a topological sort of that directed graph So a pair is nice if there exist two topological orders such that and go one before another in them We can make a bold but perfectly reasonable guess about all nice pairs A pair is nice if neither of and are reachable from each other The necessity of this condition is obvious Let s show sufficiency Let s show the construction such that goes before To remove we first have to remove all vertices that have edges to To remove them we have to remove vertices with edge to them And so on Basically to remove we have to remove all vertices that are reachable from on the transposed directed graph Since is not reachable from it doesn t have to be removed before So we can first remove all the required vertices then remove then continue removing vertices until we are able to remove By switching and in the description of that construction we can obtain the construction for before Thus we reduced the problem to a rather well known one Calculate the number of reachable pairs of vertices in a directed graph As far as I know it s not known to be solvable in sub quadratic time And we are not given a specific graph Yes it s obviously acyclic but turns out every acyclic graph can be made into a test for this problem You just have to make equal to the number of the outgoing edges for each Somehow we are still given vertices and edges If you are more familiar with that problem you might know that you can use bitset to solve it In particular let be a bitset such that if if reachable from Then you can initialize for all vertices and propagate the knowledge in reverse topological order by applying for all edges Unfortunately that requires memory and bits is over a gigabyte Let s use of my favorite tricks to make a solution with memory and the same complexity Man I love that trick Process vertices in batches of Let s calculate which vertices can reach vertices from to The algorithm is basically the same For each vertex store a smaller bitset of size also known as an unsigned long long Initialize the bitset for vertices from the batch and propagate the same way for all vertices Now just add up the number of ones in each bitset builtin popcountll Proceed to the next batch That makes it iterations of a algorithm This might require some constant optimizations In particular I suggest not to use dfs inside the iteration since the recursion makes it really slow You might iterate over a vertex in reverse topological order and its outgoing edges Or which is way faster unroll that graph into a list of edges and iterate over it directly 
375,The All Berland Team Programming Contest will take place very soon This year teams of four are allowed to participate There are programmers and mathematicians at Berland State University How many maximum teams can be made if each team must consist of exactly students teams of mathematicians or programmers are unlikely to perform well so the decision was made not to compose such teams Thus each team must have at least one programmer at least one mathematician Print the required maximum number of teams Each person can be a member of no more than one team ,If necessary change the values of and so that is always true Consider two cases 1 Let Then This means that the set is at least times larger than and we can form teams of the form where one participant will be a programmer and three will be mathematicians 2 Let Then assume that Let s substitute this value into the inequality Then we compose commands of the form Since making such a command decreases the value of by 2 The new value The condition still holds Then make commands of the form The total number of commands is That s what we wanted to get ,The answer is always or Why it is so Because if there is no such pair among all students that then we can take all students into one team Otherwise we can divide them into two teams by their programming skill parity 
376,You are given array of length You can choose one segment and integer value positive negative or even zero and change by each i e for each What is the maximum possible number of elements with value that can be obtained after one such operation ,Let be a number of occurrences of number in subsegment The given task is equivalent to choosing and value such that is maximum possible But with some transformations so we need to maximize Key observation is the next if we fix some value then we can shrink each segment between consecutive occurrences of in one element with weight equal to Then we need just to find subsegment with maximal sum the standard task which can be solved in Finally total complexity is ,Let s at first sort all matryoshkas by increasing its inner volume in i Then each nested subset will appear as subsequence in its canonical order Now we ll write the DP with d i x y the minimum extra space x and number of such subsequences y among all nested subsets where the i th doll is Why minimal not maximal for example It s just easier transitions and easier proof There are two main cases If there isn t j such that out i le in j then we can t put the i th doll inside any other So d i in i 1 Otherwise we must put the i th doll inside other doll otherwise the subset won t be a big enough If we put the i th doll inside the j th doll then we extra space of such subset is equal to d j first out i in i Since we minimize the extra space then d i first min limits out i le in j d j first out i in i min limits out i le in j d j first out i in i Since we sorted all matryoshkas so there is a position pos such that forall j ge pos out i le in j and d i first min limits j pos n d j first out i in i The d i second is just a sum from all minimums As you can see we can store d i in Segment Tree with minimum number of minimums Why in the second transition we will build only subsets It s because not big enough subsets are not optimal in terms of minimality of extra space The result complexity is O n log n 
377,There are students standing in a circle in some order The index of the th student is It is guaranteed that all indices of students are distinct integers from to i e they form a permutation Students want to start a round dance A round dance can be started if the student comes right after the student in clockwise order there are no students between them the student comes right after the student in clockwise order and so on and the student comes right after the student in clockwise order A round dance is almost the same thing the only difference is that the student should be right after the student in counterclockwise order this condition should be met for every from to For example if the indices of students listed in clockwise order are then they can start a clockwise round dance If the students have indices in clockwise order then they can start a counterclockwise round dance Your task is to determine whether it is possible to start a round dance Note that the students cannot change their positions before starting the dance they cannot swap or leave the circle and no other student can enter the circle You have to answer independent queries ,We just need to find the position of the in the array and then check if the sequence is going counterclockwise or clockwise from the position or correspondingly We can do this by two cycles Total complexity ,First let s check the array for correctness that is that it has no repeating elements Then let s look at the following ideas each number must be paired with another permutation element with by the definition of array Then since we want a lexicographically minimal permutation it is always more advantageous to put element before for the permutation to be lexicographically minimal the smallest possible numbers must be placed at the beginning Consequently the largest numbers must be placed at the end Let s proceed as follows Let s select the set of numbers that are not included in the array For an element find the maximum number of the set such that and put that number in front of the element moving from the end of the array to its beginning each element will be matched with such an element If at some point can not be matched array is not composed correctly and the answer to the query Otherwise print and the resulting permutation 
378, and the sum of over all test cases does not exceed A is a row of equal segments numbered to in order There are two terminals one above the other You are given an array of length For all there should be a straight wire from some point on segment of the top terminal to some point on segment of the bottom terminal You can t select the endpoints of a segment For example the following pictures show two possible wirings if and A occurs when two wires share a point in common In the picture above crossings are circled in red What is the number of crossings there can be if you place the wires optimally ,Let s look at two wires from and If there can never be any intersection If there has to be an intersection If it is possible that there is an intersection or not depending on how we arrange the wires on the bottom terminal In the last case if there are multiple wires that go to the same segment we can make all pairs of them cross by arranging the points in which they hit this segment from right to left For example if then we can make all pairs of segments cross as shown Since we want to maximize the number of intersections we just need to count the number of pairs such that You can brute force all pairs in ,I wanted to give this problem a lot of time ago I thought it is very standard problem but I underestimated its difficulty Let s write down the equation describing the problem So we have linear Diofant equation with two variables The solution has the form where the last equation can be solved by extended Euclid algorithm and is any integral number The variable should satisfy two conditions and The values and are fixed so we can get the segment of possible values for the values The length of the segment is the answer for the problem 
379,Polycarp likes squares and cubes of positive integers Here is the beginning of the sequence of numbers he likes For a given number count the number of integers from to that Polycarp likes In other words find the number of such that is a square of a positive integer number or a cube of a positive integer number or both a square and a cube simultaneously ,We ll search for positive integers not larger than and add their squares or cubes to the set if they don t exceed If the maximum number Polycarp will like is so the running time will be within the time limit The answer to the problem is the length of the resulting set ,We can re word the problem to count the number of numbers from that are larger than A possible way to do this is by keeping a variable that gets incremented every time we checked using the if statement whether a number is larger than The complexity is 
380,You are given three integers In one move you can add or to of these integers i e increase or decrease any number by one You can perform such operation any possibly zero number of times you can even perform this operation several times with one number You have to perform the minimum number of such operations in order to obtain three integers such that is divisible by and is divisible by You have to answer independent test cases ,Let s iterate over all possible values of from to It is obvious that cannot be bigger than else we can just move to Then let s iterate over all possible multiples of from to Let this number be Then we can find as the nearest number to that is divisible by we can check two nearest numbers to be sure These numbers are and Then we can update the answer with the found triple Note that the only condition you need to check is that Time complexity because of the sum of the harmonic series ,The number is divisible by the number if and only if modulo To solve this problem let s use the concept of dynamic programming There will be four states the number of considered digits of the number the number of such considered digits that we have colored red the remainder from dividing the red number by and the black one by The value corresponding to the state will be described by three parameters the possibility of a situation described by the states the color of the last digit and the parent state Let s assume that the number that contains digits is equal to Initially let s mark the state in which digits are considered of which are red digits and both remainders are equal to as possible Next let s iterate over all states in the following order first by the number of considered digits then by the number of considered red digits then by the remainder of the division by and by From the current state if it is possible i e the corresponding mark is set you can make two transitions to new states At the first transition we paint the last digit in red at the second one in black We need also to store the current state in the new states as the previous one A solution exists if and only if some state in which exactly digits are considered of which at least and at most red digits and the remainders are equal to is marked as possible Let s find such a state Using the stored information about the color of the last digit and the previous state we can restore the colors of all digits of the number 
381,You have a garland consisting of lamps Each lamp is colored red green or blue The color of the th lamp is and colors of lamps in the garland You have to recolor some lamps in this garland recoloring a lamp means changing its initial color to another in such a way that the obtained garland is A garland is called if any two lamps of the same color have distance divisible by three between them I e if the obtained garland is then for each such that should be satisfied The value means absolute value of the operation means remainder of when divided by For example the following garlands are The following garlands are not Among all ways to recolor the initial garland to make it you have to choose one with the number of recolored lamps If there are multiple optimal solutions print of them ,It is easy to see that any garland has one of the following patterns We can hard code all all this patterns or iterate over all these permutations of letters using three nested loops or standard language functions We can calculate for each pattern the cost to obtain such pattern from the given string and choose one with the minimum cost ,There are several ways to solve this problem The model solution does it as follows Restore the characters of from left to right The first character is restored by query For each of the next characters let s ask if this character is new by querying and comparing the result with the number of different characters on the segment If it s new ask to obtain the th character there will be at most such queries Otherwise we can find the previous occurrence of the th character with binary search Let be the number of different characters from position to position If we want to find the previous occurrence of the th character we need to find the last index such that Since the value does not decrease when we increase we can find the last such that with binary search Unfortunately the number of queries of type will be too large if we just use binary search over the whole segment To decrease the number of queries we can use the fact that the value of we are interested in is the last occurrence of some character we already met there are at most such values and binary search among them will need only iterations 
382,A thief made his way to a shop As usual he has his lucky knapsack with him The knapsack can contain objects There are kinds of products in the shop and an infinite number of products of each kind The cost of one product of kind is The thief is greedy so he will take exactly products it s possible for some kinds to take several products of that kind Find all the possible total costs of products the thief can nick into his knapsack ,Let then it is the standard problem which can be solved by FFT Fast Fourier Transform The solution is the following consider the polynomial which the th coefficient equals to one if and only if there is the number in the given array Let s multiply that polynomial by itself and find for which the coefficient in square not equals to Those values will be in the answer Easy to modificate the solution for the arbitrary We should simply calculate the th degree of the polynomial The complexity will be where is the maximal sum We can improve that solution Instead of calculating the th degree of the polynomial we can calculate the th degree of the DFT of the polynomial The only problem is the large values of the th degrees We can t use FFT with complex numbers because of the precision problems But we can do that with NTT Number theoretic transform But that solution also has a problem It can happen that some coefficients became equals to zero modulo but actually they are not equal to zero To get round that problem we can choose two three random modules and get the complexity The main author solution has the complexity FFT with complex numbers the second solution has the same complexity but uses NTT and the third solution has the improved complexity but it was already hacked by halyavin ,Firstly let s sort our array pay the attention that there are elements in this array not Then for 0 indexed array answer will be equal to where is an absolute value of difference between and 
383,Polycarp has decided to decorate his room because the New Year is soon One of the main decorations that Polycarp will install is the garland he is going to solder himself Simple garlands consisting of several lamps connected by one wire are too boring for Polycarp He is going to solder a garland consisting of lamps and wires Exactly one lamp will be connected to power grid and power will be transmitted from it to other lamps by the wires Each wire connectes exactly two lamps one lamp is called for this wire the one that gets power from some other wire and transmits it to this wire the other one is called the one that gets power from this wire Obviously each lamp has at most one wire that brings power to it and this lamp is the auxiliary lamp for this wire and the main lamp for all other wires connected directly to it Each lamp has a brightness value associated with it the th lamp has brightness We define the of the wire as the sum of brightness values over all lamps that become disconnected from the grid if the wire is cut and all other wires are still working Polycarp has drawn the scheme of the garland he wants to make the scheme depicts all lamp and wires and the lamp that will be connected directly to the grid is marked the wires are placed in such a way that the power can be transmitted to each lamp After that Polycarp calculated the importance of each wire enumerated them from to in descending order of their importance and then wrote the index of the main lamp for each wire in the order from the first wire to the last one The following day Polycarp bought all required components of the garland and decided to solder it but he could not find the scheme Fortunately Polycarp found the list of indices of main lamps for all wires Can you help him restore the original scheme ,First of all we don t like the fact that importance values can be integers up to it is kinda hard to work with them Let s rephrase the problem The highest bit set to in the importance value denotes the maximum in the subtree rooted at the auxiliary lamp for the wire So we sort the wires according to the maximums in their subtrees To break ties we could consider the second maximum then the third maximum but that s not convenient We can use something much easier suppose there are two vertices with the same maximum in their subtrees these vertices belong to the path from the root to the maximum in their subtrees and the one which is closer to the root has the greater importance value So to get the order described in the problem statement we could sort the vertices according to the maximum in their subtrees and use depth as the tie breaker What does this imply All vertices of some prefix are ancestors of vertex so some prefix denotes the path from the root to excluding itself Then there are some values describing the path from some already visited vertex to if was not met before then to and so on How can we use this information to restore the original tree is the root obviously Then the sequence can be separated into several subsegments each representing a vertical path in the tree and each vertex is the parent of the next vertex in the sequence if they belong to the same subsegment How can we separate these vertices into subsegments and how to find the parents for vertices which did not appear in the sequence at all Suppose some vertex appears several times in our sequence The first time it appeared in the sequence it was in the middle of some vertical path so the previous vertex is its parent and every time this vertex appears again it means that we start a new path and that s how decomposition into paths is done Determining the parents of vertices that did not appear in the sequence is a bit harder but can also be done Let s recall that our sequence is decomposed into paths from root to from some visited vertex to from some visited vertex to and so on so each time the path changes it means that we have found the maximum vertex among unvisited ones So we should keep track of the maximum vertex that was not introduced in the sequence while we split it into paths and each time a path breaks it means that we found the vertex we were keeping track of Overall this solution can be implemented in ,Let s solve this problem using dynamic programming on a tree Suppose the tree is rooted and the root of the tree is Also let s increase to find the subset in which any pair of vertices had distance or greater instead of or greater Let be the maximum total weight of the subset in the subtree of if the vertex with the minimum depth we took has depth Then the answer is Firstly let s calculate this dynamic programming for all children of Then we are ready to calculate all for all from to Let the current depth be then there are two cases if then Otherwise let s iterate over all children of and let be such child of that the vertex with the minimum depth we took is in the subtree of Then After we calculated all values of for the vertex we can notice that this is not what we wanted The current value of means the maximum total weight of the subset in the subtree of if the vertex with the minimum depth we took has depth To fix this let s push to for all depths from to Time complexity but it can be easily optimized to using some prefix and suffix maximums You can ask why this is but not because we iterating over all vertices then over all possible depths and then over children of the vertex and again over children of the vertex But in fact this is because if we change the order of multiplication we can see that we are iterating over pairs parent child then over children and possible depths and the number of such pairs is so the complexity is 
384,Vlad found a flowerbed with graphs in his yard and decided to take one for himself Later he found out that in addition to the usual graphs flowers also grew on that flowerbed A graph is called a flower if it consists of a simple cycle of length through each vertex of which passes its own simple cycle of length and these cycles do not intersect at the vertices For example flower looks like this Note that flower and flower do not exist since at least vertices are needed to form a cycle Vlad really liked the structure of the flowers and now he wants to find out if he was lucky to take one of them from the flowerbed ,Note a few things There are exactly vertices in the flower since from each of the vertices of the main cycle comes another cycle of size in the flower all vertices have degree except for the vertices of the main cycle whose degrees are it follows that in flower edges The listed properties do not take into account only the connectivity of the graph and the sizes of our cycles To check connectivity we run a bfs or dfs from any vertex and check that all vertices have been visited To check the cycle lengths we cut out the edges of the main one and make sure that the graph has fell apart into components of size ,Let s use contribution to the sum technique to simplify the problem Instead of counting the number of colors that occure only once for each path let s for each color count the number of paths that contain this color exactly once Now we can solve the problem independently for each color and sum up the answers The first intended solution was the following So we want to calculate the answer for some color Mark all edges of color as good the rest are bad Then we can calculate the number of paths up to vertex such that they contain either or good edges The transitions should be pretty easy and the answer should be updated when you consider gluing up paths from different children in each vertex Obviously this is per color so overall However we can only calculate this dynamic programming as easily on a virtual tree of vertices adjacent to all good edges How to calculate the dp for some vertex First push the paths from all virtual children to That was enough in the dp for the entire tree but now there are also removed vertices that could also have paths starting in them All these paths contain good edges otherwise they would have had virtual vertices on them Their amount is the following the size of the real subtree of minus the sizes of real subtrees of all its virtual children The rest is exactly the same as in the dp on the real tree A little fun trick Usually you want to add lca of adjacent vertices to the virtual tree But that s actually not needed here you can just add the root of the tree and link the vertices without a parent to them That won t change the result of the dp That solution works in or The second intended solution is slower complexity wise but not time wise In the first solution we wanted to leave only the good edges in the tree Here we want to remove only them Consider the resulting connected components What s the number of paths that contain only one of the good edges It s actually the product of sizes of the connected components this edge connects So we want to remove edges add edges and maintain the sizes of the connected components of the tree That s basically the same problem as dynamic connectivity The implementation works well enough 
385,You are the gym teacher in the school There are students in the row And there are two rivalling students among them The first one is in position the second in position Positions are numbered from to from left to right Since they are rivals you want to maximize the distance between them If students are in positions and respectively then distance between them is You can do the following operation at most times choose two students and swap them Calculate the maximum distance between two rivalling students after at most swaps ,To solve the problem you need to understand two facts The answer can t be greater than If current distance between rivaling student if less then we always can increment this distance by one swap In means that answer is equal to ,In this problem we can notice that when we calculate the answer for the kid we also calculate the answer for kids and so on So we can a little bit modify the pseudocode from the easy version to calculate answers faster pos p i ans 1cycle i while pos i cycle append pos ans 1 pos p pos for el in cycle res el ansAnd of course we don t need to run this while for all elements for which we already calculated the answer Total time complexity is because you ll process each element exactly once 
386,You are given a grid consisting of rows and columns Each cell of this grid should be colored either black or white Two cells are considered neighbours if they have a and share the same color Two cells and belong to the same component if they are neighbours or if there is a neighbour of that belongs to the same component with Let s call some bicoloring if it has exactly components Count the number of bicolorings The number can be big enough so print the answer modulo ,The problem is about counting the number of some combinatoric objects Thus dynamic programming is always the answer Let be the number of bicolorings of the first columns such that components are already created and can t be modified and the colors of the th column are determined by its first bit is the color of the lower cell and its second bit the color of the upper cell Component can be modified if the cell from the th column belongs to it The initial states are for each and for any other state You should iterate over the possible for the next column and recalculate the number of components You can easily show that the current number of components and the last column is actually enough to get the new number of components In my code I have some function to determine the added number of components while transitioning from to These are just the couple of cases to handle carefully Then all the transitions are However the last column won t contain the answer as it is the number of components will be incorrect Let s add some dummy column equal to for each This will add all the real component to the total number So the answer is the sum of over all Overall complexity where is the number of rows 2 for this problem ,Let s see how the water can flow when it meets the pipe of type or and in the other case When the water meets the pipe of type or we cannot do anything but let it flow to the right of the current cell Otherwise if the current pipe is curved then there are two cases if the pipe on the same position but in the other row is not curved then the answer is because the water has to change the row but we cannot turn the next pipe to allow it to move to the right or to the left So the current pipe is curved and the pipe on the same position in the other row is also curved let s change the row and move to the right it is obvious that we never need to move to the left So the answer and the sequence of pipes is uniquely defined by types of pipes If after iterating over all positions we didn t meet the case of and the current row is second then the answer is 
387,You are given two integers and You should create an array of such that the sum is divisible by and maximum element in is minimum possible What is the minimum possible maximum element in ,Let s denote as the sum of array From one side since should be divisible by then we can say From other side since all are positive then It s quite obvious that the smaller the smaller maximum so we need to find the smallest that Then Now we now that and we need to represent it as with maximum minimized It s easy to prove by contradiction that maximum Moreover we can always construct such array that its sum is equal to and the maximum element is equal to As a result the answer is where ,Let s write our unique function Keep the array of the taken elements Iterate over all elements in the array and if the current element is not used then add its index to the answer and set When finished check the number of distinct values that is the size of answer array If it is less than print Otherwise print and output the first elements of the answer 
388,Given three numbers You need to find an adjacency matrix of such an undirected graph that the number of components in it is equal to and the number of components in its complement is The matrix must be symmetric and all digits on the main diagonal must be zeroes In an undirected graph loops edges from a vertex to itself are not allowed It can be at most one edge between a pair of vertices The adjacency matrix of an undirected graph is a square matrix of size consisting only of 0 and 1 where is the number of vertices of the graph and the th row and the th column correspond to the th vertex of the graph The cell of the adjacency matrix contains if and only if the th and th vertices in the graph are connected by an edge A connected component is a set of vertices such that for every two vertices from this set there exists at least one path in the graph connecting this pair of vertices but adding any other vertex to violates this rule The complement or inverse of a graph is a graph on the same vertices such that two distinct vertices of are adjacent if and only if they are not adjacent in ,Let s prove that if then Let be the original graph and the complement of the graph Let s look at each pair of vertices If and belong to different components of the graph then there is an edge between them in the graph Otherwise and belong to the same component of the graph but since has more than one component there is vertex in other component of and there are edges and in That s why there is a connected path for any pair of vertices and the graph is connected Similarly the case is proved So if then the answer is NO Otherwise Consider the case where if we can swap and and output complement of the constructed graph To have components in the graph it is enough to connect the vertex with the vertex the vertex with the vertex the vertex with the vertex A particular cases are the tests and There is no suitable graph for them ,Let s call a point if its color does not match the color of any other point If a point is not isolated then it has the same color as the points with minimum distance to it and only these points should have this color Let s build a directed graph where the arc means that the point is one of the closest to the point i e If there is a path from the vertex to the vertex it means that if the vertex is not isolated the vertex should have the same color as vertex Suppose the set of vertices reachable from including itself is Finding is easy just run DFS from the vertex Let s analyze two cases there exists a pair of vertices such that and there is no arc from to for every pair of vertices such that and there is an arc Why do we need to analyze these two cases In the first case the vertex be isolated because painting it and some other vertex into the same color means that every vertex from will have this color and it will break the condition in the statement In the second case the vertex may be isolated or it may have the same color as all vertices in and if it is isolated then the whole set should consist of isolated vertices Let s find all such set of vertices that meet the second case Each vertex will belong to at most one of these sets if it doesn t belong to any it must be isolated otherwise either the whole its set consists of isolated vertices or the whole set has the same color So for each set we either use color or colors This allows us to implement a knapsack like dynamic programming let be the number of ways to paint first sets into colors such that the colors are not ordered After running this dynamic programming we can get the answer by simple combinatorics iterate on the number of colors we use in these sets in total multiply the dynamic programming for it by the ordered number of ways to choose these colors from and then by the number of ways to choose the colors for points that must be isolated This dynamic programming can even be implemented a bit easier if we treat every vertex that must be isolated as a set of size and this is the way it s written in the model solution 
389,You can not just take the file and send it When Polycarp trying to send a file in the social network Codehorses he encountered an unexpected problem If the name of the file contains three or more lowercase Latin letters in a row the system considers that the file content does not correspond to the social network topic In this case the file is not sent and an error message is displayed Determine the minimum number of characters to remove from the file name so after that the name does not contain as a substring Print if the file name does not initially contain a forbidden substring You can delete characters in arbitrary positions not necessarily consecutive If you delete a character then the length of a string is reduced by For example if you delete the character in the position from the string then the resulting string is ,Let s iterate through the given string from the left to the right In a variable we will store the number of letters which were before the current letter in a row If the current letter does not equal to we should make In the other case the current letter equals to If we should increase by one In the other case we should add one to the answer because the current letter should be removed ,We will construct the string starting with the largest letters Note that if then the th letter of the string is maximal so we know that the th letter affect all While the string is not completely constructed we will do the following Find all such that and the th character of string is not placed Put on all these positions in the string the maximum letter not used in the string there should be a sufficient number of letters in the string Subtract from all 
390,Let s define as the following permutation This means that the th permutation is i e which maps every element to itself permutation but the element is on the first position Examples You are given an array Let be the position of the element in So Let s define a function where is the absolute value of This function means the sum of distances between adjacent elements of in Your task is to calculate ,Let s calculate the answer for the first permutation naively in Then let s recalculate the answer somehow and then maybe prove that it works in linear time Which summands will change when we try to recalculate the function using First of all let s notice that each pair of adjacent elements of is the segment on the permutation To calculate fast let s firstly notice that all segments that cover the element but is not their endpoint will change their length by minus one after placing at the first position because will be removed from all such segments This part can be calculated in Let s use the standard trick with prefix sums and segments Let be the array of length For each pair of adjacent elements and for all from to let s do the following sequence of moves if then there are no points that covered by this segment not being its endpoints so let s just skip this segment Otherwise let s increase the value of by one and decrease the value of by one After this let s build prefix sums on this array make for all from to And now equals to the number of segments covering the element The second part that will change is such segments that is their endpoint Let s store the array of arrays of length and will store all elements adjacent to in the array for all from to But one important thing we don t need to consider such pairs and that it broke my solution somehow so this part is important Knowing these two parts we can easily calculate using Firstly let s initialize the result as Then we need to recalculate lengths of such segments that is their endpoint Let s iterate over all elements in set remove the old segment and set add the length of the segment from to and increase by one if it means that and change their relative order and the length of the segment from to increases by one Now we can see that after iterating over all from to we make at most moves because each pair of adjacent elements in was considered at most twice Total complexity ,Let s look at two wires from and If there can never be any intersection If there has to be an intersection If it is possible that there is an intersection or not depending on how we arrange the wires on the bottom terminal In the last case if there are multiple wires that go to the same segment we can make all pairs of them cross by arranging the points in which they hit this segment from right to left For example if then we can make all pairs of segments cross as shown Since we want to maximize the number of intersections we just need to count the number of pairs such that You can brute force all pairs in 
391,You are given two integers and You may perform any number of operations on them possibly zero During each operation you should choose any positive integer and set or Note that you may choose different values of in different operations Is it possible to make and equal to simultaneously Your program should answer independent test cases ,Let s assume Then the answer is if two following conditions holds because after each operation the value does not change ,Let s define some functions at first indicator function if is true and otherwise is a number of that and Good observation Another observation Now it s time to transform what we d like to calculate Since transformation of the second sum was standard we ll look at the first sum So we can iterate over and we d like to calculate this two sums fast enough So more transformations So while iterating over we need to make queries of two types set value in position and calculate It can be done by BIT with coordinate compression can be calculated in the same way iterating over in reverse order Result complexity is 
392,There are distinct points on a coordinate line the coordinate of th point equals to Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two It is necessary to consider each pair of points not only adjacent Note that any subset containing one element satisfies the condition above Among all these subsets choose a subset with maximum possible size In other words you have to choose the maximum possible number of points such that for each pair it is true that where is some non negative integer number not necessarily the same for each pair of points ,Firstly let s prove that the size of the answer is not greater than Suppose that the answer equals to Let be coordinates of the points in the answer and Let and Then because of the condition It means that Conditions must hold for a triple too Now it is easy to see that if then that is not a power of two So the size of the answer is not greater than Firstly let s check if the answer is Iterate over all middle elements of the answer and over all powers of two from to inclusively Let be the middle element of the answer and the current power of two Then if there are elements and in the array then the answer is Now check if the answer is Do the same as in the previous solution but now we have left point and right point If we did not find answer of lengths or then print any element of the array The solution above have time complexity because of we can check if the element is in the array with some data structure in ,Let s look at some facts At first the answer is the sum of weights taken with some coefficients So it s enough to calculate those coefficients Then can be calculated by iterating on the size of the subset containing th element where is the number of partitions of set with elements into nonempty subsets with one subset of fixed size where belongs This solution is still quite slow so the next fact is if two elements and belong to the same subset then increases the coefficient before So for each element we can iterate over all elements which will lie in one subset with In other words is the number of ways to divide set with elements into subsets in such a way that elements and wil lie in one subset can be calculated using Stirling numbers of the second kind let be the number of partitions of set with elements into non empty subsets If then else we just merge and into one element and let Final formula is And the answer is Counting Stirling numbers can be done with inclusion exclusion principle or by searching Wiki Resulting complexity is 
393,A permutation is a sequence of length integers from to in which all the numbers occur exactly once For example permutations and no Polycarp was recently gifted a permutation of length Polycarp likes trees more than permutations so he wants to transform permutation into a rooted binary tree He transforms an array of different integers into a tree as follows the maximum element of the array becomes the root of the tree all elements to the left of the maximum form a left subtree which is built according to the same rules but applied to the left part of the array but if there are no elements to the left of the maximum then the root has no left child all elements to the right of the maximum form a right subtree which is built according to the same rules but applied to the right side of the array but if there are no elements to the right of the maximum then the root has no right child For example if he builds a tree by permutation then the root will be the element and the left subtree will be the tree that will be built for the subarray and the right one for the subarray As a result the following tree will be built Another example let the permutation be In this case the tree looks like this Let us denote by the depth of the vertex that is the number of edges on the path from the root to the vertex numbered Note that the root depth is zero Given the permutation for each vertex find the value of ,We will construct the required tree recursively Let us describe the state of tree construction by three values where is the segment of the permutation and is the current depth Then the following transitions can be described find the position of the maximum element on the segment that is the depth of the vertex is equal to if then make the transition to the state if then make the transition to the state Then in order to construct the required tree it is necessary to take as the initial state ,In this problem we can use small to large merging trick also known as DSU on tree when building a depth array for a vertex we firstly build depth arrays recursively for its children then pull them upwards and merge them with small to large technique In different blogs on this technique it was mentioned that this will require operations with structures we use to maintain depth arrays overall However in this problem we may prove a better estimate it will require operations That s because the size of depth array if considering only non zero elements for a vertex is equal to the height of its subtree not to the number of vertices in it To prove that the number of operations is one can use the intuitive fact that when we merge two depth arrays all elements of the smaller array are destroyed in the process so if the size of smaller array is then we require operations to destroy elements The main problem is that we sometimes need to pull our depth arrays upwards thus inserting a to the beginning of the array Standard arrays don t support this operation so we need to either use something like and the complexity will be or keep the depth arrays in reversed order and handle them using and then complexity will be 
394,A multi subject competition is coming The competition has different subjects participants can choose from That s why Alex the coach should form a competition delegation among his students He has candidates For the th person he knows subject the candidate specializes in and a skill level in his specialization this level can be negative The rules of the competition require each delegation to choose some subset of subjects they will participate in The only restriction is that the participating in each of the subjects should be the Alex decided that each candidate would participate only in the subject he specializes in Now Alex wonders whom he has to choose to maximize the total sum of skill levels of all delegates or just skip the competition this year if every valid non empty delegation has negative sum Of course Alex doesn t have any spare money so each delegate he chooses must participate in the competition ,At first it s optimal to take candidates with maximal levels for a fixed subject At second if we fix number of participants in each subject for some delegation then it s always optimal to choose all subjects with positive sum of levels It leads us to a following solution Let s divide all candidates by it s and sort each group in non increasing order In result we can just iterate over all prefix sums for each group and update global answer of current length with current sum if it has a positive value ,If in the current day there is no exam we should prepare for an exam for which questions already given for which we prepare less than needed and which will be before other remaining exams For this we will use array where equals to the number of days which we already prepared for exam Initially array consists of zeroes Let s iterate through the days Suppose exam is in the current day If we did not have time to prepare for it and we should print In the other case in this day we will pass the exam In the other case let iterate through all exams and choose exam for which we need still to prepare i e for which already given the questions and which will be before other remaining exams If there is no such exam we should relax in this day else in this day we should prepare for exam Also we should increase by one 
395,You have got a shelf and want to put some books on it You are given queries of three types put a book having index on the shelf to the left from the leftmost existing book put a book having index on the shelf to the right from the rightmost existing book calculate the minimum number of books you need to pop from the left or from the right in such a way that the book with index will be leftmost or rightmost You can assume that the first book you will put can have any position it does not matter and queries of type are always valid it is guaranteed that the book in each such query is already placed You can also assume that you don t put the same book on the shelf twice so s don t repeat in queries of first two types Your problem is to answer all the queries of type in order they appear in the input Note that after answering the query of type all the books remain on the shelf and the relative order of books does not change ,Let imagine our shelf as an infinite array Let s carry the rightmost free position from the left of our shelf let it be and initially it equals to and the leftmost free position from the right of our shelf let it be and initially it equals to Also let s carry the array of length where will be equal to the position in our imaginary array of the book with a number Let s put the first book to the position Also let s save that where is the number of the first book equals to How will change and will become and will become Now let s process queries one by one If now we have the query of type with a book with a number then let s set and set The query of type can be processed similarly Now what about queries of type The answer to this query equals to where is the absolute value of ,Let s consider the optimal answer Suppose we take items of weight Let be the least common multiple of all weights that is Then we may represent as where Let s do the following trick we will take items of weight and all the remaining items of this weight can be merged into some items of weight Then we can write a brute force solution that picks less than items of each weight transforms the remaining ones into items of weight as much as possible and when we fix the whole subset adds maximum possible number of items of weight to the answer This works in something like operations which is too much How can we speed it up Rewrite it using dynamic programming When we have fixed the number of items we take from first sets the only two things that matter now are the current total weight of taken items and the number of items of weight we can use and it s obvious that the more items of weight we can use the better So let s write the following dynamic programming solution maximum number of items of weight we can have if we processed first types of items and current total weight is Note that the second dimension should have size 
396,Polycarp has just launched his new startup idea The niche is pretty free and the key vector of development sounds really promising so he easily found himself some investors ready to sponsor the company However he is yet to name the startup Actually Polycarp has already came up with the name but some improvement to it will never hurt So now he wants to swap letters at some positions in it to obtain the better name It isn t necessary for letters to be adjacent In addition each of the investors has chosen some index in the name and selected a set of letters that can go there Indices chosen by different investors are pairwise distinct If some indices aren t chosen by any investor then any letter can go there Finally Polycarp is sure that the smallest lexicographically name is the best Like why do you think Google decided to become Alphabet More formally you are given a string consisting of lowercase Latin letters from to You can swap letters at any positions arbitrary number of times zero swaps is also possible What is the smallest lexicographically name you can obtain such that the letter at every position is among the allowed letters If Polycarp can t produce any valid name then print ,The idea of solution is the following we build the answer letter by letter when choosing a character for some position we try all possible characters and check that we can build the suffix after placing this character But we need to somehow do this checking fast As in many previous Educational Rounds in this round some participants solutions were much easier to write and understand than our own model solution Let s build a flow network where we have vertices representing the characters of the string and vertices representing the masks of characters Add directed edges from the source to every node representing some character with capacity equal to the number of such characters in the original string also add directed edges from every node representing some character to all vertices representing masks where this character is contained with infinite capacity and finally add a directed edge from every mask node to the sink with capacity equal to the number of positions where this mask of characters is allowed If we find maximum flow in this network we can check that the answer exists and if it exists build some answer Now let s try to build optimal answer by somehow rebuilding the flow in the network Suppose we are trying to place a character to position containing mask To check whether we can do it we have to try rebuilding the flow in such a way that the edge from vertex corresponding to to vertex corresponding to has non zero flow If it is already non zero then we are done otherwise we may cancel a unit of flow going through an edge from source to vertex then cancel a unit of flow going through an edge from vertex to sink decrease the capacity of these two edges by and check that there exists an augmenting path If it exists then returning the capacities back and adding one unit of flow through the path actually builds some answer where some character is placed on some position with mask so we may place it there otherwise it s impossible When we finally decided to place on position we have to decrease the flow through and the capacities of edges and All this algorithm runs in where is the size of the alphabet Hall s theorem allows us to check that we may build the suffix of the answer much easier Each time we try to place some character we need to iterate on all possible subsets of characters we still need to place and check that the number of positions that are suitable for at least one character in a subset is not less than the size of subset just like in regular Hall s theorem The key fact here is that if we have for example characters yet to place then we don t need to check any subset containing exactly or characters since the number of suitable positions for this subset won t become larger if we add all remaining characters to a subset So the subsets we have to consider are limited by the masks of possible characters and there will be only of them ,It is easy to see that any garland has one of the following patterns We can hard code all all this patterns or iterate over all these permutations of letters using three nested loops or standard language functions We can calculate for each pattern the cost to obtain such pattern from the given string and choose one with the minimum cost 
397,You are given a permutation an array where each integer from to appears exactly once The weight of the th element of this permutation is At first you separate your permutation into two sets prefix and suffix More formally the first set contains elements the second where After that you may move elements between sets The operation you are allowed to do is to choose some element of the first set and move it to the second set or vice versa move from the second set to the first You have to pay dollars to move the element Your goal is to make it so that each element of the first set is less than each element of the second set Note that if one of the sets is empty this condition is met For example if and then the optimal strategy is separate into two parts and and then move the element into first set it costs And if then the optimal strategy is separate into two parts and and then move the element into first set it costs and element into second set it also costs Calculate the minimum number of dollars you have to spend , All elements in the left set smaller than all elements in the right set means that there is such value that all elements from the first set less than and all elements from the second set are more or equal to So let s make a sweep line on from to while trying to maintain all answers for each prefix Let s maintain for each the total cost to make sets good if we split the permutation on sets and in such way that after transformations all elements in the first set less than It s easy to see that the total cost is equal to sum of weights where and and where and So what will happen if we increase by Let s define the position of as For each we don t need to move to the second set anymore so we should make On the other hand for each we need to move from the second set to the first one now so we should make The answer will be equal to the It means that we should handle two operations add some value on the segment and ask minimum on the segment So we can store all in pretty standart Segment Tree with add on segment and minimum on segment while iterating over So the total complexity is ,Let s consider some division Represent the XOR sum of the subset via prefix XOR Those are I claim that you can collect any subset that is a XOR of an even number of for pairwise distinct values of Let s take a look on some prefix of processed segments where the last segment is taken into subset The previous taken s can t be changed the last taken can either be eliminated if we also take the current segment and that segment erases one value and adds one or added to the answer if we don t take it but the next taken segment will add two values You can see that the parity doesn t change Moreover you can collect any subset that is a XOR of an odd number of for pairwise distinct values of Just forget about taken into the answer as its value is Then all the even subsets which included it will become odd This way we can collect all subsets of for some division Now you just want find the division that produces the maximum number of linearly independent numbers binary vectors That is the size of the basis of the space of chosen numbers binary vectors Now it s time to abuse the fact that adding a number into the set can only increase the size of basis of the space Thus adding anything to the maximum set won t change the answer otherwise the result would be greater than the maximum Finally you say that the maximum basis size is equal to the basis size of all the prefix XOR and easily calculate in The only corner case is being itself Then for any division the full subset will also give result That is the only case with answer Overall complexity 
398,You are given a tree consisting of vertices Recall that a tree is an undirected connected acyclic graph The given tree is rooted at the vertex You have to process queries In each query you are given a vertex of the tree and an integer To process a query you may delete any vertices from the tree in any order except for the root and the vertex When a vertex is deleted its children become the children of its parent You have to process a query in such a way that maximizes the value of where is the resulting number of children of the vertex and is the number of vertices you have deleted Print the maximum possible value you can obtain The queries are independent the changes you make to the tree while processing a query don t affect the tree in other queries ,A naive solution to this problem would be to implement a recursive function which answers each query let be the answer to the query we can calculate it as since for each child of vertex we either delete it and change the score by or choose to let it remain and this increases the score by Unfortunately it is too slow Let s try to optimize it First of all since if we choose the exact same subset of vertices to delete for the query as we ve chosen for the query our score won t decrease Using this fact we can show that if it s optimal to remove some vertex in the query it s also optimal to remove a vertex in the query because it s optimal to remove vertex if and if this condition holds for some value of then it holds for each smaller value of Let be the maximum value of when it s optimal to remove the vertex We will calculate these values for all vertices of the tree using an event processing method we ll process the values of from to and use a set or a priority queue to store events of the form at the value vertex becomes optimal to delete This set priority queue should sort the events in descending order of the value of and in case of ties in descending order of depths of the vertices to make sure that vertices with the same value of are processed from bottom to up Let s analyze the implementation of this process more in detail For each vertex we will store two values the number of vertices we should remove from its subtree and the number of children this vertex will optimally have Using these two values we can easily calculate the value of for a vertex When a vertex is removed that is the event corresponding to this vertex is processed these values for this vertex should be added to its current parent we can use DSU to find the current parent easily for example and don t forget that the number of vertices we have to remove for this new parent also increases by then we recalculate the value of for the current parent and change the event corresponding to this current parent note that the value of for the current parent shouldn t be greater than the value of for the vertex we ve deleted Okay this allows us to calculate when it s optimal to delete each vertex But how do we answer queries One of the ways to do this is to process queries in the same event processing algorithm and for every value of we first remove the vertices with then process the queries There is an issue that when we remove a vertex it can affect the answer not only for its current parent but also for the vertices that could be its parents but are already deleted to handle this instead of adding the values of the deleted vertex only to the values of its current parent we perform an addition on the whole path from the vertex to the current parent excluding the vertex itself This path addition can be performed with a Fenwick or Segment tree over the Eulerian tour of the tree and this yields a compexity of though with a high constant factor ,Let s create two arrays of length The element of the array will contain the operation number at which the vertex which is the index of the array will be deleted The array will contain the number of neighbors of a given vertex at a certain time This array must be initialized with the number of neighbors in the original tree Initially we will suppose that the gardener performs an infinite number of operations and we will simply calculate for each vertex the number of the operation on which it will be deleted Let s create a queue which will store the order of deleting vertices The queue will contain only those vertices whose neighbors except maybe one have been removed i e Let s add all leaves of the original tree to it for each of them let s store the value in the array because all original leaves will be removed during the first operation Next we will take sequentially one vertex from the queue and update the data about its neighbors Consider the neighbors Since we are deleting the current vertex we need to update of its neighbors If the neighbor s is equal to then it s already in the queue and it doesn t need to be considered right now Otherwise we will decrease the neighbor s by If it becomes equal to then the neighbor must be added to the queue The number of the operation during which the neighbor will be deleted is equal to the number of the operation during which the current vertex will be deleted plus After we calculate the numbers of operations for all vertices we need to select among them those that will not be deleted during operations with numbers Thus the answer is the number of vertices such that 
399,We define as the remainder of division of by operator in C or Java operator in Pascal Let s call an array of positive integers if for every permutation of integers from to and for every non negative integer the following condition is met That is for each non negative integer the value of does not change if we reorder the elements of the array For two given integers and calculate the number of arrays such that ,We claim that the array is stable if and only if all elements are divisible by its minimum The proof of this fact will be at the end of the editorial To calculate the number of stable arrays now we need to iterate on the minimum in the array and choose the remaining elements so that they are multiples of it If the minimum is then the resulting elements should be divisible by There are such numbers between and and we have to choose elements out of since is already chosen The number of ways to do it can be calculated by precomputing factorials modulo since it is a binomial coefficient On the one hand since if all elements in the array are divisible by some element nothing depends on the order of these elements On the other hand suppose there exists an element such that it is not divisible by Let s take and two following reorders of the array and For the first array we get which is non zero and for the second array so the result is zero ,I know about some solutions that are trying to iterate over almost all possible triples but I have a better and more interesting one Possibly it was already mentioned in comments but I need to explain it Let s solve the problem greedily Let s sort the initial array The first number we would like to choose is the maximum element Then we need to pop out some maximum elements that are divisors of the maximum Then there are two cases the array becomes empty or we have some maximum number that does not divide the chosen number Let s take it and repeat the same procedure again but now we have to find the number that does not divide neither the first taken number nor the second taken number So we have at most three numbers after this procedure Let s update the answer with their sum This solution is almost correct Almost What have we forgotten Let s imagine that the maximum element is divisible by and and there are three following numbers in the array maximum divided by by and by Then their sum is greater than the maximum and may be greater than the answer we have because So if these conditions are satisfied let s update the answer with the sum of these three numbers It can be shown that this is the only possible triple that can break our solution The triple does not match because the maximum divided by divides the maximum divided by The triple is bad for the same reason And the triple has sum less than the maximum element 
400,You are given an array consisting of positive integers You can perform operations on it In one operation you can replace any element of the array with that is by an integer part of dividing by rounding down See if you can apply the operation some number of times possible to make the array become a permutation of numbers from to that is so that it contains all numbers from to each exactly once For example if then the answer is yes You could do the following Replace with then Replace with then Replace with then Replace with then ,Let s sort the array in descending order of the values of its elements Then let s create a logical array where will have the value if we already got element of the permutation we are looking for and the value otherwise We loop through the elements of the array and assign We ll divide by as long as it exceeds or as long as is If it turns out that then all the numbers that could be obtained from have already been obtained before Since each element of the array must produce a new value from to the answer cannot be constructed output Otherwise assign a value of this means that the number which is an element of the permutation we will get exactly from the original number After processing all elements of the array we can output ,If we can print because each such sequence is an arithmetic progression Note that an arithmetic progression is uniquely determined by the first two terms So we should brute from to the change of the first element of the given sequence and from to the change of the second element of the given sequence Then and Also we will store the number of changed elements in the sequence Initially Now we need to iterate through the sequence from the third element to th Let current element in the position It should be equals to If then such arithmetic progression is unreachable Else if we should increase on one After we considered all elements we should update the answer with the value of if for all it was true that 
401,You are given a regular polygon with vertices labeled from to in counter clockwise order The triangulation of a given polygon is a set of triangles such that each vertex of each triangle is a vertex of the initial polygon there is no pair of triangles such that their intersection has non zero area and the total area of all triangles is equal to the area of the given polygon The weight of a triangulation is the sum of weigths of triangles it consists of where the weight of a triagle is denoted as the product of labels of its vertices Calculate the minimum weight among all triangulations of the polygon ,You can use straightforward way and calculate answer with l r dp with But there is a easier claim it s optimal to split gon with diagonals coming from so answer is Proof let s look at the triange which contains edge Let s name it If we can delete this triangle and go to gon Otherwise Let s look at triangle It always exists and Finally if we change pair of triangles to answer will decrease since and that s why Note that triangle changes to and so repeating this step will eventually lead us to situation As a result we can morph any triangulation into one mentioned above and its weight won t increase ,Note that whichever path you choose the total cost will be the same If you know that the cost is the same then it s not hard to calculate it It s equal to So the task is to check is equal to or not The constant cost may be proved by induction on for cost is For a fixed there are only two last steps you can make either from with cost the total cost is or from with cost the total cost is So whichever path you choose the total cost is the same 
402,Your friend Mishka and you attend a calculus lecture Lecture lasts minutes Lecturer tells theorems during the th minute Mishka is really interested in calculus though it is so hard to stay awake for all the time of lecture You are given an array of Mishka s behavior If Mishka is asleep during the th minute of the lecture then will be equal to otherwise it will be equal to When Mishka is awake he writes down all the theorems he is being told during the th minute Otherwise he writes nothing You know some secret technique to keep Mishka awake for minutes straight However you can use it You can start using it at the beginning of any minute between and If you use it on some minute then Mishka will be awake during minutes such that and will write down all the theorems lecturer tells You task is to calculate the maximum number of theorems Mishka will be able to write down if you use your technique to wake him up ,Let s iterate over all from to and if is equal to then add to the some variable and replace with Then answer will be equal to where can be easily calculated with prefix sums for each ,We have to find the number of triples such that equations and are satisfied Let s subtract one equation from another and get that So we know that and after substituting we get that We can see that there is only one correct value of and for every odd value of greater than So we can iterate over the value of and check that the corresponding value of doesn t exceed This solution works in because but you can also solve it in 
403,There is a light source on the plane This source is so small that it can be represented as point The light source is moving from point to the with speed equal to unit per second The trajectory of this light source is a straight segment connecting these two points There is also a fence on axis represented as segments so the actual coordinates of endpoints of each segment are and The point is if segment connecting and the current position of the light source intersects or touches with any segment of the fence You are given points For each point calculate total time of this point being in the shade while the light source is moving from to the ,Let s calculate the answer for a fixed point If you project with respect of each segment of the fence to the line containing light source you can see that the answer is the length of intersection of fence projection with segment of the trajectory light source Key idea is the fact that the length of each fence segment is multiplied by the same coefficient On the other hand fence segments whose projections lie inside form a subsegment in the array of segments so its total length can be obtained with partial sums And at most two fence segment are included in the answer partially their positions can be calculated with lower bound if you project points and on axis So now you can answer the query with time and quite small hidden constant and resulting complexity is ,Let s calculate the answer for the first permutation naively in Then let s recalculate the answer somehow and then maybe prove that it works in linear time Which summands will change when we try to recalculate the function using First of all let s notice that each pair of adjacent elements of is the segment on the permutation To calculate fast let s firstly notice that all segments that cover the element but is not their endpoint will change their length by minus one after placing at the first position because will be removed from all such segments This part can be calculated in Let s use the standard trick with prefix sums and segments Let be the array of length For each pair of adjacent elements and for all from to let s do the following sequence of moves if then there are no points that covered by this segment not being its endpoints so let s just skip this segment Otherwise let s increase the value of by one and decrease the value of by one After this let s build prefix sums on this array make for all from to And now equals to the number of segments covering the element The second part that will change is such segments that is their endpoint Let s store the array of arrays of length and will store all elements adjacent to in the array for all from to But one important thing we don t need to consider such pairs and that it broke my solution somehow so this part is important Knowing these two parts we can easily calculate using Firstly let s initialize the result as Then we need to recalculate lengths of such segments that is their endpoint Let s iterate over all elements in set remove the old segment and set add the length of the segment from to and increase by one if it means that and change their relative order and the length of the segment from to increases by one Now we can see that after iterating over all from to we make at most moves because each pair of adjacent elements in was considered at most twice Total complexity 
404,A permutation of length is a sequence of integers from to such that each integer appears in it exactly once Let the fixedness of a permutation be the number of fixed points in it the number of positions such that where is the th element of the permutation You are asked to build a sequence of permutations starting from the identity permutation permutation Let s call it a permutation chain Thus is the th permutation of length For every from onwards the permutation should be obtained from the permutation by swapping any two elements in it not necessarily neighboring The fixedness of the permutation should be strictly lower than the fixedness of the permutation Consider some chains for that is a valid chain of length From to the elements on positions and get swapped the fixedness decrease from to that is not a valid chain The first permutation should always be for that is not a valid chain From to the elements on positions and get swapped but the fixedness increase from to that is a valid chain of length From to the elements on positions and get swapped the fixedness decrease from to From to the elements on positions and get swapped the fixedness decrease from to Find the longest permutation chain If there are multiple longest answers print any of them ,Ideally we would want the fixedness values to be That would make a chain of length However it s impossible to have fixedness of after one swap The first swap always makes a permutation with fixedness Okay how about then That turns out to always be achievable For example swap elements and then elements and then and and so on Overall complexity per testcase ,Imagine that all elements of are distinct This way sorting in increasing order will fix the order of If turns out sorted in a non decreasing order then the answer exists Otherwise it doesn t To obtain the sequence of swaps you can sort with any comparison based sorting algorithm you want even bubble sort will not exceed the allowed number of swaps What changes if has repeated elements Distinct elements are still ordered among themselves but now there are also blocks of equal elements For each block look into the corresponding values in Obviously these have to be sorted in a non decreasing order Rearrange them as they should be In fact this is exactly the same as sorting the sequence of pairs with a default comparator first by then by Since we fixed the wanted order we can proceed with the same steps we made in a distinct case Overall complexity or per testcase 
405,The heat during the last few days has been really intense Scientists from all over the Berland study how the temperatures and weather change and they claim that this summer is abnormally hot But any scientific claim sounds a lot more reasonable if there are some numbers involved so they have decided to actually calculate some value which would represent how high the temperatures are Mathematicians of Berland State University came up with a special This value is calculated as follows Suppose we want to analyze the segment of consecutive days We have measured the temperatures during these days the temperature during th day equals We denote the of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days So if we want to analyze the from day to day we calculate it as note that division is performed without any rounding The is the maximum of over all segments of not less than consecutive days For example if analyzing the measures and we are interested in segments and we want to find the maximum value of over these segments You have been hired by Berland State University to write a program that would compute the of a given period of days Are you up to this task ,This task is very straight forward implementation problem So we can iterate over all segments of the given array calculate their sum and if the length of the current segment is not less than k try to update the answer with the mean of this segment Overall complexity is O n 2 ,Note that in this context denotes We can make the observation that only the first elements matter since after placing them optimally we can be sure all bits that could be set in the prefix OR would have already been set So we can brute force the optimal choice times we choose to add an element if it provides the largest new prefix OR value among all unused elements and then just add the rest of the unused elements 
406,Polycarp is an organizer of a Berland ICPC regional event There are universities in Berland numbered from to Polycarp knows all competitive programmers in the region There are students the th student is enrolled at a university and has a programming skill Polycarp has to decide on the rules now In particular the number of members in the team Polycarp knows that if he chooses the size of the team to be some integer each university will send their strongest with the highest programming skill students in the first team the next strongest students in the second team and so on If there are fewer than students left then the team can t be formed Note that there might be universities that send zero teams The strength of the region is the total skill of the members of all present teams If there are no teams present then the strength is Help Polycarp to find the strength of the region for each choice of from to ,There are two important observations to make The first one is that you can calculate the answers for each university independently of each other and sum them up to obtain the true answer The second one is that if there are students in an university then that university can only contribute to answers for from to So if we learn to calculate the contribution of the th university for some fixed in then we will be able to iterate over all possible for each university and get the solution in where is the number of students in the th university To achieve it you have to gather the sum of the maximum number of students that can form full teams of size That must be the highest number less than or equal to that is divisible by so Sort the students of each university precalculate partial sums and now you are free to add the prefix sum of that number of students to the answer for Overall complexity per testcase ,This problem has many approaches as Hall s theorem Kuhn algorithm and so on I will explain one or two of them Let s find the answer using binary search It is obvious that if we can pass all the exams in days we can also pass them in days For the fixed last day let s do the following thing firstly if there exists some exam with the day of the first opportunity to pass it greater than then the answer for the day is false Next while there exist exams having only one possibility to pass them because of the upper bound of the maximum possible day or constraints imposed by the other exams we choose this day for this exam and continue after choosing such day there can appear some new exams with the same property Now there are no exams having only one day to pass them Let s take a look on the graph where vertices represent days and edges represent exams the edge between some vertices and exists iff there is an exam with the first day to pass it equal to and the second day to pass it equal to Let s remove all the exams for which we identified the answer Now let s take a look on the connected components of this graph and analyze the problem which we have now Our problem is to choose exactly one vertex incident to each edge of the connected component such that no vertex is chosen twice and we have to do this for all the connected components we have Let be the number of vertices in the current connected component and be the number of edges in the current connected component The answer for the connected component is true iff for obvious reasons There is very easy constructive method to see how we can do this If then the current connected component is a tree Let s remove some leaf of this tree and set it as the chosen vertex for the edge incident to this leaf and remove this edge too If then let s remove all leaves as in the algorithm for the tree For the remaining cycle let s choose any edge and any vertex incident to it set this vertex as the chosen to this edge and remove them Now we have a chain Chain is a tree so let s apply the algorithm for the tree to this chain So if for some connected component holds then the answer for the day is false Otherwise the answer is true Overall complexity because of numbers compressing or using logarithmic data structures to maintain the graph Also there is another solution which can be too slow I don t know why it works It is well known fact that if we will apply Kuhn algorithm to the some bipartite graph in order of increasing indices of vertices of the left part then the last vertex in the left part of this graph which is in the matching will be minimum possible Oh that s what we need Let the left part of this graph consist of days and the right part consist of exams The edge between some vertices from the left part and from the right part exists iff is one of two days to pass the exam Let s apply Kuhn algorithm to this graph considering days in increasing order The first day when matching becomes all exams are in the matching will be the answer I don t know its complexity really Maybe it works too fast because of the special properties of the graph If someone can explain in which time it works I will very happy 
407,You are given an array of integers You can perform the following operations on array elements choose any index and move the element to the of the array choose any index and move the element to the of the array For example if then the following sequence of operations can be performed after performing the operation of the first type to the second element the array will become after performing the operation of the second type to the second element the array will become You can perform operations of any type any number of times in any order Find the minimum total number of operations of the first and second type that will make the array sorted in non decreasing order In other words what is the minimum number of operations must be performed so the array satisfies the inequalities ,Let s replace each number with the number of unique numbers less than For example the array will be replaced by Note that the values of the numbers themselves were not important to us only the order between them was important Let s sort such an array Let s see what maximum length of the segment from the array is already sorted it forms a subsequence This segment can be left in place and all other numbers can be moved either to the beginning or to the end That is the task came down to finding the maximum sorted subsequence in the array This problem can be solved with the help of simple dynamic programming Let be the maximum length of a subsequence ending in position To calculate it we will find the closest past position which also has the value and the position with value lower numbers cannot be used since must stand between them Any of these positions can be extended so we take the maximum out of them and add 1 It is necessary to separately consider the first numbers in the subsequence and the last since the first should include their suffix and the last should have their prefix ,Let s define a function greaterCount number of subarrays with median greater or equal than In this case the answer on the problem is greaterCount greaterCount The subarray has median greater or equal than if and only if where is the number equal or greater than elements and is the number of less than elements In other words instead of processing you can use the sequence containing or and An element if An element if Now the median of is greater or equal than if and only if Let s iterate over from left to right Maintain the current partial sum Additionally in the array let s maintain the number of partial sum for each its value It means that before increase of you should do So if is the index of the right endpoint of a subarray i e then number of suitable indices is number of such that In other words find sum of all where it is exactly number of indices with partial sum less than Each time partial sum changes on or So the value sum of all where is easy to recalculate on each change If you decrease just subtract the value If you increase before increasing just add Since indices in can be from to you can use 0 based indices using an array In this case initialize as but not as it makes to be non negative on each step This solution works in 
408,Let s call the of the number the number of zeros to which it ends You have an array of numbers You need to choose a subset of exactly numbers so that the of the product of the selected numbers will be maximum possible ,Let s use dynamic programming to solve this task Obviously the of the number is determined by minimum of powers of and in the number Let be the maximal power of in the number and be the maximal power of Let be the maximum amount of twos we can collect by checking first numbers taking of them with total power of five equal to It is usually called the knapsack problem There are two types of transitions You can either take current element or skip it The answer will be maximum of for every Also keeping this many states can cause ML the first dimension should be stored in two layers and recalced on the fly Overall complexity ,Consider the subset that is the answer to the problem Let be the arbitrary three elements from and let no more than one of them is equal to By the pigeonhole principle two of three elements from have the same parity So we have two integers with even sum and only one of them is equal to so their sum is also greater than So the subset is not simple In this way consists of only two numbers greater than one with a prime sum or consists of some number of ones and also maybe other value so that is a prime We can simply process the first case in time The second case can be processed in linear time Also we should choose the best answer from that two To check the value of order for primality in time we can use the simple or the linear Eratosthenes sieve 
409,You are given an undirected graph consisting of vertices and edges The th edge has weight it connects the vertices and Initially each vertex contains a chip Each chip has an integer written on it the integer written on the chip in the th vertex is In one operation you can choose a chip if there are multiple chips in a single vertex you may choose any one of them and move it along one of the edges of the graph The cost of this operation is equal to the weight of the edge The of the graph is the minimum cost of a sequence of such operations that meets the following condition after all operations are performed each vertex contains exactly one chip and the integer on each chip is to the index of the vertex where that chip is located You are given queries of the form change the weight of the th edge the one which connects the vertices and to After each query print the of the graph Note that you don t actually move any chips when you compute the cost the chips are on their initial positions ,Let s try to analyze how many times we traverse each edge in the style of Contribution to the Sum technique For each edge the number of times it is traversed must be even since for every chip that goes from the part of the graph 1 i to the part i 1 n there should be a chip that goes in the opposite direction the number of chips on vertices 1 n should be unchanged For each vertex at least one incident edge should be traversed at least twice otherwise the chip from this vertex cannot be moved to any other vertex We would also like to traverse the edges as rarely as possible Is it possible to find an answer where if we traverse any edge we traverse it only twice It turns out it is possible Let s split the graph into several parts by removing the edges we don t traverse If we don t break the constraint that each vertex has at least one incident edge which is traversed by some chip then each part of the graph will contain at least two vertices And in each part we can make sure that each edge is traversed only twice as follows let the part represent the segment l r of vertices if we move the chip r to the vertex l the chip l to the vertex l 1 the chip l 1 to the vertex l 2 the chip r 1 to the vertex r then every edge in that part will be traversed exactly twice So we have shown that if we pick a subset of edges which we traverse that meets the constraint on each vertex having an incident traversed edge then it is enough to traverse each chosen edge only twice Now the problem becomes the following choose a subset of edges in such a way that every vertex has at least one incident chosen edge minimize the total weight of this subset and print the integer which is double that total weight Since the structure of the graph is specific we can run dynamic programming of the form dp i f the minimum total weight of the subset if we considered the first i edges and f is 0 if we haven t taken the last edge or 1 if we have Obviously this dynamic programming works in O n which is too slow because we have to process queries We will employ a classical technique of storing the dynamic programming in segment tree build a segment tree on n 1 leaves in every vertex of the segment tree we store a 2 times 2 matrix d if the segment represented by the node of the segment tree is l r then the value of d f 1 f 2 is the minimum total weight of the subset of edges between l and r such that among every pair of adjacent edges at least one is chosen f 1 and f 2 represent the status of the first last edge on the segment respectively And when some element changes we need to recalculate only O log n nodes of the segment tree so this solution works in O n log n q log n albeit with a very big constant factor Implementation note don t use dynamic size arrays like in C to store the values in the matrices it might slow your solution very seriously Instead use static size arrays ,Find the distances to all vertices and construct a new graph that has only edges that goes from a vertex with a smaller distance to a vertex with a larger distance Such a graph cannot contain cycles Next you need to run a dynamic programming similar to finding bridges in an undirected graph First we write the minimum distance from each vertex to the capital using no more than one edge This distance is either equal to the distance from the capital to the vertex itself or the distance to the vertex connected to us by one of the remote edges We can t go through more than one remote edge The real answer for a vertex is the minimum of such values in all vertices reachable from in the new graph Since the new graph is acyclic we can calculate the answer using dynamic programming and a depth first search started from the capital 
410,You are given an undirected graph consisting of vertices and edges Instead of giving you the edges that exist in the graph we give you unordered pairs such that there is no edge between and and if some pair of vertices is not listed in the input then there is an edge between these vertices You have to find the number of connected components in the graph and the size of each component A connected component is a set of vertices such that for every two vertices from this set there exists at least one path in the graph connecting these vertices but adding any other vertex to violates this rule ,Let be the set of unvisited vertices To store it we will use some data structure that allows us to do the following insert some value into the set delete from the set find the smallest integer from the set such that For example from allows us to do all these operations fastly Also we can use this structure to store the adjacency lists We will use a modified version of depth first search When we are entering a vertex with we erase it from the set of unvisited vertices The trick is that in we will iterate over the set of unvisited vertices using its function And we will make not more than iterations overall because when we skip an unvisited vertex that means there is no edge from this vertex to the vertex we are currently traversing in so there will be no more than skips and each iteration we don t skip decreases the number of unvisited vertices ,The first thing to come to one s mind is dynamic programming on a trie The most naive of the solutions take where is the total length of strings I ll introduce the faster approach Let be the solution for subtree of the vertex with buttons remaining and is the closest ancestor vertex with the button used in it This dp will be recalced via the other dp Let be the same thing as but only first children of is taken into consideration and doesn t have a button in it Give buttons to the current child then update with will then have two options for having button in it and for not having button in it has transitions and states has total transitions and also states 
411,You are given an expression of the form where and are integers from to You have to evaluate it and print the result ,There are multiple ways to solve this problem Most interpreted languages have some function that takes the string evaluates it as code and then returns the result One of the examples is the function in Python If the language you use supports something like that you can read the input as a string and use it as the argument of such a function Suppose you use a language where this is impossible There are still many approaches to this problem The most straightforward one is to take the first and the last characters of the input string calculate their ASCII codes and then subtract the ASCII code of the character from them to get these digits as integers not as characters Then you can just add them up and print the result ,Multiplying by power of is shift left binary operation you probably should know it Reverse and for the simplicity and look at leftmost in let s denote its position as If you move it to in then you make the lexicographically bigger than the reverse of So you should move it to in too You can choose any with position Let be the minimum position of in such that You must move to otherwise the in still be present in and it will be not optimal So the solution is next reverse and find find print 
412,Timur likes his name As a spelling of his name he allows any permutation of the letters of the name For example the following strings are valid spellings of his name Note that the correct spelling must have uppercased and lowercased other letters Today he wrote string of length consisting only of uppercase or lowercase Latin letters He asks you to check if is the correct spelling of his name ,Here are two solutions Iterate through the string character by character If then otherwise if or then or If the statement is false for any the answer is Otherwise it is Replace all with since they are the same anyway Then just check if the two strings are equal In either case the complexity is per testcase ,The only case when the answer is is when all letters of the string are equal Why is it so Because if we have at least two different letters we can place the first one at the first position of the string and the second one at the last position of the string Then it is clearly that the obtained string is We can implement this solution by the following way sort and if the first letter equals to the last one then the answer is otherwise the answer is 
413,You are given a tree an undirected connected acyclic graph consisting of vertices You are playing a game on this tree Initially all vertices are white On the first turn of the game you choose one vertex and paint it black Then on each turn you choose a white vertex adjacent connected by an edge to black vertex and paint it black Each time when you choose a vertex even during the first turn you gain the number of points equal to the size of the connected component consisting only of white vertices that contains the chosen vertex The game ends when all vertices are painted black Let s see the following example Vertices and are painted black already If you choose the vertex you will gain points for the connected component consisting of vertices and If you choose the vertex you will gain points for the connected component consisting of vertices and Your task is to maximize the number of points you gain ,I should notice that there is much simpler idea and solution for this problem without rerooting technique but I will try to explain rerooting as the main solution of this problem it can be applied in many problems and this is just very simple example What if the root of the tree is fixed Then we can notice that the answer for a subtree can be calculated as where is the set of children of the vertex The answer on the problem for the fixed root will be How can we calculate all possible values of for each root from to fast enough We can apply rerooting When we change the root of tree from the vertex to the vertex we can notice that only four values will change and Firstly we need to cut the subtree of from the tree rooted at Let s subtract and from then let s change the size of the subtree of subtract from it Now we have the tree without the subtree of Then we need to append as a child of Add to and add and to Now we have as a root of the tree and can update the answer with When we changes the root of the tree back from to we just need to rollback all changes we made So overall idea is the following calculate sizes of subtrees for some fixed root calculate dynamic programming for this root run dfs which will reroot the tree with any possible vertex and update the answer with the value of dynamic programming for each possible root The code of function that reroots the tree seems like this void dfs int v int p 1 ans max ans dp v for auto to g v if to p continue dp v dp to dp v siz to siz v siz to siz to siz v dp to siz v dp to dp v dfs to v dp to dp v dp to siz v siz to siz v siz v siz to dp v siz to dp v dp to ,Firstly let s choose some deepest farthest from the root vertex in the query among all such vertices we can choose any It is obvious that every vertex in the query should either belong to the path from the root to or the distance to some vertex of this path should be at most one Now there are two ways write some LCA algorithms and other hard stuff which is unnecessary in this problem or write about lines of code and solve the problem Let s take every non root vertex except and replace it with its parent So what s next Now the answer is if vertex after transformation belongs to the path from root to Now we just need to check if it is true We can do this using the very standard technique firstly let s run dfs from the root and calculate for each vertex the first time we visited it and the last time we visited it We can do this using the following code void dfs int v int par 1 tin v T for auto to g v if to par continue dfs to v tout v T Initially equals zero Now we have a beautiful structure giving us so much information about the tree Consider all segments We can see that there is no pair of intersecting segments The pair of segments and is either non intersecting at all or one segment lies inside the other one The second beautiful fact is that for each vertex in the subtree of the segment lies inside the segment So we can check if one vertex is the parent of the other the vertex is the parent of the vertex if and only if and the vertex is the parent of itself How do we check if the vertex lies on the path from the root to the vertex It lies on this path if the root is the parent of it is always true and is the parent of This approach can be used for each path such a path from to that is either or Time complexity 
414, Vlad built a maze out of rooms and bidirectional corridors From any room any other room can be reached through a sequence of corridors Thus the room system forms an undirected tree Vlad invited friends to play a game with them Vlad starts the game in the room and wins if he reaches a room other than into which exactly one corridor leads Friends are placed in the maze the friend with number is in the room and no two friends are in the same room that is for all Friends win if one of them meets Vlad in any room or corridor before he wins For one unit of time each participant of the game can go through one corridor All participants move at the same time Participants may not move Each room can fit all participants at the same time Friends know the plan of a maze and intend to win Vlad is a bit afraid of their ardor Determine if he can guarantee victory i e can he win in any way friends play In other words determine if there is such a sequence of Vlad s moves that lets Vlad win in any way friends play ,First we need to understand when it is not possible to get to some exit Let s fix a friend who is at the vertex and try to understand if he can interfere with us The paths from to and from to have a common part let it start at the vertex Then if the path from to is not more than from to it can prevent us from reaching this exit by blocking the vertex Since the path from to is common the previous condition is equivalent to the condition that the path from to is not greater than from to Note that if there is more than one such vertex then can overlap each of them simply by going as close to the root as possible Thus Vlad can win if there is such a leaf which by condition exits for which the distance to the root is less than the distance to any of the friends By running a breadth first search at the same time from each vertex with a friend we can find the shortest distance to any friend from each vertex and by running from the root the distance to the root Now let s just go through all the leaves and check if there is one among them that the distance to the root is less We can also run from the vertices with friends and from the root at the same time assigning them different colors then the color will correspond to what is closer the root or some friend this solution is attached to the tutorial There is also another solution which is a simplified version of the one we will use in E2 ,The main idea is to use a two dimensional data structure one dimension is depth of vertices and other dimension is the time we entered a vertex during DFS Model solution uses sparse table for these purposes First of all let s renumerate the vertices so we can handle them easier We run DFS from the root and then sort the vertices by their depth and if depths are equal by time we entered them in DFS Then we renumerate vertices in this sorted order We need to denote some functions in order to continue depth of vertex in the tree the time we entered during DFS the time we left during DFS For each depth we can store a sorted array of vertices belonging do this depth This will allow us to build an auxiliary sparse table where is such vertex that is minimal among all vertices that meet first two conditions We also need a second sparse table where is iff is minimal among all vertices that meet first two conditions These sparse tables can be built using binary search in arrays we created for depths Okay why do we need them To create a third sparse table that will process the queries themselves the minimum value of among vertices such that belongs to blocked subtree of some vertex with index included in This table can be built backwards with the help of auxiliary tables So how do we answer the queries We need to look at the binary representation of and do something like binary lifting but descending the tree instead of ascending and maintain the leftmost and the rightmost vertices on current depth which belong to the subtree we are interested in and make queries to on the segment between these two vertices This solution works in but unfortunately or fortunately to some participants we made the time limit too high so the structures that require time to process each query such as two dimensional segment trees might also get AC 
415,Dasha an excellent student is studying at the best mathematical lyceum in the country Recently a mysterious stranger brought words consisting of small latin letters to the lyceum Since that day Dasha has been tormented by Consider some pair of integers is a string for which it is true It is obtained by concatenation Its length is The number of different letters in it is The number of occurrences of each letter that is in the word is For example if abcdefg and ijklmnopqrstuvwxyz the pair creates a Dasha will stop having if she counts their number There are too many so Dasha needs your help Count the number of different are called different if the corresponding pairs are different The pairs and are called different if ,Observation the product of odd numbers is odd so the condition for the length of is automatically completed Denote by the number of ones in binary representation of Let s enumerate the letters of the Latin alphabet from to Observation for each word it is enough to know the set of letters included in it and the evenness of their numbers There are only letters in the alphabet so it is convenient to store the word characteristic as a pair of masks The bit with the number in will be responsible for the availability of the letter in The bit with the number in will be responsible for the evenness of the number of letters in Observation strings creates if and only if Let s fix the number the index of the letter that will not be in Let s throw out all the words with the letter now we can look at the words in turn and look for a pair of them among those already considered It is easy to see that the condition follows from the condition if one letter is banned To count the number of pairs that include our word we need to count the number of words with the characteristic We can do this by bin searching through a sorted array of or using standard data structures We got the solution for ,We will act greedily we will make an array consisting of elements in which we will mark if the letter is already encountered in the string and otherwise In the variable we will store the length of the even string that can be obtained from We will go through the string by executing the following algorithm if mark if then we already have a pair of repeating characters to add to an even string add to the number and clear the array Clearing is necessary because both characters that will make up the next pair must be in the string after the current character In other words if the last character in the current pair was then the first character in the new pair can be where Then we calculate the answer as 
416,You are given a colored permutation The th element of the permutation has color Let s define an as infinite sequence where all elements have We can also define a multiplication of permutations and as permutation where Moreover we can define a power of permutation as Find the minimum such that has at least one infinite path i e there is a position in such that the sequence starting from is an infinite path It can be proved that the answer always exists ,Let s look at the permutation as at a graph with vertices and edges It s not hard to prove that the graph consists of several cycles self loops are also considered as cycles So the sequence is just a walking on the corresponding cycle Let s consider one cycle In permutation we have But since or so and in general case Now walking with step we can note that the initial cycle split up on cycles of length Looking at the definition of infinite path we can understand that all we need to do is to check that at least one of cycles have all vertices of the same color We can check it in time for the cycle and fixed The final observation is next for and such that the produced cycles will have the same sets of vertices and differ only in the order of walking so we can check only one representative for each i e we can take only such which divide We can handle each cycle of separately So using the approximation that the number of divisors of is we get time complexity ,Let s try to solve for one of the given permutations Let it be some How to make the answer for it at least Well we have to find another permutation such that How about at least Well the same Push to the right side of the equation Now think What does it actually mean for some permutation to be multiplied by It stays the same So the first elements of will be equal to the first elements of Thus you have to find a permumtation such that its inverse has the longest common prefix with This can be done in multiple ways For example you can store all inverses in a trie and traverse it with until you reach a dead end Or simply push all prefixes of each inverse into a set and iterate over Alternatively you can just sort inverses and do lower bound for in this list the permutation with longest common prefix will be either the result or the one before it Overall complexity per testcase 
417,You are given a matrix with rows and columns Each element of the matrix is either an asterisk or a dot You may perform the following operation arbitrary number of times choose a square submatrix of with size where and replace each element of the chosen submatrix with a dot Choosing a submatrix of size costs coins What is the minimum number of coins you have to pay to replace all asterisks with dots ,Constraints lead us to some kind of dp solution is it usually called dp on broken profile Let will be the minimum price to get to th column and th row with selected is the previous cells inclusive from if then its exactly current column and two previous ones Transitions for submatrices and are straighforward just update mask with new ones and add to current value If the first cell of these is empty or is set in this position then you can go to or and if for free Finally you can go to with the price of Initial value can be in the first cells of the matrix The answer will be stored in some valid of However you can add extra empty columns and take the answer right from it will be of the same price Overall complexity ,The solution can be got from the second sample testcase Easy to see that if we place all odd numbers in the center in form of rhombus we will get a magic square 
418,You are given a matrix of size consisting of integers You can choose elements in Your task is to choose these elements in such a way that their sum is and this sum is the In other words you can choose no more than a half rounded down of elements in each row you have to find the maximum sum of these elements divisible by Note that you can choose zero elements and the sum of such set is ,This is pretty standard dynamic programming problem Let be the maximum possible sum we can obtain if we are at the element right now we took elements in the row and our current remainder is Initially all states are except Transitions are standard because this is a knapsack problem we either take the element if or don t take it If the element is not the last element of the row then transitions look like that we don t take the current element we take the current element this transition is only possible if The transitions from the last element of the row are almost the same but the next element is and the new value of is always zero The answer is ,At first let s solve this problem when m 1 and k 0 it is the problem of finding subarray with maximum sum For each position from 1 to n we want to know the value of maxl i max limits 1 le j le i 1 sum j i where sum l r sum limits k l k le r a k and sum x 1 x 0 We will calculate it the following way maxl i will be the maximum of two values 0 because we can take segments of length 0 a i maxl i 1 The maximum sum of some subarray is equal to max limits 1 le i le n maxl i So now we can calculate the values of best i max limits 0 le len i len cdot m ge 0 sum i len cdot m 1 i len k the same way best i is the maximum of two values 0 sum i m 1 i k best i m After calculating all values best i we can easily solve this problem At first let s iterate over the elements best i When we fix some element best i lets iterate over the value len 1 2 dots m and update the answer with value best i sum i len i 1 k 
419,There are players sitting at the card table Each player has a favorite number The favorite number of the th player is There are cards on the table Each card contains a single integer the th card contains number Also you are given a sequence Its meaning will be explained below The players have to distribute all the cards in such a way that each of them will hold exactly cards After all the cards are distributed each player counts the number of cards he has that contains his favorite number The joy level of a player equals if the player holds cards containing his favorite number If a player gets no cards with his favorite number i e his joy level is Print the maximum possible total joy levels of the players after the cards are distributed Note that the sequence is the same for all the players ,It is obvious that we can solve the problem separately for each favorite number because each player has only one favorite number and if the player gets a card not having his favorite number his joy will not change Let be the maximum possible total joy of players with the same favorite number it doesn t matter which one and cards containing their favorite number if the cards are distributed among the players optimally Note that and At the beginning all entries of the table are zeroes The transition in this dynamic programming depends on how many cards the th player will receive which is between and In other words the dynamic programming transition will look like for int i 0 i k i dp x 1 y i max dp x 1 y i dp x y h i where is the joy of the player if he receives exactly cards containing his favorite number Note that After filling the table the answer can be calculated very easily where is the number of players with favorite number and is the number of cards containing the number Time complexity is ,Suppose there is only one query i e we are given some array and we want to know who is the winner if the game is played on this array One of the obvious solutions is will the current player win if the chip is currently in the cell and the number in cell is We can already see that we don t need to know the exact value of we only want to know whether it s odd if there is a cell such that we can go from to and is a state where current player will lose then we should go to this cell since our opponent will enter a losing state of the game Otherwise we want to force our opponent to move out of cell and we can do so only if is odd So we found a dynamic programming solution with states but what is more important is that we can take all the elements in our array modulo Okay now let s solve the problem when there are only queries of type no modifications Since when calculating the values we are interested only in next cells and there are only variants of whether these cells are winning or losing we may consider each element of the array as a function that maps a mask of next states into a new mask of states if we pushed our new element into the front For example if the th element is even and states are winning losing losing winning and losing respectively and then we may consider a mask of next states as and then we can check if th state is winning and push a bit to the front of this mask discarding the last bit since new state is winning we will get a mask of It allows us to denote two functions and what will be the resulting mask of next states if current mask is and we push an even or odd element to the front Okay what about pushing more than one element We can just take the composition of their functions Since a function can be stored as an array of integers and the composition needs only time to be calculated then we can build a segment tree over the elements of the array and store a composition of all functions on the segment in each node This allows us to answer queries of type in The only thing that s left is additions on segment Adding an even number is easy just ignore this query To be able an odd number let s store another function in each node of the segment tree which would be the composition of all functions on the segment if we would add to all elements on the segment so the elements which were odd become even and vice versa This allows us to use lazy propagation if the query affects the whole node we may just swap two functions in it and push the query to the children of this node Overall complexity is It turns out we didn t think about it before the contest but some contestants submitted such solutions that it can be reduced to if we will use the distance to closest losing state instead of a mask of winning and losing states 
420,Digital collectible card games have become very popular recently So Vova decided to try one of these Vova has cards in his collection Each of these cards is characterised by its power magic number and level Vova wants to build a deck with total power not less than but magic numbers may not allow him to do so Vova can t place two cards in a deck if the sum of the magic numbers written on these cards is a prime number Also Vova cannot use a card if its level is greater than the level of Vova s character At the moment Vova s character s level is Help Vova to determine the minimum level he needs to reach in order to build a deck with the required total power ,The most tricky part of the problem is how to check if some set of cards allows us to build a deck with the required power not taking the levels of cards into account Suppose we have not more than one card with magic number if there are multiple cards with this magic number then we obviously can use only one of these Then two cards may conflict only if one of them has an odd magic number and another has an even magic number otherwise their sum is even and not less than so it s not a prime number This allows us to solve this problem as follows Construct a bipartite graph each vertex represents a card and two vertices are connected by an edge if the corresponding pair of cards can t be put in a deck Then we have to find the maximum weight of independent set in this graph This can be solved using maximum flow algorithm construct a network where source is connected with every odd vertex a vertex that represents a card with an odd magic number by an edge with capacity equal to the power of this card then connect every odd vertex to all even vertices that are conflicting with this vertex by edges with infinite capacities and then connect every even vertex to the sink by an edge with capacity equal to the power of the card all edges have to be directed Then the maximum power of the deck is equal to where is the sum of all powers and is the minimum cut value between the source and the sink which is equal to the maximum flow This allows us to check if we can build a deck of required power using only some set of cards for example only cards with level less than or equal to some ,Let s find an answer for a little different version of the game Let s say that is the final score if the first player has stamina and the second has stamina The first player can either hit the ball or How to calculate Obviously and Otherwise the first player can either hit the ball then the player spent stamina and now it s to the second player to decide hit or lose So basically we moved to the state and the answer in this case is where or lose the play then the player doesn t spend any stamina but the opponent serve the ball He serves the ball spend stamina and return to the state where the first player decides hit or lose Formally the answer in this case is Looking at and one of transitions we can guess that and prove it by induction is either or but and and is better than so The final step is to note that since Alice starts the first play and serve ball the answer is 
421,You are given strings Each string has cost Let s define the function of string where is the number of occurrences of in is the length of the string Find the maximal value of function over all strings Note that the string is not necessarily some string from ,This problem is a typical problem for some suffix data structure Four competitors who solved this problem during the contest used suffix automaton and one competitor used suffix tree My own solution used suffix tree so I ll describe solution with tree I think it s simple except of the building of the tree Let s build the new string by concatenation of all strings from input separating them by different separators The number of separators is so the alphabet is also So we should use map int int to store the tree and the complexity is increased by Let s build the suffix tree for the new string Let s match all the separators to the strings from the left of the separator Let s run dfs on the suffix tree that doesn t move over separators and returns the sum of the costs of the strings matched to the separators from the subtree of the current vertex Easy to see that we should simply update the answer by the product of the depth of the current vertex and the sum in the subtree of the current vertex ,We will construct the string starting with the largest letters Note that if then the th letter of the string is maximal so we know that the th letter affect all While the string is not completely constructed we will do the following Find all such that and the th character of string is not placed Put on all these positions in the string the maximum letter not used in the string there should be a sufficient number of letters in the string Subtract from all 
422,Let s denote yet again the sequence of Fibonacci strings where the plus sign denotes the concatenation of two strings Let s denote the sequence of suffixes of string as For example is and is the following sequence Elements in this sequence are numbered from Your task is to print first characters of th element of If there are less than characters in this suffix then output the whole suffix ,Suppose we added all the suffixes of into a trie Then we can find th suffix by descending the trie checking the sizes of subtrees to choose where to go on each iteration The model solution actually does that but computes the sizes of subtrees without building the whole trie Recall that if we insert all suffixes of a string into the trie then the size of subtree of some vertex is equal to the number of occurences of the string denoted by this vertex in the original string Since in our problem the strings are recurrent we may use prefix automaton to count the number of occurences To calculate the number of occurences of string in let s build prefix function for and an automaton which tells the value of prefix function if the previous value was and we appended to the string the same approach is used in KMP substring search algorithm Then let s build another automaton that will help us work with Fibonacci string what will be the value of prefix function if we append to the string For and this automaton can be easily built using and and for we may build using the automatons for and We also have to keep track of the number of occurences that can be done with another automaton on fibonacci strings There is a corner case when we need to stop descending the trie to handle it we need to check whether some string is a suffix of but that can be easily made by checking if Each step in trie forces us to do up to three depending on your implementation queries like count the number of occurences of some string in so overall the solution works in ,Let s count how many characters and we have in the string and store it in the array Also let s count our goal array Firstly the array is The main idea of this problem is a pretty standard lexicographically greedy approach We go from left to right and try to place the minimum possible character at the current position in such a way that placing this character is not breaking conditions of our problem How can we apply this approach to this problem Firstly let s define a function What does the value of this function mean It means the number of replacements we need to reach from Let at the beginning of the program This value means the minimum number of replacements to obtain some balanced ternary string Let s maintain the variable which initially is and means the number of replacements we already made So we iterate over all positions from to Firstly let s decrease So the array maintains the current amount of characters on suffix of the string Now let s iterate over characters from to and try to place every character If the current character is needed then let s decrease and if the number of replacements will still be minimum possible after such replacement then let s place this character set and go to the next position This will form lexicographically minimum possible answer with minimum number of replacements There is another simpler solution from PikMike you can call him to explain it I just will add his code to the editorial 
423,You are given a string consisting of lowercase Latin letters and queries for this string Recall that the substring of the string is the string For example the substrings of are but not and There are two types of queries is lowercase Latin letter replace with set calculate the number of distinct characters in the substring ,Let s store for each letter all positions in which it appears in some data structure We need such a data structure that can add remove and find the next element greater than or equal to our element fast enough Suddenly this data structure is again in C When we meet the first type query let s just modify two elements of corresponding sets one remove one add When we meet the second type query let s iterate over all letters If the current letter is in the segment then the first element greater than or equal to in the corresponding set should exist and be less than or equal to If it is so let s increase the answer by one After iterating over all letters just print the answer Time complexity when is the size of the alphabet ,Let s introduce the slightly naive solution Iterate over all values for periods and check the possibility of each one being correct The conditions for some period can be formulated the following way is the total length of the string is the number of full periods of length Let s find at least one such pair and such that and the remainder part of the string can be filled with letters A and letters B By easy construction one can deduce that the conditions of and are enough Thus should be greater or equal to and In order to move to the faster solution one should also remember that both remainder parts and should be non negative Let s learn how to solve the problem for the whole range of lengths which all have the number of full periods equal to the same value Let this range be From the aforementioned formulas one can notice that the restrictions on both and don t depend on the length itself but only on value of To be more specific The lowest and the highest values for and will be the following It is claimed that every value between and exists if the values are valid and The full proof about the given conditions being sufficient and the existence of every value on that range is left to the reader Some kind of a hint might be the suggestion to check how the inequalities change on the transition from some period to Restrict the values by and to count each answer on exactly one range of lengths Finally the value of is added to the answer The number of ranges with the same is Overall complexity 
424,You are given three integers and Your task is to find the integer such that that where is modulo operation Many programming languages use percent operator to implement it In other words with given and you need to find the maximum possible integer from to that has the remainder modulo You have to answer independent test cases It is guaranteed that such exists for each test case ,There are two cases in this problem If we try to maximize the answer we need to consider only two integers and Of course the first one is better we get rid of the existing remainder and trying to add to this number If it s too big then we can and need to take the second one this number is just the first one but decreased by The answer can be always found between these numbers Time complexity ,Let s represent as and as where and By definition so we can represent as Now we can rewrite the equation from the statement as follows Since the left hand side is divisible by the right hand side should also be divisible So we can iterate over as divisors of If the right hand side of is not divisible by then we can skip such let s denote as If has some prime divisor then exactly one of and should be divisible by because and have no common divisors So there are pairs of and for current value of We can precalculate the minimum prime divisor for each number up to the maximum value of that you may need in using Eratosthenes sieve Now we can solve the problem in for each testcase but that s not fast enough To speed up this approach we can precalculate the number of prime divisors for each number up to Let s denote as the minimum prime divisor of and as the number of prime divisors of Then plus if Now to solve the problem we only need to iterate over the divisors of so the time complexity is per testcase 
425,There are two infinite sources of water hot water of temperature cold water of temperature You perform the following procedure of alternating moves take cup of the water and pour it into an infinitely deep barrel take cup of the water and pour it into an infinitely deep barrel take cup of the water and so on The barrel is initially empty You have to pour into the barrel The water temperature in the barrel is an average of the temperatures of the poured cups You want to achieve a temperature as close as possible to So if the temperature in the barrel is then the of and should be as small as possible How many cups should you pour into the barrel so that the temperature in it is as close as possible to If there are multiple answers with the minimum absolute difference then print the smallest of them ,Alice wants to choose such a segment that is maximum possible There is a well known problem where you have to find a segment with maximum That problem is solved with Kadane algorithm Let s learn how to reduce our problem to that one Notice that the values in the array are unusually small Let s iterate over the maximum value on segment Let be the current value If we make all such that equal to then it will never be optimal to take them in a segment Find the maximum sum subarray in that modified array and update the answer with its Notice that you can ignore the fact if there is a value exactly equal to on the maximum sum segment If there isn t then you ll update the answer with a smaller value than the actual one Let the actual maximum on the maximum sum segment be some You can see that for any value between and the maximum sum segment will always be that chosen one Thus when you reach you ll update the answer with the correct value Overall complexity ,Most of the solutions used the fact that we can read all the queries compress them and process after the compression using simple segment tree But there is also an online solution Let s build a sparse table on array to answer queries on segments that are not modified in To process modification segments we will use implicit segment tree and lazy propagation technique We do not build the whole segment tree instead in the beginning we have only one node for segment and if some modification query accesses some node but does not modify the complete segment this node maintains only then we create the children of this node So the leaves of the segment tree are the nodes such that their segments are completely set to some value or not modified at all Since each modification query affects only nodes the resulting complexity will be 
426,Alice and Bob are playing a game Initially they are given a non empty string consisting of lowercase Latin letters The length of the string is even Each player also has a string of their own initially empty Alice starts then they alternate moves In one move a player takes either the first or the last letter of the string removes it from and adds to the beginning it to their own string The game ends when the string becomes empty The winner is the player with a lexicographically smaller string If the players strings are equal then it s a draw A string is lexicographically smaller than a string if there exists such position that for all and What is the result of the game if both players play optimally e g both players try to win if they can t then try to draw ,What do we do when the array loses elements only from the left or from the right and the constraints obviously imply some quadratic solution Well apply dynamic programming of course The classic what is the outcome if only the letters from positions to non inclusive are left is the answer is the base case the draw both strings are empty Let mean that Alice wins be a draw and mean that Bob wins How to recalculate it Let s consider a move of both players at the same time From some state first Alice goes then Bob The new state becomes Alice picked some letter Bob picked some letter What s that pick exactly So they both got a letter prepended it to their own string Then continued the game on a smaller string and prepended even more letters to the string Thus if we want to calculate from we say that we letters and Now it s easy If is not a draw then the new letters change nothing the result is still the same Otherwise the result of the game is the same as the comparison of letters and How to perform both moves at once First we iterate over the Alice s move whether she picks from or from After that we iterate over the Bob s move whether he picks from or from Since we want to be the best outcome for Alice we do the following For any Alice move we choose the worse of the Bob moves the maximum of Among the Alice s moves we choose the better one the minimum one Overall complexity per testcase ,Suppose there is only one query i e we are given some array and we want to know who is the winner if the game is played on this array One of the obvious solutions is will the current player win if the chip is currently in the cell and the number in cell is We can already see that we don t need to know the exact value of we only want to know whether it s odd if there is a cell such that we can go from to and is a state where current player will lose then we should go to this cell since our opponent will enter a losing state of the game Otherwise we want to force our opponent to move out of cell and we can do so only if is odd So we found a dynamic programming solution with states but what is more important is that we can take all the elements in our array modulo Okay now let s solve the problem when there are only queries of type no modifications Since when calculating the values we are interested only in next cells and there are only variants of whether these cells are winning or losing we may consider each element of the array as a function that maps a mask of next states into a new mask of states if we pushed our new element into the front For example if the th element is even and states are winning losing losing winning and losing respectively and then we may consider a mask of next states as and then we can check if th state is winning and push a bit to the front of this mask discarding the last bit since new state is winning we will get a mask of It allows us to denote two functions and what will be the resulting mask of next states if current mask is and we push an even or odd element to the front Okay what about pushing more than one element We can just take the composition of their functions Since a function can be stored as an array of integers and the composition needs only time to be calculated then we can build a segment tree over the elements of the array and store a composition of all functions on the segment in each node This allows us to answer queries of type in The only thing that s left is additions on segment Adding an even number is easy just ignore this query To be able an odd number let s store another function in each node of the segment tree which would be the composition of all functions on the segment if we would add to all elements on the segment so the elements which were odd become even and vice versa This allows us to use lazy propagation if the query affects the whole node we may just swap two functions in it and push the query to the children of this node Overall complexity is It turns out we didn t think about it before the contest but some contestants submitted such solutions that it can be reduced to if we will use the distance to closest losing state instead of a mask of winning and losing states 
427,Mihai has an chessboard whose rows are numbered from to from top to bottom and whose columns are numbered from to from left to right Mihai has placed exactly one bishop on the chessboard In other words the row and column of the bishop are between and inclusive The bishop attacks in all directions diagonally and there is no limit to the distance which the bishop can attack Note that the cell on which the bishop is placed is also considered attacked Mihai has marked all squares the bishop attacks but forgot where the bishop was Help Mihai find the position of the bishop ,There are many ways to solve the problem One way is to look for the following pattern There can only be one such pattern if there is one bishop and it s not on the edge of the board We can iterate through all cells and see if we can match this pattern and if we can we output the centre cell You can also look at the positions of the two diagonals and intersect them but it requires more implementation Time complexity per testcase ,What if there were no blocked cells Then the movement is easy From cell we can go to cells or Thus we can visit all cells that have the same remainder modulo over both dimensions The answer would be if and Let s choose the following path from start to finish Let be less or equal to If that isn t the case swap the cells First move up until the row is the same then move to the side until the column is the same What stops us from doing the same on a grid with blocked cells The first part of the part can remain the same we can always move up from the cell Only cells below the start cell can be blocked The second part is trickier If there is a column with too many blocked cells between the start and the finish column then we won t be able to pass through it Let s adjust the path for that Move up as high as possible to the highest cell with the same remainder modulo in this column Then move to the finish column and go down to the finish cell If there still exists a column with too many blocked cells then the answer is No matter what we do we won t be able to go around that column Otherwise the answer is Thus the solution is to check for remainders then find the largest number of blocked cells between the query columns and compare it to the highest row with the same remainder modulo as the start or the finish You can use any RMQ data structure you want Overall complexity with sparse table for RMQ for example 
428,Connected undirected weighted graph without self loops and multiple edges is given Graph contains vertices and edges For each edge find the minimal possible weight of the spanning tree that contains the edge The weight of the spanning tree is the sum of weights of all edges included in spanning tree ,This problem was prepared by dalex Let s build any MST with any fast algorithm for example with Kruskal s algorithm For all edges in MST the answer is the weight of the MST Let s consider any other edge x y There is exactly one path between x and y in the MST Let s remove mostly heavy edge on this path and add edge x y Resulting tree is the MST contaning edge x y this can be proven by Tarjan criterion Let s fix some root in the MST for example the vertex 1 To find the most heavy edge on the path from x to y we can firstly find the heaviest edge on the path from x to l lca x y and then on the path from y to l where l is the lowest common ancestor of vertices x and y To find l we can use binary lifting method During calculation of l we also can maintain the weight of the heaviest edge Of course this problem also can be solved with difficult data structures for example with Heavy light decomposition method or with Linkcut trees Complexity O mlogn It s very strange but I can t find any articles with Tarjan criterion on English although there are articles on Russian so here it is Some spanning tree is minimal if and only if the weight of any other edge x y not from spanning tree is not less than the weight of the heaviest edge on the path from x to y in spanning tree ,The answer is if and only if the sum of values is not equal to Writing some number on edge does not change the total sum and the goal of the problem is to make in each vertex thus getting in total The algorithm is simple you get an arbitrary spanning tree with dfs or dsu output the difference between sums of values of subtrees can be calculated with dfs for edges in this tree and for the rest of edges Let s take an arbitrary correct answer If is has some cycle in graph of edges with non zero numbers on them then you can remove it For example select any edge on it and subtract the number on it from all the edges of the cycle This doesn t break the correctness of the answer as you change both in and out flows for each vertex by the same value Now that edge has This way any answer can be transformed to tree And for any edge on tree we want to tranfer excess water units from the larger subtree to the smaller Overall complexity 
429,Polycarp has coins the value of the th coin is It is guaranteed that all the values are integer powers of i e for some integer number Polycarp wants to know answers on queries The th query is described as integer number The answer to the query is the minimum number of coins that is necessary to obtain the value using some subset of coins Polycarp can use only coins he has If Polycarp can t obtain the value the answer to the th query is The queries are independent the answer on the query doesn t affect Polycarp s coins ,We can solve the problem by the following way firstly for each power of 2 let s calculate the number of coins with the value equals this degree Let s call it cnt It is obvious that we can obtain the value b j greedily because all less values of coins are divisors of all greater values of coins Now let s iterate over all powers of 2 from 30 to 0 Let s deg be the current degree We can take min lfloor frac b j 2 deg rfloor cnt deg coins with the value equals 2 deg Let it be cur Add cur to the answer and subtract 2 deg cdot cur from b j If after iterating over all powers b j still be non zero print Otherwise print the answer Overall complexity O n q log maxAi ,Let s calculate the array where is the number of candies of the th type Let s sort it in non ascending order Obviously now we can take because this is the maximum number of candies of some type in the array Let be the last number of candies we take Initially it equals and the answer is initially the same number Then let s iterate over all values of in order from left to right If the current number is greater than or equal to the last taken number of candies then we cannot take more candies than because we iterating over values of in non ascending order so let s increase answer by and set Otherwise and we can take all candies of this type increase the answer by and set 
430,We will consider the numbers and as adjacent if they differ by exactly one that is We will consider cells of a square matrix as adjacent if they have a common side that is for cell cells and are adjacent to it For a given number construct a square matrix such that Each integer from to occurs in this matrix exactly once If and are adjacent cells then the numbers written in them ,Note that is the only case where there is no answer For other cases consider the following construction Let s say that the cell is white if is an even number otherwise we will say that the cell is black Let s arrange the cells so that all white cells are first and if the colors are equal the cells will be compared lexicographically Arrange numbers from to in ordered cells For example for the following matrix will be constructed ,Suppose and are even A necessary and sufficient condition of existence of the answer is that is even Let s prove the sufficient condition If the count of the horizontal dominoes is even then we can combine them and vertical dominoes to blocks of size the number of the vertical dominoes is even too if is even If and are even we can fill the table with these blocks The description of the locations of the dominoes may be printed as follows consider the table is a chessboard where a cell is a block of two dominoes Consider the leftmost topmost cell of the board is black If a cell of the board is black let s mark one of the dominoes of the block with the letter and the other one with the letter If a cell of the board is white let s mark one of the dominoes of the block with the letter and the other one with the letter There will be no situation that some two cells of the table are marked with one letter but belong to different dominoes Let s prove the necessary condition The number of cells in a column is even so the number of cells that belong to vertical dominoes is even because cells of each vertical domino may be either belong to the column or not belong at the same time So the number of cells that belong to horizontal dominoes is even Let s cross out all cells that belong to vertical dominoes and let s find the leftmost column having cells that haven t been crossed out It s the leftmost column with such cells so the pairwise cells of the non crossed out cells belong to the column to the right of the found one The number of such cells in the right column is equal to the number of found cells so it s even and the number of found horizontal dominoes is even too Let s cross out the found cells and the pairwise cells The number of non crossed out cells in the right column will be even The number of crossed out horizontal dominoes will be even too Let s repeat this procedure until all the dominoes will be crossed out In every step we have crossed out the even number of horizontal dominoes hence the total count of horizontal dominoes is even Suppose is odd hence is even In this case every column contains an odd number of cells whereas the number of cells that belong to vertical dominoes is even So the number of cells that belong to horizontal dominoes is odd Consider the leftmost column and find a cell of it that belongs to a horizontal domino it must be found because the number of such cells is odd so it isn t equal to Let s find the pairwise cell and cross out both cells Currently the two columns will have an even number of non crossed out cells Let s repeat the procedure until all columns will have even non crossed out cells We will cross out cells and dominoes So the necessary condition is that the number of horizontal dominoes is at least Let s extend the necessary condition with the following condition the value of is even Consider the table that we ve become after the previous procedure where each column has exactly one crossed out cell Let s start the procedure we ve done in the case of even both and The procedure can be started on our table because each column of the table has an even number of non crossed out cells As a result of the procedure we will cross out an even count of horizontal dominoes so the value of is even Let s build an answer if the conditions and is even are met Let s place in the topmost row horizontal dominoes and mark their cells as follows the first domino will be marked with the second one with the third one with and so on As the result the region of rows and columns will be unfilled Both values are even and the value of is even too So let s fill the region as if it s a separate table having even numbers of rows and columns As it was proved above it s possible to do The set of letters used for the region and set of the letters used for the topmost row don t have common elements so there will be no cells that are marked with one letter but belong to different dominoes The case of odd hence is even is similar to the previous one let s transpose the table it will have rows and columns swap the values of and solve the case above and transpose the table back to have rows and columns 
431,There are houses in a row They are numbered from to in order from left to right Initially you are in the house You have to perform moves to other house In one move you go from your current house to some other house You can t stay where you are i e in each move the new house differs from the current house If you go from the house to the house the total distance you walked increases by units of distance where is the absolute value of It is possible to visit the same house multiple times but you can t visit the same house in sequence Your goal is to walk exactly units of distance in total If it is impossible print Otherwise print and any of the ways to do that Remember that you should do exactly moves ,The solution for this problem is very simple at first if or the answer is Otherwise let s do the following thing times let be we have to greedily decrease the remaining distance but we also should remember about the number of moves which we need to perform We have to walk to possible house which is located at distance from the current house also don t forget to subtract from The proof of the fact that we can always walk to the house at distance is very simple one of the possible answers which is obtained by the algorithm above will looks like several moves of distance possibly one move of random distance less than and several moves of distance The first part of the answer can be obtained if we are stay near the leftmost or the rightmost house second and third parts always can be obtained because distances we will walk in every of such moves is less than Time complexity is ,First let s determine if it s possible to reach the end at all If the laser s field doesn t span until any wall then it s surely possible just stick to the wall yourself If it touches at most one wall it s still possible If it s the bottom wall or the left wall then take the path close to the top and the right wall Vice versa if it s the top wall or the right wall then take the path close to the bottom and the left wall What if both of these paths are locked That means that the laser touches at least two walls at the same time the top one and the left one or the bottom one and the right one Turns out it s completely impossible to reach the end in either of these two cases Just draw a picture and see for yourself Thus we can always take at least one of the path sticking to the walls The distance from the start to the end is and both of these paths are exactly this long So the answer is always either or To check if the laser touches a wall with its field you can either use a formula or check every cell adjacent to a wall Overall complexity or per testcase 
432,You have a matrix filled with integers You want your matrix to become beautiful The matrix is beautiful if the following two conditions are satisfied in each row the first element is smaller than the second element in each column the first element is smaller than the second element You can perform the following operation on the matrix any number of times rotate it clockwise by degrees so the top left element shifts to the top right cell the top right element shifts to the bottom right cell and so on Determine if it is possible to make the matrix beautiful by applying zero or more operations ,Sure you can just implement the rotation operation and check all possible ways to rotate the matrix but it s kinda boring The model solution does the different thing If a matrix is beautiful then its minimum is in the upper left corner and its maximum is in the lower right corner and vice versa If you rotate it the element from the upper left corner goes to the upper right corner and the element from the lower right corner goes to the lower left corner so these elements are still in the opposite corners No matter how many times we rotate a beautiful matrix its minimum and maximum elements will be in the opposite corners and the opposite is true as well if you have a matrix with minimum and maximum elements in opposite corners it can be rotated in such a way that it becomes beautiful So all we need to check is that the minimum and the maximum elements are in the opposite corners There are many ways to do it in my opinion the most elegant one is to read all four elements in an array of size then the opposite corners of the matrix correspond either to positions and or to positions and in this array So we check that the sum of positions of minimum and maximum is exactly ,It is clear that the order of operations does not affect the final result also it makes no sense to apply the same operation more than once by the property of the operation Let s construct a sequence of operations that will reduce the matrix to the matrix if the answer exists Let s try iterate over will we use the operation horizontal Now by the each element of the first line we can understand whether it is necessary to apply the operation vertical if Let s apply all necessary operations vertical It remains clear whether it is necessary to apply the operation horizontal for Let s look at each element of the first column by it you can understand whether it is necessary to apply the operation horizontal if 
433,Monocarp is planning to host a martial arts tournament There will be three divisions based on weight lightweight middleweight and heavyweight The winner of each division will be determined by a single elimination system In particular that implies that the number of participants in each division should be a power of two Additionally each division should have a non zero amount of participants participants have registered for the tournament so far the th of them weighs To split participants into divisions Monocarp is going to establish two integer weight boundaries and All participants who weigh strictly less than will be considered lightweight All participants who weigh greater or equal to will be considered heavyweight The remaining participants will be considered middleweight It s possible that the distribution doesn t make the number of participants in each division a power of two It can also lead to empty divisions To fix the issues Monocarp can invite an arbitrary number of participants to each division Note that Monocarp can t kick out any of the participants who have already registered for the tournament However he wants to invite as little extra participants as possible Help Monocarp to choose and in such a way that the total amount of extra participants required is as small as possible Output that amount ,Sort the weights now choosing and will split the array into three consecutive segments Consider a naive solution to the problem You can iterate over the length of the first segment and the second segment The third segment will include everyone remaining Now you have to check if there exist some and that produce such segment can be equal to the first element of the second segment since only all elements of the first segment are smaller than it Similarly can be equal to the first element of the third segment However if the last element of some segment is equal to the first element of the next segment no or can split the array like that Otherwise you can split an array like that So you can iterate over the lengths check the correctness and choose the best answer Now let s optimize it using the condition about powers of two First iterate over the size of the middle division which is a power of two Then over the length of the first segment which can be not a power of two Check if the first segment is valid So we fixed the length of the first segment and some value which is greater or equal than the length of the second segment That value isn t necessarily equal to the length of the second segment because the produced segment might be invalid So there is a greedy idea that the second segment should be as long as possible under the constraint that it doesn t exceed the fixed value The intuition is the following Consider the longest possible valid segment Now take the last element away from it We will have to invite one more participant to the middle division And that element will also get added to the third segment increasing its length So potentially you can only increase the required number of participants to invite This can be implemented in the following fashion For each position precalculate the closest possible segment border from the left Iterate over the size of the middle division as a power of two Iterate over the length of the first segment Find the closest border to the left of Get the lengths of the second and the third segments Find the closest powers of two to each length and update the answer Overall complexity per testcase ,This problem can be solved differently For example you can use some data structures or sqrt decomposition technique But it is not required We expected the following simple solution from the participants Let s preprocess the following values the position of the first element to the left from the th element such that Now to answer to the query we should check if then we have the answer Otherwise we should check the position 
434,You are given two segments and on the axis It is guaranteed that and Segments Your problem is to find two and such that and In other words you have to choose two integer points in such a way that the first point belongs to the segment and the second one belongs to the segment It is guaranteed that If there are multiple answers you can print of them You have to answer independent queries ,One of the possible answers is always a pair of endpoints of the given segments So we can add all endpoints to the array and iterate over all pairs of elements of this array and check if the current pair is suitable or not ,The triangle with side is degenerate if So we have to maximize the length of the longest side and minimize the total length of other sides Thus if then we answer if otherwise the answer is 
435,Not so long ago Vlad came up with an interesting function where is rounded the remainder of the integer division of by For example with and the value The number is fixed and known to Vlad Help Vlad find the maximum value of if can take any integer value from to inclusive ,Consider Note that is maximal over the entire segment from to so if there is in which gives a greater result then Note that numbers from to that have an incomplete quotient when divided by equal to do not fit this condition and are guaranteed to have a value less than And the number Has the maximum possible remainder Has the maximum possible among numbers less than So there are two candidates for the answer these are and The second candidate is suitable only if it is at least It remains only to compare the values of and select the maximum ,Let s represent as and as where and By definition so we can represent as Now we can rewrite the equation from the statement as follows Since the left hand side is divisible by the right hand side should also be divisible So we can iterate over as divisors of If the right hand side of is not divisible by then we can skip such let s denote as If has some prime divisor then exactly one of and should be divisible by because and have no common divisors So there are pairs of and for current value of We can precalculate the minimum prime divisor for each number up to the maximum value of that you may need in using Eratosthenes sieve Now we can solve the problem in for each testcase but that s not fast enough To speed up this approach we can precalculate the number of prime divisors for each number up to Let s denote as the minimum prime divisor of and as the number of prime divisors of Then plus if Now to solve the problem we only need to iterate over the divisors of so the time complexity is per testcase 
436,Monocarp is playing a strategy game In the game he recruits a squad to fight monsters Before each battle Monocarp has coins to spend on his squad Before each battle starts his squad is empty Monocarp chooses and recruits no more units of that type than he can recruit with coins There are types of units Every unit type has three parameters the cost of recruiting one unit of the th type the damage that one unit of the th type deals in a second the amount of health of one unit of the th type Monocarp has to face monsters Every monster has two parameters the damage that the th monster deals in a second the amount of health the th monster has Monocarp has to fight only the th monster during the th battle He wants all his recruited units to stay alive Both Monocarp s squad and the monster attack continuously not once per second and at the same time Thus Monocarp wins the battle if and only if his squad kills the monster strictly faster than the monster kills one of his units The time is compared with no rounding For each monster Monocarp wants to know the minimum amount of coins he has to spend to kill that monster If this amount is greater than then report that it s impossible to kill that monster ,Imagine you are fighting the th monster and you fixed the type of units and their amount What s the win condition Rewrite it as Notice how we only care about for both the units and the monster but not about and on their own Let s call and the power of the squad and the monster You can see that for each cost we can only leave one unit type of that price that has the largest value of Let s call it Now let s learn to determine the maximum power we can obtain for cost exactly We can iterate over the cost of one unit and the count of units in the squad Since should not exceed that will take Propagate to be the maximum power for cost exactly We have the knowledge about cost exactly but we actually want no more than Calculate prefix maximums over that will be the maximum power we can obtain with no more than coins For each monster we just have to find the smallest such that Since the array is monotone we can use binary search Overall complexity ,Let s sort the input array in non decreasing order Now we should take the first players to the first team and the last players to the second team That will guarantee that every member of the first team has greater or equal rating than every member of the second team Now the only thing left is to check if all ratings in the first teams differ from all the ratings in the second team if some are equal then in sorted order 
437,Polycarp plays a computer game yet again In this game he fights monsters using magic spells There are two types of spells spell of power deals damage to the monster and spell of power deals damage to the monster and the damage of the next spell Polycarp casts Each spell can be cast but Polycarp can cast them in any order For example suppose that Polycarp knows three spells a fire spell of power a lightning spell of power and a lightning spell of power There are ways to choose the order in which he casts the spells first second third This order deals damage first third second This order deals damage second first third This order deals damage second third first This order deals damage third first second This order deals damage third second first This order deals damage Initially Polycarp knows spells His spell set changes times each time he either learns a new spell or forgets an already known one After each change calculate the maximum possible damage Polycarp may deal using the spells he knows ,Let s solve this problem for fixed set of spells For example we have a fireball spells with powers and lighting spells with powers We reach the maximum total damage if we can double all spells with maximum damage It s possibly iff the set of largest by power spell let s denote this set as contains at least one fireball spell Otherwise if set contains only lightning spells the maximum damage reach when we double largest spells in set and one largest spell not from set if such spell exist Now how do you solve the original problem when spells are added and removed All we have to do it maintain the set of largest by power spells where is current number of lightning spells and change this set by adding or removing one spell Also you have to maintain the sum of spells power in set this set and the number of fireball spells in this set You can do it by in or on ,Let s analyze three cases based on the distance between two sections we are going to break break two neighboring sections and break two sections with another section between them and break two sections with more than one section between them Why exactly these cases Because the damage from the shots and the possibility to hit both sections with the same shot depends on the distance between them If there is more than one section between the two we want to break then any shot hits only one of these sections so each shot should be aimed at one of those sections and we break them independently Let s pick two sections with minimum durability and calculate the number of shots required to break them if these sections are and then the required number of shots is It actually does not matter if the distance between them is less than if it is so these sections will be analyzed in one of the other cases Okay now let s deal with two sections having exactly one section between them We can iterate on all combinations of these sections iterate on from to and pick sections and Let s analyze how can we damage them If we shoot at the section between them we deal damage to both sections if we shoot at one of those sections we deal damage to it and damage to the other section So each shot distributes damage between these two sections the way we want to distribute it and the number of shots required to break these two sections is The case when we try to break two adjacent sections is the trickiest one Let s say that these sections are and and If we target one of these sections we deal damage to it and damage to the other section Let s try to run the following algorithm shoot at the section with higher durability until both of them break It can be slow but we can see that after the first shots the durabilities of the sections become equal and each pair of shots after that deals damage to both sections So we can model the first shots subtract from and from and then we ll need shots The only case when this doesn t work is if we break both sections before we equalize their durabilities it means that and we need to do only shots 
438,A permutation is a sequence of integers from to in which all the numbers occur exactly once For example are permutations and are not Polycarp was given four integers and and asked to find a permutation of numbers from to that satisfies the following condition For example for and the following permutations are suitable not all options are listed But for example there is no permutation suitable for the condition above for and Help Polycarp for the given and find a permutation of numbers from to that fits the condition above If there are several suitable permutations print any of them ,It is easy to show that if we choose k numbers from a permutation of length n then the minimum sum of k numbers is frac k k 1 2 the maximum sum is frac k 2n 1 k 2 and any sum between them is achievable that is you can choose exactly k numbers from n so that their sum is equal to the desired one This fact allows us to implement the following greedy solution Denote for low k sum limits i 1 k i frac k k 1 2 for high n k sum limits i n k 1 n i frac k 2n 1 k 2 and for k r l 1 We will consider the numbers i n n 1 ldots 1 and determine whether to put them in the segment l r or not If k 0 high i k ge s and s i ge low k 1 then put the number i in the segment l r decrease s by i decrease k by 1 Otherwise we will not put the number i in the segment l r In the end if s 0 then we have chosen r l 1 a number with the sum of s so the remaining number can be arranged in any order If at the end s 0 then there is no way to select r l 1 a number from 1 2 ldots n with the sum of s ,Let s carefully analyze the operation denoted in the query Since the length of the array is always divisible by every element will be swapped with some other element The elements can be split into two groups the ones whose positions increase by and the ones whose positions decrease by Let s find some trait of the elements which will allow us to distinguish the elements of one group from the elements of the other group The first elements will be shifted to the right the next elements will be shifted to the left the next elements will be shifted to the right etc If we look at the binary representations of integers then we can see that the first elements have in the th bit the next elements have in the th bit the next elements have in the th bit and so on So if we consider the positions of elements as indexed then the operation can be described as follows Let the position of the element be If the th bit in is gets increased by otherwise gets decreased by What does it look like Actually it is just where denotes XOR So each query can be represented as swap with for some integer The combination of two queries can also be represented with a single query in fact the state of the array can be denoted as the XOR of all from the previous queries Now let s try to solve the following problem for every calculate the maximum sum of subsegment if every element is swapped with To solve this problem we can use a segment tree First of all we need to understand how to solve the problem of finding the maximum sum on subsegment using a segment tree To do this we should store the following four values in each vertex of the segment tree the sum of elements on the segment denoted by the vertex the maximum sum of elements on the prefix of the segment denoted by the vertex the maximum sum of elements on the suffix of the segment denoted by the vertex the answer on the segment If some vertex of the segment tree has two children these values for it can be easily calculated using the values from the children So we can glue two segments represented by the vertices together creating a new vertex representing the concatenation of these segments Okay but how do we apply XOR to this For every vertex of the segment tree let s create several versions the th version of the vertex represents the segment corresponding to this vertex if we apply swapping query with to it For a vertex representing the segment of length we can use the following relation to get all its versions here we denote as the th version of and and as the children of if then else The function here denotes the glueing together of two vertices we described above Now let s try to analyze how many versions of each vertex we need For the root we will need all versions For its children we need only versions For the children of the children of the root we need only versions and so on so overall the total number of versions is only and each version can be constructed in so the solution works in 
439,As you might remember from the previous round Vova is currently playing a strategic game known as Rage of Empires Vova managed to build a large army but forgot about the main person in the army the commander So he tries to hire a commander and he wants to choose the person who will be respected by warriors Each warrior is represented by his personality an integer number Each commander has two characteristics his personality and leadership both are integer numbers Warrior commander only if is the bitwise excluding OR of and Initially Vova s army is empty There are three different types of events that can happen with the army one warrior with personality joins Vova s army one warrior with personality leaves Vova s army Vova tries to hire a commander with personality and leadership For each event of the third type Vova wants to know how many warriors counting only those who joined the army and haven t left yet the commander he tries to hire ,Let s use binary trie to store all personalities of warriors that is just use the trie data structure on binary representations of all For each subtree of this trie you have to maintain the number of s currently present in this subtree when inserting a value of we increase the sizes of subtrees on the path from the node with to the root by and when removing we decrease the sizes of subtrees on this path by How can it help us with answering the events of third type We will descend the trie When descending we will try to find the number in the structure When we go to some subtree we determine whether we add the quantity of numbers in the subtree we are not going into by checking if the current bit in is equal to if so then for all numbers from this subtree their bitwise xor with the current commander s personality is less than The answer to the event is the sum of sizes of all subtrees we added while descending into the trie ,In this problem you should simply check the conditions from the problem statement 
440,You are given a string consisting of lowercase Latin letters Every letter appears in it no more than twice Your task is to rearrange the letters in the string in such a way that for each pair of letters that appear exactly twice the distance between the letters in the pair is the same You are not allowed to add or remove letters It can be shown that the answer always exists If there are multiple answers print any of them ,Let s consider a very special case of equal distances What if all distances were equal to It implies that if some letter appears exactly twice both occurrences are placed right next to each other That construction can be achieved if you sort the string for example first right down all letters a then all letters b and so on If a letter appears multiple times all its occurrences will be next to each other just as we wanted Overall complexity or per testcase ,There are two ways to solve this problem greedy approach and dynamic programming The first apprroach Considerr some segment of consecutive equal characters Let be the length of that segment Easy to see that we should change at least characters in the segment to remove all the pairs of equal consecutive letters On the other hand we can simply change the second the fourth etc symbols to letter that is not equal to the letters before and after the segment 
441,You are given array You need to split it into subsegments so every element is included in exactly one subsegment The weight of a subsegment is equal to The weight of a partition is a total weight of all its segments Find the partition of minimal weight ,Important note the author solution is using both linear Convex hull trick and persistent Li Chao tree As mentioned in commentaries applying the Divide and Conquer technique can help get rid of Li Chao tree More about both structures you can read in this article Let s try to write standard dp we can come up with arrays will be 0 indexed Let be the minimal weight if we splitted prefix of length in subsegments Then we can calculate it as 1 Maximums on segments are inconvenient let s try to group segments by the value of So we can find such sequence of borders where for each In other words and is the closest from the left position where Note that we can maintain this sequence with stack of maximums Ok then for each interval equation 1 transforms to Why did we use variables and Because there are two problems is needed because we iterate over and can t recalculate everything is needed because sequence is changing over time so do the But what we can already see we can maintain for each segment Convex hull with linear functions so we can take in logarithmic time Moreover we can store values in other Convex hull to take minimum over all segments in logarithmic time The problems arise when we try modificate structures while iterating Fortunately segments change not at random but according to stack of maximums So all we should handle are to merge segment on top of the stack with current segment in case when to erase segment on top of the stack along with its value to insert new segment on top of the stack along with its value To handle the third type is easy since all Convex hulls can insert elements There will be at most such operations on a single layer and we can ask value in and insert a line with To handle the second type is harder but possible since we can make Convex hull persistent and store its versions in the stack Persistent Convex hull persistent Li Chao tree There will be also operations in total and they cost us To handle the first type is trickiest part Note that all line coefficients of one convex hull are strictly lower than all line coefficients of the other So we can use linear Convex hulls to make insertions to back in amortized But to merge efficiently we should use Small to Large technique that s why we should be able also push front in and moreover still be able to ask minimum in And here comes the hack in C which can push pop front back in amortized and also have random access iterator to make binary search possible So each element of every segment will be transfered times with cost of amortized on a single layer In the end result complexity is Space complexity is ,Intersection of some segments is If this segment has its left bound greater than its right bound then the intersection is empty Removing some segment makes the original sequence equal to That can be split up to a prefix of length and a suffix of length Intersections for them can be precalced separately and stored in some partial sum like arrays Finally you have to iterate over the position of the removed segment and calculate the intersection of prefix and suffix without this segment Overall complexity 
442,The chef has cooked dishes yet again the th dish consists of grams of fish and grams of meat Banquet organizers consider two dishes and equal if and at the same time The banquet organizers estimate the of dishes as follows The of a set of dishes is equal to the number of different dishes in it The is the In order to reduce the a taster was invited He will eat grams of food from each dish For each dish the taster determines separately how much fish and how much meat he will eat The only condition is that he will eat exactly grams of the th dish in total Determine how much of what type of food the taster should eat from each dish so that the value of is the minimum possible If there are several correct answers you may output any of them ,Note that dishes can become equal if and only if they have equal values of that is how much fish and meat remain in them in total after tasting Let s calculate this value for each dish and group all the dishes with equal calculated values The minimum amount of fish that can remain in the th dish is in case where the maximum possible mass of fish is eaten Similarly the maximum amount of fish that can remain is in case where the maximum possible mass of meat is eaten Consider one of the groups in which there are all the dishes with equal values We sill assign each dish a corresponding segment on the coordinate line between and This segment specifies all possible values of the remaining mass of fish in the dish any value on it is achievable by replacing eating some mass of fish with the same mass of meat And since is common the same amount of remaining fish will imply the same amount of remaining meat thus equality Let us solve the problem for each group independently Within a group the problem is reduced to choosing as few points as possible that cover all the segments described in the last paragraph that is that there should be a point inside each segment Each selected point will correspond to the resulting dish and it being inside a segment will mean that such a resulting dish can be obtained from the corresponding starting one Such a problem is solved as follows we choose a segment with the minimal right end because it must contain at least one chosen point we ll greedily choose it equal to its right end there s no point in choosing a point to the left from it since it will not cover more segments than the right end of the segment in question we ll mark all segments containing this point as covered and repeat the algorithm for the next unprocessed segment with the minimal right end For this algorithm it is sufficient to sort the segments by their right ends within each group and iterate through the segments greedily selecting points in the manner described above The set of points obtained at the end will be the answer and its size and the information about the point selected within each segment should be printed in the output If for a dish a point is chosen inside its corresponding segment then there should be exactly of fish left in it that is you should output the numbers and in the answer ,Let s code the following process Go one circle across the booths calculate the total cost of sweets bought and the number of sweets bought Now you can decrease you money down to and add to answer It represents that you went maximum number of such circles The later circles will have smaller cost Let s continue this process until becomes smaller than the minimum priced sweet The number of operations made is Let be the amount of money before some operation be the total cost of sweets bought on that operation and is actually smaller than that s how modulo works and smaller than that s also how modulo works And these inequalities imply that That leads to about steps to reach the minimal price Overall complexity 
443,Vitaly enrolled in the course Advanced Useless Algorithms The course consists of tasks Vitaly calculated that he has hours to do the task from the day he enrolled in the course That is the deadline before the th task is hours The array is sorted in ascending order in other words the job numbers correspond to the order in which the assignments are turned in Vitaly does everything conscientiously so he wants to complete task by percent Initially his completion rate for each task is percent Vitaly has training options each option can be used once The th option is characterized by three integers and If Vitaly uses the th option then after hours from the current moment he will increase the progress of the task by percent For example let Vitaly have of tasks to complete Let the array have the form Suppose Vitaly has of options Then if Vitaly prepares in the following way he will be able to complete everything in time Vitaly chooses the th option Then in hour he will complete the st task at percent He still has hours left before the deadline for the st task Vitaly chooses the rd option Then in hours he will complete the nd task in its entirety He has another hour left before the deadline for the st task and hours left before the deadline for the rd task Vitaly chooses the st option Then after hour he will complete the st task for percent which means that he will complete the st task just in time for the deadline Vitaly chooses the th option He will complete the rd task for hours and after another hour Vitaly will complete the rd task in its entirety Thus Vitaly has managed to complete the course completely and on time using the options Help Vitaly print the options for Vitaly to complete the tasks in the correct order Please note each option can be used once If there are several possible answers it is allowed to output any of them ,Note that it is always advantageous for us to complete the task that has an earlier deadline first Only then will we proceed to the next task Then we can solve each problem independently for each exam Then it remains to score percent on the task on the available options This is a typical knapsack problem with an answer recovery ,Let s sort all students by their programming skills but save the initial indices to restore the answer Now we can understand that we don t need to compose the team of size greater than because in this case we can split it into more teams with fewer participants and obtain the same or even less answer Now we can do the standard dynamic programming the minimum total diversity of the division if we divided the first students in sorted order Initially all other values of are Because of the fact above we can do only three transitions indexed The answer is and we can restore it by standard carrying parent values as a parent of the state we can use for example the number of participants in the team 
444,Given an undirected connected graph with vertices and edges The graph contains no loops edges from a vertex to itself and multiple edges i e no more than one edge between each pair of vertices The vertices of the graph are numbered from to Find the number of paths from a vertex to whose length differs from the shortest path from to by no more than It is necessary to consider all suitable paths even if they pass through the same vertex or edge more than once i e they are not simple For example let and and let the graph look like the figure above Then the length of the shortest path from to is Consider all paths whose length is at most The length of the path is Path length is Path length is Path length is There is a total of of matching paths ,Note that in any shortest path we cannot return to the previous vertex Since if the current vertex the previous The current distance the shortest distance to vertex the shortest distance to vertex Then if we return to the vertex the shortest distance from it to is If we add to the current distance we get Thus we get a path at least longer than the shortest one Thus our answer consists of only simple paths If the answer consists only of simple paths then we will simply add vertices to the queue when traversing bfs twice on the first visit and on the next visit when the distance to the vertex is equal to the shortest And we will also count the number of ways to get to that vertex Then we can output the answer as soon as we get to the vertex the second time for processing After that we can terminate the loop The asymptotic will be since we only need bfs ,I think there are some ways to solve this problem with casework but let s try to come up with an intuitive and easy to implement approach It s always possible to move closer to some black vertex no matter in which vertex you are currently and which black vertex was used in the previous operation However sometimes if you try to move along an edge you immediately get forced back Let s analyze when we can move without being forced back We can move along the edge so that our next action is not moving back if either is black there is no next action or if we remove the edge between and the number of black vertices in s component is at least we can use one of them to go from to and another one to continue our path Note that the cases and may be different sometimes it will be possible to move in one direction and impossible to move in the opposite direction Let s treat this possible move as an arc in a directed graph We can find all such arcs if we can answer the queries of the type count black vertices in a subtree of some vertex and this can be done by rooting the tree and calculating this information for each subtree with DFS Now if there is a way from some vertex to some black vertex along these arcs the answer for the vertex is How can we find all such vertices Let s transpose the graph change the direction of each arc to opposite now we need to find all vertices reachable from black ones which is easily done with multisource BFS or DFS The complexity of this solution is 
445,You are given two strings and both of length Each character in both string is or In one move you can perform one of the following actions choose an occurrence of in and replace it with choose an occurrence of in and replace it with You are allowed to perform an arbitrary amount of moves possibly zero Can you change string to make it equal to string ,First check that the counts of all letters are the same in both strings Then consider the following restatement of the moves The letters in the string are stationary Letters and however move around the string The move of the first type moves a letter to the right The move of the second type moves a letter to the left Notice that letters and can never swap with each other Thus if you remove all letters from both strings the remaining strings should be the same Again since letters and can never swap with each other you can deduce where each of these letters should end up after the swaps The first letter a in should be on the position of the first letter in and so on After that we recall that s can only move to the right and s can only move to the left Thus we check that the th occurrence of in is to the left or equal to the th occurrences of in and vice versa for s Finally we can see that this is a sufficient condition Easy to show by construction you can just fix the positions one after another left to right Overall complexity per testcase ,Observation the product of odd numbers is odd so the condition for the length of is automatically completed Denote by the number of ones in binary representation of Let s enumerate the letters of the Latin alphabet from to Observation for each word it is enough to know the set of letters included in it and the evenness of their numbers There are only letters in the alphabet so it is convenient to store the word characteristic as a pair of masks The bit with the number in will be responsible for the availability of the letter in The bit with the number in will be responsible for the evenness of the number of letters in Observation strings creates if and only if Let s fix the number the index of the letter that will not be in Let s throw out all the words with the letter now we can look at the words in turn and look for a pair of them among those already considered It is easy to see that the condition follows from the condition if one letter is banned To count the number of pairs that include our word we need to count the number of words with the characteristic We can do this by bin searching through a sorted array of or using standard data structures We got the solution for 
446,The only king stands on the standard chess board You are given his position in format where is the column from a to h and is the row from 1 to 8 Find the number of moves permitted for the king Check the king s moves here https en wikipedia org wiki King chess ,Easy to see that there are only three cases in this problem If the king is in the corner of the board the answer is If the king is on the border of the board but not in a corner then the answer is Otherwise the answer is ,Suppose the answer is What s the maximum number of chips we can place Firstly the allowed points to place chips are such that We can group them by coordinate for there is only one for possible are for possible are in segment and so on For possible are in The negative s are the same Let s calculate the maximum number of chips we can place at each row for it s for there are three s but since we can t place chips at the neighboring s we can place at most chips for we have places but can place only chips for we have places but can occupy only points In total for we can place at most chips Analogically for we can place at most chips In total we can place at most chips with cost at most Note that can actually be reached since the distance between chips on the different rows is greater than So to solve our task it s enough to find minimum such that that can be done with Binary Search Or we can calculate Note that can lose precision since is cast to before taking the square root for example transforms to when converted to So you should either cast to that consists of bits in some C compilers or check value as a possible answer 
447,You are given an array consisting of integers Your task is to say the number of such positive integers such that divides number from the array In other words you have to find the number of common divisors of all elements in the array For example if the array will be then and divide each number from the array so the answer for this test is ,Let is the greatest common divisor of all elements of the array You can find it by Euclidean algorithm or some standard library functions Then the answer is just the number of divisors of You can find this value in ,The first solution take modulo and solve the problem manually then for cases and the answer is and for and the answer is Prove Let s see what can we make for numbers and We can add and in and add and in Then the difference between sums will be We can consider last four numbers this way until we have at least four numbers And then we have a case We can prove the solution for these four cases using bruteforce The second solution if is even then the answer is otherwise the answer is The formula above is just Prove if we have an integer sequence then we can obtain every number from to as the sum of some elements of this sequence How Greedily You can see how this greedy works and prove if you want yourself So what s next If is even then we can obtain the sum in and in Otherwise we can only obtain in and in or vice versa 
448,Polycarp found under the Christmas tree an array of elements and instructions for playing with it At first choose index starting position in the array Put the chip at the index on the value While add to your score and move the chip positions to the right i e replace with If then Polycarp ends the game For example if and then the following game options are possible Polycarp chooses Game process The score of the game is Polycarp chooses Game process The score of the game is Polycarp chooses Game process The score of the game is Polycarp chooses Game process The score of the game is Polycarp chooses Game process The score of the game is Help Polycarp to find out the maximum score he can get if he chooses the starting index in an optimal way ,Let be the result of the game if we chose as the starting position Let s look at some starting position After making a move from it we will get points and move to the position continuing the same game This means that by choosing the position we can assume that we will get a result more than if we chose the position Formally Let s calculate all the results of and store them in an array Let s start iterating through the positions from the end then being in the position we will know for all Using the formula above we can calculate in one operation It remains only to choose the maximum of all such values ,Let s look at an analogy for this game If Alice takes an even number she adds points to the global result otherwise If Bob takes an odd number he adds points to the global result otherwise Alice wants to maximize the global result and Bob wants to minimize it Obviously this game is completely equivalent to the conditional game Suppose now it s Alice s move Let s look at some number in the array If this number is even then taking it will add points and giving it to Bob will add points If this number is odd then taking it will add points and giving it to Bob will add points So taking the number by points is more profitable than not taking it regardless of the parity To maximize the result Alice should always take the maximum number in the array Similar reasoning can be done for Bob In the task it was necessary to sort the array and simulate the game 
449,An important meeting is to be held and there are exactly people invited At any moment any two people can step back and talk in private The same two people can talk several as many as they want times per meeting Each person has limited The sociability of the th person is a non negative integer This means that after exactly talks this person leaves the meeting and does not talk to anyone else anymore If the th person leaves the meeting immediately after it starts A meeting is considered most if the maximum possible number of talks took place during it You are given an array of sociability determine which people should talk to each other so that the total number of talks is as large as possible ,For the first conversation let s choose two people and with maximal values of sociability Note that after this conversation takes place we move on to a similar problem but in which and are decreased by After decreasing and by we repeat the choice of the two people with the maximum values of sociability Let us repeat such iterations while at least two people with positive sociability parameters remain Let us prove that this solution leads to the optimal answer Let s denote the sum by and consider two fundamentally different cases The maximal element is greater than or equal to the sum of all remaining elements That is there exists such that In this case note that the th person can not possibly have more than conversations because by that point all other people already reached their sociability limits and left the meeting Thus if the answer cannot be more than Note that this estimation is accurate since an example exists in which th person talks to all other people as many times as possible that is times with th person for all And the algorithm described above will just choose the th person as one of the participants of a conversation every time because for every conversation both and decrease by exactly so the inequality holds and it follows that Otherwise we can prove that the maximum number of conversations is always Obviously it is impossible to get more than this number since each conversation requires exactly two units of sociability one from two people while a larger answer would mean that which is obviously wrong Let us prove that this answer is achieved by the described algorithm Let s look at the last conversation held If there are at least two more people left in the meeting after it we can hold another conversation which means there is a more optimal answer If there are zero people left in the meeting then an estimate of of conversations has been achieved And if there is one person with a remaining sociability then an estimate of of conversations has been achieved If there is exactly one remaining person with a sociability residual then we can guarantee that this person has participated in all previous conversations Indeed let s look at the last conversation it was held between two people with the maximum parameters of the remaining sociability But the th person has at least sociability remaining so it couldn t have been the other two people with residuals of who left right after that Thus analyzing all conversations in reverse order we can prove that at any time which means that it is in fact the case considered above We have proven that the described greedy algorithm works This algorithm can be implemented by using any balanced search tree such as By storing pairs of elements in it we could for each time choose the next two people to talk to and update the sociability values The time complexity is ,You need to implement what is written in the statement To quickly check if a word is written by another guy you should store some or Python dictionary and increment every time you see a new string in the input Then you should iterate through each guy find the number of times their word appears and update their score The complexity is per testcase 
450,Since next season are coming you d like to form a team from two or three participants There are candidates the th candidate has rank But you have weird requirements for your teammates if you have rank and have chosen the th and th candidate then and must be met You are very experienced so you can change your rank to any non negative integer but and are tied with your birthdate so they are fixed Now you want to know how many are there pairs such that there exists an integer meeting the following constraints and It s possible that and you form a team of two is the greatest common divisor of two number the least common multiple ,At first must be met since and Now let and From now on let s consider only such that Now let s look at must be met Let Since if then must have to the power of in its factorization otherwise power of can be any non negative integer It leads us to the bitmask of restrictions with size equal to the number of different prime divisors of In the same way let s process Of course and if then must have to the power of in its factorization This is another restriction bitmask So for any pair there exists if and only if Since we look only at where then can t have power of equal to and at the same time For any other it is enough to have power of in equal to the power of in even if it s equal to So for each we need to know the number of such that is a submask of So we just need to calculate sum of submasks for each mask it can be done with or Finally how to factorize number up to Of course Pollard algorithm helps but there is another way which works sometimes Let s factorize with primes up to So after that if there is only three cases or is easy to check helps Otherwise just check with all and if you have found and then and you have found Otherwise you can assume that because this probable mistake doesn t break anything in this task Result complexity is where is the number of prime divisors of ,A lot of different solutions can be written in this problem The model solution relies on the fact that every th integer is divisible by and it means that there is always a way to change the last digit of or leave it unchanged so that the result is divisible by So if is already divisible by we just print it otherwise we change its last digit using some formulas or iteration on its value from to 
451,Luba has a ticket consisting of digits In one move she can choose digit in any position and replace it with arbitrary digit She wants to know the minimum number of digits she needs to replace in order to make the ticket lucky The ticket is considered lucky if the sum of first three digits equals to the sum of last three digits ,Let s iterate over all 6 digit numbers Now we will calculate number of positions in which digit of current ticket differs from digit of input ticket and call it Then answer will be minimal value over all lucky tickets , cannot be transformed into any other number can be transformed into or and can be transformed only into It means that if then only is reachable and if or then should be less than Otherwise we can make as large as we want so if any is reachable 
452,If an integer is divisible by another integer then is called the divisor of For example has positive divisors They are and Let s define a function number of integers between and inclusive which has exactly four positive divisors Between and only the integers and has exactly four positive divisors So You are given an integer You have to calculate ,Easy to see that only the numbers of the form and for different prime have exactly four positive divisors We can easily count the numbers of the form in where is the number from the problem statement Now let and be the number of primes from to Let s iterate over all the values Easy to see that So for fixed we should increase the answer by the value So the task is ot to find the number of primes not exceeding for all Denote the th prime number Denote the number of such that and all prime divisors of are at least note that 1 is counted in all since the set of its prime divisors is empty satisfy a simple recurrence since 2 hence Let be the smallest prime greater than Then by definition the first summand accounts for all the primes not less than If we evaluate the recurrence straightforwardly all the reachable states will be of the form We can also note that if and are both greater than then Thus for each it makes sense to keep only values of Instead of evaluating all DP states straightforwardly we perform a two step process Choose Run recursive evaluation of If we want to compute a state with memorize the query count the numbers not exceeding with all prime divisors at least Answer all the queries off line compute the sieve for numbers up to then sort all numbers by the smallest prime divisor Now all queries can be answered using RSQ structure Store all the answers globally Run recurisive evaluation of yet again If we want to compute a state with then we must have preprocessed a query for this state so take it from the global set of answers The performance of this approach relies heavily on the number of queries we have to preprocess Statement Proof Each state we have to preprocess is obtained by following a transition from some greater state It follows that doesn t exceed the total number of states for The preprocessing of queries can be done in and it is the heaviest part of the computation Choosing optimal we obtain the complexity ,Let be the length of number Then Let then and and we get Note that the right part is divisible by so the left part should as well Then we can see that should be divisible by since Let s say then divide both sides by We get Let s rearrange it and get the following Since is integer then should be integer In other words we can define such that is divisible by and is divisible by and is Since has a very special structure let s iterate over all lengths and all divisors of for a fixed Let s say and Then For a fixed and we know but don t know So let s just iterate over all possible and let s also iterate over all since is small since is a divisor of Next step is following let s look at previous equation but modulo Since then there is a solution to the previous module equation or Now we know exact value and so now the time to guess let s recall that Since we fixed then or Let s name the left border as and right border so inequality earlier is But we can make constrains even tighter note that but lately we said that or So or should be divisible by In total we can iterate in range with since we are interested only in divisible by Now we have enough variables to construct a triple we know and so If is already big we can skip that candidate Also we can calculate and check that pair is valid i e is really minimum possible We can understand it by checking that otherwise we can reduce by Value can be calculated from one of the formulas above as After that we calculate and check that is not too big Value can be calculated as At last we should check that the given triple satisfy all remaining assumptions we made is not too big is really and length of calculated is exactly we fixed If it s all fine then we found a correct triple It looks like thanks to all previous checks the triple we found is unique but just for safety let s push them all in one set to get rid of copies Calculating complexity is not trivial but let s note something the total number of divisors of for all is around For a fixed pair we iterate over all from to and for each we iterate from to but it s easy to prove that the total number of pairs is at most Now the last cycle iteration of with step where If we assume that is quite small then is proportional to and pairs are something like harmonic series with complexity In total the complexity is around 
453,You are given an array and an integer You are asked to divide this array into non empty consecutive subarrays Every element in the array should be included in exactly one subarray Let be the index of subarray the th element belongs to Subarrays are numbered from left to right and from to Let the cost of division be equal to For example if and we divide it into subbarays in the following way then the cost of division is equal to Calculate the maximum cost you can obtain by dividing the array into non empty consecutive subarrays ,Let s denote as just a suffix sum And let be the position where starts the th subarray obviously and Then we can make an interesting transformation So our task is equivalent to choosing sum of all array and different suffix sums And we want to maximize their total sum That s why we can just greedily take maximum suffix sums along with sum of all array ,To solve the problem you can build an array as follows at Let s show that from the constructed array we can get an array equal to the original array If then If then So at If and then If then If then By the construction of the array it is not possible that and So If then If then So We get that for so and array is built correctly 
454,Polycarp wrote on the board a string containing only lowercase Latin letters This string is known for you and given in the input After that he erased some letters from the string and he rewrote the remaining letters in order As a result he got some new string You have to find it with some additional information Suppose that the string has length and the characters are numbered from left to right from to You are given a sequence of integers where is the sum of the distances from the index to all such indices that consider that In other words to calculate Polycarp finds all such indices that the index contains a letter that is later in the alphabet than and sums all the values For example if then since all other indices contain letters which are later in the alphabet that is since only the index contains the letter which is later in the alphabet that is since then there are no indexes such that thus since only the index contains the letter which is later in the alphabet that is Thus if then Given the string and the array find any possible string for which the following two requirements are fulfilled simultaneously is obtained from by erasing some letters possibly zero and then writing the rest in order the array constructed from the string according to the rules above equals to the array specified in the input data ,We will construct the string starting with the largest letters Note that if then the th letter of the string is maximal so we know that the th letter affect all While the string is not completely constructed we will do the following Find all such that and the th character of string is not placed Put on all these positions in the string the maximum letter not used in the string there should be a sufficient number of letters in the string Subtract from all ,The idea is as follows we will go from the end of the string and get the original string Note that if the current digit is then a letter with a two digit number has been encoded Then we take a substring of length three from the end discard and get the number of the original letter Otherwise the current number then a letter with a one digit number was encoded We easily reconstruct the original letter Next discard the already processed characters and repeat the process until the encoded string is complete 
455,You are given a string of length consisting only of the characters and You perform the following operation until the string becomes empty choose some substring of characters erase it from the string and glue the remaining two parts together any of them can be empty in the same order For example if you erase the substring from the string you will get the string When you delete a substring of length you get points Your task is to calculate the maximum number of points that you can score in total if you have to make the given string empty ,Let be the length of the substring deleted at the th step Then the number of points will be equal to or The sum of all is equal to because in the end we deleted the entire string so the final formula has the form Obviously for you should delete the characters one by one so that Now and you have to delete the string in the minimum number of operations Let the string consist of blocks of zeros and ones then is the minimum number of operations for which the entire string can be deleted As long as the number of blocks is more than we will delete the second block the number of blocks will decrease by after each such operation the block that we delete will disappear and the first and third blocks will merge into one ,Firstly notice that there is no difference between space and hyphen you can replace them with the same character if you want Let s run binary search on answer Fix width and greedily construct ad wrap word only if you don t option to continue on the same line Then check if number of lines doesn t exceed Overall complexity 
456,You are given two integers and it is guaranteed that You may choose any integer and subtract it any number of times from Is it possible to make equal to Recall that a number is a positive integer that has exactly two positive divisors and this integer itself The sequence of prime numbers starts with Your program should solve independent test cases ,Let s denote the difference between and as Then if has a prime divisor we can subtract from times The only positive integer that doesn t have any prime divisors is So the answer is if and only if ,Let s notice that there are only beautiful numbers less than Generate them all and select the greatest one which is also divisor of Overall complexity 
457,You have an array consisting of integers Each integer from to appears exactly once in this array For some indices it is possible to swap th element with th for other indices it is not possible You may perform any number of swapping operations any order There is no limit on the number of times you swap th element with th if the position is not forbidden Can you make this array sorted in ascending order performing some sequence of swapping operations ,Take a look at some pair such that and initial It means that all the swaps from to should be allowed Then it s easy to notice that it s enough to check only and as any other pair can be deducted from this You can precalc for each and prefix sums over the string of allowed swaps to check it in no time Overall complexity ,Let s find out how to count the number of binary inversions without flips This is the number of 1 s that appear before a 0 To do this iterate through the array and keep a running total k of the number of 1 s seen so far When we see a 0 increase the total inversion count by k since this 0 makes k inversions one for each of the 1 s before it Now let s see how to maximize the inversions Consider the flip 0 to 1 We claim that it is best to always flip the earliest 0 in the array It s never optimal to flip a later 0 since we have strictly fewer 0 s after it to form inversions Similarly we should flip the latest 1 in the array Now recalculate the answer for these two choices for flipping and pick the maximum The complexity is mathcal O n 
458,Luba thinks about watering her garden The garden can be represented as a segment of length Luba has got buckets the th bucket allows her to water some continuous subsegment of garden of length each hour Luba has to choose of the buckets in order to water the garden as fast as possible as mentioned above each hour she will water some continuous subsegment of length if she chooses the th bucket Help her to determine the minimum number of hours she has to spend watering the garden It is guaranteed that Luba can always choose a bucket so it is possible water the garden See the examples for better understanding ,In this problem we just need to find maximum divisor of that belongs to array Let s call it Then we need to print ,Let s look at the slow solution first which will lead us to the full one Let s iterate over the number from to Given a number we want to find a from to such that is divisible by Since must be divisible by the following conclusion can be drawn must be divisible by Let s denote this number as Now our task is to check if there is a multiple of between and The problem can be solved in many ways you can simply consider the largest multiple of that does not exceed it is equal to We compare this number with and if it matches then we have found a suitable pair Now let s note that we do not need to iterate over all the values of because from the number we are only interested in and this is one of the divisors of Even though the product can be large we can still consider all divisors of this number since and themselves are up to Let s find the divisors of and separately then notice that any divisor of is where is some divisor and is some divisor Let s calculate the running time We need to factorize the numbers and into prime factors this can be done in Next you need to iterate over pairs of divisors and Recall the estimate for the number of divisors of a number https oeis org A066150 the number up to has no more than divisors Therefore we can sort through the pairs for We learned how to find the optimal for We get that for each test case we have learned to solve the problem in 
459,You are standing on the axis at point and you want to move to an integer point You can make several jumps Suppose you re currently at point may be negative and jump for the th time You can either jump to the point or jump to the point What is the minimum number of jumps you need to reach the point ,At first let s jump with while is still greater than the current position Now we finished in some position Note that otherwise we wouldn t make the last step If then we are lucky to finish right in point Otherwise let s look at what happens if we replace one with Basically we ll finish in And since then We know that so if then we can choose the corresponding and replace with and get straight to the point But if then we need one extra operation To calculate fast we can note we need at least since and then we can increase while ,Mouse jumps on a cycle at some point no matter the starting vertex thus it s always the most profitable to set traps on cycles The structure of the graph implies that there are no intersecting cycles Moreover mouse will visit each vertex of the cycle so it s enough to set exactly one trap on each cycle The only thing left is to find the cheapest vertex of each cycle This can be done by a simple dfs Overall complexity 
460, people gathered to hold a jury meeting of the upcoming competition the th member of the jury came up with tasks which they want to share with each other First the jury decides on the order which they will follow while describing the tasks Let that be a permutation of numbers from to an array of size where each integer from to occurs exactly once Then the discussion goes as follows If a jury member has some tasks left to tell then they tell one task to others Otherwise they are skipped If a jury member has some tasks left to tell then they tell one task to others Otherwise they are skipped If a jury member has some tasks left to tell then they tell one task to others Otherwise they are skipped If there are still members with tasks left then the process repeats from the start Otherwise the discussion ends A permutation is nice if none of the jury members tell two or more of their own tasks in a row Count the number of nice permutations The answer may be really large so print it modulo ,Note that if there are at least two members with the maximum value of then any permutation is nice Now let s consider the case when there is only one maximum Let s find out when the permutation is nice Let be the index of the jury member with the maximum number of tasks Then during the th discussion round they will be the only one who will tell their task because the other members of the jury have already told all their tasks So during the th discussion round there should be a jury member who tells a task after the th jury member Let be the number of elements in the array equal to Then if at least one of these jury members goes after the jury member in the permutation then the permutation is nice Using this we will count the number of bad permutations Let s fix the elements in the permutation that are not equal to or there are of them then the number of ways is It remains to place elements so that the maximum is in the last position among them there are such ways The total number of bad permutations is So the answer is ,Let s maintain two data structures a queue with positions of students in order of decreasing their programming skill and a set note that we need exactly set with positions of students not taken in any team To construct the first data structure we need to sort pairs in decreasing order of the first element and after that push second elements in order from left to right The second data structure can be constructed even easier we just need to insert all values from into it Also let s maintain an array where if the th student belongs to the first team and otherwise and the variable to determine whose turn is now initially it is While our set is not empty let s repeat the following algorithm firstly while the head the first element of the queue is not in the set pop it out This is how we determine which student will be taken now Let his position be And don t forget to pop him out too Create the additional dynamic array which will contain all students we will add to the team during this turn Let s find the iterator to the student with the position Then make the following sequence of moves times add the element the current iterator is pointing at to the array then if the current iterator is pointing at the first element break the cycle otherwise go to the iterator pointing at the previous element Then let s find the iterator to the student next to the student with position And then let s make almost the same sequence of moves times if the current iterator is pointing to the end of the set break the cycle otherwise add the element the current iterator is pointing at to the array and advance to the iterator pointing at the next element Then let s remove all values from the array from the set and for each student we delete let s set And change the variable to if it is now and to otherwise Time complexity 
461,In this problem you will have to deal with a very special network The network consists of two parts part and part Each part consists of vertices th vertex of part is denoted as and th vertex of part is denoted as For each index there is a directed edge from vertex to vertex and from to respectively Capacities of these edges are given in the input Also there might be several directed edges going from part to part but never from to You have to calculate the maximum flow value from to in this network Capacities of edges connecting to might sometimes change and you also have to maintain the maximum flow value after these changes Apart from that the network is fixed there are no changes in part no changes of edges going from to and no edge insertions or deletions Take a look at the example and the notes to understand the structure of the network better ,First of all let s calculate minimum cut instead of maximum flow The value of the cut is minimum if we choose the first set of the cut as first vertices of part and first vertices of part That s because if is the minimum index such that then we don t have to add any vertices such that to because that would only increase the value of the cut Similarly if is the maximum index such that then it s optimal to add every vertex such that to Okay so we can try finding minimum cut as a function value of the cut if we choose as the union of first vertices in and first vertices in To find its minimum let s rewrite it as where is the sum of capacities of edges added to the cut in part it doesn t depend on part is the sum of capacities added to the cut from part and is the sum of capacities added to the cut by edges going from to These functions can be denoted this way if otherwise is the capacity of the edge going from to if otherwise is the capacity of the edge going from to is the sum of capacities over all edges such that and Since only the values of are not fixed we can solve this problem with the following algorithm For each find the minimum possible sum of Let s denote this as and let s denote Build a segment tree that allows to get minimum value and modify a single value over the values of When we need to change capacity of an edge we add the difference between new and old capacities to and to calculate the maximum flow we query minimum over the whole tree But how can we calculate the values of We can do it using another segment tree that allows to query minimum on segment and add some value to the segment First of all let s set and build this segment tree over values of The value of is fixed for given so it is not modified the value of is initially since when there are no vertices belonging to in the part And then we calculate the values of one by one When we increase we need to process all edges leading from to part When we process an edge leading to vertex with capacity we have to add to every value of such that since if then and this can be performed by addition on segment in the segment tree After processing each edge leading from to part we can query as the minimum value in the segment tree Time complexity of this solution is ,WLOG assume all queries ask to move from a lower layer to a higher layer The first thing to notice in the problem is that it is always optimal to never go down a layer You have an optimal path that is going down some layers and then returning to the same layer So it leaves a layer in some its cell and returns to it in some other cell or the same one The best distance it can achieve is the Manhattan distance between these two cells However we can also achieve the Manhattan distance by just going along this layer and the answer will be at least as optimal If the query asks about the cells of the same layer just answer with the Manhattan distance Otherwise we can describe the path as follows go from the first cell to some door on its layer enter the door and go to another door on the next layer so on until the layer of the second cell where you go from a door to the second cell Thus we could potentially write the shortest distance from the start to the th door of the th layer Initialize both doors of the first layer take the best answer from the both doors of the last layer That would be per query which is too slow Let s optimize it with some precalculations In particular we want to know the shortest distance between one door of some layer and one door of another layer We can use the technique similar to binary lifting Calculate the distance between a pair of doors on layers which are apart for all up to Let be the distance from door of layer to door of layer can be initialized straightforwardly Then to calculate we can use the values for and for some intermediate door on layer To obtain the answer use jumps to reach the layer one before the last one Then iterate over the last door Alternatively you could pack this dynamic programming into a segment tree use divide and conquer on queries or do square root decomposition Overall complexity 
462,There are cities numbered from to roads connect these cities the th road connects cities and Each road has a direction The directions are given by a string of characters such that each character is either or If the th character is it means that the th road initially goes from the city to the city otherwise it goes from the city to the city A traveler would like to visit as many cities of this country as possible Initially they will choose some city to start their journey from Each day the traveler go from the city where they currently are to a neighboring city using one of the roads and they can go along a road only if it is directed in the same direction they are going i e if a road is directed from city to the city it is possible to travel from to but not from to After the traveler moves to a neighboring city roads change their directions If the traveler cannot go from their current city to a neighboring city their journey ends it is also possible to end the journey whenever the traveler wants to The goal of the traveler is to visit as many different cities as possible they can visit a city multiple times but only the first visit is counted For each city calculate the maximum number of different cities the traveler can visit during if they start in the city ,There are two key observations to this problem after each pair of moves the directions go back to the original ones after each move we can immediately go back and combining these observations we can derive that if we go from city to some other city we can always go back One of the solutions we can write using these observations is to build an undirected graph on vertices Each vertex represents a pair where is the city we are currently staying in and is the number of moves we made modulo Since each move is to a neighboring city each vertex is unreachable from and vice versa And since we can always go back and each pair of steps doesn t change the directions this graph is actually an undirected one So we can find the connected components of this graph using DFS BFS DSU and for each city print the size of the component the vertex belongs to Another solution is to find the leftmost and the rightmost city reachable from each city For example finding the leftmost reachable city can be done with the following dynamic programming let be the leftmost city reachable from Then if we can t go left from if we can make only one step to the left from and if we can make two steps we can take the answer from the city The same approach can be used to calculate the rightmost reachable city ,Since we are only allowed to push the same button times in a row let s do a two pointer sweep to find all segments of consisting of just one button Within each segment we ll sort and take the highest values See the code for details on the two pointer sweep 48994498 
463, Summer vacation has started so Alice and Bob want to play and joy but Their mom doesn t think so She says that they have to read books before all entertainments Alice and Bob will read each book to end this exercise faster There are books in the family library The th book is described by three integers the amount of time Alice and Bob need to spend to read it equals if Alice likes the th book and if not and equals if Bob likes the th book and if not So they need to choose books from the given books in such a way that Alice likes books from the chosen set and Bob likes books from the chosen set the total reading time of these books is they are children and want to play and joy as soon a possible The set they choose is for both Alice an Bob it s shared between them and they read all books so the total reading time is the sum of over all books that are in the chosen set Your task is to help them and find any suitable set of books or determine that it is impossible to find such a set ,A little explanation this editorial will be based on the easy version editorial so I ll use some definitions from it Here we go the most beautiful problem of the contest is waiting us Well the key idea of this problem almost the same with the easy version idea Let s iterate over the number of elements in group we need to take the cheapest ones again If the number of elements we take from group is then we need to take elements from and groups But one more thing let s iterate over not from zero but from the smallest possible number which can give us any correct set of books the numeric value of the answer doesn t matter The value of can be calculated using and sizes of groups by formula or even simple loop If we can t find any suitable value of the answer is Let s call elements from group and elements from and groups we take Other elements of the whole set of books are but Let s create the set which contains all free elements and fill it beforehand So now we took some necessary elements but we need to take some free elements to complete our set Let s create the other set which contains free elements we take to the answer and maintain the variable describing the sum of elements of How do we recalculate Before the start of the first iteration our set is already filled with some elements let s update using them Update is such an operation function that tosses the elements between and It will do the following things repeatedly and stop when it cannot do anything While the size of is greater than needed so we take more than books in total let s remove the most expensive element from and add it to while the size of is less than needed so we take less than books in total let s remove the cheapest element from and add it to while the cheapest element from is cheaper than the most expensive element form let s swap them Note that during updates you need to recalculate as well So we go over all possible values updating before the first iteration and after each iteration The size of both sets changes pretty smooth if we go from to we need to remove at most one element from because we take one element from group during each iteration and we need to add at most two elements to and because we remove at most two elements from and groups during one iteration To restore the answer let s save such a value that the answer is minimum with this value let it be Then let s just run the same simulation once more from the beginning but stop when we reach Then will contain free elements we need to take to the answer describes the number of elements we need to take from group and describes which elements from and groups we need to take Of course there are some really tough technical things like case handling there is a lot of cases for example the size of can be negative at some moment and you need to carefully handle that and can be negative after some number of iterations and there are other cases because of that and so on Time complexity ,At first treat the two subtasks as completely independent problems For both solutions the array of frequences is more convinient to use so let s build it is the number of friends living in house 1 MinimumCollect the answer greedily from left to right If then proceed to otherwise add to the answer and proceed to To prove that let s maximize the number of merges of houses instead of minimizing the actual count of them It s easy to show that the final number of houses is the initial one minus the number of merges So if there are people in all consecutive houses starting from then merges is the absolute best you can do with them skipping any of the merges won t get the better answer For only of them occupied merge is the best and we can achieve that merge And a single occupied house obviously will do merges 2 MaximumAlso greedy but let s process the houses in segments of consecutive positions with positive Take a look at the sum of some segment of houses If the sum is greater than the length then you can enlarge that segment house to the left or to the right If the sum is greater by at least than you can enlarge it both directions at the same time Thus the following greedy will work Let s update the segments from left to right For each segments check the distance to the previous one if it was enlarged to the right then consider the new right border If you can enlarge the current segment and there is space on the left then enlarge it And if you still have possibility to enlarge the segment then enlarge it to the right Notice that it doesn t matter which of any pair of consecutive segments will take the spot between them as the answer changes the same The initial segments can be obtained with two pointers Overall complexity 
464,You are given a simple connected undirected graph consisting of vertices and edges The vertices are numbered from to A vertex cover of a graph is a set of vertices such that each edge has at least one of its endpoints in the set Let s call a vertex cover such a vertex cover that edge in it has both endpoints in the set Find a vertex cover of a graph or report that there is none If there are multiple answers then print any of them ,Let s think about why we can t always make a perfect vertex cover such a vertex cover that each edge has exactly one endpoint in it Or why the answer can not exist at all Consider a bamboo It s always possible to find a perfect vertex cover Just choose every other vertex in it and account for parity Make a bamboo into a loop Now you can see that an even length loop has a perfect vertex cover An odd length doesn t That tells us that each odd length loop in a graph will have a bad edge on it Odd length loops should instantly make you think about bipartite colorings So we can see that a bipartite graph always has a perfect vertex cover Just choose one of the parts into a cover and each edge will have exactly one endpoint in it At the same time a non bipartite graph never has a perfect cover So our general goal is to remove basically mark as bad at most one edge in such a way that the remaining graph is bipartite Consider a dfs tree of the graph colored bipartitely Every edge in the tree is good has endpoints in different parts Every edge outside the tree can be either good or bad What happens to the tree if we remove an edge If we remove an edge outside the dfs tree then nothing happens to it So if there is no more than one bad edge outside the tree then we found the answer That was the easy part Now what happens if we remove an edge from the tree The back edges from the subtree of the edge can force the subtree to either remain colored the same or flip all its colors We don t really care if it remains the same because we already took care of it in the first part So let s pretend it always flips the colors Thus all edges that go from the subtree upwards above the removed edge have only one of their endpoints colors changed Good edges turn bad bad edges turn good All other edges don t change So you should choose such an edge to remove that all bad edges in the graph go from its subtree upwards above that edge and no good edges go from its subtree upwards above that edge That can be calculated with a dfs Since all non tree edges in the dfs tree are back edges you can simply increment a counter on the bottom vertex decrement the counter on the top vertex and collect sums from the bottom The sum in the vertex will tell you the number of edges that start below or in the vertex and end above the vertex Do this for both kinds of edge and check the conditions for all vertices Finally choose such a part to be a vertex cover that the removed edge has both ends in it if you choose the other part that edge won t be covered at all The solution is linear but the problem still requires a massive time and memory limit only because of recursion in the dfs Overall complexity per testcase ,Firstly let s run bfs on the given graph and calculate distances for all vertices In fact we don t need distances we need their parities The second part is to find all vertices with an even distance all vertices with and odd distance and print the smallest by size part Why is it always true Firstly it is obvious that at least one of these sizes will not exceed And secondly because we are checking just parities of distances it is obvious that each vertex of some parity is connected with at least one vertex of the opposite parity because it has this parity from some vertex of the opposite parity 
465,Given an array of elements print any value that appears at least three times or print if there is no such value ,Approach 1 Sort the array using an efficient sorting algorithm For every element check if the next two in the array are equal to it If you find such an element output it Time complexity is Approach 2 Notice that elements have an upper bound of you can use an auxiliary array to store the count of each value Go through each value and see if its count is bigger than or equal to Time complexity is ,Let s read the book greedily On th day Luba will read for seconds Subtract value for each day from until becomes less or equal to zero That will be the day Luba finishes the book Overall complexity 
466,Johnny is playing a well known computer game The game are in some country where the player can freely travel pass quests and gain an experience In that country there are islands and bridges between them so you can travel from any island to any other In the middle of some bridges are lying ancient powerful artifacts Johnny is not interested in artifacts but he can get some money by selling some artifact At the start Johnny is in the island and the artifact dealer is in the island possibly they are on the same island Johnny wants to find some artifact come to the dealer and sell it The only difficulty is that bridges are too old and destroying right after passing over them Johnnie s character can t swim fly and teleport so the problem became too difficult Note that Johnny can t pass the half of the bridge collect the artifact and return to the same island Determine if Johnny can find some artifact and sell it ,Edge biconnected component in an undirected graph is a maximal by inclusion set of vertices so that there are two edge disjoint paths between any pair of vertices Consider the graph with biconnected components as vertices Easy to see that it s a tree if it contains some cycle then the whole cycle is a biconnected component All edges are destroying when we passing over them so we can t returnto the same vertex in the tree after leaving it by some edge Consider the biconncted components that contains the vertices and Let s denote them and Statement the answer is YES if and only if on the path in the tree from the vertex to the vertex there are an edge with an artifact or there are a biconnected component that contains some edge with an artifact Easy to see that the statement is true if there are such edge then we can pass over it in the tree on the path from to or we can pass over it in biconnected component The converse also easy to check Here is one of the ways to find edge biconnected components Let s orient all edges to direction that depth first search passed it for the first time Let s find in new directed graph strongly connected components Statement the strongly connected components in the new graph coincide with the biconnected components in old undirected graph Also you can notice that the edges in tree is the bridges of the graph bridges in terms of graph theory So you can simply find the edges in the graph ,Firstly let s run bfs on the given graph and calculate distances for all vertices In fact we don t need distances we need their parities The second part is to find all vertices with an even distance all vertices with and odd distance and print the smallest by size part Why is it always true Firstly it is obvious that at least one of these sizes will not exceed And secondly because we are checking just parities of distances it is obvious that each vertex of some parity is connected with at least one vertex of the opposite parity because it has this parity from some vertex of the opposite parity 
467,A permutation of length is a sequence of integers from to of length containing each number exactly once For example are permutations and are not There was a permutation It was merged with itself In other words let s take two instances of and insert elements of the second into the first maintaining relative order of elements The result is a sequence of the length For example if some possible results are The following sequences are not possible results of a merging For example if the possible results are The following sequences are not possible results of a merging Your task is to restore the permutation by the given resulting sequence It is guaranteed that the answer You have to answer independent test cases ,The solution is pretty simple it s obvious that the first element of a is the first element of the permutation p Let s take it to p remove it and its its copy from a So we just have the smaller problem and can solve it in the same way It can be implemented as go from left to right if the current element isn t used take it and mark it s used ,For each index we will find the number of pairs before swapping such that is the first occurence of in the chosen segment Let be previous occurence of before if is the first occurence then if we suppose the array to be indexed Let s find the number of pairs such that and then multiply it by and subtract for this index has to be in segment and has to be in segment so the number of ways to choose this pair is The value we receive as the sum of these values over all segments is the total number of distinct elements over all pairs so we need to divide it by the number of these pairs 
468,You are given a binary array of length You are allowed to perform one operation on it In an operation you can choose any element and flip it turn a into a or vice versa What is the maximum number of inversions the array can have after performing operation A binary array is an array that contains only zeroes and ones The number of inversions in an array is the number of pairs of indices such that and ,Let s find out how to count the number of binary inversions without flips This is the number of 1 s that appear before a 0 To do this iterate through the array and keep a running total k of the number of 1 s seen so far When we see a 0 increase the total inversion count by k since this 0 makes k inversions one for each of the 1 s before it Now let s see how to maximize the inversions Consider the flip 0 to 1 We claim that it is best to always flip the earliest 0 in the array It s never optimal to flip a later 0 since we have strictly fewer 0 s after it to form inversions Similarly we should flip the latest 1 in the array Now recalculate the answer for these two choices for flipping and pick the maximum The complexity is mathcal O n ,Since a sequence of swaps denotes some permutation let s try to restore the permutation that was used to transform into and then get by applying inverse permutation If was or less then we could get just by asking one query send a string where no character occurs twice and the resulting positions of characters uniquely determine the permutation Unfortunately may be greater than but we can ask more than one query The main idea is the following for each index we may choose a triple of characters so all triples are distinct There are different triples and that s greater than so each index can be uniquely determined Then after we choose a triple for each index ask three queries as follows in the first query the th character of the string is the first character in the triple representing index in the second query we use the second characters from all triples and in the third query the third characters Let and be the strings we sent and and be the strings we received as answers The permutation maps index to index if and only if and because if some other index is mapped to then at least one of the aforementioned equalities is false since all triples of characters are distinct Using this fact we may recover the permutation 
469,There are cities situated along the main road of Berland Cities are represented by their coordinates integer numbers All coordinates are pairwise distinct It is possible to get from one city to another only by bus But all buses and roads are very old so the Minister of Transport decided to build a new bus route The Minister doesn t want to spend large amounts of money he wants to choose two cities in such a way that the distance between them is minimal possible The distance between two cities is equal to the absolute value of the difference between their coordinates It is possible that there are multiple pairs of cities with minimal possible distance so the Minister wants to know the quantity of such pairs Your task is to write a program that will calculate the minimal possible distance between two pairs of cities and the quantity of pairs which have this distance ,At first let s notice that if there exists such triple and that then and Thus we can sort all numbers and check only adjacent ones There are exactly of such pairs The only thing left is to find minimal distance of all pairs and count pairs with that distance Overall complexity ,There is one important observation Thus you can obtain at least pair by choosing as the minimum number in the sequence and as anything else for any positive Overall complexity per testcase 
470,Mishka got an integer array of length as a birthday present what a surprise Mishka doesn t like this present and wants to change it somehow He has invented an algorithm and called it Mishka s Adjacent Replacements Algorithm This algorithm can be represented as a sequence of steps Replace each occurrence of in the array with Replace each occurrence of in the array with Replace each occurrence of in the array with Replace each occurrence of in the array with Replace each occurrence of in the array with Replace each occurrence of in the array with Replace each occurrence of in the array with Replace each occurrence of in the array with Note that the dots in the middle of this algorithm mean that Mishka applies these replacements for each pair of adjacent integers for each as described above For example for the array the following sequence of arrays represents the algorithm replace all occurrences of with replace all occurrences of with replace all occurrences of with replace all occurrences of with replace all occurrences of with replace all occurrences of with replace all occurrences of with The later steps of the algorithm do not change the array Mishka is very lazy and he doesn t want to apply these changes by himself But he is very interested in their result Help him find it ,It is easy to see that for the odd elements there is no changes after applying the algorithm described in the problem statement and for the even elements there is only one change each of the even elements will be decreased by So we can iterate over all the elements of the array and print where is taking modulo Overall complexity is ,What is the sum of all the elements in b This is twice the sum of all the elements in a x Denote by B the sum of all the elements of b Let s iterate over which of the array elements was added as the sum of the elements a let s denote for a Then x B 2 cdot A It remains to check that the element x is present in the array b this can be done using a hash table or a binary search tree 
471,You are given a simple undirected graph with vertices is even You are going to write a letter on each vertex Each letter should be one of the first letters of the Latin alphabet A path in the graph is called Hamiltonian if it visits each vertex exactly once A string is called palindromic if it reads the same from left to right and from right to left A path in the graph is called palindromic if the letters on the vertices in it spell a palindromic string without changing the order A string of length is good if each letter is one of the first lowercase Latin letters if you write the th letter of the string on the th vertex of the graph there will exist a palindromic Hamiltonian path in the graph Note that the path doesn t necesserily go through the vertices in order Count the number of good strings ,Let s start with making some implications from the low constraints What s the upper estimate on the number of answers Too high let s think of a better one Using some combinatorics we can normalize the answers in such a way that there are at most th Bell s number of them The method basically defines the components of equal letters Given a string we write down the letters in it in the order they appear for the first time in the string and rename the first of them to the second one to and so on Only possible answers already Hmm but we should also have an even amount of each letter That is the absolute lowest estimate and it s equal to about What does it exactly mean for a string to be good There exists a path such that there s a pair of equal letters that occupy the st and the th vertex in the path a pair on the nd and th and so on So for each of possible answers we want to determine if there s a way to split the groups of equal letters into pairs of equal letters such that there exists a path through these pairs Such a path would mean building a palindrome from inside out A quick estimation on a number of splittings into pairs The first letter can be matched against other letters the first among the unmatched ones against other letters and so on Thus it s equal to For each splitting into pairs we can determine if there exists a path That is a straightforward dynamic programming similar to a usual hamiltonian path search It stores a mask of visited and the last visited pair For a transition you want to either go from the first vertex of one pair to the first vertex of another one and from the second to the second or the other way around That would take for each splitting The only thing left is to propagate the results from the splitting into pairs to splitting into even sized components of equal letters A splitting into pairs is a splitting into components of size Let that be a base case for the dp For every splitting into components find a component of size at least we still have to split it into pairs and separate it into a component of size a pair and the rest of the component Moreover a pair can always be chosen in such a way that one of its elements is the first element of the component So there are states and at most transitions from each of them Maybe there s a more convenient way to store the states but the one I found to be fast enough is hashing the state into a base integer since there are no more than components numbered through and storing it in a map hashmap ,Let s understand what MEX correct sequences look like It turns out there are only two types and For example the sequences and the empty sequence are MEX correct sequences of the first type and and of the second one Let s calculate the dynamic programming the number of MEX correct subsequences of the first type on the prefix of length with equal to and similarly the number of MEX correct subsequences of the second type on the prefix of length with equal to Let s look at the transitions in these dps and show that there are no other MEX correct sequences at the same time Let the current state be and we are trying to add an element equal to if then such an element cannot be added if then the value of will not change and the sequence is still of the first type which means we have a transition to if then the value of will increase by but it will still be of the first type which means we have a transition to if then the value of will not change but the sequence will become of the second type which means we have a transition to if then such an element cannot be added Let the current state be and we are trying to add an element equal to if then such an element cannot be added if then the value of will not change and the sequence is still of the second type which means we have a transition to if then such an element cannot be added because will increase by which means the absolute difference between and is greater than if then the value of will not change and the sequence is still of the second type which means we have a transition to if then such an element cannot be added Thus we considered all possible transitions adding a new element to the already MEX correct sequences and made sure that there are only two types While the solution itself works in time because each element has possible transitions in the dps it uses memory which does not allow us to write that solution as is However note that and similarly for differ in only a few positions in those that the element allowed us to make which means we can store only one dimensional arrays and Thus the final complexity of the solution is 
472,According to rules of the Berland fashion a jacket should be fastened by but not necessarily it should be the last one Also if the jacket has only one button it should be fastened so the jacket will not swinging open You are given a jacket with buttons Determine if it is fastened in a right way ,In this problem you should simply check the conditions from the problem statement ,Firstly you should find the minimum value in each row and after that you should find the maximum value over that minimums It s corresponding to the strategy of Jack and Emma 
473,You are given segments Each segment has one of two colors the th segment s color is Let s call a pair of segments and if the following two conditions are met the segments and intersect embed or touch i e there exists an integer such that and Calculate the maximum number of segments that can be selected from the given ones so that there is no pair among the selected ones ,There are two approaches to this problem Most of the participants of the round got AC by implementing dynamic programming with data structures such as segment tree but I will describe another solution which is much easier to code Let s consider a graph where each vertex represents a segment and two vertices are connected by an edge if the corresponding segments compose a bad pair Since each bad pair is formed by two segments of different colors the graph is bipartite The problem asks us to find the maximum independent set and in bipartite graphs the size of the independent set is equal to where is the number of vertices and is the size of the maximum matching The only thing that s left is finding the maximum matching Let s use event processing approach to do it for each segment create two events the segment begins and the segment ends While processing the events maintain the currently existing segments in two sets grouped by their colors and sorted by the time they end When a segment ends let s try to match it with some segment of the opposite color and it s quite obvious that we should choose a segment with the minimum to form a pair Overall this solution runs in ,Let s use dynamic programming to solve this problem We will start with a single biconnected component consisting of vertex and connect other vertices to it So the state of our dynamic programming will be a of vertices that are in the same biconnected component with How can we extend a biconnected component in such a way that some other vertices are added into it but it is still biconnected We will add a path possibly cyclic that starts in some vertex belonging to the goes through some vertices and ends in some vertex belonging to the possibly If for every triple we precalculate some path that starts in goes through vertices from and ends in and does not contain neither nor then we can solve the problem in there will be states for every state we will iterate on two vertices and belonging to the and the number of possible pairs of non intersecting masks and is The only thing that s left is precalculating the paths for triples That can be done with auxiliary dynamic programming which will denote whether such a path exists For every edge of the original graph is true and we can go from to some state where will contain all vertices from and vertex and we should ensure that there is an edge in the graph and the didn t contain vertex earlier We should also somehow be able to restore the paths from this dp and we also should be careful not to choose the same edge twice for example if we start a path by edge we should not use the same edge to return to both these things can be done for example by storing next to last vertex in the path 
474,Let be the minimum positive integer that is divisible by both and For example You are given two integers and Find two integers and such that and ,Suppose we have chosen and as the answer and is not a divisor of Since belongs to we could have chosen and instead So if the answer exists there also exists an answer where is a divisor of If then there is no pair such that and Otherwise and is the answer ,The number is divisible by the number if and only if modulo To solve this problem let s use the concept of dynamic programming There will be four states the number of considered digits of the number the number of such considered digits that we have colored red the remainder from dividing the red number by and the black one by The value corresponding to the state will be described by three parameters the possibility of a situation described by the states the color of the last digit and the parent state Let s assume that the number that contains digits is equal to Initially let s mark the state in which digits are considered of which are red digits and both remainders are equal to as possible Next let s iterate over all states in the following order first by the number of considered digits then by the number of considered red digits then by the remainder of the division by and by From the current state if it is possible i e the corresponding mark is set you can make two transitions to new states At the first transition we paint the last digit in red at the second one in black We need also to store the current state in the new states as the previous one A solution exists if and only if some state in which exactly digits are considered of which at least and at most red digits and the remainders are equal to is marked as possible Let s find such a state Using the stored information about the color of the last digit and the previous state we can restore the colors of all digits of the number 
475,Let s call an array by value in the next situation At first array should have at least elements Now let s calculate number of occurrences of each number in and define it as Then is dominated by if and only if for any other number For example arrays and are dominated by and respectevitely but arrays and are not Small remark since any array can be dominated only by one number we can not specify this number and just say that array is either dominated or not You are given array Calculate its shortest dominated subarray or say that there are no such subarrays The subarray of is a contiguous part of the array i e the array for some ,At first let s prove that the shortest dominated subarray has pattern like with and dominated by value Otherwise we can decrease its length by erasing an element from one of its ends which isn t equal to and it d still be dominated Now we should go over all pairs of the same numbers and check its subarrays Or not Let s look closely at the pattern if and all are pairwise distinct then the pattern is dominated subarray itself Otherwise we can find in our pattern other shorter pattern and either the found pattern is dominated or it has the pattern inside it and so on What does it mean It means that the answer is just the shortest pattern we can find And all we need to find is the shortest subarray with the same first and last elements or just distance between two consecutive occurrences of each number We can do it by iterating over current position and keeping track of the last occurrence of each number in some array Then the current distance is The total complexity is ,Let be the answer for our problem if the last element of our subsequence equals to Then we have an easy solution let s store as a C or Java Initially for each Then let s iterate over all in order of input and try to update with a Then the maximum element of will be our answer Let it be Then let s find any such that Let it be Then for restoring the answer we need to iterate over all elements of our array in reverse order and if the current element then push to the array of positions of our subsequence and make 
476,Luca has a cypher made up of a sequence of wheels each with a digit written on it On the th wheel he made moves Each move is one of two types move denoted by it increases the th digit by After applying the up move on it becomes move denoted by it decreases the th digit by After applying the down move on it becomes Luca knows the final sequence of wheels and the moves for each wheel Help him find the original sequence and crack the cypher ,We will perform each move in reverse from the final sequence of the cypher move it increases the th digit by After applying the up move on it becomes move denoted by it decreases the th digit by After applying the down move on it becomes Now we just need to implement the two types of moves The time complexity is per test case ,Let s iterate on the number of indices such that Obviously How to count the number of permutations with fixed First of all we need to choose the indices that have the property there are ways to do this Secondly we need to construct a permutation for chosen indices such that for every chosen index permutations with this property are called and the number of derangements of fixed size can be calculated using exhaustive search since So the answer is where is the number of derangements of size 
477,There are fishermen who have just returned from a fishing trip The th fisherman has caught a fish of size The fishermen will choose some order in which they are going to tell the size of the fish they caught the order is just a permutation of size However they are not entirely honest and they may increase the size of the fish they have caught Formally suppose the chosen order of the fishermen is Let be the value which the th fisherman in the order will tell to the other fishermen The values are chosen as follows the first fisherman in the order just honestly tells the actual size of the fish he has caught so every other fisherman wants to tell a value that is than the value told by the previous fisherman and is divisible by the size of the fish that the fisherman has caught So for is the smallest integer that is both than and For example let If the chosen order is then is the smallest integer divisible by and greater than which is is the smallest integer divisible by and greater than which is is the smallest integer divisible by and greater than which is is the smallest integer divisible by and greater than which is is the smallest integer divisible by and greater than which is is the smallest integer divisible by and greater than which is You have to choose the order of fishermen in a way that yields the minimum possible ,Suppose we have fixed some order of fishermen and calculated the values of Then we have the following constraints on all values of are pairwise distinct for every divides Not every possible array meeting these constraints can be achieved with some order of fishermen but we can show that if we choose an array with the among the arrays meeting these two constraints there exists an ordering of fishermen which yields this array The proof is simple suppose the ordering of fishermen is the following one the first fisherman is the one with minimum the second one the one with the second minimum and so on It s obvious that if we generate the values of according to this order they won t be greater than the values in the array we have chosen And if some value is less than the value in the chosen array it means that we haven t chosen the array with the minimum possible sum So we can rephrase the problem as the following one for each choose the value of so that it is divisible by all are distinct and their sum is minimized Using the pigeonhole principle we can show that for every we need to consider only the values of among So we can formulate the problem as an instance of the weighted bipartite matching build a graph with two parts where the left part contains nodes representing the values of the right part represents the values of the form where and there exists an edge between a vertex in the left part representing the number and a vertex in the right part representing the number with cost if and only if for some integer Okay now we need to solve this weighted matching problem but how The number of vertices is and the number of edges is as well so mincost flow will run in or which is too much Instead we can notice that the cost of the edges incident to the same vertex in the right part is the same so we can swap the parts of the graph sort the vertices of the new left part representing the numbers according to their costs and run the classical Kuhn s algorithm in sorted order Kuhn s algorithm in its original implementation will always match a vertex if it is possible so it obtains the minimum total cost for the matching if we do it in sorted order But this is still What should we do Well there are some implementations of Kuhn s algorithm which can run on graphs of size about sometimes even Why can t we use one of these Unfortunately For example greedy initialization of matching won t work So we need to choose optimizations carefully The model solution uses the following optimization of Kuhn s algorithm With this optimization Kuhn s algorithm works in where is the size of the maximum matching is the number of edges and is the number of vertices So this results in a solution with complexity of I think it s possible to show that some other optimizations of Kuhn can also work but the one I described is enough ,Number of chocolate bars Vasya can buy without offer is Number of bundles with bars Then number of additional bars In result total number of bars is 
478,You are given two strings and both consisting of exactly lowercase Latin letters is lexicographically less than Let s consider list of all strings consisting of exactly lowercase Latin letters lexicographically not less than and not greater than including and in lexicographical order For example for and the list will be Your task is to print the median the middle element of this list For the example above this will be ,This problem supposed to be Let s represent our strings as huge numbers with base Let be and be So if we will see more precisely in the problem statement then we can see that the answer is The operation with long numbers can be done in and division long number by two also can be done in All details of implementation are in the author s solution ,Presume that we want to calculate the number of blocks of length Let s divide this blocks into two types blocks which first element is a first element of integer or blocks which last element is a last element of integer for example blocks and in integer other blocks At first let s calculate the number of blocks of first type We can choose positions of this block at the start of end of the integer Now we can choose digit for this block After that we can chose digits of adjacent block if these blocks contain the same digit then we length of blocks which we want calculate greater than so we have only variations of digit in adjacent block Finally the can chose the remaining digit ways So the total number of block of first type is Now let s calculate the number of blocks of second type We can choose positions of this block all position except the start and end of integer Now we can choose 10 digit for this block After that we can chose digits of adjacent block for block to the left and for block to the right Finally the can chose the remaining digit ways So the total number of block of second type is That s almost all We have one corner case If then we number of blocks is always 
479,You are given two integer numbers and You may perform several operations with the integer Each operation you perform is the following one choose any digit that occurs in the decimal representation of at least once and replace by You want to make the length of decimal representation of without leading zeroes equal to What is the minimum number of operations required to do that ,One of the possible approaches to this problem is to try multiplying only by the largest digit in it Unfortunately this doesn t work quite well since it gives WA on one of the examples That example is too big to consider but a smaller version of it can prove that this is an incorrect solution let If we multiply by we get and there s no way to obtain a number with digits using the next action But if we multiply by we get which can then be multiplied by to obtain a digit number So considering only the largest digit is not enough This implies that we somehow need to consider the options that are not optimal locally but optimal globally i e choose a lower digit right now to obtain a higher digit in the future Let s try to estimate the number of possible integers that can be obtained using these operations to see if we can consider all possible options The key observation is that each integer we obtain will have the form since only one digit primes can be added to the factorization Since we consider only numbers less than is not greater than is not greater than is not greater than and is not greater than and the number of reachable integers is about million note that this is a very generous bound since not all combinations of yield an integer less than and not all such integers can be reached with the operations This allows us to use BFS or dynamic programming to calculate the answer ,Let s consider the following string If digit occurs times in it then string have subsequences Let s increase the number of digits in this string while condition holds is the number of digits in this string The length of this string will not exceed because The value will not exceed as well All we have to do is increase the number of subsequences in the current string by So if we add digits after the first two digits we increase the number of subsequences by The string will look like this where sequence consists of exactly digits and sequence consists of exactly digits 
480,Alice and Bob play ping pong with simplified rules During the game the player serving the ball commences a play The server strikes the ball then the receiver makes a return by hitting the ball back Thereafter the server and receiver must alternately make a return until one of them doesn t make a return The one who doesn t make a return loses this play The winner of the play commences the next play Alice starts the first play Alice has stamina and Bob has To hit the ball while serving or returning each player spends stamina so if they don t have any stamina they can t return the ball and lose the play or can t serve the ball in this case the other player serves the ball instead If both players run out of stamina the game is over Sometimes it s strategically optimal not to return the ball lose the current play but save the stamina On the contrary when the server commences a play they have to hit the ball if they have some stamina left Both Alice and Bob play optimally and want to firstly maximize their number of wins and secondly minimize the number of wins of their opponent Calculate the resulting number of Alice s and Bob s wins ,Let s find an answer for a little different version of the game Let s say that is the final score if the first player has stamina and the second has stamina The first player can either hit the ball or How to calculate Obviously and Otherwise the first player can either hit the ball then the player spent stamina and now it s to the second player to decide hit or lose So basically we moved to the state and the answer in this case is where or lose the play then the player doesn t spend any stamina but the opponent serve the ball He serves the ball spend stamina and return to the state where the first player decides hit or lose Formally the answer in this case is Looking at and one of transitions we can guess that and prove it by induction is either or but and and is better than so The final step is to note that since Alice starts the first play and serve ball the answer is ,At first let s transform input to a more convenient form We consider only such subsegments that consist of the symbols and which cannot be expanded to the right or left For example for we consider segments of length and Let s divide all such segments into four groups by their length In such a division each segment belongs to exactly one type Suppose that the Bob takes the first turn If there is a segment of second type then Bob wins because he always have a spare turn that Alice cannot make If there is a segment of fourth type then the Bob also wins because he can make the segment of second type by taking turn in this segment of four type If there are no segments of second and four types then victory depends on the parity of the number of segments of the third type But it is true if the Bob takes first turn If Alice takes first turn then she doesn t want after her move there are segments of the second and fourth types So if initially there is a segment of second type then Alice loses because she can t take turns into segment of second type If there are two or more segments of four type then Alice also loses because after her turn at least one such segments remains If there are only one segment of four type then Alice have to take turn into this segment Since the length of this segment doesn t exceed we can iterate over all possible Alice moves After Alice s move segment of fourth type can be divided into no more than two new segments let s denote their types as and If at least one of these segments of second or fourth type then it s bad turn for Alice Otherwise Alice win if remaining number of segment of third type is even note that or also can be the third type And finally if initially there are only segments of first or third type then victory depends on the parity of the number of segments of the third type 
481,Let s define the of a string as the number of index pairs and such that and You are given two positive integers and Among all strings with length that contain only the first characters of the Latin alphabet find a string with minimum possible If there are multiple such strings with minimum find any of them ,Consider all possible strings of length on the alphabet of size there are of them Let be the number of occurrences of the th of them in the string The cost of the string by definition is Now let s suppose there are two strings and such that Then if we somehow reduce the number of occurrences of the string by and increase the number of occurrences of the string by the cost will decrease So in the optimal answer all the strings of length should appear the same number of times and if it s impossible the difference in the number of appearances should not be greater than Let s suppose that then our goal is to build a string where each string of length on the alphabet of characters appears exactly once The construction of this string can be modeled using Eulerian cycles build a directed graph with vertices where each vertex represents a character each arc represents a string of length and for every pair of vertices there is an arc from to it s possible that Then by finding the Eulerian cycle in this graph it always exists since the graph is strongly connected and for each vertex its in degree is equal to its out degree we find a string of length such that all its substrings are different so each string of length appears there once as a substring Okay what about the cases and Since the string we build for the case represents a cycle we can make it cyclical and repeat the required number of times then cut last several characters if it s too big For example if then the string for is it s not the only one but we can use it We can expand this string to by repeating the last characters and delete the last character so its length is By the way in this problem you don t have to implement the algorithm that finds Eulerian cycles The graph where we want to find the Eulerian cycle has a very special structure and there are many different constructive ways to find the cycle in it But if you can t use them you always can rely on the straightforward solution that explicitly searches for the Eulerian cycle ,Greedy idea To minimize the string we will go from left to right and maintain a variable maximal character from which we will reduce everything to a Initially it is a and we spend of operations on it Then at the next symbol we can either reduce it to a in no more than operations or reduce to a the prefix we have already passed and minimize the next character in the remaining operations 
482,You are responsible for installing a gas pipeline along a road Let s consider the road for simplicity as a segment on axis The road can have several crossroads but for simplicity we ll denote each crossroad as an interval with integer So we can represent the road as a binary string consisting of characters where character means that current interval doesn t contain a crossroad and means that there is a crossroad Usually we can install the pipeline along the road on height of unit with supporting pillars in each integer point so if we are responsible for road we must install pillars But on crossroads we should lift the pipeline up to the height so the pipeline won t obstruct the way for cars We can do so inserting several zig zag like lines Each zig zag can be represented as a segment with integer consisting of three parts units of horizontal pipe unit of vertical pipe of horizontal Note that if pipeline is currently on height the pillars that support it should also have length equal to units Each unit of gas pipeline costs us bourles and each unit of pillar bourles So it s not always optimal to make the whole pipeline on the height Find the shape of the pipeline with minimum possible cost and calculate that cost Note that you start and finish the pipeline on height and also it s guaranteed that the first and last characters of the input string are equal to ,This task was designed as a simple dynamic programming problem but it also can be solved greedily The dp solution is following when we have already built some prefix of the pipeline all we need to know is the length of the prefix the height of the pipeline s endpoint or So we can calculate the following dynamic programming is the minimal answer for prefix of length with pipeline at height Transitions are quite straightforward if then we can either leave the pipeline on the same level or change it If then we have to stay on the height Look at the source code for the formal transitions The answer is The greedy solution is based on the following fact let s look at some subsegment consisting of s It s always optimal either to leave this subsegment on height or raise it to height We can calculate the amount we have to pay in both cases and choose the optimal one ,The constraits are set in such a way that naive solution won t pass unmark every edge one by one and check if graph of marked edges doesn t contain cycles with dfs bfs Thus we should somehow limit the number of edges to check Let s take arbitrary cycle in graph Do dfs store the vertex you used to travel to any other vertex and restore edges with this data if cycle is met With this algo length of cycle will not exceed Then do the naive algo but check only edges from this cycle Overall complexity 
483,Emily s birthday is next week and Jack has decided to buy a present for her He knows she loves books so he goes to the local bookshop where there are books on sale from one of genres In the bookshop Jack decides to buy Based on the genre of books on sale in the shop find the number of options available to Jack for choosing two books of different genres for Emily Options are considered different if they differ in at least one book The books are given by indices of their genres The genres are numbered from to ,Let s denote cnti the number of books of i th genre The answer to problem is equals to In first sum we are calculating the number of good pairs while in second we are subtracting the number of bad pairs from the number of all pairs Complexity O n m2 or O n m ,For each index let s try to find which we should use in order to make th element of equal to zero If then no matter which we choose So we should just ignore this index and add to the answer if Otherwise we should choose Let s calculate the required fraction for each index and among all fractions find one that fits most indices this can be done for example by storing all fractions in a The only thing that s left to analyze is how to compare the fractions because floating point numbers may be not precise enough Let s store each fraction as a pair of integers where is the numenator and is the denominator We should normalize each fraction as follows firstly we reduce it by finding the greatest common divisor of and and then dividing both numbers by this divisor Secondly we should ensure that numenator is non negative and if numenator is zero then denominator should also be non negative this can be achieved by multiplying both numbers by 
484,You are given a rooted undirected tree consisting of vertices Vertex is the root Let s denote a of vertex as an infinite sequence where is the number of vertices such that both conditions hold is an ancestor of the simple path from to traverses exactly edges The of a of vertex or shortly the of vertex is an index such that for every for every For every vertex in the tree calculate its ,In this problem we can use small to large merging trick also known as DSU on tree when building a depth array for a vertex we firstly build depth arrays recursively for its children then pull them upwards and merge them with small to large technique In different blogs on this technique it was mentioned that this will require operations with structures we use to maintain depth arrays overall However in this problem we may prove a better estimate it will require operations That s because the size of depth array if considering only non zero elements for a vertex is equal to the height of its subtree not to the number of vertices in it To prove that the number of operations is one can use the intuitive fact that when we merge two depth arrays all elements of the smaller array are destroyed in the process so if the size of smaller array is then we require operations to destroy elements The main problem is that we sometimes need to pull our depth arrays upwards thus inserting a to the beginning of the array Standard arrays don t support this operation so we need to either use something like and the complexity will be or keep the depth arrays in reversed order and handle them using and then complexity will be ,The first idea is the following it is always profitable to add the edges from the vertex to any other vertex The proof is the following if we will add two edges and then the distance to the vertex will be the distance to the vertex will be But we can add edges and and this will be better in fact you cannot obtain the less answer by adding two edges in the other way The main idea is the following Let s carry all vertices of the tree with the distance more than in the set Let the vertex with the maximum distance be What we will obtain if we will add the edge The distance to the vertex will be and the distance to the vertex where is the parent of the vertex if we will root the tree by the vertex will be So we will make reachable at most two vertices if the vertex is already reachable then it will be not counted in the answer Now what we will obtain if we will add the edge We will make reachable all the vertices adjacent to the vertex and the vertex the number of such vertices is not less than so this move won t make the answer greater instead of any other way to add the edge After adding such edge let s remove the vertex and all vertices adjacent to it from the set We need to repeat this algorithm until the set will not become empty Time complexity is I sure that there exists the solution with the dynamic programming in the linear time I will be very happy if someone will explain it to other participants 
485,A superhero fights with a monster The battle consists of rounds each of which lasts exactly minutes After a round ends the next round starts immediately This is repeated over and over again Each round has the same scenario It is described by a sequence of numbers The th element means that monster s hp hit points changes by the value during the th minute of each round Formally if before the th minute of a round the monster s hp is then after the th minute it changes to The monster s initial hp is It means that before the battle the monster has hit points Print the first minute after which the monster dies The monster dies if its hp is less than or equal to Print if the battle continues infinitely ,In general the answer looks like some number of complete full round cycles plus some prefix the the round Check corner case that there are no complete full rounds at all just check the first round in naive way If no solution found the answer has at least one complete full cycle and some prefix If total sum in one round is not negative then a complete full cycle doesn t help and it is again the no solution case Let s find number of complete full cycles We need such number of cycles that if your multiple by total sum and add some prefix the result with negative sign because it is not a damage will be greater or equal than So to find just add with the minimal prefix partial sum and divide the result by minus total sum Now you know the number of complete full cycles just iterate over the last round in naive way to find the answer ,Lets divide all dealing blows into two parts the last blow and others blows The last hit should be with maximum value of The others blows should be with the maximum value of So lets denote as and as Then if the we can beat Zmei Gorynich with one blow Otherwise if then we cannot defeat Zmei Gorynich Otherwise if and the answer is 
486,You are given an array consisting of positive integers Let s call a concatenation of numbers and the number that is obtained by writing down numbers and one right after another without changing the order For example a concatenation of numbers and is a number Count the number of ordered pairs of positions in array such that the concatenation of and is divisible by ,Let s rewrite concatenation in a more convenient form where is the number of digits in Then this number is divisible by if and only if the sum of and is either or Let s calculate arrays of remainders For each adds to That s the first term of the sum Now iterate over the second term for and for you binary search for in The number of its occurrences should be added to answer You also might have calculated some pairs iterate over them and subtract them naively Overall complexity ,A good start to solve the problem would be to check the answers for small values of One can see that the answers the sizes of the maximum subsets are not much different from itself or rather not less than Let s try to prove that this is true for all Consider is even Let let s see what the product is equal to if we take all the numbers from to From here we can see that for even the answer is at least because we can delete and the product of the remaining factorials will be the square of an integer for odd the answer is at least because we can delete and It remains to prove that the answer is at least for odd This is easy to do because the answer for is not less than the answer for minus because we can delete and solve the task with a smaller value Moreover it can be seen from the previous arguments that the answer can only be for and we already know that in this case one of the correct answers is to remove the factorials It remains to learn how to check whether it is possible to remove or numbers so that the remaining product of factorials is the square of an integer To do this we can use XOR hashes Let s assign each prime number a random bit number For composite numbers the hash is equal to the XOR of hashes of all its prime divisors from factorization Thus if some prime is included in the number an even number of times it will not affect the value of the hash which is what we need The hash of the product of two numbers is equal to the XOR of the hashes of these numbers Let s denote the hash function as Using the above let s calculate for all from to as well as for all from to this is easy to do because We will also store a map Let s calculate the hash and denote it as It remains to consider the following cases if then the current product is already the square of an integer for an answer of size we have to check that there exists such a that To find such let s check whether the map contains for an answer of size we have to check that there are such and that To do this iterate over and then check whether map contains otherwise the answer is and there is an answer where all numbers except are taken 
487,There is a grid consisting of rows and columns Each cell of the grid is either free or blocked One of the free cells contains a lab All the cells beyond the borders of the grid are also blocked A crazy robot has escaped from this lab It is currently in some free cell of the grid You can send one of the following commands to the robot move right move down move left or move up Each command means moving to a neighbouring cell in the corresponding direction However as the robot is crazy it will do anything except following the command Upon receiving a command it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked If there is such a direction then it will move to a neighbouring cell in that direction Otherwise it will do nothing We want to get the robot to the lab to get it fixed For each free cell determine if the robot can be forced to reach the lab starting in this cell That is after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses it will end up in a lab ,One way to think about this problem is in game theory terms Imagine a following game Two players alternate moves The first players chooses a direction The second player chooses a different direction and moves a robot there The game ends when the robot reaches the lab and the first player wins Otherwise it s a draw What s the outcome of the game if both players play optimally as in the first player tries to win the second player tries to draw Does it sound easier Well it sure does if you ever dealt with solving games on arbitrary graphs You can skim through this article if that s unfamiliar to you The state of the game is a pair If a direction is not chosen denote it with it s the first player s move Otherwise it s the second player s move You can even implement it as is Or you can adjust a part of this algorithm for this particular problem Initially all the states are drawing only the state is winning What we basically need is a way to determine if a state is winning or not From game theory we can tell that the state is winning if there s a transition from it to a losing state The state is losing if all the transitions from it lead to winning states So is winning if any of are losing Promote that one step further The state is winning if there exists such a direction that all neighbouring free cells except in this direction are winning states Rephrase it The state is winning if it has at least one winning state neighbour and no more than one non winning state neighbour Let s store the number of non winning neighbouring states for each cell Initially it s the number of neighbouring free cells If some state becomes marked as winning decrease the value for each of its neighbours by If some state s value reaches or after this operation mark it as winning Since what this does is basically a traversal of a grid this can be done with a DFS BFS starting from the lab Overall complexity per testcase ,At first let s jump with while is still greater than the current position Now we finished in some position Note that otherwise we wouldn t make the last step If then we are lucky to finish right in point Otherwise let s look at what happens if we replace one with Basically we ll finish in And since then We know that so if then we can choose the corresponding and replace with and get straight to the point But if then we need one extra operation To calculate fast we can note we need at least since and then we can increase while 
488,Let s call a positive integer if there is no digit in its decimal representation For an array of a numbers one found out that the sum of some two neighboring elements is equal to i e for some had turned out to be a number as well Then the elements of the array were written out one after another without separators into one string For example if then You are given a string and a number Your task is to determine the positions in the string that correspond to the adjacent elements of the array that have sum If there are several possible answers you can print any of them ,Let s denote as the largest of the terms of the sum and is the smaller one Consider cases or If then So we need to find two consecutive substrings of length such that if we convert these substrings into integers their sum is equal to If let be the largest common prefix of and if we consider them as strings Then or So it is necessary to check only these two cases and whether goes before or after in the string Thus we have reduced the number of variants where the substrings for and are located to It remains to consider how to quickly check whether the selected substrings are suitable To do this you can use hashes preferably with several random modules ,There is a property of arithmetic mean and the equality holds when Obviously we can always gain maximum arithmetic mean equal to by taking single maximum element from Considering the property above we need to take only maximum elements in our subsegment that s why we need to find the longest subsegment consisting only of maximum elements 
489,For some array let s denote a as a sequence of indices such that and for each is the minimum number such that and You are given an array For each its subsegment of length calculate the length of its longest greedy subsequence ,Let s calculate for each position position the closest greater from the right element to and add directed edge from to Then we will get oriented forest or tree if we d add fictive vertex where all edges are directed to some root So we can look at current subsegment we need to calculate the answer for as at a number of marked vertices in the tree Then the answer itself is a longest path up to the tree consisting only from marked vertices Key observation is next if and are marked and is an ancestor of then any vertex on path from to is also marked So the longest path up to the tree consisting only from marked vertices has length equal to a number of marked vertices on path to the root And we have three types of queries mark a vertex unmark a vertex and calculate maximum number of marked vertices among all paths to the root It can be done with Segment Tree on Euler Tour of the tree if we calculate and for each vertex in dfs order then marking unmarking is just adding to a segment and maximum among all paths is a maximum on the whole tree Result time complexity is and space complexity is ,This problem is about the rerooting technique Firstly let s calculate the answer for some fixed root How can we do this Let be the maximum possible difference between the number of white and black vertices in some subtree of yes the subtree of the rooted tree i e and all its direct and indirect children that the vertex We can calculate this dynamic programming by simple dfs for the vertex it will look like this Okay we can store the answer for the root somewhere What s next Let s try to change the root from the vertex to some adjacent to it vertex Which states of dynamic programming will change Only and Firstly we need to remove the child from the subtree of the vertex Then we need to attach the vertex and make it a child of the vertex Then we need to run this process recursively from store the answer reroot the tree and so on and when it ends we need to rollback our changes Now is the root again and we can try the next child of as the root Time complexity 
490,You are given intervals in form on a number line You are also given queries in form What is the minimal number of intervals you have to take so that every point from to is covered by at least one of them If you can t choose intervals so that every point from to is covered then print for that query ,Let s take a look at a naive approach at first That approach is greedy Let s find such an interval which starts to the left or at and ends as much to the right as possible Set to its right border Continue until either no interval can be found or is reached The proof basically goes like this Let there be some smaller set of intervals which cover the query these can be sorted by left border obviously their left borders are pairwise distinct Compare that set to the greedy one take a look at the first position where best set s interval has his less than the greedy set s You can see that choosing interval greedily will still allow to have the rest of best set intervals making the greedy choice optimal Let s implement it in For each position from to you can precalculate the index of such an interval that it starts to the left or at this position and ends as much to the right as possible To do this sort all intervals by their left border then iterate over positions while maintaining the maximum right border achieved by intervals starting to the left or at the current position The query is now straightforward Now there are two main ways to optimize it You can do it binary lifting style for each interval or position precalculate the index of the interval taken last after taking intervals greedily and use this data to answer queries in You can also do it path compression style Let s process the queries in the increasing order of their right borders Now do greedy algorithm but for each interval you use remember the index of the last reached interval Now the part with answering queries is in total because each interval will be jumped from no more than once Overall complexity ,There is a property of arithmetic mean and the equality holds when Obviously we can always gain maximum arithmetic mean equal to by taking single maximum element from Considering the property above we need to take only maximum elements in our subsegment that s why we need to find the longest subsegment consisting only of maximum elements 
491,There were types of swords in the theater basement which had been used during the plays Moreover there were swords of each type people have broken into the theater basement and each of them has taken exactly swords of some Note that different people might have taken different types of swords Note that the values and are unknown for you The next morning the director of the theater discovers the loss He counts all swords exactly swords of the th type are left untouched The director has no clue about the initial number of swords of each type in the basement the number of people who have broken into the basement and how many swords each of them have taken For example if then one of the possible situations is and Then the first three people took swords of the first type and the other two people took swords of the third type Note that you don t know values and beforehand but know values of and Thus he seeks for your help Determine the number of people which could have broken into the theater basement and the number of swords each of them has taken ,Firstly let s notice that for the fixed value of our problem is reduced to the following we are given numbers We need to choose such values that And among all such values we need to choose values in a way to minimize And the sum of is Of course for the fixed value the minimum sum of can be only one Let s start with It is obvious that if the maximum value in the array is the value equals for Assume that each from to has some divisor Then if we multiply by and divide each by the answer will only become better How to calculate this value of fast We can see that this value equals to And it can be proven that this value of is always optimal and we can easily determine for such Time complexity ,What is the sum of all the elements in b This is twice the sum of all the elements in a x Denote by B the sum of all the elements of b Let s iterate over which of the array elements was added as the sum of the elements a let s denote for a Then x B 2 cdot A It remains to check that the element x is present in the array b this can be done using a hash table or a binary search tree 
492,Recently you have received two integer numbers and You forgot them but you remembered a list containing all divisors of including and and all divisors of including and If is a divisor of both numbers and at the same time there are two occurrences of in the list For example if and then the given list can be any permutation of the list Some of the possible lists are or Your problem is to restore suitable integer numbers and that would yield the same list of divisors possibly in different order It is guaranteed that the answer exists i e the given list of divisors corresponds to some integers and ,Let s take a look on the maximum element of the given array Suddenly this number is or the order doesn t matter Okay what would we do if we know and merged list of divisors of and Let s remove all divisors of and see what we got The maximum element in the remaining array is So the problem is solved ,To solve the problem we can implement the encryption algorithm with a single change we have to iterate over all divisors of in increasing order Time complexity where is a divisor count function for For example 
493,Monocarp is playing a computer game In this game his character fights different monsters A fight between a character and a monster goes as follows Suppose the character initially has health and attack the monster initially has health and attack The fight consists of several steps the character attacks the monster decreasing the monster s health by the monster attacks the character decreasing the character s health by the character attacks the monster decreasing the monster s health by the monster attacks the character decreasing the character s health by and so on until the end of the fight The fight ends when someone s health becomes non positive i e or less If the monster s health becomes non positive the character wins otherwise the monster wins Monocarp s character currently has health equal to and attack equal to He wants to slay a monster with health equal to and attack equal to Before the fight Monocarp can spend up to coins to upgrade his character s weapon and or armor each upgrade costs exactly one coin each weapon upgrade increases the character s attack by and each armor upgrade increases the character s health by Can Monocarp s character slay the monster if Monocarp spends coins on upgrades optimally ,First of all let s understand how to solve the problem without upgrades To do this it is enough to compare two numbers and the number of attacks that the character needs to kill the monster and the number of attacks that the monster needs to kill the character respectively So if the first number is not greater than the second number then the character wins Note that the number of coins is not very large which means we can iterate over the number of coins that we will spend on weapon upgrades and the remaining coins will be spent on armor upgrades After that we can use the formula described above to check whether the character will win The complexity of the solution is ,It is enough to consider two cases whether we will increase the strength of the hero who will kill the dragon or not If you do not increase the hero s strength then you have to choose such that Obviously among such you have to choose with the minimum value because the strength of defending heroes is equal to It remains to increase the total strength of the remaining heroes to So the required number of coins is equal to If you increase the hero s strength then you have to choose the maximum value of which is less than In this case the required number of coins is to increase the strength of the hero who will kill the dragon plus to increase the strength of the defending heroes To find the heroes with strength as close to as possible you can use binary search don t forget to sort the heroes beforehand 
494,Polycarp has an array consisting of integers He wants to play a game with this array The game consists of several moves On the first move he chooses any element and deletes it after the first move the array contains elements For each of the next moves he chooses any element with the only restriction its parity should differ from the parity of the element deleted on the previous move In other words he alternates parities even odd even odd or odd even odd even of the removed elements Polycarp stops if he can t make a move Formally If it is the first move he chooses any element and deletes it If it is the second or any next move if the last deleted element was Polycarp chooses any element and deletes it if the last deleted element was Polycarp chooses any element and deletes it If after some move Polycarp cannot make a move the game ends Polycarp s goal is to the sum of elements of the array after end of the game If Polycarp can delete the whole array then the sum of elements is zero Help Polycarp find this value ,Let s calculate the sum of the whole array and then divide all its elements into two arrays and by their parity for odd for even Sort both of them in non increasing order Then what can we see We always can delete first elements from both arrays where is the size of So let s decrease by the sum of first elements of the array and the same for the array If one the arrays has more than elements both arrays cannot have more than elements because if it is so then should be greater then let s decrease by the th element of this array because this is the maximum possible element we can remove Now is the answer for the problem ,For each from to find all elements of the array that are congruent to modulo and store their indices in a list Also create a vector called and let be We have to cycle from to twice For each from to if there are in list too many i e elements congruent to modulo remove the extra elements from this list and add them to If instead there are too few i e elements congruent to modulo remove the last few elements from the vector For every removed index increase by After doing so after two passes we print the total increase and the updated array It is obvious that after the first iterations every list will have size at most and after more iterations all lists will have the same sizes It can be easily proved that this algorithm produces an optimal answer The time complexity is 
495,Let s call of some string as string Analogically let s call of string as string Let s say string is if its left cyclic shift is equal to its right cyclic shift You are given string which consists of digits What is the minimum number of characters you need to erase from to make it good ,Let s analyze when the string is good Suppose it is The cyclic shifts of this string are and We get the following constraints for a good string If the string has odd length then all characters should be equal to each other otherwise all characters on odd positions should be equal and all characters on even positions should be equal Now since there are only different types of characters we can brute force all possible combinations of the first and the second character of the string we want to obtain there are only of them and for each combination greedily construct the longest possible subsequence of beginning with those characters in ,You should implement what is written in the statement Here are three ways to do it Check that the first character is or check that the second character is or and check the third character is or Make an array storing all acceptable strings there are only and loop and see if any of the strings match the input Use some built in function like in C to make the string all lowercase and check if is equal to The complexity is per test case 
496,You are given an undirected tree of vertices Some vertices are colored one of the colors some are uncolored It is guaranteed that the tree contains at least one vertex of each of the colors There might be no uncolored vertices You choose a subset of and remove it from the tree Tree falls apart into connected components Let s call this subset of edges if none of the resulting components contain vertices of different colors How many subsets of edges are there in the given tree Two subsets are considered different if there is some edge that is present in one subset and absent in the other The answer may be large so print it modulo ,Okay this solution is really complicated and I would like to hear nicer approaches from you in comments if you have any However I still feel like it s ok to have this problem in a contest specifically as a harder version of F1 Let s start with the following thing Root the tree by some vertex For each color take all vertices of this color and paint their lowest common ancestor the same color as them The purpose of that will come clear later Why can we do this The case with lca some vertex of that color is trivial Now take a look at the edges from lca to its subtrees At least two of them contain a vertex of that color You can t cut the edges to these subtrees because this will make vertices of the same color belong to different components Thus lca will always be in the same component as these vertices If lca is already painted the other color then the answer is 0 That s because lca once again make vertices of the same color belong to different components Now everything will be calculated in a single dfs Let return one of the following values if there is no colored vertex in the subtree of if there exists some color such that vertex has vertices of color in its subtree and vertex has ancestors of color not necesserily direct parent otherwise I claim that if there are multiple suitable colors for some vertex then the answer is 0 Let s take a look at any two of them and call them colors and For both colors take a path from arbitrary vertex of that color in subtree to arbitrary vertex of that color that is ancestor of You can t cut any edge on these paths because that will divide the vertices of the same color Now either path for color contains vertex of color or path for color contains vertex of color That vertex is the upper end of the corresponding path That means that component of one color includes the vertex of the other color which is impossible Moreover that s the last specific check for the answer being 0 The step with lca helped us to move to the ancestor instead of any vertex in the upper subtree of I truly believe that you can avoid lca in this solution however that will make both implementation and proof harder Now let s do the number of ways to cut some edges in the subtree of so that 0 the component with vertex has no colored vertices in it 1 has some colored vertices Generally the color itself for 1 doesn t matter If for some child of returned color then it must be color in that component otherwise the color doesn t matter For all vertices of each color presented in the subtree of are contained within the subtree of The transitions will be of form do we cut the edge from to or not for all children of That is the most tedious part so I m sorry if I mess up something the way I did with my author solution DHere from now I ll ignore the children that returned if I say all children I will mean all non zero returning children as they add nothing to the answer If there are no children then the vertices with will have and the other vertices will have Basically there are two main cases I would recommend to follow the code in attachment while reading this tbh and all children dfs returned Then for each edge to the child you can either cut it if there are colored vertices take or don t cut it if it has no colored vertices take So For to have some color you ll need to push that color from exactly one of the children You can t choose two subtrees because they are guaranteed to have different colors in them otherwise they wouldn t return So To calculate that fast enough you ll need to precalculate prefix and suffix products of or but some children returned the same value Then you are required to make the part of component with vertices of color That means that for that case For children who returned you don t cut their edge take For the other children you can either cut it if there are colored vertices take or don t cut it if it has no colored vertices take Thus The answer will be stored in after that Overall complexity but I m sure this can be rewritten in such a manner that it becomes ,Let s use dynamic programming to solve this problem We will start with a single biconnected component consisting of vertex and connect other vertices to it So the state of our dynamic programming will be a of vertices that are in the same biconnected component with How can we extend a biconnected component in such a way that some other vertices are added into it but it is still biconnected We will add a path possibly cyclic that starts in some vertex belonging to the goes through some vertices and ends in some vertex belonging to the possibly If for every triple we precalculate some path that starts in goes through vertices from and ends in and does not contain neither nor then we can solve the problem in there will be states for every state we will iterate on two vertices and belonging to the and the number of possible pairs of non intersecting masks and is The only thing that s left is precalculating the paths for triples That can be done with auxiliary dynamic programming which will denote whether such a path exists For every edge of the original graph is true and we can go from to some state where will contain all vertices from and vertex and we should ensure that there is an edge in the graph and the didn t contain vertex earlier We should also somehow be able to restore the paths from this dp and we also should be careful not to choose the same edge twice for example if we start a path by edge we should not use the same edge to return to both these things can be done for example by storing next to last vertex in the path 
497,Given the string of decimal digits of length A substring is a sequence of consecutive characters of a string The substring of this string is defined by a pair of indexes with its left and right ends So each pair of indexes where corresponds to a substring of the string We will define as the numeric value of the corresponding substring leading zeros are allowed in it For example if then and You are given and an integer You need to process queries each of which is characterized by numbers The answer to the th query is such a pair of substrings of length that if we denote them as and then that is the substrings are different the remainder of dividing a number by is equal to If there are many matching substring pairs then find a pair where is as small as possible If there are many matching pairs in this case then minimize Note that the answer may not exist ,Note that the remainder of dividing a number by is equal to the remainder of dividing its sum of digits by This is easy to check because the number of digits is representable as a polynomial and gives a remainder of when divided by for any Let s count an array of prefix sums of digits for the string Now knowing we can pre calculate for each remainder modulo all possible Also for each query we can easily find the remainder of dividing by using all the same prefix sums Let s iterate over the remainder of the number when dividing by Knowing it we can easily find the remainder of the number when divided by as modulo Now using each pair of remainers let s try to update the answer then the minimum index from the pre calculated array will act as and the next largest will act as if such exist then the minimum indexes from the pre calculated array will act as and This solution works for or for ,The key fact in this problem is that the answer is not very large in fact it s not greater than 91 Why is it so Every 10 times we apply function f to our current number it gets divided by 10 at least and the number of such divisions is bounded as O log n So we can just do the following store all reachable numbers somewhere and write a loop that adds current number n to reachable numbers and sets n f n we should end this loop when n already belongs to reachable numbers The most convenient way to store reachable numbers is to use any data structure from your favourite programming language that implemenets a set but in fact the constrains were so small that it was possible to store all reachable numbers in an array 
498,Alex Bob and Carl will soon participate in a team chess tournament Since they are all in the same team they have decided to practise really hard before the tournament But it s a bit difficult for them because chess is a game for two players not three So they play with each other according to following rules Alex and Bob play the first game and Carl is spectating When the game ends the one who lost the game becomes the spectator in the next game and the one who was spectating plays against the winner Alex Bob and Carl play in such a way that there are no draws Today they have played games and for each of these games they remember who was the winner They decided to make up a log of games describing who won each game But now they doubt if the information in the log is correct and they want to know if the situation described in the log they made up was possible that is no game is won by someone who is spectating if Alex Bob and Carl play according to the rules Help them to check it ,This task is about pure implementation Maintain the number of current spectator and check if he doesn t win With knowledge of current winner and current spectator you can easily get the third player by formula just the sum of all numbers without the known ones Overall complexity ,Let s solve the problem by dynamic programming Let be the probability of winning if the last taken card has number on it and the number of taken cards is We win immediately next turn if we take card with number on it The probability of this is where is number of cards with Also we can win if we take a greater card next turn We take a card with number with probability with number with probability and so on The probability of winning in this case will be and respectively So the probability of winning for is Therefore all we need is to maintain the sum while calculating our dynamic programming 
499,Find the minimum number with the given sum of digits such that digits in it are distinct i e all digits are unique For example if then the answer is This is the minimum number in which all digits are different and the sum of the digits is For the given print the required number ,Let s use the greedy solution we will go through the digits in decreasing order If the sum of we need to dial is greater than the current digit we add the current digit to the end of the line with the answer Note that in this way we will always get an answer consisting of the minimum possible number of digits because we are going through the digits in descending order Suppose that the resulting number is not optimal Then some digit can be reduced and some digit that comes after it can be increased in order to save the sum we can not increase the digit before it as then we get a number greater than the current one Two variants are possible We want to increase the digit to but then it becomes equal to the digit following it or exceeds the value Then we can t increment that digit Otherwise in the first step we can get instead of but since we are going through the digits in decreasing order we cannot get the value of in that case Contradiction ,Let s iterate over all 6 digit numbers Now we will calculate number of positions in which digit of current ticket differs from digit of input ticket and call it Then answer will be minimal value over all lucky tickets 
500,You are given two positive integer numbers and Permute change order of the digits of to construct maximal number not exceeding No number in input and or output can start with the digit It is allowed to leave as it is ,Let s construct the answer digit by digit starting from the leftmost Obviously we are asked to build lexicographically maximal answer so in this order we should choose the greatest digit on each step Precalc number of digits in number Iterate over all possible digits starting from the greatest For each digit check if it s possible to put it in this position For this you construct minimal suffix greedily put the lowest digit and compare the resulting number with number If it became less or equal then proceed to the next digit Overall complexity where is digits from to ,This is an implementation problem You should do exactly what is written in the problem statement On my mind the simplest way is to find the position of the first not zero digit and the position of the dot The difference between that positions is the value of if the value is positive you should also decrease it by one 
501,You are given a connected weighted undirected graph consisting of vertices and edges You are asked queries about it Each query consists of a single integer For each query you select a spanning tree in the graph Let the weights of its edges be The cost of a spanning tree is the sum of absolute differences between the weights and The answer to a query is the lowest cost of a spanning tree The queries are given in a compressed format The first queries are provided explicitly For queries from to Print the xor of answers to all queries ,Consider a naive solution using Kruskal s algorithm for finding MST Given some you arrange the edges in the increasing order of and process them one by one Look closely at the arrangements At the edges are sorted by How does the arrangement change when increases Well some edges swap places Consider a pair of edges with different weights and Edge will go before edge in the arrangement as long as is closer to than So for all up to edge goes before edge And for all from onwards edge goes before edge This tells us that every pair of edge with different weights will swap exactly once So there will be at most swaps Which is at most different arrangements Each of them corresponds to some range of s We can extract the ranges of s for all arrangements and calculate MST at the start of each range We can also find the arrangement that corresponds to some from a query with a binary search However only knowing the weight of the MST at the start of the range is not enough The weights of edges change later in the range and we can t predict how Some edges have their weight increasing some decreasing First let s add more ranges We want each edge to behave the same way on the entire range either increase all the way or decrease all the way If we also add for all into the MST calculation this will hold Second let s store another value for each range the number of edges that have their weight increasing on it With that we can easily recalculate the change in the cost of the spanning tree The TL should be free enough for you to sort the edges for each MST calculation resulting in solution You can also optimize the first part to , editorial by PikMike Firtsly we can notice that we get the most profit by placing the edge in a same position no matter the query Moreover once you have calculated the minimum difference you can apply to the shortest path by adding edge of the weight you can answer the queries in each Let the current shortest distance between and be Then the answer to some query is Let s proceed to proofs of the following Consider any of the optimal positions for the edge of weight Then weight will add to the answer in this position if the path isn t already but that is trivial Let there be another position such that the answer in it is less than the current one That means that the answer for weight in it is less by which is smaller than the first one we got which leads to contradiction The second fact can deduced from the first one Then let me introduce the next bold statement We root the tree with vertex Then if there exists such a vertex in that it s not an ancestor of vertex and the number of vertices in its subtree inclusive is greater than then That is simple just put the edge between the parent of this vertex and any of vertices of the subtree there always be such that the edge doesn t exist yet That won t change the shortest path no matter which it is Then we have a graph of the following kind That is the simple path between and and some vetices on it have additional children leaves Finally let s proceed to the solution We want to choose such a pair of vertices that the sum of edge on a path between them which are also a part of the path between and plus the weights of the newly included to shortest path edges if any is minimal possible Let s precalc the sum of weights of edges from vertex to vertex and parent of vertex Let be the weight of an edge between and Then we end up with the four basic cases for these vertices and with having greater or equal number of edges on path to than each of the form whether belongs to the simple path between and whether belongs to it doesn t belong the answer is belongs doesn t both belongs Each of these formulas can be broken down to parts with exacly one of the vertices Let s call them and That means minimizing the result is be the same as minimizing each of the parts We run depth first search on vertices which belong to a simple path between and inclusive Maintain the minimum value of you have already passed by Try connecting each vertex with this and also parent of the parent of the current vertex using all the possible formulas and updating with the resulting value Finally after the precalc is finished asnwer the queries in with Overall complexity editorial by BledDest Let s denote the distance from vertex to vertex in the tree as Similarly denote the distance from to in the tree as Suppose we try to add a new edge between vertices and with length Then two new paths from to are formed one with length and another with length Then the new length of shortest path becomes So if we find two non adjacent vertices such that is maximum possible then it will always be optimal to add an edge between these two vertices How can we find this pair of vertices Firstly let s suppose that when we pick vertex we will try to pair it only with vertices corresponding to the aforementioned constraint This can be done by sorting vertices by the value of and then for each vertex pairing it only with vertices that are later than in the sorted order How do we find the best pair for The best pair could be just the vertex with maximum possible but it is not allowed to connect a vertex with itself or its neighbour To handle it we may maintain a set of possible vertices delete all neighbours of from it pick a vertex with maximum and then insert all neighbours of back into the set This solution works in time 
502,Calculate the number of permutations of size with exactly inversions pairs of indices such that and and exactly indices such that Yep that s the whole problem Good luck ,A lot of solutions which were written during the contest use Berlekamp Messey or some other algorithms related to analyzing linear recurrences but the model solution is based on other principles First of all if the number of inversions is at most it means that most elements of the permutation will stay at their own places and those which don t stay at their places can t be too far away from them Let s denote a block in a permutation as a segment of indices such that all elements less than are to the left of the block all elements greater than are to the right of the block all elements from belong to the block Let s say that a block is non trivial if it contains at least two elements Suppose we split a permutation into the maximum number of blocks Then for each block we can see that if its length is it has at least inversions to prove it you can use the fact that the number of inversions is equal to the number of swaps of adjacent elements required to sort the permutation and if we cannot split the block into other blocks it means that we have to swap each pair of adjacent elements in it at least once to sort it if the block is non trivial it has at least one such that From these two facts we can see that there will be at most non trivial blocks there will be at most elements in total belonging to non trivial blocks the maximum possible length of a block is The main idea of the solution is to calculate the following dynamic programming is the number of ways to split elements into non trivial blocks such that there are exactly inversions in them and exactly pairs Then to get the answer for the test case we can iterate on the number of non trivial blocks and the number of elements in them and choose the elements belonging to that blocks with a binomial coefficient The only thing that s left is how to calculate this dynamic programming efficiently There are a few ways to do it but the model solution uses a table the number of different non trivial blocks of length with elements and inversions to handle transitions This table is not very big so you can run an exhaustive search for minutes to calculate it and then just paste its results into the source code of your program Note that you have to make sure that you consider only the blocks which cannot be split any further ,The easiest way to solve to problem is probably to see the resemblense of a shuffle operation to an std rotate function So you can obtain the final deck by applying cyclic shifts of the deck by then and so on Since the shifts are cyclic it doesn t matter if you shift by or by or by for any non negative The result will be the same Thus you can calculate the sum of rotations you apply and subtract until it becomes less than That is taking it modulo Finally after rotating a sequence by some the th element of it indexed becomes the first one Thus you just want to print the th element of Overall complexity per testcase 
503,You are given a directed acyclic graph consisting of vertices and edges The vertices are numbered from to There are no multiple edges and self loops Let be the number of incoming edges indegree and be the number of outgoing edges outdegree of vertex You are asked to remove some edges from the graph Let the new degrees be and You are only allowed to remove the edges if the following conditions hold for every vertex or or Let s call a set of vertices if for each pair of vertices and such that and there exists a path either from to or from to over the non removed edges What is the maximum possible size of a set after you remove some edges from the graph and both indegrees and outdegrees of all vertices either decrease or remain equal to ,Let s solve the problem in reverse Imagine we have already removed some edges so that the conditions hold When is some set of vertices considered Since the graph is acyclic we can topologically sort the vertices in the set The vertices are reachable from each other so there exists a path from the th vertex in the set to the st vertex Thus there exists a path that goes through all chosen vertices However we can make this conclusion even stronger In the optimal answer not just the path goes from the th vertex to the st one but a single edge That can be shown by contradiction Let there be some vertices and that are adjacent in the chosen set There exists a path between them but not a single edge We want to show that this set is not optimal and can be made larger The vertices on that path don t belong to the set If they did they would be between and in the set because of the topological order We can add them to the set Every vertex that can reach can reach them too and every vertex that can be reached from can be reached from them Thus it will still be a set Now every vertex from to has an edge between them and the size of the set is larger Thus we showed that the maximum set in the answer is always some path in the graph So the task is to choose some path then remove some edges so that this path still exists and the conditions hold Note that if the conditions hold for some set of remaining edges then we can remove any edge from it and the conditions will still be met Thus we can only leave this path Let s look closer into the conditions What they actually tell is the following If a vertex has incoming edges then remove at least one of them The same for the outgoing edges Since we are looking for a path it s enough to leave one outgoing edge for all vertices except the last one and leave one incoming edge for all vertices except the first one In order to achieve that every vertex except the last one should have at least two outgoing edges and every vertex except the first one should have at least two incoming edges We can see that this condition is not only necessary but sufficient as well Just remove the outgoing edges which don t go to the next vertex and the incoming edges which don t go from the previous vertex Now we can wrap this up into the dynamic programming Initialize the answer with since you can always remove all edges and get a set with one vertex Then let be the longest path such that it starts in vertex all vertices in it have at least two incoming edges and all vertices except maybe the final one have at least two outgoing edges Initialize the for the vertices that can be the final in the path have at least two incoming edges with Then update for all that can be internal vertices have at least two outgoing and two incoming edges with for all outgoing edges Finally update the answer from the vertices that can be the first one in the path For each vertex that has at least two outgoing edges take the value of for all outgoing edges Overall complexity ,Let s divide all valid pairs into three categories the ones containing only edges on the path the ones containing only edges and the ones containing both types of edges To calculate the number of pairs containing only edges we may build a forest on the vertices of the original graph and edges and choose all pairs of vertices belonging to the same connected components of this forest we can find all connected components with DSU or any graph traversal algorithm The same can be done for the pairs containing only edges If a path from to is valid and contains both types of edges then there exists a vertex such that the simple path from to goes only through edges and the simple path from to goes only through edges So let s iterate on this vertex and choose some other vertex from its component in graph as and some other vertex from its component in graph as and add the number of ways to choose them to the answer 
504, heroes fight against each other in the Arena Initially the th hero has level Each minute a fight between two different heroes occurs These heroes can be chosen arbitrarily When two heroes of equal levels fight nobody wins the fight When two heroes of different levels fight the one with the higher level wins and his level increases by The winner of the tournament is the first hero that wins in at least fights A is a hero such that there exists a sequence of fights that this hero becomes the winner of the tournament Calculate the number of among heroes ,If for some hero no other hero is weaker than then the th hero cannot win any fights and is not a possible winner Otherwise the hero is a possible winner he may fight the weakest hero times and be declared the winner So the solution to the problem is calculating the number of minimum elements in the array since all other elements denote possible winners of the tournament ,Since the chess players of the first type should not lose a single game each game between two chess players of the first type should end in a draw so that none of them gets defeated And a game between a chess player of the first type and the second type should end either with a victory of the first or a draw Therefore for convenience we will say that all games with a chess player of the first type end in a draw Now there are only games between chess players of the second type left If there are only or such players then there is no answer Otherwise we can choose the following method the th chess player of the second type wins against the th chess player of the second type and the last one wins against the first all remaining games are drawn 
505,You are given an integer number The following algorithm is applied to it if then end algorithm find the smallest divisor of subtract from and go to step Determine the number of subtrations the algorithm will make ,Notice that once the number becomes even it never stops being even as subtracting doesn t change parity Thus the task is to find the smallest divisor subtract it and print Overall complexity ,Let s denote for the maximum number of moves for which the numbers and can be made equal It is easy to understand that the number of moves is maximum when and each time we divided or by a prime number That is sum of exponents of prime divisors of sum of exponents of prime divisors of Let s denote by the minimum number of moves for which the numbers and can be made equal Consider a few cases If then If or then Otherwise then Then the answer is possible in the following cases and and or and 
506,You are given a string of even length String is binary in other words consists only of s and s String has exactly zeroes and ones is even In one operation you can reverse any substring of A substring of a string is a contiguous subsequence of that string What is the minimum number of operations you need to make string A string is alternating if for all There are two types of alternating strings in general or ,We need to make our string alternating i e When we reverse substring we change no more than two pairs and Moreover one pair should be a consecutive pair and other So we can find lower bound to our answer as maximum between number of pairs of and number of pairs of And we can always reach this lower bound by pairing with or with left right border of Another way to count the answer is next suppose we want to make string then let s transform to For example if we will get We claim that after this transformation we will have equal number of and so the answer is the number of consecutive pairs of the same character divided by two The answer is the minimum between answers for and ,We will act greedily we will make an array consisting of elements in which we will mark if the letter is already encountered in the string and otherwise In the variable we will store the length of the even string that can be obtained from We will go through the string by executing the following algorithm if mark if then we already have a pair of repeating characters to add to an even string add to the number and clear the array Clearing is necessary because both characters that will make up the next pair must be in the string after the current character In other words if the last character in the current pair was then the first character in the new pair can be where Then we calculate the answer as 
507,There are pearls in a row Let s enumerate them with integers from to from the left to the right The pearl number has the type Let s call a sequence of consecutive pearls a Let s call a segment if it contains two pearls of the same type Split the row of the pearls to the maximal number of good segments Note that each pearl should appear in exactly one segment of the partition As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,Let s solve the problem greedily Let s make the first segment by adding elements until the segment will be good After that let s make the second segment in the same way and so on If we couldn t make any good segment then the answer is Otherwise let s add all uncovered elements at the end to the last segment Easy to prove that our construction is optimal consider the first two segments of the optimal answer obviously we can extend the second segment until the first segment will be equal to the first segment in our construction ,One of the possible answers is always a pair of endpoints of the given segments So we can add all endpoints to the array and iterate over all pairs of elements of this array and check if the current pair is suitable or not 
508,You are given a string consisting of characters is even For each from to is one of or A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and and and are not You want to find a string that consists of characters such that is a regular bracket sequence if for some and then In other words you want to replace all occurrences of with the same type of bracket then all occurrences of with the same type of bracket and all occurrences of with the same type of bracket Your task is to determine if such a string exists ,There are two key observations First a regular bracket sequence always starts with an opening bracket and ends with a closing one Thus the first letter of corresponds to an opening bracket and the last letter corresponds to a closing bracket If they are the same then the answer is Second a regular bracket sequence has exactly opening and closing brackets Thus we can check if the counts of the remaining letter and the first letter of the string or the remaining letter and the last letter of the string make it in total If neither of them do then the answer is If both do then that means that there are occurrences of the remaining letter so it doesn t matter what bracket it is assigned to Finally after the assignment is complete check if the resulting string is a regular bracket sequence For that you have to check if on any prefix the number of opening brackets is greater or equal to the number of closing brackets And also if the total number of opening and closing brackets is the same Overall complexity per testcase ,Note that means either or whereas means both and We can greedily solve this by starting out our string with all 1 s then marking and as 0 whenever we are forced to because Then we can simply check whether all of the conditions are valid to confirm Code 90915688 
509,Nikolay got a string of length which consists only of lowercase Latin letters and Its positions are numbered from to He wants to modify his string so that every its prefix of length has an equal amount of letters and To achieve that Nikolay can perform the following operation arbitrary number of times possibly zero choose some position in his string and replace the letter on this position with the other letter i e replace with or replace with Nikolay can use no letters except and The prefix of string of length is a string For example for the string abba there are two prefixes of the even length The first is ab and the second abba Both of them have the same number of and Your task is to calculate the minimum number of operations Nikolay has to perform with the string to modify it so that every its prefix of length has an equal amount of letters and ,The problem can be solved like this firstly let s iterate over all from to If characters and are the same then we obviously need to replace one of them with the other character We can see that such replacements are enough to make the string suitable ,The general idea of the solution is to check that string contains some substring which is a permutation of The constraints were so low you could do it with any algorithm even per test case could pass The most straightforward way was to iterate over the substring of sort it and check if it s equal to sorted That s Next you could notice than only substrings of length matter and shave another off the complexity to get After that you might remember that the size of the alphabet is pretty low And one string is a permutation of another one if the amounts of letters a letters b and so on in them are equal So you can precalculate array where is equal to the amount of the th letter of the alphabet in Calculating this array for substrings will be each so that makes it Then notice how easy it is to recalculate the letter counts going from some substring to Just subtract from the amount of the th letter and add to the amount of the th letter Comparing two array every time will still lead to though The final optimization is to maintain the boolean array such that means that is equal to the current value of of the substring You are updating just two values of on each step thus only two values of might change You want all the values to be so keep the number of values in that array and say if that number is equal to That finally makes the solution per test case 
510,You are given an array consisting of integers In one move you can choose some index and shift the segment cyclically to the right i e replace the segment with Your task is to sort the initial array by or say that it is impossible to do that You have to answer independent test cases ,Firstly let s solve the easier version of the problem Assume we are given a permutation not an array Notice that the given operation applied to some segment of the permutation cannot change the parity of number of inversions the number of inversions is the number of such pairs of indices that and So if the number of inversions in the given permutation is odd then we can t sort this permutation we can t obtain zero inversions But if the number of inversions is even then we can always sort the permutation with the following greedy algorithm let s find the minimum element and move it to the first position If its position is then we can apply the operation to the segment and our element will move by two positions to the left So after all our element is either at the first or at the second position If it s at the second position let s just apply two additional operations to the segment Then let s just cut off the first element and solve the problem without it At the end we have only two numbers that can be not sorted and we can check all three possibilities and choose one which is suitable for us it s always exists because the number of inversions is even How do we solve the problem if we are given the array not the permutation First of all we can prove that if the array contains at least two equal elements we can always sort it we will prove it by construction Let s just renumerate the elements of the given array in a way to obtian the permutation with the even number of inversions Thus if then let s find such a permutation that We can find this permutation easily if we sort the array of pairs in increasing order But there can be one problem this permutation can have odd number of inversions Then we need to find two consecutive pairs with the same first values and swap these two elements in the permutation Because in fact these two numbers are equal in the array and have consecutive values in the permutation we guaranteed change the parity of number of inversions Then we can apply our algorithm for permutations and solve the problem for the array If we failed then the answer is Otherwise the number of operations always does not exceed because this sort works like a bubble sort so our answer is suitable Time complexity ,Let be the value of the variable after steps Note that should be less than for to be not equal to It means that does not exceed It turns out that for there is always a permutation such that is equal to The only thing left is to find out how to build such a permutation There are many suitable permutations let s consider one of the possible options For an even a suitable permutation is You can see that in such a permutation changes as follows For an odd there is a similar permutation where changes as follows 
511,Treeland consists of cities and roads Each road is bidirectional and connects two distinct cities From any city you can get to any other city by roads Yes you are right the country s topology is an undirected tree There are some private road companies in Treeland The government decided to sell roads to the companies Each road will belong to one company and a company can own multiple roads The government is afraid to look unfair They think that people in a city can consider them unfair if there is one company which owns two or more roads entering the city The government wants to make such privatization that the number of such cities doesn t exceed and the number of companies taking part in the privatization is minimal Choose the number of companies such that it is possible to assign each road to one company in such a way that the number of cities that have two or more roads of one company is at most In other words if for a city all the roads belong to the different companies then the city is Your task is to find the minimal that there is such assignment to companies from to that the number of cities which are not doesn t exceed ,Formally the problem is to paint tree edges in minimal number of colors in such a way the the number of improper vertices doesn t exceed A vertex is improper if it has at least two incident edges of the same color It is easy to show that colors is always enough to paint a tree in such a way that all the vertices are proper where is the maximum vertex degree Actually it is always the truth do any bipartite graph Indeed if number of colors is less than the maximum degree such vertices will have at least two edges of the same color Dirichlet s principle If equals the maximum degree you can use just depth first search tree traversal to paint edges in different colors In this problem you can have up to improper vertices so just choose such minimal that number of vertices of degree greater than is at most In an alternative solution you can use a binary search to find such but it makes the implementation harder and the solution becomes slower by factor After it paint edges with colors each time choosing the next color skip color if it equals with the color of the traversal incoming edge ,What if the given graph will contain a cycle of odd length It will mean that some two consecutive edges of this cycle will be oriented in the same way and will form a path of length two What if there is no cycles of odd length in this graph Then it is bipartite Let s color it and see what we got We got some vertices in the left part some vertices in the right part and all edges connecting vertices from different parts Let s orient all edges such that them will go from the left part to the right part That s it 
512,You are given an array consisting of elements You may apply several operations possibly zero to it During each operation you choose two indices and increase by and remove the th element from the array so the indices of all elements to the right to it decrease by and also decreases by Your goal is to make the array strictly ascending That is the condition should hold where is the resulting size of the array Calculate the minimum number of actions required to make the array strictly ascending ,Suppose we don t have any constraints on the order of elements the resulting array just should not contain any duplicates Let s build the result one element after another in ascending order so each element we create is strictly greater than the previous To create an element just use some subset of elements and merge them into new element This process can be efficiently modeled with the following dynamic programming dp cnt mask is the minimum value of the last element if we merged all the elements from mask into cnt ascending numbers To model transitions we simply iterate on the mask of elements that will be merged into a new one and check if its sum is greater than the last element we created This runs in O n3 n if we use an efficient way to iterate on all masks that don t intersect with the given mask Okay how about maintaining the order When we create an element by merging some elements of the original array let s choose some position of an element we use in merging and state that all other elements are added to it Then to ensure that the result is ascending the position of this element should be greater than the position of the element we chose while building the previous number We can add the position we have chosen for the last element to the states of our dynamic programming so it becomes dp cnt mask pos the minimum value of the last element if we merged the mask of elements into cnt numbers and the last element originally had index pos in the array Using some greedy optimizations for example we should not iterate on the position we are choosing to merge it can be chosen greedily as the leftmost position after the position of previous element we are taking into consideration we can make it O n 2 3 n yet with a small constant factor To restore the answer we can maintain the previous values of mask and pos in each state since cnt just increases by 1 with each transition ,Let s sort the numbers in ascending order It becomes immediately clear that it is not profitable for us to increase the numbers that are equal to the last number the maximum of the array It turns out that every time you need to take such a subset of the array in which all the numbers except the maximums And once for each operation the numbers in the subset are increased by one then how many times can the operation be performed on the array Accordingly 
513,Let s call a positive integer ordinary if in the decimal notation all its digits are the same For example and are ordinary numbers but and are not ordinary numbers For a given number find the number of ordinary numbers among the numbers from to ,Note that every ordinary number can be represented as Therefore to count all ordinary numbers among the numbers from to it is enough to count the number of pairs such that In the given constraints it is enough to iterate over from to and from to ,You should delete only such for which there is no such that is a power of For each value let s find the number of its occurrences You can use simple standard data structure Do for each element Now you can easily check that doesn t have a pair Let s iterate over all possible sums and for each find calculate If for some or then a pair exists Note that in C solutions it s better to first check that is a key in and only after it calculate This needs to be done since in C when you access a key using the square brackets operator a default mapping key value is created on the absence of the key This increases both the running time and the memory consumption 
514,An online contest will soon be held on ForceCoders a large competitive programming platform The authors have prepared problems and since the platform is very popular coder from all over the world is going to solve them For each problem the authors estimated the number of people who would solve it for the th problem the number of accepted solutions will be between and inclusive The creator of ForceCoders uses different criteria to determine if the contest is good or bad One of these criteria is the number of inversions in the problem order An inversion is a pair of problems such that is located earlier in the contest but the number of accepted solutions for is greater Obviously both the creator of ForceCoders and the authors of the contest want the contest to be good Now they want to calculate the probability that there will be inversions in the problem order assuming that for each problem any number of accepted solutions for it between and is equally probable and all these numbers are independent ,The naive solution is dynamic programming let be the probability that the first problems don t have any inversions and the th one got accepted solutions Let s somehow speed it up For convenience I will modify the variable denoting the maximum number of accepted solutions for each problem and I will also reverse the problem order so that we don t want the number of solutions to decrease from problem to problem We know that if and otherwise Let s divide the whole segment between and into segments with the values of and and analyse the behavior of values on each such segment Let If we consider the behavior of on some segment we got we can prove by induction that it is a polynomial of degree not exceeding All that is left is to carefully calculate and maintain these polynomials on segments The main thing we will use to calculate the polynomials is interpolation To transition from to we will consider each segment separately calculate the first several values of on each segment we need to calculate the sum fast if is a polynomial this can also be done with interpolation and then interpolate it on the whole segment This is actually slow we have to interpolate at least polynomials and not easy to write Let s consider a better solution We will use combinatoric approach instead of calculating probabilities we will count all the non descending sequences such that and divide it by the number of all sequences without the non descending condition that is just Let s again divide into segments using the points and enumerate these segments from left to right If there are two neighboring values and they either belong to the same segment or the segment belongs to is to the right of the segment belongs to We could try to write the following dynamic programming solution is the number of non descending prefixes of the sequence such that there are elements in the prefix and the last one belongs to segment It s easy to model transitions from to where but we don t know how to model the transition to Let s get rid of them altogether We will introduce an additional constraint in our dynamic programming is the number of prefixes of the sequence of length The transitions in this dynamic programming are different we iterate on the number of elements belonging to the next segment and transition into if possible Calculating the number of ways to take elements from an interval in sorted order can be reduced to calculating the number of ways to compose as the sum of non negative summands order matters We should be able to calculate binomial coefficients with fairly large and not so large but that s not really hard if we use the formula ,We just need to find the position of the in the array and then check if the sequence is going counterclockwise or clockwise from the position or correspondingly We can do this by two cycles Total complexity 
515,You are given an undirected graph consisting of vertices and edges Your task is to find the number of connected components which are cycles Here are some definitions of graph theory An undirected graph consists of two sets set of nodes called vertices and set of edges Each edge connects a pair of vertices All edges are bidirectional i e if a vertex is connected with a vertex a vertex is also connected with a vertex An edge can t connect vertex with itself there is at most one edge between a pair of vertices Two vertices and belong to the same connected component if and only if there is at least one path along edges connecting and A connected component is a cycle if and only if its vertices can be reordered in such a way that the first vertex is connected with the second vertex by an edge the second vertex is connected with the third vertex by an edge the last vertex is connected with the first vertex by an edge all the described edges of a cycle are distinct A cycle doesn t contain any other edges except described above By definition any cycle contains three or more vertices ,Let s solve this problem for each connected component of the given graph separately It is easy to see that the connected component is a cycle iff the degree of each its vertex equals to So the solution is to count the number of components such that every vertex in the component has degree The connected components of the graph can be easily found by simple dfs or bfs ,Firstly let s remove the vertex from the graph Then let s calculate the number of connected components Let it be The answer is if and only if or is greater than the number of edges incident to the first vertex Otherwise let s construct the answer Firstly let s add into the new graph spanning trees of components in the initial graph without vertex Then let s add into the new graph edges from vertex one edge to each component Then let s add into the new graph any remaining edges from vertex The last thing we need is to construct a spanning tree of a new graph such that all edges incident to the vertex are in this spanning tree and other edges doesn t matter How to do it Let s run from the vertex in a new graph 
516,Let be the sum of digits of a decimal number Find the smallest non negative integer such that ,There are many ways to solve this problem including precalculating all answers but the model solution is based on the following In most cases It is not true only when the last digit of is and if we know the number of digits at the end of we can easily derive the formula for And since there will be at most one number with last digit equal to in Let s iterate on the last digit of and the number of digits before it Suppose the fixed has no other digits other than the last one and several digits before it Let s calculate Here goes the trick If we prepend with several digits such that the last of them is not and the sum of those digits is then So we can easily derive the value of we need and construct the smallest number with sum of digits equal to don t forget that the last digit should not be ,Denote the answer to the problem Note that or what is the same where equals to one if is a magic number otherwise equals to zero Let s solve the problem for the segment Here is described the standard technique for this kind of problems sometimes it is called dynamic programming by digits It can be realized in a two ways The first way is to iterate over the length of the common prefix with number Next digit should be less than corresponding digit in and other digits can be arbitrary Below is the description of the second approach Let be the number of magic prefixes of length with remainder modulo If than the prefix should be less than the corresponding prefix in and if than the prefix should be equal to the prefix of it can not be greater Let s do forward dynamic programming Let s iterate over digit in position We should check that if the position is even than should be equal to otherwise it cannot be equal to Also we should check for should be not greater than corresponding digit in Now let s see what will be the next state Of course By Horner scheme Easy to see that To update the next state we should increase it Of course all calculations should be done modulo 
517,Monocarp has a tree consisting of vertices He is going to select some vertex and perform the following operations on each vertex from to set equal to the distance from to the number of edges on the shortest path color some color A coloring satisfies two conditions for each pair of vertices of the same color there exists a path from to that only visits vertices of the same color for each pair of vertices of the same color Note that Monocarp can choose any amount of different colors he wants to use For each used color he then counts the number of vertices of this color The of the tree is the minimum of these numbers What can be the maximum cost of the tree ,Let s start by choosing a vertex naively Iterate over all vertices and try each of them Root the tree by and observe what the conditions become for each is just the depth of each vertex Well then the only case when the connected subgraph of vertices of the same color has all values of distinct is when they form a vertical path in the tree So the problem becomes the following Split the tree into some vertical paths in such a way that the shortest path is as long as possible Let s try greedy I guess Start the paths from the leaves and propagate them up Consider some vertex with at least two children All children have some paths leading up to them We d love to continue them all with but we can t do that We can only continue one path and cut the rest Pretty easy to see that the path to continue is the shortest path available It s at least as optimal as any other path Do that from the lowest vertices up and you got yourself a working greedy Also don t forget to stop all paths in root since you can t continue any of them further up Let s make this greedy more formal Every time we update the answer is with a path that is the shortest in every vertex lower than the current one not the shortest in the current one So we want to propagate the shortest child up and update the answer with the remaining children Updating the answer means just taking the minimum of values Thus we can actually ignore all children except the second shortest in each vertex Just don t forget to treat the root properly Now we can actually solve the problem in for a fixed You can just find two minimums in each vertex Well now that we can solve the problem for a single root let s try rerooting to solve for all of them There are solutions in but I found the solution in the neatest The constraints are low enough to allow it For each vertex maintain a multiset of lengths of vertical paths from its children I chose to store nothing in the leaves that only makes the implementation cleaner In order to update the vertex from its child you can take the minimum element in the child s set and add to it If it s empty the child is a leaf return Additionally store a multiset of the second minimums of all vertices that have at least two children In order to update the answer with the current root find the minimum of that multiset and the shortest path from the root To achieve you will probably have to either store prefix and suffix second minimums over children of each vertex or store three shortest paths in it It is kind of messy but it should still perform better Overall complexity or per testcase ,There is some obvious dynamic programming solution that someone can describe in the comments but I will describe another one that in my opinion much easier to implement Firstly let s find some diameter of the tree Let and be the endpoints of this diameter and first two vertices of the answer You can prove yourself why it is always good to take the diameter and why any diameter can be taken in the answer Then there are two cases the length of the diameter is or the length of the diameter is less than In the first case you can take any other vertex as the third vertex of the answer it will not affect the answer anyway Otherwise we can run multi source bfs from all vertices of the diameter and take the farthest vertex as the third vertex of the answer It is always true because we can take any diameter and the farthest vertex will increase the answer as much as possible Time complexity 
518,You are given a tree consisting of vertices numbered from to Initially all vertices are white You have to process queries of two different types change the color of vertex to black It is guaranteed that the first query will be of this type for the vertex find the minimum index such that the vertex with index belongs to the simple path from to some black vertex a simple path never visits any vertex more than once For each query of type print the answer to it ,After the first query make the vertex that we painted black the root of the tree and for each other vertex calculate the minimum index on the path to the root This can be done by simple DFS Then suppose we are painting some vertex black In can easily proved that for every vertex and every vertex that is on a path form to the root there exists a path from to some black vertex coming through So we have to store the minimum index among all vertices such that belongs to the path from the root to some black vertex it is a global value let s call it and the answer to every query of type is just the minimum of the value we calculated in DFS and To update quickly after painting vertex black we ascend from to the root until we arrive to some node that was visited during previous queries and we stop there because this node and all nodes on the path from it to the root were used to update in previous queries This solution works in time ,This problem has an easy constructive solution We can find lower and upper bounds on the value of for the given If the given does not belong to this segment then the answer is Otherwise the answer is for any in this segment How to construct it Let s start from the chain The answer for the chain is the upper bound of and it is Then let s try to decrease the answer by in one move Let s take some leaf the vertex without children with the smallest depth that is not and try to move it up The definition of badness will be below To do this let s find such vertex that its depth is less than the depth of by and it has less than children If we found such vertex then let s make the child of and decrease the answer by one If we didn t find such vertex I claim that the vertex has the minimum possible depth it can have and we should not consider it in the future Let s mark this vertex as and continue our algorithm If at some moment we cannot find any not leaf then the answer is Otherwise the answer is Time complexity 
519,Kristina had an array of length consisting of non negative integers She built a new array of length such that For example suppose Kristina had an array of length Then she did the following Calculated Calculated Calculated Calculated As a result she got an array of length You only know the array Find any matching array that Kristina may have originally had ,To solve the problem you can build an array as follows at Let s show that from the constructed array we can get an array equal to the original array If then If then So at If and then If then If then By the construction of the array it is not possible that and So If then If then So We get that for so and array is built correctly ,There are many ways to solve this problem I will describe the following recursive solution if let s compose an array where every segment ending with the th element is positive and every other segment is negative This array can be where is the th element of the array note that when doesn t belong to the array so it consists of only negative numbers but if solve the same problem with and recursively get an array of length with positive subarrays and append to it to make all segments ending with the last element positive 
520,You are given a regular polygon with vertices it s convex and has equal sides and equal angles and all its sides have length Let s name it as gon Your task is to find the square of the minimum size such that you can embed gon in the square Embedding gon in the square means that you need to place gon in the square in such way that each point which lies inside or on a border of gon should also lie inside or on a border of the square You can rotate gon and or the square ,At first lets place gon in such way that the lowest side of gon is horizontal Now we can without loss of generality think that the square has horizontal and vertical sides and we just rotate gon around its center If we rotate the gon at angle then it will move on itself Moreover after rotating at angle we ll get left and right sides vertical and the following rotation is meaningless since it s the same as if we just swap and coordinates So we don t we to rotate more than Also we can see that while rotating the difference between max and min decreasing while the distance between max and min increasing The answer is obviously the maximum among these differences So for example we can just ternary search the optimal answer Or we can note that the behavior of differences is symmetrical just swap and coordinates so the answer is in the middle angle i e we just need to rotate gon at angle Finally observing several right triangles we can come up with quite an easy answer ,A route visiting each cell exactly once can always be denoted as follows several possibly zero first columns of the glade are visited in a zigzag pattern then Vasya goes to the right until the end of the glade makes one step up or down and goes left until he visits all remaining cells There are such routes To calculate the weight of collected mushrooms quickly we will precompute three arrays for the first row of the glade and will be used to compute the weight of mushrooms collected when Vasya moves to the right until the last column of the glade when Vasya moves to the left from the last column and to handle the growth of mushrooms Also we have to compute the same arrays for the second row of the glade Let s iterate on the number of columns Vasya will pass in a zigzag pattern and maintain the weight of mushrooms he will collect while doing so Then we have to add the weight of the mushrooms Vasya will gather while moving to the right and then while moving to the left The first can be handled by arrays and the second by arrays and 
521,Suppose you have two points and Let s denote the Manhattan distance between them as Let s say that three points form a triple if Let s say that an array is if it is impossible to choose three indices such that the points and form a bad triple You are given an array Calculate the number of subarrays of A subarray of the array is the array for some Note that according to the definition subarrays of length and are ,Let s figure out criteria for the bad triple It s not hard to prove that the triple is bad iff point lies inside the bounding box of points and In other words if and Now looking at points and we can see that the bad situation may arise only if so we can check only ordered triples Looking closely at inequality we can note that there are two situations where forms a bad triple when either or In other words subarray is bad if and only if it contains either non decreasing subsequence of length or non increasing subsequence of length The final observation is that any sequence of length at least contains either non decreasing or non increasing subsequence of length It s not hard to prove it either brute forcing all possible variants of relative orders on paper or searching remembering the theorem that says it As a result you need to check only subarrays of length at most whichever the way you want The complexity is ,Let s compute an array of integers answers to all possible second type queries with Now if we have to perform any second type query we can split it into at most queries with and at most queries with Let s also compute an array of integers reverse permutation If then To perform any first type query we should recompute and We can swap and in the array and and in the array No more than elements will be changed in the array These are elements with indexes elements and elements We can recompute and then assign and times Similarly for Time complexity 
522,You are given an array of integer numbers Find the distance between two closest nearest minimums in it It is guaranteed that in the array a minimum occurs at least two times ,This task can be done by one array traversal Maintain current minimum value position of the last occurrence of current minumum distance between two occurrences of Now for each if then do For do In the end will be the global minimum of array and will keep the closest its occurrences Overall complexity ,At first let s reverse arrays and Now array is sorted in descending order Now let s find minimum index such that If there is no such index or if then the answer is because minimum on any prefix of array will never be equal to Otherwise let s find the minimum index such that If there is no such index or if then the answer is Also let s find the minimum index such that it can t be greater than The first subarray starts in position and ends in any position because if it ends in position or further then the minimum in the first subarray is greater than So there are ways to split subarrays and A similar approach can be used to calculate the number of ways to split the second and third subarrays and so on After all you have to check that minimum in the last subarray is equal to otherwise the answer is 
523,You are given string Let s call any largest sequence of consecutive symbols without symbols comma and semicolon For example there are four in string A word can be empty for example the string contains three empty words separated by You should find all in the given string that are nonnegative INTEGER numbers without leading zeroes and build by them new string String should contain all that are numbers separating them by the order of numbers should remain the same as in the string By all other you should build string in the same way the order of numbers should remain the same as in the string Here strings are INTEGER numbers but and are not For example for the string the string would be equal to and string would be equal to ,This is a technical problem You should do exactly what is written in problem statement ,For this problem you just need to implement what it asks you To be able to implement it you need to know about the if statement 
524,You are given a bracket sequence of length where is even divisible by two The string consists of opening brackets and closing brackets In one move you can choose and move it to the beginning of the string or to the end of the string i e you choose some index remove the th character of and insert it before or after all remaining characters of Your task is to find the minimum number of moves required to obtain from It can be proved that the answer always exists under the given constraints Recall what the regular bracket sequence is is regular bracket sequence if is regular bracket sequence then is regular bracket sequence if and are regular bracket sequences then is regular bracket sequence For example and are regular bracket sequences but and are not You have to answer independent test cases ,Let s go from left to right over characters of maintaining the current bracket balance for the position the balance is the number of opening brackets on the prefix till the th character minus the number of closing brackets on the same prefix If the current balance becomes less than zero then let s just take some opening bracket after the current position it obviously exists because the number of opening equals the number of closing brackets and move it to the beginning so the negative balance becomes zero again and the answer increases by one Or we can move the current closing bracket to the end of the string because it leads to the same result Time complexity ,Notice that it s never optimal to erase a subsequence of length greater than because every RBS of length above contains an RBS of length inside and removing it won t break the regular property of the outside one So the task can be solved for the round and the square brackets independently the answer will be the sum of both Let s solve the version for brackets and In general you just want to remove consecutive substring until there is no more left in the string That can be done by processing the string from left and right and maintaining a stack of current brackets If the top bracket in it is and the current bracket is then you can increment the answer and remove that bracket from the stack Otherwise you push the current bracket to the stack Overall complexity per testcase 
525,You came to a local shop and want to buy some chocolate bars There are bars in the shop th of them costs coins and you want to buy all of them You have different coupons that allow you to buy chocolate bars th coupon allows you to buy chocolate bars while you have to pay only for the most expensive ones so the cheapest bar of those bars is for free You can use only one coupon if you use coupon you have to choose bars and buy them using the coupon and buy all the remaining bars without any discounts To decide which coupon to choose you want to know what will be the minimum total amount of money you have to pay if you use one of the coupons optimally ,When using th coupon the bar we get for free should have at least bars not cheaper than it So if we consider sorted in non decreasing order then we cannot get discount greater than On the other hand we can always get such a discount if we pick most expensive bars to buy using the th coupon ,Let be the maximal segment of gold cups that begins in the cup Let be the maximum segment of gold cups that ends in the cup Also let the total number of gold cups be Note that it makes no sense to change the cups of the same color Then let s consider the silver cup which will change with the gold cup let its number be Then if then we will update the answer with the value and otherwise with the value This will not work if all the cups are golden In this case the answer is 
526,You are given a binary matrix of size A binary matrix is a matrix where each element is either or You may perform some possibly zero operations with this matrix During each operation you can inverse the row of this matrix or a column of this matrix Formally inverting a row is changing all values in this row to the opposite to to Inverting a column is changing all values in this column to the opposite Your task is to sort the initial matrix by some sequence of such operations The matrix is considered if the array is sorted ,The first observation if we have an answer where the first row is inverted we can inverse all rows and columns then the matrix will remain the same and the first row is not inverted in the new answer So we can suppose that the first row is never inverted Note that this will be true only for slow solution The second observation if we consider a sorted matrix its first row either consists only of s or has at least one and then all other rows consist only of s This observation can be extended to the following one user wrote a comment about it and I pinned the link to it above which can improve time complexity of the solution a lot in the sorted matrix either the first row consists only of s or the last row consists only of s the corner case is n 1 but for n 1 we can obtain both answers So what should we do with these observations I will explain a slow solution a faster solution can be obtained by mirroring one of cases of this one Let s iterate over the number of s in the first row Let it be cnt Then the first cnt elements of the first string should be s and all others should be s We can do it by inverting the columns with elements among first cnt elements of the first row and columns with elements among remaining elements So it s case handling time The first case when cnt m is pretty easy We have to check if all rows from 2 to n that they consist only of s or only of s and if some row consists of s then we should invert it If it is true then we found the answer Otherwise the first row consists only of s So we have to find the transitional row the row with some s on the prefix and s on the suffix or vice versa If the number of such rows among all rows from 2 to n is greater than 1 then this configuration is bad If the number of such rows is 1 then let idx be the index of this row Then we should inverse all rows above it consisting only of s and all rows consisting only of s below it And we have to check if the current row is really transitional We know that its sum is neither 0 nor m so there is at least one and at least in it If the first element is then let s inverse it Then we just should check if this row is sorted and if it is then we found the answer And the last case is if there are no transitional rows in the matrix Then we should invert all rows from 2 to n consisting only of s or only of s it does not matter So we have a solution with time complexity O n 3 Each number of s in the first row is processed in O n 2 and there are O n such numbers But we can see that if we apply the last case when the number of is m to the first row and then do the same but with the last row consisting of m we can get a solution in O n 2 ,In this problem you can implement an algorithm opposite to that given in the condition Let s maintain two pointers to the left most and right most unhandled element Then restoring the original array you put the left most unhandled item in the first position put the right most unhandled item in the second position put the left most unhandled item in the third position put the right most unhandled item in the fourth position That is in general you put the leftmost elements on all odd positions and the rightmost ones on all even positions After processing each element you either move the left pointer forward by one or the right one backward by one 
527,You are given a tree which consists of vertices Recall that a tree is a connected undirected graph without cycles Vertices are numbered from to All vertices have weights the weight of the vertex is Recall that the distance between two vertices in the tree is the number of edges on a simple path between them Your task is to find the subset of vertices with the maximum total weight the weight of the subset is the sum of weights of all vertices in it such that there is no pair of vertices with the distance or less between them in this subset ,Let s solve this problem using dynamic programming on a tree Suppose the tree is rooted and the root of the tree is Also let s increase to find the subset in which any pair of vertices had distance or greater instead of or greater Let be the maximum total weight of the subset in the subtree of if the vertex with the minimum depth we took has depth Then the answer is Firstly let s calculate this dynamic programming for all children of Then we are ready to calculate all for all from to Let the current depth be then there are two cases if then Otherwise let s iterate over all children of and let be such child of that the vertex with the minimum depth we took is in the subtree of Then After we calculated all values of for the vertex we can notice that this is not what we wanted The current value of means the maximum total weight of the subset in the subtree of if the vertex with the minimum depth we took has depth To fix this let s push to for all depths from to Time complexity but it can be easily optimized to using some prefix and suffix maximums You can ask why this is but not because we iterating over all vertices then over all possible depths and then over children of the vertex and again over children of the vertex But in fact this is because if we change the order of multiplication we can see that we are iterating over pairs parent child then over children and possible depths and the number of such pairs is so the complexity is ,Easy to see that the answer is equal to the answer over all sons of the root plus one Now let s solve the problem independently for each son of the root Let be the array of the depths of all leaves in the subtree of the vertex Let s sort Statement 1 it s profitable to lift the leaves in order of their appearing in Statement 2 denote the time of appearing the th leaf in the vertex let s consider the leaves and then Statement 3 where is the depth of the th leaf in the subtree of the vertex The last statement gives us the solution for the problem we should simply iterate over from left to right and recalculate the array by formula from the third statement All statements can be easily proved and it s recommended to do by yourself to understand better the idea of the solution 
528,You are given a chess board with rows and columns Initially all cells of the board are empty and you have to put a white or a black knight into each cell of the board A knight is a chess piece that can attack a piece in cell from the cell if one of the following conditions is met and or and Here are some examples of which cells knight can attack In each of the following pictures if the knight is currently in the blue cell it can attack all red cells and only them A is a pair of knights of colors such that these knights attack each other You have to put a knight a white one or a black one into each cell in such a way that the number of duels is maximum possible ,Let s denote a cell as if is even otherwise the cell is It s easy to see that if a knight is occupying a black cell then all cells attacked by it are white and vice versa Using this fact we can construct a solution where every pair of knights that attack each other have different colors put black knights into black cells and white knights into white cells so every pair of knights that can possibly form a duel actually form it ,This problem can be solved using dynamic programming with broken profile First of all we have to make the number of rows not larger than if it is larger then we can just rotate the given matrix Let s fill the matrix from left to right and in each column from top to bottom Let be the number of ways to achieve the following situation we now want to fill cell with index denotes the rows which are already protected in this column so there is a wall in this row or there is a guard to the left is a flag that denotes if current cell is protected by some guard above and is a flag that denotes if there was a cell that was not protected When advancing from one column to another we have to change the mask so we update the rows that are currently protected The rows such that in the previous column there was a wall in this row become un protected and the rows such that there is a wall in current column in this row become protected And of course becomes zero When we place a guard we set to one and make the corresponding row protected And when we are at the wall we have to set to zero so the guard from above doesn t protect next cell The answer is the sum of all values 
529,You are given the array consisting of positive greater than zero integers In one move you can choose two indices and such that the absolute difference between and is no more than one and remove the smallest of these two elements If two elements are equal you can remove any of them but exactly one Your task is to find if it is possible to obtain the array consisting of using several possibly zero such moves or not You have to answer independent test cases ,Firstly let s sort the initial array Then it s obvious that the best way to remove elements is from smallest to biggest And if there is at least one such that and then the answer is because we have no way to remove Otherwise the answer is ,At first let s solve this problem when m 1 and k 0 it is the problem of finding subarray with maximum sum For each position from 1 to n we want to know the value of maxl i max limits 1 le j le i 1 sum j i where sum l r sum limits k l k le r a k and sum x 1 x 0 We will calculate it the following way maxl i will be the maximum of two values 0 because we can take segments of length 0 a i maxl i 1 The maximum sum of some subarray is equal to max limits 1 le i le n maxl i So now we can calculate the values of best i max limits 0 le len i len cdot m ge 0 sum i len cdot m 1 i len k the same way best i is the maximum of two values 0 sum i m 1 i k best i m After calculating all values best i we can easily solve this problem At first let s iterate over the elements best i When we fix some element best i lets iterate over the value len 1 2 dots m and update the answer with value best i sum i len i 1 k 
530,Polycarp knows that if the sum of the digits of a number is divisible by then the number itself is divisible by He assumes that the numbers the sum of the digits of which is divisible by are also somewhat interesting Thus he considers a positive integer interesting if its sum of digits is divisible by Help Polycarp find the nearest larger or equal interesting number for the given number That is find the interesting number such that and is minimal ,Even if we will iterate over all possible numbers starting from and check if sum of digits of the current number is divisible by we will find the answer very fast The maximum possible number of iterations is no more than ,Suppose It means that is also divisible by or is divisible by And backward if then is also divisible by or is divisible by Since is divisible by and is divisible by so In other words we proved that Now knowing the equivalence above we can understand that we are looking for the smallest such that In other words we are searching such that is divisible by some where is some divisor of The problem is that there are a handful of divisors for some But we can note that we can consider only divisors of if and is composite then there is some prime thus It s easy to prove that there are no more than prime divisors of some Now the question is how to find all these prime divisors Note that if you know only one prime divisor for each value from to then you can find all prime divisors for all in The prime divisors are next and so on until The final step is to calculate a prime divisor for each value from to where or We can do it by slight modifications of Sieve of Eratosthenes at the step where you have some prime and want to throw out all values set for each plus set As a result we firstly calculate Sieve in and secondly calculate answer for each pair in Note that the input and output is large so you should you tricks to speed up your input and output 
531, You are given an array consisting of integers In one move you can choose any and divide it by rounding down in other words in one move you can set You can perform such an operation possibly zero number of times with Your task is to calculate the minimum possible number of operations required to obtain at least equal numbers in the array ,In this problem we need to write almost the same solution as in the previous one easy version but faster Observe that we calculate the value of too many times Let for all from to be the array of numbers of divisions we need to obtain from every possible from which we can We can calculate these arrays in time How Let s iterate over all and divide it by while it is positive and carry the number of divisions Then let s add to the array the number before each division Then we can see that we obtain the array from the tutorial of the previous problem for each from to Let s iterate over all possible values of and try to update the answer with the sum of smallest values of if there is at least elements in this array Time complexity or depends on sorting method ,Let s write our unique function Keep the array of the taken elements Iterate over all elements in the array and if the current element is not used then add its index to the answer and set When finished check the number of distinct values that is the size of answer array If it is less than print Otherwise print and output the first elements of the answer 
532,During their New Year holidays Alice and Bob play the following game using an array of integers Players take turns Alice moves first Each turn a player chooses any element and removes it from the array If Alice chooses then she adds it to her score If the chosen value is odd Alice s score does not change Similarly if Bob chooses then he adds it to his score If the chosen value is even then Bob s score does not change If there are no numbers left in the array then the game ends The player with the highest score wins If the scores of the players are equal then a draw is declared For example if and then the game could go as follows there are other options On the first move Alice chooses and get two points Her score is now The array is now On the second move Bob chooses and get five points His score is now The array is now On the third move Alice chooses and get no points Her score is now The array is now On the last move Bob chooses and get three points His score is now The array is empty now Since Bob has more points at the end of the game he is the winner You want to find out who will win if both players play optimally ,Let s look at an analogy for this game If Alice takes an even number she adds points to the global result otherwise If Bob takes an odd number he adds points to the global result otherwise Alice wants to maximize the global result and Bob wants to minimize it Obviously this game is completely equivalent to the conditional game Suppose now it s Alice s move Let s look at some number in the array If this number is even then taking it will add points and giving it to Bob will add points If this number is odd then taking it will add points and giving it to Bob will add points So taking the number by points is more profitable than not taking it regardless of the parity To maximize the result Alice should always take the maximum number in the array Similar reasoning can be done for Bob In the task it was necessary to sort the array and simulate the game ,First of all let s understand how to solve the problem without upgrades To do this it is enough to compare two numbers and the number of attacks that the character needs to kill the monster and the number of attacks that the monster needs to kill the character respectively So if the first number is not greater than the second number then the character wins Note that the number of coins is not very large which means we can iterate over the number of coins that we will spend on weapon upgrades and the remaining coins will be spent on armor upgrades After that we can use the formula described above to check whether the character will win The complexity of the solution is 
533,You are given array with integers and queries The th query is given with three integers For the th query find any position so that ,This problem can be solved differently For example you can use some data structures or sqrt decomposition technique But it is not required We expected the following simple solution from the participants Let s preprocess the following values the position of the first element to the left from the th element such that Now to answer to the query we should check if then we have the answer Otherwise we should check the position ,Make a copy of the array s call it t Sort t in non decreasing order so that t 1 is the maximum strength and t 2 the second maximum strength Then for everyone but the best person they should compare with the best person who has strength t 1 So for all i such that s i neq t 1 we should output s i t 1 Otherwise output s i t 2 the second highest strength which is the next best person 
534,Polycarp has prepared competitive programming problems The topic of the th problem is and some problems topics may coincide Polycarp has to host several thematic contests All problems in each contest should have the same topic and He may not use all the problems It is possible that there are no contests for some topics Polycarp wants to host competitions on consecutive days one contest per day Polycarp wants to host a set of contests in such a way that number of problems in each contest is as much as in the previous contest one day ago the first contest can contain arbitrary number of problems the total number of problems in all the contests should be maximized Your task is to calculate the maximum number of problems in the set of thematic contests Note that you should not maximize the number of contests ,The first thing we don t need the problems we need their counts So let s calculate for each topic the number of problems with this topic and sort them in non decreasing order The counting can be done with or another one sorting The second thing the answer is not exceed very obviously So let s iterate over the number of problems in maximum by the number of problems thematic contest Now we have to calculate the maximum number of problems we can take in the set of thematic contests Let s do it greedily The number of contests in the set don t exceed Let the number of problems in the current contest be at the beginning of iteration the current contest is the maximum by the number of problems Let s take the topic with the maximum number of problems for this contest If we cannot do it stop the iteration Otherwise we can maybe continue the iteration If is even then divide it by and continue with the rest of topics otherwise stop the iteration Which topic we have to choose for the second one contest The answer is the topic with the maximum number of problems which isn t chosen already So let s carry the pointer initially it is at the end of the array of counts and decrease it when we add another one contest to our set All calculations inside the iteration are very obviously Let s notice that one iteration spends at most operations So overall complexity of the solution is The last question is why can we take the maximum by the number of problems topic each time Suppose we have two contests with numbers of problems and correspondingly Let s consider the case when Let the number of problems of the first contest topic be and the number of problems of the second contest topic be The case don t break our assumptions The only case which can break our assumptions is So if it is then we can swap these topics because and and all will be okay So this greedy approach works ,In this problem you should simply check the conditions from the problem statement 
535,You are given a positive number Find the smallest positive integer number that has the sum of digits equal to and all digits are unique ,First of all let s understand that the answer to the problem should not contain zeros leading zeros are useless while others increase the number but do not change the sum It is also clear that the number we found should have the minimum possible length since the longer the numbers without leading zeros the larger they are Numbers of the same length are compared lexicographically that is first by the first digit then by the second and so on This means that the digits in the number must go in sorted order the order of the digits does not affect the sum but does affect the value Let s minimize the length of the number first We need to get the specified sum in as few digits as possible So we should use as large digits as possible Then let s start with the number 9 and add the digits from 8 to 1 to the beginning of the number in turn until the sum of the digits exceeds the specified sum Obviously you can t get an answer for fewer digits Now we minimize the number itself First we must minimize the first digit The first digit is uniquely determined as the difference between the sum of the remaining digits and the required sum So you need to maximize the sum of all digits except the first one which has already been done in the previous paragraph It only remains to correct the first digit and print the answer ,We need to check if the sum of the first three digits is equal to the sum of the last three digits This is doable by scanning the input as a string then comparing the sum of the first three characters with the sum of the last three characters using the if statement and the addition operation 
536,Polycarp has an integer that doesn t contain the digit He can do the following operation with his number several possibly zero times Reverse the prefix of length in other words leftmost digits of So the leftmost digit is swapped with the th digit from the left the second digit from the left swapped with th left etc For example if and then the new value of will be Note that for different operations the values of can be different The number can be equal to the length of the number in this case the whole number is reversed Polycarp loves even numbers Therefore he wants to make his number even At the same time Polycarp is very impatient He wants to do as few operations as possible Help Polycarp Determine the minimum number of operations he needs to perform with the number to make it even or determine that this is impossible You need to answer independent test cases ,If the number is already even then nothing needs to be done so the answer in this case is Now let s recall the divisibility by a number is divisible by if and only if its last digit is divisible by It follows that if there are no even digits in our number then the answer is Let s take a look at our operation What is going on The first digit always changes with the digit numbered In particular when we reverse the entire number the first digit is swapped with the last Note that no other digit except for the first one at the current moment can t be the last Therefore you can do this if the first digit of a number is divisible by then we reverse the whole number The first digit will become the last and the number will become even Therefore you only need to do one operation Now what if the first digit of a number is odd In this case we can find the first even digit in the number let it be at position and reverse the prefix of length in one operation Now the first digit of our number has become even and we can use the previous case one more operation Thus we will do only operations ,Let s iterate over all pairs of digits in the number Let the first digit in the pair be at position and the second at position Let s place these digits to the last two positions in the number The first greedily goes to the last position and then the second goes to the position next to that Now the number can contain a leading zero Find the leftmost non zero digit and move it to the first position Then if the current number is divisible by try to update the answer with the number of swaps It is easy to show that the number of swaps is minimal in this algorithm The only difference we can introduce is the number of times digit digit and the leftmost non zero digit swap among themselves And that is minimized You can also notice that the order of swaps doesn t matter and you can rearrange them in such a way that no leading zero appears on any step This solution has time complexity You can also solve this problem with complexity because you have to check only four options of the two last digits It is always optimal to choose both rightmost occurrences of the corresponding digits You can show that even if you are required to swap the chosen ones there will be no other pair with smaller total amount of moves 
537,You are given two integers and Consider a regular polygon of vertices Recall that a regular polygon is a polygon that is equiangular all angles are equal in measure and equilateral all sides have the same length Examples of convex regular polygons Your task is to say if it is possible to build another regular polygon with vertices such that its center coincides with the center of the initial polygon and each of its vertices is some vertex of the initial polygon You have to answer independent test cases ,The answer is if and only if is divisible by because if you number all vertices of the initial polygon from to clockwise then you need to take every vertex divisible by and this number obviously should be integer and there is no other way to construct the other polygon ,The problem is about counting the number of some combinatoric objects Thus dynamic programming is always the answer Let be the number of bicolorings of the first columns such that components are already created and can t be modified and the colors of the th column are determined by its first bit is the color of the lower cell and its second bit the color of the upper cell Component can be modified if the cell from the th column belongs to it The initial states are for each and for any other state You should iterate over the possible for the next column and recalculate the number of components You can easily show that the current number of components and the last column is actually enough to get the new number of components In my code I have some function to determine the added number of components while transitioning from to These are just the couple of cases to handle carefully Then all the transitions are However the last column won t contain the answer as it is the number of components will be incorrect Let s add some dummy column equal to for each This will add all the real component to the total number So the answer is the sum of over all Overall complexity where is the number of rows 2 for this problem 
538,Polycarp has a string Polycarp performs the following actions until the string is empty is initially an empty string he adds to the right to the string the string i e he does where is a concatenation of the strings and he selects an arbitrary letter of and removes from all its occurrences Polycarp performs this sequence of actions in this order Note that after Polycarp finishes the actions the string will be empty and the string will be equal to some value that is undefined and depends on the order of removing E g consider so the actions may be performed as follows the letter is selected then the letter is selected then the letter is selected then the empty string You need to restore the initial value of the string using only the final value of and find the order of removing letters from ,Suppose it s given a string for which the answer exists Consider the last non empty value of Only letter occurs in the value and the letter is the last removed letter At the same time the value of is a suffix of so the last character of is the last removed letter Consider the second last non empty value of It contains exactly distinct letters so that one of them is the last removed letter and the other is the second last removed letter The concatenation of the second last and the last values of is a suffix of consisting only of the letters Therefore the letter which occurrence is the last of the occurrences of all letters except the last removed one is the second last removed letter Considering so other values we are proving that the order of removing the letters is the order occurrences of the letters occur in the string Suppose is the number of the step in which some letter was removed is the number of occurrences of the letter in the value of The letter occurs in exactly different values of In each of them the letter occurs exactly times So the letter occurs in exactly times Therefore using the number of the step in which the letter was removed and the number of the letter s occurrences in let s calculate the number of the letter s occurrences in the string If isn t completely divisible by there s no solution The sum of all of all letters occurring in is the length of the initial value of Since the initial value is a prefix of the possible answer is the prefix of having the length equal to the sum of all Before outputting the prefix check that you can get from the supposed value of the string the string Checking it you may use the algorithm from the statement If the resulting string is equal to the answer is correct and must be outputted otherwise there s no solution ,The statement literally asks for the longest subsequence which looks like Let s find out how many zeroes will be in this sequence and then take all ones which come after the last zero On each step take the next zero from the beginning of the sequence and count ones after it Update answer with the maximum value You can precalc number of ones on suffix with partial sums but it was not necessary in this task Overall complexity naively or with partial sums 
539,You are given a square grid with rows and columns Each cell contains either or In an operation you can select a cell of the grid and flip it from or Find the minimum number of operations you need to obtain a square that remains the same when rotated and The picture below shows an example of all rotations of a grid ,Let s rotate the grid by and and mark all cells that map to each other under these rotations For example for and grids mirror grid must have the following patterns the same letters denoting equal values In general we can rotate the grid by and and see which cells need to have equal values by seeing the positions which each cell maps to Now to solve the problem we consider each equal value each of the letters in the above figures independently and consider the minimum number of moves to make them all or all The answer is the total across all values See the implementation for better understanding The time complexity is per testcase ,I am sorry that some solutions pass tests in this problem also I was supposed to increase constraints or decrease time limit The general idea of this problem is the same as in the previous problem But now we should do all what we were doing earlier faster The solution is divided by two parts The first part Let s calculate four matrices of size and will denote the distance to the nearest dot character to the top from the current position The same will denote the distance to the nearest dot character to the bottom from the current position to the left and to the right We can calculate all these matrices in using easy dynamic programming If we will iterate over all possible from to and from to we can easy see the next if the current character is dot then Otherwise if then and if then Rest two matrices can be calculated the as well as these two matrices but we should iterate over all from to and from to So this part of the solution works in After calculating all these matrices the maximum possible length of rays of the with center in position is The second part is to draw all in Let s calculate another two matrices of size and Let s iterate over all in our answer Let the center of the current is and its size is Let s increase by one and decrease by one if The same with the matrix Increase and decrease if Then let s iterate over all possible from to and from to If then set and if set How to know that the character at the position is asterisk character or dot character If either or greater than zero then the character at the position in our matrix will be the asterisk character Otherwise it is the dot character This part works also in Time complexity of the solution 
540,You are given three integers and Determine if one of them is the sum of the other two ,You only need to write an if statement and check if any of these are true ,The answer is always or Why it is so Because if there is no such pair among all students that then we can take all students into one team Otherwise we can divide them into two teams by their programming skill parity 
541,Paul and Mary have a favorite string which consists of lowercase letters of the Latin alphabet They want to paint it using pieces of chalk of two colors red and green Let s call a coloring of a string wonderful if the following conditions are met each letter of the string is either painted in exactly one color red or green or isn t painted each two letters which are painted in the same color are different the number of letters painted in red is equal to the number of letters painted in green the number of painted letters of this coloring is among all colorings of the string which meet the first three conditions E g consider a string equal to One of the wonderful colorings of the string is shown in the figure Paul and Mary want to learn by themselves how to find a wonderful coloring of the string But they are very young so they need a hint Help them find the number of red or green these numbers are equal letters in a wonderful coloring ,Let s calculate the number of letters which occur exactly once in the string and letters that occur more than once and respectively If a letter occurs more than once one of its occurrences may be painted in red and another one may be painted in green We cannot paint all other occurrences because there will be two equal letters painted in one color but this is unacceptable by the statement So there are no more than occurrences of letters that occur more than once to be painted in red Let s select such occurrences and paint them We need to paint additionally the letters which occur exactly once by meeting the same conditions as we meet painting the whole string There s no way to paint these letters and not meet the first two conditions So we must select the maximal count of the letters so that we will be able to paint some set of remaining letters in green so that the number of red letters will be equal to the number of green letters This number is equal to So the final answer is equal to ,Every beautiful set can be represented as a sequence of its elements in sorted order Let these elements for some set be also let When the set is beautiful every is an integer greater than It s easy to see that if and belong to the whole set belongs to Since in order to maximize we need to choose and as small as possible So why don t we choose and every This will allow us to calculate the maximum possible size of a beautiful set let be this maximum possible size Okay what about counting those sets The claims and that every are no longer true by default However there are some constraints on Firstly every If we had some value of we could replace it with two values of and the size of the set would increase Secondly there is at most one If there are two values we could replace them with three and the size of the set would increase as well So the sequence contains at most one value and the rest of the values are We will divide the sets we want to count into two categories the ones with all and the ones with one value To count the sets in the first category we simply need to count the number of different minimum values in those sets Those minimum values have to be such that multiplying them by wouldn t make them greater than so these are all integers from the segment For every such integer there exists exactly one set of the first category To count the sets in the second category we do a similar thing The minimum value in the set should be from the segment but for every integer from this segment there are different sets of the second category since there are ways to choose which is equal to 
542,You are given an array Array is good if for each pair of indexes the condition holds Can you shuffle this array so that it becomes good To shuffle an array means to reorder its elements arbitrarily leaving the initial order is also an option For example if then shuffled arrays and are good but shuffled arrays and aren t It s guaranteed that it s always possible to shuffle an array to meet this condition ,Let s sort array in non ascending order In this case for each pair of indexes the condition holds ,Consider every cyclic shift of the array Suppose that now the array starts from the position the first element is and the last element is Assume that before the position our dog reached her minimum possible position and now the minimum position will not change So our problem is to fill all zeros in the array in such a way that the maximum prefix sum of is the maximum possible and the total sum of is zero For simplicity consider the array which is the th cyclic shift of i e the first element is the second element is and so on Let s iterate from left to right and maintain the current sum of the array Let this variable be Now when we meet we should replace it with the maximum possible value we can because in such a way we will increase the maximum number of prefix sums Let be the number of zeros in starting from the position This value can be calculated in advance in for every cyclic shift using suffix sums Then the segment of positions we can have at the end is and we want to place the maximum possible value in in such a way that this remaining segment with addition of our current element will cover This maximum value equals If becomes less than then this cyclic shift is invalid and we should skip it Otherwise let s add to and proceed If there are no values then we placed anything correctly Now can just simulate the movements of our dog to find the answer for the current cyclic shift But there are cases when do not contain zeros so these cases should be handled somehow I just checked that after simulation we returned to If we returned to we can update the answer as the difference between the maximum and the minimum positions plus one If there is no valid cyclic shift then the answer is Time complexity 
543,You are given three integers and Your task is to construct a binary string of length such that there are exactly zeroes exactly ones and exactly indices where such that It is guaranteed that the answer always exists For example for the string there are four indices such that and For the string there are two such indices Recall that binary string is a non empty sequence of characters where each character is either or ,This problem has several general cases x is even and a b then the answer is repeated frac x 2 times then b frac x 2 ones and a frac x 2 zeroes x is even and a le b then the answer is repeated frac x 2 times then a frac x 2 zeroes and b frac x 2 ones x is odd and a b then the answer is repeated lfloor frac x 2 rfloor times then a lfloor frac x 2 rfloor zeroes and b lfloor frac x 2 rfloor ones x is odd and a le b then the answer is repeated lfloor frac x 2 rfloor times then b lfloor frac x 2 rfloor ones and a lfloor frac x 2 rfloor zeroes I am sure that there are other more beautiful solution but for me the easiest way to solve this problem is to extract general cases and handle it Overall complexity is O a b , can be arbitrarily large if and only if at least half of the numbers in the array are the same In this case we can choose any number and subtract it from all numbers for example exactly once Let s iterate over the element it will be the minimum among the numbers that we want to make the same Let s calculate the number of numbers in the array that are equal to this element If this number is at least then the answer is Otherwise we will iterate over numbers which are strictly greater than the selected minimum and for each number we will iterate over the divisors of the number For each of the found divisors let s calculate the number of for which this divisor was found Among all such divisors for which the sum of the found number and the number of numbers equal to is greater than or equal to we will choose the maximum one The greatest found divisor will be the desired This solution works in where is the absolute value of the maximum on the array 
544,You are given a board of size rows columns Some cells of the board contain chips The chip is represented as and an empty space is represented as It is guaranteed that there is at least one chip on the board In one move you can choose chip and move it to any adjacent by side cell of the board if this cell is inside the board It means that if the chip is in the first row you can move it left right or down but it shouldn t leave the board Same if the chip is in the second row you can move it left right or up If the chip moves to the cell with another chip the chip in the destination cell disappears i e our chip captures it Your task is to calculate the number of moves required to leave one chip on the board You have to answer independent test cases ,Firstly I want to say a few words about the difficulty of this problem Till the last moment we didn t know easy to prove and easy to write solutions so we decided that this is a good problem E But now we realized it is a lot easier than we expected Now let s talk about the solution At the beginning let s remove redundant columns from the beginning and from the end i e columns without chips and change the value correspondingly Now let be if is and otherwise This array needed to make the implementation easier Let s calculate the dynamic programming where is the index of the last processed column and is the number of the row where our chip is standing This seems a bit suspicious why we can calculate such a dynamic programming so let s explain some things about it It can be shown that in the optimal answer there will be some column where the last move happens And if the number of this column is then all chips to the left of will move only to the right and all chips to the right of will move only to the left Actually we can always consider that is the last column Consider paths of two chips that will survive till the last move The first chip is to the left of and will move only to the right and the second one is to the right of and will move only to the left Then we can replicate the path of the second chip in the reverse order using the first chip So the second chip can stay still until the last move In the optimal answer it is always better to have exactly one chip in the current column because moving two chips to the right is always worse than just eat one of them and move the remaining one Initial states of are except the values of the first column For the first column and The answer will be Okay how to make transitions from For all from to let s consider four cases here we need one move to go to the next column and probably one more move to delete the figure in the second row in the column So the transition seems like same as the previous transition because the cost of this transition is always the distance between these cells is we just go firstly to the right and then down to ensure that we eat the figure in the first row So the transition is same as the previous transition Time complexity ,Let s rotate the grid by and and mark all cells that map to each other under these rotations For example for and grids mirror grid must have the following patterns the same letters denoting equal values In general we can rotate the grid by and and see which cells need to have equal values by seeing the positions which each cell maps to Now to solve the problem we consider each equal value each of the letters in the above figures independently and consider the minimum number of moves to make them all or all The answer is the total across all values See the implementation for better understanding The time complexity is per testcase 
545,One day ZS the Coder wrote down an array of integers with elements A subarray of the array is a sequence for some integers such that ZS the Coder thinks that a subarray of is beautiful if the bitwise xor of all the elements in the subarray is at least Help ZS the Coder find the number of beautiful subarrays of ,The sign is used for the binary operation for bitwise exclusive or Let be the xor of the first elements on the prefix of Then the interval is beautiful if Let s iterate over from to and consider the values as the binary strings On each iteration we should increase the answer by the value the number of numbers so To do that we can use the trie data structure Let s store in the trie all the values for Besides the structure of the trie we should also store in each vertex the number of leaves in the subtree of that vertex it can be easily done during adding of each binary string To calculate the value let s go down by the trie from the root Let s accumulate the value equals to the xor of the prefix of the value with the already passed in the trie path Let the current bit in be equal to and be the depth of the current vertex in the trie If the number then we can increase by the number of leaves in vertex because all the leaves in the subtree of tha vertex correspond to the values that for sure gives After that we should go down in the subtree Otherwise if then we should simply go down to the subtree and recalculate the value ,Let s calculate for each position position the closest greater from the right element to and add directed edge from to Then we will get oriented forest or tree if we d add fictive vertex where all edges are directed to some root So we can look at current subsegment we need to calculate the answer for as at a number of marked vertices in the tree Then the answer itself is a longest path up to the tree consisting only from marked vertices Key observation is next if and are marked and is an ancestor of then any vertex on path from to is also marked So the longest path up to the tree consisting only from marked vertices has length equal to a number of marked vertices on path to the root And we have three types of queries mark a vertex unmark a vertex and calculate maximum number of marked vertices among all paths to the root It can be done with Segment Tree on Euler Tour of the tree if we calculate and for each vertex in dfs order then marking unmarking is just adding to a segment and maximum among all paths is a maximum on the whole tree Result time complexity is and space complexity is 
546,You are given a directed graph consisting of vertices and edges each edge is directed so it can be traversed in only one direction You are allowed to remove at most one edge from it Can you make this graph acyclic by removing at most one edge from it A directed graph is called acyclic iff it doesn t contain any cycle a non empty path that starts and ends in the same vertex ,The constraits are set in such a way that naive solution won t pass unmark every edge one by one and check if graph of marked edges doesn t contain cycles with dfs bfs Thus we should somehow limit the number of edges to check Let s take arbitrary cycle in graph Do dfs store the vertex you used to travel to any other vertex and restore edges with this data if cycle is met With this algo length of cycle will not exceed Then do the naive algo but check only edges from this cycle Overall complexity ,If we distribute costs optimally then this pair of paths a rightarrow b and b rightarrow c can look like just a straight path that doesn t visit the same vertex twice or like three straight paths with one intersection point x The first case is basically a subcase of the second one with the intersection point a b or c So if we fix the intersection point x then these two paths a rightarrow b and b rightarrow c become four paths a rightarrow x x rightarrow b b rightarrow x and x rightarrow c We can notice that each path we denoted should be the shortest possible because if it isn t the shortest one then we used some prices that we couldn t use Let the length of the shortest path from u to v be dist u v Then it is obvious that for the fixed intersection point x we don t need to use more than dist a x dist b x dist c x smallest costs Now we want to distribute these costs between these three paths somehow We can see that the path from b to x is used twice so it is more optimally to distribute the smallest costs along this part So let pref i be the sum of the first i smallest costs just prefix sums on the sorted array p Then for the intersection point x the answer is pref dist b x pref dist a x dist b x dist c x if dist a x dist b x dist c x le m We can calculate distances from a b and c to each vertex with three runs of bfs Time complexity O m log m 
547,You have a string a sequence of commands for your toy robot The robot is placed in some cell of a grid He can perform four commands W move one cell up S move one cell down A move one cell left D move one cell right Let be the grid of minimum possible area such that there is a position in the grid where you can place the robot in such a way that it will not fall from the grid while running the sequence of commands For example if then is the grid you can place the robot in the cell the robot performs the command D and moves to the robot performs the command S and moves to the robot performs the command A and moves to the robot performs the command W and moves to the robot performs the command W and moves to the robot performs the command A and moves to the robot performs the command W and moves to You have extra letters one W one A one S one D You d like to insert in any position of sequence to minimize the area of What is the minimum area of you can achieve ,The problem asks us to maintain the bounding box while inserting the character of one of types between every adjacent characters in Of course we can do it but do we really to do it in such way Let s think a little Inserting W or S doesn t affect the width of the bounding box and A or D doesn t affect the height So they are absolutely independent And we can divide our WASD string on WS string and AD string Moreover inserting W or S in WS string and A or D in AD string is almost same thing so we don t even need to write different code for different string How to handle only WS string Let s replace W as and S as and suppose that we started in position Then the position where we go after commands is just prefix sum of first elements Then the length of the bounding box is maximum position minimum position 1 The maximum minimum position is a maximum minimum element in array of prefix sums What the inserted value do It add to suffix of Let s choose for example The can t decrease the maximum but can increase the minimum so we need to place it somewhere before all minimums in or before the first minimum But if we place it before any of maximum elements then we will increase it and prevent decreasing the length of bounding box So we need to place somewhere after all maximums on or after the last maximum And here goes the solution find position of the first minimum in and position of the last maximum If then we can insert and decrease the length of bounding box but since we insert command that move robot we can t achieve bounding box of length What to do with Just multiply by and now we can insert instead of in absolutely same manner What to do with AD string Denote A as and D as and everything is absolutely the same ,It is easy to see that any garland has one of the following patterns We can hard code all all this patterns or iterate over all these permutations of letters using three nested loops or standard language functions We can calculate for each pattern the cost to obtain such pattern from the given string and choose one with the minimum cost 
548,Given an array of positive integers Find the maximum value of such that and are coprime or if no such exist For example consider the array The maximum value of that can be obtained is since and are coprime Two integers and are coprime if the only positive integer that is a divisor of both of them is that is their greatest common divisor is ,Note that the array has at most distinct elements since For each value store the largest index it is in Then we can brute force all pairs of values and find the coprime pair with largest sum of indices The time complexity is per testcase ,Firstly if the array already has an odd sum the answer is Otherwise we need to change the parity of the sum so we need to change the parity of some number We can do in only when we have at least one even number and at least one odd number Otherwise the answer is 
549,There are two sisters Alice and Betty You have candies You want to distribute these candies between two sisters in such a way that Alice will get candies Betty will get candies each sister will get some number of candies Alice will get a greater amount of candies than Betty i e all the candies will be given to one of two sisters i e Your task is to calculate the number of ways to distribute exactly candies between sisters in a way described above Candies are indistinguishable Formally find the number of ways to represent as the sum of where and are positive integers and You have to answer independent test cases ,The answer is where is rounded down ,Let s rewrite the original equality a bit a j a i j i a j j a i i Let s replace each a i with b i a i i Then the answer is the number of pairs i j such that i j and b i b j To calculate this value you can use or sorting 
550,A palindrome is a string which reads the same backward as forward formally for all Here denotes the length of a string For example the strings and are palindromes You have binary strings each consists of zeroes and or ones You can swap any pair of characters any number of times possibly zero Characters can be either from the same string or from different strings there are no restrictions Formally in one move you choose four integer numbers such that and and where and are string indices and and are positions in strings and respectively swap exchange the characters and What is the maximum number of strings you can make palindromic simultaneously ,Let s make several observations At first note that the lengths of the strings doesn t change At second note that if the string has even length then being palindromic is the same as having even number of zeroes and even number of ones But if the string has odd length then it always is palindromic So the question is how to fix bad strings with even length but with odd number of zeroes and ones If we have at least one string with odd length then you can trade between bad string and odd string either zero to one or one to zero fixing the bad string Otherwise you can fix two bad strings swapping appropriate characters In result we can either make all strings palindromic or all strings except one in case of absence of odd strings and having odd number of bad strings ,Yes authors also implemented hashes Note that if substrings and are isomophic then position of first encounter of some character in must be position of first encounter of some character in More over if we sort all positions for all distict characters in and sort all positions for then must be equal for any This observation gives us fact that So to check isomorphism of and we need check for each that positions of all encounters of character equal to posistions of all encounters of character To do that we can generate for each character boolean array with checked positions of its encounter and calculate prefix hashes on this arrays Also we need precalculate order of first encounters for each suffix of string To do it fast note that in transition from to only can change its relative order Result complexity is with quite big constant from hashing 
551,Alice and Bob got very bored during a long car trip so they decided to play a game From the window they can see cars of different colors running past them Cars are going one after another The game rules are like this Firstly Alice chooses some color then Bob chooses some color After each car they update the number of cars of their chosen color that have run past them Let s define this numbers after th car and If for every then the winner is Alice If for every then the winner is Bob Otherwise it s a draw Bob knows all the colors of cars that they will encounter and order of their appearance Alice have already chosen her color and Bob now wants to choose such color that he will win the game draw is not a win Help him find this color If there are multiple solutions print any of them If there is no such color then print ,Let s maintain the current availability of colors and the amounts of cars of each color Firstly color is never available When car of some color goes you check if the number of cars of color past before this one isn t smaller than the number of cars of color Only after that increment the amount by one If it was less then set its availability to false If car of color goes then simply increment its amount In the end iterate over all colors and check if it s both available and has higher or equal amount than the amount of cars of color Okay why this works As all the amounts cannot decrease color will become not available at some moment when car of color goes And this will be encountered either when the new car of color goes or in the end of the sequence Amount of cars of color doesn t update between this periods And if there was point when there became more cars of color than of color then this inequality will hold until the next moment we will check Overall complexity ,Easy to see that we can paint with both colours only tiles with the numbers multiple of Obviously that tiles should be painted with more expensive colour So the answer equals to 
552,You are given two binary strings and which are binary representations of some two integers let s denote these integers as and You can choose any integer calculate the expression and write the binary representation of in let s denote it as For example let and you ve chosen and since so and For given and you need to choose such that is read notes if you don t know what does lexicographically means It s guaranteed that with given constraints exists and is finite ,Multiplying by power of is shift left binary operation you probably should know it Reverse and for the simplicity and look at leftmost in let s denote its position as If you move it to in then you make the lexicographically bigger than the reverse of So you should move it to in too You can choose any with position Let be the minimum position of in such that You must move to otherwise the in still be present in and it will be not optimal So the solution is next reverse and find find print ,Let s compute the answer to the array where is the digit at the position in the number we are looking for Let be the position of the last digit in number be the position of the last digit in number Then denote and consider the cases if then the sum of was exactly then if then the sum was greater than and we need to look at the next digit of the number If there isn t one we can t get the answer we ll output Otherwise we recalculate and reduce by one if now and then Otherwise we deduce since we cannot get more than when adding two digits and the cases where have already been considered before After considering the cases reduce and by one and repeat the checks as long as or In the situation where but we will still have uncheked digits of number so we will also output Otherwise we output an array with the answer without leading zeros 
553,You are given an integer In move you can do one of the following actions erase any digit of the number it s acceptable that the number before the operation has exactly one digit and after the operation it is empty add one digit The actions may be performed in any order any number of times Note that if after deleting some digit from a number it will contain leading zeroes they will be deleted E g if you delete from the number the digit the result is the number not You need to perform the number of actions to make the number any power of i e there s an integer such that the resulting number is equal to E g consider The answer is equal to First let s add to the right one digit the result will be Then let s erase the digit so the result will be which is a power of E g consider The answer is equal to Let s erase any of the digits three times The result will be which is a power of ,Suppose we must turn into some number In this case we can use the following greedy algorithm Consider the string forms and of the numbers and respectively Let s make a pointer pointing at the first character of the string and a pointer pointing at the first character of the string Let s initialize a variable in which we will store a number of selected characters Until any of the pointers points at the place that is out of the corresponding string let s do the following procedure if the characters to which the pointers point are equal we will take the character increase by and move both pointers character to the right otherwise the only action we must perform is to move character to the right The variable will contain after the whole process the length of the longest subsequence of equal to a prefix of i e the maximum number of original characters of that we will not erase We must add to the resulting string all remaining characters of to turn it into Therefore we must erase digits and add digits so the answer for this subproblem is where means the length of a string Suppose we have a set of powers of two such that it s enough to consider to get the problem s answer The problem can be solved as follows for each let s calculate the answer for the subproblem described above and select the value of as the answer What set of powers of two we can take Suppose the number consists of no more than digits The answer for each consisting of digits doesn t exceed hence we can get this value by turning the number into in move adding to the right of the number and erasing all other digits Suppose there s a number such that So it consists of no more than digits this value can be reached as follows we must not erase any digit and add digits Therefore if each number such that consists of no more than digits hence Suppose consists of more than digits Then because according to the input format The answer for the number doesn t exceed we can get this answer if we erase all from the number to turn it into Suppose there s a number such that This number can consist of no more than digits digits of plus digits hence Therefore it s enough to consider all powers of two that are less than ,There are multiple ways to solve this problem Most interpreted languages have some function that takes the string evaluates it as code and then returns the result One of the examples is the function in Python If the language you use supports something like that you can read the input as a string and use it as the argument of such a function Suppose you use a language where this is impossible There are still many approaches to this problem The most straightforward one is to take the first and the last characters of the input string calculate their ASCII codes and then subtract the ASCII code of the character from them to get these digits as integers not as characters Then you can just add them up and print the result 
554,You are given an array consisting of integers Let be the minimum value among and be the maximum value among Your task is to choose three greater than integers and such that In other words you have to split the array into three consecutive non empty parts that cover the whole array and the maximum in the first part equals the minimum in the second part and equals the maximum in the third part or determine it is impossible to find such a partition Among all such triples partitions you can choose any You have to answer independent test cases ,Let s fix the length of the first block iterate through i from 0 to n 3 Let s also try to maximize the length of the third block using the second pointer So initially the length of the first block is 1 and the maximum in the block is a 0 after that its length will be 2 and the maximum will be max a 0 a 1 and so on Let s move the left border of the third block r while a r le a 0 and the second block have at least one element After we expanded the third block consider some cases if its maximum is less than a 0 then we don t need to consider this partition we expanded the third block as much as we can but didn t find the required maximum Otherwise its maximum fits our conditions Then let s find the minimum in the second block Let it be mn If mn mx this partition is also bad If mn mx this partition is good and we can just print it Otherwise mn mx and we need to fix the second block somehow I claim that we only need to expand it by at most one element Let s see why is it true Consider we want to expand it to the right the other case just uses the same logic If we expanded our block by one element to the right and the new value in it is less than mx then this partition is bad and we can not use it this is also the reason why we are trying to maximize the length of the third block Otherwise this value is always mx because the first and the third blocks didn t have values greater than mx There are some cases in the implementation we need to consider carefully first we need to find the minimum in the second block fast enough This can be done if we store it as a multiset set with repetitions Second we can remove the only maximum in the third or the first block by expanding the second one This can be handled easily if we just store all three blocks not only the second one as multisets And the last case is that we sometimes need to move the left border of the third block to the right This happens when we expand the first block and the second block becomes empty So this happens only O n times in total Total time complexity of this solution is O n log n There is also another solution from Gassa Let us start solving by asking the following question in which segments will the maximal values end up Consider the maximum value m in the whole array If there are at least three of them a valid answer is to pick any maximum except the first and the last as the middle segment For example m 3 can be partitioned as or as where the middle segment is marked with square brackets Otherwise all m should end up in the middle segment so that maximums to the left and to the right are less For example in we have to put both threes into the middle segment Let us now calculate the minimum value v on the middle segment considering the numbers between those equal to m For example in the value v min 3 1 3 1 All numbers greater than v should also go into the middle segment and everything between them which can result in v decreasing even more We have to expand the borders of the middle segment until the minimum value is such v that there are only values not greater than v left outside Continuing with the example we see that in the middle segment should be expanded to Conversely if the maximum m was unique then v m and we didn t have to expand the middle segment at this stage For example in the current state is If the maximums to the left and to the right are exactly v we found an answer Otherwise any possible middle segment contains the middle segment that we now got So we have to expand the middle segment either to the left or to the right As a result the value v may become smaller which can cause another expansion What s left is to decide where to expand when we have a choice We would like to do it greedily Indeed consider three values the minimum on middle segment v the maximum on left segment u and the maximum on right segment w When we expand the middle segment each of them can only decrease And if we find an answer the equation u v w will be satisfied So as we make the minimum of these three values smaller we have less and less opportunities to make them equal Thus we can pick the side of expansion after which the value min u v w is larger and if these are equal pick any For example in the state we have u 3 v 4 and w 3 If we expand to the left we get where u 1 v 3 and w 3 If we expand to the right we get where u 3 v 2 and w 3 Our algorithm will pick expanding to the right however there is no valid answer in this example anyway Implementation let us precalculate the maximums on all prefixes and all suffixes of the array Then we can expand the middle segment by one element in O 1 and the total running time is linear ,Let s solve the problem greedily But not from the beginning because if we solve it from the beginning we can t be sure what option is more optimal for the next elements e g for the second element it is not clear if we need to add to it starting our segment from the first position or add to it starting our segment from the second position So let s solve the problem from right to left then anything becomes clearer Actually let s operate with the array and decrease its elements instead of using some other array Let s carry some variables and the array of length along with the answer The variable means the value we need to subtract from the current element from currently existing progressions is the number of currently existing progressions and means the number of progressions that will end at the position i e will not add anything from the position and further to the left When we consider the element firstly let s fix decrease it by Then let s fix decrease it by Then let s decrease by and if it becomes less than or equal to zero just proceed Otherwise the number by which we can decrease the th element with one progression equals to zero indexed Then the number of progressions we need to satisfy this element is Let s add this number to the answer increase by increase by and if then we need to end these progressions somewhere so let s add to Time complexity 
555,For the simplicity let s say that the Death Note is a notebook that kills a person when their name is written in it It s easy to kill with it but it s pretty hard to keep track of people you haven t killed and still plan to You decided to make a Death Database Management System a computer program that provides the easy access to the database of possible victims Let me describe its specifications to you Let s define a victim entity a victim has a name not necessarily unique that consists only of lowercase Latin letters and an integer suspicion value At the start of the program the user enters a list of victim names into a database each suspicion value is set to Then the user makes queries of two types set the suspicion value of the th victim to given a string find the maximum suspicion value of a victim whose name is a contiguous substring of Just to remind you this program doesn t kill people it only helps to search for the names to write down in an actual notebook Thus the list of the victims in the database doesn t change throughout the queries What are you waiting for Write that program now ,I m feeling extremely amused by the power of Aho Corasick lately so I will describe two solutions of this problem with it Feel free to point out how cool you are solving the task with hashes or some suffix structure but Aho solutions will still be cooler I also want to mention I m quite proud of the name I came up with for that task First let s assume that the words in the dictionary are unique Build an Aho Corasick automaton on the dictionary Then build the tree of its suffix links For the first solution you can use the fact that there are not a lot of words in the dictionary that can end in each position To be exact at most one word per unique word length Thus that s bounded by the square root of the total length For that reason you can iterate over all the words that end in all positions of the queries in How to do that fast For each vertex of the automaton precalculate the closest vertex up the suffix link tree that s a terminal Feed the query word into the automaton and from each vertex you stay at just jump up the tree until you reach the root Take the maximum value over all the visited terminals The second solution actually involves an extra data structure on top of that No it s not HLD You are boring for using it Let s abuse the fact that you are allowed to solve the problem fully offline For each word you can save the list of pairs time value of the times the value of the word changed For each vertex of the automaton you can save all the times that vertex has been queried from Now traverse the tree with dfs When you enter the vertex you want to apply all the updates that are saved for the words that are terminals here What are the updates From the list we obtained for a word you can generate such triples that this word had value from query to query Don t forget the value from to the first update to this word Then ask all the queries Then go to children When you exit the vertex you want all the updates to be gone Well there is a trick for these kinds of operations it s called rollbacks Maintain a segment tree over the query times the th leaf should store the maximum value during the th query The update operation updates the range with the new possible maximum How to avoid using lazy propagation with such updates Well on point query you can collect all the values from the segtree nodes you visit on your way down That way you don t have to push the updates all the way to the leaves Not that it matters that much but the number of values to be saved for future rollbacks is decreased dramatically That solution works in ,At first notice that the final answer is minimum over answers for each character The answer for one character can be obtained like this Write down lengths of segments between two consecutive occurrences of this character from the first occurrence to the start of the string and from the last to the end of the string Take maximum of these values Answer will be this maximum 1 Overall complexity 
556,You are given an integer array Let us consider an empty deque double ended queue A deque is a data structure that supports adding elements to both the beginning and the end So if there are elements currently in the deque adding an element to the beginning will produce the sequence and adding the same element to the end will produce The elements of the array are sequentially added to the initially empty deque starting with and finishing with Before adding each element to the deque you may choose whether to add it to the beginning or to the end For example if we consider an array one of the possible sequences of actions looks like this 1 add to the beginning of the deque deque has a sequence in it 2 add to the end of the deque deque has a sequence in it 3 add to the end of the deque deque has a sequence in it 4 add to the beginning of the deque deque has a sequence in it Find the minimal possible number of inversions in the deque after the whole array is processed An in sequence is a pair of indices such that and For example the array has exactly two inversions and since and ,Let s process the array elements one by one For the first element it doesn t matter which side of the deque we add it to the result of its addition will be the same there will be a sequence of one element equal to the first array element in the deque Now let s consider adding the th element of an array into the deck First will be considered then and so on up to Let us describe the general algorithm for choosing the side of the dec for each step Note that if the elements now lie in the deck then all final sequences that can be obtained in the deck from the current state can be broken down into pairs of the form where the beginning and the end of the final sequences hidden behind are obtained by the same sequences of all the following choices and respectively coincide Note that since the prefix and suffix hidden behind the dots completely coincide in the two sequences under consideration as well as the set of numbers in the central part coincides the numbers of inversions also coincide inside the prefix and inside the suffix between elements of the prefix and elements of the suffix between elements of the prefix or suffix and elements of the central part The difference between the number of inversions in the first and second sequence consists only of the difference between the number of inversions in their central part So we can determine at the stage of adding to the deque which direction of its addition is guaranteed not to lead to the optimal answer and choose the opposite one If is added to the beginning of the deque the number of inversions in the central part will increase by the number of elements in the deque strictly smaller than and if we add it to the end of the deque it will increase by the number of elements in the deque strictly larger than Let us make a choice such that the number of inversions increases by the minimum of these two values To quickly find the number of elements smaller or larger than we will store all already processed array elements in a structure that supports the element order search operation such as Besides using this structure specifically you can write any balanced binary search tree such as a Cartesian tree sort all numbers in the input array and compress them to values preserving the relation then build a segment tree on them storing in the node the number of array numbers already processed by the deque with values between and Requests to update and get an order in such structures take time and the construction takes at worst so the time complexity of the algorithm is ,For each index we will find the number of pairs before swapping such that is the first occurence of in the chosen segment Let be previous occurence of before if is the first occurence then if we suppose the array to be indexed Let s find the number of pairs such that and then multiply it by and subtract for this index has to be in segment and has to be in segment so the number of ways to choose this pair is The value we receive as the sum of these values over all segments is the total number of distinct elements over all pairs so we need to divide it by the number of these pairs 
557,There are students at your university The programming skill of the th student is As a coach you want to divide them into teams to prepare them for the upcoming ICPC finals Just imagine how good this university is if it has students ready for the finals Each team should consist of Each student should belong to The of a team is the difference between the programming skill of some student that belongs to this team and the programming skill of some student that belongs to this team in other words if the team consists of students with programming skills then the of this team is The total is the sum of of all teams formed Your task is to minimize the total of the division of students and find the optimal way to divide the students ,Let s sort all students by their programming skills but save the initial indices to restore the answer Now we can understand that we don t need to compose the team of size greater than because in this case we can split it into more teams with fewer participants and obtain the same or even less answer Now we can do the standard dynamic programming the minimum total diversity of the division if we divided the first students in sorted order Initially all other values of are Because of the fact above we can do only three transitions indexed The answer is and we can restore it by standard carrying parent values as a parent of the state we can use for example the number of participants in the team ,Since it is better to do exactly chores in time And since we need to minimize total time we need to spend it s better to speed up the longest chores So the answer is 
558,Consider a linear function Let s define and for For the given integer values and find the value of modulo ,The problem can be solved using closed formula it s need to calculate the sum of geometric progression The formula can be calculated using binary exponentiation I ll describe more complicated solution but it s more general If we have a set of variables and at each step all variables are recalculating from each other using linear function we can use binary matrix exponentiation There is only one variable in our problem The new variable is calculating using formula Consider the matrix and the vector Let s multiply and Easy to see that we will get the vector So to make iterations we should multiply and times We can do that using binary matrix exponentiation because matrix multiplication is associative As an exercise try to write down the matrix for the Fibonacci numbers and calculate the th Fibonacci number in time The matrix and the vector is under the spoiler ,Note that Victor looks at the clock forever but there are only at most different times the clock can show because there are different minutes in a day So we only have to check the first times Victor sees and count the palindromes you can check a few more just to be safe but they will repeat anyways Now we just have to implementing adding minutes to a clock There are several ways to do this One of the slower ways might be writing functions converting a number of minutes into a time for a clock or you can just compute all palindrome times in terms of minutes and that way you don t have to convert from clock time to number of minutes The complexity is per test case since you only have to check a constant number of times 
559,The string is good if each letter of this string belongs to at least one palindrome of length than A palindrome is a string that reads the same backward as forward For example the strings are palindromes but the strings are not Here are some examples of good strings letters belong to palindrome and letters belong to palindrome letters belong to palindrome and letter belongs to palindrome all letters belong to palindrome You are given a string of length consisting of letters and You have to calculate the number of good substrings of string ,Instead of counting the number of good substrings let s count the number of bad substrings then number of good substrings is equal to Let s call a character in string is bad if there is no such palindrome that Any character in substring is good It can be proven as follows If or then belong to a palindrome of length If and then belong to a palindrome So only characters and can be bad But at the same time character is bad if there is no character such that and It is true because substring is palindrome index is minimum index such that So there are only patterns of bad strings All that remains is to count the number of substrings of this kind ,Here are two solutions Iterate through the string character by character If then otherwise if or then or If the statement is false for any the answer is Otherwise it is Replace all with since they are the same anyway Then just check if the two strings are equal In either case the complexity is per testcase 
560,Santa has candies and he wants to gift them to kids He wants to divide as many candies as possible between all kids Santa can t divide one candy into parts but he is allowed to not use some candies at all Suppose the kid who recieves the minimum number of candies has candies and the kid who recieves the maximum number of candies has candies Then Santa will be if the both conditions are met at the same time it means or the number of kids who has candies does not exceed less than or equal to is divided by and rounded to the nearest integer For example if then Your task is to find the maximum number of candies Santa can give to kids so that he will be You have to answer independent test cases ,Firstly we can notice that we always can distribute where is the modulo operation candies between kids In this case and the answer is at least And then we can add the value to the answer Why Because there is only candies remain and the maximum number of kids to whom we can give one more candy is ,In this task you just can iterate over the numbers of hamburgers and chicken burgers you want to assemble check that you have enough ingredients and update the answer If you want to sell hamburgers and chicken burgers then you need beef patties chicken cutlets and buns 
561,Recently you have bought a snow walking robot and brought it home Suppose your home is a cell on an infinite grid You also have the sequence of instructions of this robot It is written as the string consisting of characters and If the robot is in the cell right now he can move to one of the adjacent cells depending on the current instruction If the current instruction is then the robot can move to the left to if the current instruction is then the robot can move to the right to if the current instruction is then the robot can move to the top to if the current instruction is then the robot can move to the bottom to You ve noticed the warning on the last page of the manual if the robot visits some cell twice then it breaks So the sequence of instructions is valid if the robot starts in the cell performs the given instructions visits no cell other than two or more times and ends the path in the cell Also cell should be visited two times at the beginning and at the end if the path is empty then it is visited only once For example the following sequences of instructions are considered valid and the following are considered invalid the endpoint is not and the cell is visited twice The initial sequence of instructions however might be not valid You don t want your robot to break so you decided to reprogram it in the following way you will remove some possibly all or none instructions from the initial sequence of instructions then rearrange the remaining instructions as you wish and turn on your robot to move Your task is to remove as few instructions from the initial sequence as possible and rearrange the remaining ones so that the sequence is valid Report the valid sequence of the maximum length you can obtain Note that you can choose order of remaining instructions you don t need to minimize the number of swaps or any other similar metric You have to answer independent test cases ,Let be the number of occurrences of the character in the initial string the number of occurrences of the character and are the same things for remaining characters It is obvious that in every answer the number of equals the number of and the same for and The maximum theoretic answer we can obtain has length And We almost always can obtain this answer If there is at least one occurrence of each character then we can construct some kind of rectangular path moves right then moves up and the completing part But there are some corner cases when some characters are missing If then our answer is empty or if it is possible it is The same if Time complexity per test case ,Note that no matter which action is chosen after this action is performed one letter is erased from the string two letters in total are erased from the string Let s denote the length of the string by If is odd then described turns can not erase all the characters from the strings because if he is deleting two letters on each turn the length will always remain odd For example if the original length of the string is then after one turn it will be equal to and after two moves it will be equal to in which case the next turn is impossible Thus if the length of the row is odd the answer is If is even it will take exactly steps to erase all characters from the string Since each action removes exactly one letter from the string the string can become empty only if there are exactly letters Let us show that this condition is sufficient that is if a string has exactly half of the letters equal to then there always exists a sequence of actions leading to an empty string Indeed if a string of length has exactly letters exactly letters and exactly letters then Then Casimir can make moves of the first type each time removing the first occurrence of and the first occurrence of and moves of the second type each time removing the first occurrence of and the first occurrence of After such moves the string will become empty Thus checking that the number of letters in the string is exactly half of its length was enough to solve the problem 
562,Let s denote the size of the maximum matching in a graph as You are given a bipartite graph The vertices of the first part are numbered from to the vertices of the second part are numbered from to For a tuple of four integers where and let s define as the graph which consists of all vertices of the given graph that are included in the segment or in the segment and all edges of the given graph such that each of their endpoints belongs to one of these segments In other words to obtain from the original graph you have to remove all vertices such that and and all edges incident to these vertices Calculate the sum of over all tuples of integers having and ,Instead of counting the edges belonging to the maximum matching it is easier to count the vertices So we will calculate the total number of vertices saturated by the maximum matching over all possible tuples and then divide the answer by Furthermore it s easier to calculate the number of unsaturated vertices than the number of saturated vertices so we can subtract it from the total number of vertices in all graphs we consider and obtain the answer Let s analyze how to calculate the total number of unsaturated vertices Each graph is a subgraph of the given graph so it is still bipartite and the degree of each vertex is still not greater than A bipartite graph where the degree of each vertex is at most can be represented as a set of cycles and paths and the maximum matching over each of these cycles paths can be considered independently Each cycle has an even number of vertices since otherwise the graph would not be bipartite so we can saturate all vertices on a cycle with the matching For a path the number of unsaturated vertices depends on its length if the number of vertices in a path is even we can match all vertices on it otherwise one vertex will be unsaturated So the problem reduces to counting paths with odd number of vertices in all possible graphs Every path with an odd number of vertices has a center the vertex which is exactly in the middle of the path Let s iterate on the center of the path and its length and calculate the number of times this path occurs in all graphs we consider Suppose the center of the path is the vertex and the number of vertices in it is Then for this path to exist two conditions must hold every vertex such that the distance from to is not greater than should be present in the graph every vertex such that the distance from to is should be excluded from the graph It means that for each of the two parts of the graph there are several vertices that should be present in the graph and zero or two vertices that should be excluded from the graph It s easy to see that among the vertices we have to include we are only interested in the minimum one and the maximum one all vertices between them will be included as well if these two are included So we need to implement some kind of function that allows us to calculate the number of segments that cover the minimum and the maximum vertex we need and don t cover any of the vertices that we have to exclude this can be easily done in Note that the segments should be considered independently for both parts of the graph Overall for each vertex we have to consider at most different lengths of odd paths with the center in this vertex The minimum maximum indices of vertices in both parts we have to include in the graph can be maintained while we increase the length of the path so the whole solution works in ,Vasya can decrease number of isolated vertices up to using one edge and pairing them So minimum number of isolated vertices is To calculate maximum number of isolated vertices let s keep number of non isolated vertices knowing that each pair connected by edge i e size of clique Let we have size of clique and edges remained unassigned at current step If then answer is Otherwise we need to increase clique with one vertex Maximum number of edges we can add to connect this vertex is So subtract it from and increase by one Repeat this step while greater than zero Answer is One corner case is next if then answer is not 
563,You are given a rooted tree consisting of vertices Each vertex has a number written on it number is written on vertex Let s denote as the distance between vertices and in the tree that is the number of edges in the shortest path from to Also let s denote the of vertex as the set of vertices such that both these conditions are met is an ancestor of every vertex is an ancestor of itself You are given queries to the tree th query is represented by two numbers and and the answer to this query is the minimum value of among such vertices such that belongs to blocked subtree of Write a program that would process these queries quickly ,The main idea is to use a two dimensional data structure one dimension is depth of vertices and other dimension is the time we entered a vertex during DFS Model solution uses sparse table for these purposes First of all let s renumerate the vertices so we can handle them easier We run DFS from the root and then sort the vertices by their depth and if depths are equal by time we entered them in DFS Then we renumerate vertices in this sorted order We need to denote some functions in order to continue depth of vertex in the tree the time we entered during DFS the time we left during DFS For each depth we can store a sorted array of vertices belonging do this depth This will allow us to build an auxiliary sparse table where is such vertex that is minimal among all vertices that meet first two conditions We also need a second sparse table where is iff is minimal among all vertices that meet first two conditions These sparse tables can be built using binary search in arrays we created for depths Okay why do we need them To create a third sparse table that will process the queries themselves the minimum value of among vertices such that belongs to blocked subtree of some vertex with index included in This table can be built backwards with the help of auxiliary tables So how do we answer the queries We need to look at the binary representation of and do something like binary lifting but descending the tree instead of ascending and maintain the leftmost and the rightmost vertices on current depth which belong to the subtree we are interested in and make queries to on the segment between these two vertices This solution works in but unfortunately or fortunately to some participants we made the time limit too high so the structures that require time to process each query such as two dimensional segment trees might also get AC ,Because our graph is just a tree with an additional edge consider it as a cycle with trees hanged on cycle vertices Consider some tree hung on a vertex v on a cycle There is only one path between each pair of its vertices including the root which is a vertex v So if the tree has cnt v vertices then frac cnt v cnt v 1 2 paths are added to the answer What about paths that go out of a tree Let s assume that there are cnt v cdot n cnt v such paths yeah we counted only a half of actual paths from this component but this is fine When we consider other trees we will take into account the other half of paths This information can lead us to the conclusion that the only information we need to know about trees hanged on cycle vertices is the number of vertices in these trees So if we know cnt v for each vertex on a cycle we can just calculate the answer as sum limits v in cycle frac cnt v cnt v 1 2 cnt v cdot n cnt v So how to find values cnt v Of course there is a simple and straight forward solution just extract and mark all cycle vertices and run dfs from every vertex of a cycle but there is another approach without any graph algorithms that works very well for such kind of graphs Initially let cnt v 1 for each v from 1 to n Let s create a queue containing all leafs of the graph Let s take the leaf x get its parent p add cnt p cnt p cnt x and remove the vertex x with all edges incident to it After that if p became a leaf let s add it to the queue We can see that after processing all leafs only cycle vertices remain in the graph and cnt v is exactly the number of the vertices in a tree and we can just calculate the answer using the formula above This approach can be implemented in O n log n or in O n there is almost no difference but O n log n one can be written a bit simpler than a linear one 
564,You have an image file of size consisting of pixels Each pixel can have one of different colors denoted by lowercase Latin letters You want to recolor some of the pixels of the image In one move you can choose pixels and paint them into some other color What is the minimum number of moves you have to make in order to fulfill your goal ,There are some solutions based on case analysis but in my opinion the most elegant one is the following Let s pick a color with the maximum possible number of pixels and repaint all other pixels into it We will try to pick all pixels of some other color and repaint them in one operation and we can ignore the constraint that we can repaint no more than pixels since we will never need to repaint or pixels in one operation So the number of operations is just the number of colors other than the one we chosen or just where is the number of different colors in the image To calculate this we can use a set or an array of size where we mark which colors are present ,If the ball of color x is present in the first list on position i then it takes i cdot t 1 seconds to find it The same for the second list if color x is on position j it takes j cdot t 2 seconds to find it So for each position we have a coefficient which will be multiplied by the number of times it is requested and the total search time is the sum of these products for all positions There is a classical problem of the form you are given two arrays a i and b i both of length m consisting of non negative integers permute the elements of a in such a way that sum limits i 1 m a i cdot b i is the minimum possible To solve this problem you have to pair the maximum element of a with the minimum element of b the second maximum of a with the second minimum element of b and so on We can reduce our problem to this one For each of 2n positions in the lists there is a coefficient you have to assign the boxes from 1 to n to the positions so that the sum of r i multiplied by the coefficients for the positions is the minimum possible This looks similar but there are 2n positions and only n boxes To resolve this issue we can try a lot of different approaches I believe the easiest one is the following initially both lists are empty and when want to add an element to one of these two lists we choose the list such that the coefficient for the new position which is s i cdot 1 cnt i where cnt i is the number of elements we already added to the i th list is smaller If for both lists adding a new element has the same coefficient it doesn t matter which one we choose This greedy approach works because every time we add an element to the list next time we ll add another one into the same list the coefficient for that element will be greater So the problem can be solved in O n log n first we sort the boxes by the number of times they are requested in non ascending order and then we put them into the two lists greedily every time choosing the list such that the coefficient for the next element is smaller 
565,You may have already known that a standard ICPC team consists of exactly three members The perfect team however has more restrictions A student can have some specialization coder or mathematician So the team is considered perfect if it includes at least one coder at least one mathematician and it consists of exactly three members You are a coach at a very large university and you know that of your students are coders are mathematicians and have no specialization What is the maximum number of full perfect teams you can distribute them into Note that some students can be left without a team and each student can be a part of no more than one team You are also asked to answer independent queries ,Notice that if then you can equalize them to the min and re qualify the rest into students without specialization That won t change the answer Now analyze the possible team formations 1 of each kind 2 coders and 1 mathematician or 1 coder and 2 mathematicians Each of these squads have 1 coder and 1 mathematician so you can only choose the type of the third member The students without specialization can only be used in the first kind of teams so let s use them first After that you might have been left with a nonzero count of coders and mathematicians These are equal however so can be added to the answer This solves each query in You can also run a binary search and solve each query in ,If we sort the students in order of non decreasing their skill we can see that the minimum cost of the team with the lowest skill let s call it the first team is equal to if is already sorted the cost of the second team is and so on So if we sort in non decreasing order then the answer is 
566,Initially array contains just the number You can perform several operations in order to change the array In an operation you can select some subsequence of and add into an element equal to the sum of all elements of the subsequence You are given a final array Check if can be obtained from the initial array by performing some number possibly 0 of operations on the initial array A sequence is a subsequence of a sequence if can be obtained from by the deletion of several possibly zero but not all elements In other words select distinct indices and insert anywhere into a new element with the value equal to ,Let s prove that for an array that was created by using a number of operations with a sum of elements we can add into any number Suppose that it is true that in the array with some length we introduce a number Then after introducing we can create using the initial elements of the array any number and using the element and some subset of the initial elements we can create any number and because we proved that for the new array of length we can still create any number between and Since it is true for the initial array we can use induction and this fact to prove it is true for all arrays So we just need to verify if our array satisfies this condition We should sort the array and check for each if ,We will build the answer greedily from the highest significant bit to the lowest one Let s analyze how to check if the answer can have the highest bit equal to It means that every value in should have its highest bit equal to so for every exactly one of the numbers should have this bit equal to For both of the given arrays we can calculate how many elements have which value of this bit and then the number of elements with in this bit in the array should be equal to the number of elements with in the array and the same for elements with in and elements with in If these values are equal it means that the elements of and can be matched in such a way that in every pair the XOR of them has in this bit If it is so then the highest bit of the answer is otherwise it is Okay then let s proceed to the next bit Should we just do the same to check if this bit can be equal to in the answer Unfortunately that s not enough Let s look at the case We can get the value in the th bit or in the st bit but not in both So for the next bit we need to make sure that not only we can get in the result but we can also do this without transforming some of the s to s in the higher bits If it is impossible it doesn t matter if we can get in the current bit since it will be suboptimal so we have to use an ordering that gets in this bit In general case it means that we have to solve the following subproblem check if we can obtain in several bits of the answer let these bits be to are the bits that we have already checked is the new bit we are trying to check Let be the number that has in every bit and in every other bit The elements should be matched in such a way that If we group all numbers from and from according to the value of or then for every group of elements from there is a corresponding group in such that we can match the elements from the first group with the elements from the second group So if for every such group its size in is equal to the size of the corresponding group in then we can set all bits from to simultaneously Some implementation notes if the number of bits we need to check is big the number of groups can become too large to handle all of them since it is So to store the number of elements in each group we should use some associative data structure like for example in C If you use a map splitting elements into groups will be done in so in total you will get complexity of where is the maximum possible value in the input 
567,You re given a list of strings You d like to concatenate them together in some order such that the resulting string would be lexicographically smallest Given the list of strings output the lexicographically smallest concatenation ,Let s sort all the strings by comparator and concatenate them Let s prove that it s the optimal answer Let that operator be transitive so if Consider an optimal answer with two strings in reverse order by that operator Because of the transitivity of operator we can assume that pair of strings are neighbouring But then we can swap them and get the better answer Let s prove the transitivity of operator Consider the strings as the base numbers Then the relation equivalent to The last is simply the relation between real numbers So we proved the transitivity of the relation ,First of all let s think about how we should rearrange the two strings in such a way that if that is ever possible It s always optimal to arrange s characters increasingly in lexicographic order and s characters decreasingly Since initially both and contain a character the first time receives any other letter than the answer will always be because that character will always be lexicographically larger than s first character which should be In the other case we know that doesn t have any other characters than so we can compare the string with multiple characters and we know that will be smaller if and only if it s only formed of s and has a smaller size than 
568,Alice got tired of playing the tag game by the usual rules so she offered Bob a little modification to it Now the game should be played on an undirected rooted tree of vertices Vertex is the root of the tree Alice starts at vertex and Bob starts at vertex The moves are made in turns Bob goes first In one move one can either stay at the current vertex or travel to the neighbouring one The game ends when Alice goes to the same vertex where Bob is standing Alice wants to minimize the total number of moves and Bob wants to maximize it You should write a program which will determine how many moves will the game last ,If you check some games then you will notice that the most optimal strategy for Bob is always like this Climb up for some steps possibly zero Go to the lowest vertex from it Stay in this vertex till the end Thus let s precalc the depth the distance from the root of the lowest vertex of each subtree using dfs distance from Alice s starting node and from Bob s starting node to the vertex again dfs bfs Now iterate over all vertices and check if Bob can reach this vertex earlier than Alice If he can then update the answer with the lowest vertex that can be reached from this one The answer is doubled depth of the obtained lowest reachable vertex That is the time which will take Alice to get there Overall complexity ,I know there exists solution and author of the problem promises to tell it to you here he explained it I d love to tell easier to code and about the same time to work solution At first notice that it is only enough to check the paths such that all vertices on it is divisible by some prime Let s for each calculate the path of the maximum length to pass through it That means that one part of this path goes down to one child of it and another part goes down to another child For each vertex we will store the lengths of maximum paths through vertices with values divisible by each prime in That is memory To recalc the answer we will store all values of children nodes sort them and update the answer with two pointers technique Don t forget about the case of Overall complexity 
569,The flag of Berland is such rectangular field that satisfies following conditions Flag consists of three colors which correspond to letters and Flag consists of three equal in width and height stripes parralel to each other and to sides of the flag Each stripe has Each color should be used in You are given a field consisting of characters and Output without quotes if this field corresponds to correct flag of Berland Otherwise print without quotes ,There are lots of ways to check correctness For example you can keep boolean array with already used colors check stripes naively and mark the color used if the stripe has single color If all the colors are used in the end then the answer is Overall complexity ,If the ball of color x is present in the first list on position i then it takes i cdot t 1 seconds to find it The same for the second list if color x is on position j it takes j cdot t 2 seconds to find it So for each position we have a coefficient which will be multiplied by the number of times it is requested and the total search time is the sum of these products for all positions There is a classical problem of the form you are given two arrays a i and b i both of length m consisting of non negative integers permute the elements of a in such a way that sum limits i 1 m a i cdot b i is the minimum possible To solve this problem you have to pair the maximum element of a with the minimum element of b the second maximum of a with the second minimum element of b and so on We can reduce our problem to this one For each of 2n positions in the lists there is a coefficient you have to assign the boxes from 1 to n to the positions so that the sum of r i multiplied by the coefficients for the positions is the minimum possible This looks similar but there are 2n positions and only n boxes To resolve this issue we can try a lot of different approaches I believe the easiest one is the following initially both lists are empty and when want to add an element to one of these two lists we choose the list such that the coefficient for the new position which is s i cdot 1 cnt i where cnt i is the number of elements we already added to the i th list is smaller If for both lists adding a new element has the same coefficient it doesn t matter which one we choose This greedy approach works because every time we add an element to the list next time we ll add another one into the same list the coefficient for that element will be greater So the problem can be solved in O n log n first we sort the boxes by the number of times they are requested in non ascending order and then we put them into the two lists greedily every time choosing the list such that the coefficient for the next element is smaller 
570,You are given two positive integers and In one move you can increase by replace with Your task is to find the minimum number of moves you need to do in order to make divisible by It is possible that you have to make moves as is already divisible by You have to answer independent test cases ,If is divisible by just print Otherwise we need exactly moves to make zero remainder of modulo is modulo operation ,At first must be met since and Now let and From now on let s consider only such that Now let s look at must be met Let Since if then must have to the power of in its factorization otherwise power of can be any non negative integer It leads us to the bitmask of restrictions with size equal to the number of different prime divisors of In the same way let s process Of course and if then must have to the power of in its factorization This is another restriction bitmask So for any pair there exists if and only if Since we look only at where then can t have power of equal to and at the same time For any other it is enough to have power of in equal to the power of in even if it s equal to So for each we need to know the number of such that is a submask of So we just need to calculate sum of submasks for each mask it can be done with or Finally how to factorize number up to Of course Pollard algorithm helps but there is another way which works sometimes Let s factorize with primes up to So after that if there is only three cases or is easy to check helps Otherwise just check with all and if you have found and then and you have found Otherwise you can assume that because this probable mistake doesn t break anything in this task Result complexity is where is the number of prime divisors of 
571,After several latest reforms many tourists are planning to visit Berland and Berland people understood that it s an opportunity to earn money and changed their jobs to attract tourists Petya for example left the IT corporation he had been working for and started to sell souvenirs at the market This morning as usual Petya will come to the market Petya has different souvenirs to sell th souvenir is characterised by its weight and cost Petya knows that he might not be able to carry all the souvenirs to the market So Petya wants to choose a subset of souvenirs such that its total weight is not greater than and total cost is maximum possible Help Petya to determine maximum possible total cost ,There are lots of different solutions for this problem We can iterate on the number of elements we will take in this editorial element is a souvenir with weight When fixing the number of elements let it be we want to know the best possible answer for the weight while taking into account only elements and elements To answer these queries we can precalculate the values triples where is the best possible answer for the weight and and is the number of elements and elements we are taking to get this answer Of course and we can update and using value of After precalculating for each possible we can iterate on the number of elements There are also several binary ternary search solutions ,We can solve the problem by the following way firstly for each power of 2 let s calculate the number of coins with the value equals this degree Let s call it cnt It is obvious that we can obtain the value b j greedily because all less values of coins are divisors of all greater values of coins Now let s iterate over all powers of 2 from 30 to 0 Let s deg be the current degree We can take min lfloor frac b j 2 deg rfloor cnt deg coins with the value equals 2 deg Let it be cur Add cur to the answer and subtract 2 deg cdot cur from b j If after iterating over all powers b j still be non zero print Otherwise print the answer Overall complexity O n q log maxAi 
572,You have a playlist consisting of songs The th song is characterized by two numbers and its length and beauty respectively The pleasure of listening to set of songs is equal to the total length of the songs in the set multiplied by the minimum beauty among them For example the pleasure of listening to a set of songs having lengths and beauty values is equal to You need to choose songs from your playlist so the pleasure of listening to the set of these songs them is maximum possible ,If we fix a song with minimum beauty in the answer then we need to take the remaining songs or less among those having beauty greater than or equal to the beauty of the fixed song and the longer they are the better So we will iterate on the songs in the order of decreasing their beauty and for the current song we will maintain longest songs having greater or similar beauty This can be done using some standard containers in or in ,The necessary and sufficient condition is the following for each color the key should appear before the door Necessary is easy to show if there is a key after a door this door can t be opened Sufficient can be shown the following way If there are no closed doors left the knight has reached the princess Otherwise consider the first door the knight encounters He has a key for this door so he opens it We remove both the key and the door from the string and proceed to the case with one less door Overall complexity 
573,Let s define a function is a positive integer as follows write all digits of the decimal representation of backwards then get rid of the leading zeroes For example Let s define another function is a positive integer as well Your task is the following for the given positive integer calculate the number of different values of among all numbers such that ,Let s analyze which values can the function have It can be proven that the value of is equal to where is the number of zero digits at the end of the number because is the same number as except for the fact that it doesn t have any trailing zeroes Okay now let s analyze when we reach the new value of is the first value of such that is the first value of such that is the first value of such that and so on We have to calculate the maximum number that has the form and is not greater than and the answer is exactly It can be done with a mathematical solution but the most simple way to do it is read as a string instead and calculate its length ,Denote the answer to the problem Note that or what is the same where equals to one if is a magic number otherwise equals to zero Let s solve the problem for the segment Here is described the standard technique for this kind of problems sometimes it is called dynamic programming by digits It can be realized in a two ways The first way is to iterate over the length of the common prefix with number Next digit should be less than corresponding digit in and other digits can be arbitrary Below is the description of the second approach Let be the number of magic prefixes of length with remainder modulo If than the prefix should be less than the corresponding prefix in and if than the prefix should be equal to the prefix of it can not be greater Let s do forward dynamic programming Let s iterate over digit in position We should check that if the position is even than should be equal to otherwise it cannot be equal to Also we should check for should be not greater than corresponding digit in Now let s see what will be the next state Of course By Horner scheme Easy to see that To update the next state we should increase it Of course all calculations should be done modulo 
574,Let s call a fraction good if there exists at least one another fraction such that the digit denoting is contained in the decimal representation of and the digit denoting is contained in the decimal representation of For example is a good fraction because You are given an integer number Please calculate the number of good fractions such that and The answer may be really large so print it modulo ,Let s fix an fraction such that Obviously each good fraction is equal to exactly one of such irreducible fractions So if we iterate on and check that and find the number of good fractions that are equal to we will solve the problem Okay suppose we fixed and Any good fraction can be represented as where is some positive integer Let s try all possible values of and for them check whether they correspond to a good fraction How do we try all values of without iterating on them Let s construct the decimal representation of from the least significant digit to the most As soon as we fix least significant digits of we know least significant digits of and So let s try to use digit DP to try all possible values of Which states do we have to consider Of course we need to know the number of digits we already placed so that will be the first state After we placed digits we know first digits of the numerator of the fraction but to get the value of digit knowing only the value of the corresponding digit in is not enough there could be some value carried over after multiplying already placed digits by For example if and we placed the first digit of and it is we know that the first least significant digit of is and we know that after fixing the second digit of we should add to it to get the value of this digit in since is carried over from the first digit So the second state of DP should represent the number that is carried over from the previous digit in the numerator and the third state should do the same for the denominator Okay in order to know whether the fraction is good we have to keep track of some digits in the numerator and denominator If and then we have to keep track of the digit representing in the numerator and the digit representing in the denominator So we have two additional states that represent the masks of interesting digits we met in the numerator and in the denominator The only thing that s left to check is that both and are not greater than Let s construct the decimal representation of and prepend it with some leading zeroes and keep constructing the numerator and the denominator until they have the same number of digits as the decimal representation as Then we can compare the representation of for example numerator with the representation of as strings Comparing can be done with the following technique let s keep a flag denoting whether the number represented by the least significant digits of the numerator is less or equal than the number represented by the same digits from When we place another digit of the numerator we can get the new value of this flag as follows if new digit of the numerator is not equal to the corresponding digit of then the value of the flag is defined by comparing this pair of digits otherwise the value of the flag is the same as it was without this new digit Of course we should do the same for the denominator Okay now we can actually start coding this DP is the number of possible ways to put least significant digits in in such a way that the value carried over to the next digit of the numerator is and for the denominator denotes whether the current numerator is less or equal to the number represented by least significant digits of does the same for the denominator denotes which interesting digits we already met in the numerator of course does the same for the denominator If you are feeling confident in your programming abilities you can just start implementing this DP on a seven dimensional array I was too afraid to do it but looking at participants solutions I realize that it sounds much more scary than it looks in the code so I decided to write the model solution using a structure representing each state and a map to store all these structures This is a common technique when a dynamic programming solution you come up with has some really complex states and transitions it is sometimes better to use some self implemented structures to define these states and store them in a map or a hashmap Some advantages of this technique are it s sometimes much easier to code the code may be longer than the same solution with regular DP stored in a multi dimensional array but it s easier to write and understand this code if most states are unreachable they won t even appear in our map so we skip them altogether it is easy to add some optimizations related to reducing the number of states For example the number of different values for and may be too much so we can use the following optimization as soon as we find some pair of numbers in and that can represent and we can change these masks to some values that will mark that they are finished and stop updating them at all ,Let s find the first digit in a that becomes greater if we replace it obviously if there is no such digit then the best solution is to leave a unchanged In the optimal solution we will replace this digit and maybe some digits after this Why is it so It is impossible to make any of the previous digits greater since we found the first digit that can be replaced with a greater one Then let s analyze all digits to the right of it We should not replace any digit with a lower digit because it is better not to replace it and all digits to the right of it at all but there s nothing wrong with replacing any other digits So the segment we need to replace begins with the first digit that can become greater after replacing and includes this digit and goes to the right until the first digit that becomes less after replacing and this digit is excluded 
575,Vasya has got books numbered from to arranged in a stack The topmost book has number the next one and so on The book at the bottom of the stack has number Vasya wants to move all the books to his backpack in steps During th step he wants to move the book number into his backpack If the book with number is in the stack he takes this book and all the books the book and puts them into the backpack otherwise he does nothing and begins the next step For example if books are arranged in the order book is the topmost and Vasya moves the books in the order then during the first step he will move two books and during the second step he will do nothing since book is already in the backpack and during the third step one book the book number Help Vasya Tell him the number of books he will put into his backpack during each step ,Let s maintain the pointer to the topmost non deleted book and whether each book whether is removed from the stack or not Initially all books are in a stack and is 0 if we store the array 0 indexed We will process the array in the order If the current book is removed from the stack then the answer for it is zero Otherwise we will increment the pointer until the equality is satisfied while marking all the intermediate books in the array After that the answer for the book will be the number of marked books in the array including itself Since the pointer shifts times at total we get a solution with an complexity ,Let s fix number of plates to have pieces of the first cake plates left for the other cake Obviously the most optimal way to distribute pieces to plates will lead to the minimum of pieces on a plate Now try every possible and take maximum of Overall complexity 
576,The girl Umka loves to travel and participate in math olympiads One day she was flying by plane to the next olympiad and out of boredom explored a huge checkered sheet of paper Denote the th Fibonacci number as A checkered rectangle with a height of and a width of is called a Fibonacci rectangle Umka has a Fibonacci rectangle Someone colored a cell in it at the intersection of the row and the column It is necessary to cut this rectangle into squares in such way that the painted cell was in a square with a side of there was pair of squares with equal sides the side of each square was equal to a Fibonacci number Will Umka be able to cut this rectangle in that way , which can be proved by induction If the partition exists it has the form since the area of the rectangle with another partition will be greater than We will cut the rectangles in the order Denote the coordinates of the colored cell at the step as If and then there is no partition since the square at any location overlaps the colored cell Cut off the square from the right or left edge depending on the location of the colored cell that is or Suppose that it was advantageous to cut it not from the edge then it is necessary to cut the rectangles and where using the set Then will not enter the partition but so We came to a contradiction ,If then there is no suitable matrix The operation means xor Otherwise we can always construct a suitable matrix by the following method the first element of the first line will be equal to The second element of the first line is the third element is the last one is The first element of the second line will be the first element of the third line is the first element of the last line is The rest of the elements will be zero It is not difficult to verify that the matrix obtained satisfies all the restrictions 
577,You have coins of value and coins of value You always pay in exact change so you want to know if there exist such and that if you take coins of value and coins of value then the total value of taken coins will be You have to answer independent test cases ,Firstly we obviously need to take at least coins of value If we cannot do it the answer it Otherwise we always can obtain the required sum if ,Eliminate the obvious corner case when we don t have enough water Now we don t consider it in editorial Let s fix some set of tanks and let be the total amount of water in the set If and have the same remainders modulo then we can transfer all water from to one tank transfer all water from to another tank and then using some number of operations transfer required amount of water from to or from to So we have a solution when we have some set of tanks such that What if we don t have such set In this case it is impossible to solve the problem since we cannot obtain a tank with water such that and obviously we cannot obtain a tank with exactly water To find this set we may use some sort of knapsack dynamic programming 
578,Vasya is studying number theory He has denoted a function such that where is the greatest common divisor of and Vasya has two numbers and and he wants to calculate He tried to do it by himself but found out that calculating this function the way he wants to do that might take very long time So he decided to ask you to implement a program that will calculate this function swiftly ,One important fact is that when we subtract from new will be divisible by old And of course is always divisible by Let s factorize Consider the moment when changes If we denote old value of by the new value of will be divisible by some where is a prime divisor of Let s check all prime divisors of and for each of these divisors find the number of times we need to subtract from to get divisible by that is just don t forget that also has to be divisible by Among all prime divisors of pick one with the minimum required number of operations let this number of operations be add to answer subtract from and repeat the process ,Let s look at where It can be proven that there always exists such pair and that and Brief proof is following calculate then let and Obviously such will make from and from if And since and since As we can see divides so if we will iterate over all pairs where there will be pairs in total Let s fix value of Then from one side but from the other side since then Anyway all valid form a segment possibly empty segment And we need to find any that divides any from the segment and doesn t exceed Obviously it s optimally to find the minimum possible such and just check inequality We can find such for a fixed using for example built in in a set with all divisors for all valid To maintain this set we can note that simillary So we can move valid segment s ends as two pointers Each pair will be added and erased from the segment exactly once That s why the total complexity of maintaining the set of divisors as well as the total complexity of queries for each will be equal to All pairs and can be precalculated in using the sieve like algorithm 
579,At the store the salespeople want to make all prices In this problem a number that is a power of is called a number For example the numbers are numbers but and are not numbers So if an item is worth bourles the value of the item is not greater than the sellers want to change its value to the nearest number that is not greater than They ask you by how many bourles should you the value of the item to make it worth exactly bourles where the value of is the maximum possible any non negative integer For example let the item have a value of bourles Then the new price of the item will be and the answer will be ,Note that the number and the nearest round number not exceeding have the same size consist of the same number of digits in the record Denote the size of by Then we can construct the nearest round number It will consist of one and zeros ,If we did not delete the strings then the median would be equal to the binary notation of After deleting strings the median cannot change numerically by more than Let s start with the median and each time decrease it by one if there are fewer not deleted smaller numbers than not deleted large numbers Similarly you need to increase the median by one otherwise The algorithm stops when the result is the median of the current set All these steps will run at most times 
580,Recall that the sequence is a a subsequence of the sequence if can be derived from by removing zero or more elements without changing the order of the remaining elements For example if then possible subsequences are and but not and You are given a sequence consisting of positive and negative elements there is no zeros in the sequence Your task is to choose length subsequence of the given sequence i e the sign of each next element is the opposite from the sign of the current element like positive negative positive and so on or negative positive negative and so on Among all such subsequences you have to choose one which has the of elements In other words if the maximum length of subsequence is then your task is to find the of elements of some subsequence of length You have to answer independent test cases ,Firstly let s extract maximum by inclusion segments of the array that consists of the numbers with the same sign For example if the array is 1 1 2 1 5 2 1 3 then these segments are 1 1 2 1 5 2 1 and 3 We can do it with any two pointers like algorithm The number of these segments is the maximum possible length of the alternating subsequence because we can take only one element from each block And as we want to maximize the sum we need to take the maximum element from each block Time complexity O n ,Suppose the initial sum of is equal to If we perform the operation the new sum will be equal to We want the sum not to decrease or If we will get If we ll get analogically In other words array you need if sorted will have and so on And one of the variants and obviously an optimal one is just As a result since we just need to check if then we found an answer otherwise there is no counterexample 
581,Let and be some non negative integers Let s define of and as following write down the numbers one under another and align them by their least significant digit add them up digit by digit and concatenate the respective sums together Assume that both numbers have an infinite number of leading zeros For example let s take a look at a of numbers and You are given a string consisting of digits from to You are also given updates of form replace the digit at the th position of with a digit Note that string might have leading zeros at any point of time After each update print the number of pairs such that both and are non negative integers and the result of a of and is equal to Note that the numbers of pairs can be quite large so print them modulo ,Let s solve the task as if there are no updates This can be done with a pretty straightforward dp is the number of pairs such that the result of the strange addition of and is the prefix of of length From each state you can add a single digit to and to at the same time You can either go to and multiply the answer by the number of pairs of digits than sum up to Or go to and multiply the answer by the number of pairs of digits than sum up to Note that no pair of digits can sum up to a three digit value so it makes no sense to go further Let s optimize this dp with some data structure Segment tree will work well Let the node store the number of ways to split the segment into blocks of size or so that both the leftmost character and the rightmost character are not taken into any block the leftmost character is taken into some block and the rightmost character is not taken into any block the leftmost character is not taken into any block and the rightmost character is taken into some block both the leftmost and the rightmost characters are taken into some blocks This structure makes the merge pretty manageable You should glue up the segments in such a way that all the middle characters are taken into some block either in separate blocks in their own segments or into the same block of length The answer will be in the root of the tree in a value such that both characters are taken The update in the segment tree will still work in Overall complexity ,Notice that the order of letters doesn t matter at all depends only on amount of each letter Let be the possibility that string will occur in at least times after replacing all signs and after some swaps If is true then is also true That leads to binary search over the answer Let be the amount of letters in and the amount of letters in is the number of signs is true if If some letter appears in less times than needed then replace some signs with it Answer can be restored greedily by replacing signs with the letters needed Overall complexity where is the size of the alphabet 
582,You are given two arithmetic progressions and Find the number of integers such that and for some integers ,I wanted to give this problem a lot of time ago I thought it is very standard problem but I underestimated its difficulty Let s write down the equation describing the problem So we have linear Diofant equation with two variables The solution has the form where the last equation can be solved by extended Euclid algorithm and is any integral number The variable should satisfy two conditions and The values and are fixed so we can get the segment of possible values for the values The length of the segment is the answer for the problem ,The triangle with side is degenerate if So we have to maximize the length of the longest side and minimize the total length of other sides Thus if then we answer if otherwise the answer is 
583,Polycarp plays a yet another strategic computer game In this game he leads an army of mercenaries Polycarp wants to gather his army for a quest There are mercenaries for hire and the army should consist of some subset of them The th mercenary can be chosen if the number of chosen mercenaries is not less than otherwise he deems the quest to be doomed and not greater than he doesn t want to share the trophies with too many other mercenaries Furthermore pairs of mercenaries hate each other and cannot be chosen for the same quest How many subsets does Polycarp need to consider In other words calculate the number of non empty subsets of mercenaries such that the size of this subset belongs to for each chosen mercenary and there are no two mercenaries in the subset that hate each other The answer may be large so calculate it modulo ,In order to take care of the and constraints we can iterate on the number of mercenaries we ll choose and find the number of choices for each count The key constraint in this problem is that is at most 20 which means that there can only be a few connected components that aren t just a single node In particular the largest possible connected component size is 21 since a connected graph with edges has at most nodes This means that for each connected component we can iterate over all of the subsets of nodes in that component and check whether the subset is a valid choice i e is an independent set We can then do a DP for each component where dp mask k the number of submasks of mask that have k ones and represent a valid independent set subset of the component Finally we can iterate over the total number of mercenaries we want We can then do a knapsack over each of the components making sure to only consider nodes in each component where and work with our number of mercenaries Finally we determine how many valid mercenaries are available outside of our components and the rest is a simple choose function Code 90977154 ,Let s rephrase the fifth condition Each edge should connect two vertices with the numbers of different parity either to or to So the graph should actually be bipartite and the first partition should have only the odd numbers or and the second partition should have only the even numbers only Notice how and are completely interchangeable in the sense that if you have exactly vertices which should be assigned odd numbers then you can assign whichever of them to and the rest to you want So you can guess that the first step is to check if the given graph is bipartite If it isn t then the answer doesn t exist It can be done with a single dfs Actually the algorithm for that extracts the exact partitions which comes pretty handy If the graph was a single connected component then the problem would be easy Just check if either the first partition or the second one has size and assigned its vertices color If neither of them are of size then the answer obviously doesn t exist However the issue is that there might be multiple connected components and for each of them you can choose the partition to assign to independently Still each of the connected components should be bipartite for the answer to exist This can be done with a knapsack like dp Let the th connected component have partitions of sizes Then the state can be is true if connected components are processed and it s possible to assign to exactly vertices of these components As for transitions for the th component you can either take the partition with vertices or with vertices Thus if is true then both of and are also true If is false then there is no answer Otherwise you can always restore the answer through the dp The easiest way is probably to store not true false in but three values for false for the case the state is reached by taking the first partition of the th component and for the second partition Also you should store not only the sizes of the partitions but the vertices in each of them as well This way you can recover the answer by backtracking from the final state Overall complexity 
584,Max wants to buy a new skateboard He has calculated the amount of money that is needed to buy a new skateboard He left a calculator on the floor and went to ask some money from his parents Meanwhile his little brother Yusuf came and started to press the keys randomly Unfortunately Max has forgotten the number which he had calculated The only thing he knows is that the number is divisible by You are given a string consisting of digits the number on the display of the calculator after Yusuf randomly pressed the keys Your task is to find the number of substrings which are divisible by A substring can start with a zero A substring of a string is a nonempty sequence of consecutive characters For example if string is then we have four substrings that are divisible by and For the string the answer is three As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,The key observation is that the number is divisible by if and only if its last two digits forms a number divisible by So to calculate the answer at first we should count the substrings of length one Now let s consider pairs of consecutive digits If they forms a two digit number that is divisible by we should increase the answer by the index of the right one ,Let s denote for the maximum number of moves for which the numbers and can be made equal It is easy to understand that the number of moves is maximum when and each time we divided or by a prime number That is sum of exponents of prime divisors of sum of exponents of prime divisors of Let s denote by the minimum number of moves for which the numbers and can be made equal Consider a few cases If then If or then Otherwise then Then the answer is possible in the following cases and and or and 
585,You are given a rooted tree consisting of vertices Vertices are numbered from to Any vertex can be the root of a tree A is a connected undirected graph without cycles A is a tree with a selected vertex which is called the The tree is specified by an array of parents containing numbers is a parent of the vertex with the index The of a vertex is a vertex that is the next vertex on the shortest path from to the root For example on the simple path from to the root the next vertex would be so the parent of is The root has no parent so for it the value of is the root is the only vertex for which Find such a set of paths that each vertex belongs to exactly one path each path can contain one or more vertices in each path each next vertex is a son of the current vertex that is paths always lead down from parent to son number of paths is For example if and then the tree can be divided into three paths path of vertices path of vertices path of vertices ,Let s find a set of leaves of a given tree From each leaf we will climb up the tree until we meet a vertex already visited Having met such a vertex start a new path from the next leaf The sequence of vertices in the found paths must be deduced in reverse order because the paths must go from bottom to top It also follows from this solution that the number of paths will always be equal to the number of leaves in the tree ,Let s start with the solution and then proceed to the proof For each tree in a forest find such a vertex that the maximal distance from it to any vertex is minimal possible a center of a tree Tree may include two centers take any of them in that case Find the the tree with the maximum diameter Connect the centers of other trees with its center Overall complexity is the complexity of looking for a diameter or The center is the best vertex in a tree to connect to The diameter of merging two trees and by in and in with being the maximum shortest path from to any other vertex in being the same for in is Thus minimizing both and will produce the best result The most optimal structure is a star The center tree will be connected directly to any other tree The other trees will be connected through a single vertex among each other which leads to the answer no more than 1 worse than connecting them directly And building the answer the other way will exceed this difference as some tree will be connected to the center tree of the star through one vertex as well The previous fact implies that the center tree of the star should have the maximal diameter among all trees 
586,A championship is held in Berland in which players participate The player with the number has tokens The championship consists of games which are played according to the following rules in each game two random players with non zero tokens are selected the player with more tokens is considered the winner of the game in case of a tie the winner is chosen randomly the winning player takes all of the loser s tokens The last player with non zero tokens is the winner of the championship All random decisions that are made during the championship are made equally probable and independently For example if then one of the options for the game there could be other options is during the first game the first and fourth players were selected The fourth player has more tokens so he takes the first player s tokens Now during the second game the fourth and third players were selected They have the same number of tokens but in a random way the third player is the winner Now during the third game the second and third players were selected The third player has more tokens so he takes the second player s tokens Now the third player is declared the winner of the championship Championship winners will receive personalized prizes Therefore the judges want to know in advance which players have a chance of winning i e have a non zero probability of winning the championship You have been asked to find all such players ,How can a player be checked if he can win the championship Obviously he must participate in all the games otherwise we will increase the number of tokens of the opponents So you can sort out all the people and play greedily with the weakest ones Such a check will work in linear time after sorting so we got a solution for The simplest solution to this problem is binary search for the answer We will sort all the players by the number of tokens they have Let s prove that if player can win then player can also win the numbers are dealt after sorting If the player was able to win then based on the strategy above he was able to defeat all the players on the prefix The player can also defeat all these players since he has at least as many tokens Now both players have to defeat all opponents with numbers and the number of chips both players have is equal to the sum of the first numbers in the array So if the player has a strategy then the player can use the same strategy Hence the answer to the problem is sorted suffix of the input array You can find this suffix using binary search and linear time checking Bonus this problem also has a fully linear after sorting solution ,For each game we want to seat people at tables of them will be big and will sit at them and will be small Each round people will sit at the big tables Let s put people with numbers at large tables in the first round for convenience we index from zero and the rest for small ones in the second round we will seat people at large tables with numbers and so on We cycle through the players from to in blocks of Since no one person can be ahead of any other by 2 or more large tables 
587,You are given uppercase Latin letters A and letters B The period of the string is the smallest such positive integer that indexed for each Note that this implies that won t always divide For example the period of string ABAABAA is the period of AAAA is and the period of AABBB is Find the number of different periods over all possible strings with letters A and letters B ,Let s introduce the slightly naive solution Iterate over all values for periods and check the possibility of each one being correct The conditions for some period can be formulated the following way is the total length of the string is the number of full periods of length Let s find at least one such pair and such that and the remainder part of the string can be filled with letters A and letters B By easy construction one can deduce that the conditions of and are enough Thus should be greater or equal to and In order to move to the faster solution one should also remember that both remainder parts and should be non negative Let s learn how to solve the problem for the whole range of lengths which all have the number of full periods equal to the same value Let this range be From the aforementioned formulas one can notice that the restrictions on both and don t depend on the length itself but only on value of To be more specific The lowest and the highest values for and will be the following It is claimed that every value between and exists if the values are valid and The full proof about the given conditions being sufficient and the existence of every value on that range is left to the reader Some kind of a hint might be the suggestion to check how the inequalities change on the transition from some period to Restrict the values by and to count each answer on exactly one range of lengths Finally the value of is added to the answer The number of ranges with the same is Overall complexity ,Unfortunately it seems we failed to eliminate bitset solutions The approach in our model solution is the following Firstly let s try to find some naive solution for calculating the distance between two strings We may build an undirected graph where vertices represent letters and edges represent that one letter must be transformed into another Then all letters in the same component should become one letter so the answer is the number of distinct letters minus the number of components Then let s get back to original problem For every substring of we have to find which letters have to be merged to make it equal with This can be done with the help of FFT to find all positions in substrings of with character that coincide with occurences of in we may compute a convolution of two following arrays set to every position in where occurs and to every position in where occurs all other elements should be After trying these convolutions for every pair of different characters we compute the answer for every substring using DFS or any other method 
588,You have a sequence with elements Let s call as inversion in a pair of indices such that Suppose you have some permutation of size and you build a sequence of size in the following manner Your goal is to find such permutation that the total number of inversions in doesn t exceed the total number of inversions in and is Small reminder the sequence of integers is called a permutation if it contains all integers from to exactly once Another small reminder a sequence is than another sequence if either is a prefix of or for the first such that holds in the first position that these sequences are different has smaller number than ,At first let s look at sequence Let s prove that the number of inversions in is the same regardless of what are the only condition is that should be distinct Let s group all elements by their value there will be or elements in each group Then we can take any two groups with values and and calculate the number of inversions between elements in these groups It s easy to note that construction will always be like or and regardless of or in both cases there will be exactly two inversions between groups equal to and to or one inversion in the second case So the total number of inversion will be equal to Now we can split sequences and into two parts Let then the first part is elements from segment and the second is from Note that the second parts both in and are exactly the sequence described above The total number of inversions is equal to the sum of inversions in the first part in the second part and the inversions with elements from both parts Note that in the first and the third components are equal to and the second component is constant so in we must also have inversions in the first part and inversion between parts It means that must start from But since the number of inversions in the second part is constant we can set the remaining elements the way we want And since we want to build lexicographically maximum we should make the second part as In the end optimal is The permutation to make such is equal to ,Firstly let s solve the easier version of the problem Assume we are given a permutation not an array Notice that the given operation applied to some segment of the permutation cannot change the parity of number of inversions the number of inversions is the number of such pairs of indices that and So if the number of inversions in the given permutation is odd then we can t sort this permutation we can t obtain zero inversions But if the number of inversions is even then we can always sort the permutation with the following greedy algorithm let s find the minimum element and move it to the first position If its position is then we can apply the operation to the segment and our element will move by two positions to the left So after all our element is either at the first or at the second position If it s at the second position let s just apply two additional operations to the segment Then let s just cut off the first element and solve the problem without it At the end we have only two numbers that can be not sorted and we can check all three possibilities and choose one which is suitable for us it s always exists because the number of inversions is even How do we solve the problem if we are given the array not the permutation First of all we can prove that if the array contains at least two equal elements we can always sort it we will prove it by construction Let s just renumerate the elements of the given array in a way to obtian the permutation with the even number of inversions Thus if then let s find such a permutation that We can find this permutation easily if we sort the array of pairs in increasing order But there can be one problem this permutation can have odd number of inversions Then we need to find two consecutive pairs with the same first values and swap these two elements in the permutation Because in fact these two numbers are equal in the array and have consecutive values in the permutation we guaranteed change the parity of number of inversions Then we can apply our algorithm for permutations and solve the problem for the array If we failed then the answer is Otherwise the number of operations always does not exceed because this sort works like a bubble sort so our answer is suitable Time complexity 
589, You may use in C in Java in Python or in Pascal to flush the output If you use some other programming language consult its documentation You may also refer to the guide on interactive problems https codeforces com blog entry 45307 You are given a string consisting of lowercase Latin letters This string was cyphered as follows initially the jury had a string consisting of lowercase Latin letters Then they applied a sequence of no more than possibly zero operations th operation is denoted by two integers and and means swapping two elements of the string with indices and All operations were done in the order they were placed in the sequence For example if is and following operations are performed then after the first operation the current string is and after the second operation the current string is so is You are asked to restore the original string Unfortunately you have no information about the operations used in the algorithm you don t even know if there were any operations in the sequence But you may run the same sequence of operations on any string you want provided that it contains only lowercase Latin letters and its length is and get the resulting string after those operations Can you guess the original string asking the testing system to run the sequence of swaps no more than times ,Since a sequence of swaps denotes some permutation let s try to restore the permutation that was used to transform into and then get by applying inverse permutation If was or less then we could get just by asking one query send a string where no character occurs twice and the resulting positions of characters uniquely determine the permutation Unfortunately may be greater than but we can ask more than one query The main idea is the following for each index we may choose a triple of characters so all triples are distinct There are different triples and that s greater than so each index can be uniquely determined Then after we choose a triple for each index ask three queries as follows in the first query the th character of the string is the first character in the triple representing index in the second query we use the second characters from all triples and in the third query the third characters Let and be the strings we sent and and be the strings we received as answers The permutation maps index to index if and only if and because if some other index is mapped to then at least one of the aforementioned equalities is false since all triples of characters are distinct Using this fact we may recover the permutation ,The naive solution is dynamic programming let be the probability that the first problems don t have any inversions and the th one got accepted solutions Let s somehow speed it up For convenience I will modify the variable denoting the maximum number of accepted solutions for each problem and I will also reverse the problem order so that we don t want the number of solutions to decrease from problem to problem We know that if and otherwise Let s divide the whole segment between and into segments with the values of and and analyse the behavior of values on each such segment Let If we consider the behavior of on some segment we got we can prove by induction that it is a polynomial of degree not exceeding All that is left is to carefully calculate and maintain these polynomials on segments The main thing we will use to calculate the polynomials is interpolation To transition from to we will consider each segment separately calculate the first several values of on each segment we need to calculate the sum fast if is a polynomial this can also be done with interpolation and then interpolate it on the whole segment This is actually slow we have to interpolate at least polynomials and not easy to write Let s consider a better solution We will use combinatoric approach instead of calculating probabilities we will count all the non descending sequences such that and divide it by the number of all sequences without the non descending condition that is just Let s again divide into segments using the points and enumerate these segments from left to right If there are two neighboring values and they either belong to the same segment or the segment belongs to is to the right of the segment belongs to We could try to write the following dynamic programming solution is the number of non descending prefixes of the sequence such that there are elements in the prefix and the last one belongs to segment It s easy to model transitions from to where but we don t know how to model the transition to Let s get rid of them altogether We will introduce an additional constraint in our dynamic programming is the number of prefixes of the sequence of length The transitions in this dynamic programming are different we iterate on the number of elements belonging to the next segment and transition into if possible Calculating the number of ways to take elements from an interval in sorted order can be reduced to calculating the number of ways to compose as the sum of non negative summands order matters We should be able to calculate binomial coefficients with fairly large and not so large but that s not really hard if we use the formula 
590,You are given three positive i e strictly greater than zero integers and Your task is to find positive integers and such that and or determine that it is impossible to find such and You have to answer independent test cases Print required and in any arbitrary order ,Suppose If then the answer is because is the overall maximum among all three integers and and it appears in two pairs so it should appear at most twice among and Otherwise the answer exists and it can be and it is easy to see that this triple fits well ,For all elements of the arrays to become equal after subtraction of units for must be satisfied In addition if there exists then the equality can be obtained only by subtracting exactly units from Since the equality must be satisfied for all the problem is reduced to checking that for all differences are equal and for the difference does not exceed 
591,You have a bag which contains cards There is a number written on each card the number on th card is You are playing the following game During each turn you choose and remove a random card from the bag all cards that are still left inside the bag are chosen equiprobably Nothing else happens during the first turn but during the next turns after removing a card let the number on it be you compare it with the card that was removed during the previous turn let the number on it be Possible outcomes are if the game ends and you lose if the game ends and you win if the game continues If there are no cards left in the bag you lose You have to calculate the probability of winning in this game It can be shown that it is in the form of where and are non negative integers and Output the value of ,Let s solve the problem by dynamic programming Let be the probability of winning if the last taken card has number on it and the number of taken cards is We win immediately next turn if we take card with number on it The probability of this is where is number of cards with Also we can win if we take a greater card next turn We take a card with number with probability with number with probability and so on The probability of winning in this case will be and respectively So the probability of winning for is Therefore all we need is to maintain the sum while calculating our dynamic programming ,Let s solve the problem using dynamic programming the maximal probability of Ivans victory if the siths from the already fought and the th sith left alive To calculate that DP we should iterate over the next sith he will fight against the th sith 
592,Tree is a connected graph without cycles A leaf of a tree is any vertex connected with exactly one other vertex You are given a tree with vertices and a root in the vertex There is an ant in each leaf of the tree In one second some ants can simultaneously go to the parent vertex from the vertex they were in No two ants can be in the same vertex simultaneously except for the root of the tree Find the minimal time required for all ants to be in the root of the tree Note that at start the ants are only in the leaves of the tree ,Easy to see that the answer is equal to the answer over all sons of the root plus one Now let s solve the problem independently for each son of the root Let be the array of the depths of all leaves in the subtree of the vertex Let s sort Statement 1 it s profitable to lift the leaves in order of their appearing in Statement 2 denote the time of appearing the th leaf in the vertex let s consider the leaves and then Statement 3 where is the depth of the th leaf in the subtree of the vertex The last statement gives us the solution for the problem we should simply iterate over from left to right and recalculate the array by formula from the third statement All statements can be easily proved and it s recommended to do by yourself to understand better the idea of the solution ,The first idea is the following it is always profitable to add the edges from the vertex to any other vertex The proof is the following if we will add two edges and then the distance to the vertex will be the distance to the vertex will be But we can add edges and and this will be better in fact you cannot obtain the less answer by adding two edges in the other way The main idea is the following Let s carry all vertices of the tree with the distance more than in the set Let the vertex with the maximum distance be What we will obtain if we will add the edge The distance to the vertex will be and the distance to the vertex where is the parent of the vertex if we will root the tree by the vertex will be So we will make reachable at most two vertices if the vertex is already reachable then it will be not counted in the answer Now what we will obtain if we will add the edge We will make reachable all the vertices adjacent to the vertex and the vertex the number of such vertices is not less than so this move won t make the answer greater instead of any other way to add the edge After adding such edge let s remove the vertex and all vertices adjacent to it from the set We need to repeat this algorithm until the set will not become empty Time complexity is I sure that there exists the solution with the dynamic programming in the linear time I will be very happy if someone will explain it to other participants 
593,There are shovels in the nearby shop The th shovel costs bourles Misha has to buy shovels Each shovel can be bought Misha can buy shovels by several purchases During one purchase he can choose any subset of remaining non bought shovels and buy this subset There are also special offers in the shop The th of them is given as a pair and it means that if Misha buys shovels then of them are for free i e he will not pay for most cheapest shovels during the current purchase Misha can use any offer any possibly zero number of times but he cannot use offer during but he can buy shovels without using any offers Your task is to calculate the minimum cost of buying shovels if Misha buys them optimally ,First of all since we are going to buy exactly shovels we may discard most expensive shovels from the input and set and solve the problem which requires us to buy all the shovels Also let s add an offer which allows us to buy shovel and get cheapest of them for free to simulate that we can buy shovels without using offers Now we claim that if we sort all the shovels by their costs it s optimal to divide the array of costs into some consecutive subarrays and buy each subarray using some offer Why should the sets of shovels for all purchases be consecutive subarrays Suppose it s not so let s pick two purchases such that they are mixed in the array of costs i e there exists at least one shovel bought in the first purchase such that there exists a shovel cheaper than it and a shovel more expensive than it both bought in the second purchase If shovel is for free then we may swap shovels and otherwise we may swap shovels and and the answer won t become worse So we can do it until all purchases correspond to subsegments in the array of costs Then it s easy to see that we can make purchases in such a way that we always buy some amount of cheapest shovels And now the problem can be solved by knapsack like dynamic programming let be the minimum cost to buy exactly cheapest shovels is and for each offer we can update by the value of where is the sum of costs of all shovels in the sorted order from shovel on position to shovel on position inclusive these sums can be calculated in using partial sums method ,Notice that if we take offer exactly months before we buy the car it will provide us with money at the time of the car purchase Moreover the only values of that make sense are This means we can immediately solve the problem via an algorithm for the assignment problem such as min cost flow or the Hungarian algorithm This has a runtime of or which manages to fit under the time limit with a good implementation Code 49033783 The better solution is to notice that for all offers where we don t use up all months it s best to sort them by so that the highest values of have the lowest values of This leads to a very nice DP solution 49035446 
594,You are given a long decimal number consisting of digits from to You also have a function that maps every digit from to to some possibly the same digit from to You can perform the following operation choose a non empty of digits in and replace each digit from this segment with For example if and you choose the segment consisting of three rightmost digits you get as the result What is the maximum possible number you can obtain applying this operation no more than once ,Let s find the first digit in a that becomes greater if we replace it obviously if there is no such digit then the best solution is to leave a unchanged In the optimal solution we will replace this digit and maybe some digits after this Why is it so It is impossible to make any of the previous digits greater since we found the first digit that can be replaced with a greater one Then let s analyze all digits to the right of it We should not replace any digit with a lower digit because it is better not to replace it and all digits to the right of it at all but there s nothing wrong with replacing any other digits So the segment we need to replace begins with the first digit that can become greater after replacing and includes this digit and goes to the right until the first digit that becomes less after replacing and this digit is excluded ,There are multiple ways to solve this problem Most interpreted languages have some function that takes the string evaluates it as code and then returns the result One of the examples is the function in Python If the language you use supports something like that you can read the input as a string and use it as the argument of such a function Suppose you use a language where this is impossible There are still many approaches to this problem The most straightforward one is to take the first and the last characters of the input string calculate their ASCII codes and then subtract the ASCII code of the character from them to get these digits as integers not as characters Then you can just add them up and print the result 
595,There is a house with flats situated on the main street of Berlatov Vova is watching this house every night The house can be represented as an array of integer numbers where if in the th flat the light is on and otherwise Vova thinks that people in the th flats are disturbed and cannot sleep if and only if and and Vova is concerned by the following question what is the minimum number such that if people from exactly pairwise distinct flats will turn off the lights then nobody will be disturbed Your task is to find this number ,The first observation is that we are interested only in patterns of kind All other patterns don t make sense at all So let s build a greedy approach Let s iterate over the given array from the left to the right and maintain that the prefix of the given answer is already correct If now we are at some position and and the prefix from to is already correct then which one we have to replace When we replace the left one then we cannot do better in the future but when we replace the right one then we can fix some on the suffix of the array The easiest example is If now we are at the position then we will do better if we will set ,For each index we will find the number of pairs before swapping such that is the first occurence of in the chosen segment Let be previous occurence of before if is the first occurence then if we suppose the array to be indexed Let s find the number of pairs such that and then multiply it by and subtract for this index has to be in segment and has to be in segment so the number of ways to choose this pair is The value we receive as the sum of these values over all segments is the total number of distinct elements over all pairs so we need to divide it by the number of these pairs 
596,Berland Football Cup starts really soon Commentators from all over the world come to the event Organizers have already built commentary boxes regional delegations will come to the Cup Every delegation should get the of the commentary boxes If any box is left unoccupied then the delegations will be upset If is not divisible by it is impossible to distribute the boxes to the delegations at the moment Organizers can build a new commentary box paying burles and demolish a commentary box paying burles They can both build and demolish boxes arbitrary number of times each time paying a corresponding fee It is allowed to demolish all the existing boxes What is the minimal amount of burles organizers should pay to satisfy all the delegations i e to make the number of the boxes be divisible by ,Notice that you need to check just two numbers the closest one less or equal to and the closest one greater than Distances to them are and respectively Now you should multiply the first result by the second result by and compare the products Overall complexity ,Let s look at some facts At first the answer is the sum of weights taken with some coefficients So it s enough to calculate those coefficients Then can be calculated by iterating on the size of the subset containing th element where is the number of partitions of set with elements into nonempty subsets with one subset of fixed size where belongs This solution is still quite slow so the next fact is if two elements and belong to the same subset then increases the coefficient before So for each element we can iterate over all elements which will lie in one subset with In other words is the number of ways to divide set with elements into subsets in such a way that elements and wil lie in one subset can be calculated using Stirling numbers of the second kind let be the number of partitions of set with elements into non empty subsets If then else we just merge and into one element and let Final formula is And the answer is Counting Stirling numbers can be done with inclusion exclusion principle or by searching Wiki Resulting complexity is 
597,Mishka has got empty boxes For every th box is a cube with side length Mishka can put a box into another box if the following conditions are met th box is not put into another box th box doesn t contain any other boxes box is smaller than box Mishka can put boxes into each other an arbitrary number of times He wants to minimize the number of boxes A box is called iff it is not put into some another box Help Mishka to determine the minimum possible number of boxes ,You can always show that the answer is equal to the amount of boxes of the size appearing the most in array Result can be easily obtained by constructive algorithm take these most appearing boxes put smaller boxes in decreasing order of their size into free ones there always be space and put resulting boxes into the larger ones in increasing order Overall complexity ,Let s maintain all elements of the array b in a set that allows multiple copies of equal elements for C Then let s iterate from left to right over the array a and try to minimize the current element in array c This order will minimize the resulting array by lexicographical comparing definition So for the i th element a i let s find the minimum element greater than or equal to n a i in the set because n a i will give us remainder 0 n a i 1 will give us remainder 1 and so on If there is no greater or equal element in the set then let s take the minimum element of the set and take it as a pair for a i otherwise let s take this greater or equal element and remove it from the set Time complexity O n log n 
598,Timur has candies The th candy has a quantity of sugar equal to So by eating the th candy Timur consumes a quantity of sugar equal to Timur will ask you queries regarding his candies For the th query you have to answer what is the number of candies he needs to eat in order to reach a quantity of sugar or print if it s not possible to obtain such a quantity In other words you should print the minimum possible such that after eating candies Timur consumes a quantity of sugar of at least or say that no possible exists Note that he can t eat the same candy twice and queries are independent of each other Timur can use the same candy in different queries ,Let s solve the problem with just one query Greedily we should pick the candies with the most sugar first since there is no benefit to picking a candy with less sugar So the solution is as follows sort the candies in descending order and then find the prefix whose sum is This is per query which is too slow for us To speed it up notice that we just need to find a prefix sum at least So if we compute the prefix sums of the reverse sorted array we need to find the first element that is at least Since all elements of are positive the array of prefix sums is increasing Therefore you can binary search the first element This solves the problem in per query Total time complexity ,Let s denote the number of sections in the th radiator as Let s prove that in the optimal answer Proof by contradiction suppose we have and in the answer let s move from to and check The answer is not optimal contradiction Finally there is the only way to take with And it s to take elements with value and elements with 
599,You are given a string consisting only of characters 0 and 1 You have to choose a contiguous substring of and remove all occurrences of the character which is a strict minority in it from the substring That is if the amount of 0 s in the substring is strictly smaller than the amount of 1 s remove all occurrences of 0 from the substring If the amount of 1 s is strictly smaller than the amount of 0 s remove all occurrences of 1 If the amounts are the same do nothing You have to apply the operation What is the maximum amount of characters that can be removed ,Let s try to estimate the maximum possible answer Best case you will be able to remove either all zeros or all ones from the entire string Whichever has the least occurrences can be the answer If the amounts of zeros and ones in the string are different this bound is actually easy to reach just choose the substring that is the entire string If the amounts are the same the bound is impossible to reach Choosing the entire string will do nothing and asking a smaller substring will decrease the answer The smallest we can decrease the answer by is If you choose the substring that is the string without the last character you will decrease one of the amounts by one That will make the amounts different and the bound will be reached Overall complexity per testcase ,Let s solve the task as if there are no updates This can be done with a pretty straightforward dp is the number of pairs such that the result of the strange addition of and is the prefix of of length From each state you can add a single digit to and to at the same time You can either go to and multiply the answer by the number of pairs of digits than sum up to Or go to and multiply the answer by the number of pairs of digits than sum up to Note that no pair of digits can sum up to a three digit value so it makes no sense to go further Let s optimize this dp with some data structure Segment tree will work well Let the node store the number of ways to split the segment into blocks of size or so that both the leftmost character and the rightmost character are not taken into any block the leftmost character is taken into some block and the rightmost character is not taken into any block the leftmost character is not taken into any block and the rightmost character is taken into some block both the leftmost and the rightmost characters are taken into some blocks This structure makes the merge pretty manageable You should glue up the segments in such a way that all the middle characters are taken into some block either in separate blocks in their own segments or into the same block of length The answer will be in the root of the tree in a value such that both characters are taken The update in the segment tree will still work in Overall complexity 
600,You are given patterns and strings Each pattern consists of characters that are either lowercase Latin letters or wildcard characters denoted by underscores All patterns are pairwise distinct Each string consists of lowercase Latin letters A string matches a pattern if for each from to either is a wildcard character or You are asked to rearrange the patterns in such a way that the first pattern the th string matches is You are allowed to leave the order of the patterns unchanged Can you perform such a rearrangement If you can then print any valid order ,Let s write down the indices of the pattern that the th string matches If is not among these then the answer is Otherwise all the patterns except should go in the resulting ordering after Consider that as a graph Let s add an edge from to each of the matches If you add the edges for all the strings then the topological ordering of the graph will give you the valid result If the graph has any cycles in it you can t topsort it then there is no answer To find all the patterns we can use the fact that is rather small Consider all the binary masks of length Each mask can correspond to a set of positions in the string that are replaced with wildcards Now if there is a pattern that is exactly equal to the string with the fixed set of positions replaced by wildcards then that pattern is a match To search for an exact match you can either store all patterns in a map beforehand or in a sorted array or build a trie of them The second version is faster by a factor of but both solutions should pass easily Overall complexity or ,In this problem you should simply find the symmetric letters by picture and also observe that the pairs and is the symmteric reflections 
601, wants to generate an input file for some programming competition problem His input is a string consisting of letters a He is too lazy to write a generator so he will manually generate the input in a text editor Initially the text editor is empty It takes him seconds to insert or delete a letter a from the text file and seconds to copy the contents of the entire text file and duplicate it wants to find the minimum amount of time needed for him to create the input file of exactly letters a Help him to determine the amount of time needed to generate the input ,This problem has a simple solution described by participants in the comments My solution is a little harder Let s solve it using dynamic programming Let be the smallest amount of time needed to get letters a Let s consider transitions the transition for adding one letter a can be simply done Let s process transitions for multiplying by two and subtraction by one simultaneously let s decrease the number times by one right after getting it Easy to see that such updates never include each other so we can store them in queue by adding the new update at the tail of the queue and taking the best update from the head The solution is hard to describe but it is very simple in the code so please check it to understand the idea ,If we represent letters with digits then the answer can be represented as There is no substring containing more than distinct characters and each substring of length contains exactly distinct characters because of the condition Time complexity 
602,You are given two arrays and both of length All elements of both arrays are from to You can reorder elements of the array if you want you may leave the order of elements as it is After that let array be the array of length the th element of this array is where is modulo Your task is to reorder elements of the array to obtain the minimum possible array Array of length is lexicographically less than array of length if there exists such that and for any ,Let s maintain all elements of the array b in a set that allows multiple copies of equal elements for C Then let s iterate from left to right over the array a and try to minimize the current element in array c This order will minimize the resulting array by lexicographical comparing definition So for the i th element a i let s find the minimum element greater than or equal to n a i in the set because n a i will give us remainder 0 n a i 1 will give us remainder 1 and so on If there is no greater or equal element in the set then let s take the minimum element of the set and take it as a pair for a i otherwise let s take this greater or equal element and remove it from the set Time complexity O n log n ,Let s denote as just a suffix sum And let be the position where starts the th subarray obviously and Then we can make an interesting transformation So our task is equivalent to choosing sum of all array and different suffix sums And we want to maximize their total sum That s why we can just greedily take maximum suffix sums along with sum of all array 
603,You are given an undirected unweighted connected graph consisting of vertices and edges It is guaranteed that there are no self loops or multiple edges in the given graph Your task is to find spanning tree of this graph such that the is equal to or say that there are no such spanning trees Recall that the degree of a vertex is the number of edges incident to it ,Firstly let s remove the vertex from the graph Then let s calculate the number of connected components Let it be The answer is if and only if or is greater than the number of edges incident to the first vertex Otherwise let s construct the answer Firstly let s add into the new graph spanning trees of components in the initial graph without vertex Then let s add into the new graph edges from vertex one edge to each component Then let s add into the new graph any remaining edges from vertex The last thing we need is to construct a spanning tree of a new graph such that all edges incident to the vertex are in this spanning tree and other edges doesn t matter How to do it Let s run from the vertex in a new graph ,If all districts belong to the same gang then the answer is Otherwise the answer is always yeah as in the previous problem How to construct it Let s choose the first root as the district and connect all such districts that to the district So all disconnected districts that remain are under control of the gang Let s find any district that and just connect all remaining districts of the gang to this district This district always exists because we have at least two different gangs and it is connected to the remaining structure because its gang is not So all conditions are satisfied 
604,The letters shop showcase is a string consisting of lowercase Latin letters As the name tells letters are sold in the shop Letters are sold one by one from the leftmost to the rightmost Any customer can only buy some prefix of letters from the string There are friends the th of them is named Each of them is planning to estimate the following value how many letters the length of the shortest prefix would s he need to buy if s he wanted to construct her his name of bought letters The name can be constructed if each letter is presented in the equal or greater amount For example for and letters have to be bought For example for and letters have to be bought For example for and letters have to be bought For example for and letters have to be bought For example for and all letters have to be bought It is guaranteed that every friend can construct her his name using the letters from the string Note that the values for friends are independent friends are only estimating them but not actually buying the letters ,Let s construct the answer letter by letter How to get enough letters a for the name Surely the taken letters will be the first a the second a up to th a in string where is the amount of letters a in the name It s never profitable to skip the letter you need Do the same for all letters presented in the name The answer will the maximum position of these last taken letters How to obtain the th letter fast Well just precalculate the list of positions for each letter and take the needed one from it Overall complexity ,Let s consider a very special case of equal distances What if all distances were equal to It implies that if some letter appears exactly twice both occurrences are placed right next to each other That construction can be achieved if you sort the string for example first right down all letters a then all letters b and so on If a letter appears multiple times all its occurrences will be next to each other just as we wanted Overall complexity or per testcase 
605,A known chef has prepared dishes the th dish consists of grams of fish and grams of meat The banquet organizers estimate the of dishes as follows The is equal to the absolute value of the difference between the total mass of fish and the total mass of meat Technically the equals to The smaller the the better In order to improve the a taster was invited He will eat grams of food from each dish For each dish the taster determines separately how much fish and how much meat he will eat The only condition is that he should eat exactly grams of each dish in total Determine how much of what type of food the taster should eat from each dish so that the value of the is as minimal as possible If there are several correct answers you may choose any of them ,Let s find how much meat and fish a taster can eat at most Note that a taster can eat no more than of fish from the th dish since he can t eat more than or more than there is at all Similarly he can eat no more than of meat Let s sum the obtained values over all and denote the resulting sums by and the maximum total amount of fish and meat that can be eaten Let s denote by the value that is the without module If the taster eats as much fish as possible he will eat of fish and of meat and change the by Similarly if he eats the maximum amount of meat the will change by Note that the taster can achieve any between and of the same oddity as both of these numbers To do this just take the way of eating the maximum fish and substitute eating a gram of fish for a gram of meat several times Thus the final can be found as over all between and with same oddity To do this just check the boundaries of the resulting segment if they have the same sign then it s the boundary with the smallest absolute value otherwise we can take one of the numbers present in said set depending on the parity of All that remains is to find how much of what type to eat from each dish Having obtained the answer in the previous paragraph the final balance we can reconstruct how much fish and how much meat the taster has to eat to achieve it The expected amount of fish to be eaten can be found as Note that the taster must eat of fish from the th dish since if meat then at least of fish is guaranteed to be eaten Let s break down into the sum of how much total fish will have to be eaten anyway and the remaining value Let s go through all the dishes and collect the first summand as just the sum of over all and the second summand with greedy algorithm each time giving the taster as much fish beyond what he must eat anyway until the sum of such additions reaches And knowing for each dish how much fish will be eaten from it the amount of meat eaten can be calculated by subtracting the fish eaten from ,Obviously the best way to buy food for every pet is to buy maximum possible food for dogs and cats then dogs and cats will not get food We will buy universal food for these dogs and cats Then the answer is if and else 
606,Let s name a pair of positive integers if the greatest common divisor of them is equal to Let s define a induced by as a sequence of pairs for some integer The of the chain is the number of pairs it consists of or Let s name such chain if all pairs in the chain are lucky You are given pairs Calculate for each pair the length of the longest lucky chain induced by this pair Note that if is not lucky itself the chain will have the length ,Suppose It means that is also divisible by or is divisible by And backward if then is also divisible by or is divisible by Since is divisible by and is divisible by so In other words we proved that Now knowing the equivalence above we can understand that we are looking for the smallest such that In other words we are searching such that is divisible by some where is some divisor of The problem is that there are a handful of divisors for some But we can note that we can consider only divisors of if and is composite then there is some prime thus It s easy to prove that there are no more than prime divisors of some Now the question is how to find all these prime divisors Note that if you know only one prime divisor for each value from to then you can find all prime divisors for all in The prime divisors are next and so on until The final step is to calculate a prime divisor for each value from to where or We can do it by slight modifications of Sieve of Eratosthenes at the step where you have some prime and want to throw out all values set for each plus set As a result we firstly calculate Sieve in and secondly calculate answer for each pair in Note that the input and output is large so you should you tricks to speed up your input and output ,The answer can be calculated very easy by Euclid algorithm which is described in the problem statement but all subtractions will be replaced by taking by modulo 
607,There are people in a horizontal line each looking either to the left or the right Each person counts the number of people in the direction they are looking The of the line is the sum of each person s count For example in the arrangement where stands for a person looking left and stands for a person looking right the counts for each person are and the value is You are given the initial arrangement of people in the line For each from to determine the maximum value of the line if you can change the direction of people ,For each person let s calculate how much the value will change if they turn around For example in the line if the th person turns around then the value of the line will change by respectively For instance if the second person turns around they see people before and person after so the value of the line changes by if they turn around Now note that if a person turns around it doesn t affect anyone else s value So the solution is a greedy one let s sort the array of values in increasing order Afterwards we should go from the left to the right and see if the value will increase if this person turns around if it does we should add it to the current total and continue The time complexity of this solution is per testcase ,There are two key observations to this problem after each pair of moves the directions go back to the original ones after each move we can immediately go back and combining these observations we can derive that if we go from city to some other city we can always go back One of the solutions we can write using these observations is to build an undirected graph on vertices Each vertex represents a pair where is the city we are currently staying in and is the number of moves we made modulo Since each move is to a neighboring city each vertex is unreachable from and vice versa And since we can always go back and each pair of steps doesn t change the directions this graph is actually an undirected one So we can find the connected components of this graph using DFS BFS DSU and for each city print the size of the component the vertex belongs to Another solution is to find the leftmost and the rightmost city reachable from each city For example finding the leftmost reachable city can be done with the following dynamic programming let be the leftmost city reachable from Then if we can t go left from if we can make only one step to the left from and if we can make two steps we can take the answer from the city The same approach can be used to calculate the rightmost reachable city 
608,You are given points on Cartesian plane Every point is a lattice point i e both of its coordinates are integers and all points are distinct You may draw two straight lines not necessarily distinct Is it possible to do this in such a way that every point lies on at least one of these lines ,If the number of points is less than then the answer is obviously Else let s fix first points Check if there is a solution if st and nd points lie on the same line Just erase all points which lie on this line and check the remaining points if they belong to one line If we didn t find the answer let s check points and in the same way If its failed again then line which contains point can t contain points and so points and must lie on one line If we didn t succeed again then there is no way to do it so the answer is Checking that points and belong to the same line can be done by calculating 2d version of cross product It equals to if vectors and are collinear ,Let s solve the problem greedily Let s make the first segment by adding elements until the segment will be good After that let s make the second segment in the same way and so on If we couldn t make any good segment then the answer is Otherwise let s add all uncovered elements at the end to the last segment Easy to prove that our construction is optimal consider the first two segments of the optimal answer obviously we can extend the second segment until the first segment will be equal to the first segment in our construction 
609,Vova had a pretty weird sleeping schedule There are hours in a day Vova will sleep exactly times The th time he will sleep exactly after hours from the time he woke up You can assume that Vova woke up exactly at the beginning of this story the initial time is Each time Vova sleeps in other words hours Vova thinks that the th sleeping time is if he starts to sleep between hours and inclusive Vova can control himself and before the th time can choose between two options go to sleep after hours or after hours Your task is to say the maximum number of sleeping times Vova can obtain if he acts optimally ,This is a very standard dynamic programming problem Let be the maximum number of sleeping times if Vova had a sleep times already and the number of times he goes to sleep earlier by one hour is exactly Then the value will be the answer Initially all and What about transitions Let the current state of the dynamic programming be and Then we can don t go to sleep earlier and make the first transition The sign is modulo operation and the notation is the boolean result of the expression if is true and otherwise And the second transition if we go to sleep earlier Don t forget to don t make transitions from unreachable states Time complexity ,Note that if there are at least two members with the maximum value of then any permutation is nice Now let s consider the case when there is only one maximum Let s find out when the permutation is nice Let be the index of the jury member with the maximum number of tasks Then during the th discussion round they will be the only one who will tell their task because the other members of the jury have already told all their tasks So during the th discussion round there should be a jury member who tells a task after the th jury member Let be the number of elements in the array equal to Then if at least one of these jury members goes after the jury member in the permutation then the permutation is nice Using this we will count the number of bad permutations Let s fix the elements in the permutation that are not equal to or there are of them then the number of ways is It remains to place elements so that the maximum is in the last position among them there are such ways The total number of bad permutations is So the answer is 
610,You are given a set of segments on the axis each segment has integer endpoints between and inclusive Segments may intersect overlap or even coincide with each other Each segment is characterized by two integers and coordinates of the left and of the right endpoints Consider all integer points between and inclusive Your task is to print all such points that don t belong to any segment The point belongs to the segment if and only if ,In this problem all you need is to check for each point from to if it cannot belongs to any segment It can be done in by two nested loops or in by easy prefix sums calculation Both solutions are below ,Let s process all the segments on the line from left to right For each segment we should push events and into some array Sort this array of pair in increasing order usual less comparator for pairs Then we iterate over its elements and maintain the current amount of open segments we passed their left border and didn t pass their right border When we meet the event of the first type we increment the value of the second type decrement If in some moment then the answer is Overall complexity 
611,Luba needs your help again Luba has TV sets She knows that th TV set will be working from moment of time till moment inclusive Luba wants to switch off one of TV sets in order to free the socket Let s call some TV set if after switching it off the number of moments of time when at least one of TV sets is working won t decrease Luba will be very upset if she has to switch off a non TV set Help Luba by telling her the index of some TV set If there is no any print ,Firstly let s compress the moments of time Note that storing only and isn t enough consider pairs and you also should take Now moments of time are up to For every moment calculate the number of segments to cover it make and for each segment and take prefix sums over this array Then let be the number of moments of time covered by only one segment on some prefix up to th moment And finally if for some segment from the input is then you can safely delete this segment Overall complexity ,It is easy to show that if we choose k numbers from a permutation of length n then the minimum sum of k numbers is frac k k 1 2 the maximum sum is frac k 2n 1 k 2 and any sum between them is achievable that is you can choose exactly k numbers from n so that their sum is equal to the desired one This fact allows us to implement the following greedy solution Denote for low k sum limits i 1 k i frac k k 1 2 for high n k sum limits i n k 1 n i frac k 2n 1 k 2 and for k r l 1 We will consider the numbers i n n 1 ldots 1 and determine whether to put them in the segment l r or not If k 0 high i k ge s and s i ge low k 1 then put the number i in the segment l r decrease s by i decrease k by 1 Otherwise we will not put the number i in the segment l r In the end if s 0 then we have chosen r l 1 a number with the sum of s so the remaining number can be arranged in any order If at the end s 0 then there is no way to select r l 1 a number from 1 2 ldots n with the sum of s 
612,You should process queries over a set of strings Each query is one of three kinds Add a string to the set It is guaranteed that the string was not added before Delete a string from the set It is guaranteed that the string is in the set For the given string find the number of occurrences of the strings from the set If some string from has several occurrences in you should count all of them Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query of the third type Use functions in and in languages after each writing in your program ,Let s get rid of the queries for deleting a string There are no strings that will be added two times so we can calculate the answer for the added but not deleted strings and for the deleted separately and subtract the second from the first to get the answer So we can consider that there are no queries of deletion Now let s use Aho Corasik algorithm The only difficulty is that the strings are adding in online mode but Aho Corasik algorithm works only after adding all the strings Note that the answer for the given set of strings equal to the answer for any part of the set plus the answer for the remaining part Let s use the trick with converting the static data structure Aho Corasik in this case to the dynamic one For the set of strings let s maintain a set of no more than sets of the strings with sizes of different powers of two After adding new string we should move the sets from the lowest powers of two to the largest until we got an invariant set of sets Easy to see that each string will be moved no more than times so we can process each query in time ,First find all occurrences of in as substrings This can be done using the prefix function To find the minimum number of times we need to cut substrings consider all indexes of occurrences Having considered the index of the occurrence we cut out the rightmost occurrence that intersects with it After that we find the leftmost occurrence that does not intersect with the cut one If it doesn t we end the loop The number of optimal sequences of moves will be calculated using dynamic programming For each occurrence we can count how many ways we can cut out all occurrences of in the suffix starting with this occurrence in the minimum number of moves Considering the occurrence we find the leftmost occurrence that does not intersect with it and then iterate over the occurrences with which we can remove it 
613,You have a Petri dish with bacteria and you are preparing to dive into the harsh micro world But unfortunately you don t have any microscope nearby so you can t watch them You know that you have bacteria in the Petri dish and size of the th bacteria is Also you know intergalactic positive integer constant The th bacteria can swallow the th bacteria if and only if and The th bacteria disappear but the th bacteria doesn t change its size The bacteria can perform multiple swallows On each swallow operation any bacteria can swallow any bacteria if and The swallow operations go one after another For example the sequence of bacteria sizes and The one of possible sequences of swallows is In total there are bacteria remained in the Petri dish Since you don t have a microscope you can only guess what the minimal possible number of bacteria can remain in your Petri dish when you finally will find any microscope ,It can be proved that the optimal answer equals to a number of bacteria which can t be eaten by any other bacteria So for each bacteria you need to check existence of any bacteria satisfying condition There plenty of ways to check this condition One of them is to sort array and for each find minimal with or with two pointers technique Or you can use the fact that and build solution around it Result complexity is ,Let s denote the number of sections in the th radiator as Let s prove that in the optimal answer Proof by contradiction suppose we have and in the answer let s move from to and check The answer is not optimal contradiction Finally there is the only way to take with And it s to take elements with value and elements with 
614,Polycarp has found a table having an infinite number of rows and columns The rows are numbered from starting from the topmost one The columns are numbered from starting from the leftmost one Initially the table hasn t been filled and Polycarp wants to fix it He writes integers from and so on to the table as follows The leftmost topmost cell of the table is filled with the number Then he writes in the table all positive integers beginning from sequentially using the following algorithm First Polycarp selects the leftmost non filled cell in the first row and fills it Then while the left neighbor of the last filled cell is filled he goes down and fills the next cell So he goes down until the last filled cell has a non filled neighbor to the left look at the vertical arrow going down in the figure above After that he fills the cells from the right to the left until he stops at the first column look at the horizontal row in the figure above Then Polycarp selects the leftmost non filled cell in the first row goes down and so on A friend of Polycarp has a favorite number He wants to know which cell will contain the number Help him to find the indices of the row and the column such that the intersection of the row and the column is the cell containing the number ,Let s call a set of cells being filled from the topmost row to the leftmost column a E g the st layer consists of the single number the nd layer consists of the numbers and the rd layer consists of the numbers and etc The number of cells in layers forms an arithmetic progression The first layer consists of cells the th layer consists of cells The minimum number in the th layer is equal to the sum of sizes of all layers from the st to the th plus Suppose that belongs to the th layer Consider the value of Polycarp fills exactly cells on the th layer before he starts filling the cells from the right to the left i e while he goes down Therefore if the number belongs to the th row and the th column Otherwise the number belongs to the th row and the th column Consider a way to find the coordinates of a given number Let s iterate by the layer number to which given the number belongs calculating the values of and going to the next layer let s calculate the next layer parameters as follows The iteration must be stopped if the layer number is such that Using the values of and we can calculate the given number s coordinates in the described way in The total time of calculating the coodrinates for one given is where is the number of the layer to which the given belongs Let s represent the value of as hence Therefore the coordinates of one number may be calculated in At the same time as it follows from the formulas the layer number can be calculated as follows the square root of rounded up To avoid accuracy problems you can calculate the value using a loop ,Let s consider the optimal answer to always look like will be the leftmost position of a pillar with maximum height We will heavily use the fact that all integers from to appear in this sequence to the right of If you are able to construct any answer it is easy to rearrange it to this pattern select the leftmost maximum sort in non decreasing order and in non increasing order Sorted sequence will also be valid Let a pyramid of height be such a valid castle that it occupies exactly consecutive spots and Exactly sand packs are required to build it At first let s solve the problem without even touching the fence This won t always give the minimal answer but it ll help us further Given some you can build the pyramid of height and get sand packs left over This can fit in exactly pillars you can place any pillar of height next to some pillar of the same height That way we see that This function is non increasing let s show that for any from to is non positive Now we can show that it is always optimal to push the initial pyramid to the left as far as possible probably removing some pillars on positions less than That way the leftmost pillar will have height The total number of sand packs required to build it is This pattern will also include all the integers from to and will have the minimal width you can achieve Monotonicity of this function can be proven in the similar manner Finally the answer can be calculated using the following algorithm Find the maximum such that where Solve the equation or just do the binary search Output the width of resulting truncated pyramid plus the minimal number of additional pillars it will take to distribute leftover sand packs You should also take into consideration the upper bound on to avoid multiplying huge numbers It s about so bit integer type will be enough for all the calculations Overall complexity or 
615,The grasshopper is located on the numeric axis at the point with coordinate Having nothing else to do he starts jumping between integer points on the axis Making a jump from a point with coordinate with a distance to the left moves the grasshopper to a point with a coordinate while jumping to the right moves him to a point with a coordinate The grasshopper is very fond of positive integers so for each integer starting with the following holds exactly minutes after the start he makes a jump with a distance of exactly So in the first minutes he jumps by then by and so on The direction of a jump is determined as follows if the point where the grasshopper was before the jump has an coordinate the grasshopper jumps to the he jumps to the For example if after consecutive jumps he arrives at the point with a coordinate he will jump by a distance of to the right since is an odd number and will end up at a point Since is an even number the next jump the grasshopper will make to the left by a distance of and it will move him to the point Find exactly which point the grasshopper will be at after exactly jumps ,Consider the first four actions that the grasshopper will perform starting at a point with coordinate coordinate is jumping to leads to coordinate is jumping to leads to coordinate is jumping to leads to coordinate is jumping to leads to If you look closely at the next four jumps they follow the same pattern jump to the left two jumps to the right jump to the left In general making jumps with numbers the grasshopper will start from coordinate and move as Thus if were always zero the answer would be if if if if is divisible by Let s find an answer for the cases when But if is even then all steps will follow the same directions and the answer will be where is the answer for the same and starting point described above And if is odd then all steps will have opposite directions and the answer will be ,You can notice that moves of kind and are changing value to and Thus you can determine by checking adjacent nodes in the path The answer is if there are one or zero distinct values of differences not counting difference of You can also set to arbitrary big value it doesn t really matter until you can fit all values will work just fine Finally knowing and simulate the process and check that all moves are valid Overall complexity 
616,Polycarp has a cat and his cat is a real gourmet Dependent on a day of the week he eats certain type of food on Mondays Thursdays and Sundays he eats on Tuesdays and Saturdays he eats on other days of week he eats Polycarp plans to go on a trip and already packed his backpack His backpack contains daily rations of daily rations of daily rations of Polycarp has to choose such day of the week to start his trip that his cat can eat without additional food purchases as long as possible Print the maximum number of days the cat can eat in a trip without additional food purchases if Polycarp chooses the day of the week to start his trip optimally ,Let the number of rations of fish food be the number of rations of rabbit stew be and the number of rations of chicken stakes be so we have an array consisting of elements Let be the maximum number of full weeks cat can eat if the starting day of the trip can be any day of the week The value of is Let s subtract the value from and from and We can see that we cannot feed the cat at least one more full week So the final answer is where Now it s time for some good implementation Of course you can try to analyze all cases and handle them using ifs or something similar but I will try to suggest you a good enough way to implement the remaining part of the problem Let s create an array of length where means the type of the food cat eats during the th day of the week for fish food for rabbit stew and for chicken stake It will be Now let s iterate over the day we will start our trip Let it be For the current starting day let be the number of rations cat has eaten already initially it is zero be the current day of the trip initially it is and the array be the copy of the array Then let s do the following sequence of the operations while is greater than zero decrease by one increase by one and set take it modulo and add one After this cycle we can update the answer with the value of ,We can solve the problem with a two pointers technique Let be the left pointer initially at and be the right pointer initially at Let s store Alice and Bob s current totals as and Let s iterate from the left to the right For each we should do the following Increase by Alice eats the th candy Move leftwards until Bob s total is at least Alice s total and update every time we move If the two pointers have crossed then both Alice and Bob took the same candy which is not possible So we should exit and output the current answer Otherwise if after this step we should update the current answer to be the value that is equal to Alice and Bob Both and move at most times in total so the solution runs in 
617,You are given a set of integer numbers initially it is empty You should perform queries There are three different types of queries Add all missing numbers from the interval Remove all present numbers from the interval Invert the interval add all missing and remove all present numbers from the interval After each query you should output of the set the smallest positive integer number which is not presented in the set ,There are many ways to solve this problem you can use cartesian tree segment tree sqrt decomposition maybe something else I personally see the solution with the segment tree the easiest one so let me describe it Firstly let s notice that the queries are offline So we can compress the numbers by taking and of each query will be either one of these numbers or So now we have numbers up to and pretty basic task on segment tree The first two types of queries are translated to assign value or on a segment set the number on some position is either present or not The third is for each in segment assign to this will inverse the segment as described in statement Segment tree should keep sum of the segment in its nodes XOR on segment will turn into is the length of the segment being covered by the node The leftmost zero cell is While standing in some node check if its left son is full has in every cell of the segment like if you use 1 indexed tree and intervals for it If it is full then go down to the right son otherwise there exists some zero cell in a segment of the left child and you should go down to it You should use lazy propagation to guarantee per query Overall complexity ,Consider the following dynamic programming the minimum cost to make have value after the th line The transitions here are pretty easy on set you just consider two options of skipping or not skipping the instructions and on if you either go to the next line or to the end of the block depending on the value There are a lot of possible values so that dp works in First let s notice that all the values that don t appear in the input won t matter so you can keep only the existing values in the dp Next let s consider the following modification to it What happens when you enter an if block It s actually the same dp but the only starting value is not with cost as in the beginning of the whole program but some value with some cost So let s calculate this dp separately from the outer one and just merge the values together Notice that if some value doesn t appear inside the if block then its cost can not decrease exiting out of it Thus it s enough to calculate the inner dp only for values that appear inside the if block Okay the transitions for if became easier The set transitions are still slow though Examine the nature of them All the values besides the written on the set instruction increase their cost by As for the its cost becomes equal to the cost of the cheapest value before the instruction Thus let s maintain the dp in some data structure that allows to add the same integer to all elements and take the minimum of its elements That can be done with a set and a single integer that stores the current shift that should be applied to all elements Surely you ll also need a map to retrieve the current cost of particular values The final part is fast merging of the if block dp and the outer one It might not appear obvious but if you do that in a straightforward manner of adding all the costs from if one by one it can become in total So we can apply small to large and swap these dp s based on their sizes Overall complexity 
618,There are students in a university The number of students is even The th student has programming skill equal to The coach wants to form teams Each team should consist of exactly two students and each student should belong to exactly one team Two students can form a team only if their skills are equal otherwise they cannot understand each other and cannot form a team Students can solve problems to increase their skill One solved problem increases the skill by one The coach wants to know the minimum total number of problems students should solve to form exactly teams i e each pair of students should form a team Your task is to find this number ,If we sort the students in order of non decreasing their skill we can see that the minimum cost of the team with the lowest skill let s call it the first team is equal to if is already sorted the cost of the second team is and so on So if we sort in non decreasing order then the answer is ,This is a pretty obvious binary search problem If we get banned after messages we also get banned after and so on messages and vice versa if we don t get banned after messages we also don t get banned after and so on messages For simplicity let s split the problem into two parts when we check if we re getting banned after messages let s handle cases and separately Recall that the sum of the arithmetic progression consisting of integers is Let it be The first case is pretty simple the number of emotes we send with messages when is which is So we only need to check if The second case is a bit harder but still can be done using arithmetic progression formulas Firstly we send all messages for the number of such messages is Then we need to add messages This number equals to i e we send all messages from to and subtract messages from to from this amount The final condition is Time complexity per test case 
619,Let s call the string if it does not contain a substring of length at least which is a palindrome Recall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first For example the strings are palindromes but the strings are not Let s define of a string as the minimum number of operations so that the string becomes beautiful if in one operation it is allowed to change any character of the string to one of the first letters of the Latin alphabet in lowercase You are given a string of length each character of the string is one of the first letters of the Latin alphabet in lowercase You have to answer queries calculate the cost of the substring of the string from th to th position inclusive ,Note that in the beautiful string s i neq s i 1 because it is a palindrome of length 2 and s i neq s i 2 because it is a palindrome of length 3 This means s i s i 3 i e a beautiful string has the form up to the permutation of the letters and For each permutation of the letters and we will construct a string t of the form of length n Let s define an array a of length n as follows a i 0 if s i t i i e the character at the i th position does not need to be changed and a i 1 otherwise Let s build an array pr of prefix sums of the array a Now you can process a query of the number of positions that need to be replaced for the current line t in O 1 ,What s the issue with calculating the prefix function on the string and then appending the string with an extra recalculations Calculating prefix function is linear anyway Well it s linear but it s also amortized So while it will make operations for a string in total it can take up to on every particular letter These particular letters can appear in string making the algorithm work in Let s analyze the classic way to calculate the prefix function To append a character to the string and calculate the new value of the prefix function you have to do the following take the longest proper prefix of a string before appending the letter which is also a suffix if the letter right after it is the same as the new one then the new value is length of it plus one if it s empty then the new value is otherwise take its longest proper prefix and return to step Basically from having the value of the prefix function of the string and the new letter you can determine the new value of the prefix function If was always equal to then you would only want to try all options for the next letter after a string That should remind you of a structure known as prefix function automaton Its states are the values of the prefix function and the transitions are appending a letter to a string with a certain value of the prefix function So you can append a letter in if you have an automaton built on the string However you can t just append more letters after one you don t have the automaton built this far You can follow two paths The first one is to jump with a regular way of calculating the prefix function until you reach the state of the automaton which exists The second one is to continue building the automaton onto the string calculating the prefix function along the way Appending a layer to the automaton takes non amortized After you calculated everything you needed pop the states back to the original Overall complexity or 
620,Polycarp remembered the th year and he is happy with the arrival of the new th year To remember such a wonderful moment Polycarp wants to represent the number as the sum of a certain number of and a certain number of For example if then the number can be represented as the sum then the number can be represented as the sum then the number can be represented as the sum then the number cannot be represented as the sum of the numbers and Help Polycarp to find out whether the number can be represented as the sum of a certain number of numbers and a certain number of numbers ,Let the number of the number of Let us write the required decomposition of the number Then we get that is divisible by Take equal to the remainder of divided by Then is uniquely determined from the formula above Then if the result is that because the remainder of dividing by is non negative then can be represented as the sum of a certain number of and a certain number of ,Firstly for every we can calculate the number of paths such that is divisible by We can do it as follows generate all divisors of numbers numbers not exceeding have at most divisors so this will be fast enough and then for every analyze the graph containing the vertices that have as its divisor Each component of this graph gives us paths if its size is and this is the only formula we need to calculate the number of paths where is divisible by let this be How can we get the answer if we know the values of We can use inclusion exclusion with Mobius function for example to prove that and then if we want to apply the same technique for finding with any possible we could divide all numbers by and do the same thing But it might be too slow so it s better to rewrite this formula as because we will do exactly the same when dividing all numbers by In fact most contestants have written a much easier version of this solution so this might be a bit too complicated This problem can also be solved with centroid decomposition 
621,You are given two strings and both of length and both consisting of lowercase Latin letters In one move you can choose any length from to and perform the following operation Choose any contiguous substring of the string of length and reverse it choose any contiguous substring of the string of length and reverse it as well Note that during one move you reverse substring of the string and substring of the string Also note that borders of substrings you reverse in and in the only restriction is that you reverse the substrings of equal length For example if and you can reverse and and but not and Your task is to say if it is possible to make strings and equal after some possibly empty sequence of moves You have to answer independent test cases ,The necessary condition to make strings equal is that the number of occurrences of each character should be the same in both strings Let s show that if some character appears more than once we always can make strings equal How Let s sort the first string by swapping adjacent characters and it does not matter what do we do in the second string Then let s sort the second string also by swapping adjacent characters but choose the pair of adjacent equal characters in the first string it always exists because the first string is already sorted Otherwise all characters in both strings are distinct and they lengths are at most Then the answer is if the parity of the number of inversions the number inversions in the array is the number of such pairs of indices that but are the same It can be proven in the following way every swap of two adjacent elements changes the parity of the number of inversions Time complexity ,The only case when the answer is is when all letters of the string are equal Why is it so Because if we have at least two different letters we can place the first one at the first position of the string and the second one at the last position of the string Then it is clearly that the obtained string is We can implement this solution by the following way sort and if the first letter equals to the last one then the answer is otherwise the answer is 
622, Summer vacation has started so Alice and Bob want to play and joy but Their mom doesn t think so She says that they have to read some amount of books before all entertainments Alice and Bob will read each book to end this exercise faster There are books in the family library The th book is described by three integers the amount of time Alice and Bob need to spend to read it equals if Alice likes the th book and if not and equals if Bob likes the th book and if not So they need to choose some books from the given books in such a way that Alice likes books from the chosen set and Bob likes books from the chosen set the total reading time of these books is they are children and want to play and joy as soon a possible The set they choose is for both Alice an Bob it s shared between them and they read all books so the total reading time is the sum of over all books that are in the chosen set Your task is to help them and find any suitable set of books or determine that it is impossible to find such a set ,Let s divide all books into four groups both Alice and Bob doesn t like these books only Alice likes these books only Bob likes these books both ALice and Bob like these books Obviously group is useless now So how to solve the problem Let s iterate over the number of books we take from group Let it be Then we obviously need to take exactly books from groups and Among all books in these three groups we have to choose the cheapest ones To calculate sum of times in each group fast enought we can sort each group independently and implement prefix sums on these arrays If is less than zero or greater than the size of or group for each possible then the answer is And don t forget that the answer can be up to Time complexity ,Let s find how much meat and fish a taster can eat at most Note that a taster can eat no more than of fish from the th dish since he can t eat more than or more than there is at all Similarly he can eat no more than of meat Let s sum the obtained values over all and denote the resulting sums by and the maximum total amount of fish and meat that can be eaten Let s denote by the value that is the without module If the taster eats as much fish as possible he will eat of fish and of meat and change the by Similarly if he eats the maximum amount of meat the will change by Note that the taster can achieve any between and of the same oddity as both of these numbers To do this just take the way of eating the maximum fish and substitute eating a gram of fish for a gram of meat several times Thus the final can be found as over all between and with same oddity To do this just check the boundaries of the resulting segment if they have the same sign then it s the boundary with the smallest absolute value otherwise we can take one of the numbers present in said set depending on the parity of All that remains is to find how much of what type to eat from each dish Having obtained the answer in the previous paragraph the final balance we can reconstruct how much fish and how much meat the taster has to eat to achieve it The expected amount of fish to be eaten can be found as Note that the taster must eat of fish from the th dish since if meat then at least of fish is guaranteed to be eaten Let s break down into the sum of how much total fish will have to be eaten anyway and the remaining value Let s go through all the dishes and collect the first summand as just the sum of over all and the second summand with greedy algorithm each time giving the taster as much fish beyond what he must eat anyway until the sum of such additions reaches And knowing for each dish how much fish will be eaten from it the amount of meat eaten can be calculated by subtracting the fish eaten from 
623,Consider the following process You have a binary string a string where each character is either or of length and an integer You build a new binary string consisting of characters The th character of is chosen as follows if the character exists and is equal to then is formally if and then if the character exists and is equal to then is formally if and then if both of the aforementioned conditions are false then is You are given the integer and the resulting string Reconstruct the original string ,Note that means either or whereas means both and We can greedily solve this by starting out our string with all 1 s then marking and as 0 whenever we are forced to because Then we can simply check whether all of the conditions are valid to confirm Code 90915688 ,The answer is when in string there is a character that is not in string Otherwise let s precalculate the following array minimum index from to such that if there is no such index then Now we can solve this problem by simple greed Presume that now and last taken symbol in is Then there are two options if then if then and is equal to initially 
624,You are given an integer sequence Find the number of pairs of indices such that the value of median of is exactly the given number The median of a sequence is the value of an element which is in the middle of the sequence after sorting it in non decreasing order If the length of the sequence is even the left of two middle elements is used For example if then its median is since after sorting the sequence it will look like and the left of two middle elements is equal to The median of equals since after sorting the value will be in the middle of the sequence Write a program to find the number of pairs of indices such that the value of median of is exactly the given number ,Let s define a function greaterCount number of subarrays with median greater or equal than In this case the answer on the problem is greaterCount greaterCount The subarray has median greater or equal than if and only if where is the number equal or greater than elements and is the number of less than elements In other words instead of processing you can use the sequence containing or and An element if An element if Now the median of is greater or equal than if and only if Let s iterate over from left to right Maintain the current partial sum Additionally in the array let s maintain the number of partial sum for each its value It means that before increase of you should do So if is the index of the right endpoint of a subarray i e then number of suitable indices is number of such that In other words find sum of all where it is exactly number of indices with partial sum less than Each time partial sum changes on or So the value sum of all where is easy to recalculate on each change If you decrease just subtract the value If you increase before increasing just add Since indices in can be from to you can use 0 based indices using an array In this case initialize as but not as it makes to be non negative on each step This solution works in ,Let us add to the sum of the elements of the array and try to find a suitable permutation To do this greedily add elements until their sum is less than And at the end we will check that the sum has matched Also check that the maximal element from and that the total elements in 
625,You are given an array such that Let be the sum of all elements of the array Let s call an array of integers if for each from to for every pair of adjacent integers from the array either divides or divides or both Your task is to find any beautiful array It can be shown that at least one beautiful array always exists ,It is enough to consider two possible arrays and It is not difficult to notice that in these arrays the condition is met that among two neighboring elements one divides the other It remains to show that at least one of these two arrays satisfies the condition Let s consider the sum of elements at odd positions and the sum of elements at even positions Since at least one of the values of and does not exceed because otherwise their sum will be strictly greater than Without losing generality assume that Note that for the second variant of the array the condition holds so ,Firstly if n is not divisible by 4 then the answer is because the parities of halves won t match Otherwise the answer is always Let s construct it as follows firstly let s create the array 2 4 6 dots n 1 3 5 dots n 1 This array is almost good except one thing the sum in the right half is exactly frac n 2 less than the sum in the left half So we can fix it easily just add frac n 2 to the last element 
626,Monocarp plays a computer game yet again This game has a unique trading mechanics To trade with a character Monocarp has to choose one of the items he possesses and trade it for some item the other character possesses Each item has an integer price If Monocarp s chosen item has price then he can trade it for any item with price not greater than Monocarp initially has items the price of the th item he has is The character Monocarp is trading with has items the price of the th item they have is Monocarp can trade with this character as many times as he wants possibly even zero times each time exchanging one of his items with one of the other character s items according to the aforementioned constraints Note that if Monocarp gets some item during an exchange he can trade it for another item since now the item belongs to him and vice versa if Monocarp trades one of his items for another item he can get his item back by trading something for it You have to answer queries Each query consists of one integer which is the value of and asks you to calculate the maximum possible total cost of items Monocarp can have after some sequence of trades assuming that he can trade an item of cost for an item of cost not greater than during each trade Note that the queries are independent the trades do not actually occur Monocarp only wants to calculate the maximum total cost he can get ,Suppose we have fixed the value of so we can trade an item with price for an item with price if We can see that it s never optimal to trade an item with higher price for an item with lower price and we could just simulate the trading process as follows try to find an item owned by Polycarp and a more expensive item owned by the other character which can be traded repeat until we cannot find any suitable pair Unfortunately it is too slow Instead let s try to analyze for a given value of how to verify that an item of price can be traded for an item of price maybe not right away but with intermediate trades You can build a graph of vertices representing items where two vertices representing items with prices and are connected by an edge if and only if Then the edges of the graph represent possible trades and the paths in the graph represent sequences of trades So one item can be traded for another item possibly with intermediate trades if the vertices representing the items belong to the same component For a fixed value of we can build this graph find all of its components calculate the number of Monocarp s items in each component and add this number of most expensive vertices from the component to the answer There are two problems though The first one is that the graph may have up to edges But if we sort all items according to their prices we are only interested in edges between vertices which represent adjacent items in sorted order so the size of the graph is decreased to Another problem is that there are multiple queries for different values of To handle it we can sort the values of in ascending order and go in sorted order while maintaining the graph for the current value of A data structure like DSU or a method like small to large merging can be helpful to update the components as they merge The last trick to quickly recalculate the number of items Monocarp has in a component and the sum of most expensive several items you can build two prefix sum arrays one over the array storing the costs of the items and another one over the array which stores values or depending on who owns the respective item the items should still be considered in sorted order Since each component is a segment of costs of items prefix sums allow us to calculate the required values in By the way knowing that each component is a segment we can get rid of the graph and the structure that stores it altogether and just maintain a set of segments of items representing the components ,First of all let s find out how to calculate This can be done greedily let s iterate from the higher denominations to the lower ones the number of banknotes of th type is equal to the value of here changes to reflect that we have already taken some banknotes that is we subtract from each time which is the same as taking modulo We can see that after we process the th type of banknotes the condition holds which means that the number of banknotes of th type does not exceed except in the case of Now we can find the minimum number such that Let be the number of banknotes that still remains to take initially equal to because we want to be at least Let s iterate from the lower denominations to the highest ones the number of banknotes of th type we take should be equal to the minimum of how many we need to take and how many we are allowed to take so as not to break the minimality of the function 
627,Berland Music is a music streaming service built specifically to support Berland local artist Its developers are currently working on a song recommendation module So imagine Monocarp got recommended songs numbered from to The th song had its predicted rating equal to where and every integer from to appears exactly once In other words is a permutation After listening to each of them Monocarp pressed either a like or a dislike button Let his vote sequence be represented with a string such that means that he disliked the th song and means that he liked it Now the service has to re evaluate the song ratings in such a way that the new ratings still form a permutation each integer from to appears exactly once every song that Monocarp liked should have a greater rating than every song that Monocarp disliked formally for all such that and should hold Among all valid permutations find the one that has the smallest value of where is an absolute value of Print the permutation If there are multiple answers you can print any of them ,Since we know that every disliked song should have lower rating than every liked song we actually know which new ratings should belong to disliked songs and which should belong to the liked ones The disliked songs take ratings from to the number of zeros in The liked songs take ratings from the number of zeros in plus to Thus we have two independent tasks to solve Let the disliked songs have ratings Their new ratings should be We can show that if we sort the array then will be the lowest possible The general way to prove it is to show that if the order has any inversions we can always fix the leftmost of them swap two adjacent values and the cost doesn t increase So the solution can be to sort triples and restore from the order of in these Overall complexity per testcase ,At first it s optimal to take candidates with maximal levels for a fixed subject At second if we fix number of participants in each subject for some delegation then it s always optimal to choose all subjects with positive sum of levels It leads us to a following solution Let s divide all candidates by it s and sort each group in non increasing order In result we can just iterate over all prefix sums for each group and update global answer of current length with current sum if it has a positive value 
628,Vlad went into his appartment house entrance now he is on the th floor He was going to call the elevator to go up to his apartment There are only two elevators in his house Vlad knows for sure that the first elevator is currently on the floor it is currently motionless the second elevator is located on floor and goes to floor Please note if then the elevator is already leaving the floor and Vlad does not have time to enter it If you call the first elevator it will immediately start to go to the floor If you call the second one then first it will reach the floor and only then it will go to the floor It takes seconds for each elevator to move from floor to floor Vlad wants to call an elevator that will come to him faster Help him choose such an elevator ,You had to to calculate the time that each elevator would need and compare them Let the time required by the first elevator be and the time required by the second one be Then the answer is if if and if ,In this problem you should simply do what was written in the problem statement There are no tricks 
629,Merge sort is a well known sorting algorithm The main function that sorts the elements of array with indices from can be implemented as follows If the segment is already sorted in non descending order that is for any such that then end the function call Let Call Call Merge segments and making the segment sorted in non descending order The merge algorithm doesn t call any other functions The array in this problem is indexed so to sort the whole array you need to call The number of calls of function is very important so Ivan has decided to calculate it while sorting the array For example if then there will be call of which will check that the array is sorted and then end If then the number of calls is first of all you call which then sets and calls and which do not perform any recursive calls because segments and are sorted Ivan has implemented the program that counts the number of calls but now he needs to test it To do this he needs to find an array such that is a permutation of size that is the number of elements in is and every integer number from can be found in this array and the number of calls when sorting the array is exactly Help Ivan to find an array he wants ,First of all if is even then there is no solution since the number of calls is always odd one call in the beginning and each call makes either or recursive calls Then if is odd let s try to start with a sorted permutation and try to unsort it Let s make a function that will do it When we unsort a segment we can either keep it sorted if we already made enough calls or make it non sorted and then call and if we need more calls When we make a segment non sorted it s better to keep its both halves sorted an easy way to handle this is to swap two middle element It s easy to see that the number of calls is equal to the number of calls to sort the resulting permutation so we can use this approach to try getting exactly calls ,We will perform each move in reverse from the final sequence of the cypher move it increases the th digit by After applying the up move on it becomes move denoted by it decreases the th digit by After applying the down move on it becomes Now we just need to implement the two types of moves The time complexity is per test case 
630,For an array let s denote its as the array For example the array has non empty subarrays You are given two integers and Construct an array consisting of integers such that all elements of are from to has exactly subarrays with positive sums the rest subarrays of have negative sums ,There are many ways to solve this problem I will describe the following recursive solution if let s compose an array where every segment ending with the th element is positive and every other segment is negative This array can be where is the th element of the array note that when doesn t belong to the array so it consists of only negative numbers but if solve the same problem with and recursively get an array of length with positive subarrays and append to it to make all segments ending with the last element positive ,Let s maintain all elements of the array b in a set that allows multiple copies of equal elements for C Then let s iterate from left to right over the array a and try to minimize the current element in array c This order will minimize the resulting array by lexicographical comparing definition So for the i th element a i let s find the minimum element greater than or equal to n a i in the set because n a i will give us remainder 0 n a i 1 will give us remainder 1 and so on If there is no greater or equal element in the set then let s take the minimum element of the set and take it as a pair for a i otherwise let s take this greater or equal element and remove it from the set Time complexity O n log n 
631,Suppose you are given two strings and You can apply the following operation any number of times choose any substring of or and sort the characters in it in non descending order Let the minimum number of operations you have to apply in order to make them equal or if it is impossible to make and equal using these operations For example in one operation we can sort the whole first string in one operation we can sort the substring of the second string starting from the nd character and ending with the th character You are given strings having equal length Calculate ,Disclaimer the model solution is very complicated compared to most participants solutions Feel free to discuss your approaches in the comments First of all it s easy to determine when two strings cannot be made equal using these operations it s when their multisets of characters differ So we divide the strings into different equivalence classes and for any pair of strings from different classes the answer is For any pair of strings from the same class the answer is either or since operations are always enough to make the strings from the same equivalence class equal we just sort both of them Okay now for each class we have to calculate the number of pairs of strings with the distance equal to Okay suppose you have two strings and and you want to make them equal using one operation Suppose that lexicographically Since applying an operation can t result in getting a lexicographically larger string we should apply the operation on the string not Suppose we choose a substring of the string and sort it All characters to the left of position and to the right of position are untouched and all characters in are ordered in non descending order so in order to transform into we should choose a subsegment such that all characters outside this segment are the same in both strings and the substring of is sorted So the best way to choose a subsegment is to compute the longest common prefix of and the longest common suffix of and and try sorting everything in the middle in This gives us a solution in for a pair of strings we can check that one of them can be transformed into the other in To do so we need to build some data structure allowing to query longest common prefixes suffixes in a trie with LCA or precalculating LCP and building a sparse table of them can do the trick furthermore we want to be able to check if some subsegment of some string is sorted in but precalculating them is quite easy So we have a solution that works if the strings are long in the model solution this approach is used on classes having not more than strings The second approach can be used on classes having many strings If the number of strings is big it means that they are short so we can do the following thing for each string iterate on the subsegment we will sort and check if the resulting string exists The model solution uses some very complicated data structures to implement this but I believe that it s quite easy to get this approach working using string hashes The only dangerous thing in the second solution you have to consider is that choosing different substrings to sort may result in getting the same resulting string One good way to deal with this is to ignore some substrings if sorting them doesn t change the leftmost or the rightmost character in the substring for example if we sort the substring in the string the character in the beginning of this substring is unchanged so we can get the same result by sorting So we consider sorting the substring only if it changes both the first and the last characters of the substring Okay so we have two approaches one works well with a small number of long strings and the other works well with a big number of short strings We can choose which of them to run depending on the size of the equivalence class we are considering and this idea gives us a working solution ,If the length of the given string is odd then the answer is since adding two strings cannot do that Otherwise let be the length of the string Let s go through the first half of the string comparing whether its first and characters are equal its second and characters are equal and so on If the characters in any pair are not equal the answer is otherwise 
632,You are given a ternary string it is a string which consists only of characters and You can swap any two adjacent consecutive characters and i e replace with or vice versa or any two adjacent consecutive characters and i e replace with or vice versa For example for string we can perform the following moves Note than you cannot swap and vice versa You cannot perform any other operations with the given string excluding described above You task is to obtain the minimum possible lexicographically string by using these swaps arbitrary number of times String is lexicographically less than string if strings and have the same length if there exists some position where is the length of the string such that for every holds and ,Let s notice that described swaps allows us to place any character to any position of the string relative order of and obviously cannot be changed Let s remove all characters from the string and keep their count in some variable Now more profitable move is to place all the 1 characters right before the first character of and if there is no character in then place they after the end of the string ,Firstly notice that the length of the answer cannot exceed copies of Now we can do some kind of simple dynamic programming Let be the minimum possible length of the prefix of the regular bracket sequence if we are processed first characters of the first sequence first characters of the second sequence and the current balance is Each dimension of this dp should have a size nearby The base of this dp is all other values Transitions are very easy if we want to place the opening bracket then we increase if the th character of exists and equals the same with the second sequence and the balance increases by one and the length of the answer increases by one If we want to place the closing bracket then we increase if the th character of exists and equals the same with the second sequence and the balance decreases by one and the length of the answer increases by one Don t forget to maintain parents in this dp to restore the actual answer The last problem that can be unresolved is how to write this dp The easiest way is bfs because every single transition increases our answer by one Then we can restore answer from the state You can write it recursively but I don t sure this will look good And you also can write it just with nested loops if you are careful enough Time complexity If you know the faster solution please share it 
633,You are given of integers Process queries of two types query of the form add the value to all even elements of the array query of the form add the value to all odd elements of the array Note that when processing the query we look specifically at the odd even value of not its index After processing each query print the sum of the elements of the array Please note that the answer for some test cases won t fit into 32 bit integer type so you should use at least 64 bit integer type in your programming language like for C ,Let the initial sum in the array the number of even numbers the number of odd numbers Let s see how these values change with each action In fact we can consider four main options Add an even number to all even numbers Then will increase by and the number of even and odd numbers will remain the same Add an odd number to all even numbers Then will increase by the number of even numbers will become all numbers will become odd so Add an even number to all odd numbers Then will increase by and the number of even and odd numbers will remain the same Add an odd number to all odd numbers Then will increase by the number of odd numbers will become all numbers will become even so ,This problem has several general cases x is even and a b then the answer is repeated frac x 2 times then b frac x 2 ones and a frac x 2 zeroes x is even and a le b then the answer is repeated frac x 2 times then a frac x 2 zeroes and b frac x 2 ones x is odd and a b then the answer is repeated lfloor frac x 2 rfloor times then a lfloor frac x 2 rfloor zeroes and b lfloor frac x 2 rfloor ones x is odd and a le b then the answer is repeated lfloor frac x 2 rfloor times then b lfloor frac x 2 rfloor ones and a lfloor frac x 2 rfloor zeroes I am sure that there are other more beautiful solution but for me the easiest way to solve this problem is to extract general cases and handle it Overall complexity is O a b 
634,Vasya has an array You don t know this array but he told you facts about this array The th fact is a triple of numbers and and it means if then subbarray is sorted in non decreasing order if then subbarray is not sorted in non decreasing order A subarray is not sorted if there is at least one pair of consecutive elements in this subarray such that the former is greater than the latter For example if then he could give you three facts the subarray is sorted the subarray is not sorted and the subarray is not sorted You don t know the array Find array which satisfies all the given facts ,Let s consider array such that Then subarray is sorted in non decreasing order if and only if all elements are greater or equal to zero So if we have fact then all elements must be greater or equal to zero Let s create the following array if there is such a fact that and otherwise After that we create the following array and for all other indexes This array satisfies all facts such that So all we have to do is check that all remaining facts are satisfied ,Let s denote as just a suffix sum And let be the position where starts the th subarray obviously and Then we can make an interesting transformation So our task is equivalent to choosing sum of all array and different suffix sums And we want to maximize their total sum That s why we can just greedily take maximum suffix sums along with sum of all array 
635,You are given an integer Check if has an divisor greater than one does there exist such a number that is divisible by and is odd For example if then there is If then such a number does not exist ,If the number has an odd divisor then it has an odd prime divisor To understand this fact we can consider what happens when multiplying even and odd numbers even even even even odd even odd even even odd odd There is only one even prime number So if a number has no odd divisors then it must be a power of two To check this fact for example you can divide by as long as it is divisible If at the end we got then the power of two You can also use the following condition to check If the number is a power of two then it contains only one unit in the binary notation Then contains units in all positions except the one in which the unit in is located So their bitwise AND does not contain units ,If the number consists of other primes than and then the answer is Otherwise let be the number of twos in the factorization of and be the number of threes in the factorization of If then the answer is because we can t get rid of all twos Otherwise the answer is Time complexity 
636,You are given a rooted tree with root in vertex Each vertex is coloured in some colour Let s call colour dominating in the subtree of vertex if there are no other colours that appear in the subtree of vertex more times than colour So it s possible that two or more colours will be dominating in the subtree of some vertex The subtree of vertex is the vertex and all other vertices that contains vertex in each path to the root For each vertex find the sum of all dominating colours in the subtree of vertex ,The name of this problem is anagram for Small to large There is a reason for that The author solution for this problem uses the classic technique for computing sets in tree The simple solution is the following let s find for each vertex v the map int int the number of occurences for each colour set pair int int pairs the number of occurences and the colour and the number sum the sum of most frequent colours in subtree of v To find that firstly we should find the same thing for all childs of v and then merge them to one These solution is correct but too slow it works in O n2logn time Let s improve that solution every time when we want to merge two map s a and b let s merge the smaller one to larger simply by iterating over all elements of the smaller one this is the Small to large Let s consider some vertex v every time when vertex v will be moved from one map to another the size of the new map will be at least two times larger So each vertex can be moved not over than logn times Each moving can be done in O logn time If we accumulate that values by all vertices then we get the complexity O nlog2n I saw the solutions that differs from author s but this technique can be used in a lot of other problems ,The necessary and sufficient condition is the following for each color the key should appear before the door Necessary is easy to show if there is a key after a door this door can t be opened Sufficient can be shown the following way If there are no closed doors left the knight has reached the princess Otherwise consider the first door the knight encounters He has a key for this door so he opens it We remove both the key and the door from the string and proceed to the case with one less door Overall complexity 
637,Polygon is not only the best platform for developing problems but also a square matrix with side initially filled with the character On the polygon military training was held The soldiers placed a cannon above each cell in the first row and a cannon to the left of each cell in the first column Thus exactly cannons were placed Cannons shoot character At any moment of time no more than one cannon is shooting When a flies out of a cannon it flies forward in the direction of the shot until it collides with a polygon border or another After that it takes the cell in which it was before the collision and remains there Take a look at the examples for better understanding More formally if a cannon stands in the row to the left of the first column and shoots with a then the starts its flight from the cell and ends in some cell if a cannon stands in the column above the first row and shoots with a then the starts its flight from the cell and ends in some cell For example consider the following sequence of shots You have a report from the military training on your desk This report is a square matrix with side length consisting of and You wonder if the training actually happened In other words is there a sequence of shots such that after the training you get the given matrix Each cannon can make an arbitrary number of shots Before the training each cell of the polygon contains ,Let s see how the matrix looks like after some sequence of shoots The matrix consists of or There is at least one at position or and any not at position or must have below or right If the second condition is violated then the in the corresponding cell would continue its flight Thus it is necessary and sufficient to verify that the matrix satisfies the condition above ,This one is a pure implementation task Just check every possible line of length If the current one contains crosses and empty cell then the answer is 
638,Vova again tries to play some computer card game The rules of deck creation in this game are simple Vova is given an existing deck of cards and a magic number The order of the cards in the deck is fixed Each card has a number written on it number is written on the th card in the deck After receiving the deck and the magic number Vova removes possibly cards from the top of the deck possibly cards from the bottom of the deck and the rest of the deck is his new deck Vova has to leave at least one card in the deck after removing cards So Vova s new deck actually contains cards from the original deck Vova s new deck is considered iff the product of all numbers written on the cards in his new deck is divisible by So Vova received a deck possibly not a one and a number and now he wonders how many ways are there to choose and so the deck he will get after removing cards from the top and cards from the bottom is ,Let s use two pointers Firstly you need to learn to factorize any number in no more than We don t actually need any of their prime divisors except for those that are presented in So let s factorize in After that check for the maximum power of each useful prime will work in for each number Now notice that if some segment has its product divisible by then all segments for will also have products divisible by Now we have to find the smallest for each out there That s where two pointers kick in Let s maintain the current product of the segment in factorized form only useful primes as in normal form its enormous The power of some prime in this form is the sum of powers of this prime in all the numbers in the segment We firstly move the left border of the segment one step to the right and then keep moving the right border to the right until power of at least one prime number in the product is smaller than in It means that it is not divisible by Moving the left border means subtracting all the powers of useful primes of number from the product and moving the right border is adding all the powers of useful primes of The first time we reach such a segment we add to answer consider indexed Overall complexity where is up to ,Let s define the semantics of moving along the graph On each step the current number is either multiplied by some prime or divided by it I claim that the all shortest paths from to always go through Moreover the vertex numbers on the path first only decrease until and only increase after it Let s watch what happens to the divisors list on these paths At first all the divisors of that are not divisors of are removed from the list Now we reach gcd and we start adding the divisors of that are missing from the list The length of the path is this total number of changes to the list That shows us that these paths are the shortest by definition If we ever take a turn off that path we either will add some divisor that we will need to remove later or remove some divisor that we will need to add later That makes the length of the path not optimal Now let s learn to calculate the number of paths The parts before gcd and after it will be calculated separately the answer is the product of answers for both parts How many paths are there to gcd Well let s divide by that will give us the primes that should be removed from You can remove them in any order because the length of the path is always the same That is just the number of their permutations with repetitions you might also know that formula as multinomial coefficient The number of paths from to is calculated the same way To find the primes in you can factorize beforehand and only iterate over the primes of Overall complexity 
639,Little Joty has got a task to do She has a line of tiles indexed from to She has to paint them in a strange pattern An unpainted tile should be painted Red if it s index is divisible by and an unpainted tile should be painted Blue if it s index is divisible by So the tile with the number divisible by and can be either painted Red or Blue After her painting is done she will get chocolates for each tile that is painted Red and chocolates for each tile that is painted Blue Note that she can paint tiles in any order she wants Given the required information find the maximum number of chocolates Joty can get ,Easy to see that we can paint with both colours only tiles with the numbers multiple of Obviously that tiles should be painted with more expensive colour So the answer equals to ,There are lots of ways to check correctness For example you can keep boolean array with already used colors check stripes naively and mark the color used if the stripe has single color If all the colors are used in the end then the answer is Overall complexity 
640,There are gift boxes in a row numbered from to from left to right It s known that exactly of them contain valuable gifts other boxes contain just lucky stones All boxes look the same and differ only in weight All than boxes with valuable items But valuable gifts may be different so the boxes with valuable items may have different weights You can ask no more than queries printing an answer doesn t count By each query you can compare total weights of two non intersecting subsets of boxes and In return you ll get one of four results if subset is strictly if subset is strictly if subsets have equal total weights if the query is incorrect or the limit of queries is exceeded Using such queries or maybe intuition find the box with a valuable gift with ,The solution consists of several steps Let s find out does the first box contain stone or valuable gift using random Let s make queries to compare the weight of the first box with the weight of another random box If the first box is lighter than we found an answer otherwise the probability of the first box having stones is at least Let s compare the weights of the first box and the second one If they are equal then let s compare the weights of boxes and If they are equal then let s compare the boxes and and so on In other words let s find the minimum such that contains only boxes with stones but contain at least one box with a valuable gift It s easy to see that we d spend no more than queries We have segment with only stones and with at least one gift Let s just binary search the leftmost gift in the segment using boxes from as reference if we need to know does segment of boxes have at least one gift let s just compare it with segment which have only stones if is lighter then it has otherwise doesn t have This part also requires no more than queries ,Let s divide all books into four groups both Alice and Bob doesn t like these books only Alice likes these books only Bob likes these books both ALice and Bob like these books Obviously group is useless now So how to solve the problem Let s iterate over the number of books we take from group Let it be Then we obviously need to take exactly books from groups and Among all books in these three groups we have to choose the cheapest ones To calculate sum of times in each group fast enought we can sort each group independently and implement prefix sums on these arrays If is less than zero or greater than the size of or group for each possible then the answer is And don t forget that the answer can be up to Time complexity 
641,You are given three integers and conditions Calculate the number of distinct arrays consisting of integers such that for each bitwise AND of numbers for each Two arrays and are considered different if there exists such a position that The number can be pretty large so print it modulo ,We will solve the problem for each bit separately and then multiply the results Obviously if the position is covered by a segment with the value then we have no choice and we must put there For segments with the value there must be at least one position that they cover and its value is So we can write the following dynamic programming the number of arrays such that the last was exactly at the position and all segments to the left of it contain at least one zero It remains to determine which states we can update from The only restriction we have is that there should not be any segment with the value such that and Since in this case this segment will not contain any zero values For each position we may precalculate the rightmost position where some segment ending before begins and while calculating we should sum up only the values starting from position This can be done with prefix sums ,We will use the Contribution to the Sum technique to solve this problem for every integer from to let s calculate the number of ways to choose the operators so it belongs to the result and add all of the results For a fixed integer the number of ways to choose the operators so that belongs to the result can be done as follows let be the number of ways to choose the first operators so that after applying them the resulting set contains if and does not contain if The transitions from to depend on whether the number belongs to the segment Obviously this is too slow if we compute the dynamic programming from scratch for every integer Instead we can notice that the transitions from to are linear combinations both and are linear combinations of and with coefficients depending on whether the element belongs to the set or not So transitioning from to can be written in terms of multiplying by a matrix Let s build a segment tree where each vertex stores a transition matrix and operations are calculate the product of matrices on a segment and replace a matrix at some index We can build a sequence of these transition matrices for and store them in the segment tree for this sequence of transition matrices will change only in positions such that either belongs to and does not belong to it or vice versa So we can go from to by replacing these transition matrices in the segment tree For the only changes from are in positions such that either belongs to and does not belong to it or vice versa and we can replace the matrices in these positions as well In total there will be only such replacements so we solve the problem in where is the constraint on the numbers belonging to the sets 
642,You are given two integers and You need to construct a rooted binary tree consisting of vertices with a root at the vertex and the sum of depths of all vertices equals to A tree is a connected graph without cycles A rooted tree has a special vertex called the root A parent of a vertex is the last different from vertex on the path from the root to the vertex The depth of the vertex is the length of the path from the root to the vertex Children of vertex are all vertices for which is the parent The binary tree is such a tree that no vertex has more than children You have to answer independent test cases ,This problem has an easy constructive solution We can find lower and upper bounds on the value of for the given If the given does not belong to this segment then the answer is Otherwise the answer is for any in this segment How to construct it Let s start from the chain The answer for the chain is the upper bound of and it is Then let s try to decrease the answer by in one move Let s take some leaf the vertex without children with the smallest depth that is not and try to move it up The definition of badness will be below To do this let s find such vertex that its depth is less than the depth of by and it has less than children If we found such vertex then let s make the child of and decrease the answer by one If we didn t find such vertex I claim that the vertex has the minimum possible depth it can have and we should not consider it in the future Let s mark this vertex as and continue our algorithm If at some moment we cannot find any not leaf then the answer is Otherwise the answer is Time complexity ,If you check some games then you will notice that the most optimal strategy for Bob is always like this Climb up for some steps possibly zero Go to the lowest vertex from it Stay in this vertex till the end Thus let s precalc the depth the distance from the root of the lowest vertex of each subtree using dfs distance from Alice s starting node and from Bob s starting node to the vertex again dfs bfs Now iterate over all vertices and check if Bob can reach this vertex earlier than Alice If he can then update the answer with the lowest vertex that can be reached from this one The answer is doubled depth of the obtained lowest reachable vertex That is the time which will take Alice to get there Overall complexity 
643,You are given two arrays an array consisting of zeros and an array consisting of integers You can apply the following operation to the array an arbitrary number of times choose some subsegment of of length and add the arithmetic progression to this subsegment i e add to the first element of the subsegment to the second element and so on The chosen subsegment should be inside the borders of the array i e if the left border of the chosen subsegment is then the condition should be satisfied Note that the progression added is always but not the or anything else i e the leftmost element of the subsegment always increases by the second element always increases by and so on Your task is to find the possible number of operations required to satisfy the condition for each from to Note that the condition should be satisfied for all elements at once ,Let s solve the problem greedily But not from the beginning because if we solve it from the beginning we can t be sure what option is more optimal for the next elements e g for the second element it is not clear if we need to add to it starting our segment from the first position or add to it starting our segment from the second position So let s solve the problem from right to left then anything becomes clearer Actually let s operate with the array and decrease its elements instead of using some other array Let s carry some variables and the array of length along with the answer The variable means the value we need to subtract from the current element from currently existing progressions is the number of currently existing progressions and means the number of progressions that will end at the position i e will not add anything from the position and further to the left When we consider the element firstly let s fix decrease it by Then let s fix decrease it by Then let s decrease by and if it becomes less than or equal to zero just proceed Otherwise the number by which we can decrease the th element with one progression equals to zero indexed Then the number of progressions we need to satisfy this element is Let s add this number to the answer increase by increase by and if then we need to end these progressions somewhere so let s add to Time complexity ,We need to minimize the result of the bitwise operation so for convenience we represent the answer as a mask Firstly let s assume that this mask is composed entirely of ones Let s go from the most significant bit to the least significant one and try to reduce the answer To understand whether it is possible to remove the th bit remove it and check if the graph in which all the weights are submasks of the current answer is connected for this you can use depth first search or a disjoint sets union If the graph is connected then the bit can obviously be thrown out and if not it cannot and must be returned 
644,An L shape is a figure on gridded paper that looks like the first four pictures below An L shape contains exactly three shaded cells denoted by which can be rotated in any way You are given a rectangular grid Determine if it contains L shapes only where L shapes can t touch an edge or corner More formally Each shaded cell in the grid is part of exactly one L shape and no two L shapes are adjacent by edge or corner For example the last two grids in the picture above satisfy the condition because the two L shapes touch by corner and edge respectively ,The problem is mainly a tricky implementation problem Let s denote the of an L shape as the square in the middle the one that is side adjacent to two other squares Every elbow is part of exactly one L shape and every L shape has exactly one elbow Iterate through the grid and count the number of side adjacent neighbors they have If there is a cell with more than 2 or if there is a cell with exactly two neighbors on opposite sides then the answer is Otherwise if there are exactly 2 neighbors this cell is an elbow Mark all three cells of this L shape with a unique number say mark the first one you find with the second with and so on If you ever remark a cell that already has a number then two elbows are adjacent and you can output After all elbows are marked check if all shaded cells have a number If some don t then they are not part of an L shape so you can output Finally we should check that L shapes don t share edge or corner Just check for each number if it is only diagonally adjacent to other numbers equal to it or unshaded cells If it is diagonally adjacent to other unequal numbers then the answer is because two L shapes share an edge or corner then Otherwise the answer is There are many other solutions all of which are various ways to check the conditions The complexity is per testcase ,The problem is about counting the number of some combinatoric objects Thus dynamic programming is always the answer Let be the number of bicolorings of the first columns such that components are already created and can t be modified and the colors of the th column are determined by its first bit is the color of the lower cell and its second bit the color of the upper cell Component can be modified if the cell from the th column belongs to it The initial states are for each and for any other state You should iterate over the possible for the next column and recalculate the number of components You can easily show that the current number of components and the last column is actually enough to get the new number of components In my code I have some function to determine the added number of components while transitioning from to These are just the couple of cases to handle carefully Then all the transitions are However the last column won t contain the answer as it is the number of components will be incorrect Let s add some dummy column equal to for each This will add all the real component to the total number So the answer is the sum of over all Overall complexity where is the number of rows 2 for this problem 
645,Let s denote a function in such a way we add to then while there is at least one trailing zero in the resulting number we remove that zero For example We say that some number is from if we can apply function to some possibly zero times so that we get as a result For example is reachable from because and any number is reachable from itself You are given a number your task is to count how many different numbers are reachable from ,The key fact in this problem is that the answer is not very large in fact it s not greater than 91 Why is it so Every 10 times we apply function f to our current number it gets divided by 10 at least and the number of such divisions is bounded as O log n So we can just do the following store all reachable numbers somewhere and write a loop that adds current number n to reachable numbers and sets n f n we should end this loop when n already belongs to reachable numbers The most convenient way to store reachable numbers is to use any data structure from your favourite programming language that implemenets a set but in fact the constrains were so small that it was possible to store all reachable numbers in an array ,If the number is already even then nothing needs to be done so the answer in this case is Now let s recall the divisibility by a number is divisible by if and only if its last digit is divisible by It follows that if there are no even digits in our number then the answer is Let s take a look at our operation What is going on The first digit always changes with the digit numbered In particular when we reverse the entire number the first digit is swapped with the last Note that no other digit except for the first one at the current moment can t be the last Therefore you can do this if the first digit of a number is divisible by then we reverse the whole number The first digit will become the last and the number will become even Therefore you only need to do one operation Now what if the first digit of a number is odd In this case we can find the first even digit in the number let it be at position and reverse the prefix of length in one operation Now the first digit of our number has become even and we can use the previous case one more operation Thus we will do only operations 
646,You are given an integer from to without leading zeroes In one move you can swap any two adjacent digits in the given number in such a way that the resulting number will not contain leading zeroes In other words the number you have cannot contain any leading zeroes What is the minimum number of moves you have to make to obtain a number that is divisible by Print if it is impossible to obtain a number that is divisible by ,Let s iterate over all pairs of digits in the number Let the first digit in the pair be at position and the second at position Let s place these digits to the last two positions in the number The first greedily goes to the last position and then the second goes to the position next to that Now the number can contain a leading zero Find the leftmost non zero digit and move it to the first position Then if the current number is divisible by try to update the answer with the number of swaps It is easy to show that the number of swaps is minimal in this algorithm The only difference we can introduce is the number of times digit digit and the leftmost non zero digit swap among themselves And that is minimized You can also notice that the order of swaps doesn t matter and you can rearrange them in such a way that no leading zero appears on any step This solution has time complexity You can also solve this problem with complexity because you have to check only four options of the two last digits It is always optimal to choose both rightmost occurrences of the corresponding digits You can show that even if you are required to swap the chosen ones there will be no other pair with smaller total amount of moves ,In the problem you had to find the largest common prefix LCP of the first characters of the number and the string To do this we will go from the beginning and compare the characters until we find a non matching one or until the string ends 
647,Codeforces separates its users into divisions by their rating For Division 1 For Division 2 For Division 3 For Division 4 Given a print in which division the belongs ,For this problem you just need to implement what it asks you To be able to implement it you need to know about the if statement ,Let s found two athletes with numbers and the strength of is not greater than the strength of which have the minimal modulus of the difference of their strength Obviously we cannot get an answer less than this Let s show how to get the partition with exactly this answer Sort all athletes by strength Our two athletes will stand in neighboring positions otherwise we can decrease the answer Let the first team contains all athletes who stand on positions not further than and the second team contains other athletes We got a partition in which the athlete with number has the maximal strength in the first team and the athlete with number has the minimal strength in the second team 
648,You are given a string consisting only of Latin letters a and a string consisting of lowercase Latin letters In one move you can replace any letter a in the string with a string Note that after the replacement string might contain letters other than a You can perform an arbitrary number of moves including zero How many different strings can you obtain Print the number or report that it is infinitely large Two strings are considered different if they have different length or they differ at some index ,Let s consider some cases If there are letters a in string then the moves can be performed endlessly If itself is equal to a then the string won t change so the answer is Otherwise the length of is least so string will be increasing in length after each move and the answer is If there are no letters a in string then the resulting string is only determined by whichever letters a we chose to replace with That s because once we replace a letter a with string we can do nothing with the new letters anymore We can actually imagine that is equal to b and the answer won t change Now it s easy to see that the answer is equal to the number of strings of length consisting only of letters a and b There are two options for each position and there are positions so the answer is Overall complexity per testcase ,We will solve the problem by dynamic programming Let be the answer for substring Then we have two cases The first letter of the substring is deleted separately from the rest then The first letter of the substring is deleted alongside with some other letter both letters must be equal then 
649,Monocarp is playing a video game In the game he controls a spaceship and has to destroy an enemy spaceship Monocarp has two lasers installed on his spaceship Both lasers and have two values the power of the laser the reload time of the laser When a laser is fully charged Monocarp can either shoot it or wait for the other laser to charge and shoot both of them at the same time An enemy spaceship has durability and shield capacity When Monocarp shoots an enemy spaceship it receives damage i e gets subtracted from its durability where is the total power of the lasers that Monocarp shoots i e if he only shoots laser and if he shoots both lasers at the same time An enemy spaceship is considered destroyed when its durability becomes or lower Initially both lasers are zero charged What s the lowest amount of time it can take Monocarp to destroy an enemy spaceship ,At any time we have three possible choices wait and shoot the first laser the second laser and both lasers Sometimes it makes sense to wait to both because you can deal more damage than you would do by shooting both lasers separately The first claim greedy won t work Maybe there is a sufficiently smart greedy we weren t able to come up with it The second claim bruteforce won t work The funny thing is that it actually worked on the constraints up to but again we couldn t code any sufficiently fast one for Thus let s try some dynamic programming Since all the times are huge we d want to avoid having them as the states What is small however is the durability of the enemy ship and the number of shots we have to make to destroy it Ideally we d like to have some the smallest time to deal damage to the enemy ship This way would be the answer Sadly it s not immediately clear how to get rid of reload times completely There might be states with different times until the charge with the same damage dealt and we don t know which of those we want to keep Thus let s make the dp state more complicated Let be the smallest time it takes to deal damage if the last shot was from both lasers at the same time This way we know the reload times of both lasers they are full and as moment has both lasers zero charged as if after a shot What are the transitions Well now we have to shoot each laser multiple times then wait until both are charged and shoot both Both lasers can now be considered independent of each other Let the time between the previous double shot and the next one be some value During this time it never made sense to wait until shooting each laser So we waited shot the first laser waited another shot again until we couldn t shoot anymore since the laser wouldn t recharge in time before the double shot Same for the second laser Notice that if both and then you could just decrease by and shoot each laser the same number of times Thus only that are multiples of either or are optimal Thus we can iterate over all possible waiting times Just iterate over and for all from to Having a fixed calculate the number of shots of each laser calculate the damage go into the corresponding dp state It could also happen that the last shot before destroying the ship wasn t a double one However it still follows the same ideas It means that each laser was shooting non stop until the ship was destroyed Thus the destruction time is still a multiple of either of the reload times Overall complexity ,The first spell looks pretty weak compared to the second spell Feels like you almost always replace one with another Let s show that you can totally avoid casting the spell of the first type twice or more on one monster Let the two first spell casts be and for some monsters and You can replace them by a cast of the second spell on and a cast of the first spell on That would deal even more damage to and the same amount to and The number of casts doesn t change Thus it only makes sense to use the first spell on monsters with health Calculate the number of them kill the full pairs of them with the first spell and use the second spell on the remaining monsters Overall complexity per testcase 
650,You are given an array of integers Count the number of pairs of indices such that and ,Let s rewrite the original equality a bit a j a i j i a j j a i i Let s replace each a i with b i a i i Then the answer is the number of pairs i j such that i j and b i b j To calculate this value you can use or sorting ,If we want to divide all balls from some box into sets with sizes and and there are balls in this box then either or So the solution will be like that Iterate over the possible sizes of sets from to or to some constant in our solution it s and check if we can divide all balls into sets with sizes and Then iterate over the number of sets calculate the sizes of sets if we want to divide the first box exactly into sets and try to divide balls from all other boxes into sets of these sizes If we want to divide balls from the same box into sets then the sizes will be and but if then we also have to check if sizes can be and If we fix sizes and and we want to check whether we can divide a box with balls into sets with these sizes and to get the minimum possible number of such sets then the best option will be to take sets If then such division is possible If not then it s impossible to divide balls into sets of and balls Time complexity of this solution is 
651,Let denote the bitwise AND operation and denote the bitwise OR operation You are given an array of length and a non negative integer You can perform operations on the array of the following type Select an index and replace with where is any integer between and In other words in an operation you can choose an index and set the th bit of to Output the maximum possible value of after performing operations ,The optimal strategy is to greedily take the highest bit we have enough operations to set in every array element To do this we maintain a count for each bit with the number of elements that have it set already The cost to set the th bit will be We go from the highest bit to the lowest If we have enough operations left we set the bit subtract its cost from the operations and move to the next lower bit If we don t have enough operations we move on to the next lower bit and don t modify the operations We stop once we processed bit The time complexity is ,Let s look at our arrays and Note that for any position such that we can always fix it by swapping positions from to In that case contribution from all won t change contribution of pair will decrease and contribution from all won t change again since we swapped all of them It means that we already can use the following algorithm while exists such that just swap all from to This solution works for per test that should be enough But we can optimize our approach by realizing that we can instead of searching each time just go from to and fix pairs one by one if then swap with next if then swap with and so on In such way solution works in 
652,Monocarp is the coach of the Berland State University programming teams He decided to compose a problemset for a training session for his teams Monocarp has problems that none of his students have seen yet The th problem has a topic an integer from to and a difficulty an integer from to All problems are different that is there are no two tasks that have the same topic and difficulty at the same time Monocarp decided to select exactly problems from problems for the problemset The problems should satisfy of two conditions possibly both the topics of all three selected problems are different the difficulties of all three selected problems are different Your task is to determine the number of ways to select three problems for the problemset ,There are many different ways to solve this problem but in my opinion the easiest one is to count all possible triples and subtract the number of bad triples The first part is easy the number of ways to choose elements out of is just The second part is a bit tricky What does it mean that the conditions in the statements are not fulfilled There is a pair of problems with equal difficulty and there is a pair of problems with the same topic Since all problems in the input are different it means that every bad triple has the following form i e there exists a problem such that it shares the difficulty with one of the other two problems and the topic with the remaining problem of the triple This observation allows us to calculate the number of bad triples as follows we will iterate on the central problem the one that shares the topic with the second problem and the difficulty with the third problem If we pick as the central problem we need to choose the other two Counting ways to choose the other problems is easy if we precalculate the number of problems for each topic difficulty let be the number of problems with topic and be the number of problems with difficulty then if we pick the problem as the central one there are ways to choose a problem that shares the topic with it and ways to choose a problem that has the same difficulty so we have to subtract from the answer for every problem ,Accordingly as it was said in the task we put all tasks into the queue in the order of their arrival then we fix the time at the beginning as So while there is a task in the queue we proceed as follows Take the task from the queue Take as time the maximum from the current and from the arrival time of the task We subtract the current time from the time when the task was done Replace the current time with the time the task was done If there is a task in the queue go to item 
653,You talked to Polycarp and asked him a question You know that when he wants to answer yes he repeats many times in a row Because of the noise you only heard part of the answer some substring of it That is if he answered then you could hear but you couldn t or Determine if it is true that the given string is a substring of repeated many times in a row ,Note that it is enough to consider the string where is written times since and our substring has size Then we just use the built in function to find out if our string is a substring of the string ,We need to make our string alternating i e When we reverse substring we change no more than two pairs and Moreover one pair should be a consecutive pair and other So we can find lower bound to our answer as maximum between number of pairs of and number of pairs of And we can always reach this lower bound by pairing with or with left right border of Another way to count the answer is next suppose we want to make string then let s transform to For example if we will get We claim that after this transformation we will have equal number of and so the answer is the number of consecutive pairs of the same character divided by two The answer is the minimum between answers for and 
654,One day people is an even number met on a plaza and made two round dances each round dance consists of exactly people Your task is to find the number of ways people can make two round dances if each round dance consists of exactly people Each person should belong to exactly one of these two round dances Round dance is a dance circle consisting of or more people Two round dances are indistinguishable equal if one can be transformed to another by choosing the first participant For example round dances and are indistinguishable For example if then the number of ways is one round dance consists of the first person and the second one of the second person For example if then the number of ways is Possible options one round dance another one round dance another one round dance another Your task is to find the number of ways people can make two round dances if each round dance consists of exactly people ,Firstly we need to choose the set of people to be in the first round dance the other half is going to the second one The number of ways to do that is Then we need to set some order of people in both round dances but we don t want to forget about rotation because rotation can lead us to counting the same ways several times So the number of ways to arrange people inside one round dance is This is true because we just fixed who will be the first in the round dance and place others in every possible order So we need to multiply our initial answer by this value twice because we have two round dances And finally we have to divide our answer by because we counted ordered pairs i e we distinguish pairs of kind and but we don t have to do that So the final answer is divided by This formula can be reduced to You could also find the sequence of answers in OEIS and this can be really useful skill sometimes ,The idea of this solution is the same as in the easy version but now we need to do the same sequence of moves faster We can notice that the smartphone screen works as a queue so let store it as a queue When the new message appears we have to check if the friend with this ID is in the queue already but we need to check it somehow fast Let s use some logarithmic structure that stores the same information as the queue but in other order to find add and remove elements fast In C this structure is So let s check if the current friend is in the queue and if no let s check if the size of the queue is If it is so then let s remove the first element of the queue from it and the same element from the set also Then add the current friend to the queue and to the set After processing all messages the reversed queue the queue from tail to head is the answer to the problem Time complexity And don t forget that and other standard hashmaps can work in linear time in the worst case so you need to redefine the hash function to use them You can read more about this issue here https codeforces com blog entry 62393 
655, You are given a string consisting of lowercase Latin letters You have to color its characters each character to exactly one color the same letters can be colored the same or different colors i e you can choose exactly one color for each index in After coloring you can swap two neighboring characters of the string that are colored colors You can perform such an operation arbitrary possibly zero number of times The goal is to make the string sorted i e all characters should be in alphabetical order Your task is to say if it is possible to color the given string so that after coloring it can become sorted by sequence of swaps Note that you have to restore only coloring not the sequence of swaps ,Note that the actual problem is to divide the string into two subsequences that both of them are non decreasing You can note that this is true because you cannot the relative order of the elements colored in the same color but you can write down subsequences of different colors in any order you want In this problem you can write the following dynamic programming is if you can split the prefix of the string into two non decreasing sequences such that the first one ends with the character and the second one with characters are numbered from to otherwise is zero Initially only other values are zeros Transitions are very easy if the current value of dp is then we can make a transition to if and to if Then you can restore the answer by carrying parent values But there is another very interesting solution Let s go from left to right and carry two sequences and If the current character is not less than the last character of then let s append it to otherwise if this character is not less than the last character of then append it to otherwise the answer is If the answer isn t then and are required sequences The proof and other stuff will be in the editorial of the hard version Time complexity or or ,Let s solve the problem using binary search by the answer It is easy to see that if we can construct the answer for some number of copies then we also can do it for The only thing we need is to write the function which will say can we cut off copies of some array from or not Let s imagine copies of string as a matrix of size Obviously each row of this matrix should be equal to each other row Let s fill not rows but columns of this matrix For some element of we can easy notice that we can take exactly columns containing this element where is the number of such elements in So overall number of columns we can fill in this matrix will be If this value is greater than or equal to then is true otherwise it is false It is easy to construct the answer using all things we described above Overall complexity is where is the size of the alphabet 
656,Berland year consists of months with days each Months are numbered from to Berland week consists of days The first day of the year is also the first day of the week Note that the last week of the year might be shorter than days A pair such that is ambiguous if day of month is the same day of the week as day of month Count the number of ambiguous pairs ,Let the month the days in them and the days of the week be numbered based Translate the th day of the th month to the index of that day in a year that would be Thus the corresponding day of the week is So we can rewrite the condition for a pair as That s also Continue with So should be divisible by is fixed and some prime divisors of might have appeared in it already If we remove them from then should just be divisible by the resulting number So we can divide by and obtain that Now we should just count the number of pairs such that is divisible by We know that the difference should be from to So we can fix the difference and add the number of pairs for that difference That would be for a difference Finally the answer is Use the formula for the sum of arithmetic progression to solve that in Overall complexity per testcase ,Let be the number of elements of with the remainder modulo Then the initial answer can be represented as and we have to compose numbers with remainders and somehow optimally It can be shown that the best way to do it is the following firstly while there is at least one remainder and at least one remainder let s compose them into one After this at least one of the numbers will be zero then we have to compose remaining numbers into numbers divisible by If then the maximum remaining number of elements we can obtain is because and in the other case the maximum number of elements is because 
657, teams participate in a playoff tournament The tournament consists of games They are held as follows first of all the teams are split into pairs team plays against team team plays against team exactly in this order and so on so games are played in that phase When a team loses a game it is eliminated and each game results in elimination of one team there are no ties After that only teams remain If only one team remains it is declared the champion otherwise games are played in the first one of them the winner of the game vs plays against the winner of the game vs then the winner of the game vs plays against the winner of the game vs and so on This process repeats until only one team remains For example this picture describes the chronological order of games with Let the string consisting of characters describe the results of the games in chronological order as follows if is then the team with lower index wins the th game if is then the team with greater index wins the th game if is then the result of the th game is unknown any team could win this game Let be the number of of the tournament described by the string A team is a of the tournament if it is possible to replace every with either or in such a way that team is the champion You are given the initial state of the string You have to process queries of the following form replace with character and print as the result of the query ,Denote as the number of teams that can be winners in the th game The answer to the problem is If the th game is played between the winners of games and then if if if So we can calculate all values of for the initial string Note that the result of no more than other games depends on the result of any game So if we change it will change no more than values of and we can recalculate all of them For convenience you can renumerate the games so that the playoff looks like a segment tree i e the final has the number the semifinals have numbers and etc ,The maximum number of rounds Alice can win is pretty easy to calculate greedily What about the minimum number of rounds It can be shown that if we started using some combination we are better to end it before using the other one There are six possible combinations to not win the round and and and and and and We can iterate over all permutations of these combinations there are possible permutations and greedily apply them Use the first while it is possible then the second and so on and find the best answer It is also possible that the order of these combinations does not matter but we didn t prove that fact Time complexity 
658,Let s call a set of positive integers if the product of the factorials of its elements is a square of an integer i e for some integer You are given a positive integer Your task is to find a subset of a set of maximum size If there are multiple answers print any of them ,A good start to solve the problem would be to check the answers for small values of One can see that the answers the sizes of the maximum subsets are not much different from itself or rather not less than Let s try to prove that this is true for all Consider is even Let let s see what the product is equal to if we take all the numbers from to From here we can see that for even the answer is at least because we can delete and the product of the remaining factorials will be the square of an integer for odd the answer is at least because we can delete and It remains to prove that the answer is at least for odd This is easy to do because the answer for is not less than the answer for minus because we can delete and solve the task with a smaller value Moreover it can be seen from the previous arguments that the answer can only be for and we already know that in this case one of the correct answers is to remove the factorials It remains to learn how to check whether it is possible to remove or numbers so that the remaining product of factorials is the square of an integer To do this we can use XOR hashes Let s assign each prime number a random bit number For composite numbers the hash is equal to the XOR of hashes of all its prime divisors from factorization Thus if some prime is included in the number an even number of times it will not affect the value of the hash which is what we need The hash of the product of two numbers is equal to the XOR of the hashes of these numbers Let s denote the hash function as Using the above let s calculate for all from to as well as for all from to this is easy to do because We will also store a map Let s calculate the hash and denote it as It remains to consider the following cases if then the current product is already the square of an integer for an answer of size we have to check that there exists such a that To find such let s check whether the map contains for an answer of size we have to check that there are such and that To do this iterate over and then check whether map contains otherwise the answer is and there is an answer where all numbers except are taken ,One important fact is that when we subtract from new will be divisible by old And of course is always divisible by Let s factorize Consider the moment when changes If we denote old value of by the new value of will be divisible by some where is a prime divisor of Let s check all prime divisors of and for each of these divisors find the number of times we need to subtract from to get divisible by that is just don t forget that also has to be divisible by Among all prime divisors of pick one with the minimum required number of operations let this number of operations be add to answer subtract from and repeat the process 
659,You are given a set of all integers from to inclusive and is always odd You want to split these numbers into exactly pairs in such a way that for each pair the greatest common divisor of and is equal to Each number should appear in exactly one of the pairs Print the resulting pairs or output that no solution exists If there are multiple solutions print any of them ,Numbers with the difference of are always relatively prime That s the only thing I should mention for this editorial Overall complexity ,Firstly let s factorize Since we can factorize and separately and then unite divisors For example use can get canonical representations of and to get canonical representation of and then use it to generate all divisors of Let s estimate the number of divisors It s convenient for our purposes to estimate it as More precisely there are at most divisors for search Highly Composite Numbers for more info How to calculate the answer for each divisor There are two ways for each we are searching for the minimum that and Since is fixed the minimum means the maximum So let s find instead In other words for each we need to find the maximum such that divides and We can do it efficiently with on divisors Let be the maximum that is a divisor of and If then obviously Otherwise we know that we are searching Let say that are the prime divisors of the initial number Since is a divisor of and then exists some among the set of prime divisors such that is a divisor of as well So instead of brute search it s enough to take a value In other words if we can calculate Ok now we know value for each divisor Since we found the maximum the last step is to calculate the desired and if we found the answer otherwise it means that is not presented table and The total complexity is per test where is the number of divisors of and is the number of prime divisor of Note that complexity is quite high so you should write it at least a little accurate for example store in an array not map and search position of with There is also a way to get rid of extra factor if you iterate through is a smart way faster easier unproven Let s generate a list of all divisors of as in the increasing order For some divisor we are searching the minimum that is a divisor of and It means that So let s just find the first position such that with and start iterating from onward searching the first that is a divisor of The found would be the minimum we need It looks like in average we will find the correct quite fast or we ll break when 
660,A set of positive integers is called beautiful if for every two integers and from this set either divides or divides or both You are given two integers and Consider all beautiful sets consisting of integers not less than and not greater than You have to print two numbers the maximum possible size of a beautiful set where all elements are from to the number of beautiful sets consisting of integers from to with the maximum possible size Since the second number can be very large print it modulo ,Every beautiful set can be represented as a sequence of its elements in sorted order Let these elements for some set be also let When the set is beautiful every is an integer greater than It s easy to see that if and belong to the whole set belongs to Since in order to maximize we need to choose and as small as possible So why don t we choose and every This will allow us to calculate the maximum possible size of a beautiful set let be this maximum possible size Okay what about counting those sets The claims and that every are no longer true by default However there are some constraints on Firstly every If we had some value of we could replace it with two values of and the size of the set would increase Secondly there is at most one If there are two values we could replace them with three and the size of the set would increase as well So the sequence contains at most one value and the rest of the values are We will divide the sets we want to count into two categories the ones with all and the ones with one value To count the sets in the first category we simply need to count the number of different minimum values in those sets Those minimum values have to be such that multiplying them by wouldn t make them greater than so these are all integers from the segment For every such integer there exists exactly one set of the first category To count the sets in the second category we do a similar thing The minimum value in the set should be from the segment but for every integer from this segment there are different sets of the second category since there are ways to choose which is equal to ,Without loss of generality let s say otherwise we can swap them Note that you can t use more than packets at least one red bean in each packet so can t exceed at most blue beans in each packet So if then asnwer is Otherwise we can form exactly packets 
661,You are given array with elements and the number Consider some subsequence of and the value of least common multiple LCM of its elements Denote LCM as Find any longest subsequence of with the value A subsequence of is an array we can get by erasing some elements of It is allowed to erase zero or all elements The LCM of an empty array equals ,Let be the number of occurences of the number in the given array easy to see that we can ignore the numbers greater than Let s iterate over and and increase the value in the position in some array by the value So the value equals the number of numbers in the given array which divide Let s find the minimal with the maximum value Easy to see that the answer to the problem is the numbers which divide Let s calculate the complexity of the solution The number of the pairs we can bound with the value ,We can rethink this as counting the number of equal pairs where To do this we loop over from right to left and make sure we have all pairs where counted in a map Then we simply iterate over and add up the number of occurrences of each in the map For implementation details note that we don t actually want to use a map and make our code slower We can just use an array of size and convert the pair to the number since the are in the range As a bonus even if the were larger than we could just compress them down to and repeat the solution above Code 91019003 
662,Alice and Bob have received three big piles of candies as a gift Now they want to divide these candies as fair as possible To do this Alice takes one pile of candies then Bob takes one of the other two piles The last pile is split between Alice and Bob as they want for example it is possible that Alice takes the whole pile and Bob gets nothing from it After taking the candies from the piles if Alice has more candies than Bob she discards some candies so that the number of candies she has is equal to the number of candies Bob has Of course Bob does the same if he has more candies Alice and Bob want to have as many candies as possible and they plan the process of dividing candies accordingly Please calculate the maximum number of candies Alice can have after this division process of course Bob will have the same number of candies You have to answer independent queries Let s see the following example Then Alice can choose the third pile Bob can take the second pile and then the only candy from the first pile goes to Bob then Alice has candies and Bob has candies Another example is Then Alice can choose the second pile Bob can choose the first pile and candies from the third pile can be divided in such a way that Bob takes candies and Alice takes candies Now Bob has candies and Alice has candies so she has to discard one candy and after that she has candies too ,The answer is always Let s understand why it is so Let Then let Bob take the pile with candies and Alice take the pile with candies Then because of we can see that Bob s pile always can reach size of Alice s pile and remaining candies can be divided between them fairly except one candy if is odd ,First of all sort the fishermen so it is easier to consider them in ascending order The key observation that allows us to solve the problem is the following there will be an increasing sequence of happy fishermen and all other fishermen will be unhappy Consider the fisherman which belongs to the increasing sequence Let s analyze which fisherman will be next to it in the order It is either a fisherman that will be happy or a fisherman that will be sad In the first case the fish caught by this fisherman must have a size of at least in the second case at most The first case will be considered later For the second case if we know the number of fishermen that were already placed in the order we know that all of them except the th one belong to the sad category that is the fish of every already placed fisherman except for the th one is at least two times smaller than the fish of the th fisherman So if we have already placed fishermen the last happy fisherman was the th one and we want to place a sad fisherman then the number of ways to choose this sad fisherman is exactly where is the number of fishermen such that If we can handle the first case this observation will allow us to solve the problem with dynamic programming Let be the number of ways to choose first fishermen in the order so that the th fisherman is the last happy one The case when the next fisherman is sad can be handled with a transition to the state don t forget to multiply by the number of ways to choose the next sad fisherman as described earlier What about the case when the next fisherman is happy We should iterate on the fisherman such that and transition from to but this part works in To get an solution we have to speed it up with prefix sums or something like that 
663,There are cities in Berland arranged in a circle and numbered from to in clockwise order You want to travel all over Berland starting in some city visiting all the other cities and returning to the starting city Unfortunately you can only drive along the Berland Ring Highway which connects all cities The road was designed by a very titled and respectable minister so it is one directional it can only be traversed clockwise only from the city to the city i e from to from in from to The fuel tank of your car holds up to liters of fuel To drive from the th city to the next one liters of fuel are needed and are consumed in the process Every city has a fuel station a liter of fuel in the th city costs burles Refueling between cities is not allowed if fuel has run out between cities then your journey is considered incomplete For each city calculate the minimum cost of the journey if you start and finish it in that city ,The problem has a rather obvious naive solution in for each starting city but it s too slow So we have to speed up this solution somehow Binary lifting is one of the options but here we have a problem that it is difficult to connect two consecutive groups of steps because after the first group there is a certain amount of fuel left Therefore one of the solutions is to switch to such steps that liters of fuel remains after it Let s consider one of such greedy steps Suppose we are in the city with fuel then the following situations are possible let s buy exactly liters of fuel to reach the next city then the step length is and the cost is and where is the maximum number such that i e the number of consecutive cities with the cost let s buy exactly liters of fuel to reach the next city then the step length is and the cost is and let s find a minimum such that and i e such that you can reach it by spending all of liters let s buy exactly liters with the cost in the city then the step length is and the cost is let s buy liters with the cost in the city and the remainder of liters with the cost in the city then the step length is and the cost is Now using these types of steps we maintain an important invariant after each step the amount of fuel is So we can easily calculate the total distance and cost for several consecutive steps Which leads us to a solution using binary lifting for each city calculate the length and cost of the path with for all up to greedy steps And then using this data we can calculate the answer for each starting city in ,This problem was prepared by dalex Let s build any MST with any fast algorithm for example with Kruskal s algorithm For all edges in MST the answer is the weight of the MST Let s consider any other edge x y There is exactly one path between x and y in the MST Let s remove mostly heavy edge on this path and add edge x y Resulting tree is the MST contaning edge x y this can be proven by Tarjan criterion Let s fix some root in the MST for example the vertex 1 To find the most heavy edge on the path from x to y we can firstly find the heaviest edge on the path from x to l lca x y and then on the path from y to l where l is the lowest common ancestor of vertices x and y To find l we can use binary lifting method During calculation of l we also can maintain the weight of the heaviest edge Of course this problem also can be solved with difficult data structures for example with Heavy light decomposition method or with Linkcut trees Complexity O mlogn It s very strange but I can t find any articles with Tarjan criterion on English although there are articles on Russian so here it is Some spanning tree is minimal if and only if the weight of any other edge x y not from spanning tree is not less than the weight of the heaviest edge on the path from x to y in spanning tree 
664,You are given a permutation of the numbers and pairs of positions At each step you can choose a pair from the given positions and swap the numbers in that positions What is the lexicographically maximal permutation one can get Let and be two permutations of the numbers is lexicographically smaller than the if a number exists so for and ,Consider a graph with vertices whose edges is the pairs from the input It s possible to swap any two values with the positions in some connected component in that graph So we can sort the values from any component in decreasing order Easy to see that after sorting the values of each component we will get the lexicographically maximal permutation ,When Kristina writes sequences on the whiteboard she removes an element with each index exactly once Thus the first element of the permutation will be deleted only once on the first step All sequences except one will start with itTo solve the problem find a sequence such that it starts with some element all sequences other than this one begin with some element Then this permutation will describe the sequence of numbers remaining after removing the th element and the first element itself will be equal to the number The initial permutation will look like 
665,Polycarp has built his own web service Being a modern web service it includes login feature And that always implies password security problems Polycarp decided to store the hash of the password generated by the following algorithm take the password consisting of lowercase Latin letters and shuffle the letters randomly in it to obtain can still be equal to generate two random strings consisting of lowercase Latin letters and any of these strings can be empty the resulting hash where addition is string concatenation For example let the password Then can be equal to Random strings and Then Note that no letters could be deleted or added to to obtain only the order could be changed Now Polycarp asks you to help him to implement the password check module Given the password and the hash check that can be the hash for the password Your program should answer independent test cases ,The general idea of the solution is to check that string contains some substring which is a permutation of The constraints were so low you could do it with any algorithm even per test case could pass The most straightforward way was to iterate over the substring of sort it and check if it s equal to sorted That s Next you could notice than only substrings of length matter and shave another off the complexity to get After that you might remember that the size of the alphabet is pretty low And one string is a permutation of another one if the amounts of letters a letters b and so on in them are equal So you can precalculate array where is equal to the amount of the th letter of the alphabet in Calculating this array for substrings will be each so that makes it Then notice how easy it is to recalculate the letter counts going from some substring to Just subtract from the amount of the th letter and add to the amount of the th letter Comparing two array every time will still lead to though The final optimization is to maintain the boolean array such that means that is equal to the current value of of the substring You are updating just two values of on each step thus only two values of might change You want all the values to be so keep the number of values in that array and say if that number is equal to That finally makes the solution per test case ,Let s write down the indices of the pattern that the th string matches If is not among these then the answer is Otherwise all the patterns except should go in the resulting ordering after Consider that as a graph Let s add an edge from to each of the matches If you add the edges for all the strings then the topological ordering of the graph will give you the valid result If the graph has any cycles in it you can t topsort it then there is no answer To find all the patterns we can use the fact that is rather small Consider all the binary masks of length Each mask can correspond to a set of positions in the string that are replaced with wildcards Now if there is a pattern that is exactly equal to the string with the fixed set of positions replaced by wildcards then that pattern is a match To search for an exact match you can either store all patterns in a map beforehand or in a sorted array or build a trie of them The second version is faster by a factor of but both solutions should pass easily Overall complexity or 
666,You are given two integers and You have to construct the array of length consisting of i e integers greater than or equal to zero such that the sum of elements of this array is and the value is the maximum possible Recall that is the absolute value of In other words you have to maximize the sum of absolute differences between adjacent consecutive elements For example if the array then the value above for this array is Note that this example but it shows how the required value for some array is calculated You have to answer independent test cases ,If then the answer is Otherwise the best way is to construct the array For we can t reach answer more than and for we can t reach the answer more than because each unit can t be used more than twice So the answer can be represented as ,There are two possible solutions in time First of them answers each query using simple iteration changes to for each query until becomes greater than as stated in the problem But it is too slow Second solution precalculates answers for each and if then else But this uses memory and can be done in time Now we can notice that if then second solution will use only time and memory and if then first solution will do not more than operations on each query So we can combine these two solutions Time complexity 
667,Consider an array of length with elements numbered from to It is possible to remove the th element of if where denotes the greatest common divisor After an element is removed the elements to the right are shifted to the left by one position An array with integers such that is a if it is possible to remove all elements of if you remove the th element then the th then the th element For example let is a removal sequence when you remove the st element of the array the condition holds and the array becomes when you remove the st element again the condition holds and the array becomes empty is not a removal sequence when you try to remove the nd element the condition is false An array is if it has removal sequences For example the array is ambiguous it has removal sequences and The array is not ambiguous the only removal sequence it has is You are given two integers and You have to calculate the number of arrays such that the length of is from to and each is an integer from to ,We will calculate the answer by subtracting the number of arrays which have only one removal sequence from the total number of arrays The latter is very simple it s just How do we calculate the number of unambiguous arrays We can always delete the st element of an array so is a removal sequence for each array So we have to calculate the number of arrays which have no other removal sequences How do we check if the array has no removal sequences other than If at any time it s possible to remove some element other than the st from the array it creates another removal sequence since we can always complete that sequence Let s analyze the constraints on each element of the array can be any integer from to should be divisible by otherwise we can remove it on the first step should be divisible by otherwise we can remove it on the first step and by otherwise we can remove it on the second step should be divisible by and but not necessarily by since an element which is divisible by already has a common divisor with And so on using induction we can show that the th element should be divisible by where are all of the primes in Obviously the number of such elements is So we can easily calculate the number of possible elements for each index of the array and that allows us to count all unambiguous arrays ,Let is the greatest common divisor of all elements of the array You can find it by Euclidean algorithm or some standard library functions Then the answer is just the number of divisors of You can find this value in 
668,You are playing a new computer game in which you have to fight monsters In a dungeon you are trying to clear you met three monsters the first of them has health points the second has health points and the third has To kill the monsters you can use a cannon that when fired deals damage to the selected monster Every th i e shots with numbers etc cannon shot is and deals damage to monsters not just one of them If some monster s current amount of health points is it can t be targeted by a regular shot and does not receive damage from an shot You want to pass the dungeon beautifully i e kill all the monsters with the same shot i e after some shot the health points of each of the monsters should become equal to Each shot must hit a monster i e each shot deals damage to at least one monster ,Note that for every shots we deal a total of units of damage Since we want to kill all the monsters with a shot which index is divisible by let s denote the number of shots as In this case a total of units of damage must be dealt hence if the result of the division is not an integer then there is no answer Since each monster will receive at least units of damage with shots the health of each monster must be at least If the two conditions described above are met then the remaining shots can always be distributed in the desired way ,Let s represent spells as points on cartesian plane If we consider three spells and such that and is above on the cartesian plane or belongs to it then we don t need to use spell because we can replace it with a linear combination of spells and without any additional mana cost We can maintain the lower boundary of the convex hull of all points from type queries and the point Then to process type query we have to find the intersection of aforementioned lower boundary and the line our average damage in this fight has to be at least this value If there is no intersection then the answer is because even with infinite mana Vova s character can t deal that much damage before dying If there is an intersection we have to check that it is not higher than the line to ensure that we have enough mana to kill the monster in given time Model solution uses only integral calculations but it seems that precision is enough Time complexity 
669,Three guys play a game first each person writes down distinct words of length Then they total up the number of points as follows if a word was written by one person that person gets 3 points if a word was written by two people each of the two gets 1 point if a word was written by all nobody gets any points In the end how many points does each player have ,You need to implement what is written in the statement To quickly check if a word is written by another guy you should store some or Python dictionary and increment every time you see a new string in the input Then you should iterate through each guy find the number of times their word appears and update their score The complexity is per testcase ,To solve the problem you need to understand two facts The answer can t be greater than If current distance between rivaling student if less then we always can increment this distance by one swap In means that answer is equal to 
670,You are a rebel leader and you are planning to start a revolution in your country But the evil Government found out about your plans and set your punishment in the form of correctional labor You must paint a fence which consists of planks in two colors in the following way suppose planks are numbered from left to right from if the index of the plank is divisible by such planks have indices and so on then you must paint it red if the index of the plank is divisible by such planks have indices and so on then you must paint it blue if the index is divisible both by and to paint the plank otherwise you don t need to paint the plank at all and it is forbidden to spent paint on it Furthermore the Government added one additional restriction to make your punishment worse Let s list all planks of the fence in ascending order if there are consecutive planks with the same color in this list then the Government will state that you failed the labor and execute you immediately If you don t paint the fence according to the four aforementioned conditions you will also be executed The question is will you be able to accomplish the labor the time is not important or the execution is unavoidable and you need to escape at all costs ,At first suppose that if not swap them Let s look at the case where We can be sure that there will be a situation where the th plank is painted in blue and plank is painted in red It s true because it s equivalent to the solution of equation And all we need to check that interval contains less than red planks Or in formulas The situation with is almost the same if we look only at positions which are divisible by in other words we can just divide on and on and check the same condition ,The problem is mainly a tricky implementation problem Let s denote the of an L shape as the square in the middle the one that is side adjacent to two other squares Every elbow is part of exactly one L shape and every L shape has exactly one elbow Iterate through the grid and count the number of side adjacent neighbors they have If there is a cell with more than 2 or if there is a cell with exactly two neighbors on opposite sides then the answer is Otherwise if there are exactly 2 neighbors this cell is an elbow Mark all three cells of this L shape with a unique number say mark the first one you find with the second with and so on If you ever remark a cell that already has a number then two elbows are adjacent and you can output After all elbows are marked check if all shaded cells have a number If some don t then they are not part of an L shape so you can output Finally we should check that L shapes don t share edge or corner Just check for each number if it is only diagonally adjacent to other numbers equal to it or unshaded cells If it is diagonally adjacent to other unequal numbers then the answer is because two L shapes share an edge or corner then Otherwise the answer is There are many other solutions all of which are various ways to check the conditions The complexity is per testcase 
671,You are given a table of size i e two rows and columns consisting of integers from to In one move you can choose some and swap values and in it Each column can be chosen Your task is to find the number of moves required to obtain permutations of size in both first and second rows of the table or determine if it is impossible to do that You have to answer independent test cases Recall that the permutation of size is such an array of size that contains from to exactly once the order of elements doesn t matter ,Firstly we can determine that the answer is if some number has not two occurrences Otherwise the answer exists and we actually don t need to prove it because we can check it later Let s find for each number i from 1 to n indices of columns in which it appears c 1 i and c 2 i Consider some number i If c 1 i c 2 i then let s just skip it we can t change anything by swapping values in this column Otherwise let r 1 i be the number of row of the number i in the column c 1 i and r 2 i is the number of row of the number i in the column c 2 i If r 1 i r 2 i then it s obvious that at exactly one of these two columns should be swapped The same if r 1 i ne r 2 i then it s obvious that we either swap both of them or don t swap both of them Let s build a graph consisting of n vertices when the vertex v determines the state of the v th column If r 1 i r 2 i then let s add edge of color 1 between vertices c 1 i and c 2 i Otherwise let s add the edge of color 0 between these vertices So we have the graph consisting of several connected components and some strange edges Let s color it If the edge v to has the color 1 then the color of the vertex to should be different from the color of the vertex v The same if the edge v to has the color 0 then the color of the vertex to should be the same as the color of the vertex v This makes sense because edges with color 1 mean that exactly one of the columns connected by this edge should be swapped and vice versa So after we colored the graph we can ensure that conditions for each edge are satisfied If it isn t so the answer is but this case can t actually appear Otherwise we need to decide for each component independently what is the color 0 and the color 1 means for it The color 0 can mean that the column having this color isn t swapped and the color 1 means that the column having this color is swapped in this case and vice versa We can choose greedily the minimum number of swaps for each component and print the answer Time complexity O n ,Constraints lead us to some kind of dp solution is it usually called dp on broken profile Let will be the minimum price to get to th column and th row with selected is the previous cells inclusive from if then its exactly current column and two previous ones Transitions for submatrices and are straighforward just update mask with new ones and add to current value If the first cell of these is empty or is set in this position then you can go to or and if for free Finally you can go to with the price of Initial value can be in the first cells of the matrix The answer will be stored in some valid of However you can add extra empty columns and take the answer right from it will be of the same price Overall complexity 
672,Consider the following experiment You have a deck of cards and exactly one card is a joker times you do the following shuffle the deck take the top card of the deck look at it and return it into the deck Let be the number of times you have taken the joker out of the deck during this experiment Assuming that every time you shuffle the deck all possible permutations of cards are equiprobable what is the expected value of Print the answer modulo ,1278F CardsFirst of all I would like to thank Errichto for his awesome lecture on expected value part 1 part 2 This problem was invented after I learned the concept of estimating the square of expected value from that lecture and the editorial uses some ideas that were introduced there Okay now for the editorial itself We call a number as good if and the th shuffle of the deck resulted in a joker on top from our problem is the number of such good numbers We can represent as the number of pairs such that every element of the pair is a good number as the number of triples and so on is the number of tuples such that each element of a tuple is a good number So we can rewrite the expected value of as the expected number of such tuples or the sum of over all tuples where is the probability that consists of good numbers How to calculate the probability that is a good tuple Since all shuffles of the deck result in a joker with probability should be equal to but that is true only if all elements in are unique How to deal with tuples with repeating elements Since all occurences of the same element are either good or bad with probability of being good the correct formula for is where is the number of distinct elements in the tuple Okay then for each we have to calculate the number of tuples with exactly distinct elements To do that we use dynamic programming let be the number of tuples with exactly distinct elements Each transition in this dynamic programming solution models adding an element to the tuple if we want to compute the transitions leading from we either add a new element to the tuple there are ways to choose it and we enter the state or we add an already existing element there are ways to choose it and we enter the state Overall complexity is or depending on your implementation ,This problem can be solved using dynamic programming is if Roma could play first games with balance is and for each such that and we update if if if and all three states if If either of and is then we can restore the sequence Time and memory complexity is As an exercise you can think about linear solution 
673, teams participate in a playoff tournament The tournament consists of games They are held as follows in the first phase of the tournament the teams are split into pairs team plays against team team plays against team and so on so games are played in that phase When a team loses a game it is eliminated and each game results in elimination of one team there are no ties After that only teams remain If only one team remains it is declared the champion otherwise the second phase begins where games are played in the first one of them the winner of the game vs plays against the winner of the game vs then the winner of the game vs plays against the winner of the game vs and so on This process repeats until only one team remains The skill level of the th team is where is a permutation of integers a permutation is an array where each element from to occurs exactly once You are given a string which consists of characters These characters denote the results of games in each phase of the tournament as follows if is equal to then during the th phase the phase with games in each match the team with the lower skill level wins if is equal to then during the th phase the phase with games in each match the team with the higher skill level wins Let s say that an integer is if it is possible to find a permutation such that the team with skill wins the tournament Find all winning integers ,Firstly let s prove that the order of characters in s is interchangeable Suppose we have a tournament of four teams with skills a b c and d such that a b c d and this tournament has the form 01 or 10 It s easy to see that a and d cannot be winners since a will be eliminated in the round with type 1 and d will be eliminated in the round with type 0 However it s easy to show that both with s 10 and with s 01 b and c can be winners Using this argument to matches that go during phases i and i 1 a group of two matches during phase i and a match during phase i 1 between the winners of those matches can be considered a tournament with n 2 we can show that swapping s i and s i 1 does not affect the possible winners of the tournament So suppose all phases of type 1 happen before phases of type 0 there are x phases of type 1 and y phases of type 0 x y n 2 x y 2 y teams will be eliminated in the first part phases of type 1 and the team with the lowest skill that wasn t eliminated in the first half will win the second half It s easy to see that the teams with skills 1 2 x 1 cannot pass through the first part of the tournament since to pass the first part a team has to be the strongest in its subtree of size 2 x Furthermore since the minimum of 2 y teams passing through the first half wins the winner should have skill not greater than 2 x y 2 y 1 the winner should have lower skill than at least 2 y 1 teams so teams with skills higher than 2 x y 2 y 1 cannot win Okay now all possible winners belong to the segment 2 x 2 n 2 y 1 Let s show that any integer from this segment can be winning Suppose k in 2 x 2 n 2 y 1 let s construct the tournament in such a way that only team with skill k and 2 y 1 teams with the highest skill pass through the first part of the tournament obviously then team k wins There are 2 y independent tournaments of size 2 x in the first part let s assign teams with skills from 1 to 2 x 1 and also the team k to one of those tournaments for all other 2 y 1 tournaments let s assign the teams in such a way that exactly one team from the 2 y 1 highest ones competes in each of them It s easy to see that the team k will win its tournament and every team from the 2 y 1 highest ones will win its tournament as well so the second half will contain only teams with skills k and 2 n 2 y 2 2 n and obviously k will be the winner of this tournament So the answer to the problem is the segment of integers 2 x 2 n 2 y 1 ,1278F CardsFirst of all I would like to thank Errichto for his awesome lecture on expected value part 1 part 2 This problem was invented after I learned the concept of estimating the square of expected value from that lecture and the editorial uses some ideas that were introduced there Okay now for the editorial itself We call a number as good if and the th shuffle of the deck resulted in a joker on top from our problem is the number of such good numbers We can represent as the number of pairs such that every element of the pair is a good number as the number of triples and so on is the number of tuples such that each element of a tuple is a good number So we can rewrite the expected value of as the expected number of such tuples or the sum of over all tuples where is the probability that consists of good numbers How to calculate the probability that is a good tuple Since all shuffles of the deck result in a joker with probability should be equal to but that is true only if all elements in are unique How to deal with tuples with repeating elements Since all occurences of the same element are either good or bad with probability of being good the correct formula for is where is the number of distinct elements in the tuple Okay then for each we have to calculate the number of tuples with exactly distinct elements To do that we use dynamic programming let be the number of tuples with exactly distinct elements Each transition in this dynamic programming solution models adding an element to the tuple if we want to compute the transitions leading from we either add a new element to the tuple there are ways to choose it and we enter the state or we add an already existing element there are ways to choose it and we enter the state Overall complexity is or depending on your implementation 
674,You are given an array consisting of integers and a positive integer It is guaranteed that is a divisor of In a single move you can choose any position between and and increase by Let s calculate the number of elements having remainder when divided by In other words for each remainder let s find the number of corresponding elements in with that remainder Your task is to change the array in such a way that Find the minimum number of moves to satisfy the above requirement ,For each from to find all elements of the array that are congruent to modulo and store their indices in a list Also create a vector called and let be We have to cycle from to twice For each from to if there are in list too many i e elements congruent to modulo remove the extra elements from this list and add them to If instead there are too few i e elements congruent to modulo remove the last few elements from the vector For every removed index increase by After doing so after two passes we print the total increase and the updated array It is obvious that after the first iterations every list will have size at most and after more iterations all lists will have the same sizes It can be easily proved that this algorithm produces an optimal answer The time complexity is ,We will calculate the answer by subtracting the number of arrays which have only one removal sequence from the total number of arrays The latter is very simple it s just How do we calculate the number of unambiguous arrays We can always delete the st element of an array so is a removal sequence for each array So we have to calculate the number of arrays which have no other removal sequences How do we check if the array has no removal sequences other than If at any time it s possible to remove some element other than the st from the array it creates another removal sequence since we can always complete that sequence Let s analyze the constraints on each element of the array can be any integer from to should be divisible by otherwise we can remove it on the first step should be divisible by otherwise we can remove it on the first step and by otherwise we can remove it on the second step should be divisible by and but not necessarily by since an element which is divisible by already has a common divisor with And so on using induction we can show that the th element should be divisible by where are all of the primes in Obviously the number of such elements is So we can easily calculate the number of possible elements for each index of the array and that allows us to count all unambiguous arrays 
675,Assume that you have one dimensional segments each segment is denoted by two integers its endpoints Then you can build the following graph on these segments The graph consists of vertexes and there is an edge between the th and the th vertexes if and only if the segments and intersect there exists at least one point that belongs to both of them For example if then the resulting graph is the following A tree of size is good if it is possible to choose one dimensional segments so that the graph built on these segments coincides with this tree You are given a tree you have to find its good subtree with maximum possible size Recall that a subtree is a connected subgraph of a tree Note that you have to answer independent queries ,At first let s understand which trees are good For this let s consider some vertex we denote its segment as which is not a leaf Also let s consider some adjacent vertex we denote its segment as which also is not leaf It is claimed that segment can t be inside segment it s means and vice versa It s true because if segment is inside the segment then some vertex adjacent with also will be adjacent with So any non leaf vertex can be adjacent with at most non leaf vertexes Therefore good tree is a path with a leafs adjacent to this path So all the have to do it s find the such subtree of maximum size We can do it by subtree dynamic programming At first let chose the root of the tree some not leaf vertex Let be the answer for the subtree with root in and dp v 1 be the answer for the subtree with root in if we already took and its parent to the answer It can be calculated as follows there is a first maximum of all and is a second maximum and is a degree of vertex ,The task is obviously solved by dynamic programming so our first reaction should be to start looking for meaningful states for it Obviously one of the states is the vertex which subtree we are processing We can choose the root for the tree arbitrarily let it be vertex What can be the other helpful state Consider the method to find the diameter of the subtree of vertex The diameter can be one of the following paths either the longest path that is completely in some subtree of or the concatenation of the longest paths that start in vertex and end in different subtrees The diameter is the longest path Thus the diameter being less than or equal to means that all paths should have length less than or equal to If we can guarantee that no path that is completely in some subtree of have length greater than then we will only have to worry about not concatenating long paths from different subtrees Phrase it the other way around if we never concatenate the paths from the different subtrees in such a way that their total length is greater than then no diameter will be greater than Thus we can attempt to have the number of ways to cut some edges in the subtree of in such a way that there is no path of length greater than and the longest path starting at vertex has length Now for the transitions For the simplicity let vertex have exactly two children It s not too hard to merge their s Iterate over the length of the first child the length of the second child If then you can concatenate their longest paths and the longest path for will be of length You can also cut either of the edges from to the first child or to the second child The approach is good however it s not clear how to make it work on a larger number of children Also the complexity sounds pretty bad Instead of merging children to each other let s merge each child to the of one by one can store the current maximum length over all processed children When processing a new child you can choose to cut or not to cut the edge to it So you can iterate over the current longest path from and the longest path from that child So far the only way to estimate the complexity is to say that each child has to merge its dp to the parent in thus making the algorithm That s obviously too slow The trick that makes the solution fast is to iterate not to but to the height of the subtree of and the subtree of a child Surely that is allowed since the path just can t grow longer than that value Consider the even worse option not the height but the size of the subtree It s easy to see that the size is always greater or equal than the height Interpret the merge the following way enumerate the vertices inside all the subtrees of the processed children and the vertices inside the subtree of the new child Iterating up to the size of the subtree is the same number of moves as going over the vertices in it The merge will go over all the pairs of vertices such that the first vertex of the pair is in the first set and the second vertex is in the second set Thus each pair of vertices of the tree will be processed exactly once in lca of these vertices There are such pairs thus such s work in Overall complexity 
676,You are given an undirected tree consisting of vertices An undirected tree is a connected undirected graph with edges Your task is to add the minimum number of edges in such a way that the length of the shortest path from the vertex to any other vertex is at most Note that you are not allowed to add loops and multiple edges ,The first idea is the following it is always profitable to add the edges from the vertex to any other vertex The proof is the following if we will add two edges and then the distance to the vertex will be the distance to the vertex will be But we can add edges and and this will be better in fact you cannot obtain the less answer by adding two edges in the other way The main idea is the following Let s carry all vertices of the tree with the distance more than in the set Let the vertex with the maximum distance be What we will obtain if we will add the edge The distance to the vertex will be and the distance to the vertex where is the parent of the vertex if we will root the tree by the vertex will be So we will make reachable at most two vertices if the vertex is already reachable then it will be not counted in the answer Now what we will obtain if we will add the edge We will make reachable all the vertices adjacent to the vertex and the vertex the number of such vertices is not less than so this move won t make the answer greater instead of any other way to add the edge After adding such edge let s remove the vertex and all vertices adjacent to it from the set We need to repeat this algorithm until the set will not become empty Time complexity is I sure that there exists the solution with the dynamic programming in the linear time I will be very happy if someone will explain it to other participants ,I know there exists solution and author of the problem promises to tell it to you here he explained it I d love to tell easier to code and about the same time to work solution At first notice that it is only enough to check the paths such that all vertices on it is divisible by some prime Let s for each calculate the path of the maximum length to pass through it That means that one part of this path goes down to one child of it and another part goes down to another child For each vertex we will store the lengths of maximum paths through vertices with values divisible by each prime in That is memory To recalc the answer we will store all values of children nodes sort them and update the answer with two pointers technique Don t forget about the case of Overall complexity 
677,Dima overslept the alarm clock which was supposed to raise him to school Dima wonders if he will have time to come to the first lesson To do this he needs to know the it will take him to get from home to school The city where Dima lives is a rectangular field of size Each cell on this field is denoted by one number The number means that the passage through the cell is prohibited The number means that the cell is free and Dima can walk though it The number means that the cell contains a portal with a cost of A cell with a portal is also considered free From any portal Dima can go to any other portal while the time of moving from the portal to the portal corresponds to the sum of their costs In addition to moving between portals Dima can also move between unoccupied cells adjacent to one side in time In particular he can enter a cell with a portal and not use it Initially Dima is in the upper left cell and the school is in the lower right cell ,There is no point in using two transitions between portals because if you want to go from portal A to portal B and then from portal C to portal D then you can immediately go from portal A to portal D for less Then there are two possible paths First do not use portals Here it is enough to find the shortest path between two points The second use a single transition Let s choose a portal from which we should teleport Obviously this is a portal with a minimum distance to it and the cost of the transition Similarly the portal in which we should teleport is selected ,First of all let s calculate minimum cut instead of maximum flow The value of the cut is minimum if we choose the first set of the cut as first vertices of part and first vertices of part That s because if is the minimum index such that then we don t have to add any vertices such that to because that would only increase the value of the cut Similarly if is the maximum index such that then it s optimal to add every vertex such that to Okay so we can try finding minimum cut as a function value of the cut if we choose as the union of first vertices in and first vertices in To find its minimum let s rewrite it as where is the sum of capacities of edges added to the cut in part it doesn t depend on part is the sum of capacities added to the cut from part and is the sum of capacities added to the cut by edges going from to These functions can be denoted this way if otherwise is the capacity of the edge going from to if otherwise is the capacity of the edge going from to is the sum of capacities over all edges such that and Since only the values of are not fixed we can solve this problem with the following algorithm For each find the minimum possible sum of Let s denote this as and let s denote Build a segment tree that allows to get minimum value and modify a single value over the values of When we need to change capacity of an edge we add the difference between new and old capacities to and to calculate the maximum flow we query minimum over the whole tree But how can we calculate the values of We can do it using another segment tree that allows to query minimum on segment and add some value to the segment First of all let s set and build this segment tree over values of The value of is fixed for given so it is not modified the value of is initially since when there are no vertices belonging to in the part And then we calculate the values of one by one When we increase we need to process all edges leading from to part When we process an edge leading to vertex with capacity we have to add to every value of such that since if then and this can be performed by addition on segment in the segment tree After processing each edge leading from to part we can query as the minimum value in the segment tree Time complexity of this solution is 
678,Polycarp has an array of is even integers Polycarp conceived of a positive integer After that Polycarp began performing the following operations on the array take an index and reduce the number by After Polycarp performed some possibly zero number of such operations it turned out that numbers in the array became the same Find the maximum at which such a situation is possible or print if such a number can be arbitrarily large , can be arbitrarily large if and only if all numbers in the array are the same In this case we can choose any number and subtract it from all the numbers for example exactly once Suppose we fix some Let be the number of subtractions of the number from the number In this case all numbers will be equal if and only if for any two numbers and from the array Let be the minimum of Then all numbers in the array become the same if for each index we subtract from not but times Then we will never subtract from the element This means that there is always an element in the array from which we can never subtract This element is the minimum on the array Then from we will subtract exactly times Thus with the current it is possible to make all elements equal if and only if for all elements the value where is the minimum on the array is divisible by So the maximum is the greatest common divisor of all values of ,Let s notice that if we multiply the numbers then the power of two of the product is equal to the sum of the powers of two in each of the numbers Let s calculate the initial sum of the powers of twos in the product This can be done as follows let s take the element and divide it by as long as we can while remembering to increase our counter by the number of occurrences of a power of two Now let s move on to operations and note that choosing the index will increase the degree of occurrence of two by a fixed number that is it does not matter when to apply this operation Choosing an index will increment the counter by a number such that is divisible by but not by you can find this again by dividing by while we can Since we want to minimize the number of operations used at each moment of time we will try to use an index that increases the counter by the largest number To do this it is enough to sort the indices by this index of increase and take them greedily from the largest increase to the smallest We get the solution in 
679,Karlsson has recently discovered a huge stock of berry jam jars in the basement of the house More specifically there were jars of strawberry and blueberry jam All the jars are arranged in a row The stairs to the basement are exactly in the middle of that row So when Karlsson enters the basement he sees exactly jars to his left and jars to his right For example the basement might look like this Being the starightforward man he is he immediately starts eating the jam In one minute he chooses to empty either the first non empty jar to his left or the first non empty jar to his right Finally Karlsson decided that at the end the amount of full strawberry and blueberry jam jars should become the same For example this might be the result Jars are numbered from to from left to right so Karlsson initially stands between jars and What is the minimum number of jars Karlsson is required to empty so that an equal number of full strawberry and blueberry jam jars is left Your program should answer independent test cases ,Let s transit from counting strawberry and blueberry jam jars separately to their difference Let be equal to Then eating one strawberry jar decreases by and eating one blueberry jar increases by The goal is to make equal to Let there be some initial difference Let s eat first jars from the left and first jars from the right Difference of the jars on the left is on the right it s So the goal becomes to find such and that Rewrite that as Now for each unique value of save the smallest to reach that value in a map Finally iterate over the and find the minimum answer Overall complexity ,Let s fix number of plates to have pieces of the first cake plates left for the other cake Obviously the most optimal way to distribute pieces to plates will lead to the minimum of pieces on a plate Now try every possible and take maximum of Overall complexity 
680,You are given an integer In one move you can either multiply by two or divide by if it is divisible by without the remainder Your task is to find the minimum number of moves needed to obtain from or determine if it s impossible to do that You have to answer independent test cases ,If the number consists of other primes than and then the answer is Otherwise let be the number of twos in the factorization of and be the number of threes in the factorization of If then the answer is because we can t get rid of all twos Otherwise the answer is Time complexity ,Numbers with the difference of are always relatively prime That s the only thing I should mention for this editorial Overall complexity 
681,You are given an integer and an integer In one step you can do one of the following moves decrease by divide by if is divisible by For example if and you can do the following steps You are asked to calculate the minimum number of steps to reach from ,It s always optimal to divide by whenever it s possible since dividing by equivalent to decreasing by The only problem is that it s too slow to just subtract from each time since in the worst case we can make operations Consider case and But if we d look closer then we can just replace times of subtract with one subtraction of And to make is divisible by we should make subtractions ,The answer can be calculated very easy by Euclid algorithm which is described in the problem statement but all subtractions will be replaced by taking by modulo 
682,You are given an array of positive integers In one step the array is replaced with another array of length in which each element is the greatest common divisor GCD of two neighboring elements the element itself and its right neighbor consider that the right neighbor of the th element is the th element Formally speaking a new array is being built from array such that where is the greatest common divisor of and and is the remainder of dividing by In one step the array is built and then the array is replaced with that is the assignment is taking place For example if then Thus after one step the array will be equal to For a given array find the minimum number of steps after which all values become equal that is If the original array consists of identical elements then consider the number of steps is equal to ,First note that the array stabilizes if and only if it consists of equal elements and the number the array will be consisted of is Indeed at the th step a number equal to will be written at the th position in the array This is easy to prove by induction if at the previous step the adjacent elements in the array were equal to of the numbers on adjacent segments of length in the original array then their greatest common divisor will be the greatest common divisor of the union of these two segments GCD is an idempotent operation Thus the algorithm will stop in no more than steps since after steps all numbers will be equal exactly to If we divide all the numbers by before starting the algorithm then the number of steps won t change but the array will stabilize at the number Since the numbers in the array after the th step will be exactly equal to of all segments of length of the original array it follows that the number of steps after which all values become the same is exactly equal to the length of the maximum segment of the original array on which There are several ways to find the length of such a segment For example you can use range GCD query and binary search The following method is based on the factorization of numbers in other words on their decomposition into prime factors Factorization in this problem could be done using both the sieve of Eratosthenes or factoring each number independently in After all the numbers have been factorized iterate over each and each prime in its factorization In linear time we can go left and right from finding the maximum segment of numbers that contain the same factor Then we can update the answer with the length of this segment and move onto the next prime in the factorization of or go to if all primes have already been iterated through Note that if a segment of numbers divisible by contains indices from to then we iterate through it times In order to avoid reiteration on each segment we remove from the factorizations of all numbers on the segment after considering only one The resulting solution works in where the maximum number of different primes in factoriztion of Considering that so the solution fits into the time limit ,We will calculate the answer by subtracting the number of arrays which have only one removal sequence from the total number of arrays The latter is very simple it s just How do we calculate the number of unambiguous arrays We can always delete the st element of an array so is a removal sequence for each array So we have to calculate the number of arrays which have no other removal sequences How do we check if the array has no removal sequences other than If at any time it s possible to remove some element other than the st from the array it creates another removal sequence since we can always complete that sequence Let s analyze the constraints on each element of the array can be any integer from to should be divisible by otherwise we can remove it on the first step should be divisible by otherwise we can remove it on the first step and by otherwise we can remove it on the second step should be divisible by and but not necessarily by since an element which is divisible by already has a common divisor with And so on using induction we can show that the th element should be divisible by where are all of the primes in Obviously the number of such elements is So we can easily calculate the number of possible elements for each index of the array and that allows us to count all unambiguous arrays 
683,Kristina has two arrays and each containing non negative integers She can perform the following operation on array any number of times apply a decrement to each non zero element of the array that is replace the value of each element such that with the value If was its value does not change Determine whether Kristina can get an array from an array in some number of operations probably zero In other words can she make after some number of operations for each For example let and In this case she can apply the operation twice after the first application of the operation she gets after the second use of the operation she gets Thus in two operations she can get an array from an array ,For all elements of the arrays to become equal after subtraction of units for must be satisfied In addition if there exists then the equality can be obtained only by subtracting exactly units from Since the equality must be satisfied for all the problem is reduced to checking that for all differences are equal and for the difference does not exceed ,Firstly let s notice that for the fixed value of our problem is reduced to the following we are given numbers We need to choose such values that And among all such values we need to choose values in a way to minimize And the sum of is Of course for the fixed value the minimum sum of can be only one Let s start with It is obvious that if the maximum value in the array is the value equals for Assume that each from to has some divisor Then if we multiply by and divide each by the answer will only become better How to calculate this value of fast We can see that this value equals to And it can be proven that this value of is always optimal and we can easily determine for such Time complexity 
684,Adilbek has to water his garden He is going to do it with the help of a complex watering system he only has to deliver water to it and the mechanisms will do all the remaining job The watering system consumes one liter of water per minute if there is no water it is not working It can hold no more than liters Adilbek has already poured liters of water into the system He is going to start watering the garden right now and water it for minutes and the watering system should contain at least one liter of water at the beginning of the th minute for every from to Now Adilbek wonders what he will do if the watering system runs out of water He called his friends and asked them if they are going to bring some water The th friend answered that he can bring no more than liters of water he will arrive at the beginning of the th minute and pour all the water he has into the system if the system cannot hold such amount of water the excess water is poured out and then he will ask Adilbek to pay dollars for each liter of water he has brought You may assume that if a friend arrives at the beginning of the th minute and the system runs out of water at the beginning of the same minute the friend pours his water fast enough so that the system does not stop working Of course Adilbek does not want to pay his friends but he has to water the garden So he has to tell his friends how much water should they bring Formally Adilbek wants to choose integers in such a way that if each friend brings exactly liters of water then the watering system works during the whole time required to water the garden the sum is minimum possible Help Adilbek to determine the minimum amount he has to pay his friends or determine that Adilbek not able to water the garden for minutes You have to answer independent queries ,Despite the fact that statement sounds like some dp or flow the actual solution is pretty greedy Let s iterate over all minutes Adilbek has to water at and maintain the cheapest liters he can obtain to this minute Let this be some structure which stores data in form price for 1 liter total volume Adilbek can buy for this price Pairs will be sorted by the price of a liter The most convenient structure for that might be a C map for example When moving to the next minute pop the cheapest liter out of this structure and add it to the answer If that minute some friend comes then push his water to the structure if the total updated volume in the structure is greater than then pop the most expensive left overs out of it so that the structure holds no more than liters total That prevents out solution to fill the watering system over its capacity The main idea for why this greedy strategy works is that it s never optimal to take not the cheapest liter because a liter of that price or cheaper will still be available in the future minutes Note that between each pairs of adjacent coming friends basically nothing happens Thus you can find the time between them and pop that number of cheapest liters right away instead of iterating minute by minute Overall complexity per query ,Eliminate the obvious corner case when we don t have enough water Now we don t consider it in editorial Let s fix some set of tanks and let be the total amount of water in the set If and have the same remainders modulo then we can transfer all water from to one tank transfer all water from to another tank and then using some number of operations transfer required amount of water from to or from to So we have a solution when we have some set of tanks such that What if we don t have such set In this case it is impossible to solve the problem since we cannot obtain a tank with water such that and obviously we cannot obtain a tank with exactly water To find this set we may use some sort of knapsack dynamic programming 
685,The capital of Berland looks like a rectangle of size of the square blocks of same size Fire It is known that blocks got caught on fire Those blocks are centers of ignition Moreover positions of of these centers are known and one of these stays unknown All positions are distinct The fire goes the following way during the zero minute of fire only these centers of ignition are burning Every next minute the fire goes to all neighbouring blocks to the one which is burning You can consider blocks to burn for so long that this time exceeds the time taken in the problem The neighbouring blocks are those that touch the current block by a side or by a corner Berland Fire Deparment wants to estimate the minimal time it takes the fire to lighten up the whole city Remember that the positions of blocks centers of ignition are known and th can be positioned in any other block Help Berland Fire Department to estimate the minimal time it takes the fire to lighten up the whole city ,We can use binary search to find the answer When binary searching to check whether the whole city will be lightened up after minutes we can use sweep line technique to find the smallest coordinate of the cell that is not lightened by centers of ignition and the smallest coordinate too Suppose that and are these coordinates then we can place the last center of ignition at coordinates Then we can use sweep line again to check whether the city is fully ignited ,For each person let s calculate how much the value will change if they turn around For example in the line if the th person turns around then the value of the line will change by respectively For instance if the second person turns around they see people before and person after so the value of the line changes by if they turn around Now note that if a person turns around it doesn t affect anyone else s value So the solution is a greedy one let s sort the array of values in increasing order Afterwards we should go from the left to the right and see if the value will increase if this person turns around if it does we should add it to the current total and continue The time complexity of this solution is per testcase 
686, You may use in C in Java in Python or in Pascal to flush the output If you use some other programming language consult its documentation You may also refer to the guide on interactive problems https codeforces com blog entry 45307 The jury has chosen a string consisting of characters each character of is a lowercase Latin letter Your task is to guess this string initially you know only its length You may ask queries of two types the query of the first type where is an integer from to In response to this query the jury will tell you the character the query of the second type where and are integers such that In response to this query the jury will tell you the number of different characters among You are allowed to ask no more than queries of the first type and no more than queries of the second type Your task is to restore the string For each test in this problem the string is fixed beforehand and will be the same for every submission ,There are several ways to solve this problem The model solution does it as follows Restore the characters of from left to right The first character is restored by query For each of the next characters let s ask if this character is new by querying and comparing the result with the number of different characters on the segment If it s new ask to obtain the th character there will be at most such queries Otherwise we can find the previous occurrence of the th character with binary search Let be the number of different characters from position to position If we want to find the previous occurrence of the th character we need to find the last index such that Since the value does not decrease when we increase we can find the last such that with binary search Unfortunately the number of queries of type will be too large if we just use binary search over the whole segment To decrease the number of queries we can use the fact that the value of we are interested in is the last occurrence of some character we already met there are at most such values and binary search among them will need only iterations ,At first notice that the final answer is minimum over answers for each character The answer for one character can be obtained like this Write down lengths of segments between two consecutive occurrences of this character from the first occurrence to the start of the string and from the last to the end of the string Take maximum of these values Answer will be this maximum 1 Overall complexity 
687,The whole delivery market of Berland is controlled by two rival companies BerEx and BerPS They both provide fast and reliable delivery services across all the cities of Berland The map of Berland can be represented as an graph The cities are vertices and the roads are edges between them Each pair of cities has no more than one road between them Each road connects different cities BerEx and BerPS are so competitive that for each pair of cities they have set up their paths from to in such a way that It is guaranteed that it was possible Now Berland government decided to cut down the road maintenance cost by abandoning some roads Obviously they want to maintain as little roads as possible However they don t want to break the entire delivery system So BerEx and BerPS should still be able to have their paths between every pair of cities non intersecting What is the minimal number of roads Berland government can maintain ,Let s use dynamic programming to solve this problem We will start with a single biconnected component consisting of vertex and connect other vertices to it So the state of our dynamic programming will be a of vertices that are in the same biconnected component with How can we extend a biconnected component in such a way that some other vertices are added into it but it is still biconnected We will add a path possibly cyclic that starts in some vertex belonging to the goes through some vertices and ends in some vertex belonging to the possibly If for every triple we precalculate some path that starts in goes through vertices from and ends in and does not contain neither nor then we can solve the problem in there will be states for every state we will iterate on two vertices and belonging to the and the number of possible pairs of non intersecting masks and is The only thing that s left is precalculating the paths for triples That can be done with auxiliary dynamic programming which will denote whether such a path exists For every edge of the original graph is true and we can go from to some state where will contain all vertices from and vertex and we should ensure that there is an edge in the graph and the didn t contain vertex earlier We should also somehow be able to restore the paths from this dp and we also should be careful not to choose the same edge twice for example if we start a path by edge we should not use the same edge to return to both these things can be done for example by storing next to last vertex in the path ,Let s call a point if its color does not match the color of any other point If a point is not isolated then it has the same color as the points with minimum distance to it and only these points should have this color Let s build a directed graph where the arc means that the point is one of the closest to the point i e If there is a path from the vertex to the vertex it means that if the vertex is not isolated the vertex should have the same color as vertex Suppose the set of vertices reachable from including itself is Finding is easy just run DFS from the vertex Let s analyze two cases there exists a pair of vertices such that and there is no arc from to for every pair of vertices such that and there is an arc Why do we need to analyze these two cases In the first case the vertex be isolated because painting it and some other vertex into the same color means that every vertex from will have this color and it will break the condition in the statement In the second case the vertex may be isolated or it may have the same color as all vertices in and if it is isolated then the whole set should consist of isolated vertices Let s find all such set of vertices that meet the second case Each vertex will belong to at most one of these sets if it doesn t belong to any it must be isolated otherwise either the whole its set consists of isolated vertices or the whole set has the same color So for each set we either use color or colors This allows us to implement a knapsack like dynamic programming let be the number of ways to paint first sets into colors such that the colors are not ordered After running this dynamic programming we can get the answer by simple combinatorics iterate on the number of colors we use in these sets in total multiply the dynamic programming for it by the ordered number of ways to choose these colors from and then by the number of ways to choose the colors for points that must be isolated This dynamic programming can even be implemented a bit easier if we treat every vertex that must be isolated as a set of size and this is the way it s written in the model solution 
688,You are given an undirected connected graph consisting of vertices and edges vertices of this graph are special You have to direct each edge of this graph or leave it undirected If you leave the th edge undirected you pay coins and if you direct it you don t have to pay for it Let s call a vertex if it is reachable from each special vertex along the edges of the graph if an edge is undirected it can be traversed in both directions After you direct the edges of the graph possibly leaving some of them undirected you receive coins for each saturated vertex Thus your total profit can be calculated as where is the set of saturated vertices and is the set of edges you leave undirected For each vertex calculate the maximum possible profit you can get if you have to make the vertex saturated ,Suppose we want to calculate the maximum profit for some vertex in Let s try to find out how it can be done and then optimize this process so we don t have to run it times First of all we have to find the bridges and biconnected components in our graph Why do we need them Edges in each biconnected component can be directed in such a way that it becomes a strongly connected component so we don t have to leave these edges undirected it is never optimal Furthermore for each such component either all vertices are saturated or no vertex is saturated Let s build a tree where each vertex represents a biconnected component of the original graph and each edge represents a bridge We can solve the problem for this tree and then the answer for some vertex of the original graph is equal to the answer for the biconnected component this vertex belongs to Okay now we have a problem on tree Let s implement the following dynamic programming solution root the tree at the vertex we want to find the answer for and for each vertex calculate the value of the maximum profit we can get for the subtree of vertex if it should be reachable by all special vertices from its subtree Let s analyze how we can calculate these values Suppose we have a vertex with children we have already calculated the values for the children and we want to calculate First of all since the vertex is going to be saturated we will get the profit from it so we initialize with Then we should decide whether we want to get the profit from the children of vertex Suppose the edge leading from to has weight If we want to take the profit from the subtree of we usually have to make this edge undirected so both vertices are saturated thus we get as profit or we could leave this edge directed from to so the vertex is saturated and is not and get as the profit But sometimes we can gain the profit from the vertex and its subtree without leaving the edge undirected if all special vertices belong to the subtree of we can just direct this edge from to and there is no reason to choose the opposite direction or leave the edge undirected Similarly if all special vertices are outside of this subtree there s no reason to direct the edge from to So if one of this conditions is met we can get the full profit from the subtree of without leaving the edge undirected Okay let s summarize it We can calculate as where is either if one of the aforementioned conditions is met we don t have to leave the edge undirected if we want to saturate both vertices or otherwise Now we have an solution Let s optimize it to Root the tree at vertex and calculate the dynamic programming as if is the root Then we shall use technique to recalculate the dynamic programming for all other vertices we will try each vertex as the root of the tree and is the answer for the vertex if it is the root The rerooting technique works as follows let s run DFS from the initial root of the tree and when we traverse an edge by starting or finishing a recursive call of DFS we move the root along the edge so if we call is the current root if it has some child we move the root to the same moment when we call and when the call of ends the root moves back to Okay the only thing that s left is to describe how we move the root If the current root is and we want to move it to a vertex adjacent to then we have to change only the values of and first of all since is no longer a child of we have to subtract the value that was added to while we considered vertex then we have to make the child of vertex so we add the profit we can get from the vertex to It can be done in so our solution runs in though with a very heavy constant factor ,Let s find a set of leaves of a given tree From each leaf we will climb up the tree until we meet a vertex already visited Having met such a vertex start a new path from the next leaf The sequence of vertices in the found paths must be deduced in reverse order because the paths must go from bottom to top It also follows from this solution that the number of paths will always be equal to the number of leaves in the tree 
689,You are given an array of integers You can apply the following operation an arbitrary number of times select an index and replace the value of the element with the value where is the remainder of the integer dividing by For a single index value this operation can be applied multiple times If the operation is applied repeatedly to the same index then the current value of is taken into account each time For example if then after the first operation we get and after the second operation we get Check if it is possible to make array elements equal by applying multiple possibly zero operations For example you have an array Let s apply this operation to the first element of the array Let s replace with We get the array Then apply this operation to the second element of the array Let s replace with We get the array Thus by applying operations you can make all elements of an array equal ,Let s see which remainders modulo change into which ones If the array contains a number divisible by then it cannot be changed If there is a number that has a remainder of modulo then it can only be replaced once Thus if the array contains a number divisible by then we apply this operation to all elements of the array once and check that all its elements are equal The remaining odd balances immediately turn into even ones The even remainders change in a cycle while the array element increases by in operations Thus we will apply the operation to each element of the array until its remainder modulo becomes for example and then check that the array does not contain both remainders and modulo , can be arbitrarily large if and only if at least half of the numbers in the array are the same In this case we can choose any number and subtract it from all numbers for example exactly once Let s iterate over the element it will be the minimum among the numbers that we want to make the same Let s calculate the number of numbers in the array that are equal to this element If this number is at least then the answer is Otherwise we will iterate over numbers which are strictly greater than the selected minimum and for each number we will iterate over the divisors of the number For each of the found divisors let s calculate the number of for which this divisor was found Among all such divisors for which the sum of the found number and the number of numbers equal to is greater than or equal to we will choose the maximum one The greatest found divisor will be the desired This solution works in where is the absolute value of the maximum on the array 
690,You are given two strings and both consisting only of lowercase Latin letters The substring is the string which is obtained by taking characters without changing the order Each of the occurrences of string in a string is a position such that is the length of string You are asked queries for the th query you are required to calculate the number of occurrences of string in a substring ,Let s take a look at a naive approach for each query you iterate over positions and check if Okay this is obviously Now we notice that there are only positions for to start from we can calculate if there is an occurrence of starting in this position beforehand in Thus we transition to solution Finally we calculate a partial sum array over this occurrence check array and answer each query in Overall complexity ,We can add or subtract until the difference between and becomes less than And if it is not after all such moves we need one additional move Let is the absolute difference between and The final answer is plus one if This formula can be represented as divided by rounded up in other words 
691,The chief wizard of the Wizengamot once caught the evil wizard Drahyrt but the evil wizard has returned and wants revenge on the chief wizard So he stole from his student Harry The is a length string of lowercase Latin letters Drahyrt wants to replace with an unforgivable curse string Drahyrt using ancient magic can swap letters at a distance or in as many times as he wants In other words Drahyrt can change letters in positions and in if or For example if and Drahyrt can act as follows swap the letters at positions and to get swap the letters at positions and to get You are given and Can Drahyrt change to ,In these constraints the problem could be solved as follows Note that for strings of length and more it is enough to check that the strings and match character by character that is up to permutation since each character can be moved to the desired half and then moved to the desired side by length by applying two operations on the length is and For example there was a string and we want to shift the character to the left then we can first get the string and then the string Well we can restore the used symbols by putting them in their place That is we were able to simply swap two adjacent characters Thus with such a clipping it was possible to solve the problem by brute force for To iterate it was possible to store of strings which we can get and iterate through all the strings using ,Consider all possible strings of length on the alphabet of size there are of them Let be the number of occurrences of the th of them in the string The cost of the string by definition is Now let s suppose there are two strings and such that Then if we somehow reduce the number of occurrences of the string by and increase the number of occurrences of the string by the cost will decrease So in the optimal answer all the strings of length should appear the same number of times and if it s impossible the difference in the number of appearances should not be greater than Let s suppose that then our goal is to build a string where each string of length on the alphabet of characters appears exactly once The construction of this string can be modeled using Eulerian cycles build a directed graph with vertices where each vertex represents a character each arc represents a string of length and for every pair of vertices there is an arc from to it s possible that Then by finding the Eulerian cycle in this graph it always exists since the graph is strongly connected and for each vertex its in degree is equal to its out degree we find a string of length such that all its substrings are different so each string of length appears there once as a substring Okay what about the cases and Since the string we build for the case represents a cycle we can make it cyclical and repeat the required number of times then cut last several characters if it s too big For example if then the string for is it s not the only one but we can use it We can expand this string to by repeating the last characters and delete the last character so its length is By the way in this problem you don t have to implement the algorithm that finds Eulerian cycles The graph where we want to find the Eulerian cycle has a very special structure and there are many different constructive ways to find the cycle in it But if you can t use them you always can rely on the straightforward solution that explicitly searches for the Eulerian cycle 
692,Consider the points on the number line There is a teleporter located on each of the points At point you can do the following Move left one unit it costs coin Move right one unit it costs coin Use a teleporter at point if it exists it costs coins As a result you can choose whether to teleport to point or point Once you use a teleporter you use it again You have coins and you start at point What s the most number of teleporters you can use ,Please also refer to the tutorial for the easy version If we are not at the first taken portal the problem is still independent for each portal but this time the cost of a portal is since we can come to a portal either from point or point So we again sort the portals by their costs But this time we need to make sure that the first taken portal is taken from point so we will iterate over all portals and check the maximum amount of portals we can take if we use it as the first one We can check this using prefix sums over the minimum cost array and binary searching checking if the amount of considered portals taken doesn t exceed the number of coins we initially have we also have to deal with the case when the portal we are considering is included both times as the initial portal and in the minimum cost prefix ,Firstly let s find any spanning tree and root it at any vertex For each vertex we calculate the distance to the root let it be for vertex There are no more than edges that don t belong to the tree For each of these edges let s run Dijkstra s algorithm from some vertex incident to this edge Suppose we are answering a query If the shortest path between these vertices passes only along the edges of the tree then it can be calculated by the formula where is the lowest common ancestor of vertices and You may use any fast enough algorithm you know to calculate Otherwise there exists at least one vertex such that we ran Dijkstra s algorithm from it and it belongs to the shortest path Just iterate on every vertex for which we ran Dijkstra and update the answer with the value of where is the shortest path to the vertex from the fixed vertex 
693,You are given two integers and You want to choose two greater than zero integers and and then apply the following operation to times replace with You want to find two positive integers and such that becomes equal to after this process If there are multiple possible pairs you can choose If there is no such pair report it For example if and you may choose and so that becomes equal to if and you may choose and so that becomes equal to if and there is no answer since you cannot decrease with the given operations ,The process in the statement can be rephrased as multiply by will be divisible by so if is not divisible by there is no answer Otherwise and can be used ,Note that n le d n le 10 7 10 7 is the maximum value of c in the problem so it is enough for every n 1 10 7 to calculate the value of d n To calculate the value of d n you can use the sieve of Eratosthenes and get the solution for mathcal O 10 7 log 10 7 Also you can use the linear sieve of Eratosthenes to find the minimum divisor for each n 1 10 7 and use the multiplicativity of the function d n d a cdot b d a cdot d b if gcd a b 1 
694,You are given an array Some element of this array is a iff it is strictly less than both of its neighbours that is and Also the element can be called iff it is strictly greater than its neighbours that is and Since and have only one neighbour each they are neither local minima nor local maxima An element is called a iff it is either local maximum or local minimum Your task is to calculate the number of local extrema in the given array ,Iterate over indices from to and check if at least one of given local extremum conditions holds Overall complexity ,The answer to this problem can be constructed this way Sum up all positive numbers Find maximum of negative odd numbers Find minimum of positive odd numbers If sum was even then subtract Overall complexity 
695,You are given a string consisting of lowercase Latin letters You are asked queries about it given another string consisting of lowercase Latin letters perform the following steps concatenate and calculate the prefix function of the resulting string print the values of the prefix function on positions and denote the lengths of strings and respectively revert the string back to The prefix function of a string is a sequence where is the maximum value of such that and denotes a contiguous substring of a string from a position to a position inclusive In other words it s the longest proper prefix of the string that is equal to its suffix of the same length ,What s the issue with calculating the prefix function on the string and then appending the string with an extra recalculations Calculating prefix function is linear anyway Well it s linear but it s also amortized So while it will make operations for a string in total it can take up to on every particular letter These particular letters can appear in string making the algorithm work in Let s analyze the classic way to calculate the prefix function To append a character to the string and calculate the new value of the prefix function you have to do the following take the longest proper prefix of a string before appending the letter which is also a suffix if the letter right after it is the same as the new one then the new value is length of it plus one if it s empty then the new value is otherwise take its longest proper prefix and return to step Basically from having the value of the prefix function of the string and the new letter you can determine the new value of the prefix function If was always equal to then you would only want to try all options for the next letter after a string That should remind you of a structure known as prefix function automaton Its states are the values of the prefix function and the transitions are appending a letter to a string with a certain value of the prefix function So you can append a letter in if you have an automaton built on the string However you can t just append more letters after one you don t have the automaton built this far You can follow two paths The first one is to jump with a regular way of calculating the prefix function until you reach the state of the automaton which exists The second one is to continue building the automaton onto the string calculating the prefix function along the way Appending a layer to the automaton takes non amortized After you calculated everything you needed pop the states back to the original Overall complexity or ,Greedy idea To minimize the string we will go from left to right and maintain a variable maximal character from which we will reduce everything to a Initially it is a and we spend of operations on it Then at the next symbol we can either reduce it to a in no more than operations or reduce to a the prefix we have already passed and minimize the next character in the remaining operations 
696,You are given segments on the coordinate axis The th segment is Let s denote the set of all integer points belonging to the th segment as Let be the union of two sets and be the intersection of two sets and and be the symmetric difference of and a set which contains all elements of and all elements of except for the ones that belong to both sets Let be an array where each element is either or Over all ways to choose this array calculate the sum of the following values In this expression denotes the size of the set ,We will use the Contribution to the Sum technique to solve this problem for every integer from to let s calculate the number of ways to choose the operators so it belongs to the result and add all of the results For a fixed integer the number of ways to choose the operators so that belongs to the result can be done as follows let be the number of ways to choose the first operators so that after applying them the resulting set contains if and does not contain if The transitions from to depend on whether the number belongs to the segment Obviously this is too slow if we compute the dynamic programming from scratch for every integer Instead we can notice that the transitions from to are linear combinations both and are linear combinations of and with coefficients depending on whether the element belongs to the set or not So transitioning from to can be written in terms of multiplying by a matrix Let s build a segment tree where each vertex stores a transition matrix and operations are calculate the product of matrices on a segment and replace a matrix at some index We can build a sequence of these transition matrices for and store them in the segment tree for this sequence of transition matrices will change only in positions such that either belongs to and does not belong to it or vice versa So we can go from to by replacing these transition matrices in the segment tree For the only changes from are in positions such that either belongs to and does not belong to it or vice versa and we can replace the matrices in these positions as well In total there will be only such replacements so we solve the problem in where is the constraint on the numbers belonging to the sets ,Let be a number of occurrences of number in subsegment The given task is equivalent to choosing and value such that is maximum possible But with some transformations so we need to maximize Key observation is the next if we fix some value then we can shrink each segment between consecutive occurrences of in one element with weight equal to Then we need just to find subsegment with maximal sum the standard task which can be solved in Finally total complexity is 
697,Vova has won trophies in different competitions Each trophy is either golden or silver The trophies are arranged in a row The of the arrangement is the length of the longest subsegment consisting of golden trophies Vova wants to swap two trophies not necessarily adjacent ones to make the arrangement as beautiful as possible that means to maximize the length of the longest such subsegment Help Vova Tell him the maximum possible beauty of the arrangement if he is allowed to do at most one swap ,Let be the maximal segment of gold cups that begins in the cup Let be the maximum segment of gold cups that ends in the cup Also let the total number of gold cups be Note that it makes no sense to change the cups of the same color Then let s consider the silver cup which will change with the gold cup let its number be Then if then we will update the answer with the value and otherwise with the value This will not work if all the cups are golden In this case the answer is ,Let s build some rectangles and take a look at the resulting pairings For example consider only red green rectangles Let the rectangles be Sort them in a non decreasing order of I claim that in the most optimal set are also sorted in a non decreasing order It s easy to prove with some induction Moreover if there are some green or red sticks that are not taken and that are longer than the smallest taken corresponding sticks then it s always optimal to take those instead These facts helps us to conclude that from each set only some suffix of the largest sticks are taken And they also give us the idea of the solution sort the sticks in each set and pick the largest from any of the two sets into a pair until no pairs can be taken However the greedy approach of take from any two of the three sets is incorrect We need to choose these two sets smartly Let store the maximum total area that can be obtained by taking largest red sticks largest green sticks and largest blue sticks Each transition chooses a pair of colors and takes the next pairs in both of them The answer is the maximum value in all the Overall complexity 
698,Chef Monocarp has just put dishes into an oven He knows that the th dish has its optimal cooking time equal to minutes At any minute Monocarp can put dish out of the oven If the th dish is put out at some minute then its unpleasant value is the absolute difference between and Once the dish is out of the oven it can t go back in Monocarp should put all the dishes out of the oven What is the minimum total unpleasant value Monocarp can obtain ,There are a lot of solutions for the problem Let s start with the easiest one Sort the dishes in the non decreasing order of their optimal time I claim that there is an optimal answer such that the times for each dish go in the increasing order That s not too hard to prove something along the lines of if there are two dishes and such that and then is always greater than So we can use dynamic programming to solve the task Let be the minimum total unpleasant value if dishes are processed and the current minute is For the transitions you can either put out the current dish at the current minute or wait one more minute Notice that you ll never need more time than minutes the actual constraint is even smaller just consider the case with all dishes times equal to So that dp works in The other possible solution is matching Let s build the following graph The left partition is vertices corresponding to dishes The right partition is vertices corresponding to minutes as we saw in previous solution is always enough Now add the edges between all dishes and all minutes with the cost of their absolute different Finally find the minimum cost maximum matching That can be done with MCMF or Hungarian algorithm Both should pass pretty easily There s also a solution in involving the slope trick ,Eliminate the obvious corner case when we don t have enough water Now we don t consider it in editorial Let s fix some set of tanks and let be the total amount of water in the set If and have the same remainders modulo then we can transfer all water from to one tank transfer all water from to another tank and then using some number of operations transfer required amount of water from to or from to So we have a solution when we have some set of tanks such that What if we don t have such set In this case it is impossible to solve the problem since we cannot obtain a tank with water such that and obviously we cannot obtain a tank with exactly water To find this set we may use some sort of knapsack dynamic programming 
699,Today at the lesson of mathematics Petya learns about the digital root The digital root of a non negative integer is the single digit value obtained by an iterative process of summing digits on each iteration using the result from the previous iteration to compute a digit sum The process continues until a single digit number is reached Let s denote the digital root of as Then As a homework Petya got tasks of the form find th positive number whose digital root is Petya has already solved all the problems but he doesn t know if it s right Your task is to solve all tasks from Petya s homework ,The key observation is that the digital root of an integer is the single digit number such that You can prove this by noticing that for all Once we observe this finding the th number is very simple see the code 48993705 ,Let s consider two sequences of digits and there is the first even digit in is the second even digit and so on and is the first odd digit in is the second odd digit and so on Since you can t swap digits of same parity the sequence of even digits of never changed Sequence of odd digits of also never changed So the first digit in the answer will be equal to or to And since we have to minimize the answer we have to chose the as the first digit in answer and them delete it from the corresponding sequence in this way sequence turn into or sequence turn into Second third and followings digits need to choose in the same way 
700,You are given a string consisting of lowercase Latin letters Character is called dominant iff each substring of with length at least contains this character You have to find minimum such that there exists at least one dominant character ,At first notice that the final answer is minimum over answers for each character The answer for one character can be obtained like this Write down lengths of segments between two consecutive occurrences of this character from the first occurrence to the start of the string and from the last to the end of the string Take maximum of these values Answer will be this maximum 1 Overall complexity ,Let s replace all characters of with zeros and ones zero if the character is unavailable and one otherwise Then we have the binary string and we have to calculate the number of contiguous segments of this string consisting only of ones It can be done with two pointers approach If we are staying at the position and its value is zero just skip it Otherwise let s find the leftmost position such that and the th value is zero Then we have to add to the answer the value and set Time complexity 
701,You are given an integer You have to change the minimum number of digits in it in such a way that the resulting number and If there are multiple ways to do it print any of them If the given number is already divisible by leave it unchanged ,A lot of different solutions can be written in this problem The model solution relies on the fact that every th integer is divisible by and it means that there is always a way to change the last digit of or leave it unchanged so that the result is divisible by So if is already divisible by we just print it otherwise we change its last digit using some formulas or iteration on its value from to ,Let s rewrite concatenation in a more convenient form where is the number of digits in Then this number is divisible by if and only if the sum of and is either or Let s calculate arrays of remainders For each adds to That s the first term of the sum Now iterate over the second term for and for you binary search for in The number of its occurrences should be added to answer You also might have calculated some pairs iterate over them and subtract them naively Overall complexity 
702,Recently a new building with a new layout was constructed in Monocarp s hometown According to this new layout the building consists of three types of apartments three room five room and seven room apartments It s also known that each room of each apartment has exactly one window In other words a three room apartment has three windows a five room five windows and a seven room seven windows Monocarp went around the building and counted windows Now he is wondering how many apartments of each type the building may have Unfortunately Monocarp only recently has learned to count so he is asking you to help him to calculate the possible quantities of three room five room and seven room apartments in the building that has windows If there are multiple answers you can print any of them Here are some examples if Monocarp has counted windows there could have been three room apartments five room apartments and seven room apartments since if Monocarp has counted windows there could have been three room apartments five room apartments and seven room apartments since if Monocarp has counted windows he should have mistaken since no building with the aforementioned layout can have windows ,There are many possible solutions to this problem The simplest one is to notice that using several flats of size and one flat of some size possibly also possibly not we can get any equal to or The only numbers that don t belong to these lists are and and it s easy to see that there is no answer for that numbers So the solution is to try all possible sizes of one flat and if the remaining number of windows is non negative and divisible by then take the required number of three room flats ,There are three constraints on the number of emeralds the number of emeralds can t be greater than the number of emeralds can t be greater than the number of emeralds can t be greater than So the answer is 
703,There are students in a school class the rating of the th student on Codehorses is You have to form a team consisting of students such that the ratings of all team members If it is impossible to form a suitable team print without quotes Otherwise print and then print distinct numbers which should be the indices of students in the team you form If there are multiple answers print any of them ,Let s write our unique function Keep the array of the taken elements Iterate over all elements in the array and if the current element is not used then add its index to the answer and set When finished check the number of distinct values that is the size of answer array If it is less than print Otherwise print and output the first elements of the answer ,Let then it is the standard problem which can be solved by FFT Fast Fourier Transform The solution is the following consider the polynomial which the th coefficient equals to one if and only if there is the number in the given array Let s multiply that polynomial by itself and find for which the coefficient in square not equals to Those values will be in the answer Easy to modificate the solution for the arbitrary We should simply calculate the th degree of the polynomial The complexity will be where is the maximal sum We can improve that solution Instead of calculating the th degree of the polynomial we can calculate the th degree of the DFT of the polynomial The only problem is the large values of the th degrees We can t use FFT with complex numbers because of the precision problems But we can do that with NTT Number theoretic transform But that solution also has a problem It can happen that some coefficients became equals to zero modulo but actually they are not equal to zero To get round that problem we can choose two three random modules and get the complexity The main author solution has the complexity FFT with complex numbers the second solution has the same complexity but uses NTT and the third solution has the improved complexity but it was already hacked by halyavin 
704,You are given a permutation of integers a permutation is an array where each element from to occurs exactly once Let s call some subsegment of this permutation special if Please calculate the number of special subsegments ,Let s fix the maximum element on segment and iterate on either the elements to the left of it or to the right of it and if the current maximum is and the element we found is check whether the element can form a special subsegment with that is is the maximum value on the segment between and That obviously works in yes Well not exactly If we can precompute the borders of the segment where is the maximum element this can be done with some logarithmic data structure or just by processing the array with a stack forwards and backwards and always choose to iterate on the smaller part of the segment it s Why is it so Every element will be processed no more than times because if we process it in a segment of size the smaller part of it contains no more than elements which we will process later and the smaller part of this segment contains no more than elements and so on Checking whether the element belongs to the segment we are interested in can be done in if we precompute inverse permutation for ,Let s the same sum of blocks in the answer Obviously can be represented as a sum of some adjacent elements of i e for some and Iterate over all possible blocks in and for each sum store all the blocks You can use map int vector pair int int to store blocks grouped by a sum You can do it with the following code map int vector pair int int segs for int r 0 r n r int sum 0 for int l r l 0 l sum a l segs sum push back l r Note that blocks are sorted by the right end in each group After it you can independently try each group there are of them and find the maximal disjoint set of blocks of a group You can do it greedily each time taking into the answer segment with the smallest right end Since in each group they are ordered by the right end you can find the required maximal disjoint block set with one pass Let s assume is the current group of blocks they are ordered by the right end then the following code constructs the maximal disjoint set int cur 0 int r 1 vector pair int int now for auto seg pp if seg first r cur now push back seg r seg second Choose the maximum among maximal disjoint sets for the groups 
705,Medicine faculty of Berland State University has just finished their admission campaign As usual about of applicants are girls and majority of them are going to live in the university dormitory for the next hopefully years The dormitory consists of rooms and a single mouse Girls decided to set mouse traps in some rooms to get rid of the horrible monster Setting a trap in room number costs burles Rooms are numbered from to Mouse doesn t sit in place all the time it constantly runs If it is in room in second then it will run to room in second without visiting any other rooms inbetween means that mouse won t leave room It s second in the start If the mouse is in some room with a mouse trap in it then the mouse get caught into this trap That would have been so easy if the girls actually knew where the mouse at Unfortunately that s not the case mouse can be in any room from to at second What it the minimal total amount of burles girls can spend to set the traps in order to guarantee that the mouse will eventually be caught no matter the room it started from ,Mouse jumps on a cycle at some point no matter the starting vertex thus it s always the most profitable to set traps on cycles The structure of the graph implies that there are no intersecting cycles Moreover mouse will visit each vertex of the cycle so it s enough to set exactly one trap on each cycle The only thing left is to find the cheapest vertex of each cycle This can be done by a simple dfs Overall complexity ,For each person let s calculate how much the value will change if they turn around For example in the line if the th person turns around then the value of the line will change by respectively For instance if the second person turns around they see people before and person after so the value of the line changes by if they turn around Now note that if a person turns around it doesn t affect anyone else s value So the solution is a greedy one let s sort the array of values in increasing order Afterwards we should go from the left to the right and see if the value will increase if this person turns around if it does we should add it to the current total and continue The time complexity of this solution is per testcase 
706,Polycarp owns a shop in the capital of Berland Recently the criminal activity in the capital increased so Polycarp is thinking about establishing some better security in the storehouse of his shop The storehouse can be represented as a matrix with rows and columns Each element of the matrix is either an empty space or a wall Polycarp wants to hire some guards possibly zero to watch for the storehouse Each guard will be in some cell of matrix and will protect every cell to the right of his own cell and every cell to the bottom of his own cell until the nearest wall More formally if the guard is standing in the cell then he protects cell if all these conditions are met is an empty cell either and or and there are no walls between cells and Guards can be placed only in empty cells and can protect only empty cells The of placing the guards is some set of cells where guards will be placed of course two plans are different if there exists at least one cell that is included in the first plan but not included in the second plan or vice versa Polycarp calls a plan if there is empty cell that is not protected Polycarp wants to know the number of suitable plans Since it can be very large you have to output it modulo ,This problem can be solved using dynamic programming with broken profile First of all we have to make the number of rows not larger than if it is larger then we can just rotate the given matrix Let s fill the matrix from left to right and in each column from top to bottom Let be the number of ways to achieve the following situation we now want to fill cell with index denotes the rows which are already protected in this column so there is a wall in this row or there is a guard to the left is a flag that denotes if current cell is protected by some guard above and is a flag that denotes if there was a cell that was not protected When advancing from one column to another we have to change the mask so we update the rows that are currently protected The rows such that in the previous column there was a wall in this row become un protected and the rows such that there is a wall in current column in this row become protected And of course becomes zero When we place a guard we set to one and make the corresponding row protected And when we are at the wall we have to set to zero so the guard from above doesn t protect next cell The answer is the sum of all values ,The problem is about counting the number of some combinatoric objects Thus dynamic programming is always the answer Let be the number of bicolorings of the first columns such that components are already created and can t be modified and the colors of the th column are determined by its first bit is the color of the lower cell and its second bit the color of the upper cell Component can be modified if the cell from the th column belongs to it The initial states are for each and for any other state You should iterate over the possible for the next column and recalculate the number of components You can easily show that the current number of components and the last column is actually enough to get the new number of components In my code I have some function to determine the added number of components while transitioning from to These are just the couple of cases to handle carefully Then all the transitions are However the last column won t contain the answer as it is the number of components will be incorrect Let s add some dummy column equal to for each This will add all the real component to the total number So the answer is the sum of over all Overall complexity where is the number of rows 2 for this problem 
707,You are given three multisets of pairs of colored sticks pairs of red sticks the first pair has length the second pair has length the th pair has length pairs of green sticks the first pair has length the second pair has length the th pair has length pairs of blue sticks the first pair has length the second pair has length the th pair has length You are constructing rectangles from these pairs of sticks with the following process take a pair of sticks of one color take a pair of sticks of another color different from the first one add the area of the resulting rectangle to the total area Thus you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color Each pair of sticks can be used at most once some pairs can be left unused You are not allowed to split a pair into independent sticks What is the maximum area you can achieve ,Let s build some rectangles and take a look at the resulting pairings For example consider only red green rectangles Let the rectangles be Sort them in a non decreasing order of I claim that in the most optimal set are also sorted in a non decreasing order It s easy to prove with some induction Moreover if there are some green or red sticks that are not taken and that are longer than the smallest taken corresponding sticks then it s always optimal to take those instead These facts helps us to conclude that from each set only some suffix of the largest sticks are taken And they also give us the idea of the solution sort the sticks in each set and pick the largest from any of the two sets into a pair until no pairs can be taken However the greedy approach of take from any two of the three sets is incorrect We need to choose these two sets smartly Let store the maximum total area that can be obtained by taking largest red sticks largest green sticks and largest blue sticks Each transition chooses a pair of colors and takes the next pairs in both of them The answer is the maximum value in all the Overall complexity ,The main idea of this problem is to use a technique similar to contribution to the sum We will model the value of as the number of tuples where each element is an index of a bag from which we have taken an odd ball Let be the number of ways to take balls from bags so that all elements from tuple are indices of bags with odd balls then the answer to the problem can be calculated as the sum of over all possible tuples First of all let s obtain a solution in per test case We need to answer the following questions while designing a solution to the problem How do we calculate for a given tuple How do we group tuples and iterate through them The first question is not that difficult Every element from the tuple should be an index of a bag from which we have taken an odd ball so for every bag appearing in the tuple we can take only a ball with odd number but for every bag not appearing in the tuple we can choose any ball So if the number of elements in a tuple is then for the tuple can be calculated as This actually gives as a hint for the answer to the second question since depends on the number of distinct elements in the tuple let s try to group the tuples according to the number of distinct elements in them So the answer will be calculated as where is the number of tuples with exactly different elements How do we calculate First of all if then is obviously Otherwise we can use the following recurrence let be the number of tuples of elements with distinct ones then if and for a tuple with one element there are ways to choose it if and if and there is only one distinct element and it was already chosen if and we either add an element which did not belong to the tuple and there are ways to choose it or we add an already existing element and there are ways to choose it Obviously this recurrence can be calculated in with dynamic programming so we get a solution in per test case How do we speed this up Let s change the way we calculate Instead of considering tuples with values from to we will consider only tuples where values are from to and the first appearance of a value is only after the first appearance of the value So these tuples actually represent a way to split a set of integers into several subsets so they are the Stirling numbers of the second kind and we can calculate them in with dynamic programming outside of processing the test cases How do we calculate using these values If we use distinct integers as the elements of the tuple there are ways to choose the first one ways to choose the second one etc so where is the Stirling number of the second kind for the parameters and We can maintain the values of and while iterating on from to and that gives us a way to solve the problem in per test case Overall complexity for precalculation and per test case 
708,Polycarp was given an array of of integers He can perform the following operation with the array no more than times Polycarp selects the index and adds the value to of its neighbors More formally Polycarp adds the value of to or to if such a neighbor does not exist then it is impossible to add to it After adding it Polycarp removes the th element from the array During this step the length of is decreased by The two items above together denote one single operation For example if Polycarp has an array then it can perform the following sequence of operations with it Polycarp selects and adds the value to th element Polycarp selects and adds the value to th element Polycarp selects and adds the value to th element Polycarp selects and adds the value to th element Note that Polycarp could stop performing operations at any time Polycarp wondered how many minimum operations he would need to perform to make all the elements of equal i e he wants all are equal to each other ,Let k be the number of operations performed by Polycarp Let s see how to check if k is the answer Let s denote by s the sum of numbers in the array a Note that after each operation s does not change Since we know that after k operations all elements must be the same and the sum of the numbers in the array does not change then each of the remaining elements must be equal to frac s n k Let s check if it is possible to perform k operations so that at the end all elements are equal to frac s n k Note that the process described in the condition is equivalent to the following process Choose a set of n k 1 indices i 1 i 2 dots i n k 1 1 i 1 i 2 dots i n k i n k 1 n 1 partitions Create a new array b of n k elements where b j sum limits t i j i j 1 1 b t For example the array a of 8 elements after 4 operations could turn into an array b a 1 a 2 a 3 a 4 a 5 a 6 a 7 a 8 In this case the set of indices is i 1 5 6 8 9 Then to check if k is the answer it is necessary to split the a array into n k subarrays in which the sum of all elements is equal to frac s n k Such a check can be implemented greedily in mathcal O n It is enough to go through the array from left to right and take an element into the current subarray until the sum in it exceeds frac s n k The resulting solution works in mathcal O n cdot sigma s or mathcal O n 2 where sigma s is the number of divisors s ,Let s write our unique function Keep the array of the taken elements Iterate over all elements in the array and if the current element is not used then add its index to the answer and set When finished check the number of distinct values that is the size of answer array If it is less than print Otherwise print and output the first elements of the answer 
709,There is a sheet of paper that can be represented with a grid of size rows and columns of cells All cells are colored in white initially operations have been applied to the sheet The th of them can be described as follows choose one of non white colors and color the entire row and the entire column in it The new color is applied to each cell regardless of whether the cell was colored before the operation The sheet after applying all operations is called a coloring Two colorings are different if there exists at least one cell that is colored in different colors How many different colorings are there Print the number modulo ,Let s take a look at a final coloring Each cell has some color There exist cells such that there were no operation in their row and their column They are left white and they don t affect the answer All other cells are colored in one of colors For each cell there is a query that has been the last one to color this cell it covered row column or both of them So all cells that have the same query as the last one will have the same color Since the color for each query is chosen independently the number of colorings will be to the power of the number of queries that have at least one cell belong to them How to determine if a query has at least one cell This is true unless one of these things happen afterwards both its row and its column are recolored all rows are recolored all columns are recolored So the solution is to process the queries backwards Maintain the set of colored rows and colored columns For each query check the conditions If none hold multiply the answer by Overall complexity or per testcase ,Let s maintain an array of size where will be equal to the number of switches that are connected to the th lamp Then answer will be if and only if there exists some switch such that for each lamp that is connected to this switch Otherwise the answer will be 
710,Polycarp studies in Berland State University Soon he will have to take his exam He has to pass exactly exams For the each exam there are known two days day of the first opportunity to pass the exam day of the second opportunity to pass the exam Polycarp during each day For each exam Polycarp chooses by himself which day he will pass this exam He has to pass all the exams Polycarp wants to pass all the exams as soon as possible Print the minimum index of day by which Polycarp can pass all the exams or print if he cannot pass all the exams at all ,This problem has many approaches as Hall s theorem Kuhn algorithm and so on I will explain one or two of them Let s find the answer using binary search It is obvious that if we can pass all the exams in days we can also pass them in days For the fixed last day let s do the following thing firstly if there exists some exam with the day of the first opportunity to pass it greater than then the answer for the day is false Next while there exist exams having only one possibility to pass them because of the upper bound of the maximum possible day or constraints imposed by the other exams we choose this day for this exam and continue after choosing such day there can appear some new exams with the same property Now there are no exams having only one day to pass them Let s take a look on the graph where vertices represent days and edges represent exams the edge between some vertices and exists iff there is an exam with the first day to pass it equal to and the second day to pass it equal to Let s remove all the exams for which we identified the answer Now let s take a look on the connected components of this graph and analyze the problem which we have now Our problem is to choose exactly one vertex incident to each edge of the connected component such that no vertex is chosen twice and we have to do this for all the connected components we have Let be the number of vertices in the current connected component and be the number of edges in the current connected component The answer for the connected component is true iff for obvious reasons There is very easy constructive method to see how we can do this If then the current connected component is a tree Let s remove some leaf of this tree and set it as the chosen vertex for the edge incident to this leaf and remove this edge too If then let s remove all leaves as in the algorithm for the tree For the remaining cycle let s choose any edge and any vertex incident to it set this vertex as the chosen to this edge and remove them Now we have a chain Chain is a tree so let s apply the algorithm for the tree to this chain So if for some connected component holds then the answer for the day is false Otherwise the answer is true Overall complexity because of numbers compressing or using logarithmic data structures to maintain the graph Also there is another solution which can be too slow I don t know why it works It is well known fact that if we will apply Kuhn algorithm to the some bipartite graph in order of increasing indices of vertices of the left part then the last vertex in the left part of this graph which is in the matching will be minimum possible Oh that s what we need Let the left part of this graph consist of days and the right part consist of exams The edge between some vertices from the left part and from the right part exists iff is one of two days to pass the exam Let s apply Kuhn algorithm to this graph considering days in increasing order The first day when matching becomes all exams are in the matching will be the answer I don t know its complexity really Maybe it works too fast because of the special properties of the graph If someone can explain in which time it works I will very happy ,Let s found two athletes with numbers and the strength of is not greater than the strength of which have the minimal modulus of the difference of their strength Obviously we cannot get an answer less than this Let s show how to get the partition with exactly this answer Sort all athletes by strength Our two athletes will stand in neighboring positions otherwise we can decrease the answer Let the first team contains all athletes who stand on positions not further than and the second team contains other athletes We got a partition in which the athlete with number has the maximal strength in the first team and the athlete with number has the minimal strength in the second team 
711,Let s call a string if it is symmetric about the middle of the string For example the string is but the string is not The string is not because the second half of it is not a mirror reflection of the first half You are given a string Check if the string is ,In this problem you should simply find the symmetric letters by picture and also observe that the pairs and is the symmteric reflections ,There are multiple solutions involving advanced methods such as binary search or two pointers but I ll try to describe a simpler one The main idea of my solution is that the answer should look like one character of type a block of characters of type and one character of type If we find all blocks of consecutive equal characters in our string each candidate for the answer can be obtained by expanding a block to the left and to the right by exactly one character So the total length of all candidates is and we can check them all Why does the answer look like If the first character of the substring appears somewhere else in it it can be deleted The same applies for the last character So the first and the last characters should be different and should not appear anywhere else within the string Since there are only three types of characters the answer always looks like 
712,Polycarp lives on a coordinate line at the point He goes to his friend that lives at the point Polycarp can move only from left to right he can pass one unit of length each second Now it s raining so some segments of his way are in the rain Formally it s raining on non intersecting segments the th segment which is in the rain is represented as There are umbrellas lying on the line the th umbrella is located at point and has weight When Polycarp begins his journey he doesn t have any umbrellas During his journey from to Polycarp can pick up and throw away umbrellas Polycarp picks up and throws down any umbrella instantly He can carry any number of umbrellas at any moment of time Because Polycarp doesn t want to get wet he must carry at least one umbrella while he moves from to if a segment is in the rain i e if there exists some such that and The condition above is the only requirement For example it is possible to go without any umbrellas to a point where some rain segment starts pick up an umbrella at this point and move along with an umbrella Polycarp can swap umbrellas while he is in the rain Each unit of length passed increases Polycarp s fatigue by the sum of the weights of umbrellas he carries while moving Can Polycarp make his way from point to point If yes find the minimum total fatigue after reaching if Polycarp picks up and throws away umbrellas optimally ,Any experienced contestant can easily guess that the problem can be solved with dynamic programming Coordinates are not really large so you can precalculate the array where is a boolean value if there exists some segment of rain to cover the segment between positions and and otherwise This can be done in with the most straightforward algorithm You can also precalculate another array where is the index of the umbrella of minimal weight at position or if there is no such umbrella Now let be the minimal total fatigue you can take if you are holding umbrella number on the end of the walk up to position If then you hold no umbrella Initially all the values are and is You can either hold your umbrella drop it or pick up the best one lying there and drop the current one if any when going from some position to So here are the transitions for these cases if if if The answer is equal to If it is then there is no answer So you have states and all the transitions are Overall complexity There is also a solution in with Convex Hull Trick using Li Chao tree You can probably even achieve with some coordinate compression Obviously this wasn t required for the problem as the constraints are small enough ,This is a typical problem on the technique The number of moves we will made equals So if would be small enough 25 is the upper bound I think then we can just run recursive backtracking in or in to iterate over all binary masks of lengths containing exactly ones and check each path described by such mask in this mask is the move to the bottom and is the move to the right if its is But it is too slow So let s split this mask of bits into two parts the left part will consist of bits and the right part will consist of bits Note that each left mask and each right mask too uniquely describes the endpoint of the path and the path itself Let s carry associative arrays where for the endpoint and will denote the number of paths which end in the cell having Let s run recursive backtracking which will iterate over paths starting from the cell and move to the right or to the bottom and maintain of the path If we made moves and we are currently in the cell with right now set and return from the function Otherwise try to move to the bottom or to the right changing as needed Let s run another recursive backtracking which will iterate over paths starting from the cell and move to the left or to the top and maintain of the path except the last cell The same if we made moves and we are currently in the cell with right now let s add to the answer obvious that way we complement our from the right part of the path with the suitable from the left part of the path Otherwise try to move to the left or to the top changing as needed So this is the technique at least the way I code it Overall complexity is 
713,You are given a rooted tree Each vertex contains tons of gold which costs per one ton Initially the tree consists only a root numbered with tons of gold and price per ton There are queries Each query has one of two types Add vertex where is an index of query as a son to some vertex vertex will have tons of gold with per ton It s guaranteed that For a given vertex consider the simple path from to the root We need to purchase tons of gold from vertices on this path spending the minimum amount of money If there isn t enough gold on the path If we buy tons of gold in some vertex the remaining amount of gold in it decreases by of course we can t buy more gold that vertex has at the moment For each query of the second type calculate the resulting amount of gold we bought and the amount of money we should spend Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query so don t forget to flush output after printing answers You can use functions like in and in or similar after each writing in your program In standard if you don t tweak I O flushes in and in or in makes automatic flush as well ,Note that for each vertex So if we consider a path from some vertex to the closer you are to the cheaper the cost In other words it s always optimal to choose the highest vertex on the path with Suppose we can find such vertex for a given How many times we will repeat this search operation If we need to buy tons and has tons then it s optimal to buy tons in After we buy tons either becomes or becomes Since for each vertex can become equal to zero at most once and since after is zero we stop buying then there will be searches in total The next question is how to find efficiently for a given Consider the path from to some vertex Since we prefer to buy from higher vertices all empty vertices on this path will form some prefix of it possibly empty prefix So we can make some sort of binary search to find the first non empty vertex But instead of binary search we will use binary lifting technique If we know for each which vertex on the path from to on distance from then we can efficiently jump up the path Let s firstly jump at distance if then we jump too high let s not jump But if then we can safely jump or Now we know that we don t need a second jump so we try jump and so on In other words using binary lifting we can find the highest vertex with in steps Also we can calculate array for vertex right after we add vertex to the tree since and The resulting complexity is ,If we would naively solve the problem we would just try to replace each edge s cost with zero and run Dijkstra algorithm times to get the cheapest paths But this is too slow Let s try to replace each edge s cost with zero anyway but use some precalculations to improve the speed of the solution Let s firstly run Dijkstra times to calculate all cheapest pairwise paths Then let s fix which edge we remove There are three cases for the path this edge was not on the cheapest path before removing and is not on the cheapest path after removing Then the cost of this path is The second case is when this edge was not on the cheapest path before removing but it is on the cheapest path after removing Then the cost of this path is So we are just going from to using the cheapest path then going through the zero edge and then going from to using the cheapest path also or vice versa from to and from to And the third case is when this edge was already on the cheapest path between and but this case is essentially the same as the second one So if we fix the edge then the answer for this edge is Taking the minimum over all edges we will get the answer The precalculating part works in and the second part works in 
714,A tuple of positive integers is called simple if for all pairs of positive integers is a prime You are given an array with positive integers not necessary distinct You want to find a simple subset of the array with the maximum size A prime number or a prime is a natural number greater than that has no positive divisors other than and itself Let s define a subset of the array as a tuple that can be obtained from by removing some possibly all elements of it ,Consider the subset that is the answer to the problem Let be the arbitrary three elements from and let no more than one of them is equal to By the pigeonhole principle two of three elements from have the same parity So we have two integers with even sum and only one of them is equal to so their sum is also greater than So the subset is not simple In this way consists of only two numbers greater than one with a prime sum or consists of some number of ones and also maybe other value so that is a prime We can simply process the first case in time The second case can be processed in linear time Also we should choose the best answer from that two To check the value of order for primality in time we can use the simple or the linear Eratosthenes sieve ,Let s calculate for each number how many times it occurs in the array Let s denote this number as Let s use the dynamic programming method Let be equal to the maximum number of numbers not greater than such that for each pair of them one of the conditions above is satisfied More formally if then there exists numbers from the array such that for all one of the conditions above is satisfied Then to calculate you can use the following formula Note that to calculate you need to go through the list of divisors of For this we use the sieve of Eratosthenes 
715,You are given a set of points on the number line Two points and can be matched with each other if the following conditions hold neither nor is matched with any other point What is the maximum number of pairs of points you can match with each other ,Let s denote the points that have greater coordinates in their matched pairs as points and the points that have smaller coordinates as points Suppose we have an point that has smaller coordinate than some point Then we can swap them and the answer won t become worse Also if some point has smaller coordinate than some point that doesn t belong to any pair or some point has greater coordinate than some point that doesn t belong to any pair we can swap them too So if the answer is we choose leftmost points as points and rightmost ones as points For a fixed value of it s easy to see that we should match the leftmost point with the leftmost point the second point with the second point and so on in order to maximize the minimum distance in a pair This fact allows us to check whether it is possible to construct at least pairs and we can use binary search to compute the answer to the problem ,First let s understand that if we choose some subset of points then it does not matter to which point we move it inside the segment because the minimum number of moves will always be the same and it is equal to Okay we need to split all points into two subsets and collect all points of the first subset in some point inside it and the same with the second subset What can we notice If we sort the points it s always optimal to choose these subsets as segments I e if the maximum point of the first subset is the minimum point of the second subset is and we can swap them and decrease answers for both subsets So we need to cover all the points with two segments with the minimum total length What is this length It is is the maximum distance between two consecutive points i e So we can solve the problem in without queries But how to deal with queries Let s maintain the set which contains all points and the multiset set with repetitions that maintains all gaps between two adjacent points So the answer is maximum in the set of points minus minimum in the set of points minus maximum in the multiset of lengths How do we recalculate these sets between queries If some point is removed let s find the maximum point less than let it be and the minimum point greater than let it be in the current set of points Both these points can be found in a logarithmic time Then we need to remove with from the multiset and add to the multiset and of course remove from the set If some point is added then we need to remove from the multiset and add with to the multiset and add to the set So we can process every query in time and the total time complexity is 
716,You are given a sequence initially consisting of integers You want to transform this sequence so that all elements in it i e it contains several occurrences of the same element To achieve this you choose some integer and then perform the following operation any number of times possibly zero choose some segment of the sequence and remove it But there is one exception More formally you choose some contiguous subsequence such that if and remove it After removal the numbering of elements to the right of the removed segment changes the element that was the th is now th the element that was th is now th and so on i e the remaining sequence just collapses Note that you after you chose it For example suppose Then one of the ways to transform it in two operations is to choose then choose so the resulting sequence is choose so the resulting sequence is Note that choosing is not an operation Also note that you remove any occurrence of Your task is to find the number of operations required to transform the sequence in a way described above You have to answer independent test cases ,Firstly let s remove all consecutive equal elements just keep one occurrence of each such element For example the array 1 1 2 3 3 3 2 becomes 1 2 3 2 Now the answer for each a i is the number of its occurrences plus one Why is it so Because we need to remove all segments of elements between every pair of consecutive occurrences of a i The number of such segments is the number of occurrences of a i minus one There is also a segment before the first occurrence of a i and a segment after the last occurrence of a i But the first segment doesn t exist for the first element and the last segment doesn t exist for the last element So after removing consecutive elements let s calculate for each a i the number of its occurrences plus one subtract one from the value of the first element and from the value of the last element Then the answer is the minimum among these values for all a i ,Let s reformulate this problem in next form we can sort only subarray of length 2 swap two consecutive elements and if It is simular tasks because we can sort any array by sorting subbarray of length 2 for example bubble sort does exactly that Now lets look at elements and If then we will solve this task for arrays and Otherwise lets look at minimum position such that if there is no such position then answer to the problem is We can move element to the beginning of array only if all elements greater then In other words any index such that must be greater then And if this condition holds then we just delete element and solve task for arrays and But instead of deleting this element we will change information about minimum index such that This index will be the minimum index such that and For do this we will maintain stacks such that for any element of stack condition holds and moreover all elements in stacks are sorted in ascending order the top element of stack is minimal For example if then For finding minimum element on top of stacks we can use some data structure for example segment tree 
717,You are given an array of integers A is a sequence of contiguous consecutive elements Thus a block is defined by a pair of indices Find a set of blocks such that They do not intersect i e they are disjoint Formally for each pair of blocks and where either or For each block the sum of its elements is the same Formally The number of the blocks in the set is maximum Formally there does not exist a set of blocks satisfying the above two requirements with Write a program to find such a set of blocks ,Let s the same sum of blocks in the answer Obviously can be represented as a sum of some adjacent elements of i e for some and Iterate over all possible blocks in and for each sum store all the blocks You can use map int vector pair int int to store blocks grouped by a sum You can do it with the following code map int vector pair int int segs for int r 0 r n r int sum 0 for int l r l 0 l sum a l segs sum push back l r Note that blocks are sorted by the right end in each group After it you can independently try each group there are of them and find the maximal disjoint set of blocks of a group You can do it greedily each time taking into the answer segment with the smallest right end Since in each group they are ordered by the right end you can find the required maximal disjoint block set with one pass Let s assume is the current group of blocks they are ordered by the right end then the following code constructs the maximal disjoint set int cur 0 int r 1 vector pair int int now for auto seg pp if seg first r cur now push back seg r seg second Choose the maximum among maximal disjoint sets for the groups ,Alice wants to choose such a segment that is maximum possible There is a well known problem where you have to find a segment with maximum That problem is solved with Kadane algorithm Let s learn how to reduce our problem to that one Notice that the values in the array are unusually small Let s iterate over the maximum value on segment Let be the current value If we make all such that equal to then it will never be optimal to take them in a segment Find the maximum sum subarray in that modified array and update the answer with its Notice that you can ignore the fact if there is a value exactly equal to on the maximum sum segment If there isn t then you ll update the answer with a smaller value than the actual one Let the actual maximum on the maximum sum segment be some You can see that for any value between and the maximum sum segment will always be that chosen one Thus when you reach you ll update the answer with the correct value Overall complexity 
718,You had positive integers arranged For each pair of neighboring numbers and and and and and you wrote down are the numbers in the pair equal or not Unfortunately you ve lost a piece of paper with the array Moreover you are afraid that even information about equality of neighboring elements may be inconsistent So you are wondering is there any array which is consistent with information you have about equality or non equality of corresponding pairs ,Let s look at a group of it s easy to see that each such a group is equal to the same number Now let s look at how these groups are distributed on the circle If there are no then all are just equal to each other It s okay If there is exactly one then from one side all of them are still in one group so they should be equal but from the other side one pair should have different values It s contradiction If there are more than one then all numbers are divided in several groups with different values It s okay As a result array exists as long as the number of isn t ,Let s see which remainders modulo change into which ones If the array contains a number divisible by then it cannot be changed If there is a number that has a remainder of modulo then it can only be replaced once Thus if the array contains a number divisible by then we apply this operation to all elements of the array once and check that all its elements are equal The remaining odd balances immediately turn into even ones The even remainders change in a cycle while the array element increases by in operations Thus we will apply the operation to each element of the array until its remainder modulo becomes for example and then check that the array does not contain both remainders and modulo 
719,There are kids numbered from to dancing in a circle around the Christmas tree Let s enumerate them in a clockwise direction as all these numbers are from to and are distinct so is a permutation Let the next kid for a kid be kid if and otherwise After the dance each kid remembered two kids the next kid let s call him and the next kid for Each kid told you which kids he she remembered the kid remembered kids and However the order of and can differ from their order in the circle You have to restore the order of the kids in the circle using this information If there are several answers you may print any It is guaranteed that at least one solution exists ,Let s write a function which will try to restore the circle if kid with number comes right after kid with number If comes right after then we can determine the number of kid who is next to kid So now we have comes right after comes right after Let s determine kid who is next to kid If we repeat this operation times then we can the answer if comes right after But it can be wrong so we have to check that our answer corresponds to the input So if we have this function we can apply it two times to determine the correct answer Just call and ,Let s start moving from an arbitrary cell of the table for example from Movement from each cell is specified by the direction given in that cell so you can run a loop with a stopping condition exit from the board border or get to the already visited cell Create a separate array how many commands the robot will execute starting the movement from the cell we will also use it to check whether the cell has already been visited or not not visited if is not yet positive Finishing the movement from let s consider two cases Either we have gone beyond the boundary of the array then we can say for sure that for the th cell from the end of the sequence the answer is Or we came to the already visited cell let it be the th from the end in our path Then at the end of the path there is a cycle of length starting the movement at any cell of this cycle the robot will walk exactly steps until it arrives at the already visited cell Thus for distance will be equal to and for all others it will be as in the first case Let us run the same algorithm from the next cell which we have not yet considered There will be three cases of robot stopping the execution of the commands the first two repeat those already considered above and the third case is that the robot will come to the cell already visited on some of the previous iterations of our algorithm In this case we know that starting from the robot will make exactly steps so for the th cell from the end on the current path will hold The first two cases are handled completely in the same way as described above Each of the cases is eventually reduced to another iteration over the cells visited in the current path Let s visit all the cells in reverse and mark all values of Such algorithm is enough to repeat until each cell is processed after which for each cell of the table its will be known and we ll only have to choose the maximal value of among all 
720,You are given an array consisting of integers Beauty of array is the maximum sum of some of this array this subarray may be empty For example the beauty of the array is and the beauty of the array is You may choose of and multiply all values contained in this subarray by You want to maximize the beauty of array after applying at most one such operation ,The first intuitive guess one s probably made is multiplying the segment of maximum sum for positive That thing is correct Unfortunately there is no similar strategy for non positive simple greedy won t work there Thus dynamic programming is our new friend Let s introduce the following state where is the length of the currently processed prefix is the state of maximum sum segment is not reached it ll appear later is open current elements are added to it is passed the segment appeared earlier and is the state of segment multiplied by with the same values This will store the maximum segment sum we can achieve The only base state is the prefix of length is processed and both segments are not open yet The rest of values in are There are two main transitions At any moment we can change the state of each segment to the next one without moving to the next position From state not reached we can go to state opened and from state we can go to state passed Note that this easily covers the case where optimal segment is empty We can also move to the next position updating the value of with correspondance to the current states of segments The answer will be stored in the state where all the array is processed and both segments are closed Overall complexity ,Let s fix the length of the first block iterate through i from 0 to n 3 Let s also try to maximize the length of the third block using the second pointer So initially the length of the first block is 1 and the maximum in the block is a 0 after that its length will be 2 and the maximum will be max a 0 a 1 and so on Let s move the left border of the third block r while a r le a 0 and the second block have at least one element After we expanded the third block consider some cases if its maximum is less than a 0 then we don t need to consider this partition we expanded the third block as much as we can but didn t find the required maximum Otherwise its maximum fits our conditions Then let s find the minimum in the second block Let it be mn If mn mx this partition is also bad If mn mx this partition is good and we can just print it Otherwise mn mx and we need to fix the second block somehow I claim that we only need to expand it by at most one element Let s see why is it true Consider we want to expand it to the right the other case just uses the same logic If we expanded our block by one element to the right and the new value in it is less than mx then this partition is bad and we can not use it this is also the reason why we are trying to maximize the length of the third block Otherwise this value is always mx because the first and the third blocks didn t have values greater than mx There are some cases in the implementation we need to consider carefully first we need to find the minimum in the second block fast enough This can be done if we store it as a multiset set with repetitions Second we can remove the only maximum in the third or the first block by expanding the second one This can be handled easily if we just store all three blocks not only the second one as multisets And the last case is that we sometimes need to move the left border of the third block to the right This happens when we expand the first block and the second block becomes empty So this happens only O n times in total Total time complexity of this solution is O n log n There is also another solution from Gassa Let us start solving by asking the following question in which segments will the maximal values end up Consider the maximum value m in the whole array If there are at least three of them a valid answer is to pick any maximum except the first and the last as the middle segment For example m 3 can be partitioned as or as where the middle segment is marked with square brackets Otherwise all m should end up in the middle segment so that maximums to the left and to the right are less For example in we have to put both threes into the middle segment Let us now calculate the minimum value v on the middle segment considering the numbers between those equal to m For example in the value v min 3 1 3 1 All numbers greater than v should also go into the middle segment and everything between them which can result in v decreasing even more We have to expand the borders of the middle segment until the minimum value is such v that there are only values not greater than v left outside Continuing with the example we see that in the middle segment should be expanded to Conversely if the maximum m was unique then v m and we didn t have to expand the middle segment at this stage For example in the current state is If the maximums to the left and to the right are exactly v we found an answer Otherwise any possible middle segment contains the middle segment that we now got So we have to expand the middle segment either to the left or to the right As a result the value v may become smaller which can cause another expansion What s left is to decide where to expand when we have a choice We would like to do it greedily Indeed consider three values the minimum on middle segment v the maximum on left segment u and the maximum on right segment w When we expand the middle segment each of them can only decrease And if we find an answer the equation u v w will be satisfied So as we make the minimum of these three values smaller we have less and less opportunities to make them equal Thus we can pick the side of expansion after which the value min u v w is larger and if these are equal pick any For example in the state we have u 3 v 4 and w 3 If we expand to the left we get where u 1 v 3 and w 3 If we expand to the right we get where u 3 v 2 and w 3 Our algorithm will pick expanding to the right however there is no valid answer in this example anyway Implementation let us precalculate the maximums on all prefixes and all suffixes of the array Then we can expand the middle segment by one element in O 1 and the total running time is linear 
721,Given an array of positive integers you can do operations of two types on it Add to element with an index In other words change the array as follows Add to element with an index In other words change the array as follows Determine if after any number of operations it is possible to make the final array contain only even numbers or only odd numbers In other words determine if you can make all elements of the array have the same parity after any number of operations Note that you can do operations of both types any number of times even none Operations of different types can be performed a different number of times ,Note is that after doing two operations of the same type they are cancelled out in terms of parity since we would change the parity of all elements once then change it back again So we know that we will do each operation exactly or time It is possible to check all possible cases just by simulating or we can notice that all elements on all indices of the same parity have the same parity and if they do we can always find an answer by doing just a single type of operation a single time in case the array doesn t already contain all elements of the same parity The time complexity is ,After some simulation of the given algorithm in your head on paper or on a computer we can realize that exactly all odd numbers are erased So all even numbers remain and the answer is 
722,You are given a string Each character is either or You want all s in the string to form a contiguous subsegment For example if the string is or then all s form a contiguous subsegment and if the string is or then this condition is not met You may erase some possibly none s from the string What is the minimum number of s that you have to erase ,Let s find the first and the last position of characters denote them as and respectively Since the can t delete characters all characters between and will remain So we have to delete all characters between and ,Instead of counting the number of good substrings let s count the number of bad substrings then number of good substrings is equal to Let s call a character in string is bad if there is no such palindrome that Any character in substring is good It can be proven as follows If or then belong to a palindrome of length If and then belong to a palindrome So only characters and can be bad But at the same time character is bad if there is no character such that and It is true because substring is palindrome index is minimum index such that So there are only patterns of bad strings All that remains is to count the number of substrings of this kind 
723,The King of Berland Polycarp LXXXIV has daughters To establish his power to the neighbouring kingdoms he wants to marry his daughters to the princes of these kingdoms As a lucky coincidence there are other kingdoms as well So Polycarp LXXXIV has enumerated his daughters from to and the kingdoms from to For each daughter he has compiled a list of kingdoms princes of which she wanted to marry Polycarp LXXXIV is very busy so he finds a couple for his daughters greedily one after another For the first daughter he takes and marries the daughter to their prince For the second daughter he takes If there are no free princes in the list then the daughter marries nobody and Polycarp LXXXIV proceeds to the next daughter The process ends after the th daughter For example let there be daughters and kingdoms the lists daughters have are respectively In that case daughter marries the prince of kingdom daughter marries the prince of kingdom daughter marries the prince of kingdom leaving daughter nobody to marry to Actually before starting the marriage process Polycarp LXXXIV has the time to convince one of his daughters that some prince is also worth marrying to Effectively that means that he can add exactly one kingdom to exactly one of his daughter s list Polycarp LXXXIV wants to increase the number of married couples Unfortunately what he doesn t have the time for is determining what entry to add If there is no way to increase the total number of married couples then output that the marriages are already optimal Otherwise find such an entry that the total number of married couples increases if Polycarp LXXXIV adds it If there are multiple ways to add an entry so that the total number of married couples increases then print any of them For your and our convenience you are asked to answer independent test cases ,Simulate the process without adding the new entry For this you can just maintain an array th value of which is true if the th prince is married and false otherwise Now observe that there are two possible outcomes Every daughter is married the answer is optimal There is a daughter who isn t married That means that there is a free prince as well Marry them to each other because doing that won t affect any other marriages and add a new one to the answer Overall complexity ,To solve it it should be noted that despite the way the deck with bonuses works the order in which they will be applied is not important Then when we meet the hero card we just need to add to the answer the maximum of the available bonuses Constraints make you use structures such as a priority queue to quickly find and extract the maximum 
724,You are given a string of length consisting of characters and or Let be the number of occurrences of string in as a Analogically is the number of occurrences of in as a In one step you can choose any index and replace with character or What is the minimum number of steps you need to make to achieve The number of occurrences of string in as substring is the number of indices such that substring is equal to For example since there are two indices where and where ,Let s look at the first and the last characters of Note that if where then is always equal to It can be proved for example by induction if consists of equal characters then if has a structure like or then Otherwise there is at least one character in the middle that equal to and So we can split string in and Both these string has by induction so our string also has As a result if then the answer is and we print the string untouched Otherwise we replace either or and get the desired string It also can be proved that if then ,We could iterate on the substrings we want to shuffle and try to count the number of ways to reorder their characters but unfortunately there s no easy way to take care of the fact that shuffling different substrings may yield the same result Instead we will iterate on the first and the last character that are changed Let these characters be and First of all let s check that they can belong to the same substring we can shuffle it is the case if the string contains at least characters and the substring from the th character to the th character contains at most characters Then after we ve fixed the first and the last characters that are changed we have to calculate the number of ways to shuffle the characters between them including them so that both of these characters are changed Let s calculate and the number of characters and respectively in the substring Then we need to modify these two values for example if the th character is then since it is the first changed character it should become so we need to put there and decrease by one The same for the th character Let and be the values of and after we take care of the fact that the th and the th character are fixed The remaining characters can be in any order so the number of ways to arrang them is We can add up these values for all pairs such that we can shuffle a substring containing these two characters We won t be counting any string twice because we ensure that is the first changed character and is the last changed character Don t forget to add to the answer the string we didn t count is the original one This solution works in but the problem is solvable in 
725,Given an array consisting of elements find the maximum possible sum the array can have after performing the following operation Choose elements and flip both of their signs In other words choose an index such that and assign and ,We can notice that by performing any number of operations the parity of the count of negative numbers won t ever change Thus if the number of negative numbers is initially even we can make it equal to by performing some operations So for an even count of negative numbers the answer is the sum of the absolute values of all numbers since we can make all of them positive And if the count of negative numbers is odd we must have one negative number at the end We will choose the one smallest by absolute value and keep the rest positive for simplicity we consider as a negative number ,The problem can be divided into two classic ones Count the number of pairs Count the number of pairs Let be the answer to the first problem and be the answer to the second problem Then is the answer to the original problem The new problem can be solved by binary search Iterate over the first element of the pair Then you need to count the number of elements such that If you sort the array this value can be calculated by running a single binary search 
726,You are given a rooted tree It contains vertices which are numbered from to The root is the vertex Each edge has two positive integer values Thus two positive integers and are given for each edge Output numbers where is defined as follows Consider the path from the root vertex to Let the sum of the costs of along this path be Then is equal to the length of the maximum prefix of this path such that the sum of along this prefix does not exceed Consider an example In this case since the path to has an amount of equal to only the prefix of this path of length has a smaller or equal amount of since the path to has an amount of equal to the prefix of length of this path has a sum of equal to the number is since the path to has an amount of equal to the prefix of length of this path has an amount of equal to this is the longest suitable prefix since the prefix of length already has an amount of equal to which is more than since the path to has an amount of equal to the prefix of length of this path has a sum of equal to this is the longest suitable prefix since the prefix of length already has an amount of equal to what is more than since the path up to has an amount of equal to the prefix of length of this path has an amount of equal to since the path to has an amount of equal to the prefix of length of this path has an amount of equal to this is the longest suitable prefix since the prefix of length already has an amount of equal to which is more than since the path up to has an amount of equal to the prefix of length of this path has an amount of equal to since the path to has an amount of equal to the prefix of length of this path has a sum of equal to ,Note that all are positive which means that the amount on the prefix only increases This allows us to use binary search to find the answer for the vertex It remains only to learn how to quickly find the sum of on the path prefix Let s run a depth first search and store the prefix sums of the current path in stack going to the vertex add the sum to the end of the path and delete it when exiting ,Note that so you can make any value equal to by multiplying it by two times since So the answer for each value is at most Now let s note that there is always an optimal answer that consists of at first add one times then multiply by two times and is the minimum answer In other words let s just iterate over all and and check that The answer is minimum among them To prove that it s optimal to add at first and only then to multiply note that it s not optimal to add more than once after muptiplying can be replaced by So there is at most one between two but it s not optimal to make even one since we need to make divisible by and break divisibility There are many other approaches to this task except this one for example since you can write bfs to find the shortest paths from to all 
727,Alice and Bob play a game Initially they have a string consisting of only characters and They take alternating turns and Alice is moving first During each turn the player has to select a contiguous substring consisting only of characters and replaces each of them with Alice must select a substing of length and Bob must select a substring of length It is guaranteed that For example if and then after Alice s move string can turn only into And if it s Bob s turn and the string then after Bob s move the string can turn into or Whoever is unable to make a move loses You have to determine who wins if they both play optimally You have to answer independent queries ,At first let s transform input to a more convenient form We consider only such subsegments that consist of the symbols and which cannot be expanded to the right or left For example for we consider segments of length and Let s divide all such segments into four groups by their length In such a division each segment belongs to exactly one type Suppose that the Bob takes the first turn If there is a segment of second type then Bob wins because he always have a spare turn that Alice cannot make If there is a segment of fourth type then the Bob also wins because he can make the segment of second type by taking turn in this segment of four type If there are no segments of second and four types then victory depends on the parity of the number of segments of the third type But it is true if the Bob takes first turn If Alice takes first turn then she doesn t want after her move there are segments of the second and fourth types So if initially there is a segment of second type then Alice loses because she can t take turns into segment of second type If there are two or more segments of four type then Alice also loses because after her turn at least one such segments remains If there are only one segment of four type then Alice have to take turn into this segment Since the length of this segment doesn t exceed we can iterate over all possible Alice moves After Alice s move segment of fourth type can be divided into no more than two new segments let s denote their types as and If at least one of these segments of second or fourth type then it s bad turn for Alice Otherwise Alice win if remaining number of segment of third type is even note that or also can be the third type And finally if initially there are only segments of first or third type then victory depends on the parity of the number of segments of the third type ,Let s determine for each cell whether it s winning or losing position we can do it since the game is symmetric and doesn t depend on a player The th cell is obviously losing the st and nd ones is both winning since we can move to the th cell and put our opponent in the losing position here comes criterion the position is winning if and only if there is a move to the losing position If is large enough then the th rd th th are losing So here comes divisibility by If then this move doesn t change anything since if then so it s not the move to the losing position so doesn t become the winning one Otherwise if then the th positions becomes winning but the th cell is losing all moves are to th th or st cells and all of them are winning The th and th cells are winning and so on In the end we came up with cycle of length where position divisible by except are losing All we need to do is small case work 
728,You are given an integer You have to find a sequence consisting of digits such that it has exactly subsequences equal to For example sequence has subsequences equal to you can remove the second and fifth characters you can remove the third and fifth characters you can remove the fourth and fifth characters you can remove the second and sixth characters you can remove the third and sixth characters you can remove the fourth and sixth characters You have to answer independent queries ,Let s consider the following string If digit occurs times in it then string have subsequences Let s increase the number of digits in this string while condition holds is the number of digits in this string The length of this string will not exceed because The value will not exceed as well All we have to do is increase the number of subsequences in the current string by So if we add digits after the first two digits we increase the number of subsequences by The string will look like this where sequence consists of exactly digits and sequence consists of exactly digits ,Let s use the greedy solution we will go through the digits in decreasing order If the sum of we need to dial is greater than the current digit we add the current digit to the end of the line with the answer Note that in this way we will always get an answer consisting of the minimum possible number of digits because we are going through the digits in descending order Suppose that the resulting number is not optimal Then some digit can be reduced and some digit that comes after it can be increased in order to save the sum we can not increase the digit before it as then we get a number greater than the current one Two variants are possible We want to increase the digit to but then it becomes equal to the digit following it or exceeds the value Then we can t increment that digit Otherwise in the first step we can get instead of but since we are going through the digits in decreasing order we cannot get the value of in that case Contradiction 
729,You are given two arrays and each contains integers You want to create a new array as follows choose some real i e not necessarily integer number and then for every let Your goal is to maximize the number of zeroes in array What is the largest possible answer if you choose optimally ,For each index let s try to find which we should use in order to make th element of equal to zero If then no matter which we choose So we should just ignore this index and add to the answer if Otherwise we should choose Let s calculate the required fraction for each index and among all fractions find one that fits most indices this can be done for example by storing all fractions in a The only thing that s left to analyze is how to compare the fractions because floating point numbers may be not precise enough Let s store each fraction as a pair of integers where is the numenator and is the denominator We should normalize each fraction as follows firstly we reduce it by finding the greatest common divisor of and and then dividing both numbers by this divisor Secondly we should ensure that numenator is non negative and if numenator is zero then denominator should also be non negative this can be achieved by multiplying both numbers by ,There are two possible solutions in time First of them answers each query using simple iteration changes to for each query until becomes greater than as stated in the problem But it is too slow Second solution precalculates answers for each and if then else But this uses memory and can be done in time Now we can notice that if then second solution will use only time and memory and if then first solution will do not more than operations on each query So we can combine these two solutions Time complexity 
730,You are given an array consisting of positive integers You pick two integer numbers and from to inclusive numbers are picked randomly equiprobably and independently If then you swap values of and You have to calculate the expected value of the number of unique elements in segment of the array from index to index inclusive indexed ,For each index we will find the number of pairs before swapping such that is the first occurence of in the chosen segment Let be previous occurence of before if is the first occurence then if we suppose the array to be indexed Let s find the number of pairs such that and then multiply it by and subtract for this index has to be in segment and has to be in segment so the number of ways to choose this pair is The value we receive as the sum of these values over all segments is the total number of distinct elements over all pairs so we need to divide it by the number of these pairs ,Let s find out how to count the number of binary inversions without flips This is the number of 1 s that appear before a 0 To do this iterate through the array and keep a running total k of the number of 1 s seen so far When we see a 0 increase the total inversion count by k since this 0 makes k inversions one for each of the 1 s before it Now let s see how to maximize the inversions Consider the flip 0 to 1 We claim that it is best to always flip the earliest 0 in the array It s never optimal to flip a later 0 since we have strictly fewer 0 s after it to form inversions Similarly we should flip the latest 1 in the array Now recalculate the answer for these two choices for flipping and pick the maximum The complexity is mathcal O n 
731,Now Vasya is taking an exam in mathematics In order to get a good mark Vasya needs to guess the matrix that the teacher has constructed Vasya knows that the matrix consists of rows and columns For each row he knows the xor bitwise excluding or of the elements in this row The sequence denotes the xor of elements in rows with indices respectively Similarly for each column he knows the xor of the elements in this column The sequence denotes the xor of elements in columns with indices respectively Help Vasya Find a matrix satisfying the given constraints or tell him that there is no suitable matrix ,If then there is no suitable matrix The operation means xor Otherwise we can always construct a suitable matrix by the following method the first element of the first line will be equal to The second element of the first line is the third element is the last one is The first element of the second line will be the first element of the third line is the first element of the last line is The rest of the elements will be zero It is not difficult to verify that the matrix obtained satisfies all the restrictions ,Constraints lead us to some kind of dp solution is it usually called dp on broken profile Let will be the minimum price to get to th column and th row with selected is the previous cells inclusive from if then its exactly current column and two previous ones Transitions for submatrices and are straighforward just update mask with new ones and add to current value If the first cell of these is empty or is set in this position then you can go to or and if for free Finally you can go to with the price of Initial value can be in the first cells of the matrix The answer will be stored in some valid of However you can add extra empty columns and take the answer right from it will be of the same price Overall complexity 
732,You are given an integer array of size You have to perform queries Each query has one of two types calculate the minimum value such that there are exist integers such that for every and for every where is the number of occurrences of in the subarray If it is impossible to choose integers report it assign ,Let s consider a problem without queries of the second type Now we can try to solve the problem using Mo s algorithm Let s maintain array the number of occurrences of on the current segment and array array sorted in descending order Let s take a look at how we should handle adding an element equal to Surely we should increase by but now we should erase an element equal to from the array and insert an element is such a way that the array is still sorted Instead we can increase the leftmost element equal to by Similarly we can handle deleting an element decrease the rightmost element equal to by In order to quickly find the leftmost rightmost element equal to we can store the left and the right bounds of the array where all the numbers are equal to To answer the query of type we should find two elements in the array at distance whose absolute difference is minimal Since the size of the array without zero elements is we can t look at the whole array But using the fact that there are no more than different values in the array we can create an auxiliary array of pairs the value from the array and the number of occurrences of that value In such an array we need to find a subarray where the sum of the second elements in the pairs is at least and the absolute difference between the first elements in the pairs is minimal That can be solved using standard two pointers method in The total complexity of the solution is In fact we can use Mo s algorithm even with updates But its complexity is You can read the editorial of the problem 940F on Codeforces or the following blog to learn about processing updates in Mo https codeforces com blog entry 72690,This problem is given because on the Codeforces pages we often see questions like What is the method of the two pointers This problem is a typical problem that can be solved using two pointers technique Let s find for each left end the maximal right end that is a good segment Note if is a good segment then is also a good segment So the search of the maximal right end for we can start from the maximal right end for The only thing that we should do is to maintain in the array for each number the number of it s occurrences in the current segment and the number of different numbers in We should move the right end until the segment became bad and then move the left end Each of the ends will be moved exactly times 
733,You are given a sequence of positive integers Your task is to construct an undirected graph such that there are exactly vertices there are no self loops there are no multiple edges there are no more than edges its is equal to Vertices should be numbered through is an array with length equal to the number of vertices in a graph such that is the number of vertices adjacent to th vertex is a sorted in increasing order sequence of all distinct values from the It is guaranteed that there exists such a graph that all the conditions hold and it contains no more than edges Print the resulting graph ,We prove that the answer always always exists by constructing it Graph for is a single vertex Graph for is a clique of vertices Graph for some is obtained from the graph by adding vertices initially connected to nothing and vertices connected to all previously mentioned ones The vertices connected to nothing got degrees the vertices from the previous step increased their degrees by and finally there appeared vertices of degree The number is vertices is as needed ,Let s denote a way to distribute numbers as a Let s also call the paintings that meet the constraints paintings and all other paintings are bad We can solve the problem for each connected component of the graph independently and multiply the answers Let s analyze a painting of some connected component If some vertex has an odd number written on it then we should write even numbers on all adjacent vertices and vice versa So in fact we need to check if the component is bipartite and if it is divide it into two parts The number of good paintings is where is the size of the first part and is the size of the second part because we write s into all vertices of one part and s or s into all vertices of another part 
734,Turbulent times are coming so you decided to buy sugar in advance There are shops around that sell sugar the th shop sells one pack of sugar for coins but only each day So in order to buy several packs you need to visit several shops Another problem is that prices are increasing each day during the first day the cost is during the second day cost is during the third day and so on for each shop On the contrary your everyday budget is only coins In other words each day you go and buy as many packs as possible with total cost not exceeding Note that if you don t spend some amount of coins during a day you can t use these coins during the next days Eventually the cost for each pack will exceed and you won t be able to buy even a single pack So how many packs will you be able to buy till that moment in total ,Firstly note that if we want to buy as many packs as possible then it s optimal to buy the cheapest packs In other words if we sort all packs we ll always buy a prefix of array Next note that each day we buy some number of packs so instead of iterating through the days we can iterate through the number of packs and for each calculate the number of days we ll buy exactly packs Since the prices increasing and at day the price is then exists last day such that as days we could buy packs and at days we can t And we can find as maximum possible integer solution to inequation or We can calculate all using prefix sums in linear time As a result we buy packs in days in total packs in days in total packs in days in total and so on The resulting complexity is because of sort ,The area of a triangle is equal to its base multiplied by its height divided by Let the two points that have to be on the same side of a rectangle form its base To maximize it let s choose such two points that are the most apart from each other the first and the last in the list Then the height will be determined by the distance from that side to the remaining point Since there are points on all sides the points on the opposite side are the furthest Thus the height is always one of or depending on whether we picked the horizontal or the vertical side So we have to check four options to pick the side and choose the best answer among them 
735,Recently Max has got himself into popular CCG BrainStone As BrainStone is a pretty intellectual game Max has to solve numerous hard problems during the gameplay Here is one of them Max owns creatures th of them can be described with two numbers its health and its damage Max also has two types of spells in stock Doubles health of the creature Assigns value of of the creature to its Spell of first type can be used no more than times in total of the second type no more than times in total Spell can be used on a certain creature multiple times Spells can be used in arbitrary order It isn t necessary to use all the spells Max is really busy preparing for his final exams so he asks you to determine what is the maximal total damage of all creatures he can achieve if he uses spells in most optimal way ,At first let s prove that in optimal solution all spells of 1 st type are assigned to single creature By contradiction let s optimal answer contains indices where and If using spells of 1 st type is meaningless Otherwise if in general case then Contradiction So we can check for each creature maximal damage with its health multiplied At second if we sort all creatures in order by decreasing using spells on first creatures gives best answer So calculating answer for chosen creature invokes 2 cases if chosen creature is belong to first creatures then subtract from its contribution calculate new value and add it to otherwise we need one spell of second type which is optimal to take from th creature so along with replacing old value of chosen one we need to replace in contribution of th creature Result complexity is ,Note that each unit of damage dealt by explosions save us from using one more basic spell In other words the more the damage from explosions the better So the answer will be equal to Note that in order to kill all remaining monsters with the last spell the array should have the following structure there is a monster we cast the spell onto it and is strictly increasing in and strictly decreasing in ignoring prefix and suffix of s Let s focus on the left part of array segment since solving the right part is exactly the same Maximizing the total damage is equivalent to maximizing the sum of right before the final spell Note that we can use the straight greedy strategy to kill the chosen monster we should use Explosion spell of power exactly it s not optimal to make it either more or less powerful After that monster will create an explosion of power If we must decrease it to exactly to continue the chain of explosions of maximum total damage If we also decrease it to exactly and so on The general formula is This series will stop either if or or there are no monsters left or we met the monster with The two first cases are easy to check in constant time so let s look at the last case Suppose that monster position is equal to then or That monster is interesting to us because after death it creates an explosion of damage that already doesn t depend on and next calculation is practically the same task what chain of explosion we can have if we start from That idea drives us to dp let be the maximum damage of chaining explosion we can deal if we start from and move to the left For simplicity let s include into that total damage Calculating is next let s find the first such that If there are no such or if that is too far from i e we will set Now we know that on interval the damage dealt is the arithmetic progression for it s for it s for it s In total And if such exists and not too far away we increase by as well The last question is finding for each the closest such that Note that if we define we need just need to find last and that s quite standard task that can be solved with stack Let s iterate over and maintain a stack of previous When we need to find for the current let s just look at the top of the stack if we found we wanted otherwise just pop it and check the new top again and so on until either we find or stack becomes empty that would mean that there are no After processing the th element push on top of the stack Why it works Consider some The element on top of the stack is firstly it s but we are talking about general case If we found what we want Otherwise but it also means that previous elements that was popped on previous iteration was greater than So is bigger than as well and there were no need to even consider them i e popping them out earlier doesn t break anything Since each element is pushed in the stack once and popped out once then the complexity is for all for to or amortized The answer for the chosen position then is where is dp we discussed above is the same dp but on reversed array and because we included into both and Both and are calculated in so the total comlpexity is 
736,Polycarp has just invented a new binary protocol for data transmission He is encoding positive integer decimal number to binary string using following algorithm Each digit is represented with number of characters equal to the value of that digit for it is zero ones Digits are written one by one in order corresponding to number and separated by single character Though Polycarp learnt how to encode the numbers he has no idea how to decode them back Help him calculate the decoded number ,Let s decode the number digit by digit starting from the leftmost When you meet in the string increase the value of the current digit For print current digit and proceed to the next one Don t forget to print the last digit when the string is over Overall complexity ,Presume that we want to calculate the number of blocks of length Let s divide this blocks into two types blocks which first element is a first element of integer or blocks which last element is a last element of integer for example blocks and in integer other blocks At first let s calculate the number of blocks of first type We can choose positions of this block at the start of end of the integer Now we can choose digit for this block After that we can chose digits of adjacent block if these blocks contain the same digit then we length of blocks which we want calculate greater than so we have only variations of digit in adjacent block Finally the can chose the remaining digit ways So the total number of block of first type is Now let s calculate the number of blocks of second type We can choose positions of this block all position except the start and end of integer Now we can choose 10 digit for this block After that we can chose digits of adjacent block for block to the left and for block to the right Finally the can chose the remaining digit ways So the total number of block of second type is That s almost all We have one corner case If then we number of blocks is always 
737,A tourist wants to visit country Zeydabad for Zbazi a local game in Zeydabad The country Zeydabad is a rectangular table consisting of rows and columns Each cell on the country is either or The tourist knows this country is named Zeydabad because there are lots of s in the country A is a square which anti diagonal is completely filled with and its upper and lower rows are also completely filled with All other cells of a square can be arbitrary Note that a can consist of only one cell see the examples So he wants to count the number of s in the country a necessary skill for Zbazi Now your task is to help tourist with counting number of s As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,Let s precalculate the values the maximal number of letters z to the left to the right and to the left down from the position It s easy to do in time Let s fix some cell Consider the value It s the maximum size of the square with upper right ceil in But the number of z patterns can be less than Consider some cell diagonally down left from on the distance no more than The cells and forms z pattern if Let s maintain some data structure for each antidiagonal it can be described by formula that can increment in a point and take the sum on a segment Fenwick tree will be the best choice for that Let s iterate over columns from the right to the left and process the events we have some cell for which In that case we should increment the position in the tree number by one Now we should iterate over the cells in the current column and add to the answer the value of the sum on the segment from to in the tree number ,To obtain a segment of cells of black color we need to paint all the white cells of the segment black Then go through all the segments of length there are only and choose such a segment among them that the number of white cells on it is minimal You can quickly find out the number of white cells in the segment by prefix sums 
738,There is a classroom with two rows of computers There are computers in each row and each computer has its own grade Computers in the first row has grades and in the second row Initially all pairs of computers in each row are connected by wire pairs for all so two rows form two independent computer networks Your task is to combine them in one common network by connecting one or more pairs of computers from rows Connecting the th computer from the first row and the th computer from the second row costs You can connect one computer to several other computers but you need to provide at least a basic fault tolerance you need to connect computers in such a way that the network stays connected despite one of its computer failing In other words if one computer is broken no matter which one the network won t split in two or more parts That is the minimum total cost to make a fault tolerant network ,There is a criterion when the given network becomes fault tolerant the network becomes fault tolerant if and only if each of corner computers let s name them and is connected to the other row From the one side if WLOG is not connected to other row then if is broken loses connection to the other network since is connected only with From the other side suppose WLOG is broken then the row is falling in at most two parts and But since both and are connected to row and is still connected then the resulting network is still connected Now the question is how to connect all corner computers Because sometimes it s optimal not to connect corners directly One of the approaches is described below Let s look at Essentially there are three ways to connect it to row to or where is with minimum possible The same applies to So let s just iterate over all these variants For each of these variants if we didn t cover then we should also add one more connection between and if we didn t cover then we should also add one more connection between and As a result we choose the best variant ,Let s solve this problem for each connected component of the given graph separately It is easy to see that the connected component is a cycle iff the degree of each its vertex equals to So the solution is to count the number of components such that every vertex in the component has degree The connected components of the graph can be easily found by simple dfs or bfs 
739,A subarray of array from index to the index is the array The number of occurrences of the array in the array is the number of subarrays of such that they are equal to You are given arrays the elements of these arrays are integers from to You have to build an array consisting of integers from to in such a way that for given subarray the number of occurrences of in the array is than the number of occurrences of each non empty subarray of in Note that if doesn t occur in and no subarray of occurs in this condition is still met for Your task is to calculate the number of different arrays you can build and print it modulo ,What does the condition the number of occurrences of in the array is than the number of occurrences of each non empty subarray of in mean First if contains two or more equal elements then any occurrence of introduces at least two occurrences of that element so any element in is forbidden it should not appear in the resulting array Now let s consider an array such that every its element is unique Every element of should be a part of an occurrence of in the array Let s rephrase this condition as follows Let s build a directed graph on vertices where an arc from vertex to vertex means that each occurrence of should be followed by and each occurrence of should be preceded by i e is followed by in some array Let s consider the weakly connected components in this graph If we have at least one occurrence of some element from a component in it means that all other elements from this component occur in as well Some integers from and are bad in a sense that we cannot uniquely determine which element should follow precede them in terms of graph theory it means that the in degree or out degree of a vertex is at least Since by picking one element from a component we will have to use all elements from a component it means that if a component contains at least one bad element the whole component will be bad we cannot use any element from it If a component is a cycle no vertex has in degree or out degree greater than but the component is still bad since if we include at least one element from we cannot finish the cycle the array is not infinite but the cycle is Okay the only good components are chains When we use an element from a chain in all elements from this chain will be used in exactly the same order that they were in the chain so should consist of some chains linked together chains may repeat and some chains may be absent from We can write a solution with dynamic programming let be the number of ways to construct an array of length using these chains The transitions are as follows where is the number of chains and is the length of the th chain The number of chains is up to and the number of states in dynamic programming is so the solution works in which is too slow We can improve it with the following two facts all chains of the same length are indistinguishable there are different lengths of chains So instead of iterating on the chains themselves in dynamic programming we will iterate on the lengths of the chains considering only lengths having at least one chain and process all chains of the same length as one by introducing a multiplier in our dynamic programming where is the number of chains of length That way our dynamic programming will work in if we skip the values of with ,Let s sort the numbers in ascending order It becomes immediately clear that it is not profitable for us to increase the numbers that are equal to the last number the maximum of the array It turns out that every time you need to take such a subset of the array in which all the numbers except the maximums And once for each operation the numbers in the subset are increased by one then how many times can the operation be performed on the array Accordingly 
740,You are given a matrix initially filled with zeroes We define as the element in the th row and the th column of the matrix Two cells of the matrix are if they share a side and the elements in these cells are equal Two cells of the matrix belong to the same if there exists a sequence such that is the first cell is the second cell and for every and are connected You are given queries of the form For every such query you have to do the following replace the element with count the number of connected components in the matrix There is one additional constraint for every ,Note that because of the low constraints on the number of colors the problem can be solved independently for each color Now you can divide the queries into two types add a cell to the field and delete it You have to maintain the number of components formed by added cells Cell deletions will occur after all additions because of the condition The first part of the solution will be to calculate the number of components while adding new cells This is a standard problem that can be solved using the DSU After that we should note that if we consider the process of removing cells from the end this process is similar to the process of adding Therefore we have to process delete requests from the end in the same way as add requests only their contribution to the number of components will be opposite in sign ,The name of this problem is anagram for Small to large There is a reason for that The author solution for this problem uses the classic technique for computing sets in tree The simple solution is the following let s find for each vertex v the map int int the number of occurences for each colour set pair int int pairs the number of occurences and the colour and the number sum the sum of most frequent colours in subtree of v To find that firstly we should find the same thing for all childs of v and then merge them to one These solution is correct but too slow it works in O n2logn time Let s improve that solution every time when we want to merge two map s a and b let s merge the smaller one to larger simply by iterating over all elements of the smaller one this is the Small to large Let s consider some vertex v every time when vertex v will be moved from one map to another the size of the new map will be at least two times larger So each vertex can be moved not over than logn times Each moving can be done in O logn time If we accumulate that values by all vertices then we get the complexity O nlog2n I saw the solutions that differs from author s but this technique can be used in a lot of other problems 
741,Several days ago you bought a new house and now you are planning to start a renovation Since winters in your region can be very cold you need to decide how to heat rooms in your house Your house has rooms In the th room you can install at most heating radiators Each radiator can have several sections but the cost of the radiator with sections is equal to burles Since rooms can have different sizes you calculated that you need at least sections in total in the th room For each room calculate the minimum cost to install at most radiators with total number of sections not less than ,Let s denote the number of sections in the th radiator as Let s prove that in the optimal answer Proof by contradiction suppose we have and in the answer let s move from to and check The answer is not optimal contradiction Finally there is the only way to take with And it s to take elements with value and elements with ,Let s start by learning how to answer a query all red pepper and black pepper options are available Let s iterate over all options to put the peppers and choose the maximum of them First let s use the red pepper for all dishes Now we want to select some of them to use black pepper instead of red pepper Which ones do we choose When we switch from the red pepper to the black pepper the total tastiness changes by for the th dish They are completely independent of each other so we want to choose largest of these values Let be the sequence of values of in a non increasing order Thus black peppers will yield the result of We can answer a query by looking for a maximum in the sequence Now consider an arbitrary query Let be all options for the amount of available black peppers for the query Naively we could iterate over all of them and choose the maximum one However notice an interesting thing about the sequence of the answers By definition it is non strictly convex In particular one idea that can be extracted from this is the following Find the position of an arbitrary maximum in this sequence Then everything to the left of is is non increasing Everything to the right of it is non increasing Thus for a query it s enough to consider only two options the one closest to the maximum from the left and from the right Now we only have to learn how to get these options fast enough For a query we want to solve what s called a diophantine equation An arbitrary solution can be obtained by using extended Euclid algorithm Let it be some Then we would want to check the answer for black peppers The amount of solutions to the equation is either infinite or zero If it s infinite all solutions will be of the form for any integer Remember that not all the solutions will be in a range Finally find the two solutions that are the closest to the maximum check that they are in the range and print the best answer of them Overall complexity 
742,You are given an array consisting of integers You have to process queries to this array each query is given as four numbers and denoting that for every such that and you have to set equal to Print the array after all queries are processed ,We can represent a query as a function if If we want to apply two functions then we can calculate a composition of these functions in time in this problem is So we can do the following Use scanline technique Build a segment tree over queries where we store a composition of functions on segment in each vertex Initially all transformations are When a segment where we apply a query begins we update the segment tree we change the transformations on this query s index to the following if When a segment ends we revert the transformation on this index to The trick is that the composition of all current transformations is stored in the root of the segment tree so we can easily calculate the result of transformation ,Let s decrease by one Now let s determine the block with the th number To do that let s at first subtract from then subtract then subtract and so on until we got negative The number of subtractions will be the number of the block and the position in the block will be the last nonnegative number we will get 
743,Vlad has friends for each of whom he wants to buy gift for the New Year There are shops in the city in each of which he can buy a gift for any of his friends If the th friend receives a gift bought in the shop with the number then the friend receives units of joy The rectangular table is given in the input Vlad has time to visit at most shops where is the number of He chooses which shops he will visit and for which friends he will buy gifts in each of them Let the th friend receive units of joy from Vlad s gift Let s find the value Vlad s goal is to buy gifts so that the value of is as large as possible In other words Vlad wants to maximize the minimum of the joys of his friends For example let Let the joy from the gifts that we can buy in the first shop in the second shop Then it is enough for Vlad to go only to the second shop and buy a gift for the first friend bringing joy and for the second bringing joy In this case the value will be equal to Help Vlad choose gifts for his friends so that the value of is as high as possible Please note that each friend must receive one gift Vlad can visit at most shops where is the number of In the shop he can buy any number of gifts ,Note that if we cannot get joy then we cannot get and if we can get at least then we can get at least These facts allow us to use binary search to find the answer Now we need to understand how exactly we can recognize whether we can gain joy at least or not We can enter at most shops so we always need to take two gifts from some store which means there must be a store in which we can find two or more gifts with pleasure at least Also each friend should receive a gift which means that we should be able to buy each gift with pleasure at least It takes O nm to check that both of these conditions are met The total solution works in O nm log nm ,Let s divide all books into four groups both Alice and Bob doesn t like these books only Alice likes these books only Bob likes these books both ALice and Bob like these books Obviously group is useless now So how to solve the problem Let s iterate over the number of books we take from group Let it be Then we obviously need to take exactly books from groups and Among all books in these three groups we have to choose the cheapest ones To calculate sum of times in each group fast enought we can sort each group independently and implement prefix sums on these arrays If is less than zero or greater than the size of or group for each possible then the answer is And don t forget that the answer can be up to Time complexity 
744, is an array of positive integers all of which are not greater than You have to process queries to this array Each query is represented by two numbers and Several operations are performed in each query each operation changes to There operations are applied until becomes greater than The answer to the query is the number of performed operations ,There are two possible solutions in time First of them answers each query using simple iteration changes to for each query until becomes greater than as stated in the problem But it is too slow Second solution precalculates answers for each and if then else But this uses memory and can be done in time Now we can notice that if then second solution will use only time and memory and if then first solution will do not more than operations on each query So we can combine these two solutions Time complexity ,Let s work with the formula a bit Let then the formula becomes Considering thus is strictly increasing and has its minimum at So the solution will be to sort the list extract the pairs of sticks of equal length and check only neighbouring pairs in sorted order for the answer Overall complexity 
745,For the New Year Polycarp decided to send postcards to all his friends He wants to make postcards with his own hands For this purpose he has a sheet of paper of size which can be cut into pieces Polycarp can cut any sheet of paper that he has in only two cases If is even then he can cut the sheet in half and get two sheets of size If is even then he can cut the sheet in half and get two sheets of size If and are even at the same time then Polycarp can cut the sheet according to any of the rules above After cutting a sheet of paper the total number of sheets of paper is increased by Help Polycarp to find out if he can cut his sheet of size at into or more pieces using only the rules described above ,If we cut the sheet in width we will reduce its width by half without changing the height Therefore the width and height dimensions do not affect each other in any way Let s calculate the maximum number of sheets that we can get by cutting Let s say that initially this number is Let s cut the sheet in width Then the sheets number will become but they will be the same If we can cut the sheet again it is more profitable to cut all the sheets we have because this way we will get more new sheets and their size will still be the same So we can maintain the current number of identical sheets and as long as either the width or height is divided by divide it and multiply the number of sheets by two ,Firstly note that if we want to buy as many packs as possible then it s optimal to buy the cheapest packs In other words if we sort all packs we ll always buy a prefix of array Next note that each day we buy some number of packs so instead of iterating through the days we can iterate through the number of packs and for each calculate the number of days we ll buy exactly packs Since the prices increasing and at day the price is then exists last day such that as days we could buy packs and at days we can t And we can find as maximum possible integer solution to inequation or We can calculate all using prefix sums in linear time As a result we buy packs in days in total packs in days in total packs in days in total and so on The resulting complexity is because of sort 
746,Consider the points on the number line There is a teleporter located on each of the points At point you can do the following Move left one unit it costs coin Move right one unit it costs coin Use a teleporter at point if it exists it costs coins As a result you teleport to point Once you use a teleporter you use it again You have coins and you start at point What s the most number of teleporters you can use ,It s easy to see that it s optimal to only move right or to use a portal once we are at it We can notice that when we teleport back the problem is independent of the previous choices We still are at point and have some portals left Thus we can just find out the individual cost of each portal sort portals by individual costs and take them from smallest to largest by cost as long as we can The cost of portal is since we pay to use it and need moves to get to it ,Note that all are positive which means that the amount on the prefix only increases This allows us to use binary search to find the answer for the vertex It remains only to learn how to quickly find the sum of on the path prefix Let s run a depth first search and store the prefix sums of the current path in stack going to the vertex add the sum to the end of the path and delete it when exiting 
747,Masha meets a new friend and learns his phone number She wants to remember it as soon as possible The phone number is a string of length that consists of digits from to The phone number may start with Masha already knows phone numbers all numbers have the same length It will be easier for her to remember a new number if the is represented as segments of numbers she already knows Each such segment must be of length otherwise there will be too many segments and Masha will get confused For example Masha needs to remember the number and she already knows numbers You can represent as a segment of number one of number two and of number three There are other ways to represent Masha asks you for help she asks you to break the string into segments of length or more of the numbers she already knows If there are several possible answers print of them ,The key idea is that any string of length greater than 3 can be obtained by concatenating strings of length or Then when reading the data remember all occurring substring of length and There are at most Now we will count the dynamics on the prefix if we can get the prefix of length of phone by segments of length and of the known phones Masha Then for the transition we need to look through the lengths and then take a substring of the corresponding length and find out whether such a string occurred in the phones known to Masha Then it will take or time to recalculate the dynamics depending on the implementation But it will still take more time to read the data so the final asymptotic will be or ,Let s notice that described swaps allows us to place any character to any position of the string relative order of and obviously cannot be changed Let s remove all characters from the string and keep their count in some variable Now more profitable move is to place all the 1 characters right before the first character of and if there is no character in then place they after the end of the string 
748,You are planning to buy an apartment in a floor building The floors are numbered from to from the bottom to the top At first for each floor you want to know the minimum total time to reach it from the first the bottom floor Let for all from to be the time required to go from the th floor to the th one and from the th to the th as well using the for all from to be the time required to go from the th floor to the th one and from the th to the th as well using the also there is a value time overhead for elevator usage you need to wait for it the elevator doors are too slow In one you can go from the floor you are staying at to any floor in two different ways If you are using the stairs just sum up the corresponding values of Formally it will take time units If you are using the elevator just sum up and the corresponding values of Formally it will take time units You can perform as many as you want possibly zero So your task is for each to determine the minimum total time it takes to reach the th floor from the st bottom floor ,This is easy dynamic programming problem It is easy to understand that we don t need to go down at all otherwise your solution will be Dijkstra s algorithm not dynamic programming Let be the minimum required time to reach the floor if we not in the elevator right now and be the minimum required time to reach the floor if we in the elevator right now Initially all values are except and Transitions are pretty easy we was not in the elevator and going to the next floor using stairs we was in the elevator and going to the next floor using stairs we was not in the elevator and going to the next floor using elevator we was in the elevator and going to the next floor using elevator The answer for the th floor is Time complexity ,Notice that it never makes sense to move blocks between the towers such that neither of them is tower 1 as that can only decrease the heights Moreover it never makes sense to move blocks away from the tower 1 Thus all operations will be moving blocks from some towers to tower 1 At the start which towers can move at least one block to tower 1 Well only such i that a i a 1 What happens after you move a block Tower 1 becomes higher some tower becomes lower Thus the set of towers that can share a block can t become larger Let s order the towers by the number of blocks in them At the start the towers that can share a block are at the end on some suffix in this order After one move is made the towers get reordered and the suffix can only shrink Ok but if that suffix shrinks what s the first tower that will become too low The leftmost one that was available before So regardless of what the move is the first tower that might become unavailable is the leftmost available tower Thus let s attempt using it until it s not too late The algorithm then is the following Find the lowest tower that can move the block to tower 1 move a block repeat When there are no more towers higher than tower 1 the process stops However the constraints don t allow us to do exactly that We ll have to make at most 10 9 moves per testcase Ok let s move the blocks in bulk every time Since the lowest available tower will remain the lowest until you can t use it anymore make all the moves from it at the same time If the current number of blocks in tower 1 is x and the current number of blocks in that tower is y lceil frac y x 2 rceil blocks can be moved You can also avoid maintaining the available towers by just iterating over the towers in the increasing order of their height Overall complexity O n log n per testcase 
749,There are workers and tasks The workers are numbered from to Each task has a value the index of worker who is proficient in this task Every task should have a worker assigned to it If a worker is proficient in the task they complete it in hour Otherwise it takes them hours The workers work in parallel independently of each other Each worker can only work on one task at once Assign the workers to all tasks in such a way that the tasks are completed as early as possible The work starts at time What s the minimum time all tasks can be completed by ,The statement should instantly scream binary search at you Clearly if you can assign the workers in such a way that the tasks are completed by time you can complete them all by or more as well How to check if the tasks can be completed by some time What that means is that all workers have hours to work on some tasks If all tasks took hours to complete then each of them could complete of them Thus together they would be able to complete tasks How to incorporate the hour tasks into that Well we can redistribute the tasks in such a way that each worker first completes the tasks they are proficient in then some other tasks if they have more time So the general idea is the following Let each worker complete hour tasks where is the number of tasks the th worker is proficient in Then remember how many hour tasks they can complete which is Finally remember how many tasks that they are proficient in they didn t have time to complete which is If the sum of the number of incomplete tasks doesn t exceed the sum of the number of tasks they have time to complete then everything can be completed in time Worst case it can take up to hours to complete everything if you assign all tasks to a single worker and they are not proficient in any of them Overall complexity per testcase ,In this problem we can notice that when we calculate the answer for the kid we also calculate the answer for kids and so on So we can a little bit modify the pseudocode from the easy version to calculate answers faster pos p i ans 1cycle i while pos i cycle append pos ans 1 pos p pos for el in cycle res el ansAnd of course we don t need to run this while for all elements for which we already calculated the answer Total time complexity is because you ll process each element exactly once 
750,XXI Berland Annual Fair is coming really soon Traditionally fair consists of booths arranged in a circle The booths are numbered through clockwise with being adjacent to The th booths sells some candies for the price of burles per item Each booth has an unlimited supply of candies Polycarp has decided to spend at most burles at the fair However he has some plan in mind for his path across the booths at first he visits booth number if he has enough burles to buy candy from the current booth then he buys it immediately then he proceeds to the next booth in the clockwise order regardless of if he bought a candy or not Polycarp s money is finite thus the process will end once he can no longer buy candy at any booth Calculate the number of candies Polycarp will buy ,Let s code the following process Go one circle across the booths calculate the total cost of sweets bought and the number of sweets bought Now you can decrease you money down to and add to answer It represents that you went maximum number of such circles The later circles will have smaller cost Let s continue this process until becomes smaller than the minimum priced sweet The number of operations made is Let be the amount of money before some operation be the total cost of sweets bought on that operation and is actually smaller than that s how modulo works and smaller than that s also how modulo works And these inequalities imply that That leads to about steps to reach the minimal price Overall complexity ,When using th coupon the bar we get for free should have at least bars not cheaper than it So if we consider sorted in non decreasing order then we cannot get discount greater than On the other hand we can always get such a discount if we pick most expensive bars to buy using the th coupon 
751,You are given two positive integers and Print the th positive integer that is not divisible by For example if and then all numbers that are not divisible by are The th number among them is ,Suppose the answer is just th positive integer which we should shift right by some number Each multiplier of shifts our answer by The number of such multipliers is where is divided by rounded down So the final answer is th positive integer with the required number of skipped integers multipliers of You can also use a binary search to solve this problem ,Easy to see that only the numbers of the form and for different prime have exactly four positive divisors We can easily count the numbers of the form in where is the number from the problem statement Now let and be the number of primes from to Let s iterate over all the values Easy to see that So for fixed we should increase the answer by the value So the task is ot to find the number of primes not exceeding for all Denote the th prime number Denote the number of such that and all prime divisors of are at least note that 1 is counted in all since the set of its prime divisors is empty satisfy a simple recurrence since 2 hence Let be the smallest prime greater than Then by definition the first summand accounts for all the primes not less than If we evaluate the recurrence straightforwardly all the reachable states will be of the form We can also note that if and are both greater than then Thus for each it makes sense to keep only values of Instead of evaluating all DP states straightforwardly we perform a two step process Choose Run recursive evaluation of If we want to compute a state with memorize the query count the numbers not exceeding with all prime divisors at least Answer all the queries off line compute the sieve for numbers up to then sort all numbers by the smallest prime divisor Now all queries can be answered using RSQ structure Store all the answers globally Run recurisive evaluation of yet again If we want to compute a state with then we must have preprocessed a query for this state so take it from the global set of answers The performance of this approach relies heavily on the number of queries we have to preprocess Statement Proof Each state we have to preprocess is obtained by following a transition from some greater state It follows that doesn t exceed the total number of states for The preprocessing of queries can be done in and it is the heaviest part of the computation Choosing optimal we obtain the complexity 
752,Along the railroad there are stations indexed from to An express train always travels along a route consisting of stations with indices where The train travels along the route from left to right It starts at station then stops at station then at and so on Station the terminus It is possible that the train will visit the same station more than once That is there may be duplicates among the values You are given queries each containing two different integers and For each query determine whether it is possible to travel by train from the station with index to the station with index For example let the train route consist of of stations with indices and give of the following queries It is possible to travel from station to station by taking a section of the route consisting of stations Answer You cannot travel from station to station because the train cannot travel in the opposite direction Answer It is not possible to travel from station to station because station is not part of the train s route Answer ,To solve the problem we will use the dictionary Each station will be matched with a pair of integers the indices of its first and last entries in the route Then we will sequentially process queries If at least one of the stations or is missing in the dictionary the answer is Otherwise check If the index of the first entry of station in the route is strictly less than the index of the last entry of station in the route the answer is Otherwise the answer is ,Let s sort all students by their programming skills but save the initial indices to restore the answer Now we can understand that we don t need to compose the team of size greater than because in this case we can split it into more teams with fewer participants and obtain the same or even less answer Now we can do the standard dynamic programming the minimum total diversity of the division if we divided the first students in sorted order Initially all other values of are Because of the fact above we can do only three transitions indexed The answer is and we can restore it by standard carrying parent values as a parent of the state we can use for example the number of participants in the team 
753,You are given a tree consisting of vertices There are chips placed in vertices All are distinct Vertices are colored black initially The remaining vertices are white You are going to play a game where you perform some moves possibly zero On the th move indexed you are going to move the st chip from its current vertex to an adjacent vertex and color that vertex So if you move chip on move chip on move chip on move chip on move chip on move and so on If there is no adjacent white vertex then the game ends What s the maximum number of moves you can perform ,The constraints tell us that the solution should be linear or pretty close to it Well in particular that implies that the solution almost certainly isn t dynamic programming since we have both and to care about Thus we ll think about something greedy When we know the number of move the game will last we can tell how many steps each chip should make Well since the more moves the game last the more steps each ship makes the answer is a monotonic function Let s apply binary search and think if we can check if each chip can make some known number of steps A common idea in the problems where you have to do something greedily on a tree is to root the tree arbitrarily and process everything bottom up Consider the bottommost chip If it can move its number of moves downwards it s always optimal to do that Since it s the bottommost chip it can only make things worse for chips above it And any of them can t pass through the initial vertex of this chip anyway If it can t it has to move to its parent vertex Let s move it there and deal with this chip later when it becomes the bottommost again If it can t move to its parent it can t move at all Thus the game can t last for this many steps Since we only apply either the move which is guaranteed to not interrupt any other moves or the move which is forced the greedy strategy is correct As for implementation details it s not too tricky Basically for each vertex we should maintain these values if this vertex has been visited the number of steps the chip in this vertex still has to make if any chip is in this vertex the longest path downwards from this vertex via non visited vertices The second value can be initialized beforehand and pushed to the parent when needed The rest of them are easily maintained with a single dfs Overall complexity per testcase ,Consider the first four actions that the grasshopper will perform starting at a point with coordinate coordinate is jumping to leads to coordinate is jumping to leads to coordinate is jumping to leads to coordinate is jumping to leads to If you look closely at the next four jumps they follow the same pattern jump to the left two jumps to the right jump to the left In general making jumps with numbers the grasshopper will start from coordinate and move as Thus if were always zero the answer would be if if if if is divisible by Let s find an answer for the cases when But if is even then all steps will follow the same directions and the answer will be where is the answer for the same and starting point described above And if is odd then all steps will have opposite directions and the answer will be 
754,For an array of integers of size we construct another array as follows for Your task is to restore the array from a given array or to report that there are multiple possible arrays ,Note that or Since there is no upper bound for the values of the case where for all always exists It remains to check if there are other ways To do this it is enough to check whether there is such a position that the change to doesn t result in a negative value of The reason for is that for no matter the plus or minus we choose the array doesn t change If you could change at least one sign to minus that would be another answer ,The maximum possible you can obtain is the sum of the largest values of the given array This is obvious because we can always separate these maximums and then extend the segments corresponding to them to the left or to the right and cover the entire array I suggest the following extract largest values of the given array and place a separator right after each of them except the rightmost one Overall complexity is 
755,Kirill lives on a connected undirected graph of vertices and edges at vertex One fine evening he gathered friends the th friend lives at the vertex So all friends are now in the vertex the th friend must get to his home to the vertex The evening is about to end and it is time to leave It turned out that of his friends have no cars and they would have to walk if no one gives them a ride One friend with a car can give a ride to number of friends without cars but only if he can give them a ride by driving along one of the paths to his house For example in the graph below a friend from vertex can give a ride to friends from the following sets of vertices but can t give a ride to friend from vertex or a set Kirill wants as few friends as possible to have to walk Help him find the possible number ,To begin with let s learn how to find possible sets of friends for the vertex whom he can give a ride in the form of masks Let s use a breadth first search every time we find the shortest path to the vertex with the previous vertex we will add the masks of the vertex to the masks of the vertex updating them with friends living in Now according to the resulting sets you need to get the best combination of them We will find it using the knapsack problem we will use masks as weights and the total weight will be the bitwise of the selected set ,You can use straightforward way and calculate answer with l r dp with But there is a easier claim it s optimal to split gon with diagonals coming from so answer is Proof let s look at the triange which contains edge Let s name it If we can delete this triangle and go to gon Otherwise Let s look at triangle It always exists and Finally if we change pair of triangles to answer will decrease since and that s why Note that triangle changes to and so repeating this step will eventually lead us to situation As a result we can morph any triangulation into one mentioned above and its weight won t increase 
756,You have a garland consisting of colored light bulbs the color of the th light bulb is Initially all the light bulbs are turned off Your task is to turn all the light bulbs on You can perform the following operation any number of times select a light bulb and switch its state turn it on if it was off and turn it off if it was on The only restriction on the above operation is that you can apply the operation to a light bulb only if the previous operation was applied to a light bulb of a different color the first operation can be applied to any light bulb Calculate the minimum number of operations to turn all the light bulbs on or report that this is impossible ,Note that there are only a few configuration classes and Let s discuss each of them If all bulbs are of the same color then it is impossible to turn all the bulbs on because after you switch one light bulb it is impossible to turn the others on If there is a color with bulbs then it is impossible to turn all the bulbs on in operations which means there is a bulb that turns on turns off and then turns on again i e the answer is at least operations And there is a sequence of exactly operations such an example was shown in the problem notes For configurations like and it is enough to turn on the color bulbs not in a row i e in order for the first case and for the second one So the answer for such configurations is If all the bulbs are of different colors then nothing prevents you from turning them all on in operations ,There are lots of ways to check correctness For example you can keep boolean array with already used colors check stripes naively and mark the color used if the stripe has single color If all the colors are used in the end then the answer is Overall complexity 
757,Consider some positive integer Its prime factorization will be of form Let s call if the greatest common divisor of the sequence is equal to For example numbers are and numbers are not Count the number of integers from to Each testcase contains several values of for each of them you are required to solve the problem separately ,Whoops it seems this problem can be done in a similar manner as in problem Firstly is some number has of the prime powers not equal to then you can take root th power from it That is the same as dividing all powers by Now it turned out there are really a small amount of these numbers up to if you take the squares out Actually our solution wasn t that Let s count the answer using inclusion exclusion principle For this Mobius function can be used The answer is The power part is the amount of numbers which raised to the th power becomes less ot equal to This turns zero for like iterations on for any up to However calculating each log as it is will lead to a solution which might be too slow Let s process the queries in the decreasing order of will be calculated naively each time in or however complexity has the built in function maybe or The rest powers will be initialized with their upper limits in the start like for for and so on Now proceeding to the next number will only decrease the current maximum number for each power Subtract one until you reach the needed number and check in Overall complexity ,Firstly let s prove that the size of the answer is not greater than Suppose that the answer equals to Let be coordinates of the points in the answer and Let and Then because of the condition It means that Conditions must hold for a triple too Now it is easy to see that if then that is not a power of two So the size of the answer is not greater than Firstly let s check if the answer is Iterate over all middle elements of the answer and over all powers of two from to inclusively Let be the middle element of the answer and the current power of two Then if there are elements and in the array then the answer is Now check if the answer is Do the same as in the previous solution but now we have left point and right point If we did not find answer of lengths or then print any element of the array The solution above have time complexity because of we can check if the element is in the array with some data structure in 
758,You are given positive integers with and Find any pair of numbers and that satisfies the following conditions is divisible by Note that required and may not exist ,Let s look at the slow solution first which will lead us to the full one Let s iterate over the number from to Given a number we want to find a from to such that is divisible by Since must be divisible by the following conclusion can be drawn must be divisible by Let s denote this number as Now our task is to check if there is a multiple of between and The problem can be solved in many ways you can simply consider the largest multiple of that does not exceed it is equal to We compare this number with and if it matches then we have found a suitable pair Now let s note that we do not need to iterate over all the values of because from the number we are only interested in and this is one of the divisors of Even though the product can be large we can still consider all divisors of this number since and themselves are up to Let s find the divisors of and separately then notice that any divisor of is where is some divisor and is some divisor Let s calculate the running time We need to factorize the numbers and into prime factors this can be done in Next you need to iterate over pairs of divisors and Recall the estimate for the number of divisors of a number https oeis org A066150 the number up to has no more than divisors Therefore we can sort through the pairs for We learned how to find the optimal for We get that for each test case we have learned to solve the problem in ,If is not divisible by then just print and stop the program Otherwise calculate denoting the required number of times to multiply It is easy to see that should be a product of zero or more s and of zero or more s i e for integers To find just use a loop to divide by while it is divisible by Similarly to find just use a loop to divide by while it is divisible by After the divisions the expected value of is If print Otherwise print the total number of the loop iterations 
759,There are friends who want to give gifts for the New Year to each other Each friend should give one gift and receive one gift The friend give the gift to himself For each friend the value is known it is either if the th friend doesn t know whom he wants to give the gift to or if the th friend wants to give the gift to the friend You want to fill in the unknown values in such a way that each friend gives one gift and receives one gift and there is friend who gives the gift to himself It is guaranteed that the initial information isn t contradictory If there are several answers you can print any ,In this problem we need to print the permutation without fixed points without values but some values are known in advance Let s consider the permutation as a graph We know that the permutation is the set of non intersecting cycles In this problem we are given such a graph but some edges are removed How to deal with it Firstly let s find isolated vertices in the graph Let its number be If then all is ok and we skip the current step If then let s pin this isolated vertex to any vertex to which we can pin it Otherwise and we can create the chine consisting of all isolated vertices Now and we can finally construct the remaining part of the graph We can notice that we have the same number of vertices with zero incoming and zero outcoming degrees And because we got rid of all possible loops in the graph we can match these vertices as we want Time complexity ,The first thing to notice the answer always exists For numbers answer choices as well as permutation combinations It remains only to restore the answer from this permutation We will restore by performing reverse operations On the th operation will be selectd the first elements of the array and rotate them times to the left elements with numbers and more remain in their places Where is equal to if otherwise and is the index of the number Thus for each from right to left performing a left cyclic shift operation we move the number at index As a result we move numbers times The time complexity 
760,Recently you bought a brand new smart lamp with programming features At first you set up a schedule to the lamp Every day it will turn power on at moment and turn power off at moment Moreover the lamp allows you to set a program of switching its state states are lights on and lights off Unfortunately some program is already installed into the lamp The lamp allows only programs Good program can be represented as a non empty array where All must be integers Of course preinstalled program is a good program The lamp follows program in next manner at moment turns power and light on Then at moment the lamp flips its state to opposite if it was lit it turns off and vice versa The state of the lamp flips instantly for example if you turn the light off at moment and then do nothing the total time when the lamp is lit will be Finally at moment the lamp is turning its power off regardless of its state Since you are not among those people who read instructions and you don t understand the language it s written in you realize after some testing the only possible way to alter the preinstalled program You can element into the program so it still should be a program after alteration Insertion can be done between any pair of consecutive elements of or even at the begining or at the end of Find such a way to alter the program that the total time when the lamp is lit is maximum possible Maybe you should leave program untouched If the lamp is lit from till moment then its lit for units of time Segments of time when the lamp is lit are summed up ,At first let s insert and in array so all possible positions for inserting will always belong to At second let be value to insert and It can be proven that it s always optimal to move to or to So for each we need to check only and To check it fast enough we need to know total time of lamp is lit for each prefix and precalculate for each total time of lamp is lit if starting from light is on lights is off Result complexity is ,Let s calculate the number of letters which occur exactly once in the string and letters that occur more than once and respectively If a letter occurs more than once one of its occurrences may be painted in red and another one may be painted in green We cannot paint all other occurrences because there will be two equal letters painted in one color but this is unacceptable by the statement So there are no more than occurrences of letters that occur more than once to be painted in red Let s select such occurrences and paint them We need to paint additionally the letters which occur exactly once by meeting the same conditions as we meet painting the whole string There s no way to paint these letters and not meet the first two conditions So we must select the maximal count of the letters so that we will be able to paint some set of remaining letters in green so that the number of red letters will be equal to the number of green letters This number is equal to So the final answer is equal to 
761,Stephen Queen wants to write a story He is a very unusual writer he uses only letters and To compose a story Stephen wrote out words consisting of the first lowercase letters of the Latin alphabet He wants to select the number of to make an story Let a story be a sequence of words that are not necessarily different A story is called if there exists a letter which occurs among all words of the story more times than all other letters together For example the story consisting of three words is interesting the letter occurs times all other letters occur times in total But the story consisting of two words is not no such letter that it occurs more than all other letters in total You are given a sequence of words consisting of letters and Your task is to choose the maximum number of them to make an interesting story If there s no way to make a non empty story output ,Let be the number of the occurrences of the letter in the word minus the number of the occurrences of all other letters in total Since for each two words and the number of the occurrences of a letter in the word is the sum of the numbers of its occurrences in and the equality is true means the concatenation of and Consider a sequence of words A story consisting of words is interesting if and only if there s a letter such that it exactly means that there s a letter which occurs more times than all other in total So we are interested in searching for a letter such that exists a positive integer a maximal number of words such that Suppose we have a set of words that form an interesting story and where is the letter having more occurrences than all other letters in total Suppose we can add to it one of few words We had better add a word such that is maximal to be able to add more words in the future So the problem has the following solution for each letter of the Latin alphabet and for each word let s calculate Then let s iterate over all letters take a sequence and sort it in descending order Let s initialize an interesting story by a set of a single word corresponding to the first element of the sequence If there s no word such that then there s no non empty interesting story containing some words of the given set Otherwise let s take the next elements of the sequence sequentially until the sum of over all taken words is greater than zero Let s select a letter such that the corresponding taken set is maximal over all letters Finally we should print the set s size The solution consists of two phases the calculation of all works in where is the alphabet s size is the lengths of a string and building a maximal interesting story for each letter sorting and a greedy algorithm ,This problem has a very standard solution let s take the leftmost zero place it as left as possible and solve the problem without this zero and all operations we spent But we should do it fast Let s go from left to right and carry the number of ones on the prefix If we meet let s just increase and continue the algorithm It is obvious that if we meet we need to make exactly swaps to place it before all ones If we can do it let s just add to the answer decrease by and continue Otherwise this zero will be between some of these ones and we can place it naively In this case the suffix of the string will not change If after all operations we didn t meet the case above let s add all ones to the suffix of the resulting string Time complexity 
762,You are a coach of a group consisting of students The th student has programming skill You want to divide them into teams in such a way that No two students and such that belong to the same team i e skills of each pair of students in the same team have the difference strictly greater than the number of teams is the minimum possible You have to answer independent queries ,The answer is always or Why it is so Because if there is no such pair among all students that then we can take all students into one team Otherwise we can divide them into two teams by their programming skill parity ,In this problem we can notice that when we calculate the answer for the kid we also calculate the answer for kids and so on So we can a little bit modify the pseudocode from the easy version to calculate answers faster pos p i ans 1cycle i while pos i cycle append pos ans 1 pos p pos for el in cycle res el ansAnd of course we don t need to run this while for all elements for which we already calculated the answer Total time complexity is because you ll process each element exactly once 
763,Johny likes numbers and very much Now Johny wants to find the smallest integer greater than so it is divisible by the number ,We should find minimal so Easy to see that To learn more about floor ceil functions I reccomend the book of authors Graham Knuth Patashnik Concrete Mathematics There is a chapter there about that functions and their properties , Okay we need more definitions Here they come This way we can transform the formula for to the following Or even this since This is almost the convolution of the sequences and with a bit extra additional operations after the convolution so to compute the sequence we just need to compute the sequences and and then calculate their convolution with NTT All that s left is to multiply every element by the corresponding factorial But wait that s not so easy In order to calculate and we need to know Note that we can ignore the fact that and appear in the formula for since they are multiplied by so at least we don t have a dependency cycle Unfortunately we cannot just straightforwardly use convolution if we don t know the sequences and The model solution handles it using the following approach Let s generate and in parallel on the th iteration calculate then calculate and using it And we will calculate the convolution of the sequences and Suppose we want to calculate and the last time we calculated the convolution of and was after the iteration Back then we knew all elements from to and from to So the th term in the convolution of and contained the sum of over all such that and So in order to calculate we have to pick this value from the convolution and then add the sum of over all such that or and there are such values Suppose we compute the convolution every iterations Then the maximum value of is and every value of is calculated in We also make convolutions so the total complexity of this solution will be which can be transformed into if we pick 
764,Recently students from city S moved to city P to attend a programming camp They moved there by train In the evening all students in the train decided that they want to drink some tea Of course no two people can use the same teapot simultaneously so the students had to form a queue to get their tea th student comes to the end of the queue at the beginning of th second If there are multiple students coming to the queue in the same moment then the student with greater index comes after the student with lesser index Students in the queue behave as follows if there is nobody in the queue before the student then he uses the teapot for exactly one second and leaves the queue with his tea otherwise the student waits for the people before him to get their tea If at the beginning of th second student still cannot get his tea there is someone before him in the queue then he leaves the queue without getting any tea For each student determine the second he will use the teapot and get his tea if he actually gets it ,Let s store the last moment when somebody gets a tea in the variable Then if for the th student then he will not get a tea Otherwise he will get it during second And if he gets a tea then will be replaced with the answer for this student ,This problem has many approaches as Hall s theorem Kuhn algorithm and so on I will explain one or two of them Let s find the answer using binary search It is obvious that if we can pass all the exams in days we can also pass them in days For the fixed last day let s do the following thing firstly if there exists some exam with the day of the first opportunity to pass it greater than then the answer for the day is false Next while there exist exams having only one possibility to pass them because of the upper bound of the maximum possible day or constraints imposed by the other exams we choose this day for this exam and continue after choosing such day there can appear some new exams with the same property Now there are no exams having only one day to pass them Let s take a look on the graph where vertices represent days and edges represent exams the edge between some vertices and exists iff there is an exam with the first day to pass it equal to and the second day to pass it equal to Let s remove all the exams for which we identified the answer Now let s take a look on the connected components of this graph and analyze the problem which we have now Our problem is to choose exactly one vertex incident to each edge of the connected component such that no vertex is chosen twice and we have to do this for all the connected components we have Let be the number of vertices in the current connected component and be the number of edges in the current connected component The answer for the connected component is true iff for obvious reasons There is very easy constructive method to see how we can do this If then the current connected component is a tree Let s remove some leaf of this tree and set it as the chosen vertex for the edge incident to this leaf and remove this edge too If then let s remove all leaves as in the algorithm for the tree For the remaining cycle let s choose any edge and any vertex incident to it set this vertex as the chosen to this edge and remove them Now we have a chain Chain is a tree so let s apply the algorithm for the tree to this chain So if for some connected component holds then the answer for the day is false Otherwise the answer is true Overall complexity because of numbers compressing or using logarithmic data structures to maintain the graph Also there is another solution which can be too slow I don t know why it works It is well known fact that if we will apply Kuhn algorithm to the some bipartite graph in order of increasing indices of vertices of the left part then the last vertex in the left part of this graph which is in the matching will be minimum possible Oh that s what we need Let the left part of this graph consist of days and the right part consist of exams The edge between some vertices from the left part and from the right part exists iff is one of two days to pass the exam Let s apply Kuhn algorithm to this graph considering days in increasing order The first day when matching becomes all exams are in the matching will be the answer I don t know its complexity really Maybe it works too fast because of the special properties of the graph If someone can explain in which time it works I will very happy 
765,Monocarp is playing Minecraft and wants to build a wall of cacti He wants to build it on a field of sand of the size of cells Initially there are cacti in some cells of the field Monocarp can plant new cacti they must also fulfil the aforementioned condition He can t chop down any of the cacti that are already growing on the field he doesn t have an axe and the cacti are too prickly for his hands Monocarp believes that the wall is complete if there is no path from the top row of the field to the bottom row such that each two consecutive cells in the path are adjacent by side no cell belonging to the path contains a cactus Your task is to plant the minimum number of cacti to build a wall or to report that this is impossible ,In order to block any path from the top row to the bottom row you have to build a path from the left side to the right side consisting of Since two consecutive cacti in a path cannot be placed side by side they should be placed diagonally i e should be followed by on the path So we can rephrase the task as a shortest path problem The edge weight is if cactus is already in the cell that corresponds to the end of the edge and otherwise Don t forget that some cells can t contain a cactus thus be part of a path because of the cacti initially placed The shortest path can be found using Dijkstra s or 0 1 BFS algorithm ,Firstly if is odd then the answer is by obvious reasons Otherwise we can notice that the top left and the bottom right values of the tile do not matter since we can place tiles symmetrically So we only need to check that there is some tile that its top right value equals its bottom left value because this is how we get main diagonal symmetry 
766,Vasya decided to go to the grocery store He found in his wallet coins of burle and coins of burles He does not yet know the total cost of all goods so help him find out the positive integer amount of money he pay without change or pay at all using only his coins For example if and he has one burle coin and one burle coin then he can pay burle without change paying with one burle coin he can pay burle without change paying with one burle coin he can pay burle without change by paying with one burle coin and one burle coin he cannot pay burle without change moreover he cannot pay this amount at all So for and the answer is ,If Vasya has coins of burles then he can collect amounts of burls If Vasya does not have burles coins then he cannot collect the amount of burle If he has at least one coin in burl he can score odd amounts up to The following burl coins increase the maximum amount he can make If Vasya has coins for burle he can make up the amount of burles and not anymore ,At first consider the problems on candies and oranges independently Then it s pretty obvious that for candies the optimal way is to decrease all to the value we need obtain at least this value to equalize all the elements and there is no point to decrease elements further The same works for the array Then if we unite these two problems we need to take the maximum moves we need for each because we need exactly that amount of moves to decrease to and to simultaneously So the answer is 
767,Consider a segment of the coordinate line There are lanterns and points of interest in this segment For each lantern you can choose its power an integer between and inclusive A lantern with coordinate illuminates the point of interest with coordinate if is less than or equal to the power of the lantern A way to choose the power values for all lanterns is considered if every point of interest is illuminated by at least one lantern You have to process queries Each query is represented by one integer To answer the th query you have to add a lantern on coordinate calculate the number of valid ways to assign power values to all lanterns and print it modulo remove the lantern you just added ,Let s start without the queries How to calculate the number of ways for the given lanterns First it s much easier to calculate the number of bad ways some point of interest is not illuminated If at least one point of interest is not illuminated then all lanterns have power lower than the distance from them to this point of interest More importantly it s less than Thus the number of good ways is minus the number of bad ways Let s use inclusion exclusion For a mask of non illuminated points of interest let s calculate the number of ways to assign the powers to the lanterns in such a way that at least these points of interest are not illuminated All other points can be either illuminated or not Let s call it With the values for all masks the answer is the sum of over all masks How to calculate the value for the mask First let s do it in for each mask Each lantern can have any power from to the distance to the closest point of interest inside the mask non inclusive Thus we can iterate over the lanterns and find the closest point to each of them then multiply the number of ways for all lanterns Let s calculate it the other way around Initialize the answers for the masks with Then iterate over the lantern and the point of interest that will be the closest non illuminated one to this lantern Let the distance between them be some value Which masks will this pair affect Let the lantern be to the right of that point of interest The opposite can be handled similarly All points to the left of the chosen point can be in either state All points between the chosen one and the lantern must be illuminated All points to the right of the lantern and with distance smaller than must also be illumunated All point to the right of these can be in either state Thus the masks look like 1000 000 where 1 denotes the chosen non illuminated point All masks that correspond to this template will be multiplied by You have to be careful when there are two points of interest with the same distance to some lantern one to the left of it and one to the right of it In particular in one case you should force illumination on all points with distance In another case you should force illumination on all points with distance How to multiply fast enough We ll use a technique called sum over subsets Let s express the template in terms of submasks For a template 100000 all submasks of 111100000111 will be multiplied by However we accidentally multiplied masks of form 000000 too Let s cancel them by dividing the submasks of 111000000111 by Record all multiplications for all pairs them force push them into submasks with sum over subsets well product over subsets in this case Now we have the values of for all masks in basically give or take the time to find the points that must be forced illuminated extra from lower bound or two pointers which is not really faster Now for the queries How does the answer change after an extra lantern is added Again let s iterate over the closest point of interest and find the mask template All masks corresponding to this template will get multiplied by Thus the answer will change by the sum of values of these masks multiplied by including the inclusion exclusion coefficient How to handle that Well yet another sum over subsets Just collect the sum of values over the submasks beforehand and use these during the query That gives us an per query Overall complexity ,Without loss of generality let s say otherwise we can swap them Note that you can t use more than packets at least one red bean in each packet so can t exceed at most blue beans in each packet So if then asnwer is Otherwise we can form exactly packets 
768,You have a set of discs the th disc has radius Initially these discs are split among towers each tower contains at least one disc and the discs in each tower are sorted in descending order of their radii from bottom to top You would like to assemble one tower containing all of those discs To do so you may choose two different towers and each containing at least one disc take several possibly all top discs from the tower and put them on top of the tower in the same order as long as the top disc of tower is bigger than each of the discs you move You may perform this operation any number of times For example if you have two towers containing discs and in order from bottom to top there are only two possible operations move disc from the first tower to the second tower so the towers are and move discs from the first tower to the second tower so the towers are and Let the of some set of towers be the minimum number of operations required to assemble one tower containing all of the discs For example the of the set of towers is you may move the disc to the second tower and then move both discs from the second tower to the first tower You are given queries Each query is denoted by two numbers and and means merge the towers and that is take all discs from these two towers and assemble a new tower containing all of them in descending order of their radii from top to bottom The resulting tower gets index For each calculate the of the set of towers after the first queries are performed ,First of all let s try to find a simple way to evaluate the difficulty of a given set of towers I claim that the difficulty is equal to the number of pairs of discs that belong to different towers during each operation we can merge at most one such pair if we move discs to the tower with disk on top of it only the pair can be affected we can always take the first several discs belonging to the same tower and move them to the tower containing disc thus merging exactly one pair in exactly one operation After that there are two main approaches LCA and small to large merging The model solution uses LCA so I ll describe it For each pair we have to find the first moment these discs belong to the same tower To do so let s build a rooted tree on vertices The vertices to will be the leaves of the tree and will represent the original towers The vertex will represent the tower created during the th query and will have two children the vertices representing the towers we merge during the th query The vertex is the root Now if some vertex is an ancestor of vertex it means that the tower represented by vertex contains all the discs from the tower represented by vertex So to find the first tower containing two discs and we have to find the lowest common ancestor of the vertices representing the towers and The easiest way to do it is to implement something like binary lifting which allows us to solve the problem in ,Let s store for each vertex the minimum distance from it to the nearest one let s call it We will also store the global answer which for obvious reasons does not increase we will call it Let s now color the vertex let s set and run a depth first search from it This DFS will visit the vertices with Let us consider the vertex and its neighbour If we can relax through let s do it and start from Otherwise has a closer neighbour let s try to update the answer through it Also do not forget to update the answer via from all vertices that we visited The correctness of the algorithm is obvious let s evaluate its time complexity It is easy to notice that after the first operations We enter only the vertices from which firstly does not exceed and secondly was relaxed by the parent that is decreased by at least So we allowed ourselves a complete tree bypassing for the first operations and then amortized performed no more than operations The final asymptotics will be 
769,The robot is placed in the top left corner of a grid consisting of rows and columns in a cell In one step it can move into a cell adjacent by a side to the current one The robot can t move outside the grid The cell contains a deadly laser If the robot comes into some cell that has distance less than or equal to to the laser it gets evaporated The distance between two cells and is Print the smallest number of steps that the robot can take to reach the cell without getting evaporated or moving outside the grid If it s not possible to reach the cell print The laser is neither in the starting cell nor in the ending cell The starting cell always has distance greater than to the laser ,First let s determine if it s possible to reach the end at all If the laser s field doesn t span until any wall then it s surely possible just stick to the wall yourself If it touches at most one wall it s still possible If it s the bottom wall or the left wall then take the path close to the top and the right wall Vice versa if it s the top wall or the right wall then take the path close to the bottom and the left wall What if both of these paths are locked That means that the laser touches at least two walls at the same time the top one and the left one or the bottom one and the right one Turns out it s completely impossible to reach the end in either of these two cases Just draw a picture and see for yourself Thus we can always take at least one of the path sticking to the walls The distance from the start to the end is and both of these paths are exactly this long So the answer is always either or To check if the laser touches a wall with its field you can either use a formula or check every cell adjacent to a wall Overall complexity or per testcase ,The constraints tell us that the solution should be linear or pretty close to it Well in particular that implies that the solution almost certainly isn t dynamic programming since we have both and to care about Thus we ll think about something greedy When we know the number of move the game will last we can tell how many steps each chip should make Well since the more moves the game last the more steps each ship makes the answer is a monotonic function Let s apply binary search and think if we can check if each chip can make some known number of steps A common idea in the problems where you have to do something greedily on a tree is to root the tree arbitrarily and process everything bottom up Consider the bottommost chip If it can move its number of moves downwards it s always optimal to do that Since it s the bottommost chip it can only make things worse for chips above it And any of them can t pass through the initial vertex of this chip anyway If it can t it has to move to its parent vertex Let s move it there and deal with this chip later when it becomes the bottommost again If it can t move to its parent it can t move at all Thus the game can t last for this many steps Since we only apply either the move which is guaranteed to not interrupt any other moves or the move which is forced the greedy strategy is correct As for implementation details it s not too tricky Basically for each vertex we should maintain these values if this vertex has been visited the number of steps the chip in this vertex still has to make if any chip is in this vertex the longest path downwards from this vertex via non visited vertices The second value can be initialized beforehand and pushed to the parent when needed The rest of them are easily maintained with a single dfs Overall complexity per testcase 
770,You are given an undirected graph with vertices numbered from to Initially there are no edges You are asked to perform some queries on the graph Let be the answer to the latest query of the second type it is set to before the first such query Then the queries are the following add an undirected edge between the vertices and if it doesn t exist yet otherwise remove it check if there exists a path between the vertices and which goes only through currently existing edges and set to if so and otherwise Good luck ,The problem directly tells you do solve some kind of Dynamic Connectivity Problem You could use the online approach with Link Cut Tree if you d had its implementation beforehand There is also a nice modification to the solution of the offline version of DCP check out the comment I d tell the solution which is probably the easiest to come up with and to code Let s recall the sqrt optimization method of solving DCP Process blocks of queries of size one at a time Split the edges into two groups The edges which were added on queries before the block and aren t touched by the queries in the block the edges modified by the queries in the block The first type of edges can be added to the graph before the block processing starts You can use DSU for that The second type contains no more than edges Maintain the list of those of them which exist in the graph On each ask query add them to graph then delete them This can be done explicitly by doing DFS only over these edges and the vertices which correspond to the connected components on the edges of the first type Implicitly doing DSU merges for these edges and rolling them back is a viable option as well costs extra log factor but has lower constant It s easy to see that it isn t hard to modify this solution to our problem Let s define the edges of the first type more generally the edges which were added on queries before the block and touched by the queries in the block So neither from the add query nor could be of the first type Now there might be edges of the second type in the list However that doesn t make the complexity any worse Process block the same way rebuild the DSU with the edges of the first type every queries The overall complexity can be if you use DFS or if you use DSU notice how the rebuild is and the query is and set the size of the block so that these parts are about the same ,WLOG assume all queries ask to move from a lower layer to a higher layer The first thing to notice in the problem is that it is always optimal to never go down a layer You have an optimal path that is going down some layers and then returning to the same layer So it leaves a layer in some its cell and returns to it in some other cell or the same one The best distance it can achieve is the Manhattan distance between these two cells However we can also achieve the Manhattan distance by just going along this layer and the answer will be at least as optimal If the query asks about the cells of the same layer just answer with the Manhattan distance Otherwise we can describe the path as follows go from the first cell to some door on its layer enter the door and go to another door on the next layer so on until the layer of the second cell where you go from a door to the second cell Thus we could potentially write the shortest distance from the start to the th door of the th layer Initialize both doors of the first layer take the best answer from the both doors of the last layer That would be per query which is too slow Let s optimize it with some precalculations In particular we want to know the shortest distance between one door of some layer and one door of another layer We can use the technique similar to binary lifting Calculate the distance between a pair of doors on layers which are apart for all up to Let be the distance from door of layer to door of layer can be initialized straightforwardly Then to calculate we can use the values for and for some intermediate door on layer To obtain the answer use jumps to reach the layer one before the last one Then iterate over the last door Alternatively you could pack this dynamic programming into a segment tree use divide and conquer on queries or do square root decomposition Overall complexity 
771,You are given chips on a number line The th chip is placed at the integer coordinate Some chips You can perform each of the two following types of moves any possibly zero number of times on any chip Move the chip by to the left or to the right i e replace the current coordinate with or with move the chip by to the left or to the right and pay for this move i e replace the current coordinate with or with Note that it s allowed to move chips to any integer coordinate including negative and zero Your task is to find the minimum total number of coins required to move all chips to the same coordinate i e all should be equal after some sequence of moves ,We can see that the only information we need is the parity of the coordinate of each chip because we can move all chips that have the same parity to one coordinate for free So if the number of chips with odd coordinate is then the answer is ,It s not hard to come up with a solution if you just imagine how gon looks when is even The solution is to rotate gon in such way that several its sides are parallel to sides of the square And the answer is equal to the distance from center to any side multiplied by two or 
772,You are given two strings and In a single move you can choose any of two strings and delete the first that is the leftmost character After a move the length of the string decreases by You can t choose a string if it is empty For example by applying a move to the string the result is the string by applying a move to the string the result is an empty string You are required to make two given strings equal using the fewest number of moves It is possible that in the end both strings will be equal to the empty string and so are equal to each other In this case the answer is obviously the sum of the lengths of the initial strings Write a program that finds the minimum number of moves to make two given strings and equal ,Let s find the value the length of the longest common suffix of and You can easily find it in one linear loop just compare the last letters of and If they are equal then compare before the last letters of and And so on The last letters of and are two equal strings which will be the result of after optimal moves So the answer is ,Suppose we build the string from left to right and when we place the i th character we ensure that all substrings are valid What do we need to know in order to calculate the number of different characters in the string ending with the i th character Suppose the character s i is Let s try going to the left of it The string from i to i will have the same characters but if there is at least one character before the i th position the string s 1 s 2 s 3 dots s i will have two different characters What about the strings in the middle The string s j s j 1 dots s i will contain different characters if and only if there is at least one in j i since s i is so we are actually interested in the position of the last character before i The same logic applies if the character s i is we are only interested in the position of the last before i and it is enough to check if all substrings ending with the i th character are violated What if when we choose the i th character we violate some substring that doesn t end in the i th position Well you could also check that or you could just ignore it Actually it doesn t matter if this happens because it means that the substring that is violated ends in some position k i and we will check it when placing the k th character So the solution can be formulated with the following dynamic programming let dp i j be the number of ways to choose the first i characters of the string so that the last character different from s i was s j or j 0 if there was no such character and all the constraints on the substrings ending no later than position i are satisfied The transitions are simple you either place the same character as the last one going from dp i j to dp i 1 j or a different character going from dp i j to dp i 1 i and when you place a character you check all the constraints on the substrings ending with the i th position Note that the state dp 1 0 is actually represented by two strings and This solution works in O n 3 although O n 4 or O n 2 implementations are also possible 
773,Polycarp has an array of is even integers Polycarp conceived of a positive integer After that Polycarp began performing the following operations on the array take an index and reduce the number by After Polycarp performed some possibly zero number of such operations it turned out that of the numbers in the array became the same Find the maximum at which such a situation is possible or print if such a number can be arbitrarily large , can be arbitrarily large if and only if at least half of the numbers in the array are the same In this case we can choose any number and subtract it from all numbers for example exactly once Let s iterate over the element it will be the minimum among the numbers that we want to make the same Let s calculate the number of numbers in the array that are equal to this element If this number is at least then the answer is Otherwise we will iterate over numbers which are strictly greater than the selected minimum and for each number we will iterate over the divisors of the number For each of the found divisors let s calculate the number of for which this divisor was found Among all such divisors for which the sum of the found number and the number of numbers equal to is greater than or equal to we will choose the maximum one The greatest found divisor will be the desired This solution works in where is the absolute value of the maximum on the array ,Note is that after doing two operations of the same type they are cancelled out in terms of parity since we would change the parity of all elements once then change it back again So we know that we will do each operation exactly or time It is possible to check all possible cases just by simulating or we can notice that all elements on all indices of the same parity have the same parity and if they do we can always find an answer by doing just a single type of operation a single time in case the array doesn t already contain all elements of the same parity The time complexity is 
774,A team of three programmers is going to play a contest The contest consists of problems numbered from to Each problem is printed on a separate sheet of paper The participants have decided to divide the problem statements into three parts the first programmer took some prefix of the statements some number of first paper sheets the third contestant took some suffix of the statements some number of last paper sheets and the second contestant took all remaining problems But something went wrong the statements were printed in the wrong order so the contestants have received the problems in some random order The first contestant has received problems The second one has received problems The third one has received all remaining problems The contestants don t want to play the contest before they redistribute the statements They want to redistribute them so that the first contestant receives some prefix of the problemset the third contestant receives some suffix of the problemset and the second contestant receives all the remaining problems During one move some contestant may give one of their problems to other contestant What is the minimum number of moves required to redistribute the problems ,Suppose we want to divide first problems of the contest between the first contestant and the second contestant the first contestant will get first problems and the second contestant will get problems in the middle and then give all the remaining problems to the third contestant We are going to iterate on from to and for each possible find the best value of Okay Now suppose we fixed and and now we want to calculate the number of problems that should be redistributed Let s denote as the number of problems among first ones given to the th contestant as the number of problems among last ones given to the th contestant and as the number of problems in the middle given to the th contestant Obviously the answer for fixed and is but we don t like this expression because we don t know how to minimize it for fixed We know that for fixed the values of and are constant Using that we may arrive at the fact that minimizing is the same as minimizing for fixed and now we have a way to quickly find best possible for fixed ,You only need to write an if statement and check if any of these are true 
775,Alice is a composer and recently she had recorded two tracks that became very popular Now she has got a lot of fans who are waiting for new tracks This time Alice wants to form four melodies for her tracks Alice has a sheet with notes written on it She wants to take four such non empty non intersecting subsequences that all of them form a and sum of their lengths is maximal Subsequence forms a melody when each two adjacent notes either differ by or are congruent modulo You should write a program which will calculate maximum sum of lengths of such four non empty non intersecting subsequences that all of them form a melody ,Let s build a directed graph where vertices represent notes and a directed edge comes from vertex to vertex iff and and can be consecutive notes in a melody Now we have to find four longest vertex disjoint paths in this graph This problem can be solved with mincost flow algorithms We build a network where each vertex of the graph is split into two let s denote the vertices that we obtain when we are splitting some vertex as and Then each directed edge transforms into a directed edge from vertex to vertex in the network the capacity of this edge is and the cost is Also we add directed edges from the source to every vertex and from every vertex to the sink they have the same characteristics capacity is cost is And for each we add a directed edge between and these edges actually represent that we are using some note in a melody so their capacities are also equal to and their costs are The answer to the problem is equal to the absolute value of minimum cost of flow in this network The bad thing is that the network is really large So we have to use some advanced mincost algorithm here Model solution uses Dijkstra s algorithm with Johnson s potentials to find augmenting paths of minimum cost We set a number for each vertex of the network these numbers are called potentials Then we modify costs of the edges if some edge had cost now it s cost is It s easy to prove that if some path from vertex to vertex was the shortest one between these vertices without modifying the costs with potentinals then after modifying it will also be the shortest between these vertices So instead of looking for an augmenting path in the original network we can try looking for it in a network with modified edges Why Because it is always possible to set all potentials in such a way that all costs of edges will be non negative and we will be able to use Dijkstra to find the shortest path from the source to the sink Before looking for the first augmenting path we calculate potentials recursively we check all s such that there is an edge in the network The network is acyclic before we push flow so there is always a way to calculate these potentials with dynamic programming Then each time we want to find an augmenting path we run Dijkstra s algoritm on modified network push flow through the path we found and modify the potentials new potential of each vertex becomes where is the distance between the source and vertex in the modified network and we found this distance with Dijkstra When we have found four augmenting paths we are done and it s time to evaluate the cost of the flow ,Consider a naive solution using Kruskal s algorithm for finding MST Given some you arrange the edges in the increasing order of and process them one by one Look closely at the arrangements At the edges are sorted by How does the arrangement change when increases Well some edges swap places Consider a pair of edges with different weights and Edge will go before edge in the arrangement as long as is closer to than So for all up to edge goes before edge And for all from onwards edge goes before edge This tells us that every pair of edge with different weights will swap exactly once So there will be at most swaps Which is at most different arrangements Each of them corresponds to some range of s We can extract the ranges of s for all arrangements and calculate MST at the start of each range We can also find the arrangement that corresponds to some from a query with a binary search However only knowing the weight of the MST at the start of the range is not enough The weights of edges change later in the range and we can t predict how Some edges have their weight increasing some decreasing First let s add more ranges We want each edge to behave the same way on the entire range either increase all the way or decrease all the way If we also add for all into the MST calculation this will hold Second let s store another value for each range the number of edges that have their weight increasing on it With that we can easily recalculate the change in the cost of the spanning tree The TL should be free enough for you to sort the edges for each MST calculation resulting in solution You can also optimize the first part to 
776,You are given sequence of integer numbers of length Your task is to find such subsequence that its sum is odd and maximum among all such subsequences It s guaranteed that given sequence contains subsequence with odd sum Subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements You should write a program which finds sum of the best subsequence ,The answer to this problem can be constructed this way Sum up all positive numbers Find maximum of negative odd numbers Find minimum of positive odd numbers If sum was even then subtract Overall complexity ,As you can see from the example the maximum answer doesn t exceed So we can run some precalculation before all queries which will find all less than The number is if it has no in the ternary numeral system When you read the next query you can increase until you find some precalculated Time complexity is You also can implement the solution which doesn t use any precalculations and just increase each time in each query and checks if the number is inside this loop Then time complexity will be 
777,There are districts in the town the th district belongs to the th bandit gang Initially no districts are connected to each other You are the mayor of the city and want to build two way roads to connect all districts two districts can be connected directly or through other connected districts If two districts belonging to the same gang are connected with a road this gang will revolt You don t want this so your task is to build two way roads in such a way that all districts are reachable from each other possibly using intermediate districts and of directly connected districts belong to or determine that it is impossible to build roads to satisfy all the conditions You have to answer independent test cases ,If all districts belong to the same gang then the answer is Otherwise the answer is always yeah as in the previous problem How to construct it Let s choose the first root as the district and connect all such districts that to the district So all disconnected districts that remain are under control of the gang Let s find any district that and just connect all remaining districts of the gang to this district This district always exists because we have at least two different gangs and it is connected to the remaining structure because its gang is not So all conditions are satisfied ,Let s divide all valid pairs into three categories the ones containing only edges on the path the ones containing only edges and the ones containing both types of edges To calculate the number of pairs containing only edges we may build a forest on the vertices of the original graph and edges and choose all pairs of vertices belonging to the same connected components of this forest we can find all connected components with DSU or any graph traversal algorithm The same can be done for the pairs containing only edges If a path from to is valid and contains both types of edges then there exists a vertex such that the simple path from to goes only through edges and the simple path from to goes only through edges So let s iterate on this vertex and choose some other vertex from its component in graph as and some other vertex from its component in graph as and add the number of ways to choose them to the answer 
778,There is a chess board of size The rows are numbered from to the columns are numbered from to Let s call a cell if a knight placed in that cell can t move to any other cell on the board Recall that a chess knight moves two cells in one direction and one cell in a perpendicular direction Find any cell on the board If there are no such cells print any cell on the board ,Let s consider some cases If at least one of or are then all cells are isolated A knight can t move one in a perpendicular direction If at least one of or are at least then the knight always has at least one move No matter where you place it it can move two cells along the greater of the dimensions and move one in a perpendicular direction because it s at least Three cases are left and For all of these cases the middle cell is isolated That cell is Since it doesn t matter which cell you print in the first two cases you can always print Overall complexity per testcase Alternatively you can check every possible cell Iterate over a cell and check all eight possible knight moves from it If none are inside the board the cell is isolated Overall complexity per testcase ,This one is a pure implementation task Just check every possible line of length If the current one contains crosses and empty cell then the answer is 
779, fishermen have just returned from a fishing vacation The th fisherman has caught a fish of weight Fishermen are going to show off the fish they caught to each other To do so they firstly choose an order in which they show their fish each fisherman shows his fish exactly once so formally the order of showing fish is a permutation of integers from to Then they show the fish they caught according to the chosen order When a fisherman shows his fish he might either become happy become sad or stay content Suppose a fisherman shows a fish of weight and the maximum weight of a previously shown fish is if that fisherman is the first to show his fish Then if the fisherman becomes happy if the fisherman becomes sad if none of these two conditions is met the fisherman stays content Let s call an order in which the fishermen show their fish if after all fishermen show their fish according to this order each fisherman becomes either happy or sad Calculate the number of orders modulo ,First of all sort the fishermen so it is easier to consider them in ascending order The key observation that allows us to solve the problem is the following there will be an increasing sequence of happy fishermen and all other fishermen will be unhappy Consider the fisherman which belongs to the increasing sequence Let s analyze which fisherman will be next to it in the order It is either a fisherman that will be happy or a fisherman that will be sad In the first case the fish caught by this fisherman must have a size of at least in the second case at most The first case will be considered later For the second case if we know the number of fishermen that were already placed in the order we know that all of them except the th one belong to the sad category that is the fish of every already placed fisherman except for the th one is at least two times smaller than the fish of the th fisherman So if we have already placed fishermen the last happy fisherman was the th one and we want to place a sad fisherman then the number of ways to choose this sad fisherman is exactly where is the number of fishermen such that If we can handle the first case this observation will allow us to solve the problem with dynamic programming Let be the number of ways to choose first fishermen in the order so that the th fisherman is the last happy one The case when the next fisherman is sad can be handled with a transition to the state don t forget to multiply by the number of ways to choose the next sad fisherman as described earlier What about the case when the next fisherman is happy We should iterate on the fisherman such that and transition from to but this part works in To get an solution we have to speed it up with prefix sums or something like that ,Let s maintain the pointer to the topmost non deleted book and whether each book whether is removed from the stack or not Initially all books are in a stack and is 0 if we store the array 0 indexed We will process the array in the order If the current book is removed from the stack then the answer for it is zero Otherwise we will increment the pointer until the equality is satisfied while marking all the intermediate books in the array After that the answer for the book will be the number of marked books in the array including itself Since the pointer shifts times at total we get a solution with an complexity 
780,You re given a tree with vertices The color of the th vertex is The value of the tree is defined as where is the number of edges on the shortest path between and The color of each vertex is lost you only remember that can be any integer from inclusive You want to calculate the sum of values of all trees meeting these conditions modulo the set of edges is fixed but each color is unknown so there are different trees ,Let s set the root as Define as the lowest common ancestor of vertices and as the depth of vertex Obviously The answer we want to calculate is where represent all possible colorings of the tree We can enumerate the color For a fixed color we need to calculate Let Also denote as a predicate which is true iff Now our problem is how to maintain this formula while enumerating the color can be easily maintained For we can add to all vertices in path to for each existing vertex and when new vertex is added just calculate the sum of vertices on path from to minus the contribution of vertex because there are vertices in the path to and multiply it Similar operation can be used to handle the situation when some vertex disappears All of this can be done with HLD Overall it s ,For each vertex we will build the following structure for its children the segment for the second child is nested in the segment for the first child the nested for the third child is nested in the segment for the second child and so on and the children of different vertices do not intersect at all Let s solve the problem recursively for each of the children create a set of segments with endpoints from to where is the size of the subtree After that combine them To do this you can use small to large technique and change the coordinates of the segments or use the necessary offset in the function call for the next child After that it remains to cross children s segments with the segment of the vertex itself To do this you can move the right ends of all segments of the children by to the right and add a segment that starts before the first one and ends immediately after the last one 
781,Find an matrix with different numbers from to so the sum in each row column and both main diagonals are odd ,The solution can be got from the second sample testcase Easy to see that if we place all odd numbers in the center in form of rhombus we will get a magic square ,I am sorry that some solutions pass tests in this problem also I was supposed to increase constraints or decrease time limit The general idea of this problem is the same as in the previous problem But now we should do all what we were doing earlier faster The solution is divided by two parts The first part Let s calculate four matrices of size and will denote the distance to the nearest dot character to the top from the current position The same will denote the distance to the nearest dot character to the bottom from the current position to the left and to the right We can calculate all these matrices in using easy dynamic programming If we will iterate over all possible from to and from to we can easy see the next if the current character is dot then Otherwise if then and if then Rest two matrices can be calculated the as well as these two matrices but we should iterate over all from to and from to So this part of the solution works in After calculating all these matrices the maximum possible length of rays of the with center in position is The second part is to draw all in Let s calculate another two matrices of size and Let s iterate over all in our answer Let the center of the current is and its size is Let s increase by one and decrease by one if The same with the matrix Increase and decrease if Then let s iterate over all possible from to and from to If then set and if set How to know that the character at the position is asterisk character or dot character If either or greater than zero then the character at the position in our matrix will be the asterisk character Otherwise it is the dot character This part works also in Time complexity of the solution 
782,You are given two strings and consisting of lowercase Latin letters The length of is i e this string consists only of two characters In one move you can choose character of and replace it with lowercase Latin letter More formally you choose some and replace the character at the position with some character from to You want to do replacements in such a way that the number of occurrences of in as a Recall that a subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements ,I m almost sure this problem can be solved faster and with greater constraints but this version is fine for the last problem Consider both strings indexed and let s do the dynamic programming It means the maximum number of occurrences of if we considered first characters of did moves and the number of characters is The answer to the problem is Initially all states are and is What about transitions There are essentially three types of them don t change the current character change the current character to and change the current character to Let s create three additional variables to make our life easier if that were true is if and otherwise is if and otherwise and is if and otherwise Now let s make and describe our transitions Don t change the th character The expression is just ternary if statement if is true return otherwise return So the number of characters increases if equals and the answer increases if the th character equals because we added all occurrences that end in the th character Change the th character to possible only when The number of characters always increases and the answer increases if equals by the same reason as in the previous transition Change the th character to possible only when The number of characters increases only if and the answer always increases Note that we always increase the number of moves in the second and the third transitions even when equals or because this case is handled in the first transition so we don t care Time complexity There are also some greedy approaches which work in with pretty small constant and can be optimized even further ,On every step you should maintain minimal alphabetic letter in current string this can be done by keeping array of 26 cells with number of times each letter appear in string nd updating it on every step Let s call string a stack and use its terms Now you extract letters from one by one Put the letter to the top of the stack Pop letters from the top of stack and push them to answer while they are less or equal than any letter left in string After string becomes empty push all the letters from stack to answer The answer will be lexicographically minimal It is obvious if we consider the case when current top of stack is strictly greater than any character from the remaining string or there is a character in that is strictly less than current top If current top is equal to some character then appending answer with the letter from top won t make answer worse Overall complexity where is the length of the alpabet in our case 
783,A string of length can be encrypted by the following algorithm iterate over all divisors of in decreasing order i e from to for each divisor reverse the substring i e the substring which starts at position and ends at position For example the above algorithm applied to the string leads to the following changes obviously the last reverse operation doesn t change the string because You are given the encrypted string Your task is to decrypt this string i e to find a string such that the above algorithm results in string It can be proven that this string always exists and is unique ,To solve the problem we can implement the encryption algorithm with a single change we have to iterate over all divisors of in increasing order Time complexity where is a divisor count function for For example ,Let s represent as and as where and By definition so we can represent as Now we can rewrite the equation from the statement as follows Since the left hand side is divisible by the right hand side should also be divisible So we can iterate over as divisors of If the right hand side of is not divisible by then we can skip such let s denote as If has some prime divisor then exactly one of and should be divisible by because and have no common divisors So there are pairs of and for current value of We can precalculate the minimum prime divisor for each number up to the maximum value of that you may need in using Eratosthenes sieve Now we can solve the problem in for each testcase but that s not fast enough To speed up this approach we can precalculate the number of prime divisors for each number up to Let s denote as the minimum prime divisor of and as the number of prime divisors of Then plus if Now to solve the problem we only need to iterate over the divisors of so the time complexity is per testcase 
784,Nastya baked pancakes and spread them on dishes The dishes are in a row and numbered from left to right She put pancakes on the dish with the index Seeing the dishes Vlad decided to bring order to the stacks and move some pancakes In one move he can shift one pancake from any dish to the closest one that is select the dish and do one of the following if put the pancake on a dish with the previous index after this move and if put the pancake on a dish with the following index after this move and Vlad wants to make the array after moving as few pancakes as possible Help him find the minimum number of moves needed for this The array is called non increasing if for all from to ,For convenience we will calculate the prefix sums on the array we will also enter the array containing the indexes of all pancakes and calculate the prefix sums on it Let s use dynamic programming Let s define as the required number of operations to correctly lay out the th prefix with the final and Then you can go to from the previous number must be greater and the sum is fixed To it will be necessary to add a certain number of actions necessary to get let s call it all the terrible prefix sums are needed to count it Since depends only on and we only need to choose the minimum the choice can be optimized by suffix minima As a result the solution works for that s how many states need to be processed ,When using th coupon the bar we get for free should have at least bars not cheaper than it So if we consider sorted in non decreasing order then we cannot get discount greater than On the other hand we can always get such a discount if we pick most expensive bars to buy using the th coupon 
785,You are given an array consisting of integers Initially all other elements are equal to You have to perform operations During the th operation you choose two indices and such that and swap and Calculate the number of indices such that it is possible to choose the operations so that in the end ,Let s consider how the set of possible indices where the can be changes Initially only one index is correct After performing an operation such that or this set does not change But after performing an operation such that we should insert the elements into this set if they are not present Now consider how the set changes If segments and do not share any indices there are no changes but if they do the set turns into So the set of reachable indices is always a segment of numbers and to process an operation we should check whether the segment from operation intersects with the segment of indices we have and if it is true unite them ,Firstly let s compress the moments of time Note that storing only and isn t enough consider pairs and you also should take Now moments of time are up to For every moment calculate the number of segments to cover it make and for each segment and take prefix sums over this array Then let be the number of moments of time covered by only one segment on some prefix up to th moment And finally if for some segment from the input is then you can safely delete this segment Overall complexity 
786,Petya recently found a game Choose a Square In this game there are points numbered from to on an infinite field The th point has coordinates and cost You have to choose a square such that its sides are parallel to coordinate axes the lower left and upper right corners belong to the line and all corners have integer coordinates The score you get is the sum of costs of the points covered by the selected square minus the length of the side of the square Note that the length of the side can be zero Petya asks you to calculate the maximum possible score in the game that can be achieved by placing exactly one square ,Notice that the square covers the point if and only if Using this fact let s reformulate the problem the following way we have to find the segment such that the sum of the segments fully covered by it is maximal Let s build a segment tree the th of its leaves stores the sum of the segments covered by the segment Initially it s built for some such that it is to the right of all segments Other nodes store the maximum in them Now let s iterate over the values of in descending order Let there be some segment starting in with the cost All the answers for won t change because they don t cover that new segment And the values on the suffix from the position will increase by The only thing left is to learn how to handle the subtraction of the length of the side That term is and the thing we are looking for is Rewrite it in form and you ll see that you can just subtract from the value of the th leaf of the segment tree at the beginning to get the correct result Surely you ll need to add that after you ask the maximum of all the segtree to obtain the answer You ll probably need to compress the coordinates leave only such positions that there is at least one or Implicit segtree might work but neither ML nor TL are not friendly to it Also be careful with the case with all points being negative ,One possible solution involves the method of dynamic programming As a state of DP we will use the number of already placed segments and the distance from the end of the last segment to the current left boundary of the coverage and in the DP we will store the minimal possible distance from the end of the last segment to the current right boundary of the coverage We can prove that the answer never exceeds where is the maximal length of the segments To do this let us define a region of length specifically the segment If the end of the last segment has a coordinate we put the next segment to the left otherwise we put it to the right With this algorithm none of the end endpoints of the segments will go beyond the marked boundaries because to do so the segment must be placed from the coordinate of one sign beyond the boundary of the opposite sign and thus must have a length greater than which contradicts how we defined Using this fact we will consider the DP for and as the minimum distance between the end of the th segment and the right boundary of the axis coverage of the first segments when the distance to the left boundary of the coverage equals to The end of the th segment here is the beginning of the first one that is the point The base of DP is since when no segments are placed the coverage boundaries and the current point are all coincident Next we consider the forward dynamic programming relaxation for every there are two cases to consider the case of the next segment being placed to the left and the case of it being placed to the right value below refers to the distance to the right boundary of the coverage and is an alias for If a segment of length is placed to the left side then the new distance to the left boundary will be equal to and distance to the right boundary will always be which gives us the relaxation formula If a segment of length is placed to the right side then the new distance to the right boundary will be equal to and distance to the left boundary will always be which gives us the relaxation formula The values in array can be calculated in ascending order by Then the answer for the problem can be found as the minimum sum of and in the last row of that is The time complexity is 
787,A sequence is called good if for each element there exists an element such that is a power of two that is for some non negative integer For example the following sequences are good for example for we can choose Note that their sum is a power of two Similarly such an element can be found for and Note that by definition an empty sequence with a length of is good For example the following sequences are not good for it is impossible to find another element such that their sum is a power of two for it is impossible to find another element such that their sum is a power of two for it is impossible to find another element such that their sum is a power of two You are given a sequence What is the minimum number of elements you need to remove to make it good You can delete an arbitrary set of elements ,You should delete only such for which there is no such that is a power of For each value let s find the number of its occurrences You can use simple standard data structure Do for each element Now you can easily check that doesn t have a pair Let s iterate over all possible sums and for each find calculate If for some or then a pair exists Note that in C solutions it s better to first check that is a key in and only after it calculate This needs to be done since in C when you access a key using the square brackets operator a default mapping key value is created on the absence of the key This increases both the running time and the memory consumption ,Firstly let s sort our array pay the attention that there are elements in this array not Then for 0 indexed array answer will be equal to where is an absolute value of difference between and 
788,Polycarp loves ciphers He has invented his own cipher called Repeating cipher is used for strings To encrypt the string Polycarp uses the following algorithm he writes down ones he writes down twice he writes down three times he writes down times For example if the process is So the encrypted is Given string the result of encryption of some string Your task is to decrypt it i e find the string ,There are many possible approaches in this problem I will describe one of the easiest Let s print the initial string by the following algorithm firstly init the variable Then while the encrypted string isn t empty print the first character of this string remove first characters from it and increase by one ,Suppose the number contains digits and its decimal representation is The desired number isn t greater than the number consisting of digits This number is beautiful whereas any beautiful number is at the same time beautiful so contains at most digits At the same time so contains at least digits Therefore the desired number contains exactly digits Since we search for the minimum we need to minimize first of all the first digit only then the second digit etc Therefore we need to find a prefix of the decimal representation of such that is a prefix of the decimal representation of Let s do it greedily Let s find the maximum prefix of such that contains no more than distinct numbers Suppose the prefix has the length If then is already beautiful let s output it Otherwise let s increase the prefix like a number by e g if and then we increase by the resulting prefix is All other digits let s set to zeroes e g if and then will be turned into The answer for the old is the answer for the new To get the answer for the new let s start the described procedure once again preparing the new Let s find the maximum prefix of such that contains no more than distinct numbers It s possible to do using a in which for each digit the key the number of its occurrences in the prefix is stored For an empty prefix the is empty If we increase the prefix length by we need to check that contains no more than keys and add a new key with the value or increase the value of an existing key If the length of the found prefix is equal to the length of the whole decimal representation the given number is already beautiful so the answer is Otherwise the found prefix may not be a prefix of the desired number Let s change the digits of the decimal representation of to turn it into the desired number Let s start the following procedure suppose we consider a prefix with the length equal to First let s find out is it possible to increase the first element out of the prefix i e We need to do it because if we consider the length then the prefix with the length cannot be unchanged so the element must be changed whereas it cannot be decreased because in this case we will get the number which is less than If we can increase the element so that the prefix with the length has at most distinct digits the only thing that is remained to do is to fill the remaining digits somehow greedily and output the result If we cannot increase the element let s decrease the length of the considered prefix by updating the let s decrease the value corresponding to the key by then if it s equal to we remove the key from the Consider how and under what conditions we can change and the following digits If it s impossible Suppose the considered prefix contains less than distinct digits the number of the keys in the is less than In this case we can replace the digit with the value so the prefix with the length will not contain more than distinct elements because the prefix with the length doesn t contain more than distinct elements If the prefix with the length still contains less than distinct numbers let s replace the remaining digits etc with Otherwise we can replace them with the minimum digit that occurs in the prefix with the length it may be Suppose the considered prefix contains exactly distinct digits So let s find the minimum digit that occurs in the prefix with the length and is greater than If such digit exists let s replace with it and all following digits with the minimum digit that occurs in the prefix with the length Otherwise the element cannot be increased The converted by the procedure is the answer 
789,You are given a string consisting of exactly characters and each character is either or Such strings are called Your task is to in this string with other characters to obtain a ternary string ternary string is a ternary string such that the number of characters in this string is equal to the number of characters and the number of characters and obviously is equal to the number of characters Among all possible ternary strings you have to obtain the lexicographically alphabetically smallest Note that you can neither remove characters from the string nor add characters to the string Also note that you can replace the given characters only with characters and It is that the answer exists ,Let s count how many characters and we have in the string and store it in the array Also let s count our goal array Firstly the array is The main idea of this problem is a pretty standard lexicographically greedy approach We go from left to right and try to place the minimum possible character at the current position in such a way that placing this character is not breaking conditions of our problem How can we apply this approach to this problem Firstly let s define a function What does the value of this function mean It means the number of replacements we need to reach from Let at the beginning of the program This value means the minimum number of replacements to obtain some balanced ternary string Let s maintain the variable which initially is and means the number of replacements we already made So we iterate over all positions from to Firstly let s decrease So the array maintains the current amount of characters on suffix of the string Now let s iterate over characters from to and try to place every character If the current character is needed then let s decrease and if the number of replacements will still be minimum possible after such replacement then let s place this character set and go to the next position This will form lexicographically minimum possible answer with minimum number of replacements There is another simpler solution from PikMike you can call him to explain it I just will add his code to the editorial ,Let be the number of the occurrences of the letter in the word minus the number of the occurrences of all other letters in total Since for each two words and the number of the occurrences of a letter in the word is the sum of the numbers of its occurrences in and the equality is true means the concatenation of and Consider a sequence of words A story consisting of words is interesting if and only if there s a letter such that it exactly means that there s a letter which occurs more times than all other in total So we are interested in searching for a letter such that exists a positive integer a maximal number of words such that Suppose we have a set of words that form an interesting story and where is the letter having more occurrences than all other letters in total Suppose we can add to it one of few words We had better add a word such that is maximal to be able to add more words in the future So the problem has the following solution for each letter of the Latin alphabet and for each word let s calculate Then let s iterate over all letters take a sequence and sort it in descending order Let s initialize an interesting story by a set of a single word corresponding to the first element of the sequence If there s no word such that then there s no non empty interesting story containing some words of the given set Otherwise let s take the next elements of the sequence sequentially until the sum of over all taken words is greater than zero Let s select a letter such that the corresponding taken set is maximal over all letters Finally we should print the set s size The solution consists of two phases the calculation of all works in where is the alphabet s size is the lengths of a string and building a maximal interesting story for each letter sorting and a greedy algorithm 
790,You are given a weighed undirected graph consisting of vertices and edges You should answer queries the th query is to find the shortest distance between vertices and ,Firstly let s find any spanning tree and root it at any vertex For each vertex we calculate the distance to the root let it be for vertex There are no more than edges that don t belong to the tree For each of these edges let s run Dijkstra s algorithm from some vertex incident to this edge Suppose we are answering a query If the shortest path between these vertices passes only along the edges of the tree then it can be calculated by the formula where is the lowest common ancestor of vertices and You may use any fast enough algorithm you know to calculate Otherwise there exists at least one vertex such that we ran Dijkstra s algorithm from it and it belongs to the shortest path Just iterate on every vertex for which we ran Dijkstra and update the answer with the value of where is the shortest path to the vertex from the fixed vertex ,Consider the undirected complete graph with nodes with an edge between nodes with cost Let denote the minimum possible value of the max edge of a path from to We know that by definition If the matrix is magic we can choose arbitrary such that by repeating invocations of the inequality given Also you can show that if this inequality is satisfied then the matrix is magic by choosing an and arbitrary So this shows that the matrix is magic if and only if Thus combining with we have We need a fast way to compute for all pairs This can be computed as the MST as the path in the MST minimizes the max edge between all pairs of nodes So the algorithm works as follows First find the MST on the complete graph Then the matrix is magic if and only if the max edge on the path between in the MST is exactly equal to Also you shouldn t forget to check symmetry of the matrix and diagonal for zeros P S Unfortunately we couldn t increase the value in this problem the tests already had the size about 67MB and they couldn t be given with generator So most of the users who solved this problem uses bitset s The complexity of their solution is where or 
791,Many years ago Berland was a small country where only people lived Each person had some savings the th one had burles The government considered a person as wealthy if he had at least burles To increase the number of wealthy people Berland decided to carry out several reforms Each reform looked like that the government chooses some subset of people maybe all of them the government takes all savings from the chosen people and redistributes the savings among the chosen people equally For example consider the savings as list if the government chose the st and the rd persons then it at first will take all burles and after that will return burles to the chosen people As a result the savings will become A lot of data was lost from that time so we don t know how many reforms were implemented and to whom All we can do is ask you to calculate the maximum possible number of wealthy people after several maybe zero reforms ,In fact to carry out only one reform is always enough And it s easy to prove if you make only one reform it s always optimal to take the maximum such that the average of maximums in the array is at least i e sum greater or equal to So the solution is next sort array and find the suffix with maximum length such that the sum on the suffix is at least To prove the fact about one reform we can prove another fact after each reform the sum of maximums doesn t increase for each We ll prove it in two steps The first step Let s look at some reform and form an array from the chosen elements in in descending order After the reform we ll get array where all Let s just skip the proof and say it s obvious enough that for any The second step Let fix and divide array on two parts maximums as and other elements as And let s make the same division of the array after performing the reform on and So we need to prove that Suppose elements were chosen in the reform of them were in and now in If then we can think like maximum elements from elements in were replaced by the average and other were replaced by elements from Since and any element from is greater or equal to any element from then we proved that when If then let s look at and The has chosen elements and has so and we can prove that practically in the same way as before Obviously if and then Q E D The last step is easy let s prove that the only reform is enough The answer after several reforms is clearly equal to maximums which are at least But it means that the sum of maximums is at least therefore the sum of maximums in the initial array is at least So we can make them all at least by only one reform ,Suppose the initial sum of is equal to If we perform the operation the new sum will be equal to We want the sum not to decrease or If we will get If we ll get analogically In other words array you need if sorted will have and so on And one of the variants and obviously an optimal one is just As a result since we just need to check if then we found an answer otherwise there is no counterexample 
792,You are given a huge integer consisting of digits is between and inclusive It may contain leading zeros You can swap two digits on adjacent neighboring positions if the swapping digits are of different parity that is they have different remainders when divided by For example if you can get the following integers in a single operation if you swap the first and the second digits if you swap the second and the third digits if you swap the fifth and the sixth digits if you swap the sixth and the seventh digits if you swap the seventh and the eighth digits Note that you can t swap digits on positions and because the positions are not adjacent Also you can t swap digits on positions and because the digits have the same parity You can perform any number possibly zero of such operations Find the minimum integer you can obtain ,Let s consider two sequences of digits and there is the first even digit in is the second even digit and so on and is the first odd digit in is the second odd digit and so on Since you can t swap digits of same parity the sequence of even digits of never changed Sequence of odd digits of also never changed So the first digit in the answer will be equal to or to And since we have to minimize the answer we have to chose the as the first digit in answer and them delete it from the corresponding sequence in this way sequence turn into or sequence turn into Second third and followings digits need to choose in the same way ,We need to check if the sum of the first three digits is equal to the sum of the last three digits This is doable by scanning the input as a string then comparing the sum of the first three characters with the sum of the last three characters using the if statement and the addition operation 
793,You have an array of integers initially empty You have to perform queries Each query is of one of two types add the element to the end of the array replace all occurrences of in the array with Find the resulting array after performing all the queries ,Let s solve the problem from the end Let s maintain the array what number will become if we apply to it all the already considered queries of type If the current query is of the first type then we simply add to the resulting array If the current query is of the second type then we have to change the value of Since all occurrences of must be replaced with it is enough to assign Since we process each query in the final complexity is There is also an alternative solution Let s process queries in the direct order Let s store all its positions in an array for each number Then for the first query it is enough to put the index in the corresponding array of positions And for a query of the second type we have to move all the positions of the number into an array of positions of the number The naive implementation is obviously too slow but we can use the small to large method then the complexity of the solution will be ,Let s compute an array of integers answers to all possible second type queries with Now if we have to perform any second type query we can split it into at most queries with and at most queries with Let s also compute an array of integers reverse permutation If then To perform any first type query we should recompute and We can swap and in the array and and in the array No more than elements will be changed in the array These are elements with indexes elements and elements We can recompute and then assign and times Similarly for Time complexity 
794,A tree is an undirected connected graph in which there are no cycles This problem is about non rooted trees A leaf of a tree is a vertex that is connected to vertex The gardener Vitaly grew a tree from vertices He decided to trim the tree To do this he performs a number of operations In one operation he removes leaves of the tree For example consider the tree shown in the figure above The figure below shows the result of applying exactly one operation to the tree Note the special cases of the operation applying an operation to an empty tree of vertices does not change it applying an operation to a tree of one vertex removes this vertex this vertex is treated as a leaf applying an operation to a tree of two vertices removes both vertices both vertices are treated as leaves Vitaly applied operations sequentially to the tree How many vertices remain ,Let s create two arrays of length The element of the array will contain the operation number at which the vertex which is the index of the array will be deleted The array will contain the number of neighbors of a given vertex at a certain time This array must be initialized with the number of neighbors in the original tree Initially we will suppose that the gardener performs an infinite number of operations and we will simply calculate for each vertex the number of the operation on which it will be deleted Let s create a queue which will store the order of deleting vertices The queue will contain only those vertices whose neighbors except maybe one have been removed i e Let s add all leaves of the original tree to it for each of them let s store the value in the array because all original leaves will be removed during the first operation Next we will take sequentially one vertex from the queue and update the data about its neighbors Consider the neighbors Since we are deleting the current vertex we need to update of its neighbors If the neighbor s is equal to then it s already in the queue and it doesn t need to be considered right now Otherwise we will decrease the neighbor s by If it becomes equal to then the neighbor must be added to the queue The number of the operation during which the neighbor will be deleted is equal to the number of the operation during which the current vertex will be deleted plus After we calculate the numbers of operations for all vertices we need to select among them those that will not be deleted during operations with numbers Thus the answer is the number of vertices such that ,This problem has an easy constructive solution We can find lower and upper bounds on the value of for the given If the given does not belong to this segment then the answer is Otherwise the answer is for any in this segment How to construct it Let s start from the chain The answer for the chain is the upper bound of and it is Then let s try to decrease the answer by in one move Let s take some leaf the vertex without children with the smallest depth that is not and try to move it up The definition of badness will be below To do this let s find such vertex that its depth is less than the depth of by and it has less than children If we found such vertex then let s make the child of and decrease the answer by one If we didn t find such vertex I claim that the vertex has the minimum possible depth it can have and we should not consider it in the future Let s mark this vertex as and continue our algorithm If at some moment we cannot find any not leaf then the answer is Otherwise the answer is Time complexity 
795,Pasha is participating in a contest on one well known website This time he wants to win the contest and will do anything to get to the first place This contest consists of problems and Pasha solves th problem in time units his solutions are always correct At any moment of time he can be thinking about a solution to only one of the problems that is he cannot be solving two problems at the same time The time Pasha spends to send his solutions is negligible Unfortunately there are too many participants and the website is not always working Pasha received the information that the website will be working only during time periods th period is represented by its starting moment and ending moment Of course Pasha can send his solution only when the website is working In other words Pasha can send his solution at some moment iff there exists a period such that Pasha wants to know his best possible result We need to tell him the minimal moment of time by which he is able to have if he acts optimally or say that it s impossible no matter how Pasha solves the problems ,Notice that we can keep solved tasks and then submit all at once So the solution goes down to this you should find the first moment of time that the site works at that moment and Also it s convinient that the intervals are already sorted in increasing order Let s sum up all elements of array and write it to some variable The answer is obtained this way if the sum lies in the current interval then the answer is the sum Otherwise there are two cases If there exists some interval that then the answer is In other case the answer is 1 ,The problem is solved by the dynamic programming Let be the answer for the prefix of the array starting at it contains the indices If then Otherwise let s go over the position with which the next good array begins Then we need to select positions among positions which will be elements of the array The number of ways to choose an unordered set of items from of different objects is calculated using the formula Thus the dynamics is as follows The basis of dynamics is the value 
796,You have array that contains all integers from to twice You can arbitrary permute any numbers in Let number be in positions in the permuted array Let s define the value the distance between the positions of the number Permute the numbers in array to minimize the value of the sum ,Let s build the answer with the sum equal to zero Let be even Let s place odd numbers in the first half of the array the number in the positions and the number in the positions and and so on Similarly let s place even numbers in the second half the number in the position and the number in the positions and and so on We can place the number in the leftover positions We can build the answer for odd in a similar way Easy to see that our construction will give zero sum ,Consider the subset that is the answer to the problem Let be the arbitrary three elements from and let no more than one of them is equal to By the pigeonhole principle two of three elements from have the same parity So we have two integers with even sum and only one of them is equal to so their sum is also greater than So the subset is not simple In this way consists of only two numbers greater than one with a prime sum or consists of some number of ones and also maybe other value so that is a prime We can simply process the first case in time The second case can be processed in linear time Also we should choose the best answer from that two To check the value of order for primality in time we can use the simple or the linear Eratosthenes sieve 
797,Kid was gifted a tree of vertices with the root in the vertex Since he really like objects Kid wants to find out if this tree is Formally a tree is if there exists an order of children such that The subtree of the leftmost child of the root is a mirror image of the subtree of the rightmost child the subtree of the second left child of the root is a mirror image of the subtree of the second right child of the root if the number of children of the root is odd then the subtree of the middle child should be ,Note that if one subtree is a mirror image of another then they are isomorphic that is equal without taking into account the vertex numbers To check the subtrees for isomorphism we use Now we just have to learn how to check trees for symmetry To do this let s calculate how many children of each type our vertex has let s denote the hash of its subtree by the vertex type In order for the vertex subtree to be symmetric each child must have a pair of the same type except perhaps one which must also be symmetric We can calculate the symmetry of the subtrees while counting their hash to simplify this task ,Recall that the path in the rooted tree ascends from one end to the least common ancestor of the ends and descends to the other end possibly by 0 Then our set is divided into two simple ways To check this you only need to count We will first calculate the depths as for solving an easy version of the problem We will go along the vertices according to the non growth of the depths if of the deepest vertex and the current one is equal to the current one then it is the ancestor of the deepest one we will mark it Next we will find the deepest unmarked vertex and do the same if there is no such vertex then the whole path goes down and the answer is If there are unmarked vertices then there are vertices outside of those two ascents and the answer is Now we need to check that the two ascents do not intersect or intersect only at the of ends for this we just make sure that is not deeper than the shallowest vertex of the set 
798,You are walking with your dog and now you are at the promenade The promenade can be represented as an infinite line Initially you are in the point with your dog You decided to give some freedom to your dog so you untied her and let her run for a while Also you watched what your dog is doing so you have some writings about how she ran During the th minute the dog position changed from her previous position by the value it means that the dog ran for meters during the th minute If is positive the dog ran meters to the right otherwise if is negative she ran meters to the left During some minutes you were chatting with your friend so you don t have writings about your dog movement during these minutes These values equal zero You want your dog to return to you after the end of the walk so the destination point of the dog after minutes Now you are wondering what is the maximum possible number of different of the line your dog could visit on her way if you replace every with some integer from to and your dog return to after the walk The dog visits an integer point if she runs through that point or reaches in it at the end of any minute Point is always visited by the dog since she is initially there If the dog cannot return to the point after minutes regardless of the integers you place print ,Consider every cyclic shift of the array Suppose that now the array starts from the position the first element is and the last element is Assume that before the position our dog reached her minimum possible position and now the minimum position will not change So our problem is to fill all zeros in the array in such a way that the maximum prefix sum of is the maximum possible and the total sum of is zero For simplicity consider the array which is the th cyclic shift of i e the first element is the second element is and so on Let s iterate from left to right and maintain the current sum of the array Let this variable be Now when we meet we should replace it with the maximum possible value we can because in such a way we will increase the maximum number of prefix sums Let be the number of zeros in starting from the position This value can be calculated in advance in for every cyclic shift using suffix sums Then the segment of positions we can have at the end is and we want to place the maximum possible value in in such a way that this remaining segment with addition of our current element will cover This maximum value equals If becomes less than then this cyclic shift is invalid and we should skip it Otherwise let s add to and proceed If there are no values then we placed anything correctly Now can just simulate the movements of our dog to find the answer for the current cyclic shift But there are cases when do not contain zeros so these cases should be handled somehow I just checked that after simulation we returned to If we returned to we can update the answer as the difference between the maximum and the minimum positions plus one If there is no valid cyclic shift then the answer is Time complexity ,Let s define a function greaterCount number of subarrays with median greater or equal than In this case the answer on the problem is greaterCount greaterCount The subarray has median greater or equal than if and only if where is the number equal or greater than elements and is the number of less than elements In other words instead of processing you can use the sequence containing or and An element if An element if Now the median of is greater or equal than if and only if Let s iterate over from left to right Maintain the current partial sum Additionally in the array let s maintain the number of partial sum for each its value It means that before increase of you should do So if is the index of the right endpoint of a subarray i e then number of suitable indices is number of such that In other words find sum of all where it is exactly number of indices with partial sum less than Each time partial sum changes on or So the value sum of all where is easy to recalculate on each change If you decrease just subtract the value If you increase before increasing just add Since indices in can be from to you can use 0 based indices using an array In this case initialize as but not as it makes to be non negative on each step This solution works in 
799,Polycarp was gifted an array of length Polycarp considers an array beautiful if there exists a number such that each number in the array occurs either zero or times Polycarp wants to remove some elements from the array to make it beautiful For example if and then the following options are possible to make the array array beautiful Polycarp removes elements at positions and array becomes equal to Polycarp removes elements at positions and array becomes equal to Polycarp removes elements at positions and array becomes equal to Help Polycarp determine the minimum number of elements to remove from the array to make it beautiful ,Let s calculate the value of how many times the number occurs in the array We will iterate over the value of and look for the minimum number of moves necessary for each number to appear in the array either times or times Note that if there is no such number that then such a value of will not give the minimum answer because we have removed unnecessary elements Then for a specific the answer is calculated as follows Since the number of candidates for the value of is no more than this method works in Then there are two ways to optimize our solution you can consider only unique values of there are no more than and get a solution in you can sort the values and use prefix sums this solution works for or for if you use counting sort ,There are many ways to solve this problem I will describe the following recursive solution if let s compose an array where every segment ending with the th element is positive and every other segment is negative This array can be where is the th element of the array note that when doesn t belong to the array so it consists of only negative numbers but if solve the same problem with and recursively get an array of length with positive subarrays and append to it to make all segments ending with the last element positive 
800,You are given a set of elements indexed from to The weight of th element is The weight of some subset of a given set is denoted as The weight of some partition of a given set into subsets is recall that a partition of a given set is a set of its subsets such that every element of the given set belongs to exactly one subset in partition Calculate the sum of weights of all partitions of a given set into exactly subsets and print it modulo Two partitions are considered different iff there exist two elements and such that they belong to the same set in one of the partitions and to different sets in another partition ,Let s look at some facts At first the answer is the sum of weights taken with some coefficients So it s enough to calculate those coefficients Then can be calculated by iterating on the size of the subset containing th element where is the number of partitions of set with elements into nonempty subsets with one subset of fixed size where belongs This solution is still quite slow so the next fact is if two elements and belong to the same subset then increases the coefficient before So for each element we can iterate over all elements which will lie in one subset with In other words is the number of ways to divide set with elements into subsets in such a way that elements and wil lie in one subset can be calculated using Stirling numbers of the second kind let be the number of partitions of set with elements into non empty subsets If then else we just merge and into one element and let Final formula is And the answer is Counting Stirling numbers can be done with inclusion exclusion principle or by searching Wiki Resulting complexity is ,As you can see from the example the maximum answer doesn t exceed So we can run some precalculation before all queries which will find all less than The number is if it has no in the ternary numeral system When you read the next query you can increase until you find some precalculated Time complexity is You also can implement the solution which doesn t use any precalculations and just increase each time in each query and checks if the number is inside this loop Then time complexity will be 
801,You are given an array which is sorted in non descending order You decided to perform the following steps to create array Create an array consisting of arbitrary integers Set for each Sort the array in non descending order You are given the resulting array For each index calculate what is the minimum and maximum possible value of you can choose in order to get the given array Note that the minimum maximum s are of each other i e they can be obtained from different possible arrays ,For the start let s note that for each Otherwise there is no way to get from Firstly let s calculate for each Since all then is always greater or equal than you get it from So the minimum would come from lowest that still Since is sorted we can find such with in Let s prove that we can build such that transforms to we found earlier Let s just make for for and It s easy to see that all are non negative so such is valid Now let s calculate Suppose we transform to for some It s not hard to prove that the proving array may be constructed in the similar way for for and In order to build such array you need for each In other words if there is some position such that and you can t choose such that It means that we can iterate in descending order and just keep track of leftmost with Then is equal to or if there are no such The resulting complexity is because of the first part But it can be optimized to if we use two pointers instead of ,A solution in iterate on check that there exists an element lower than to the left of it and check that there exists an element lower than to the right of it Can be optimized to with prefix suffix minima A solution in note that if there is some answer we can find an index such that and if there is no such triple the array descends to some point and ascends after that so there is no answer So we only have to check consecutive triples 
802,Petya got an array of numbers from to where He performed operations sequentially In the end he received a new state of the array At the th operation Petya chose the first elements of the array and cyclically shifted them to the right an arbitrary number of times elements with indexes and more remain in their places One cyclic shift to the right is such a transformation that the array becomes equal to the array For example if and that is this is the third operation then as a result of this operation he could get any of these three arrays makes cyclic shifts or any number that is divisible by makes cyclic shift or any number that has a remainder of when divided by makes cyclic shifts or any number that has a remainder of when divided by Let s look at an example Let i e initially A possible scenario is described below no matter how many cyclic shifts Petya makes the array does not change let s say Petya decided to make a cyclic shift then the array will look like let s say Petya decided to make cyclic shift then the array will look like let s say Petya decided to make cyclic shifts the original array will look like let s say Petya decided to make cyclic shifts then the array won t change let s say Petya decided to make cyclic shifts the array will look like You are given a final array state after all operations Determine if there is a way to perform the operation that produces this result In this case if an answer exists print the numbers of cyclical shifts that occurred during each of the operations ,The first thing to notice the answer always exists For numbers answer choices as well as permutation combinations It remains only to restore the answer from this permutation We will restore by performing reverse operations On the th operation will be selectd the first elements of the array and rotate them times to the left elements with numbers and more remain in their places Where is equal to if otherwise and is the index of the number Thus for each from right to left performing a left cyclic shift operation we move the number at index As a result we move numbers times The time complexity ,The simple simulation works here while there is at least one inversion such a pair of indices and that we can fix let s fix it we can fix this inversion if If there are inversions but we cannot fix any of them the answer is Otherwise the answer is There is also a solution it is obvious that we have some segments in which we can change the order of elements as we want And it is also obvious that we cannot move elements between these allowed segments So each of them is independent of each other We can just find all these segments of indices using two pointers and sort them independently Then we just need to check if the array becomes sorted Time complexity is or 
803,You have a stripe of checkered paper of length Each cell is either white or black What is the minimum number of cells that must be recolored from white to black in order to have a segment of consecutive black cells on the stripe If the input data is such that a segment of consecutive black cells already exists then print ,To obtain a segment of cells of black color we need to paint all the white cells of the segment black Then go through all the segments of length there are only and choose such a segment among them that the number of white cells on it is minimal You can quickly find out the number of white cells in the segment by prefix sums ,Let s see how the matrix looks like after some sequence of shoots The matrix consists of or There is at least one at position or and any not at position or must have below or right If the second condition is violated then the in the corresponding cell would continue its flight Thus it is necessary and sufficient to verify that the matrix satisfies the condition above 
804,You are given a sequence of length consisting of integers from to Find the number of tuples of elements such that the maximum number in the tuple differs from the minimum by no more than Formally you need to find the number of triples of indices such thatFor example if and then there are two such triples and If and then all four possible triples are suitable ,In the easy version of the problem you can count how many times each number occurs the numbers themselves do not exceed n Note that we do not have very many options for which triples of numbers can be included in the answer Let s iterate over x the minimum number in the triples Then there are the following options x x 1 x 2 x x 1 x 1 x x 2 x 2 x x x 1 x x x 2 x x x In each option you need to multiply the number of ways to choose one two or three numbers from all occurrences of this number This is done using binomial coefficients Formally if cnt x is the number of occurrences of the number x then the formulas corresponding to the options in the list above are as follows cnt x cdot cnt x 1 cdot cnt x 2 cnt x cdot frac cnt x 1 cdot cnt x 1 1 2 cnt x cdot frac cnt x 2 cdot cnt x 2 1 2 frac cnt x cdot cnt x 1 2 cdot cnt x 1 frac cnt x cdot cnt x 1 2 cdot cnt x 2 frac cnt x cdot cnt x 1 cdot cnt x 2 6 If we sum these values over all x from 1 to n then we get the answer to the problem ,Let s notice that if we multiply the numbers then the power of two of the product is equal to the sum of the powers of two in each of the numbers Let s calculate the initial sum of the powers of twos in the product This can be done as follows let s take the element and divide it by as long as we can while remembering to increase our counter by the number of occurrences of a power of two Now let s move on to operations and note that choosing the index will increase the degree of occurrence of two by a fixed number that is it does not matter when to apply this operation Choosing an index will increment the counter by a number such that is divisible by but not by you can find this again by dividing by while we can Since we want to minimize the number of operations used at each moment of time we will try to use an index that increases the counter by the largest number To do this it is enough to sort the indices by this index of increase and take them greedily from the largest increase to the smallest We get the solution in 
805, is a complete binary tree consisting of vertices It means that exactly one vertex is a root and each vertex is either a leaf and doesn t have children or an inner node and has exactly two children All leaves of a complete binary tree have the same depth distance from the root So is a number such that is a power of In the picture you can see a complete binary tree with Vertices are numbered from to in a special recursive way we recursively assign numbers to all vertices from the left subtree if current vertex is not a leaf then assign a number to the current vertex and then recursively assign numbers to all vertices from the right subtree if it exists In the picture vertices are numbered exactly using this algorithm It is clear that for each size of a complete binary tree exists exactly one way to give numbers to all vertices This way of numbering is called You have to write a program that for given answers queries to the tree Each query consists of an integer number and a string where is the number of vertex and represents the path starting from this vertex String doesn t contain any characters other than and which mean traverse to the left child to the right child and to the parent respectively Characters from have to be processed from left to right considering that is the vertex where the path starts If it s impossible to process a character for example to go to the left child of a leaf then you have to skip it The answer is the number of vertex where the path represented by ends For example if and then the answer is ,In this editorial represents the number of vertex we are currently in Let be the maximum integer number such that is divisible by or the number of zeroes at the end of the binary representation of It is easy to prove that if then is a leaf if then both children of are leaves and so on Even more the difference between and any of his children is exactly So to traverse to the left child we have to subtract from if is not a leaf and to traverse to the right child we add to How can we process traversions up Let be the number of the parent node has exactly zeroes at the end of its binary representation so to traverse from to we need to either add or subtract from And to traverse from to we also have to either subtract or add to One of these operations will lead us to the number divisible by and not divisible by and we need to choose this operation Time complexity is ,The first observation we need to solve this problem the required height is either or where is the maximum initial height of some tree We don t need heights greater than because for example if the height is we can remove some moves and get the answer for the height The same thing applies to all heights greater than Why do we even need the height In some cases like the answer for the height is better than the answer for the height in this particular case it is vs Now we have two ways to solve the problem either use some gross formulas or just write a binary search on the answer I won t consider the solution with formulas but we have one so let s assume we use binary search Let the current answer be Then let be the number of operations we can do and be the number of operations we can do We can use operations greedily and then just check if the number of operations is sufficient to grow up the remaining heights Time complexity per test case 
806,You are given two positive integers and Represent the number as the sum of positive integers of the same parity have the same remainder when divided by In other words find such that all and either all are even or all are odd at the same time If such a representation does not exist then report it ,Consider two cases when we choose all odd numbers and all even numbers In both cases let s try to maximize the maximum So if we choose odd numbers let s try to take ones and the remainder But we need to sure that is greater than zero and odd And in case of even numbers let s try to take twos and the remainder We also need to check that the remainder is greater than zero and even If none of these cases is true print ,Since we only care about the last digit of the sum we can ignore all numbers other than the last digits of the elements of For example we can consider to be the same as Now note that if a number appears more than times in the array we can ignore all copies that occur more than times since our sum only involves three numbers For example we can consider to be the same as Using these observations note that there are only digits and each digit can occur at most times So we can always reduce the array to one of length Since is very small we can brute force all triples which runs quickly enough Time complexity 
807,Let s say string has period if for all from to means length of string and is the minimum positive integer with this property Some examples of a period for the period is for the period is for the period is for the period is You are given string consisting only of s and s and you need to find such string that String consists only of s and s The length of doesn t exceed String is a subsequence of string String has smallest possible period among all strings that meet conditions 1 3 Let us recall that is a subsequence of if can be derived from by deleting zero or more elements any without changing the order of the remaining elements For example is a subsequence of ,Let s see how strings with periods k 1 and k 2 look There are two types of strings with a period equal to 1 and And there are two types of strings with a period equal to 2 and It s easy to see if t consists only of s s then the string itself is an answer since it has period equal to 1 Otherwise it s also quite obvious that any string t is a subsequence of of 2 t length ,By the definition of lexicographical comparing we can see that if we can remove one character we always have to do it Besides we have to remove the character from the leftmost position such that and or from the position if there is no such 
808,You are given a string of length consisting of lowercase English letters For two given strings and say is the set of distinct characters of and is the set of distinct characters of The strings and are if their lengths are equal and there is a one to one mapping bijection between and for which Formally for any index for any character there is exactly one character that for any character there is exactly one character that For example the strings and are isomorphic Also the strings and are isomorphic The following pairs of strings are not isomorphic and and You have to handle queries characterized by three integers For each query check if two substrings and are isomorphic ,Yes authors also implemented hashes Note that if substrings and are isomophic then position of first encounter of some character in must be position of first encounter of some character in More over if we sort all positions for all distict characters in and sort all positions for then must be equal for any This observation gives us fact that So to check isomorphism of and we need check for each that positions of all encounters of character equal to posistions of all encounters of character To do that we can generate for each character boolean array with checked positions of its encounter and calculate prefix hashes on this arrays Also we need precalculate order of first encounters for each suffix of string To do it fast note that in transition from to only can change its relative order Result complexity is with quite big constant from hashing ,Let be the mirror reflection of the string For example Let string be good if it does not have a prefix which have more closing brackets than opening ones For example are good and are not The balance of the string is the difference between number of opening and closing brackets in For example 1 0 Let be the number of good strings with a balance The answer to the problem is 
809,Consider a road consisting of several rows Each row is divided into several rectangular tiles and all tiles in the same row are equal The first row contains exactly one rectangular tile Look at the picture below which shows how the tiles are arranged The road is constructed as follows the first row consists of tile then rows follow each of these rows contains tile greater than the previous row then rows follow each of these rows contains tile less than the previous row then rows follow each of these rows contains tile greater than the previous row then rows follow each of these rows contains tile less than the previous row then rows follow each of these rows contains tile greater than the previous row then rows follow each of these rows contains tile less than the previous row An example of the road with Rows are arranged from left to right You start from the only tile in the first row and want to reach the last row any tile of it From your current tile you can move to any tile in the next row which touches your current tile Calculate the number of different paths from the first row to the last row Since it can be large print it modulo ,The group of the rows where the number of rectangular tiles increases times and then decreases times can be represented as a rectangular table with diagonals where the size of the first diagonal is equal to the number of rectangular tiles before the operations are applied let their number be and the size of the last diagonal is In such a rectangular table one can move from the cell to the cells and if they exist which lie on the next diagonal next row in terms of the original problem It s a well known fact that the number of different paths from one cell to another is some binomial coefficient Let s define as the number of paths from the st row to the th tile in the th row i e row after the th group of operations Now we want to find the values of using the values of let its size be Using the fact described in the first paragraphs we know that depends on with some binomial coefficient In fact for But this solution is too slow To speed up this solution we have to notice that the given formula is a convolution of and some binomial coefficients So we can use NTT to multiply them in instead of time ,Firstly if is odd then the answer is by obvious reasons Otherwise we can notice that the top left and the bottom right values of the tile do not matter since we can place tiles symmetrically So we only need to check that there is some tile that its top right value equals its bottom left value because this is how we get main diagonal symmetry 
810,You are given an array consisting of nonnegative integers Let s define the prefix OR array as the array where represents the bitwise OR operation In other words the array is formed by computing the of every prefix of You are asked to rearrange the elements of the array in such a way that its prefix OR array is lexicographically maximum An array is lexicographically greater than an array if in the first position where and differ ,Note that in this context denotes We can make the observation that only the first elements matter since after placing them optimally we can be sure all bits that could be set in the prefix OR would have already been set So we can brute force the optimal choice times we choose to add an element if it provides the largest new prefix OR value among all unused elements and then just add the rest of the unused elements ,The value of always changes by thus the set of values of is always some contiguous segment The length of such segment can be determined by just its minimum and maximum values So we have to solve two separate tasks for each query find the minimum and the maximum value gets assigned to I ll describe only the minimum one This task however can as well be split into two parts minimum value on a prefix before and on a suffix after The prefix is easy it doesn t get changed by a query so it can be precalculated beforehand Minimum value on a prefix of length is minimum of a minimum value on a prefix of length and the current value The suffix minimum is not that trivial First in order to precalculate the minimum value on a suffix of length we have to learn to prepend an instruction to the suffix of length Consider the graph of values of over time What happens to it if the initial value of is not but for example It just gets shifted by upwards That move is actually the same as prepending a instruction So the minimum value for a suffix of length is a minimum of a minimum value for a suffix of length increased by the current instruction and the start of the graph So now we have a minimum value on a suffix after However it can t be taken into the answer as it is because it considers the graph for the suffix to be starting from And that s not the case The graph for the suffix starts from the value the prefix ends on So we can shift the answer for the suffix by the value of after the prefix The overall minimum value is just the minimum on a prefix and on a suffix then Overall complexity per testcase 
811,Masha works in an advertising agency In order to promote the new brand she wants to conclude contracts with some bloggers In total Masha has connections of different bloggers Blogger numbered has followers Since Masha has a limited budget she can only sign a contract with different bloggers Of course Masha wants her ad to be seen by as many people as possible Therefore she must hire bloggers with the maximum total number of followers Help her find the number of ways to select bloggers so that the total number of their followers is maximum possible Two ways are considered different if there is at least one blogger in the first way which is not in the second way Masha believes that all bloggers have different followers that is there is no follower who would follow two different bloggers For example if then Masha has two ways to select bloggers with the maximum total number of followers conclude contracts with bloggers with numbers and In this case the number of followers will be equal to conclude contracts with bloggers with numbers and In this case the number of followers will be equal to Since the answer can be quite large ,It is obvious that Masha will enter into agreements only with bloggers that have the most subscribers You can sort all the bloggers and greedily select the prefix Let be the minimum number of subscribers for the hired blogger Then we must hire all the bloggers who have more subscribers Let the number of bloggers who have more than subscribers the number of bloggers who have exactly subscribers Then we should select bloggers from The number of ways to do this is equal to the binomial coefficient of by You could calculate it by searching for the inverse element modulo Then you could calculate the factorials and use the equality Alternatively you can use the equation and calculate it using dynamic programming This method is better known as the Pascal triangle ,This problem can be solved differently For example you can use some data structures or sqrt decomposition technique But it is not required We expected the following simple solution from the participants Let s preprocess the following values the position of the first element to the left from the th element such that Now to answer to the query we should check if then we have the answer Otherwise we should check the position 
812,A triple of points and on a coordinate line is called if and You are given a set of points on a coordinate line initially empty You have to process queries of three types add a point remove a point calculate the number of beautiful triples consisting of points belonging to the set ,We are going to calculate the answer as follows for every point let be the number of points such that i e the number of points that are to the right of and have distance at most from it Then the number of beautiful triples where is the leftmost point is We can sum these values over all points to get the answer so the solution should somehow maintain and update the sum of these values efficiently Let s see what happens when we add a new point or remove an existing point For all points to the left of it with distance no more than the value of increases or decreases by So we need some sort of data structure that allows adding subtracting on segment and maintains the sum of This looks like a lazy segment tree but updating the sum of can be tricky One way to do this is to notice that So maybe we can maintain the sum of and the sum of on the segment It turns out we can The model solution does this as follows the leaf of the segment tree corresponding to the position stores a vector with three values The inner nodes store the sums of these vectors in the subtree We can find a matrix which when multiplied by gets the vector and the inverse matrix to it Then adding to on segment means multiplying all vectors on segment by that matrix and subtracting means multiplying by the inverse matrix and since matrix multiplication is both associative and distributive the segment tree can handle these queries Okay there s only one small issue left right now our structure can store the sum of and over all possible points we build it on segment for example but we only need the sum over points One way to handle it is to use a flag for each leaf of the segment tree and pull the value up from the leaf only if this flag is true We will need a function that changes the value of this flag for a single leaf but it s not very different from a function that changes one value in a lazy segment tree Time complexity of the solution is where is the maximum coordinate of the point although the constant factor of the described approach is fairly large since it involves matrix multiplications You can improve the constant factor by getting rid of the matrices as mentioned earlier ,The main idea of the solution is to find a linear number of intersections of segments Intersections can be found with sweep line approach We will maintain a set for the endpoints open segments When we add a segment we find all segments which intersect with it that is all segments that end earlier than it Obviously if the number of intersections are greater than then the answer is So as soon as we find intersections we stop our algorithm After that it is necessary to check the connectivity of the resulting graph You can use DFS or DSU to do this 
813,Let us denote by the sum of all divisors of the number i e For example For a given number find the minimum such that ,Note that n le d n le 10 7 10 7 is the maximum value of c in the problem so it is enough for every n 1 10 7 to calculate the value of d n To calculate the value of d n you can use the sieve of Eratosthenes and get the solution for mathcal O 10 7 log 10 7 Also you can use the linear sieve of Eratosthenes to find the minimum divisor for each n 1 10 7 and use the multiplicativity of the function d n d a cdot b d a cdot d b if gcd a b 1 ,A good start to solve the problem would be to check the answers for small values of One can see that the answers the sizes of the maximum subsets are not much different from itself or rather not less than Let s try to prove that this is true for all Consider is even Let let s see what the product is equal to if we take all the numbers from to From here we can see that for even the answer is at least because we can delete and the product of the remaining factorials will be the square of an integer for odd the answer is at least because we can delete and It remains to prove that the answer is at least for odd This is easy to do because the answer for is not less than the answer for minus because we can delete and solve the task with a smaller value Moreover it can be seen from the previous arguments that the answer can only be for and we already know that in this case one of the correct answers is to remove the factorials It remains to learn how to check whether it is possible to remove or numbers so that the remaining product of factorials is the square of an integer To do this we can use XOR hashes Let s assign each prime number a random bit number For composite numbers the hash is equal to the XOR of hashes of all its prime divisors from factorization Thus if some prime is included in the number an even number of times it will not affect the value of the hash which is what we need The hash of the product of two numbers is equal to the XOR of the hashes of these numbers Let s denote the hash function as Using the above let s calculate for all from to as well as for all from to this is easy to do because We will also store a map Let s calculate the hash and denote it as It remains to consider the following cases if then the current product is already the square of an integer for an answer of size we have to check that there exists such a that To find such let s check whether the map contains for an answer of size we have to check that there are such and that To do this iterate over and then check whether map contains otherwise the answer is and there is an answer where all numbers except are taken 
814,Recently Polycarp noticed that some of the buttons of his keyboard are malfunctioning For simplicity we assume that Polycarp s keyboard contains buttons one for each letter of the Latin alphabet Each button is either working fine or malfunctioning To check which buttons need replacement Polycarp pressed some buttons in sequence and a string appeared on the screen When Polycarp presses a button with character one of the following events happened if the button was working correctly a character appeared at the end of the string Polycarp was typing if the button was malfunctioning characters appeared at the end of the string For example suppose the buttons corresponding to characters and are working correctly and the button corresponding to is malfunctioning If Polycarp presses the buttons in the order then the string he is typing changes as follows You are given a string which appeared on the screen after Polycarp pressed some buttons Help Polycarp to determine which buttons are working correctly for sure that is this string could not appear on the screen if any of these buttons was malfunctioning You may assume that the buttons don t start malfunctioning when Polycarp types the string each button either works correctly throughout the whole process or malfunctions throughout the whole process ,If a key malfunctions each sequence of presses of this key gives a string with even number of characters So if there is a substring consisting of odd number of equal characters such that it cannot be extended to the left or to the right without adding other characters then it could not be produced by presses of button if was malfunctioning The only thing that s left is to find all maximal by inclusion substrings consisting of the same character ,If we don t have two distinct strings then we just have to swap any pair of characters in any of the given strings and print it Otherwise we have to find two indices and such that Then let s store all positions such that in array If the number of those positions will exceed 4 then the answer will be 1 Otherwise we need to iterate over all positions in array try to swap with any other character of and check that current string can be the answer We also should try the same thing with string It is clear how we can check string to be the answer Let s iterate over all strings and for each string count the number of positions such that Let s call it If for any given string is not equal to 0 or 2 then string can t be the answer Otherwise if for any given string is equal to 0 and all characters in string are distinct then can t be the answer If there is no string that satisfies all aforementioned conditions then the answer will be 1 
815,You are given an array of integer numbers Your task is to divide the array into the maximum number of segments in such a way that each element is contained in segment each segment contains at least one element there doesn t exist a non empty subset of segments such that bitwise XOR of the numbers from them is equal to Print the maximum number of segments the array can be divided into Print if no suitable division exists ,Let s consider some division Represent the XOR sum of the subset via prefix XOR Those are I claim that you can collect any subset that is a XOR of an even number of for pairwise distinct values of Let s take a look on some prefix of processed segments where the last segment is taken into subset The previous taken s can t be changed the last taken can either be eliminated if we also take the current segment and that segment erases one value and adds one or added to the answer if we don t take it but the next taken segment will add two values You can see that the parity doesn t change Moreover you can collect any subset that is a XOR of an odd number of for pairwise distinct values of Just forget about taken into the answer as its value is Then all the even subsets which included it will become odd This way we can collect all subsets of for some division Now you just want find the division that produces the maximum number of linearly independent numbers binary vectors That is the size of the basis of the space of chosen numbers binary vectors Now it s time to abuse the fact that adding a number into the set can only increase the size of basis of the space Thus adding anything to the maximum set won t change the answer otherwise the result would be greater than the maximum Finally you say that the maximum basis size is equal to the basis size of all the prefix XOR and easily calculate in The only corner case is being itself Then for any division the full subset will also give result That is the only case with answer Overall complexity ,Several observations Generally we have two types of operations divide and either or If then in one division we ll get element so we can just keep track of the total possible number of these operations as If then if we decide to split whole to s then we get elements but in operations i e in one division we ll get elements So it s preferably to fully split than Also the less the more profitable each division As a result let s act greedy let s say we need more elements Let s iterate over in the increasing order If then let s fully split in in operations decrease increase a counter of operations and increase accordingly If then the situation becomes complicated We can either don t touch and try to use preserved operations with small if or split in two s Now we spent one operation and get two If then we don t need one of and can split further only one If then it s optimal to fully split one of and proceed further with only one and recalculated and In both cases we can solve optimal splitting of recursively in the same manner as Since in each step we lower then we need to check only cases per each query Note that we can treat situation in packs for several with equal so the first part also works in The resulting complexity is per query 
816,For some binary string i e each character is either or all pairs of consecutive adjacent characters were written In other words all substrings of length were written For each pair substring of length the number of ones in it was calculated You are given three numbers the number of such pairs of consecutive characters substrings where the number of ones equals the number of such pairs of consecutive characters substrings where the number of ones equals the number of such pairs of consecutive characters substrings where the number of ones equals For example for the string the following substrings would be written Thus Your task is to restore suitable binary string from the given values It is guaranteed that at least one of the numbers is greater than Also it is guaranteed that a solution exists ,Consider case separately and print the sting of zeros or ones correspondingly Now our string has at least one pair or Let s form the pattern of length So all substrings with the sum are satisfied Now let s insert zeros before the first zero in this way we satisfy the substrings with the sum And then just insert ones before the first one in this way we satisfy the substrings with the sum ,If then the answer is equal to Otherwise answer will be equal to where is the count of the zeroes in the given string i e the answer is the binary string of length in which the first character is one and the other characters are zeroes 
817,You are given an array which is sorted in non decreasing order Find three indices such that and it is to construct a non degenerate triangle a triangle with nonzero area having sides equal to and for example it is possible to construct a non degenerate triangle with sides and but impossible with sides and If it is impossible to find such triple report it ,The triangle with side is degenerate if So we have to maximize the length of the longest side and minimize the total length of other sides Thus if then we answer if otherwise the answer is ,There are at least two solution to the problem I ll describe both of them The first solution firstly let s notice that the point we search can have non integer coordinates but if the answer exists then there will be the answer such that its point has at most half integer coordinates So let s multiply all coordinates by two and solve the problem with integer coordinates The second thing is that for some there is only two points we need to check top point with this and bottom point with this The same for some So we can iterate over all possible values of and check if the point lies outside of both black rectangles The same with point Then do the same for points and should be in range and should be in range Time complexity is linear on size of the white rectangle The second solution is most tricky but has the better time complexity Let be the intersection of white rectangle and the first black rectangle the same but with the second black rectangle and be the intersection of and Then it is obvious that the answer exists if and doesn t cover the whole white rectangle Time complexity 
818,Alperen has two strings and which are both initially equal to He will perform operations of two types on the given strings Append the string exactly times at the end of string In other words Append the string exactly times at the end of string In other words After each operation determine if it is possible to the characters of and such that is lexicographically smaller than Note that the strings change after performing each operation and go back to their initial states Simply speaking the lexicographical order is the order in which words are listed in a dictionary A formal definition is as follows string is lexicographically smaller than string if there exists a position such that and for all If no such exists then is lexicographically smaller than if the length of is less than the length of For example and where we write if is lexicographically smaller than ,First of all let s think about how we should rearrange the two strings in such a way that if that is ever possible It s always optimal to arrange s characters increasingly in lexicographic order and s characters decreasingly Since initially both and contain a character the first time receives any other letter than the answer will always be because that character will always be lexicographically larger than s first character which should be In the other case we know that doesn t have any other characters than so we can compare the string with multiple characters and we know that will be smaller if and only if it s only formed of s and has a smaller size than ,We need to make our string alternating i e When we reverse substring we change no more than two pairs and Moreover one pair should be a consecutive pair and other So we can find lower bound to our answer as maximum between number of pairs of and number of pairs of And we can always reach this lower bound by pairing with or with left right border of Another way to count the answer is next suppose we want to make string then let s transform to For example if we will get We claim that after this transformation we will have equal number of and so the answer is the number of consecutive pairs of the same character divided by two The answer is the minimum between answers for and 
819,You are given an integer You can perform any of the following operations with this number an arbitrary possibly zero number of times Replace with if is divisible by Replace with if is divisible by Replace with if is divisible by For example you can replace with using the first operation with using the second operation or with using the third operation Your task is to find the minimum number of moves required to obtain from or say that it is impossible to do it You have to answer independent queries ,What if the given number cannot be represented as It means that the answer is because all actions we can do are remove one power of two remove one power of three and add one power of two and remove one power of five and add two powers of two So if the answer is not then it is If this formula isn t pretty clear for you you can just simulate the process performing actions from third to first ,Let s fix an fraction such that Obviously each good fraction is equal to exactly one of such irreducible fractions So if we iterate on and check that and find the number of good fractions that are equal to we will solve the problem Okay suppose we fixed and Any good fraction can be represented as where is some positive integer Let s try all possible values of and for them check whether they correspond to a good fraction How do we try all values of without iterating on them Let s construct the decimal representation of from the least significant digit to the most As soon as we fix least significant digits of we know least significant digits of and So let s try to use digit DP to try all possible values of Which states do we have to consider Of course we need to know the number of digits we already placed so that will be the first state After we placed digits we know first digits of the numerator of the fraction but to get the value of digit knowing only the value of the corresponding digit in is not enough there could be some value carried over after multiplying already placed digits by For example if and we placed the first digit of and it is we know that the first least significant digit of is and we know that after fixing the second digit of we should add to it to get the value of this digit in since is carried over from the first digit So the second state of DP should represent the number that is carried over from the previous digit in the numerator and the third state should do the same for the denominator Okay in order to know whether the fraction is good we have to keep track of some digits in the numerator and denominator If and then we have to keep track of the digit representing in the numerator and the digit representing in the denominator So we have two additional states that represent the masks of interesting digits we met in the numerator and in the denominator The only thing that s left to check is that both and are not greater than Let s construct the decimal representation of and prepend it with some leading zeroes and keep constructing the numerator and the denominator until they have the same number of digits as the decimal representation as Then we can compare the representation of for example numerator with the representation of as strings Comparing can be done with the following technique let s keep a flag denoting whether the number represented by the least significant digits of the numerator is less or equal than the number represented by the same digits from When we place another digit of the numerator we can get the new value of this flag as follows if new digit of the numerator is not equal to the corresponding digit of then the value of the flag is defined by comparing this pair of digits otherwise the value of the flag is the same as it was without this new digit Of course we should do the same for the denominator Okay now we can actually start coding this DP is the number of possible ways to put least significant digits in in such a way that the value carried over to the next digit of the numerator is and for the denominator denotes whether the current numerator is less or equal to the number represented by least significant digits of does the same for the denominator denotes which interesting digits we already met in the numerator of course does the same for the denominator If you are feeling confident in your programming abilities you can just start implementing this DP on a seven dimensional array I was too afraid to do it but looking at participants solutions I realize that it sounds much more scary than it looks in the code so I decided to write the model solution using a structure representing each state and a map to store all these structures This is a common technique when a dynamic programming solution you come up with has some really complex states and transitions it is sometimes better to use some self implemented structures to define these states and store them in a map or a hashmap Some advantages of this technique are it s sometimes much easier to code the code may be longer than the same solution with regular DP stored in a multi dimensional array but it s easier to write and understand this code if most states are unreachable they won t even appear in our map so we skip them altogether it is easy to add some optimizations related to reducing the number of states For example the number of different values for and may be too much so we can use the following optimization as soon as we find some pair of numbers in and that can represent and we can change these masks to some values that will mark that they are finished and stop updating them at all 
820,Tanya is learning how to add numbers but so far she is not doing it correctly She is adding two numbers and using the following algorithm If one of the numbers is shorter than the other Tanya adds leading zeros so that the numbers are the same length The numbers are processed from right to left that is from the least significant digits to the most significant In the first step she adds the last digit of to the last digit of and writes their sum in the answer At each next step she performs the same operation on each pair of digits in the same place and writes the result to the side of the answer For example the numbers and Tanya adds up as follows calculates the sum of and writes in the answer calculates the sum of and writes the result to the left side of the answer to get calculates the sum of and writes the result to the left side of the answer to get calculates the sum of and writes the result to the left side of the answer to get calculates the sum of and writes the result to the left side of the answer and get As a result she gets You are given two positive integers and Find the number such that by adding and as described above Tanya will get Or determine that no suitable exists ,Let s compute the answer to the array where is the digit at the position in the number we are looking for Let be the position of the last digit in number be the position of the last digit in number Then denote and consider the cases if then the sum of was exactly then if then the sum was greater than and we need to look at the next digit of the number If there isn t one we can t get the answer we ll output Otherwise we recalculate and reduce by one if now and then Otherwise we deduce since we cannot get more than when adding two digits and the cases where have already been considered before After considering the cases reduce and by one and repeat the checks as long as or In the situation where but we will still have uncheked digits of number so we will also output Otherwise we output an array with the answer without leading zeros ,The key fact in this problem is that the answer is not very large in fact it s not greater than 91 Why is it so Every 10 times we apply function f to our current number it gets divided by 10 at least and the number of such divisions is bounded as O log n So we can just do the following store all reachable numbers somewhere and write a loop that adds current number n to reachable numbers and sets n f n we should end this loop when n already belongs to reachable numbers The most convenient way to store reachable numbers is to use any data structure from your favourite programming language that implemenets a set but in fact the constrains were so small that it was possible to store all reachable numbers in an array 
821,It s New Year s Eve soon so Ivan decided it s high time he started setting the table Ivan has bought two cakes and cut them into pieces the first cake has been cut into pieces and the second one into pieces Ivan knows that there will be people at the celebration including himself so Ivan has set plates for the cakes Now he is thinking about how to distribute the cakes between the plates Ivan wants to do it in such a way that all following conditions are met Each piece of each cake is put on some plate Each plate contains at least one piece of cake No plate contains pieces of both cakes To make his guests happy Ivan wants to distribute the cakes in such a way that the minimum number of pieces on the plate is maximized Formally Ivan wants to know the maximum possible number such that he can distribute the cakes according to the aforementioned conditions and each plate will contain at least pieces of cake Help Ivan to calculate this number ,Let s fix number of plates to have pieces of the first cake plates left for the other cake Obviously the most optimal way to distribute pieces to plates will lead to the minimum of pieces on a plate Now try every possible and take maximum of Overall complexity ,At first let s precalculate array pos such that pos a i i Now presume that we have to calculate answer for b i Then there are two cases let s denote lst max limits 1 le j i pos b j initially lst 1 if pos b i lst then we have to spend 1 2 cdot pos b i i 1 seconds on it second on the gift b i pos b i i 1 seconds on removing gifts above and pos b i i 1 seconds on pushing these gifts if pos b i lst then we can reorder gifts by previous actions such that gift b i be on the top of stack So we spend only second on it 
822,A matrix of size such that each cell of it contains either or is considered if the sum in every contiguous submatrix of size is exactly i e every square of size contains exactly two s and exactly two s You are given a matrix of size Initially each cell of this matrix is empty Let s denote the cell on the intersection of the th row and the th column as You have to process the queries of three types clear the cell if there was a number in it write the number in the cell write the number in the cell After each query print the number of ways to fill the empty cells of the matrix so that the resulting matrix is Since the answers can be large print them modulo ,For best understanding we replace the matrix with and with the matrix with black and white cells At first let s consider matrix if there are two adjacent horizontal cell with same color for example cells and are black Then the cells and must have the opposite color white the cells and must have the same color black and so on So two adjacent horizontal cells generate the of width two Reciprocally two adjacent vertical cells generate the of width two And if simultaneously there are and then the answer is because they contradict each other If there are two cells of same color in the same row with even number of cells between them for example and with four cells between them then there is the because there are always two adjacent cells with same color between them The same is correct for Now let s consider how the matrix look if there are the It look like a chess board of size but colors of some verticals are inverted The same is correct if there are the How we can quickly understand that there are two cells of same color in the same row with even number of cells between them For this mentally color the matrix in a checkerboard pattern And then one of this cells has the same color witch cells in chessboard and the other has the opposite color witch cells in chessboard For calculating the answer we have maintain to the following values The color of each colored cell The row and columns containing the cells of same color with even number of cells between them And the number of row and columns containing at least one colored cell for calculating the number of beautiful matrix ,Really low constraints choosing some permutation Surely this will be some dp on subsets At first let s get rid of For each two rows calculate the minimum difference between the elements of the same columns let s call this for some rows This will be used to put row right after row Let s also calculate the minimum difference between the elements of the column of row and column of row This will be used to put row as the last row and row as the first one Now let s think of choosing the permutation as choosing the traversal of the following graph Vertices are rows and the weights of edges between the vertices are stored in However you can t straight up do minimum weight Hamiltonian cycle search as the edge between the first vertex and the last one should be of weight from and not Let s fix some starting vertex and find minimum weight Hamiltonian paths from it to all vertices Finally update the answer with That will lead to approach minimum weight Hamiltonian path is a well known problem solved by That s completely fine and it s the most intended solution However there exist another solution that would have worked better if the edge weight were a bit smaller Let s do binary search each time checking if the answer is greater or equal to The check is simple enough Now the graph is binary edge exists if its weight is greater or equal to thus you should check for existence of Hamiltonian path not for the minimum weight one That can be done in leading to solution The key idea of that dp is storing the vertices where the path of the current mask could have ended as a mask itself Then it becomes with transitions Overall complexity or 
823,Mihai and Bianca are playing with bags of candies They have a row of bags of candies The th bag has candies The bags are given to the players in the order from the first bag to the th bag If a bag has an even number of candies Mihai grabs the bag Otherwise Bianca grabs the bag Once a bag is grabbed the number of candies in it gets added to the total number of candies of the player that took it Mihai wants to show off so he wants to reorder the array so that at any moment except at the start when they both have no candies Mihai will have candies than Bianca Help Mihai find out if such a reordering exists ,Let be the total number of candies with all bags with an even number of candies and the total of all bags with an odd number of candies If then the answer is because at the end Mihai who takes only even numbers of candies will have less candies than Bianca Otherwise if the answer is The construction is to simply put all even bags first and then all odd bags since all even bags come before all odd bags and at any point in time Mihai will have more candies than Bianca The time complexity is ,The answer is always Let s understand why it is so Let Then let Bob take the pile with candies and Alice take the pile with candies Then because of we can see that Bob s pile always can reach size of Alice s pile and remaining candies can be divided between them fairly except one candy if is odd 
824,You are given an undirected graph consisting of vertices and edges where is divisible by Each edge has a weight which is a positive greater than zero integer The graph has the following structure it is split into triples of vertices the first triple consisting of vertices the second triple consisting of vertices and so on Every pair of vertices from the same triple is connected by an edge There are no edges between vertices from different triples You have to paint the vertices of this graph into two colors red and blue Each vertex should have exactly one color there should be exactly red vertices and blue vertices The coloring is called valid if it meets these constraints The weight of the coloring is the sum of weights of edges connecting two vertices with different colors Let be the maximum possible weight of a valid coloring Calculate the number of valid colorings with weight and print it modulo ,Let s ignore the constraint on the number of red blue vertices for a moment What is the maximum possible weight of a coloring From any triple we can have any two edges connect vertices of different colors So the maximum possible weight of a coloring not necessarily a valid one is the sum of all edge weights except for the minimum weight in each triple Let s show that it is always possible to choose a valid coloring to achieve this weight In each triple we should make sure that the two maximum edges connect vertices with different colors to do this we can color the vertex incident to both of these edges in one color and the two other vertices will be painted in the other color So for each triple of vertices there will be either one red vertex and two blue ones or two red ones and one blue Let s suppose the first triples have one red vertex and two blue vertices each and the other triples have one blue vertex and two red vertices each That way we obtain a valid coloring with maximum possible weight Okay now let s try to find out how do we calculate the number of valid colorings with the maximum possible weight Each triple of vertices will be either red two red vertices one blue or blue the other way around Since exactly half of the vertices should be red then exactly half of the triples should be red so the number of ways to choose a color for all triples is After choosing the color of each triple let s choose how we actually color them The triples are independent so for each triple we can introduce the coefficient which is the number of ways to color it so that its weight is maximized and the triple has some specific type either red or blue doesn t matter since these are symmetric Choosing the vertex which will be different from its neighbors is equivalent to choosing the edge which will not be included in the weight of the coloring this is the edge which is not incident to the chosen vertex So is equal to the number of ways to choose that vertex in the th triple so that the weight is maximized i e the weight of the edge not incident to the chosen vertex should be minimized Thus is just the number of minimum edge weights in the th triple The formula for the final answer is ,We prove that the answer always always exists by constructing it Graph for is a single vertex Graph for is a clique of vertices Graph for some is obtained from the graph by adding vertices initially connected to nothing and vertices connected to all previously mentioned ones The vertices connected to nothing got degrees the vertices from the previous step increased their degrees by and finally there appeared vertices of degree The number is vertices is as needed 
825,You are policeman and you are playing a game with Slavik The game is turn based and each turn consists of two phases During the first phase you make your move and during the second phase Slavik makes his move There are doors the th door initially has durability equal to During your move you can try to break one of the doors If you choose door and its current durability is then you reduce its durability to the value is given During Slavik s move he tries to repair one of the doors If he chooses door and its current durability is then he increases its durability to the value is given The game lasts turns If some player cannot make his move then he has to skip it Your goal is to maximize the number of doors with durability equal to at the end of the game You can assume that Slavik the number of such doors What is the number of such doors in the end if you both play optimally ,Let s consider two cases If then the answer is because we can make opposite moves to the Slavik s moves and it always will reduce durability of some door so at some point we will reach the state when all doors will have durability Otherwise and we have to realize the optimal strategy for us If we have some door with durability then let s break it immediately why shouldn t we do this If we don t do it then Slavik will repair this door during his move So what Slavik will do now He will repair some door Which door he has to repair Of course the one with durability because otherwise we will break it during our next move So we can realize that doors with durability are not interesting for us because Slavik will make opposite moves to our moves And what is the answer if the number of doors with durability equals to It is ,At first let s prove that in optimal solution all spells of 1 st type are assigned to single creature By contradiction let s optimal answer contains indices where and If using spells of 1 st type is meaningless Otherwise if in general case then Contradiction So we can check for each creature maximal damage with its health multiplied At second if we sort all creatures in order by decreasing using spells on first creatures gives best answer So calculating answer for chosen creature invokes 2 cases if chosen creature is belong to first creatures then subtract from its contribution calculate new value and add it to otherwise we need one spell of second type which is optimal to take from th creature so along with replacing old value of chosen one we need to replace in contribution of th creature Result complexity is 
826,You are given an array consisting of positive integers You have to choose a positive integer and paint all elements into two colors All elements which are divisible by will be painted red and all other elements will be painted blue The coloring is called beautiful if there are no pairs of adjacent elements with the same color in the array Your task is to find any value of which yields a beautiful coloring or report that it is impossible ,What does it mean that no pair of adjacent elements should have the same color It means that either all elements on odd positions are blue and all elements on even positions are red or vice versa So we need to check these two cases Let s try to solve a case when we have to find a number such that are divisible by and are not What does it mean that divides all of the numbers It means that divides the where represents the greatest common divisor Let s calculate this using Euclidean algorithm or some built in functions in Okay now we need to check all divisors of the and find if any of them does not divide So we have to factorize and generate all of its divisors or do we In fact if divides any of the numbers then every divisor of also divides that number So the only two numbers we have to check as canditates for the answer are and ,There are two cases in this problem If we try to maximize the answer we need to consider only two integers and Of course the first one is better we get rid of the existing remainder and trying to add to this number If it s too big then we can and need to take the second one this number is just the first one but decreased by The answer can be always found between these numbers Time complexity 
827,Let be the number of positive divisors of a positive integer For example is divisible by and is divisible by and You are given an array of integers You have to process two types of queries for every replace with calculate Print the answer for each query ,At first let s notice that this function converges very quickly for values up to it s at most steps Now we should learn how to skip updates on the numbers and The function values can be calculated from the factorization of numbers in with Eratosthenes sieve Let s write two segment trees one will store maximum value on segment the other will store the sum When updating some segment check if its maximum is greater than Updates are done in the manner one can usually write build function you go down to the node corresponding to the segment of length and update the value directly Overall complexity as we access any segment no more than times ,Note the fact that if the number of minus signs is greater than the number of plus signs by at least then there is sure to be a pair of standing next to minus signs according to the Dirichlet principle When we apply the operation of replacing two adjacent minus signs with a plus sign the balance the difference of plus signs and minus signs increases by Then we need to find the number of subsections such that the balance on them is a multiple of and non positive then we can apply the operations until the balance is The balance value on the segment equals the balance value on the right boundary minus the balance value on the left boundary i e we can find by prefix sums 
828,One important contest will take place on the most famous programming platform Topforces very soon The authors have a pool of problems and should choose of them into this contest The prettiness of the th problem is The authors have to compose the most pretty contest in other words the cumulative prettinesses of chosen problems should be But there is one important thing in the contest preparation because of some superstitions of authors the prettinesses of problems cannot divide each other In other words if the prettinesses of chosen problems are then should be divisible by neither nor should be divisible by neither nor and should be divisible by neither nor If the prettinesses of chosen problems are and then neither should be divisible by nor should be divisible by Any contest composed from one problem is considered good Your task is to find out the maximum possible total prettiness of the contest composed of problems from the given pool You have to answer independent queries ,I know about some solutions that are trying to iterate over almost all possible triples but I have a better and more interesting one Possibly it was already mentioned in comments but I need to explain it Let s solve the problem greedily Let s sort the initial array The first number we would like to choose is the maximum element Then we need to pop out some maximum elements that are divisors of the maximum Then there are two cases the array becomes empty or we have some maximum number that does not divide the chosen number Let s take it and repeat the same procedure again but now we have to find the number that does not divide neither the first taken number nor the second taken number So we have at most three numbers after this procedure Let s update the answer with their sum This solution is almost correct Almost What have we forgotten Let s imagine that the maximum element is divisible by and and there are three following numbers in the array maximum divided by by and by Then their sum is greater than the maximum and may be greater than the answer we have because So if these conditions are satisfied let s update the answer with the sum of these three numbers It can be shown that this is the only possible triple that can break our solution The triple does not match because the maximum divided by divides the maximum divided by The triple is bad for the same reason And the triple has sum less than the maximum element ,Let be the number of occurences of the number in the given array easy to see that we can ignore the numbers greater than Let s iterate over and and increase the value in the position in some array by the value So the value equals the number of numbers in the given array which divide Let s find the minimal with the maximum value Easy to see that the answer to the problem is the numbers which divide Let s calculate the complexity of the solution The number of the pairs we can bound with the value 
829,It s been almost a week since Polycarp couldn t get rid of insomnia And as you may already know one week in Berland lasts days When Polycarp went to a doctor with his problem the doctor asked him about his sleeping schedule more specifically the average amount of hours of sleep per week Luckily Polycarp kept records of sleep times for the last days So now he has a sequence where is the sleep time on the th day The number of records is so large that Polycarp is unable to calculate the average value by himself Thus he is asking you to help him with the calculations To get the average Polycarp is going to consider consecutive days as a week So there will be weeks to take into consideration For example if and then the result is You should write a program which will calculate average sleep times of Polycarp over all weeks ,To get the sum for th week you need to take sum of th week subtract first element of th week from it and add up last element of th week All common elements will remain Thus by moving right week by week calculate sum of all weeks and divide it by Overall complexity ,Note that it is always advantageous for us to complete the task that has an earlier deadline first Only then will we proceed to the next task Then we can solve each problem independently for each exam Then it remains to score percent on the task on the available options This is a typical knapsack problem with an answer recovery 
830,You are given a sequence consisting of integers You can choose any non negative integer i e and for each you can add only once i e perform or subtract only once i e perform or leave the value of unchanged It is possible that after an operation the value becomes negative Your goal is to choose such and perform changes in such a way that all are equal i e Print the required or if it is impossible to choose such value print For example for array the value is minimum possible because you can obtain the array if you will add to and subtract from And for array the value is also minimum possible You can add it to and subtract it from and obtain the array ,Let s leave only unique values of the given array in the array i e construct an array that is actually array without duplicate element and sort it in ascending order Then let s consider the following cases If the length of is greater than then the answer is if the length of is then there are two cases if then the answer is otherwise the answer is if the length of is then there are also two cases if is even then the answer is otherwise the answer is and if the length of is then the answer is ,Let s count the number of pairs with multiple less than To get the number of not less pairs we should sumply subtract from the number of less pairs Let be the number of values in equal to and be the number of pairs from with the multiple equal to To calculate the values from we can use something like Eratosthenes sieve let s iterate over the first multiplier and the multiple of it and increment by the value After calculating the array we should calculate the array of its partial sums and find the number of less pairs in time 
831,You are given a permutation consisting of exactly integers from to since it is a permutation each integer from to occurs in exactly once and two strings and consisting of lowercase Latin letters A substring of string is an of string if the following conditions are met for each either or where is the index of character in Latin alphabet For example if then three substrings of are occurences of they are and For each substring of having length equal to check if it is an of ,We will run two tests for each substring of we are interested in If at least one of them shows that the substring is not an occurence of we print otherwise we print The first test is fairly easy The given permutation can be decomposed into cycles Let s replace each character with the index of its cycle in both strings and check if each substring of is equal to after this replacement for example using regular KMP algorithm If some substring is not equal to after the replacement then it is definitely not an occurence The second test will help us distinguish the characters belonging to the same cycle Let be some cycle in our permutation elements are listed in the order they appear in the cycle so We will replace each character with a complex number in such a way that the case when they match are easily distinguishable from the case when they don t match One of the ways to do this is to replace with a complex number having magnitude equal to and argument equal to if this character belongs to or to if this character belongs to How does this replacement help us checking the occurence If we multiply the numbers for two matching characters we get a complex number with argument equal to or to and its real part will be In any other case the real part of the resulting number will be strictly less than and the difference will be at least So if we compute the value of for the th substring of where is the number that replaced the character we can check if the real part of the result is close to the value we would get if we matched with itself and if the difference is big enough at least one pair of characters didn t match The only case when this method fails is if we try to match characters from different cycles of the permutation that s why we needed the first test Overall the first test can be done in using prefix function or any other linear substring search algorithm and the second test can be done in if we compute the aforementioned values for each substring using FFT ,By the definition of lexicographical comparing we can see that if we can remove one character we always have to do it Besides we have to remove the character from the leftmost position such that and or from the position if there is no such 
832,You want to build a fence that will consist of equal sections All sections have a width equal to and height equal to You will place all sections in one line side by side Unfortunately the ground beneath the fence is not flat For simplicity you can think that the ground level under the th section is equal to You should follow several rules to build the fence the consecutive sections should have a common side of length at least the first and the last sections should stand on the corresponding ground levels the sections between may be either on the ground level or higher but not higher than from the ground level the height should be an integer Is it possible to build a fence that meets all rules ,Let s set sections from left to right Note that for the th section all valid heights heights for which it s possible to choose heights for all sections meeting all rules and finishing with the height of equal to form a segment It s not hard to prove by induction For the first section the valid segment is The step of induction if the valid segment for is then valid s for is the segment since for each you can find at least one in which don t break the first rule If for any the correct segment is empty or if we can t fulfill the third rule then there is no answer otherwise at least one answer is always exist As a result to solve the problem you should just maintain the segment of valid using the formula above while iterating Complexity is ,The triangle with side is degenerate if So we have to maximize the length of the longest side and minimize the total length of other sides Thus if then we answer if otherwise the answer is 
833,You are given a following process There is a platform with columns squares are appearing one after another in some columns on this platform If there are no squares in the column a square will occupy the bottom row Otherwise a square will appear at the top of the highest square of this column When all of the columns have at least one square in them the bottom row is being removed You will receive point for this and all the squares left will fall down one row You task is to calculate the amount of points you will receive ,The answer will be equal to where is the number of squares that will appear in the th column ,Really low constraints choosing some permutation Surely this will be some dp on subsets At first let s get rid of For each two rows calculate the minimum difference between the elements of the same columns let s call this for some rows This will be used to put row right after row Let s also calculate the minimum difference between the elements of the column of row and column of row This will be used to put row as the last row and row as the first one Now let s think of choosing the permutation as choosing the traversal of the following graph Vertices are rows and the weights of edges between the vertices are stored in However you can t straight up do minimum weight Hamiltonian cycle search as the edge between the first vertex and the last one should be of weight from and not Let s fix some starting vertex and find minimum weight Hamiltonian paths from it to all vertices Finally update the answer with That will lead to approach minimum weight Hamiltonian path is a well known problem solved by That s completely fine and it s the most intended solution However there exist another solution that would have worked better if the edge weight were a bit smaller Let s do binary search each time checking if the answer is greater or equal to The check is simple enough Now the graph is binary edge exists if its weight is greater or equal to thus you should check for existence of Hamiltonian path not for the minimum weight one That can be done in leading to solution The key idea of that dp is storing the vertices where the path of the current mask could have ended as a mask itself Then it becomes with transitions Overall complexity or 
834,You are given a positive integer In one move you can increase by one i e make Your task is to find the minimum number of moves you need to perform in order to make the sum of digits of be less than or equal to You have to answer independent test cases ,Firstly let s check if the initial fits the conditions If it is print and continue Otherwise let s solve the problem greedily At first let s try to set the last digit to zero Let We need exactly moves to do that Let s add this number to and to the answer and check if the current fits the conditions If it isn t let s try to set the previous last digit to zero Let Then we need moves to do that Let s add this number to and to the answer and check if the current fits the conditions If it isn t repeat the same with the third digit and so on This cycle can do no more than iterations And we can fing the sum of digits of in at most iterations too decimal logarithm of So the total time complexity is , cannot be transformed into any other number can be transformed into or and can be transformed only into It means that if then only is reachable and if or then should be less than Otherwise we can make as large as we want so if any is reachable 
835,You are given permutations each of length Recall that a permutation of length is a sequence of integers from to Let the beauty of a permutation be the largest such that If then the beauty is The product of two permutations is a permutation such that For each from to print the largest beauty of a permutation over all from to possibly ,Let s try to solve for one of the given permutations Let it be some How to make the answer for it at least Well we have to find another permutation such that How about at least Well the same Push to the right side of the equation Now think What does it actually mean for some permutation to be multiplied by It stays the same So the first elements of will be equal to the first elements of Thus you have to find a permumtation such that its inverse has the longest common prefix with This can be done in multiple ways For example you can store all inverses in a trie and traverse it with until you reach a dead end Or simply push all prefixes of each inverse into a set and iterate over Alternatively you can just sort inverses and do lower bound for in this list the permutation with longest common prefix will be either the result or the one before it Overall complexity per testcase ,The first observation is that we are interested only in patterns of kind All other patterns don t make sense at all So let s build a greedy approach Let s iterate over the given array from the left to the right and maintain that the prefix of the given answer is already correct If now we are at some position and and the prefix from to is already correct then which one we have to replace When we replace the left one then we cannot do better in the future but when we replace the right one then we can fix some on the suffix of the array The easiest example is If now we are at the position then we will do better if we will set 
836,A one dimensional Japanese crossword can be represented as a binary string of length An encoding of this crossword is an array of size where is the number of segments formed completely of s and is the length of th segment No two segments touch or intersect For example If and the crossword is then its encoding is an array If and the crossword is then its encoding is an array If and the crossword is then its encoding is an array If and the crossword is then its encoding is an empty array Mishka wants to create a new one dimensional Japanese crossword He has already picked the length and the encoding for this crossword And now he needs to check if there is crossword such that its length and encoding are equal to the length and encoding he picked Help him to check it ,The only answer is when no segment can be moved one cell either to the left or to the right So there should be exactly one cell between two consecutive segments and the first and the last segments should touch the borders Thus total count of cells needed is Overall complexity ,Let s see how the matrix looks like after some sequence of shoots The matrix consists of or There is at least one at position or and any not at position or must have below or right If the second condition is violated then the in the corresponding cell would continue its flight Thus it is necessary and sufficient to verify that the matrix satisfies the condition above 
837,You were walking down the street and heard a sound The sound was described by the string consisting of lowercase and uppercase Latin characters Now you want to find out if the sound was a cat meowing For the sound to be a meowing the string can only contain the letters and in either uppercase or lowercase Also string must start with non empty sequence consisting only of characters or it must be immediately followed by non empty sequence consisting only of characters or it must be immediately followed by non empty sequence consisting only of characters or it must be immediately followed by non empty sequence consisting only of characters or this sequence ends the string after it immediately comes the string end For example strings describe a meowing but strings do not Determine whether the sound you heard was a cat meowing or something else ,To solve the problem you may convert the string to lower case strip all duplicated characters from it and compare the result to meow string To exclude duplicate characters you can for example use the function in C ,Let s sort all the strings by comparator and concatenate them Let s prove that it s the optimal answer Let that operator be transitive so if Consider an optimal answer with two strings in reverse order by that operator Because of the transitivity of operator we can assume that pair of strings are neighbouring But then we can swap them and get the better answer Let s prove the transitivity of operator Consider the strings as the base numbers Then the relation equivalent to The last is simply the relation between real numbers So we proved the transitivity of the relation 
838,There are segments drawn on a plane the th segment connects two points and Each segment is non degenerate and is either horizontal or vertical formally for every either or but only one of these conditions holds Only segments of different types may intersect no pair of horizontal segments shares any common points and no pair of vertical segments shares any common points We say that four segments having indices and such that and form a rectangle if the following conditions hold segments and are horizontal segments and are vertical segment intersects with segment segment intersects with segment segment intersects with segment segment intersects with segment Please calculate the number of ways to choose four segments so they form a rectangle Note that the conditions and should hold ,Let s iterate over the lower horizontal segment Denote its coordinates as and where We call vertical segment good if followings conditions holds Now let s use the scanline method At first for each good vertical segment we increment the value of element in position in some data structure for example Fenwick Tree Next we will process two types of queries in order of increasing their y coordinate horizontal segments with coordinates upper point of some vertical segment with coordinates And if two events of different types have the same y coordinate then the event of first type must be processed first For event of first type we need to find sum on range in our data structure Let s denote this sum as Then we need to add to the answer because we have vertical segments which intersect with both fixed horizontal segments and we can choose two of them in so many ways For event of second type we just need decrement the value of element in position in our data structure ,One of the possible answers is always a pair of endpoints of the given segments So we can add all endpoints to the array and iterate over all pairs of elements of this array and check if the current pair is suitable or not 
839,You are given an array of length You are also given a set of positions where The position means that you can swap elements and You can apply this operation any number of times for each of the given Your task is to determine if it is possible to sort the initial array in non decreasing order using only allowed swaps For example if and then we can first swap elements and because position is contained in the given set We get the array Then we swap and position is also contained in We get the array Finally we swap and again and get the array sorted in non decreasing order You can see that if and then you cannot sort the array You have to answer independent test cases ,The simple simulation works here while there is at least one inversion such a pair of indices and that we can fix let s fix it we can fix this inversion if If there are inversions but we cannot fix any of them the answer is Otherwise the answer is There is also a solution it is obvious that we have some segments in which we can change the order of elements as we want And it is also obvious that we cannot move elements between these allowed segments So each of them is independent of each other We can just find all these segments of indices using two pointers and sort them independently Then we just need to check if the array becomes sorted Time complexity is or ,First of all since the second operation changes all occurrences of some number to other number and vice versa then by using it we can convert an array into another array if there exists a bijection between elements in the first array and elements in the second array It can also be shown that so we can consider that if we want to transform an array into another array then we first apply the function then the function Another relation that helps us is that it means that every time we apply the function we can easily rollback the changes Considering that we have already shown that a sequence of transformations can be reordered so that we apply only after we ve made all operations with the function let s try to rollback the second part of transformations i e for each array find some which can be obtained by using the function Since applying the second operation several times is equal to applying some bijective function to the array we can treat each array as a partition of the set into several subsets So if we are not allowed to perform the first operation the answer to the problem is equal to where is the number of ways to partition a set of objects into non empty sets these are known as There are many ways to calculate Stirling numbers of the second kind but in this problem we will have to use some FFT related approach which allows getting all Stirling numbers for some value of in time For example you can use the following relation If we substitute and we can see that the sequence of Stirling numbers for some fixed is just the convolution of sequences and For simplicity in the following formulas let s denote We now know that this value can be calculated in Okay now back to the original problem Unfortunately we didn t take the operation into account Let s analyze it The result of function consists of several blocks of equal elements and it s easy to see that the lengths of these blocks except for maybe the last one should be divisible by The opposite is also true if the lengths of all blocks except maybe for the last one are divisible by some integer then the array can be produced as for some array What does it mean If the greatest common divisor of the lengths of the blocks except for the last one is not the array that we consider can be obtained by applying the function to some other array Otherwise it cannot be obtained in such a way Now inclusion exclusion principle comes to the rescue Let s define as the number of arrays that we consider which have the lengths of all their blocks except maybe for the last one divisible by It s easy to see that we can compress every consecutive elements into one Then using inclusion exclusion principle we can see that the answer is where is the Mobius function Using this formula we can calculate the answer in This inclusion exclusion principle handles the arrays according to the GCD of the blocks that they consist of except for the last one But what if the array consists only of one block These arrays can be counted wrongly so we should exclude them i e use instead of just and count the arrays consisting of the same element if we need any of them in the answer separately Depending on the way you implement this or or both may be a corner case 
840,A permutation of size is given A of size is an array of size in which each integer from to occurs exactly once For example and are correct permutations while and are not Let us consider an empty deque double ended queue A deque is a data structure that supports adding elements to both the beginning and the end So if there are elements currently in the deque adding an element to the beginning will produce the sequence and adding same element to the end will produce The elements of the permutation are sequentially added to the initially empty deque starting with and finishing with Before adding each element to the deque you may choose whether to add it to the beginning or the end For example if we consider a permutation one of the possible sequences of actions looks like this 1 add to the end of the deque deque has a sequence in it 2 add to the beginning of the deque deque has a sequence in it 3 add to the end of the deque deque has a sequence in it 4 add to the end of the deque deque has a sequence in it Find the lexicographically smallest possible sequence of elements in the deque after the entire permutation has been processed A sequence is than the sequence if there exists such that and In other words if the sequences and have some possibly empty matching prefix and the next element of the sequence is strictly smaller than the corresponding element of the sequence For example the sequence is smaller than the sequence because after the two matching elements in the start the first sequence has an element which is smaller than the corresponding element in the second sequence ,We ll process the permutation elements one by one For the first element it doesn t matter which side of the deque we add it to the result of its addition will be the same there will be a sequence of one element equal to the first permutation element in the deque Now let s consider adding the th element of a permutation to the deque First will be considered then and so on up to Let us describe the general algorithm for choosing the side of the deque for each step Note that if the elements are now in the deque then all final permutations that can be obtained in the deque from the current state can be broken down into pairs of the form where the beginning and the end of the final permutations hidden behind are obtained by the same sequences of all the following choices and thus are equal between the first and the second Note that when the first permutation will always be lexicographically smaller than the second one and vice versa Therefore regardless of the following choices if then the second permutation will never be minimal and if then the first permutation will never be minimal This means that we can make a choice about the side of the deque to add the th element to based only on its relation to if then is added to the beginning of the deque otherwise to the end The time complexity is Alternative solutions which also fit in the time limit involved finding a lexicographically minimal increasing sequence in the reversed original permutation and could be implemented either with time complexity or with time complexity if the permutation s definition was taken into consideration ,First of all if is even then there is no solution since the number of calls is always odd one call in the beginning and each call makes either or recursive calls Then if is odd let s try to start with a sorted permutation and try to unsort it Let s make a function that will do it When we unsort a segment we can either keep it sorted if we already made enough calls or make it non sorted and then call and if we need more calls When we make a segment non sorted it s better to keep its both halves sorted an easy way to handle this is to swap two middle element It s easy to see that the number of calls is equal to the number of calls to sort the resulting permutation so we can use this approach to try getting exactly calls 
841,A is a figure of the following type an asterisk character in the center of the figure and four rays to the left right top bottom of the same positive length The size of a is the length of its rays The size of a star must be a positive number i e rays of length are not allowed Let s consider empty cells are denoted by then the following figures are You are given a rectangular grid of size consisting only of asterisks and periods dots Rows are numbered from to columns are numbered from to Your task is to draw this grid using number of or find out that it is impossible can intersect overlap or even coincide with each other The number of in the output can t exceed Each star should be completely inside the grid You can use stars of same and arbitrary sizes ,I am sorry that some solutions pass tests in this problem also I was supposed to increase constraints or decrease time limit The general idea of this problem is the same as in the previous problem But now we should do all what we were doing earlier faster The solution is divided by two parts The first part Let s calculate four matrices of size and will denote the distance to the nearest dot character to the top from the current position The same will denote the distance to the nearest dot character to the bottom from the current position to the left and to the right We can calculate all these matrices in using easy dynamic programming If we will iterate over all possible from to and from to we can easy see the next if the current character is dot then Otherwise if then and if then Rest two matrices can be calculated the as well as these two matrices but we should iterate over all from to and from to So this part of the solution works in After calculating all these matrices the maximum possible length of rays of the with center in position is The second part is to draw all in Let s calculate another two matrices of size and Let s iterate over all in our answer Let the center of the current is and its size is Let s increase by one and decrease by one if The same with the matrix Increase and decrease if Then let s iterate over all possible from to and from to If then set and if set How to know that the character at the position is asterisk character or dot character If either or greater than zero then the character at the position in our matrix will be the asterisk character Otherwise it is the dot character This part works also in Time complexity of the solution ,After some tinkering with the given condition we notice that an compression is possible iff divides and the matrix is divisible into matrices such that each matrix is either all 1 or all 0 We can loop over all such and check the condition in time per but this is potentially too slow To speed this up we can precompute rectangle sums for every rectangle containing the upper left corner which enables us to compute the sum of any rectangle in This improves our time complexity to Since really this means our solution is Code 49028814 
842,The rules of Sith Tournament are well known to everyone Sith take part in the Tournament The Tournament starts with the random choice of two Sith who will fight in the first battle As one of them loses his place is taken by the next randomly chosen Sith who didn t fight before Does it need to be said that each battle in the Sith Tournament ends with a death of one of opponents The Tournament ends when the only Sith remains alive Jedi Ivan accidentally appeared in the list of the participants in the Sith Tournament However his skills in the Light Side of the Force are so strong so he can influence the choice of participants either who start the Tournament or who take the loser s place after each battle Of course he won t miss his chance to take advantage of it Help him to calculate the probability of his victory ,Let s solve the problem using dynamic programming the maximal probability of Ivans victory if the siths from the already fought and the th sith left alive To calculate that DP we should iterate over the next sith he will fight against the th sith ,The example tests suggest that there is only one possible distribution with a draw Let s find out why it is so We will use a process similar to induction recursion to distribute the cards between the two players so that the game ends in a draw suppose Alex receives the card Then he wins since he can play it immediately So for the game to result in a draw Boris must receive the card suppose Boris receives the card Then he wins since he also has the card he can use it to answer any first move of Alex and then win the game by playing So for the game to result in a draw Alex must receive the card suppose Boris receives the card Then he wins since he also has the card if Alex plays the card Boris responds with and then plays if Alex plays some other card Boris responds with and the plays So for the game to result in a draw Alex must receive the card and so on In fact if Alex receives the card and Boris receives the card Alex must play the card or something equivalent to it on the first move and Boris must respond with the card so we can consider the game without these two cards with the roles swapped So if we consider the distribution of cards as a string with characters and where denotes the card belonging to Alex and denotes the card belonging to Boris and the th character of the string represents the card the only possible distribution for the draw is But there s more to this string representation of the distribution of cards the first character that is different from this pattern denotes the winner if the first different character is in the draw distribution and in the distribution we consider the winner is Boris otherwise the winner is Alex This may lead us to the following ways to count the number of possible distributions which win lose for Alex we can use dynamic programming of the form where is the number of characters we used is the number of characters we used and is or depending on whether our string coincides with the draw string differs from it in a way that Alex wins or differs from it in a way that Boris wins the actual value of must be the number of ways to reach this state of dynamic programming The answer then is stored in the states of the form or we can use combinatorics let s iterate on the length of the prefix that is common in the draw string and in the string representing the distribution of cards and then count the number of ways to distribute the remaining characters with a binomial coefficient To calculate the binomial coefficients we can use one of the following methods Pascal s triangle precalculating factorials and modular inverses to then or calculating factorials with big integers in Java or Python 
843,You are given a board of size where is not divisible by Initially each cell of the board contains one figure In one move you can select presented in some cell and move it to one of the cells i e from the cell you can move the figure to cells Of course you move figures to cells out of the board It is allowed that after a move there will be several figures in one cell Your task is to find the minimum number of moves needed to get into cell i e cells should contain figures and one cell should contain figures You have to answer independent test cases ,It is intuitive and provable that the best strategy is to move each figure to the center cell Now with some paperwork or easy observations we can notice that we have exactly cells with the shortest distance cells with the shortest distance cells with the shortest distance and so on So we have cells with the shortest distance So the answer is It can be rewritten as so we can just calculate the sum of squares of all integers from to using loop or formula and multiply the answer by Time complexity or ,Firstly if is odd then the answer is by obvious reasons Otherwise we can notice that the top left and the bottom right values of the tile do not matter since we can place tiles symmetrically So we only need to check that there is some tile that its top right value equals its bottom left value because this is how we get main diagonal symmetry 
844,You are given four integers and Initially and You can do the following operation times Choose either or and decrease it by one However as a result of this operation value of cannot become less than and value of cannot become less than Your task is to find the possible product of and you can achieve by applying the given operation no more than times You have to answer independent test cases ,The only fact required to solve the problem if we start decreasing the number we are better to end decreasing it and only then decrease the other number So we can just consider two cases when we decrease first and after that and vice versa and just take the minimum product of these two results The rest is just implementation ,The naive solution would be the number of sequences of allowed digits with length and sum We compute it for and for every possible and the answer is Let s speed this up Let s denote the following polynomial where if is an allowed digit otherwise It s easy to see that the coefficients of are equal to the values of Using mathematical induction we may prove that the coefficients of are equal to So now we need to compute There are two possible ways to do this that result in complexity The first option is to apply binary exponentiation with NTT polynomial multiplication The second option is to use the fact that if we apply NTT to a polynomial we get a set of its values in some points So if we exponentiate these values we get a set of values of exponentiated polynomial in the same points So we may apply NTT to treating it as a polynomial of degree raise each resulting value to the power of and apply inverse transformation 
845,Let s call two strings and both of length if they have the same character in some position i e there exists at least one such that You are given a binary string of length a string of characters and or and an integer Let s denote the string as the substring of starting from the th character and ending with the th character that is Let s call a binary string of length if it is to all substrings of having length exactly that is it is to Your goal is to find the smallest string that is or report that no such string exists String is lexicographically less than string if either is a prefix of and or there exists such that and for any ,Let s denote as the number of substrings of having length exactly so The first and crucial observation is that if then the answer always exists Each of substrings forbids one of the strings from being the answer a string is forbidden if every each character differs from the corresponding character in one of the substrings we can forbid at most strings from being the answer and the number of possible candidates for the answer is This observation leads us to a more strong fact that actually allows us to find a solution we can set the first characters in the answer to all the remaining characters are enough to find the answer There are at most possible combinations of the last characters and this number is not greater than Let s iterate on each substring of of length and check which combination it forbids by inverting the last characters of the substring After that find the minimum unforbidden combination Note that there may be a case when a substring doesn t actually forbid any combination if there are zeroes in the first characters of the substring it is to the answer no matter which combination we choose This can be checked by precalculating the closest position of zero to the left right of each index The whole solution works in per test case the hardest part is inverting the suffix of each substring we are interested in ,Note that the actual problem is to divide the string into two subsequences that both of them are non decreasing You can note that this is true because you cannot the relative order of the elements colored in the same color but you can write down subsequences of different colors in any order you want In this problem you can write the following dynamic programming is if you can split the prefix of the string into two non decreasing sequences such that the first one ends with the character and the second one with characters are numbered from to otherwise is zero Initially only other values are zeros Transitions are very easy if the current value of dp is then we can make a transition to if and to if Then you can restore the answer by carrying parent values But there is another very interesting solution Let s go from left to right and carry two sequences and If the current character is not less than the last character of then let s append it to otherwise if this character is not less than the last character of then append it to otherwise the answer is If the answer isn t then and are required sequences The proof and other stuff will be in the editorial of the hard version Time complexity or or 
846,You are given an integer sequence You have to divide it into two sets and in such a way that each element belongs to set and is minimum possible The value is the absolute value of and is the sum of elements of the set ,The first solution take modulo and solve the problem manually then for cases and the answer is and for and the answer is Prove Let s see what can we make for numbers and We can add and in and add and in Then the difference between sums will be We can consider last four numbers this way until we have at least four numbers And then we have a case We can prove the solution for these four cases using bruteforce The second solution if is even then the answer is otherwise the answer is The formula above is just Prove if we have an integer sequence then we can obtain every number from to as the sum of some elements of this sequence How Greedily You can see how this greedy works and prove if you want yourself So what s next If is even then we can obtain the sum in and in Otherwise we can only obtain in and in or vice versa ,Note is that after doing two operations of the same type they are cancelled out in terms of parity since we would change the parity of all elements once then change it back again So we know that we will do each operation exactly or time It is possible to check all possible cases just by simulating or we can notice that all elements on all indices of the same parity have the same parity and if they do we can always find an answer by doing just a single type of operation a single time in case the array doesn t already contain all elements of the same parity The time complexity is 
847, loves simple strings A string is called simple if every pair of adjacent characters are distinct For example are simple whereas are not simple is given a string He wants to change a minimum number of characters so that the string becomes simple Help him with this task ,There are two ways to solve this problem greedy approach and dynamic programming The first apprroach Considerr some segment of consecutive equal characters Let be the length of that segment Easy to see that we should change at least characters in the segment to remove all the pairs of equal consecutive letters On the other hand we can simply change the second the fourth etc symbols to letter that is not equal to the letters before and after the segment ,Let s iterate over all characters of the string from left to right excluding last character Suppose is a position of the current element of the string If increase answer by and increase by else just increase by 
848,Let s define a multiplication operation between a string and a positive integer is the string that is a result of writing copies of one after another For example A string is divisible by another string if there exists an integer such that For example is divisible by but is not divisible by or LCM of two strings and defined as is the shortest non empty string that is divisible by both and You are given two strings and Find or report that it does not exist It can be shown that if exists it is unique ,We should notice that if some string is a multiple of string then is a multiple of This fact leads us to the conclusion that should be a common multiple of and Since we want to minimize the length of the string then its length is So we have to check that copies of the string equal to copies of the string If such strings are equal print them otherwise there is no solution ,The answer is when in string there is a character that is not in string Otherwise let s precalculate the following array minimum index from to such that if there is no such index then Now we can solve this problem by simple greed Presume that now and last taken symbol in is Then there are two options if then if then and is equal to initially 
849,Let s denote as an infinite sequence of integers such that and where is the greatest common divisor of two integer numbers sorted in ascending order The elements of are indexed for example and are the first the second and the third elements of respectively You have to process queries Each query is denoted by three integers and and the answer to this query is th element of ,Let s use binary searching to find the answer Denote as the number of positive integers such that and the answer is the smallest integer such that We may use for example as the right border of segment where we use binary searching although the answers are a lot smaller than this number for it is obvious that will be really large for any from How can we calculate fastly Let s factorize and use inclusion exclusion Let be a subset of the set of prime divisors of and be the product of all numbers from For each possible subset we have to add to the result since there are exactly integers from divisible by every prime from Since any number from has at most prime divisors there are at most subsets to process ,Let s denote the difference between and as Then if has a prime divisor we can subtract from times The only positive integer that doesn t have any prime divisors is So the answer is if and only if 
850,A bracket sequence is a string containing only characters and A regular bracket sequence or shortly an RBS is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and bracket sequences and are not There was an RBS Some brackets have been replaced with question marks Is it true that there is a way to replace question marks with brackets so that the resulting sequence is an RBS ,There are many different approaches to this problem but I think the model solution has the most elegant one First of all let s construct an RBS from the given string it always exists so it is always possible By calculating the number of opening brackets closing brackets and questions in the given string we can compute the number of question marks that should be replaced with opening brackets it is easy since exactly half of the characters in each RBS are opening brackets Then let s form the RBS greedily replace the first several question marks with opening brackets and all remaining ones with closed brackets Okay then what about finding a second RBS Recall that a bracket sequence is an RBS when for each of its positions the number of closing brackets before it is not greater than the number of opening brackets before it and these two values should be equal at the end of the sequence but it is less important now Consider the segment between the last question mark replaced with an opening bracket and the first question mark replaced by the closing bracket If we try to change the order of characters corresponding to question marks the balance on this segment will decrease at least by since at least one opening bracket to the left of it will become a closing bracket Is there a way to affect only this segment and change the balance on it only by Yes just swap the endpoints of this segment i e the last opening bracket that was a question mark and the first closing bracket that was also a question mark If it yields an RBS then the answer is Otherwise the answer is since any other permutation of characters that were replacing question marks will also decrease the balance on this segment by at least ,There are two solutions to this problem casework and greedy The greedy solution goes as follows the number of opening brackets in an RBS should be exactly and if there is a closing bracket before an opening bracket it s optimal to swap them if possible So we should replace the first question marks with opening brackets other question marks with closing brackets and if the answer exists this method will find it All that s left is to check that the resulting sequence is an RBS The casework solution goes as follows first of all each RBS should have an even length so if is odd there is no answer Furthermore an RBS always begins with an opening bracket and always ends with a closing bracket so if the first character is a closing bracket or the last character is an opening bracket there is no answer Since there is at most one opening bracket and at most one closing bracket in the original sequence these three constraints are enough if the opening bracket is before the closing bracket then they balance out and all other characters can be replaced in such a way that they form an RBS of length If the opening bracket is after the closing bracket then the first and the last characters are question marks since the first character is not a closing bracket and the last one is not an opening bracket We should replace the first character with an opening bracket the last character with a closing bracket so we get four characters two opening and two closing brackets which balance themselves out All other question marks can be replaced in such a way that they form an RBS of length So all we have to check is that is even the first character is not a closing bracket and the last character is not an opening bracket 
851,You are given two arrays of integers and For each element of the second array you should find the number of elements in array that are less than or equal to the value ,Let s sort all numbers in a Now let s iterate over elements of b and for element bj find the index of lowest number that is greater than bj We can do that using binary search That index will be the answer for value bj Complexity O nlogn ,We have to find the number of triples such that equations and are satisfied Let s subtract one equation from another and get that So we know that and after substituting we get that We can see that there is only one correct value of and for every odd value of greater than So we can iterate over the value of and check that the corresponding value of doesn t exceed This solution works in because but you can also solve it in 
852,Sir Monocarp Hamilton is planning to paint his wall The wall can be represented as a grid consisting of rows and columns Initially the wall is completely white Monocarp wants to paint a black picture on the wall In particular he wants cell the th cell in the th row to be colored black if and to be left white if Additionally he wants each column to have at least one black cell so for each the following constraint is satisfied or both of them will be equal to In order for the picture to turn out smooth Monocarp wants to place down a paint brush in some cell and move it along the path so that for each and share a common side all black cells appear in the path white cells don t appear in the path Determine if Monocarp can paint the wall ,Why is there a constraint of each column having at least one black cell Does the problem change a lot if there were white columns Well if such a column was inbetween some black cells then the answer would be If it was on the side of the grid you could remove it and proceed to solve without it So that doesn t really change the problem other than removing some casework Let s try to fix a start Find a column that has only one black cell in it If there are no such columns the answer is immediately Otherwise the path will always go through it in known directions to the left and to the right if both of them exist Let s solve the problem separately for the left part of the path and for the right one find a path that starts to the left of it and covers everything to the left and the same for the right part Consider the right part If the next column also has one black cell then we can determine where to go uniquely If this cell is on the opposite row then the answer is Otherwise go there and proceed further Let it have two black cells now Find the entire two black row rectangle of maximum size that starts there If there s nothing after it you can easily traverse it any way you like Otherwise you have to traverse it in such a way that you end up in its last column then go to the right from there Turns out there s only one way to achieve that Go up down to another row go right up down to another row right and so on Now you just have to check if you end up in the correct row Thus you can simulate the path to the left and to the right and check if you never get stuck Overall comlexity per testcase ,The answer is if and only if is divisible by because if you number all vertices of the initial polygon from to clockwise then you need to take every vertex divisible by and this number obviously should be integer and there is no other way to construct the other polygon 
853,We guessed a permutation consisting of integers The permutation of length is the array of length where each element from to appears exactly once This permutation is a secret for you For each position from to we chose some other index and gave you the segment in order i e we rearranged the elements of this segment in a way that the elements of this segment are sorted Thus you are given exactly segments of the initial permutation but elements inside each segment are sorted The segments are given to you in random order For example if the secret permutation is then the possible given set of segments can be Your task is to find suitable permutation i e any permutation corresponding to the given input data It is guaranteed that the input data corresponds to some permutation i e such permutation exists You have to answer independent test cases ,Let s fix the first element and then try to restore permutation using this information One interesting fact if such permutation exists with this first element then it can be restored uniquely Let s remove the first element from all segments containing it we can use some logarithmic data structure for it Then we just have a smaller problem but with one important condition there is a segment consisting of one element again if such permutation exists So if the number of segments of length 1 is zero or more than one by some reason then there is no answer for this first element Otherwise let s place this segment a single element in second place remove it from all segments containing it and just solve a smaller problem again If we succeed with restoring the permutation then we need to check if this permutation really satisfies the given input segments see the first test case of the example to understand why this case appears Let s just iterate over all i from 2 to n and then over all j from i 1 to 1 If the segment a j a j 1 dots a i is in the list remove it and go to the next i If we can t find the segment for some i then this permutation is wrong Time complexity O n 3 log n or less maybe ,The easiest way to solve to problem is probably to see the resemblense of a shuffle operation to an std rotate function So you can obtain the final deck by applying cyclic shifts of the deck by then and so on Since the shifts are cyclic it doesn t matter if you shift by or by or by for any non negative The result will be the same Thus you can calculate the sum of rotations you apply and subtract until it becomes less than That is taking it modulo Finally after rotating a sequence by some the th element of it indexed becomes the first one Thus you just want to print the th element of Overall complexity per testcase 
854,Reziba has many magic gems Each magic gem can be split into normal gems The amount of space each magic and normal gem takes is unit A normal gem cannot be split Reziba wants to choose a set of magic gems and split some of them so the total space occupied by the resulting set of gems is units If a magic gem is chosen and split it takes units of space since it is split into gems if a magic gem is not split it takes unit How many different configurations of the resulting set of gems can Reziba have such that the total amount of space taken is units Print the answer modulo Two configurations are considered different if the number of magic gems Reziba takes to form them differs or the indices of gems Reziba has to split differ ,Let s reformulate the solution to the form of dynamic programming the number of ways to split the gems so that the total amount of space taken is Then there are obvious transitions of either splitting the last gem or not And that can be easily rewritten in such a way that matrix exponentiation becomes the solution Overall complexity , All elements in the left set smaller than all elements in the right set means that there is such value that all elements from the first set less than and all elements from the second set are more or equal to So let s make a sweep line on from to while trying to maintain all answers for each prefix Let s maintain for each the total cost to make sets good if we split the permutation on sets and in such way that after transformations all elements in the first set less than It s easy to see that the total cost is equal to sum of weights where and and where and So what will happen if we increase by Let s define the position of as For each we don t need to move to the second set anymore so we should make On the other hand for each we need to move from the second set to the first one now so we should make The answer will be equal to the It means that we should handle two operations add some value on the segment and ask minimum on the segment So we can store all in pretty standart Segment Tree with add on segment and minimum on segment while iterating over So the total complexity is 
855,Mishka wants to buy some food in the nearby shop Initially he has burles on his card Mishka can perform the following operation any number of times possibly zero choose some buy food that costs exactly burles and obtain burles as a cashback in other words Mishka spends burles and obtains back The operation means divided by rounded down It is guaranteed that you can always buy some food that costs for any possible value of Your task is to say the maximum number of burles Mishka can spend if he buys food optimally For example if Mishka has burles then the maximum number of burles he can spend is Firstly he can spend burles obtain burle as a cashback Now he has burles so can spend burles obtain burle as a cashback and spend it too You have to answer independent test cases ,Let s do the following greedy solution it is obvious that when we buy food that costs exactly for we don t lose any burles because of rounding Let s take the maximum power of that is not greater than let it be buy food that costs and add this number to the answer and add to Apply this process until and then add to the answer Time complexity per test case ,Note that 2 coins with denomination k can be replaced with k coins with denomination 2 So if the answer exists then there is also such a set of coins where there is no more than one coin with denomination k Therefore it is enough to iterate through the number of coins with denomination k from 0 to 1 and check that the remaining number is non negative and even i e it can be represented as some number of coins with denomination 2 
856,Vasya has a tree consisting of vertices with root in vertex At first all vertices has written on it Let be the distance between vertices and i e number of edges in the shortest path from to Also let s denote subtree of vertex set of vertices such that next two conditions are met is the ancestor of each vertex is the ancestor of itself Vasya needs you to process queries The th query is a triple and For each query Vasya adds value to each vertex from subtree of Report to Vasya all values written on vertices of the tree after processing all queries ,To solve this problem we can use a data structure which allows to add some value on segment and get a value from some point Fenwick tree segment tree or anything you are familliar with Let s run DFS from the root while maintaining current depth When entering a vertex on depth let s consider all queries having and for each such query add on segment Then for current vertex the answer is the value in point When leaving vertex we need to rollback everything we have done for all queries having subtract on segment ,To begin with we will hang the tree by the vertex In fact we want to go from the root to the top of going off this path to do things and coming back At one vertex of the path it is advantageous to get off it in all the necessary directions and follow it further So we will go once for each edge leading to and times for each edge leading to some of the cases but not leading to Let s match each vertex with an edge to its ancestor If the edge of a vertex leads to then is in the subtree of this vertex similarly with vertices with cases It is necessary for each vertex to determine whether there is a vertex in its subtree and whether there is a vertex from the array this can be done using a depth first search then we will calculate the answer according to the rules described above 
857,Polycarp and his friends want to visit a new restaurant The restaurant has tables arranged along a straight line People are already sitting at some tables The tables are numbered from to in the order from left to right The state of the restaurant is described by a string of length which contains characters the table is occupied and the table is empty Restaurant rules prohibit people to sit at a distance of or less from each other That is if a person sits at the table number then all tables with numbers from to except for the th should be free In other words the absolute difference of the numbers of any two occupied tables must be strictly greater than For example if and then strings satisfy the rules of the restaurant strings do not satisfy to the rules of the restaurant since each of them has a pair of with a distance less than or equal to In particular if the state of the restaurant is described by a string without or a string with one then the requirement of the restaurant is satisfied You are given a binary string that describes the current state of the restaurant It is guaranteed that the rules of the restaurant are satisfied for the string Find the maximum number of free tables that you can occupy so as not to violate the rules of the restaurant Formally what is the maximum number of that can be replaced by such that the requirement will still be satisfied For example if then the answer to the problem will be since only the table at position can be occupied such that the rules are still satisfied ,Let s split a given string into blocks of consecutive zeros Then in each such block you can independently put the maximum number of people who fit in it But there are three cases to consider If the current block is not the first and not the last then there are ones at the border and this means that the first tables of the current block and the last are prohibited Therefore remove these zeroes from the string If the current block is the first then the one is at the end and you need to delete the last zeros If the current block is the last then in the beginning there is one and you need to delete the first zeros Also as a separate case you need to consider a string consisting only of zeros Then there is exactly one block from which you do not need to remove zeros Now all the tables in each block are free then in each block we can put Sum these values over all blocks ,Suppose we have fixed the value of so we can trade an item with price for an item with price if We can see that it s never optimal to trade an item with higher price for an item with lower price and we could just simulate the trading process as follows try to find an item owned by Polycarp and a more expensive item owned by the other character which can be traded repeat until we cannot find any suitable pair Unfortunately it is too slow Instead let s try to analyze for a given value of how to verify that an item of price can be traded for an item of price maybe not right away but with intermediate trades You can build a graph of vertices representing items where two vertices representing items with prices and are connected by an edge if and only if Then the edges of the graph represent possible trades and the paths in the graph represent sequences of trades So one item can be traded for another item possibly with intermediate trades if the vertices representing the items belong to the same component For a fixed value of we can build this graph find all of its components calculate the number of Monocarp s items in each component and add this number of most expensive vertices from the component to the answer There are two problems though The first one is that the graph may have up to edges But if we sort all items according to their prices we are only interested in edges between vertices which represent adjacent items in sorted order so the size of the graph is decreased to Another problem is that there are multiple queries for different values of To handle it we can sort the values of in ascending order and go in sorted order while maintaining the graph for the current value of A data structure like DSU or a method like small to large merging can be helpful to update the components as they merge The last trick to quickly recalculate the number of items Monocarp has in a component and the sum of most expensive several items you can build two prefix sum arrays one over the array storing the costs of the items and another one over the array which stores values or depending on who owns the respective item the items should still be considered in sorted order Since each component is a segment of costs of items prefix sums allow us to calculate the required values in By the way knowing that each component is a segment we can get rid of the graph and the structure that stores it altogether and just maintain a set of segments of items representing the components 
858,Vasya is reading a e book The file of the book consists of pages numbered from to The screen is currently displaying the contents of page and Vasya wants to read the page There are two buttons on the book which allow Vasya to scroll pages forwards or backwards but he cannot scroll outside the book For example if the book consists of pages and then from the first page Vasya can scroll to the first or to the fourth page by pressing one of the buttons from the second page to the first or to the fifth from the sixth page to the third or to the ninth from the eighth to the fifth or to the tenth Help Vasya to calculate the minimum number of times he needs to press a button to move to page ,It is easy to understand that the optimal answer is achieved in one of three cases Vasya is trying to visit page without visiting pages and Vasya first goes to the page and then to the page Vasya first goes to the page and then to the page In the first case Vasya can go directly to the page from the page if is divided by In the second case Vasya can get to page through page if is divided by The required number of actions will be equal to Similarly in the third case Vasya can go to the page through the page if is divided by The required number of actions will be equal to If none of the three options described above is appropriate then there is no answer ,The solution consist of two main parts calculate the initial number of staircases and recalculate the number of staircases on query The constraints were pretty loose so we ll do the first part in and the second part in per query However it s worth mentioning that faster is possible The first part can surely be done in and can probably be done in The second part can be done in per query It s important to notice is that the only staircase that satisfy the requirements for both types is the staircase that consists of a single cell Thus staircases of both types can be calculated almost separately Let s define base staircases as the staircases that can t be prolonged further in any direction There are of them on the grid If a staircase consists of at least two cells it s a part of exactly one staircase At the same time every segment of a staircase is a valid staircase by itself Thus the main idea of calculating the initial answer is the following Isolate each staircase and determine its length possibly in Add the number of segments of length at least to the answer Add extra one cell staircases afterwards If you draw the staircases on the grid you can easily determine their starting cell The staircases that start by going one cell to the right start from the first row The staircases that start by going one cell to the bottom start from the first column Notice that both types can start from cell The updates can be handled the following way The answer always changes by the number of staircases that pass through cell if you ignore its state If the cell becomes free then these staircases are added to the answer Otherwise they are subtracted from it That can be calculated for two cases as well Go first down then right as far as possible Let it be steps Go first left then up as far as possible Let it be steps Then staircases are added to the answer Then change the order of steps in both directions to calculate the other type of staircases Beware of one cell staircases again To achieve for precalc you can calculate the length of each staircase with a formula To achieve per query you can first enumerate cells in each staircase separately then maintain the set of segments of adjacent free cells in it 
859,Marian is at a casino The game at the casino works like this Before each round the player selects a number between and After that a dice with faces is rolled so that a random number between and appears If the player guesses the number correctly their total money is doubled else their total money is halved Marian predicted the future and knows all the numbers that the dice will show in the next rounds He will pick three integers and He will play rounds rounds between and inclusive In each of these rounds he will guess the same number At the start before the round he has dollar Marian asks you to determine the integers and such that he makes the most money at the end Note that during halving and multiplying there is no rounding and there are no precision errors So for example during a game Marian could have money equal to etc any value of where is an integer of any sign ,There are several solutions Here is one If we fix the value of then let s make a new array as follows if and otherwise Then the total amount of money earned will just be so we only need to maximize In other words we need to find the maximum sum of a subarray This is a standard problem that can be solved using segment tree Note that we need to iterate over all values of of which there are possibilities So we have to update elements of the segment tree times and query once for each which means overall the solution runs in ,Notice that we can keep solved tasks and then submit all at once So the solution goes down to this you should find the first moment of time that the site works at that moment and Also it s convinient that the intervals are already sorted in increasing order Let s sum up all elements of array and write it to some variable The answer is obtained this way if the sum lies in the current interval then the answer is the sum Otherwise there are two cases If there exists some interval that then the answer is In other case the answer is 1 
860,In the pet store on sale there are packs of dog food packs of cat food packs of universal food such food is suitable for both dogs and cats Polycarp has dogs and cats Is it possible that he will be able to buy food for all his animals in the store Each of his dogs and each of his cats should receive one pack of suitable food for it ,Obviously the best way to buy food for every pet is to buy maximum possible food for dogs and cats then dogs and cats will not get food We will buy universal food for these dogs and cats Then the answer is if and else ,We can solve the problem with a two pointers technique Let be the left pointer initially at and be the right pointer initially at Let s store Alice and Bob s current totals as and Let s iterate from the left to the right For each we should do the following Increase by Alice eats the th candy Move leftwards until Bob s total is at least Alice s total and update every time we move If the two pointers have crossed then both Alice and Bob took the same candy which is not possible So we should exit and output the current answer Otherwise if after this step we should update the current answer to be the value that is equal to Alice and Bob Both and move at most times in total so the solution runs in 
861,You have to handle a very complex water distribution system The system consists of junctions and pipes th pipe connects junctions and The only thing you can do is adjusting the pipes You have to choose integer numbers and use them as pipe settings th pipe will distribute units of water per second from junction to junction if is negative then the pipe will distribute units of water per second from junction to junction It is allowed to set to any integer from to In order for the system to work properly there are some constraints for every th junction has a number associated with it meaning that the difference between incoming and outcoming flow for th junction must be if is not negative then th junction must receive units of water per second if it is negative then th junction must transfer units of water per second to other junctions Can you choose the integers in such a way that all requirements on incoming and outcoming flows are satisfied ,The answer is if and only if the sum of values is not equal to Writing some number on edge does not change the total sum and the goal of the problem is to make in each vertex thus getting in total The algorithm is simple you get an arbitrary spanning tree with dfs or dsu output the difference between sums of values of subtrees can be calculated with dfs for edges in this tree and for the rest of edges Let s take an arbitrary correct answer If is has some cycle in graph of edges with non zero numbers on them then you can remove it For example select any edge on it and subtract the number on it from all the edges of the cycle This doesn t break the correctness of the answer as you change both in and out flows for each vertex by the same value Now that edge has This way any answer can be transformed to tree And for any edge on tree we want to tranfer excess water units from the larger subtree to the smaller Overall complexity ,If we distribute costs optimally then this pair of paths a rightarrow b and b rightarrow c can look like just a straight path that doesn t visit the same vertex twice or like three straight paths with one intersection point x The first case is basically a subcase of the second one with the intersection point a b or c So if we fix the intersection point x then these two paths a rightarrow b and b rightarrow c become four paths a rightarrow x x rightarrow b b rightarrow x and x rightarrow c We can notice that each path we denoted should be the shortest possible because if it isn t the shortest one then we used some prices that we couldn t use Let the length of the shortest path from u to v be dist u v Then it is obvious that for the fixed intersection point x we don t need to use more than dist a x dist b x dist c x smallest costs Now we want to distribute these costs between these three paths somehow We can see that the path from b to x is used twice so it is more optimally to distribute the smallest costs along this part So let pref i be the sum of the first i smallest costs just prefix sums on the sorted array p Then for the intersection point x the answer is pref dist b x pref dist a x dist b x dist c x if dist a x dist b x dist c x le m We can calculate distances from a b and c to each vertex with three runs of bfs Time complexity O m log m 
862,A of length is an array containing each integer from to exactly once For example is a permutation For the permutation the square of permutation is the permutation that for each For example the square of is This problem is about the inverse operation given the permutation you task is to find such permutation that If there are several such find any of them ,Consider some permutation q Let s build by it the oriented graph with edges i qi Easy to see and easy to prove that this graph is the set of disjoint cycles Now let s see what would be with that graph when the permutation will be multiplied by itself all the cycles of odd length would remain so only the order of vertices will change they will be alternated but the cycles of even length will be split to the two cycles of the same length So to get the square root from the permutation we should simply alternate in reverse order all cycles of the odd length and group all the cycles of the same even length to pairs and merge cycles in each pair If it s impossible to group all even cycles to pairs then the answer doesn t exist Complexity O n ,Let s look at the permutation as at a graph with vertices and edges It s not hard to prove that the graph consists of several cycles self loops are also considered as cycles So the sequence is just a walking on the corresponding cycle Let s consider one cycle In permutation we have But since or so and in general case Now walking with step we can note that the initial cycle split up on cycles of length Looking at the definition of infinite path we can understand that all we need to do is to check that at least one of cycles have all vertices of the same color We can check it in time for the cycle and fixed The final observation is next for and such that the produced cycles will have the same sets of vertices and differ only in the order of walking so we can check only one representative for each i e we can take only such which divide We can handle each cycle of separately So using the approximation that the number of divisors of is we get time complexity 
863,You have a number of length and one additional digit You can insert this digit anywhere in the number including at the beginning or at the end Your task is to make the result as large as possible For example you have the number and the additional digit is Then the maximum number you can get is and it can be obtained in two ways by inserting a digit after the th or after the th digit of the number ,Note that numbers of the same length are compared lexicographically That is until some index the numbers will match and then the digit in our number should be greater Let s write out the numbers until As soon as this condition is false or the line ends insert the digit We got the lexicographically maximum number which means just the maximum number ,There are many possible approaches in this problem I will describe one of the easiest Let s print the initial string by the following algorithm firstly init the variable Then while the encrypted string isn t empty print the first character of this string remove first characters from it and increase by one 
864,Alice and Bob have decided to play the game Rock Paper Scissors The game consists of several rounds each round is independent of each other In each round both players show one of the following things at the same time rock paper or scissors If both players showed the same things then the round outcome is a draw Otherwise the following rules applied if one player showed rock and the other one showed scissors then the player who showed rock is considered the winner and the other one is considered the loser if one player showed scissors and the other one showed paper then the player who showed scissors is considered the winner and the other one is considered the loser if one player showed paper and the other one showed rock then the player who showed paper is considered the winner and the other one is considered the loser Alice and Bob decided to play exactly rounds of the game described above Alice decided to show rock times show scissors times and show paper times Bob decided to show rock times show scissors times and show paper times Though both Alice and Bob the sequence in which they show things It is guaranteed that and Your task is to find two numbers the minimum number of round Alice can win the maximum number of rounds Alice can win ,The maximum number of rounds Alice can win is pretty easy to calculate greedily What about the minimum number of rounds It can be shown that if we started using some combination we are better to end it before using the other one There are six possible combinations to not win the round and and and and and and We can iterate over all permutations of these combinations there are possible permutations and greedily apply them Use the first while it is possible then the second and so on and find the best answer It is also possible that the order of these combinations does not matter but we didn t prove that fact Time complexity ,This problem seems like a version of Nim with some forbidden moves so let s try to apply Sprague Grundy theory to it First of all we may treat each castle as a separate game compute its Grundy value and then XOR them to determine who is the winner of the game When analyzing the state of a castle we have to know two things the number of remaining soldiers in it and the type of the last attack performed on it So the state of the game can be treated as a pair We can compute Grundy values for each state in a straightforward way but the constraints are too large to do it Instead we should try to search for a period five consecutive rows by row we mean a vector of Grundy values for the same number of remaining soldiers but different types of last attacks of Grundy values determine all of the values after them so as soon as we get the same five rows of Grundy values that we already met we can determine the period There are values stored in these five rows so the period can be up to but that s a really generous upper bound Some intuition can help us to prove something like or as an upper bound but it is better to check all cases with brute force and find out that the period is at most After we ve found the period of Grundy values it s easy to get them in for any castle To count the number of winning moves for the first player we can compute the XOR sum of all castles and for each castle check what happens if we make some type of attack on it if the XOR sum becomes then this move is winning 
865,Casimir has a string which consists of capital Latin letters and only Each turn he can choose to do one of the two following actions he can either erase exactly one letter exactly one letter from arbitrary places of the string these letters don t have to be adjacent or he can erase exactly one letter exactly one letter from arbitrary places in the string these letters don t have to be adjacent Therefore each turn the length of the string is decreased exactly by All turns are independent so for each turn Casimir can choose any of two possible actions For example with he can obtain a string in one turn by erasing the first occurrence of and the second occurrence of There are also many other options for a turn aside from this particular example For a given string determine whether there is a sequence of actions leading to an empty string In other words Casimir s goal is to erase all letters from the string Is there a way to do this ,Note that no matter which action is chosen after this action is performed one letter is erased from the string two letters in total are erased from the string Let s denote the length of the string by If is odd then described turns can not erase all the characters from the strings because if he is deleting two letters on each turn the length will always remain odd For example if the original length of the string is then after one turn it will be equal to and after two moves it will be equal to in which case the next turn is impossible Thus if the length of the row is odd the answer is If is even it will take exactly steps to erase all characters from the string Since each action removes exactly one letter from the string the string can become empty only if there are exactly letters Let us show that this condition is sufficient that is if a string has exactly half of the letters equal to then there always exists a sequence of actions leading to an empty string Indeed if a string of length has exactly letters exactly letters and exactly letters then Then Casimir can make moves of the first type each time removing the first occurrence of and the first occurrence of and moves of the second type each time removing the first occurrence of and the first occurrence of After such moves the string will become empty Thus checking that the number of letters in the string is exactly half of its length was enough to solve the problem ,Unfortunately it seems we failed to eliminate bitset solutions The approach in our model solution is the following Firstly let s try to find some naive solution for calculating the distance between two strings We may build an undirected graph where vertices represent letters and edges represent that one letter must be transformed into another Then all letters in the same component should become one letter so the answer is the number of distinct letters minus the number of components Then let s get back to original problem For every substring of we have to find which letters have to be merged to make it equal with This can be done with the help of FFT to find all positions in substrings of with character that coincide with occurences of in we may compute a convolution of two following arrays set to every position in where occurs and to every position in where occurs all other elements should be After trying these convolutions for every pair of different characters we compute the answer for every substring using DFS or any other method 
866,Polycarp came up with a new programming language There are only two types of statements in it assign the variable named the value where is a string For example the statement assigns the variable named the value Note that is the value of a string not the name of a variable Between the variable name the operator and the string contains exactly one space each assign the variable named the concatenation of values of two variables and For example if the program consists of three statements then the variable will contain the string It is guaranteed that the program is correct and the variables and were previously defined There is exactly one space between the variable names and the and operators All variable names and strings only consist of lowercase letters of the English alphabet and do not exceed characters The result of the program is the number of occurrences of string in the string that was written to the variable in the last statement Polycarp was very tired while inventing that language He asks you to implement it Your task is for given program statements calculate the number of occurrences of string in the last assigned variable ,We can t model this process directly since the maximum string length reaches look at the second example from the statements To optimize this process you can store each row as a set of the following values Number of occurrences of in the string String length The first three characters of the string are The last three characters of the string are Then to process the second type of request and combine the two strings and into the string you need New occurrences may be added at the junction of two words However if the string length is less than then you need to handle this case carefully with your hands Similarly you need to process small strings separately ,Let s iterate over all characters of the string from left to right excluding last character Suppose is a position of the current element of the string If increase answer by and increase by else just increase by 
867,You are given an array consisting of integers You have to find the length of the smallest shortest of elements you need to erase from to make it a array Recall that the prefix of the array is a subarray consisting several first elements the prefix of the array of length is the array The array of length is called if you can obtain a array from it repeating the following operation times initially is empty select either the first or the last element of remove it from and append it to the end of the array For example if we do operations take then then and at last then becomes and Consider the following example This array is because we can obtain array from it by the following sequence of operations take the first element of so take the last element of so take the last element of so take the first element of so take the first element of so take the last element of so take the only element of so is non decreasing Note that the array consisting of one element is Print the length of the shortest prefix of to delete erase to make to be a array Note that the required length can be You have to answer independent test cases ,Consider the maximum element a mx of the good array a of length k Then we can notice that the array a looks like a 1 le a 2 le dots le a mx ge dots ge a k 1 ge a k And this is pretty obvious that if the array doesn t have this structure then it isn t good you can see it yourself So we need to find the longest such suffix It s pretty easy doable with pointer initially the pointer pos is at the last element Then while pos 1 and a pos 1 ge a pos decrease pos by one If we re done with the previous step we do the same but while pos 1 and a pos 1 le a pos The answer is pos 1 ,Fairly enough solutions of both versions of the problem are pretty similar Read the second part of the previous tutorial first This problem can also be implemented in the strightforward manner The greedy solution now is searching for the first minimum in array and putting a brick in there If it s impossible then the answer is This can also be simulated with sets a bit more tedious but still ok and also Now back to the stack approach Here you can t go to parities of the numbers like tests and lead to different results You push the number itself However you will also need an extra condition on the stack You can t push to it the number greater than the current topmost element The only problem with this are maximums of array Obviously the resulting wall if the answer exists will be of height equal to the maximum initial height And it means that you shouldn t care about the ability to match all maximums in stack They way I suggest to take around the issue is to process separately each segment between two consecutive maximums One can easily prove the correctness of it by construction Overall complexity 
868,Ivan has songs on his phone The size of the th song is bytes Ivan also has a flash drive which can hold at most bytes in total Initially his flash drive is empty Ivan wants to copy all songs to the flash drive He can compress the songs If he compresses the th song the size of the th song reduces from to bytes Ivan can compress any subset of the songs possibly empty and copy all the songs to his flash drive if the sum of their sizes is at most He can compress subset of the songs not necessarily contiguous Ivan wants to find the minimum number of songs he needs to compress in such a way that all his songs fit on the drive i e the sum of their sizes is less than or equal to If it is impossible to copy all the songs even if Ivan compresses all the songs print Otherwise print the minimum number of songs Ivan needs to compress ,If we will no compress songs the sum of the sizes will be equal Let it be Now if we will compress the th song how do will change It will decrease by This suggests that the optimal way to compress the songs is the compress it in non increasing order of Let s create the array of size where Let s sort it in non increasing order and then iterate over all from to If at the current step we print and terminate the program Otherwise we set After all we have to check again if then print otherwise print Time complexity is because of sorting ,Let s notice that if we process the queries of type naively then each such query consumes time where is the size of the array So queries with large can be processed naively For queries with small we may notice two things there are only possible queries each number in the array affects only possible queries So for small we may maintain the exact answer for each query and modify it each time we modify an element in the array If we process naively all queries with and maintain the answers for all queries with we will obtain a solution having time complexity Note that as in most problems related to sqrt heuristics it may be optimal to choose the constant that is not exactly but something similar to it but most solutions should pass without tuning the constant 
869,You are a usual chat user on the most famous streaming platform Of course there are some moments when you just want to chill and spam something More precisely you want to spam the emote triangle of size It consists of messages The first message consists of one emote the second one of two emotes the th one of emotes the th one of emotes and the last one of one emote For example the emote triangle for consists of messages Of course most of the channels have auto moderation Auto moderator of the current chat will ban you right after you spam at least emotes in succession you can assume you are the only user in the chat Now you are interested how many messages will you write before getting banned Or maybe you will not get banned at all i e will write all messages and complete your emote triangle successfully Note that if you get banned as a result of writing a message this message is also counted You have to answer independent test cases ,This is a pretty obvious binary search problem If we get banned after messages we also get banned after and so on messages and vice versa if we don t get banned after messages we also don t get banned after and so on messages For simplicity let s split the problem into two parts when we check if we re getting banned after messages let s handle cases and separately Recall that the sum of the arithmetic progression consisting of integers is Let it be The first case is pretty simple the number of emotes we send with messages when is which is So we only need to check if The second case is a bit harder but still can be done using arithmetic progression formulas Firstly we send all messages for the number of such messages is Then we need to add messages This number equals to i e we send all messages from to and subtract messages from to from this amount The final condition is Time complexity per test case ,If we sort the students in order of non decreasing their skill we can see that the minimum cost of the team with the lowest skill let s call it the first team is equal to if is already sorted the cost of the second team is and so on So if we sort in non decreasing order then the answer is 
870,There is an infinite 2 dimensional grid The robot stands in cell and wants to reach cell Here is a list of possible commands the robot can execute move north from cell to move east from cell to move south from cell to move west from cell to stay in cell The robot wants to reach cell in as few commands as possible However he can t execute the same command two or more times in a row What is the minimum number of commands required to reach from ,Obviously you can always obtain the optimal answer without using west or south moves So the shortest path consists of east moves and north moves Let s estimate the lower bound of the answer Take a look at these constructions and let question mark be any command different from the used one That s the tightest you can put east or north moves in So the answer is at least For you can put them just as in the construction and fill the rest of question marks with a stay in place move case works differently though You can do it only in moves by taking alternating moves Overall complexity per testcase ,There are two key observations to this problem after each pair of moves the directions go back to the original ones after each move we can immediately go back and combining these observations we can derive that if we go from city to some other city we can always go back One of the solutions we can write using these observations is to build an undirected graph on vertices Each vertex represents a pair where is the city we are currently staying in and is the number of moves we made modulo Since each move is to a neighboring city each vertex is unreachable from and vice versa And since we can always go back and each pair of steps doesn t change the directions this graph is actually an undirected one So we can find the connected components of this graph using DFS BFS DSU and for each city print the size of the component the vertex belongs to Another solution is to find the leftmost and the rightmost city reachable from each city For example finding the leftmost reachable city can be done with the following dynamic programming let be the leftmost city reachable from Then if we can t go left from if we can make only one step to the left from and if we can make two steps we can take the answer from the city The same approach can be used to calculate the rightmost reachable city 
871,Given strings each of length consisting of lowercase Latin alphabet letters output the number of pairs of indices such that and the th string and the th string differ in exactly one position In other words count the number of pairs such that the th string and the th string have one position such that The answer may not fit into 32 bit integer type so you should use 64 bit integers like in C to avoid integer overflow ,One solution is to go through all given strings generate all strings that differ in exactly one position and count the number of times these strings occur in the array A possible way to count them is by using either the map dictionary data structure or even simpler a frequency array Depending on the implementation you may need to divide the answer by because of overcounting pairs The solution runs in or depending on the implementation ,We just need to make sure our string of characters matches each of the substrings in at least one spot The easiest way to do this is to take every other character from Code 90908018 Another fun solution we can generate random strings and check them until we find one that matches everything This works because the probability of failing to match any particular substring is so as gets bigger the probability of failing gets extremely low Code 90999219 
872,You are given segments on a number line each endpoint of every segment has integer coordinates Some segments can degenerate to points Segments can intersect with each other be nested in each other or even coincide The intersection of a sequence of segments is such a maximal set of points not necesserily having integer coordinates that each point lies within every segment from the sequence If the resulting set isn t empty then it always forms some continuous segment The length of the intersection is the length of the resulting segment or in case the intersection is an empty set For example the intersection of segments and is length the intersection of segments and is length and the intersection of segments and is an empty set length Your task is to remove exactly one segment from the given sequence in such a way that the intersection of the remaining segments has the maximal possible length ,Intersection of some segments is If this segment has its left bound greater than its right bound then the intersection is empty Removing some segment makes the original sequence equal to That can be split up to a prefix of length and a suffix of length Intersections for them can be precalced separately and stored in some partial sum like arrays Finally you have to iterate over the position of the removed segment and calculate the intersection of prefix and suffix without this segment Overall complexity ,First let s understand that if we choose some subset of points then it does not matter to which point we move it inside the segment because the minimum number of moves will always be the same and it is equal to Okay we need to split all points into two subsets and collect all points of the first subset in some point inside it and the same with the second subset What can we notice If we sort the points it s always optimal to choose these subsets as segments I e if the maximum point of the first subset is the minimum point of the second subset is and we can swap them and decrease answers for both subsets So we need to cover all the points with two segments with the minimum total length What is this length It is is the maximum distance between two consecutive points i e So we can solve the problem in without queries But how to deal with queries Let s maintain the set which contains all points and the multiset set with repetitions that maintains all gaps between two adjacent points So the answer is maximum in the set of points minus minimum in the set of points minus maximum in the multiset of lengths How do we recalculate these sets between queries If some point is removed let s find the maximum point less than let it be and the minimum point greater than let it be in the current set of points Both these points can be found in a logarithmic time Then we need to remove with from the multiset and add to the multiset and of course remove from the set If some point is added then we need to remove from the multiset and add with to the multiset and add to the set So we can process every query in time and the total time complexity is 
873,You have a password which you often type a string of length Every character of this string is one of the first lowercase Latin letters Since you spend a lot of time typing it you want to buy a new keyboard A keyboard is a permutation of the first Latin letters For example if then there are six possible keyboards and Since you type your password with one finger you need to spend time moving your finger from one password character to the next The time to move from character to character is equal to the distance between these characters on keyboard The total time you have to spend typing the password with a keyboard is called the of this keyboard More formaly the slowness of keyboard is equal to where is position of letter in keyboard For example if is and the keyboard is then the total time of typing this password is Before buying a new keyboard you want to know the minimum possible slowness that the keyboard can have ,Let s solve this problem by subset dynamic programming Let s denote as the number of adjacent characters and in such that or Let s be some intermediate result further it will be explained what kind of intermediate result if we already added letters corresponding to subset to the keyboard and we don t care about the order of these letters Now let s consider how to recalculate values of this dynamic programming using some Let s iterate over a new letter on keyboard and we know the position of this letter on the keyboard it s equal to the number of elements in After adding this new letter we want to calculate what it added to the Let consider some letter and calculate how much time will be spent on moving and There are two cases If letter is already on current keyboard then we should add to answer and otherwise where is the position of character on the keyboard But we don t know the position of the letter Let s fix it as follows We will add the contribution of some letter when it will be added to the keyboard So when we added letter we should add the value So the total complexity is ,Greedy idea To minimize the string we will go from left to right and maintain a variable maximal character from which we will reduce everything to a Initially it is a and we spend of operations on it Then at the next symbol we can either reduce it to a in no more than operations or reduce to a the prefix we have already passed and minimize the next character in the remaining operations 
874,You are given an integer Find the minimum integer such that and the number is A number is called if its decimal representation having no leading zeroes contains no more than different digits E g if the numbers and are whereas the numbers and are not ,Suppose the number contains digits and its decimal representation is The desired number isn t greater than the number consisting of digits This number is beautiful whereas any beautiful number is at the same time beautiful so contains at most digits At the same time so contains at least digits Therefore the desired number contains exactly digits Since we search for the minimum we need to minimize first of all the first digit only then the second digit etc Therefore we need to find a prefix of the decimal representation of such that is a prefix of the decimal representation of Let s do it greedily Let s find the maximum prefix of such that contains no more than distinct numbers Suppose the prefix has the length If then is already beautiful let s output it Otherwise let s increase the prefix like a number by e g if and then we increase by the resulting prefix is All other digits let s set to zeroes e g if and then will be turned into The answer for the old is the answer for the new To get the answer for the new let s start the described procedure once again preparing the new Let s find the maximum prefix of such that contains no more than distinct numbers It s possible to do using a in which for each digit the key the number of its occurrences in the prefix is stored For an empty prefix the is empty If we increase the prefix length by we need to check that contains no more than keys and add a new key with the value or increase the value of an existing key If the length of the found prefix is equal to the length of the whole decimal representation the given number is already beautiful so the answer is Otherwise the found prefix may not be a prefix of the desired number Let s change the digits of the decimal representation of to turn it into the desired number Let s start the following procedure suppose we consider a prefix with the length equal to First let s find out is it possible to increase the first element out of the prefix i e We need to do it because if we consider the length then the prefix with the length cannot be unchanged so the element must be changed whereas it cannot be decreased because in this case we will get the number which is less than If we can increase the element so that the prefix with the length has at most distinct digits the only thing that is remained to do is to fill the remaining digits somehow greedily and output the result If we cannot increase the element let s decrease the length of the considered prefix by updating the let s decrease the value corresponding to the key by then if it s equal to we remove the key from the Consider how and under what conditions we can change and the following digits If it s impossible Suppose the considered prefix contains less than distinct digits the number of the keys in the is less than In this case we can replace the digit with the value so the prefix with the length will not contain more than distinct elements because the prefix with the length doesn t contain more than distinct elements If the prefix with the length still contains less than distinct numbers let s replace the remaining digits etc with Otherwise we can replace them with the minimum digit that occurs in the prefix with the length it may be Suppose the considered prefix contains exactly distinct digits So let s find the minimum digit that occurs in the prefix with the length and is greater than If such digit exists let s replace with it and all following digits with the minimum digit that occurs in the prefix with the length Otherwise the element cannot be increased The converted by the procedure is the answer ,If the number is already even then nothing needs to be done so the answer in this case is Now let s recall the divisibility by a number is divisible by if and only if its last digit is divisible by It follows that if there are no even digits in our number then the answer is Let s take a look at our operation What is going on The first digit always changes with the digit numbered In particular when we reverse the entire number the first digit is swapped with the last Note that no other digit except for the first one at the current moment can t be the last Therefore you can do this if the first digit of a number is divisible by then we reverse the whole number The first digit will become the last and the number will become even Therefore you only need to do one operation Now what if the first digit of a number is odd In this case we can find the first even digit in the number let it be at position and reverse the prefix of length in one operation Now the first digit of our number has become even and we can use the previous case one more operation Thus we will do only operations 
875,You are given an undirected unweighted graph consisting of vertices and edges You have to write a number on each vertex of the graph Each number should be or The graph becomes beautiful if for each edge the sum of numbers on vertices connected by this edge is odd Calculate the number of possible ways to write numbers and on vertices so the graph becomes beautiful Since this number may be large print it modulo The graph does not have any self loops or multiple edges ,Let s denote a way to distribute numbers as a Let s also call the paintings that meet the constraints paintings and all other paintings are bad We can solve the problem for each connected component of the graph independently and multiply the answers Let s analyze a painting of some connected component If some vertex has an odd number written on it then we should write even numbers on all adjacent vertices and vice versa So in fact we need to check if the component is bipartite and if it is divide it into two parts The number of good paintings is where is the size of the first part and is the size of the second part because we write s into all vertices of one part and s or s into all vertices of another part ,We prove that the answer always always exists by constructing it Graph for is a single vertex Graph for is a clique of vertices Graph for some is obtained from the graph by adding vertices initially connected to nothing and vertices connected to all previously mentioned ones The vertices connected to nothing got degrees the vertices from the previous step increased their degrees by and finally there appeared vertices of degree The number is vertices is as needed 
876,Monocarp is a tutor of a group of students He communicates with them using a conference in a popular messenger Today was a busy day for Monocarp he was asked to forward a lot of posts and announcements to his group that s why he had to write a very large number of messages in the conference Monocarp knows the students in the group he is tutoring quite well so he understands which message should each student read Monocarp wants the student to read the message Of course no one s going to read all the messages in the conference That s why Monocarp decided to pin some of them Monocarp can pin any number of messages and if he wants anyone to read some message he should pin it otherwise Unfortunately even if a message is pinned some students may skip it anyway For each student Monocarp knows that they will read at most messages Suppose Monocarp pins messages if then the th student will read all the pinned messages but if the th student will choose exactly random pinned messages all possible subsets of pinned messages of size are equiprobable and read only the chosen messages Monocarp wants to maximize the expected number of students that read their respective messages i e the number of such indices that student reads the message Help him to choose how many and which messages should he pin ,First of all let s rewrite the answer using expectation linearity The expected number of students who read their respective messages is equal to where is a random value which is if the th student reads the message and if the th student doesn t do it Let s analyze the expected value of Suppose Monocarp pins the messages There are three cases if then the th student won t read the message so if and then the th student will definitely read the message so if and then If we iterate on the number of messages we pin we can calculate the sum of for each message considering that we pin it sort all of the messages and pick best of them So we have a solution working in The only thing we need to improve this solution sufficiently is the fact that we don t have to consider the case Since every is not greater than the sum of for a message in the case is the same as this sum of in the case but multiplied by the coefficient and we pick best values their sum multiplied by is not greater than the sum of best values The same holds for and greater ,Since it is better to do exactly chores in time And since we need to minimize total time we need to spend it s better to speed up the longest chores So the answer is 
877,Ivan has different boxes The first of them contains some balls of different colors Ivan wants to play a strange game He wants to distribute the balls into boxes in such a way that for every th box will contain all balls with color In order to do this Ivan will make some turns Each turn he does the following Ivan chooses any non empty box and takes all balls from this box Then Ivan chooses any empty boxes the box from the first step becomes empty and Ivan is allowed to choose it separates the balls he took on the previous step into non empty groups and puts each group into one of the boxes He should put each group into a separate box He can choose either or The of the turn is the number of balls Ivan takes from the box during the first step of the turn And of the game is the total of turns made by Ivan until he distributes all balls to corresponding boxes Help Ivan to determine the minimum possible of the game ,Let s consider the process backwards we will store the number of balls of each color in a multiset and then merge some of them If is odd then we can always pick three groups of balls with minimal sizes and replace them by one group adding the size of this group to the penalty Repeat until you have only one group If is even then we need to add an auxiliary group of size Then becomes odd so we can use the above algorithm to solve this case Why does it work This algorithm is exactly the same as the algorithm of building a Huffman code with the alphabet of size And it can easily be seen that these problems are similar by separating a group of balls into three groups we add a new character to the codes of the colours present in that group and our goal is to obtain a prefix code ,Note that there are only a few configuration classes and Let s discuss each of them If all bulbs are of the same color then it is impossible to turn all the bulbs on because after you switch one light bulb it is impossible to turn the others on If there is a color with bulbs then it is impossible to turn all the bulbs on in operations which means there is a bulb that turns on turns off and then turns on again i e the answer is at least operations And there is a sequence of exactly operations such an example was shown in the problem notes For configurations like and it is enough to turn on the color bulbs not in a row i e in order for the first case and for the second one So the answer for such configurations is If all the bulbs are of different colors then nothing prevents you from turning them all on in operations 
878,You are playing a very popular game called Cubecraft Initially you have one stick and want to craft torches One torch can be crafted using Hopefully you ve met a very handsome wandering trader who has two trade offers exchange stick for sticks you lose stick and gain sticks exchange sticks for coal you lose sticks and gain coal During one trade you can use of these two trade offers You can use each trade offer any number of times you want to in any order Your task is to find the minimum number of trades you need to craft at least torches The answer always exists under the given constraints You have to answer independent test cases ,You need additional sticks to get torches sticks for units of coal and also sticks required to craft torches and you get sticks per one trade To buy this number of sticks you need trades And also you need additional trades to turn some sticks into coals And the final answer is ,Let s fix number of plates to have pieces of the first cake plates left for the other cake Obviously the most optimal way to distribute pieces to plates will lead to the minimum of pieces on a plate Now try every possible and take maximum of Overall complexity 
879,The government of Berland decided to improve network coverage in his country Berland has a unique structure the capital in the center and cities around the capital The capital already has a good network coverage so the government ignores it but the th city contains households that require a connection The government designed a plan to build network stations between all pairs of neighboring cities which will maintain connections only for these cities In other words the th network station will provide service only for the th and the th city the th station is connected to the th and the st city All network stations have capacities the th station can provide the connection to at most households Now the government asks you to check can the designed stations meet the needs of all cities or not that is is it possible to assign each household a network station so that each network station provides the connection to at most households ,There are plenty of different solutions to this problem Here is one that doesn t use Hall s theorem Let s look at pair as fuction how many connections will be left for the th city if we take connections from the th station This function has the following structure there is a minimum required let s name it to meet the needs of the th city and with borrowed connections there will be free connections to the th city Increasing by some we can get free connections but there is upper bound to number of free connections In other words the function where For example let s calculate the corresponding coefficients for the th function if then and if then and Why did we define such functions If we can calculate result function then we can check the possibility of meeting all needs by checking that this fuction exists and i e the minimum free can be used as borrowed Fortunately it turns out that the superposition is either don t exists if for example or it has the same structure as any function So we can calculate in one pass and find the answer We will skip the detailed formulas to calculate you can either find them by yourself or look at function in author s solution The resulting complexity is ,Note that all are positive which means that the amount on the prefix only increases This allows us to use binary search to find the answer for the vertex It remains only to learn how to quickly find the sum of on the path prefix Let s run a depth first search and store the prefix sums of the current path in stack going to the vertex add the sum to the end of the path and delete it when exiting 
880,You are given a matrix consisting of rows and columns The rows are numbered top to bottom the columns are numbered left to right Each cell of the matrix can be either free or locked Let s call a path in the matrix if it starts and ends in the free cell visits only free cells has one of the two following structures the second cell is to the right from the first one the third cell is to the bottom from the second one the fourth cell is to the right from the third one and so on the second cell is to the bottom from the first one the third cell is to the right from the second one the fourth cell is to the bottom from the third one and so on In particular a path consisting of a single cell is considered to be a staircase Here are some examples of staircases Initially all the cells of the matrix are You have to process queries each of them flips the state of a single cell So if a cell is currently free it makes it locked and if a cell is currently locked it makes it free Print the number of different staircases after each query Two staircases are considered different if there exists such a cell that appears in one path and doesn t appear in the other path ,The solution consist of two main parts calculate the initial number of staircases and recalculate the number of staircases on query The constraints were pretty loose so we ll do the first part in and the second part in per query However it s worth mentioning that faster is possible The first part can surely be done in and can probably be done in The second part can be done in per query It s important to notice is that the only staircase that satisfy the requirements for both types is the staircase that consists of a single cell Thus staircases of both types can be calculated almost separately Let s define base staircases as the staircases that can t be prolonged further in any direction There are of them on the grid If a staircase consists of at least two cells it s a part of exactly one staircase At the same time every segment of a staircase is a valid staircase by itself Thus the main idea of calculating the initial answer is the following Isolate each staircase and determine its length possibly in Add the number of segments of length at least to the answer Add extra one cell staircases afterwards If you draw the staircases on the grid you can easily determine their starting cell The staircases that start by going one cell to the right start from the first row The staircases that start by going one cell to the bottom start from the first column Notice that both types can start from cell The updates can be handled the following way The answer always changes by the number of staircases that pass through cell if you ignore its state If the cell becomes free then these staircases are added to the answer Otherwise they are subtracted from it That can be calculated for two cases as well Go first down then right as far as possible Let it be steps Go first left then up as far as possible Let it be steps Then staircases are added to the answer Then change the order of steps in both directions to calculate the other type of staircases Beware of one cell staircases again To achieve for precalc you can calculate the length of each staircase with a formula To achieve per query you can first enumerate cells in each staircase separately then maintain the set of segments of adjacent free cells in it ,Notice that it never makes sense to move blocks between the towers such that neither of them is tower 1 as that can only decrease the heights Moreover it never makes sense to move blocks away from the tower 1 Thus all operations will be moving blocks from some towers to tower 1 At the start which towers can move at least one block to tower 1 Well only such i that a i a 1 What happens after you move a block Tower 1 becomes higher some tower becomes lower Thus the set of towers that can share a block can t become larger Let s order the towers by the number of blocks in them At the start the towers that can share a block are at the end on some suffix in this order After one move is made the towers get reordered and the suffix can only shrink Ok but if that suffix shrinks what s the first tower that will become too low The leftmost one that was available before So regardless of what the move is the first tower that might become unavailable is the leftmost available tower Thus let s attempt using it until it s not too late The algorithm then is the following Find the lowest tower that can move the block to tower 1 move a block repeat When there are no more towers higher than tower 1 the process stops However the constraints don t allow us to do exactly that We ll have to make at most 10 9 moves per testcase Ok let s move the blocks in bulk every time Since the lowest available tower will remain the lowest until you can t use it anymore make all the moves from it at the same time If the current number of blocks in tower 1 is x and the current number of blocks in that tower is y lceil frac y x 2 rceil blocks can be moved You can also avoid maintaining the available towers by just iterating over the towers in the increasing order of their height Overall complexity O n log n per testcase 
881,You are given an array of size and queries to it There are queries of two types perform a cyclic shift of the segment to the right That is for every such that new value of becomes equal to old value of and new value of becomes equal to old value of reverse the segment There are important indices in the array For each such that you have to output the number that will have index in the array after all queries are performed ,One can guess from the constraits that complexity of the algorithm should be either or And there is a solution with the second one Let s try to solve the reversed problem answer what position will some number be at after all the queries Check the impact of some query on position Let the query be on some segment If is outside this segment then you can skip it Otherwise reverse will swap and shift will swap and if then it will be instead of This task can be translated to the given one just by reversing the query list Overall complexity Obviously you can also solve it with Cartesian tree online in ,Let s use dynamic programming described in the previous tutorial to solve this problem too But its complexity is so we have to improve some part of the solution Let s see how we do transitions in this dp for What can we do to optimize it is the constant and we have to take the maximum value among You will say segment tree I say no Not a segment tree Not a sparse table Not a cartesian tree or some other logarithmic data structures If you want to spend a lot of time to fit such solution in time and memory limits okay it is your choice I prefer the queue with supporting the maximum on it The last part of this tutorial will be a small guide about how to write and use the queue with supporting the maximum on it The first part of understanding this data structure is the stack with the maximum How do we support the stack with the maximum on it That s pretty easy let s maintain the stack of pairs when the first value of pair is the value in the stack and the second one is the maximum on the stack if this element will be the topmost Then when we push some value in it the first element of pair will be and the second one will be if is our stack and is the topmost element When we pop the element we don t need any special hacks to do it Just pop it And the maximum on the stack is always Okay the second part of understanding this data structure is the queue on two stacks Let s maintain two stacks and and try to implement the queue using it We will push elements only to and pop elements only from Then how to maintain the queue using such stacks The push is pretty easy just push it in The main problem is pop If is not empty then we have to pop it from But what do we do if is empty No problems let s just transfer elements of to pop from push to in order from top to bottom And don t forget to pop the element after this transfer Okay if we will join these two data structures we can see that we obtain exactly what we want Just two stacks with maximums That s pretty easy to understand and implement it The last part of the initial solution is pretty easy just apply this data structure in fact data structures to do transitions in our dynamic programming The implementation of this structure can be found in the authors solution Total complexity of the solution is 
882,You are given a positive integer it is guaranteed that is even i e divisible by You want to construct the array of length such that The first elements of are even divisible by the second elements of are odd not divisible by the sum of the first half equals to the sum of the second half If there are multiple answers you can print any It is that the answer exists You have to answer independent test cases ,Firstly if n is not divisible by 4 then the answer is because the parities of halves won t match Otherwise the answer is always Let s construct it as follows firstly let s create the array 2 4 6 dots n 1 3 5 dots n 1 This array is almost good except one thing the sum in the right half is exactly frac n 2 less than the sum in the left half So we can fix it easily just add frac n 2 to the last element ,It s obvious that we don t need elements that are larger than If the sum of the remaining elements is greater than or equal to 2048 then the answer is and otherwise It s true because for getting a integer that wasn t in the multiset initially we first need to get integer 
883,Alice and Bob are playing yet another card game This time the rules are the following There are cards lying in a row in front of them The th card has value First Alice chooses a non empty consecutive segment of cards After that Bob removes a single card from that segment The score of the game is the total value of the remaining cards on the segment In particular if Alice chooses a segment with just one element then the score after Bob removes the only card is Alice wants to make the score as big as possible Bob takes such a card that the score is as small as possible What segment should Alice choose so that the score is maximum possible Output the maximum score ,Alice wants to choose such a segment that is maximum possible There is a well known problem where you have to find a segment with maximum That problem is solved with Kadane algorithm Let s learn how to reduce our problem to that one Notice that the values in the array are unusually small Let s iterate over the maximum value on segment Let be the current value If we make all such that equal to then it will never be optimal to take them in a segment Find the maximum sum subarray in that modified array and update the answer with its Notice that you can ignore the fact if there is a value exactly equal to on the maximum sum segment If there isn t then you ll update the answer with a smaller value than the actual one Let the actual maximum on the maximum sum segment be some You can see that for any value between and the maximum sum segment will always be that chosen one Thus when you reach you ll update the answer with the correct value Overall complexity ,Let s learn how to count the number of subsegments where for a fixed value of Let s understand on which subsegments has such a value We understand that the numbers should be in this subsegment the number should not and then does not matter Let be the index of the left most occurrence of the numbers and the right most occurrence Also let be the index of the number If then there is no subsegment with the given otherwise let s think about how many numbers can be in a subsegment It is stated that if the length of a segment is then on it otherwise it is not true Indeed if the length of a segment is then simply by the definition of the median it will be among the first numbers On the other hand if the length of the segment becomes longer then according to the same definition of the median it will no longer be among the first numbers which are equal to It turns out that we need to count the number of subsegments of length that contain the subsegment inside themselves but not This of course can be done with large formulas and the like but one more useful fact can be noticed If we iterate over in ascending order and at the same time maintain and then let s see what happens with a fixed and a position of for convenience let s assume that since the second case is similar In fact you can simply iterate over the left border of our segment from to and then use a simpler formula to calculate the number of good subsegments with such fixed values Why can this left boundary be iterated for each if correspondingly if it were then we would iterate over the right boundary Let s remember that after this step becomes equal to That is if we iterate over an element then we move the corresponding border And we can only move it times 
884,Dmitry has a string consisting of lowercase Latin letters Dmitry decided to remove two characters from the string and you are wondering how many different strings can be obtained after such an operation For example Dmitry has a string You can get the following different strings by deleting the first two or second and third characters by deleting the third and fourth characters by deleting the fourth and the fifth character and by deleting the last two ,Consider deleting characters with numbers and as well as characters with numbers and In the first case the symbol with the number remains in the second Symbols with numbers less than or more than remain in both cases Therefore the same strings will be obtained if the characters with the numbers and match Therefore we just need to count the number of and subtract this value from ,We need to make our string alternating i e When we reverse substring we change no more than two pairs and Moreover one pair should be a consecutive pair and other So we can find lower bound to our answer as maximum between number of pairs of and number of pairs of And we can always reach this lower bound by pairing with or with left right border of Another way to count the answer is next suppose we want to make string then let s transform to For example if we will get We claim that after this transformation we will have equal number of and so the answer is the number of consecutive pairs of the same character divided by two The answer is the minimum between answers for and 
885,You are given an array consisting of integers In one operation you can choose two elements of the array and replace them with the element equal to their sum it does not matter where you insert the new element For example from the array you can obtain the following arrays and Your task is to find the maximum possible number of elements divisible by that are in the array after performing this operation an arbitrary possibly zero number of times You have to answer independent queries ,Let be the number of elements of with the remainder modulo Then the initial answer can be represented as and we have to compose numbers with remainders and somehow optimally It can be shown that the best way to do it is the following firstly while there is at least one remainder and at least one remainder let s compose them into one After this at least one of the numbers will be zero then we have to compose remaining numbers into numbers divisible by If then the maximum remaining number of elements we can obtain is because and in the other case the maximum number of elements is because ,Let s denote the difference between and as Then if has a prime divisor we can subtract from times The only positive integer that doesn t have any prime divisors is So the answer is if and only if 
886,You are given an array consisting of integers You have to find array of length such that you can cut out maximum number of copies of array from array Cutting out the copy of means that for each element of array you have to find in and remove it from If for some you cannot find such element in then you cannot cut out one more copy of The both arrays can contain duplicate elements For example if and then one of the possible answers is This array can be cut out times To cut out the first copy of you can use the elements use the highlighted elements After cutting out the first copy of the array can look like To cut out the second copy of you can use the elements After cutting out the second copy of the array will be Your task is to find such array that you can cut out the copy of from maximum number of times If there are multiple answers you may choose of them ,Let s solve the problem using binary search by the answer It is easy to see that if we can construct the answer for some number of copies then we also can do it for The only thing we need is to write the function which will say can we cut off copies of some array from or not Let s imagine copies of string as a matrix of size Obviously each row of this matrix should be equal to each other row Let s fill not rows but columns of this matrix For some element of we can easy notice that we can take exactly columns containing this element where is the number of such elements in So overall number of columns we can fill in this matrix will be If this value is greater than or equal to then is true otherwise it is false It is easy to construct the answer using all things we described above Overall complexity is where is the size of the alphabet ,Suppose the string consists of characters and each character is different from the adjacent ones so the string looks like or It s easy to see that we can t make more than operations each operation deletes at least two characters except for the case when the string consists of only one character And there is an easy way to perform exactly operations always choose the last character and delete it Okay what about the case when some adjacent characters in the string are equal It s never optimal to delete a character that s different from both adjacent characters since the second part of each operation always deletes the left block of equal characters this action merges two blocks so they will be deleted in one second part of the operation which decreases the total number of operations So we should always delete a character from a block with at least two equal characters From which of the blocks if there are more than one It s easy to see that we should choose a character from the leftmost such block since that block is the earliest to be deleted and if we want to make the same action later we might be unable to do it So the solution is greedy during each action we have to find the leftmost block consisting of at least equal characters and delete a character from it or the last character of the string if there are no such blocks Since the length of the string is up to and the number of operations is up to we should do it efficiently for example by storing the eligible blocks in some data structure 
887,You are given segments on a Cartesian plane Each segment s endpoints have integer coordinates Segments can intersect with each other No two segments lie on the same line Count the number of distinct points with which are covered by at least one segment ,I won t tell all the small geometric details just cover some major points The problem asks you the following thing Sum up the total number of points covered by each segment and for each unique point subtract the number of segments covering it minus one Let s reformulate it For each segment add the number of points covered by it and subtract the number of points covered by it and by some already processed segment The first part is easy Segment covers exactly points with integer coordinates The proof left to the reader as an exercise The second part can be done in the following manner Intersect the segment with all segments insert all the points of intersection into set and take its size You can consider only integer points of intersection and use no floating point numbers in your program Overall complexity ,At first let prove that all possible angles in the regular gon equal to where To prove it we can build circumscribed circle around gon Then the circle will be divided on equal arcs with lengths Any possible angle in the gon is a inscribed angle in the circle and equal to half of central angle Any central angle in turn equals to sum of some consecitive arcs In result any angle equal to The maximal possible angle is reached from three consecutive vertices and equal by properties of regular polygons to So we need to find minimal integer such that where is integer and Its equivalent to find minimal integer solution of Let then we can divide both parts on In result Since then must divide Analogically must divide Then solution is next and We are finding the minimal solution so is almost always except cases where here we must take since we have restricition on The picture for the futher visibility 
888,Suppose you are performing the following algorithm There is an array filled with zeroes at start The following operation is applied to the array several times at th step indexed you can either choose position and increase by or not choose any position and skip this step You can choose how the algorithm would behave on each step and when to stop it The question is can you make array equal to the given array for each after some step ,This is the solution that doesn t involve masks Let s reverse the process and try to get all zeroes from the array since all we can start from maximum The key idea since then there should be no more than one position such that and we should decrease it by Now we can decrease by and repeat the same process If at any step there are at least two or as result we won t get array filled with then there is no way to build the array ,Suppose the initial sum of is equal to If we perform the operation the new sum will be equal to We want the sum not to decrease or If we will get If we ll get analogically In other words array you need if sorted will have and so on And one of the variants and obviously an optimal one is just As a result since we just need to check if then we found an answer otherwise there is no counterexample 
889,You are given a room that can be represented by a grid There is a ball at position the intersection of row and column and it starts going diagonally in one of the four directions The ball is going down and right denoted by it means that after a step the ball s location goes from to The ball is going down and left denoted by it means that after a step the ball s location goes from to The ball is going up and right denoted by it means that after a step the ball s location goes from to The ball is going up and left denoted by it means that after a step the ball s location goes from to After each step the ball maintains its direction unless it hits a wall that is the direction takes it out of the room s bounds in the next step In this case the ball s direction gets flipped along the axis of the wall if the ball hits a corner both directions get flipped Any instance of this is called a The ball never stops moving In the above example the ball starts at and goes until it reaches the bottom wall then it bounces and continues in the direction After reaching the left wall the ball bounces and continues to go in the direction When the ball reaches the upper wall it bounces and continues in the direction After reaching the bottom right corner it bounces and continues in direction and so on Your task is to find how many bounces the ball will go through until it reaches cell in the room or report that it never reaches cell by printing Note that the ball first goes in a cell and only after that bounces if it needs to ,We can see that there are at most states the ball can be in because there are cells and states of direction We can simulate the bouncing process keeping count of the bounces until we arrive at the finish cell when we can output the answer or we arrive at a previously visited state and end up in a loop then we can output 1 Bonus Can you prove there are at most states for any given starting position ,If is even then each hour A and B are on the spots with different parity so they will never meet Otherwise let s look closely what happens At the start A in and B in But since we can form a cycle from spots then it means that and in reality are neighbors After that A and B starting from neighboring positions just go in opposite directions and meet each other in the opposite spot after exactly steps After meeting B jumps over A making extra step and the situation become practically the same A and B are neighbors and move in the opposite direction In other words each steps B makes one extra step so the answer if both and spots are indexed is 
890,Mishka is decorating the Christmas tree He has got three garlands and all of them will be put on the tree After that Mishka will switch these garlands on When a garland is switched on it periodically changes its state sometimes it is lit sometimes not Formally if th garland is switched on during th second then it is lit only during seconds and so on Mishka wants to switch on the garlands in such a way that during each second after switching the garlands on there would be at least one lit garland Formally Mishka wants to choose three integers and not necessarily distinct so that he will switch on the first garland during th second the second one during th second and the third one during th second respectively and during each second starting from at least one garland will be lit Help Mishka by telling him if it is possible to do this ,There are pretty few cases to have One of is equal to At least two of are equal to All equal It s easy to notice that having minimum of equal to produce the only case greater numbers will always miss some seconds Let s consider minimum of let it cover all odd seconds Now you should cover all even seconds and and are the only possible solutions Overall complexity ,One can notice or actually derive using some maths that the answer is the sum of products of nested for loops iterations for every add command Let s learn to simulate that in linear complexity Maintain the stack of multipliers on for push the top of stack multiplied by to the stack on end pop the last value on add add the top of the stack to the answer The problem however is the values are really large Notice that once you add the value greater or equal to to the answer it immediately becomes OVERFLOW Thus let s push not the real multiplier to the stack but min multiplier That way the maximum value you can achieve is about which fits into the 64 bit integer Overall complexity 
891,You are given a positive integer Check whether the number is representable as the sum of the cubes of two positive integers Formally you need to check if there are two integers and such that For example if then the numbers and are suitable If then no pair of numbers and is suitable ,In this problem we need to find and such that and Since and are positive and are also positive Hence Therefore the number can be iterated from to Since in all tests then For each you can find by the formula This is a positive number It remains to check that is an integer ,Let s denote the difference between and as Then if has a prime divisor we can subtract from times The only positive integer that doesn t have any prime divisors is So the answer is if and only if 
892,Mikhail walks on a 2D plane He can go either up or right You are given a sequence of Mikhail s moves He thinks that this sequence is too long and he wants to make it as short as possible In the given sequence moving up is described by character and moving right is described by character Mikhail can replace any pair of consecutive moves or with a diagonal move described as character After that he can go on and do some other replacements until there is no pair of consecutive moves or left Your problem is to print the minimum possible length of the sequence of moves after the replacements ,Let s iterate over all characters of the string from left to right excluding last character Suppose is a position of the current element of the string If increase answer by and increase by else just increase by ,You can just implement what is written in the problem statement and solve this problem this way Let s iterate over all starting positions of the substring from to and over all possible offsets of the string from to inclusive Then let s iterate over all position of the current substring from to and carry the variable which denotes the answer for the current starting position and the current offset And if then let s increase by After iterating over all positions let s update the answer with the value of 
893,You are given four integers Timur and three other people are running a marathon The value is the distance that Timur has run and correspond to the distances the other three participants ran Output the number of participants in front of Timur ,We can re word the problem to count the number of numbers from that are larger than A possible way to do this is by keeping a variable that gets incremented every time we checked using the if statement whether a number is larger than The complexity is ,Let s sort all numbers in a Now let s iterate over elements of b and for element bj find the index of lowest number that is greater than bj We can do that using binary search That index will be the answer for value bj Complexity O nlogn 
894,There are armchairs numbered from to from left to right Some armchairs are occupied by people at most one person per armchair others are not The number of occupied armchairs is not greater than For some reason you would like to tell people to move from their armchairs to some other ones If the th armchair is occupied by someone and the th armchair is not you can tell the person sitting in the th armchair to move to the th armchair The time it takes a person to move from the th armchair to the th one is minutes You may perform this operation any number of times but these operations must be done sequentially i e you cannot tell a person to move until the person you asked to move in the last operation has finished moving to their destination armchair You want to achieve the following situation every seat that was initially occupied must be free What is the minimum time you need to do it ,Let s say that the starting position of people are in sorted order and ending positions of people are also in sorted order It s always optimal to match these starting and ending positions in sorted order the leftmost starting position is matched with the leftmost ending the second starting position is matched with the second ending and so on To prove it suppose that position is matched with position is matched with and If both persons go to the left or to the right it means that either or so nothing changes if we swap the matched positions If instead the person that goes from to goes to the right and the person that goes from to goes to the left the segment belongs to both paths and swapping the matched pairs removes this segment from both paths and decreases the total time So if the order of starting positions is sorted and the order of ending positions is sorted these positions should be matched exactly in those order Using this fact we can implement the following dynamic programming let be the minimum time if we considered first positions and picked of them as the ending ones Transitions are the following we either take the current position as the ending one if it s not a starting one match it with the th starting position and go to or we skip the current position and go to It works in since it has up to states and just up to transitions from each state ,Notice that it never makes sense to move blocks between the towers such that neither of them is tower 1 as that can only decrease the heights Moreover it never makes sense to move blocks away from the tower 1 Thus all operations will be moving blocks from some towers to tower 1 At the start which towers can move at least one block to tower 1 Well only such i that a i a 1 What happens after you move a block Tower 1 becomes higher some tower becomes lower Thus the set of towers that can share a block can t become larger Let s order the towers by the number of blocks in them At the start the towers that can share a block are at the end on some suffix in this order After one move is made the towers get reordered and the suffix can only shrink Ok but if that suffix shrinks what s the first tower that will become too low The leftmost one that was available before So regardless of what the move is the first tower that might become unavailable is the leftmost available tower Thus let s attempt using it until it s not too late The algorithm then is the following Find the lowest tower that can move the block to tower 1 move a block repeat When there are no more towers higher than tower 1 the process stops However the constraints don t allow us to do exactly that We ll have to make at most 10 9 moves per testcase Ok let s move the blocks in bulk every time Since the lowest available tower will remain the lowest until you can t use it anymore make all the moves from it at the same time If the current number of blocks in tower 1 is x and the current number of blocks in that tower is y lceil frac y x 2 rceil blocks can be moved You can also avoid maintaining the available towers by just iterating over the towers in the increasing order of their height Overall complexity O n log n per testcase 
895,You are given an undirected unweighted connected graph consisting of vertices and edges It is guaranteed that there are no self loops or multiple edges in the given graph Your task is to choose vertices in this graph so unchosen vertex is adjacent in other words connected by an edge to at least one of chosen vertices It is guaranteed that the answer exists If there are multiple answers you can print any You will be given multiple independent queries to answer ,Firstly let s run bfs on the given graph and calculate distances for all vertices In fact we don t need distances we need their parities The second part is to find all vertices with an even distance all vertices with and odd distance and print the smallest by size part Why is it always true Firstly it is obvious that at least one of these sizes will not exceed And secondly because we are checking just parities of distances it is obvious that each vertex of some parity is connected with at least one vertex of the opposite parity because it has this parity from some vertex of the opposite parity ,Let s divide all valid pairs into three categories the ones containing only edges on the path the ones containing only edges and the ones containing both types of edges To calculate the number of pairs containing only edges we may build a forest on the vertices of the original graph and edges and choose all pairs of vertices belonging to the same connected components of this forest we can find all connected components with DSU or any graph traversal algorithm The same can be done for the pairs containing only edges If a path from to is valid and contains both types of edges then there exists a vertex such that the simple path from to goes only through edges and the simple path from to goes only through edges So let s iterate on this vertex and choose some other vertex from its component in graph as and some other vertex from its component in graph as and add the number of ways to choose them to the answer 
896,You are given a string of length consisting of lowercase Latin letters You may apply some operations to this string in one operation you can delete some contiguous substring of this string if all letters in the substring you delete are equal For example after deleting substring from string we get the string Calculate the minimum number of operations to delete the whole string ,We will solve the problem by dynamic programming Let be the answer for substring Then we have two cases The first letter of the substring is deleted separately from the rest then The first letter of the substring is deleted alongside with some other letter both letters must be equal then ,Let s go from left to right over characters of maintaining the current bracket balance for the position the balance is the number of opening brackets on the prefix till the th character minus the number of closing brackets on the same prefix If the current balance becomes less than zero then let s just take some opening bracket after the current position it obviously exists because the number of opening equals the number of closing brackets and move it to the beginning so the negative balance becomes zero again and the answer increases by one Or we can move the current closing bracket to the end of the string because it leads to the same result Time complexity 
897,Given a lowercase Latin character letter check if it appears in the string ,You need to implement what is written in the statement You can either use an if statement for each of the characters or you can iterate through the string check if the current character equals ,The general idea of the solution is to check that string contains some substring which is a permutation of The constraints were so low you could do it with any algorithm even per test case could pass The most straightforward way was to iterate over the substring of sort it and check if it s equal to sorted That s Next you could notice than only substrings of length matter and shave another off the complexity to get After that you might remember that the size of the alphabet is pretty low And one string is a permutation of another one if the amounts of letters a letters b and so on in them are equal So you can precalculate array where is equal to the amount of the th letter of the alphabet in Calculating this array for substrings will be each so that makes it Then notice how easy it is to recalculate the letter counts going from some substring to Just subtract from the amount of the th letter and add to the amount of the th letter Comparing two array every time will still lead to though The final optimization is to maintain the boolean array such that means that is equal to the current value of of the substring You are updating just two values of on each step thus only two values of might change You want all the values to be so keep the number of values in that array and say if that number is equal to That finally makes the solution per test case 
898,You are given matrix with rows and columns filled with zeroes You should put ones in it in such a way that the resulting matrix is symmetrical with respect to the main diagonal the diagonal that goes from the top left to the bottom right corner and is lexicographically maximal One matrix is lexicographically greater than the other if the first different number in the first different row from the top in the first matrix is greater than the corresponding number in the second one If there exists no such matrix then output ,Let s construct matrix from top to bottom from left to right At current step we consider position Look at contents of cells and If number of zeroes in them doesn t exceed then let s fill those cells with ones and decrease by this number If isn t equal to in the end of algorithm then there is no answer Overall complexity ,There are pretty few cases to have One of is equal to At least two of are equal to All equal It s easy to notice that having minimum of equal to produce the only case greater numbers will always miss some seconds Let s consider minimum of let it cover all odd seconds Now you should cover all even seconds and and are the only possible solutions Overall complexity 
899,There are cities in Berland The city numbered is the capital Some pairs of cities are connected by a road of length 1 Before the trip Polycarp for each city found out the value of the shortest distance from the capital the st city to the th city Polycarp begins his journey in the city with number and being in the th city chooses one of the following actions Travel from the th city to the th city if there is a road from the th city to the th and Travel from the th city to the th city if there is a road from the th city to the th and Stop traveling Since the government of Berland does not want all people to come to the capital so Polycarp can take the second action from the list in other words he can perform the second action or time during his journey Polycarp on the other hand wants to be as close to the capital as possible For example if and the cities are connected as in the picture above then Polycarp could have made the following travels not all possible options Polycarp wants for each starting city to find out how close he can get to the capital More formally he wants to find the minimal value of that Polycarp can get from the city to the city according to the rules described above ,Find the distances to all vertices and construct a new graph that has only edges that goes from a vertex with a smaller distance to a vertex with a larger distance Such a graph cannot contain cycles Next you need to run a dynamic programming similar to finding bridges in an undirected graph First we write the minimum distance from each vertex to the capital using no more than one edge This distance is either equal to the distance from the capital to the vertex itself or the distance to the vertex connected to us by one of the remote edges We can t go through more than one remote edge The real answer for a vertex is the minimum of such values in all vertices reachable from in the new graph Since the new graph is acyclic we can calculate the answer using dynamic programming and a depth first search started from the capital ,The constraits are set in such a way that naive solution won t pass unmark every edge one by one and check if graph of marked edges doesn t contain cycles with dfs bfs Thus we should somehow limit the number of edges to check Let s take arbitrary cycle in graph Do dfs store the vertex you used to travel to any other vertex and restore edges with this data if cycle is met With this algo length of cycle will not exceed Then do the naive algo but check only edges from this cycle Overall complexity 
900,Monocarp had a permutation of integers a permutation is an array where each element from to occurs exactly once Then Monocarp calculated an array of integers of size where For example if the permutation is then the array is equal to Unfortunately the Monocarp has lost his permutation so he wants to restore it Your task is to find a permutation that corresponds to the given array If there are multiple possible permutations then print any of them The tests are constructed in such a way that least one suitable permutation exists ,We have for each we can rewrite this as follows or From here we can see that for each there is a segment of values that can be assigned to So we have to match each number from to with one of these segments To solve this problem we can iterate from to Let the current number be then it can be paired with a segment without a pair such that and the right bound is minimum among all such segments because it will be the first to end among these segments To do this it is enough to maintain a set with open segments that have not yet been assigned a pair and choose from it a segment with the minimum right bound Before running this method you can sort the segments by their left border so they can be easily added to this set when we go from to we will need to insert all segments that begin with that s why it s convenient to have them sorted by their left border beforehand ,We are given the definition of the balanced multiset but let s instead fix the criteria to determine if the multiset is unbalanced Take an empty multiset and start adding numbers to it until it becomes unbalanced Empty set to the set of one number is trivial Now for the second number If there is some position such that both numbers have non zero digits in it then the multiset becomes unbalanced let these be non zero digits and then can be neither nor After that let s prove that you can never make an unbalanced multiset balanced again by adding numbers to it Let there be such multisets and such is unbalanced is balanced and Take a look at the lowest position which has non zero digits in several numbers from The sum of these digits should be equal to at least one of them modulo to satisfy the condition of balance That can only mean their sum is greater or equal to thus is make a carry to the next position The sum of digits on the next position plus carry should also be equal to some digit of them thus pushing some other carry value to the next one And so on until the carry makes it to the position greater than any position in any of the numbers But the carry is non zero and there is no number with any non zero digit in this position That makes our assumption incorrect After all it implies that any unbalanced multiset of size greater than two has an unbalanced multiset of size two The problem now got reduced to find a pair of numbers and such that there is at least one position such that both and have non zero digits on it and is minimal possible That can be easily maintained in a segment tree Let a node corresponding to the interval keep the best answer on an interval the sum of such a pair and an array the smallest number on an interval which has a non zero digit at position or if none exists The update is easy Iterate over the digits of a new number and update the values in the array in the corresponding nodes The merge is done the following way push the best answers from children to the parent and then iterate over the positions and try to combine the smallest numbers at each one from the left child and the right child Idea wise this is the same as storing a segtree and calculating the answer by each position separately However these approaches differ by a huge constant factor performance wise The former one accesses the memory in a much more cache friendly way You might want to take that as a general advice on implementing multiple segtrees Overall complexity 
901,You are given a tree with vertices its root is vertex Also there is a token initially placed in the root You can move the token to other vertices Let s assume current vertex of token is then you make any of the following two possible moves move down to any in subtree of if vertex is a leaf then move up to the parent no more than times In other words if is the depth of vertex the depth of the root is then you can move to vertex such that is an ancestor of and Consider that root is not a leaf even if its degree is Calculate the maximum number of different leaves you can visit during one sequence of moves ,Let s calculate answer in two steps At first let s calculate for each vertex what we can gain if we must return from subtree of in the end We need only pair of values minimal possible depth we can acquire to move up from subtree of and maximal number of different leaves we can visit Note that this two values are independent since we must return from and if for some child of we can return from it it s profitable to visit and return But if we can t return from so we are prohibited to descent to So number of visited leaves is just a sum of all if Also note that we can always reorder all children in such way that last visited vertex will have minimal So minimal possible depth is a minimum over all At second let s calculate maximal number of different leaves we can visit if we don t need to return from subtree of It can be calculated quite easy using array We just need to choose child we will not return from so from vertex we will take value and from other childen which we can return from value Result complexity is ,The first idea is the following it is always profitable to add the edges from the vertex to any other vertex The proof is the following if we will add two edges and then the distance to the vertex will be the distance to the vertex will be But we can add edges and and this will be better in fact you cannot obtain the less answer by adding two edges in the other way The main idea is the following Let s carry all vertices of the tree with the distance more than in the set Let the vertex with the maximum distance be What we will obtain if we will add the edge The distance to the vertex will be and the distance to the vertex where is the parent of the vertex if we will root the tree by the vertex will be So we will make reachable at most two vertices if the vertex is already reachable then it will be not counted in the answer Now what we will obtain if we will add the edge We will make reachable all the vertices adjacent to the vertex and the vertex the number of such vertices is not less than so this move won t make the answer greater instead of any other way to add the edge After adding such edge let s remove the vertex and all vertices adjacent to it from the set We need to repeat this algorithm until the set will not become empty Time complexity is I sure that there exists the solution with the dynamic programming in the linear time I will be very happy if someone will explain it to other participants 
902,One day Masha came home and noticed mice in the corridor of her flat Of course she shouted loudly so scared mice started to run to the holes in the corridor The corridor can be represeted as a numeric axis with mice and holes on it th mouse is at the coordinate and th hole at coordinate th hole has enough room for mice so not more than mice can enter this hole What is the minimum sum of distances that mice have to go through so that they all can hide in the holes If th mouse goes to the hole then its distance is Print the minimum sum of distances ,This problem can be solved using dynamic programming Let be the answer for first holes and mice If the constraints were smaller then we could calculate it in just trying to update by all values of where and calculating the cost to transport all mice from the segment to th hole To calculate this in we will use a deque maintaining the minimum or a queue implemented on two stacks for example We iterate on and update all the values of with the help of this deque for each index we insert a value in the deque equal to where is the total distance required to move first mice to hole Updating the value is just extracting the minimum and adding this to it Don t forget to delete values from the deque to ensure that we don t send too much mice to the hole Time complexity ,At first lets place gon in such way that the lowest side of gon is horizontal Now we can without loss of generality think that the square has horizontal and vertical sides and we just rotate gon around its center If we rotate the gon at angle then it will move on itself Moreover after rotating at angle we ll get left and right sides vertical and the following rotation is meaningless since it s the same as if we just swap and coordinates So we don t we to rotate more than Also we can see that while rotating the difference between max and min decreasing while the distance between max and min increasing The answer is obviously the maximum among these differences So for example we can just ternary search the optimal answer Or we can note that the behavior of differences is symmetrical just swap and coordinates so the answer is in the middle angle i e we just need to rotate gon at angle Finally observing several right triangles we can come up with quite an easy answer 
903, You are given an array consisting of integers In one move you can choose any and divide it by rounding down in other words in one move you can set You can perform such an operation possibly zero number of times with Your task is to calculate the minimum possible number of operations required to obtain at least equal numbers in the array ,Let be the number such that after some sequence of moves there will be at least elements in the array We can see that there is always possible candidates because all values are among all possible values of for some from to So we need to check each candidate separately and try to update the answer with it How to do this Let the current number we trying to obtain is Then let s iterate over all in any order Let be the current value of Let s divide it by while its value is greater than and carry the number of divisions we made If after all divisions then let s remember the value of in some array If after iterating over all elements of the size of is greater than or equal to then let s sort it and update the answer with the sum of smallest values of Time complexity or depends on sorting method ,Let s look at our arrays and Note that for any position such that we can always fix it by swapping positions from to In that case contribution from all won t change contribution of pair will decrease and contribution from all won t change again since we swapped all of them It means that we already can use the following algorithm while exists such that just swap all from to This solution works for per test that should be enough But we can optimize our approach by realizing that we can instead of searching each time just go from to and fix pairs one by one if then swap with next if then swap with and so on In such way solution works in 
904,Monocarp is going to host a party for his friends He prepared dishes and is about to serve them First he has to add some powdered pepper to each of them otherwise the dishes will be pretty tasteless The th dish has two values and its tastiness with red pepper added or black pepper added respectively Monocarp won t add both peppers to any dish won t add any pepper multiple times and won t leave any dish without the pepper added Before adding the pepper Monocarp should first purchase the said pepper in some shop There are shops in his local area The th of them has packages of red pepper sufficient for servings and packages of black pepper sufficient for servings Monocarp goes to exactly one shop purchases multiple possibly zero packages of each pepper in such a way that More formally if he purchases red pepper packages and black pepper packages then and should be non negative and should be equal to For each shop determine the maximum total tastiness of the dishes after Monocarp buys pepper packages only in this shop and adds the pepper to the dishes If it s impossible to purchase the packages in the said way print ,Let s start by learning how to answer a query all red pepper and black pepper options are available Let s iterate over all options to put the peppers and choose the maximum of them First let s use the red pepper for all dishes Now we want to select some of them to use black pepper instead of red pepper Which ones do we choose When we switch from the red pepper to the black pepper the total tastiness changes by for the th dish They are completely independent of each other so we want to choose largest of these values Let be the sequence of values of in a non increasing order Thus black peppers will yield the result of We can answer a query by looking for a maximum in the sequence Now consider an arbitrary query Let be all options for the amount of available black peppers for the query Naively we could iterate over all of them and choose the maximum one However notice an interesting thing about the sequence of the answers By definition it is non strictly convex In particular one idea that can be extracted from this is the following Find the position of an arbitrary maximum in this sequence Then everything to the left of is is non increasing Everything to the right of it is non increasing Thus for a query it s enough to consider only two options the one closest to the maximum from the left and from the right Now we only have to learn how to get these options fast enough For a query we want to solve what s called a diophantine equation An arbitrary solution can be obtained by using extended Euclid algorithm Let it be some Then we would want to check the answer for black peppers The amount of solutions to the equation is either infinite or zero If it s infinite all solutions will be of the form for any integer Remember that not all the solutions will be in a range Finally find the two solutions that are the closest to the maximum check that they are in the range and print the best answer of them Overall complexity ,If we cut the sheet in width we will reduce its width by half without changing the height Therefore the width and height dimensions do not affect each other in any way Let s calculate the maximum number of sheets that we can get by cutting Let s say that initially this number is Let s cut the sheet in width Then the sheets number will become but they will be the same If we can cut the sheet again it is more profitable to cut all the sheets we have because this way we will get more new sheets and their size will still be the same So we can maintain the current number of identical sheets and as long as either the width or height is divided by divide it and multiply the number of sheets by two 
905,A tennis tournament with participants is running The participants are playing by an olympic system so the winners move on and the losers drop out The tournament takes place in the following way below is the number of the participants of the current round let be the maximal power of the number such that participants compete in the current round and a half of them passes to the next round the other participants pass to the next round directly when only one participant remains the tournament finishes Each match requires bottles of water for each participant and one bottle for the judge Besides towels are given to each participant for the whole tournament Find the number of bottles and towels needed for the tournament Note that it s a tennis tournament so in each match two participants compete one of them will win and the other will lose ,Here you can simply model the process Or you can note that after each match some player drops out In total players will drop out So the first answer is Obviously the second answer is ,If for some hero no other hero is weaker than then the th hero cannot win any fights and is not a possible winner Otherwise the hero is a possible winner he may fight the weakest hero times and be declared the winner So the solution to the problem is calculating the number of minimum elements in the array since all other elements denote possible winners of the tournament 
906,A string is called if it is some string written twice in a row For example the strings and are square But the strings and are not square For a given string determine if it is square ,If the length of the given string is odd then the answer is since adding two strings cannot do that Otherwise let be the length of the string Let s go through the first half of the string comparing whether its first and characters are equal its second and characters are equal and so on If the characters in any pair are not equal the answer is otherwise ,The necessary condition to make strings equal is that the number of occurrences of each character should be the same in both strings Let s show that if some character appears more than once we always can make strings equal How Let s sort the first string by swapping adjacent characters and it does not matter what do we do in the second string Then let s sort the second string also by swapping adjacent characters but choose the pair of adjacent equal characters in the first string it always exists because the first string is already sorted Otherwise all characters in both strings are distinct and they lengths are at most Then the answer is if the parity of the number of inversions the number inversions in the array is the number of such pairs of indices that but are the same It can be proven in the following way every swap of two adjacent elements changes the parity of the number of inversions Time complexity 
907,Two players are playing a game They have a permutation of integers a permutation is an array where each element from to occurs exactly once The permutation is not sorted in either ascending or descending order i e the permutation does not have the form or Initially all elements of the permutation are colored red The players take turns On their turn the player can do one of three actions rearrange the elements of the permutation in such a way that all elements keep their positions note that elements can be swapped with each other but it s not obligatory change the color of one red element to blue skip the turn The first player wins if the permutation is sorted in ascending order i e it becomes The second player wins if the permutation is sorted in descending order i e it becomes If the game lasts for turns and nobody wins it ends in a draw Your task is to determine the result of the game if both players play optimally ,Note that it makes no sense to use the first type of operation if it does not lead to an instant win because the opponent can return the previous state of the array with their next move So the winner is the one who has time to color their elements in blue first Let s denote as the number of elements that only the first player needs to color as the number of elements only the second player needs to color both players needs to color To win the first player needs to have time to paint elements and they have no more than moves to do it because otherwise the second player can prevent the win of the first player So the winning condition for the first player is Similarly for the second player with the only difference that they have move less because they go second which means the condition is If none of these conditions are met then neither player has a winning strategy which means they will both reduce the game to a draw ,At first let s transform input to a more convenient form We consider only such subsegments that consist of the symbols and which cannot be expanded to the right or left For example for we consider segments of length and Let s divide all such segments into four groups by their length In such a division each segment belongs to exactly one type Suppose that the Bob takes the first turn If there is a segment of second type then Bob wins because he always have a spare turn that Alice cannot make If there is a segment of fourth type then the Bob also wins because he can make the segment of second type by taking turn in this segment of four type If there are no segments of second and four types then victory depends on the parity of the number of segments of the third type But it is true if the Bob takes first turn If Alice takes first turn then she doesn t want after her move there are segments of the second and fourth types So if initially there is a segment of second type then Alice loses because she can t take turns into segment of second type If there are two or more segments of four type then Alice also loses because after her turn at least one such segments remains If there are only one segment of four type then Alice have to take turn into this segment Since the length of this segment doesn t exceed we can iterate over all possible Alice moves After Alice s move segment of fourth type can be divided into no more than two new segments let s denote their types as and If at least one of these segments of second or fourth type then it s bad turn for Alice Otherwise Alice win if remaining number of segment of third type is even note that or also can be the third type And finally if initially there are only segments of first or third type then victory depends on the parity of the number of segments of the third type 
908, There is a deck of cards each of which is characterized by its power There are two types of cards a hero card the power of such a card is always equal to a bonus card the power of such a card is always positive You can do the following with the deck take a card from the top of the deck if this card is a bonus card you can put it of your bonus deck or discard if this card is a hero card then the power of card from your bonus deck is added to his power if it is not empty after that the hero is added to your army and the used bonus discards Your task is to use such actions to gather an army with the maximum possible total power ,To solve it it should be noted that despite the way the deck with bonuses works the order in which they will be applied is not important Then when we meet the hero card we just need to add to the answer the maximum of the available bonuses Constraints make you use structures such as a priority queue to quickly find and extract the maximum ,To view the main idea of the problem read the editorial of easy version The only difference is that for non negative we don t need to print if we cannot take the project we just need to skip it because we cannot take it at all And for negative we need to write the knapsack dynamic programming to take the maximum possible number of projects we need to consider them in order of their sorting Dynamic programming is pretty easy means that we consider projects and our current rating is and the value of dp is the maximum number of negative projects we can take If the current project is the th negative project in order of sorting we can do two transitions and if then we can make the transition And then we just need to find the maximum value among all values of dp and add the number of positive projects we take to find the answer 
909,You are given a program that consists of instructions Initially a single variable is assigned to Afterwards the instructions are of two types increase by decrease by You are given queries of the following format query how many distinct values is assigned to if all the instructions between the th one and the th one inclusive are ignored and the rest are executed without changing the order ,The value of always changes by thus the set of values of is always some contiguous segment The length of such segment can be determined by just its minimum and maximum values So we have to solve two separate tasks for each query find the minimum and the maximum value gets assigned to I ll describe only the minimum one This task however can as well be split into two parts minimum value on a prefix before and on a suffix after The prefix is easy it doesn t get changed by a query so it can be precalculated beforehand Minimum value on a prefix of length is minimum of a minimum value on a prefix of length and the current value The suffix minimum is not that trivial First in order to precalculate the minimum value on a suffix of length we have to learn to prepend an instruction to the suffix of length Consider the graph of values of over time What happens to it if the initial value of is not but for example It just gets shifted by upwards That move is actually the same as prepending a instruction So the minimum value for a suffix of length is a minimum of a minimum value for a suffix of length increased by the current instruction and the start of the graph So now we have a minimum value on a suffix after However it can t be taken into the answer as it is because it considers the graph for the suffix to be starting from And that s not the case The graph for the suffix starts from the value the prefix ends on So we can shift the answer for the suffix by the value of after the prefix The overall minimum value is just the minimum on a prefix and on a suffix then Overall complexity per testcase ,Let s prove that in the set minimum elements will be from pairs where we ll take minimums and analogically maximums will be from pairs where we ll take maximums By contradiction let s look at two pairs and where we will take maximum from and minimum from and if we swap elements and and get pair the result won t change but now minimum from pair will be less than maximum from So we can always make pairs in such a way that the chosen minimum from any pair will be less than the chosen maximum from any other pair Let s make set as all elements which are not in In the same way we can prove that minimums of are from pairs where we took maximums and maximums are from pairs where we took minimums Let s say and are sorted Now we ve proven that for a fixed we should pair with and with It s not hard to prove that it s optimal to pair and in the same way For a fixed we can just check that constructed pairs are valid But what happens if we move from to If for all was valid then for all pairs will be valid as well And on contrary if at least one pair wasn t valid then for the pair won t be valid as well Due to monotony we can find the maximum valid just checking only pairs and in the same way we can find maximum minimum such that all pairs are valid That s why all valid s form a segment and we need to find its borders We can find a maximum maximum with either binary search or with two pointers and print the length of the segment Time complexity is either or 
910,You are given four integers and Let s name a tuple as if Find any good tuple ,Let s look at where It can be proven that there always exists such pair and that and Brief proof is following calculate then let and Obviously such will make from and from if And since and since As we can see divides so if we will iterate over all pairs where there will be pairs in total Let s fix value of Then from one side but from the other side since then Anyway all valid form a segment possibly empty segment And we need to find any that divides any from the segment and doesn t exceed Obviously it s optimally to find the minimum possible such and just check inequality We can find such for a fixed using for example built in in a set with all divisors for all valid To maintain this set we can note that simillary So we can move valid segment s ends as two pointers Each pair will be added and erased from the segment exactly once That s why the total complexity of maintaining the set of divisors as well as the total complexity of queries for each will be equal to All pairs and can be precalculated in using the sieve like algorithm ,This problem has a GCD based solution Firstly lets try to solve it naively Always suppose that If this is not true let s swap and Firstly if let s do Okay now let s subtract from until again and repeat this algorithm till or If after some step we get or we are done and the answer is If or and we didn t get then the answer is Okay we can see that we always subtract the minimum possible from and trying to maintain this condition It can be proven that this algorithm yields all possible integers that are obtainable by any sequence of the operations from the problem statement either in or in Now we have to speed up this solution somehow Obviously most operations are redundant for us in this particular problem The first thing is that we can skip all operations till becomes greater than The number of such operations is And the second thing is that we can skip all operations till we get in The number of such operations is For simplicity this part can be also written as This doesn t affect the time complexity much but the formula for the final number of operations we can skip will be simpler This number equals in fact we take the minimum between two values written above because we don t want to skip any of these two cases So we can transform the pair to the pair and continue this algorithm There are also simpler approaches using the same idea but in a cooler way Time complexity per test case 
911, Vlad found a row of tiles and the integer The tiles are indexed from left to right and the th tile has the color After a little thought he decided what to do with it You can start from any tile and jump to any number of tiles forming the path Let s call the path of length if can be divided into blocks of length exactly that is is divisible by Your task is to find the number of paths of length Since this number may be too large print it modulo ,Let s use the dynamic programming Let be the number of paths on the prefix of blocks of the same color To make transitions in such dynamics for the position we will iterate over the position in which the block started Denote as the number of the same elements as and between them then such a transition creates combinations This solution works in complexity ,There are some solutions based on case analysis but in my opinion the most elegant one is the following Let s pick a color with the maximum possible number of pixels and repaint all other pixels into it We will try to pick all pixels of some other color and repaint them in one operation and we can ignore the constraint that we can repaint no more than pixels since we will never need to repaint or pixels in one operation So the number of operations is just the number of colors other than the one we chosen or just where is the number of different colors in the image To calculate this we can use a set or an array of size where we mark which colors are present 
912,Two gram is an ordered pair i e string of length two of capital Latin letters For example three distinct two grams You are given a string consisting of capital Latin letters Your task is to find two gram contained in the given string i e two consecutive characters of the string maximal number of times For example for string the answer is two gram which contained in three times In other words find any most frequent two gram Note that occurrences of the two gram can overlap with each other ,There are at least two different approaches to this problem You can iterate over all substrings of of length and calculate for each of them the number of its occurrences in and try to update the result with the current substring Also you can iterate over all two grams in the alphabet and do the same as in the aforementioned solution ,This problem can be solved with different suffix structures Model solution uses suffix array First of all let s reverse so for we will count only occurences that start in non forbidden indices Then if there is at least one non forbidden index there are two cases then the best option to choose is to use a suffix which begins in the leftmost after reversing non forbidden index then is the longest common prefix of some two suffixes of Let s build a suffix array then calculate the LCP array Then recall the fact that a LCP of two suffixes is the minimum on the segment of LCP array between these two suffixes so we can use a common stack algorithm that will for each LCP find the segment of suffixes such that this LCP is a prefix of these suffixes to do this for each element of LCP array we find the largest segment such that this element is minimal on that segment and then we can use prefix sums to find the number of non forbidden suffixes such that chosen LCP is a prefix of this suffix and so calculate easily for each LCP 
913,There is a grid You are standing at cell and your goal is to finish at cell You can move to the neighboring cells to the right or down In other words suppose you are standing at cell You can move right to the cell it costs burles move down to the cell it costs burles Can you reach cell spending burles ,Note that whichever path you choose the total cost will be the same If you know that the cost is the same then it s not hard to calculate it It s equal to So the task is to check is equal to or not The constant cost may be proved by induction on for cost is For a fixed there are only two last steps you can make either from with cost the total cost is or from with cost the total cost is So whichever path you choose the total cost is the same ,Find the distances to all vertices and construct a new graph that has only edges that goes from a vertex with a smaller distance to a vertex with a larger distance Such a graph cannot contain cycles Next you need to run a dynamic programming similar to finding bridges in an undirected graph First we write the minimum distance from each vertex to the capital using no more than one edge This distance is either equal to the distance from the capital to the vertex itself or the distance to the vertex connected to us by one of the remote edges We can t go through more than one remote edge The real answer for a vertex is the minimum of such values in all vertices reachable from in the new graph Since the new graph is acyclic we can calculate the answer using dynamic programming and a depth first search started from the capital 
914,There is a field of size Each cell of this field can either contain grass or be empty The value is if the cell contains grass or otherwise In one move you can choose and and cut all the grass in this row and this column In other words you choose the row and the column then you cut the grass in all cells and all cells for all from to After you cut the grass from a cell it becomes empty i e its value is replaced by Your task is to find the minimum number of moves required to cut the grass in all non empty cells of the field i e make all zeros You have to answer independent test cases ,If there is no grass on the field the answer is If the whole field is filled with grass the answer is because there always will be one cell that we can t clear with one move Otherwise the answer is This is because if the cell is empty we can just choose other row than and other column than and clear three other cells in one move ,Let s rotate the grid by and and mark all cells that map to each other under these rotations For example for and grids mirror grid must have the following patterns the same letters denoting equal values In general we can rotate the grid by and and see which cells need to have equal values by seeing the positions which each cell maps to Now to solve the problem we consider each equal value each of the letters in the above figures independently and consider the minimum number of moves to make them all or all The answer is the total across all values See the implementation for better understanding The time complexity is per testcase 
915,There are candies in a row they are numbered from left to right from to The size of the th candy is Alice and Bob play an interesting and tasty game they eat candy Alice will eat candy and Bob The game ends if all the candies are eaten The process consists of moves During a move the player eats one or more sweets from her his side Alice eats from the left Bob from the right Alice makes the first move During the first move she will eat candy its size is Then each successive move the players alternate that is Bob makes the second move then Alice then again Bob and so on On each move a player counts the total size of candies eaten during the current move Once this number becomes strictly greater than the total size of candies eaten by the other player on their previous move the current player stops eating and the move ends In other words on a move a player eats the smallest possible number of candies such that the sum of the sizes of candies eaten on this move is than the sum of the sizes of candies that the other player ate on the move If there are not enough candies to make a move this way then the player eats up all the remaining candies and the game ends For example if and then move 1 Alice eats one candy of size and the sequence of candies becomes move 2 Alice ate on the previous move which means Bob must eat or more Bob eats one candy of size and the sequence of candies becomes move 3 Bob ate on the previous move which means Alice must eat or more Alice eats three candies with the total size of and the sequence of candies becomes move 4 Alice ate on the previous move which means Bob must eat or more Bob eats two candies with the total size of and the sequence of candies becomes move 5 Bob ate on the previous move which means Alice must eat or more Alice eats two candies with the total size of and the sequence of candies becomes move 6 the last Alice ate on the previous move which means Bob must eat or more It is impossible so Bob eats the two remaining candies and the game ends Print the number of moves in the game and two numbers the total size of all sweets eaten by Alice during the game the total size of all sweets eaten by Bob during the game ,This is just an implementation problem and it can be solved in time but we didn t ask for such solutions so you could solve it in or maybe even in I ll describe solution anyway Firstly we need to maintain several variables initially the number of moves passed the position of the leftmost remaining candy initially the position of the rightmost remaining candy initially the sum of candies eaten by Alice initially the sum of candied eaten by Bob initially the sum of candies eaten by Alice during her last move initially and the sum of candies eaten by Bob during his last move initially So let s just simulate the following process while if the number of moves is even then now is Alice s move and we need to maintain the sum of candies Alice eats during this move How to calculate it While and let s eat the leftmost candy so variables will change like this After all let s add to replace with assign and increase by If the number of moves is odd then the process is the same but from the Bob s side I ll also add a simply implemented solution written by Gassa below ,Let imagine our shelf as an infinite array Let s carry the rightmost free position from the left of our shelf let it be and initially it equals to and the leftmost free position from the right of our shelf let it be and initially it equals to Also let s carry the array of length where will be equal to the position in our imaginary array of the book with a number Let s put the first book to the position Also let s save that where is the number of the first book equals to How will change and will become and will become Now let s process queries one by one If now we have the query of type with a book with a number then let s set and set The query of type can be processed similarly Now what about queries of type The answer to this query equals to where is the absolute value of 
916,You are given an multiplication table and a positive integer A multiplication table is a table with rows and columns numbered from to where For each divisor of check does occur in the table at least once and if it does what is the row that contains ,Firstly let s factorize Since we can factorize and separately and then unite divisors For example use can get canonical representations of and to get canonical representation of and then use it to generate all divisors of Let s estimate the number of divisors It s convenient for our purposes to estimate it as More precisely there are at most divisors for search Highly Composite Numbers for more info How to calculate the answer for each divisor There are two ways for each we are searching for the minimum that and Since is fixed the minimum means the maximum So let s find instead In other words for each we need to find the maximum such that divides and We can do it efficiently with on divisors Let be the maximum that is a divisor of and If then obviously Otherwise we know that we are searching Let say that are the prime divisors of the initial number Since is a divisor of and then exists some among the set of prime divisors such that is a divisor of as well So instead of brute search it s enough to take a value In other words if we can calculate Ok now we know value for each divisor Since we found the maximum the last step is to calculate the desired and if we found the answer otherwise it means that is not presented table and The total complexity is per test where is the number of divisors of and is the number of prime divisor of Note that complexity is quite high so you should write it at least a little accurate for example store in an array not map and search position of with There is also a way to get rid of extra factor if you iterate through is a smart way faster easier unproven Let s generate a list of all divisors of as in the increasing order For some divisor we are searching the minimum that is a divisor of and It means that So let s just find the first position such that with and start iterating from onward searching the first that is a divisor of The found would be the minimum we need It looks like in average we will find the correct quite fast or we ll break when ,Let the month the days in them and the days of the week be numbered based Translate the th day of the th month to the index of that day in a year that would be Thus the corresponding day of the week is So we can rewrite the condition for a pair as That s also Continue with So should be divisible by is fixed and some prime divisors of might have appeared in it already If we remove them from then should just be divisible by the resulting number So we can divide by and obtain that Now we should just count the number of pairs such that is divisible by We know that the difference should be from to So we can fix the difference and add the number of pairs for that difference That would be for a difference Finally the answer is Use the formula for the sum of arithmetic progression to solve that in Overall complexity per testcase 
917,Berland State University has received a new update for the operating system Initially it is installed only on the st computer Update files should be copied to all computers The computers are not connected to the internet so the only way to transfer update files from one computer to another is to copy them using a patch cable a cable connecting two computers directly Only one patch cable can be connected to a computer at a time Thus from any computer where the update files are installed they can be copied to some other computer in exactly one hour Your task is to find the minimum number of hours required to copy the update files to all computers if there are only patch cables in Berland State University ,Let be the current number of computers with the update already installed initially it is Then in hour we can increase by From here we can see that the value of will double for the first few hours and then when it becomes greater than it will begin to increase by exactly The process when the number of computers doubles can be modeled using a loop because the number of doublings does not exceed And after that we have to increase the answer by to take the number of additions of into account Note that computing should be done without using fractional data types to calculate in integers you should divide by using integer division this will work provided that both and are non negative and If you use real numbers this may cause precision issues ,To begin with we will learn how to find the optimal place for the exam that we want to move Let s imagine that it is not in the schedule in this case we have two options Put the exam at the end of the session so that there are days before it Put it in the middle of the largest break between exams let its length be so that between it and the nearest one there is because this is no worse than putting it in any part of any other break That is the answer for such an arrangement is the minimum of the larger of these options and the minimum break in schedule without the moved exam Now note that the minimum break in most variants is the same minimum in the initial schedule So in order to reduce you need to move exactly one of the two exams that form it and you need to check which of the two options is better 
918,Monocarp is playing a computer game once again He is a wizard apprentice who only knows a single spell Luckily this spell can damage the monsters The level he s currently on contains monsters The th of them appears seconds after the start of the level and has health points As an additional constraint for all All are different Monocarp can cast the spell at moments which are positive integer amounts of second after the start of the level The damage of the spell is calculated as follows If he didn t cast the spell at the previous second the damage is Otherwise let the damage at the previous second be Then he can choose the damage to be either or A spell uses mana casting a spell with damage uses mana Mana doesn t regenerate To kill the th monster Monocarp has to cast a spell with damage at least at the exact moment the monster appears which is Note that Monocarp can cast the spell even when there is no monster at the current second The mana amount required to cast the spells is the sum of mana usages for all cast spells Calculate the least amount of mana required for Monocarp to kill all monsters It can be shown that it s always possible to kill all monsters under the constraints of the problem ,Consider the problem with There is a single monster with some health that appears at some second In order to kill it we have to wind up our spell until it has damage So we have to use it from second to second Look at it as a segment on a timeline Actually to avoid handling zero length segments let s instead say that a segment covers the time from non inclusive to inclusive producing a half interval This way the total mana cost will be where is the length of the half interval Now There are two time segments If they don t intersect segments and don t intersect since they are half intervals then it s always better to wind up the spell for the monsters separately instead of saving the damage However if they intersect then we don t have the choice other than to save the damage from the earlier one to the later one Otherwise there won t be enough time to wind up the spell What that means in a mathematic sense The answer is the union of two half intervals If they don t intersect they are left as is Otherwise they become one half interval that covers them both Now add the third monster into the construction The same argument applies While there exists a pair of intersecting half intervals keep uniting them The union of all half intervals can be found in but the constraints allowed slower approaches as well ,First of all let s find a solution in We will use the lineriality of expectation the answer for some shield is equal to where is the probability that the monster will deal damage if we use the th shield Let s see how to calculate Consider a monster such that To deal damage he should be preceded by at least other monsters having We can write a complicated formula with binomial coefficients to calculate the probability of this happening and then simplify it but a much easier solution is to consider the order of these strong monsters Suppose there are of them then there are strong monsters that will deal damage Since all orderings are equiprobable the probability that our fixed monster will deal damage is since it is the probability that it will take one of the last places in the order Okay what about weak monsters It turns out that we can use the same approach to deal damage a weak monster should be preceded by at least strong monsters Consider the relative order of strong monsters and that weak monster we are analyzing There are positions where the weak monster will deal damage so the probability of weak monster dealing damage is Okay we got a solution in How to make it faster Whenever we consider a shield all monsters are split into two types strong and weak and we may sort the monsters beforehand so the number of strong monsters and their total strength can be found with binary search Since the probabilities for all strong monsters are the same we can multiply their total strength by the probability that one fixed strong monster will deal damage we already described how to calculate it The same applies for the weak monsters so the total complexity is 
919,There is a string of length consisting of uppercase and lowercase English letters Check if it is equal to without quotes where each letter can be in any case For example are all allowable ,You should implement what is written in the statement Here are three ways to do it Check that the first character is or check that the second character is or and check the third character is or Make an array storing all acceptable strings there are only and loop and see if any of the strings match the input Use some built in function like in C to make the string all lowercase and check if is equal to The complexity is per test case ,Consider case separately and print the sting of zeros or ones correspondingly Now our string has at least one pair or Let s form the pattern of length So all substrings with the sum are satisfied Now let s insert zeros before the first zero in this way we satisfy the substrings with the sum And then just insert ones before the first one in this way we satisfy the substrings with the sum 
920,A big football championship will occur soon teams will compete in it and each pair of teams will play exactly one game against each other There are two possible outcomes of a game the game may result in a tie then both teams get point one team might win in a game then the winning team gets points and the losing team gets points The score of a team is the number of points it gained during all games that it played You are interested in a hypothetical situation when all teams get the same score at the end of the championship A simple example of that situation is when all games result in ties but you want to minimize the number of ties as well Your task is to describe a situation choose the result of each game so that all teams get the same score and the number of ties is the minimum possible ,If is odd then we can solve the problem without any ties each team should win exactly matches and lose the same number of matches Finding which matches each team wins and which matches each team loses can be done with some graph algorithms like Eulerian cycles or circulations or with a simple construction place all teams in a circle in any order and let the th team win against the next teams after it in the circle and lose to all other teams Unfortunately if is even we need to use some ties since the total sum of scores over all teams is exactly when there are no ties and this number is not divisible by when is even Each tie reduces the total sum by and the minimum number of ties to make divisible by is since So if we find an answer with exactly ties it is optimal And it s easy to find one once again place all teams in a circle in any order make the th team win against next teams in the circle lose against previous teams in the circle and tie with the opposite team in the circle ,Let s solve the problem by dynamic programming Let be the probability of winning if the last taken card has number on it and the number of taken cards is We win immediately next turn if we take card with number on it The probability of this is where is number of cards with Also we can win if we take a greater card next turn We take a card with number with probability with number with probability and so on The probability of winning in this case will be and respectively So the probability of winning for is Therefore all we need is to maintain the sum while calculating our dynamic programming 
921, robots have escaped from your laboratory You have to find them as soon as possible because these robots are experimental and their behavior is not tested yet so they may be really dangerous Fortunately even though your robots have escaped you still have some control over them First of all you know the location of each robot the world you live in can be modeled as an infinite coordinate plane and the th robot is currently located at the point having coordinates Furthermore you may send exactly one command to all of the robots The command should contain two integer numbers and and when each robot receives this command it starts moving towards the point having coordinates The robot stops its movement in two cases either it reaches or it cannot get any closer to Normally all robots should be able to get from any point of the coordinate plane to any other point Each robot usually can perform four actions to move Let s denote the current coordinates of the robot as Then the movement system allows it to move to any of the four adjacent points the first action allows it to move from to the second action allows it to move from to the third action allows it to move from to the fourth action allows it to move from to Unfortunately it seems that some movement systems of some robots are malfunctioning For each robot you know which actions it can perform and which it cannot perform You want to send a command so all robots gather at the same point To do so you have to choose a pair of integer numbers and so that each robot can reach the point Is it possible to find such a point ,In fact we have some restrictions on axis and axis for example if some robot stays at the position and cannot move to the left then the answer point should have So we can take the minimum among all coordinates of robots that cannot go up and save it into maximum among all coordinates of robots that cannot go down and save it into minimum among all coordinates of robots that cannot go right and save it into and maximum among all coordinates of robots that cannot go right and save it into Initially So these restrictions are describe some rectangle possibly incorrect with or Let be the bottom left point of this rectangle and be the top right point of this rectangle In case if this rectangle have or the answer is Otherwise this rectangle describes all integer points which can be reachable all robots and you can print any of them ,It is easy to see that the area of the plot is the sum of areas of all triangles in this plot Each move increases area by one We cannot obtain the answer less than but we always can obtain such an answer 
922,Initially you have the array consisting of one element In one move you can do one of the following things Increase some element of by choose some from to the current length of and increase by one Append the copy of some element of to the end of the array choose some from to the current length of and append to the end of the array For example consider the sequence of five moves You take the first element append its copy to the end of the array and get You take the first element increase it by and get You take the second element append its copy to the end of the array and get You take the first element append its copy to the end of the array and get You take the fourth element increase it by and get Your task is to find the number of moves required to obtain the array with the sum at least You have to answer independent test cases ,It is pretty intuitive that we firstly need to do all increments and only then copy numbers because otherwise we can swap the order of moves and the sum will not decrease You could notice that the answer does not exceed so we can just iterate from to and fix the number we will copy Let it be Then we need moves to obtain it and also need moves to get the enough number of copies So we can update the answer with this number of moves Time complexity per test case Actually the required number is always pretty near to so it is enough to try a few options in range to get the optimal answer This is solution ,It is easy to see that the area of the plot is the sum of areas of all triangles in this plot Each move increases area by one We cannot obtain the answer less than but we always can obtain such an answer 
923,The campus has rooms numbered from to Also the mouse lives in the campus The mouse is not just a mouse each second mouse moves from room to the room in fact it teleports from one room to another since it doesn t visit any intermediate room Starting position of the mouse is unknown You are responsible to catch the mouse in the campus so you are guessing about minimum possible number of traps one trap in one room you need to place You are sure that if the mouse enters a trapped room it immediately gets caught And the only observation you made is ,Some notes At first there is since lets define as That means that for each there is exactly one that So if we look at this problem as the graph then it consists of cycles consider loops as cycles of length one So we need to know number of cycles in this graph At second since and and So all can be divided in groups by its And we can calculate number of cylces in each group independently Let fix some equal to All numbers such that can be represented as and Number of such equals to Moreover Here we can shift from and to and In result we need for each calculate number of cycles created by from numbers that and Lets set Next step is to find minimal such that let s name it order of or Then for each if then and so each cycle will have length equal to and number of cycles will be equal to Last step is calculate for each There is a fact that so can try to iterate over all divisors of and check by binary exponentiation It seems as but it s faster and author s version work around 2 seconds It doesn t pass but somebody can write better But we ll speed it up Let So we can independently for each find its minimal power such that We can just iterate over all and since Some words about finding its factorization differs from factorization of just by lowering degrees of primes and adding factorizations of some But we can manually find factorization of with memorization or even without it since So our steps are next factorize recursively iterate over all divisors of find and and add to the answer Result complexity is And the last note is how to multiply modulo You can use binary multiplification which will give you extra what is not critically in this task in C of course Or you can use multiplification from hashes which will work with 64 bit double since it s only ,A good start to solve the problem would be to check the answers for small values of One can see that the answers the sizes of the maximum subsets are not much different from itself or rather not less than Let s try to prove that this is true for all Consider is even Let let s see what the product is equal to if we take all the numbers from to From here we can see that for even the answer is at least because we can delete and the product of the remaining factorials will be the square of an integer for odd the answer is at least because we can delete and It remains to prove that the answer is at least for odd This is easy to do because the answer for is not less than the answer for minus because we can delete and solve the task with a smaller value Moreover it can be seen from the previous arguments that the answer can only be for and we already know that in this case one of the correct answers is to remove the factorials It remains to learn how to check whether it is possible to remove or numbers so that the remaining product of factorials is the square of an integer To do this we can use XOR hashes Let s assign each prime number a random bit number For composite numbers the hash is equal to the XOR of hashes of all its prime divisors from factorization Thus if some prime is included in the number an even number of times it will not affect the value of the hash which is what we need The hash of the product of two numbers is equal to the XOR of the hashes of these numbers Let s denote the hash function as Using the above let s calculate for all from to as well as for all from to this is easy to do because We will also store a map Let s calculate the hash and denote it as It remains to consider the following cases if then the current product is already the square of an integer for an answer of size we have to check that there exists such a that To find such let s check whether the map contains for an answer of size we have to check that there are such and that To do this iterate over and then check whether map contains otherwise the answer is and there is an answer where all numbers except are taken 
924,So we got bored and decided to take our own guess at how would Inception production go if the budget for the film had been terribly low The first scene we remembered was the one that features the whole city bending onto itself It feels like it will require high CGI expenses doesn t it Luckily we came up with a similar looking scene which was a tiny bit cheaper to make Firstly forget about 3D that s hard and expensive The city is now represented as a number line Secondly the city doesn t have to look natural at all There are buildings on the line Each building is a square Lower corners of building are at integer points and of the number line Also the distance between any two neighbouring buildings and doesn t exceed Distance between some neighbouring buildings and is calculated from the lower right corner of building to the lower left corner of building Finally curvature of the bend is also really hard to simulate Let the bend at some integer coordinate be performed with the following algorithm Take the ray from to and all the buildings which are on this ray and start turning the ray and the buildings counter clockwise around point At some angle some building will touch either another building or a part of the line You have to stop bending there The only thing left is to decide what integer point is the best to start bending around Fortunately we ve already chosen candidates to perform the bending So can you please help us to calculate terminal angle for each bend from our list of candidates ,Let s solve the problem for a single query at first There are two possible types of collisions between two buildings and between a building and a ray Obviously if the collision of the second type happens then it s the building which is the closest to the bend point from either left or right The less obvious claim is that among all buildings collisions the closest is the biggest angle one Let s boil down some possibilities of colliding buildings Let two buildings be the same distance from the bend point Then they will collide and the collision point will Two buildings also collide if the left one is from and the right one is Then the point of collision is And for the opposite case the point of collision is also These points can be easily proven by checking the distances to upper corners of each building No other two buildings will collide Now that we know this we can transition to solving a problem of checking if there exists such a pair that the distances to from them differ by at most one Finding such a pair with minimal is enough Obviously this can be done with some sort of two pointers However that s not the intended solution Let s constuct bitset of 7000 positions to the left of the bend and to the right of the bend AND of these bitsets will give you the pairs such that the distance is the same for them However you can put 1 in points and for each building to the left and and for each building to the right This way AND will give you the exact pairs you need Use Find first to find the closest one Let collision happen on distance Then the collision of the first type will have angle and the collision of the second type will have angle The answer is the maximum of these two values Be careful with cases where How to process lots of queries Let s just move the bitsets to the right while going through queries in ascending order Bitsets can be updated in for each query and only buildings will be added to them in total Overall complexity ,Let s process all the segments on the line from left to right For each segment we should push events and into some array Sort this array of pair in increasing order usual less comparator for pairs Then we iterate over its elements and maintain the current amount of open segments we passed their left border and didn t pass their right border When we meet the event of the first type we increment the value of the second type decrement If in some moment then the answer is Overall complexity 
925,You have an initially empty cauldron and you want to brew a potion in it The potion consists of two ingredients magic essence and water The potion you want to brew should contain exactly magic essence and water In one step you can pour either one liter of magic essence or one liter of water into the cauldron What is the minimum number of steps to brew a potion You don t care about the total volume of the potion only about the ratio between magic essence and water in it A small reminder if you pour liters of essence and liters of water into the cauldron then it contains without rounding magic essence and water ,Since you need liters of essence to be exactly of potion then we can write an equality or and for some integer Since we need to minimize and then we should maximize but both and should be divisible by In other words taking as Greatest Common Divisor of and is optimal As a result ,First iterate on the number of swords we will personally take Then we should greedily take as many war axes as we can until we run out of money At this point our follower needs to take as many items as possible They can do this by greedily taking whichever of swords or war axes are cheaper until they run out followed by taking the more expensive of the two Code 90918673 
926,Timur has a stairway with steps The th step is meters higher than its predecessor The first step is meters higher than the ground and the ground starts at meters Timur has questions each denoted by an integer For each question you have to print the maximum possible height Timur can achieve by climbing the steps if his legs are of length Timur can only climb the th step if his legs are of length at least In other words for each step climbed Note that you should answer each question independently ,Let s compute the prefix sums of the array let Rephrasing the problem for each question containing an integer we need to find the largest such that are all at most and then output In other words Let s make the prefix maximums of the array let Then we need to find the largest such that which is doable using binary search since the array is non decreasing Once we find the index we simply need to output The time complexity is per testcase ,The problem can be solved using closed formula it s need to calculate the sum of geometric progression The formula can be calculated using binary exponentiation I ll describe more complicated solution but it s more general If we have a set of variables and at each step all variables are recalculating from each other using linear function we can use binary matrix exponentiation There is only one variable in our problem The new variable is calculating using formula Consider the matrix and the vector Let s multiply and Easy to see that we will get the vector So to make iterations we should multiply and times We can do that using binary matrix exponentiation because matrix multiplication is associative As an exercise try to write down the matrix for the Fibonacci numbers and calculate the th Fibonacci number in time The matrix and the vector is under the spoiler 
927,You are given two lists of segments and Initially all segments are equal to and all segments are equal to In one step you can choose one segment either from the first or from the second list and extend it by In other words suppose you ve chosen segment then you can transform it either into or into Let s define a total intersection as the sum of lengths of intersections of the corresponding pairs of segments i e Empty intersection has length and length of a segment is equal to What is the minimum number of steps you need to make greater or equal to ,At first note that of segments and can be calculated as If it s negative then segments don t intersect otherwise it s exactly length of intersection Now we have two major cases do segments and already intersect or not If segments intersect then we already have as the total intersection Note that making both segments equal to in each pair are always optimal since in each step we will increase the total intersection by After making all segments equal to we can increase total intersection by only in two steps we need to extend both segments in one pair In result we can find not a hard formula to calculate the minimum number of steps we already have of the total intersection then we can increase it by at most using one step per increase and then to any number using two steps per increase In the case of non intersecting and we should at first invest some number of steps in each pair to make them intersect So let s iterate over the number of segments to invest We should make steps to make segments touch Now segments touch so we can use almost the same formulas for them as in the previous case The total complexity is per test case ,Let be true if it s possible to have a collision before time That function is monotonous thus let s binary search for For some fixed car can end up in any point from to units along the ray That makes it a segment So the collision can happen if some pair of segments intersects Let s learn how to find that out The general idea is to use sweep line So let s add the events that the th segment such that opens at and closes at There were no vertical segments so and are always different At every moment of time we want to maintain the segments ordered by their intersection with the line Note that if two segments change their order moving along the sweep line then they intersect So we can maintain a set with a custom comparator that returns if one segment intersects the current line lower than the other one When adding a segment to set you want to check it s intersections with the next segment in the order and the previous one When removing a segment you want to check the intersection between the next and the previous segment in the order If any check triggers then return true immediately It s easy to show that if the intersection happens between some pair of segments then the intersection between only these pairs of segment also happens Now for the implementation details Precision errors play a huge role here since we use binary search and also store some stuff dependant on floats in the set The solution I want to tell requires no epsilon comparisons thus it calculates the answer only with the precision of binary search So the first issue rises when we have to erase elements from the set Notice that we can make a mistake when we are adding the segment and there is a segment with almost the same intersection point That will not make the answer incorrect that s not trivial to show but it s possible if you consider some cases If you can find it later to remove then it s not an issue at all However that will probably mess up the lower bound in the set Thus let s save the pointer to each element in the set and remove it later by that pointer The second issue comes when you have to check the intersection of two segments The error might appear when one segment let the first point be the original and the second point be calculated depending on has it s intersection point with segment at exactly So the slightest miscalculations could matter a lot Let s learn to intersect in such a way that no epsilon comparisons are required Firstly we can store lines in the set instead of segments Second we can check the intersection of rays first and only then proceed to check the intersection of segments So two rays intersect if their lines intersect easy to check in integers the intersection point lies in the correct direction of both rays the intersection point is always a pair of fractions and you want to compare the signs of and Finally if all the checks hold then you can compare maximum of distances from and to the intersection point and If is greater or equal then they intersect in time There is no way to make that comparison in integers However it s precision only depends on the precision of as in the error here can t affect the answer greatly Overall complexity 
928, Vlad found a row of tiles and the integer The tiles are indexed from left to right and the th tile has the color After a little thought he decided what to do with it You can start from any tile and jump to any number of tiles forming the path Let s call the path of length if can be divided into blocks of length exactly that is is divisible by Your task is to find the number of paths of length Since this number may be too large print it modulo ,To solve the hard version let s modify the simple version solution Note that the parameter can be discarded since we only need paths of maximum length on each prefix Now as we denote a pair of the number of maximum paths and the number of blocks in them For the position we will find the position closest to the left from which we can start a block and so we will find out what is the maximum for We will update until the maximum of the position being sorted is suitable for us ,If is even then each hour A and B are on the spots with different parity so they will never meet Otherwise let s look closely what happens At the start A in and B in But since we can form a cycle from spots then it means that and in reality are neighbors After that A and B starting from neighboring positions just go in opposite directions and meet each other in the opposite spot after exactly steps After meeting B jumps over A making extra step and the situation become practically the same A and B are neighbors and move in the opposite direction In other words each steps B makes one extra step so the answer if both and spots are indexed is 
929,Recently Polycarp completed successive tasks For each completed task the time is known when it was given no two tasks were given at the same time Also given is the time when the task was completed For each task there is an unknown value It is known that the tasks were completed in the order in which they came Polycarp performed the tasks as follows As soon as the very first task came Polycarp immediately began to carry it out If a new task arrived before Polycarp finished the previous one he put the new task at the end of the queue When Polycarp finished executing the next task and the queue was not empty he took a new task from the head of the queue if the queue is empty he just waited for the next task Find duration of each task ,Accordingly as it was said in the task we put all tasks into the queue in the order of their arrival then we fix the time at the beginning as So while there is a task in the queue we proceed as follows Take the task from the queue Take as time the maximum from the current and from the arrival time of the task We subtract the current time from the time when the task was done Replace the current time with the time the task was done If there is a task in the queue go to item ,For this problem you just need to implement what it asks you To be able to implement it you need to know about the if statement 
930,You are given two arrays and both of length Let s define a function Your task is to reorder the elements choose an arbitrary order of elements of the array to minimize the value of Since the answer can be very large you have to print it modulo Note that you should ,Let s use technique to solve this problem How many times the value will occur in the answer It will occur times Okay now we can see that for each position we have the value The only non constant value there is So let We should pair the minimum with the maximum the second minimum with the second maximum and so on So let s sort the array and the array reverse the array and calculate the sum of values don t forget about modulo here ,For each from to find all elements of the array that are congruent to modulo and store their indices in a list Also create a vector called and let be We have to cycle from to twice For each from to if there are in list too many i e elements congruent to modulo remove the extra elements from this list and add them to If instead there are too few i e elements congruent to modulo remove the last few elements from the vector For every removed index increase by After doing so after two passes we print the total increase and the updated array It is obvious that after the first iterations every list will have size at most and after more iterations all lists will have the same sizes It can be easily proved that this algorithm produces an optimal answer The time complexity is 
931,Polycarp found segments on the street A segment with the index is described by two integers and coordinates of the beginning and end of the segment respectively Polycarp realized that he didn t need all the segments so he wanted to delete some of them Polycarp believes that a set of segments is good if there is a segment from the set such that it intersects every segment from the set the intersection must be a For example a set of segments is good since the segment intersects each segment from the set Set of segments is not good Polycarp wonders what is the minimum number of segments he has to delete so that the remaining segments form a good set ,As we know from the problem statement Polycarp believes that a set of k segments is good if there is a segment l i r i 1 leq i leq k from the set such that it intersects every segment from the set the intersection must be a Let s iterate over this segment which intersects all the others and construct a good set of the remaining segments maximum in terms of inclusion It is easy to understand that this set will include all segments that intersect with ours We must delete all other segments Two segments l 1 r 1 and l 2 r 2 intersect if max l 1 l 2 le min r 1 r 2 Then if the segment that we iterate over has coordinates L R then we must remove all such segments l r for which r L or R l is satisfied that is the segment ends earlier than ours begins or vice versa Note that these two conditions cannot be fulfilled simultaneously since l le r and if both conditions are satisfied then r L le R l This means that we can count the number of segments suitable for these conditions independently Each of these conditions is easy to handle Let s create two arrays all the left boundaries of the segments and all the right boundaries of the segments Let s sort both arrays Now we can count the required quantities using the binary search or prefix sums but in this case we need to use the coordinate compression technique Taking at least the number of deleted segments among all the options we will get the answer to the problem ,The main idea of the solution is to calculate the following dynamic programming is the maximum prefix we can fully cover with first lanterns Let s look at how can we solve it in with this kind of dynamic programming First of all let s write it forward Which transitions from do we have iterate on the lantern facing left that will cover the lantern Let this lantern be It should cover all lanterns in so all lanterns from can be turned to the right and we need a max query to determine the new covered prefix if lantern is already covered we can just extend the prefix by turning the th lantern to the right Note that turning it to the right when it is not covered yet will be modeled by the first transition It is obviously how can we optimize it Let s write this dynamic programming backward The second transition is changed to backward dp easily what about the first one Suppose we want to turn some lantern to the left Let s iterate on the prefix that we will connect to it for this prefix should be at least and we update with the maximum of since it is covered by lantern and the result of max query on In fact we need only one such prefix the one with the minimum among those which have So we build a minimum segment tree where each pair is interpreted as the value of in position and with min query on the suffix from we find this optimal prefix from which we should update and to update we can use any DS that allows max queries on segment in my solution it s another segment tree 
932,You are given an array consisting of integers The array is sorted if You want to make the array sorted by applying the following operation choose an integer then for every replace by Find any value of that will make the array sorted or report that there is no such value ,What does it actually mean for an array to be sorted That means and and so on For each pair of adajacent elements let s deduce which values put them in the correct order Any value of that puts all pairs in the correct order will be the answer Consider any and and solve the inequality If then any value of works Let be smaller than If is smaller than or equal to then the inequality becomes Thus they don t change their order and any works If is greater than or equal to then the inequality becomes Thus they always change their order and none of work If is between and then the inequality becomes Thus they only remain in the same order for any integer such that In union that tells us that all values of that work for such a pair are The similar analysis can be applied to which results in the required being for such pairs Finally how to find out if some value of passes all conditions Among all conditions of form in order for some to work it should be less than or equal to even the smallest of them Similarly among all conditions of form in order for some to work it should be greater than or equal to even the largest of them Thus take the minimum over the pairs of one type Take the maximum over the pairs of another type If two resulting values are contradictory then there is no answer Otherwise any value inside the resulting range of works Overall complexity per testcase ,Firstly let s prove that the size of the answer is not greater than Suppose that the answer equals to Let be coordinates of the points in the answer and Let and Then because of the condition It means that Conditions must hold for a triple too Now it is easy to see that if then that is not a power of two So the size of the answer is not greater than Firstly let s check if the answer is Iterate over all middle elements of the answer and over all powers of two from to inclusively Let be the middle element of the answer and the current power of two Then if there are elements and in the array then the answer is Now check if the answer is Do the same as in the previous solution but now we have left point and right point If we did not find answer of lengths or then print any element of the array The solution above have time complexity because of we can check if the element is in the array with some data structure in 
933,You have an array Answer queries of the following form If we change all elements in the range of the array to will the sum of the entire array be odd Note that queries are and do not affect future queries ,Note that for each question the resulting array is So the sum of the elements of the new array after each question is We can compute and in time by precomputing the sum of all prefixes and suffixes or alternatively by using the prefix sums technique So we can find the sum each time in per question and just check if it s odd or not The time complexity is ,There are pretty few cases to have One of is equal to At least two of are equal to All equal It s easy to notice that having minimum of equal to produce the only case greater numbers will always miss some seconds Let s consider minimum of let it cover all odd seconds Now you should cover all even seconds and and are the only possible solutions Overall complexity 
934,You are given a rooted tree consisting of vertices Vertices are numbered from to Any vertex can be the root of a tree A is a connected undirected graph without cycles A is a tree with a selected vertex which is called the The tree is specified by an array of ancestors containing numbers is an ancestor of the vertex with the number The of a vertex is a vertex that is the next vertex on a simple path from to the root For example on the simple path from to the root the next vertex would be so the ancestor of is The root has no ancestor so for it the value of is the root is the only vertex for which For example if and then the tree looks like this You are given an array a permutation of the vertices of the tree If it is possible assign any integer weights on the edges so that the vertices sorted by distance from the root would form the given permutation In other words for a given permutation of vertices it is necessary to choose such edge weights so that the condition is true for each from to is a sum of the weights of the edges on the path from the root to In particular if the vertex is the root of the tree For example assume that In this case the following edge weights satisfy this permutation the edge has a weight of the edge has weight of the edge has a weight of the edge has a weight of The array of distances from the root looks like The vertices sorted by increasing the distance from the root form the given permutation Print the required edge weights or determine that there is no suitable way to assign weights If there are several solutions then print any of them ,Consider the cases when it is impossible to form a given permutation 1 For root it is true that For any other vertex the value of will be positive since there is at least one edge of positive weight on the path to it 2 In a rooted tree there is exactly one path from the root to any vertex and it goes through its parent so it must always be true Let us start filling the array where Consider a vertex The vertex whose distance at the current time is maximal is Then is at least We assign a value to remembering to check that has already been counted After counting all values we can output the lengths of the edges ,Let s create two arrays of length The element of the array will contain the operation number at which the vertex which is the index of the array will be deleted The array will contain the number of neighbors of a given vertex at a certain time This array must be initialized with the number of neighbors in the original tree Initially we will suppose that the gardener performs an infinite number of operations and we will simply calculate for each vertex the number of the operation on which it will be deleted Let s create a queue which will store the order of deleting vertices The queue will contain only those vertices whose neighbors except maybe one have been removed i e Let s add all leaves of the original tree to it for each of them let s store the value in the array because all original leaves will be removed during the first operation Next we will take sequentially one vertex from the queue and update the data about its neighbors Consider the neighbors Since we are deleting the current vertex we need to update of its neighbors If the neighbor s is equal to then it s already in the queue and it doesn t need to be considered right now Otherwise we will decrease the neighbor s by If it becomes equal to then the neighbor must be added to the queue The number of the operation during which the neighbor will be deleted is equal to the number of the operation during which the current vertex will be deleted plus After we calculate the numbers of operations for all vertices we need to select among them those that will not be deleted during operations with numbers Thus the answer is the number of vertices such that 
935,There are towns located on a coordinate line numbered from to The th town is located at the point You build a radio tower in each of the towns with probability these events are independent After that you want to set the signal power on each tower to some integer from to signal powers are not necessarily the same but also not necessarily different The signal from a tower located in a town with signal power reaches every city such that After building the towers you want to choose signal powers in such a way that towns and don t get any signal from the radio towers towns get signal from one radio tower each For example if and you have built the towers in towns and you may set the signal power of the tower in town to and the signal power of the towers in towns and to That way towns and don t get the signal from any tower towns and get the signal from the tower in town town gets the signal from the tower in town and town gets the signal from the tower in town Calculate the probability that after building the towers you will have a way to set signal powers to meet all constraints ,The crucial observation is that when the positions of towers are fixed the way to set their signal powers is unique if it exists That s because the first tower should have its signal power exactly equal to the required to cover all towns before it the second tower should have signal power exactly equal to the required to cover all towns before it that weren t covered by the first one and so on So let s count the number of ways to cover all towns and then divide it by Covering all towns can be expressed as splitting into the sum of several positive odd integers It can be calculated with dynamic programming with prefix sums but we can also prove that the number of ways to split is exactly the th integer in the Fibonacci sequence as follows this proof uses mathematical induction for it s quite obvious for and let s iterate on the length of the last segment We have to sum and so on until we get for and let s iterate on the length of the last segment and add to result since we can cover everything with a single segment So this is and so on So the answer to the problem is The last thing we have to consider is that we have to print a fraction modulo Since is a prime using Fermat little theorem we can calculate as Exponentiation must be done with some fast algorithm for example binary exponentiation Note it s common in problems requiring to calculate something modulo some prime number to have problems with overflow in intermediate calculations or some other issues when we forget to take the result of some expression modulo I recommend using either special addition multiplication exponentiation functions that always take the result modulo an example how to write and use them can be viewed in the model solution or a special modular integer data structure with overloaded operators that you have to implement by yourself ,One way to think about this problem is in game theory terms Imagine a following game Two players alternate moves The first players chooses a direction The second player chooses a different direction and moves a robot there The game ends when the robot reaches the lab and the first player wins Otherwise it s a draw What s the outcome of the game if both players play optimally as in the first player tries to win the second player tries to draw Does it sound easier Well it sure does if you ever dealt with solving games on arbitrary graphs You can skim through this article if that s unfamiliar to you The state of the game is a pair If a direction is not chosen denote it with it s the first player s move Otherwise it s the second player s move You can even implement it as is Or you can adjust a part of this algorithm for this particular problem Initially all the states are drawing only the state is winning What we basically need is a way to determine if a state is winning or not From game theory we can tell that the state is winning if there s a transition from it to a losing state The state is losing if all the transitions from it lead to winning states So is winning if any of are losing Promote that one step further The state is winning if there exists such a direction that all neighbouring free cells except in this direction are winning states Rephrase it The state is winning if it has at least one winning state neighbour and no more than one non winning state neighbour Let s store the number of non winning neighbouring states for each cell Initially it s the number of neighbouring free cells If some state becomes marked as winning decrease the value for each of its neighbours by If some state s value reaches or after this operation mark it as winning Since what this does is basically a traversal of a grid this can be done with a DFS BFS starting from the lab Overall complexity per testcase 
936,Luba has to do chores today th chore takes units of time to complete It is guaranteed that for every the condition is met so the sequence is sorted Also Luba can work really hard on some chores She can choose not more than any chores and do each of them in units of time instead of Luba is very responsible so she has to do all chores and now she wants to know the minimum time she needs to do everything Luba cannot do two chores simultaneously ,Since it is better to do exactly chores in time And since we need to minimize total time we need to spend it s better to speed up the longest chores So the answer is ,Let s keep an array of booleans denoting whether or not some team has solved the th problem already Now we can iterate through the string from left to right and keep a running total If is true the th problem has already been solved increase by otherwise increase by and set to true The time complexity is Bonus the answer is always Can you see why 
937,Initially array contains just the number You can perform several operations in order to change the array In an operation you can select some subsequence of and add into an element equal to the sum of all elements of the subsequence You are given a final array Check if can be obtained from the initial array by performing some number possibly 0 of operations on the initial array A sequence is a subsequence of a sequence if can be obtained from by the deletion of several possibly zero but not all elements In other words select distinct indices and insert anywhere into a new element with the value equal to ,Firstly let s note that it doesn t matter in what order we add the elements to the array since if we can add an element in any position if it s possible to get the said elements of the array then we can obtain them in any order Now let s note that it s always optimal to obtain the needed elements in sorted order since we only use smaller values in order to obtain the current one so we will consider the array as sorted If the first element of the array isn t then we immediately know such an array doesn t exist Otherwise we can use dynamic programming for finding out if the remaining elements are obtainable Let s denote a boolean array which tells us whether sum is obtainable Initially since the first element is guaranteed to be We will go in increasing order of and if we calculated an element to be obtainable in the past we update all obtainable values with the new value We do this in by going through all sums and updating is true if it already was true or if was true and we add to that sum the new value The total time complexity of this solution is ,In fact to carry out only one reform is always enough And it s easy to prove if you make only one reform it s always optimal to take the maximum such that the average of maximums in the array is at least i e sum greater or equal to So the solution is next sort array and find the suffix with maximum length such that the sum on the suffix is at least To prove the fact about one reform we can prove another fact after each reform the sum of maximums doesn t increase for each We ll prove it in two steps The first step Let s look at some reform and form an array from the chosen elements in in descending order After the reform we ll get array where all Let s just skip the proof and say it s obvious enough that for any The second step Let fix and divide array on two parts maximums as and other elements as And let s make the same division of the array after performing the reform on and So we need to prove that Suppose elements were chosen in the reform of them were in and now in If then we can think like maximum elements from elements in were replaced by the average and other were replaced by elements from Since and any element from is greater or equal to any element from then we proved that when If then let s look at and The has chosen elements and has so and we can prove that practically in the same way as before Obviously if and then Q E D The last step is easy let s prove that the only reform is enough The answer after several reforms is clearly equal to maximums which are at least But it means that the sum of maximums is at least therefore the sum of maximums in the initial array is at least So we can make them all at least by only one reform 
938,You are given two positive integer numbers and An array is called an of iff the following conditions are met There are elements in and all of them are integer numbers You have to count the number of pairwise distinct arrays that are factorizations of Two arrays and are considered different iff there exists at least one index such that Since the answer can be very large print it modulo ,Fill the array with ones Now we should take every prime divisor of and distribute maximum power of this prime to appear in of it into some cells of the array It is pretty well known problem it s equal to Take product of this values for every prime This will be the answer if there were no negative numbers But we should also multiply it by number of ways to select even number of position to put unary minuses like you can fill in position anyhow and the final one will be determined by parity of current count To process many queries you should factorize numbers in by precalcing the smallest prime divisor of every number up to with sieve of Eratosthenes get in by precalcing factorials and inverse factorials and get in binary exponentiation Overall complexity ,The first solution take modulo and solve the problem manually then for cases and the answer is and for and the answer is Prove Let s see what can we make for numbers and We can add and in and add and in Then the difference between sums will be We can consider last four numbers this way until we have at least four numbers And then we have a case We can prove the solution for these four cases using bruteforce The second solution if is even then the answer is otherwise the answer is The formula above is just Prove if we have an integer sequence then we can obtain every number from to as the sum of some elements of this sequence How Greedily You can see how this greedy works and prove if you want yourself So what s next If is even then we can obtain the sum in and in Otherwise we can only obtain in and in or vice versa 
939, Polycarp has to write a coursework The coursework consists of pages Polycarp also has cups of coffee The coffee in the th cup has caffeine in it Polycarp can drink some cups of coffee each one no more than once He can drink cups in Polycarp drinks each cup and i e he cannot split any cup into several days Surely courseworks are not usually being written in a single day in a perfect world of Berland at least Some of them require multiple days of hard work Let s consider some day of Polycarp s work Consider Polycarp drinks cups of coffee during this day and caffeine dosages of cups Polycarp drink during this day are Then the first cup he drinks gives him energy to write pages of coursework the second cup gives him energy to write pages the third cup gives him energy to write pages the th cup gives him energy to write pages If Polycarp doesn t drink coffee during some day he cannot write coursework at all that day Polycarp has to finish his coursework as soon as possible spend the minimum number of days to do it Your task is to find out this number of days or say that it is impossible ,Since the number of days doesn t exceed let s iterate over this value from to So now we have to check somehow if the current number of days is enough to write a coursework Let the current number of days be The best way to distribute first cups of coffee for each day is to take maximums in the array Then we have to distribute second cups for each day Let s also take the next maximums in the remaining array and so on How do we can calculate such a thing easily Let s sort the array in the reversed order before iterating over all numbers of days then the following formula will work fine for the current number of days So if the value of the formula above is greater than or equal to then the current number of days is enough If there is no any suitable number of days the answer is ,First of all sort the fishermen so it is easier to consider them in ascending order The key observation that allows us to solve the problem is the following there will be an increasing sequence of happy fishermen and all other fishermen will be unhappy Consider the fisherman which belongs to the increasing sequence Let s analyze which fisherman will be next to it in the order It is either a fisherman that will be happy or a fisherman that will be sad In the first case the fish caught by this fisherman must have a size of at least in the second case at most The first case will be considered later For the second case if we know the number of fishermen that were already placed in the order we know that all of them except the th one belong to the sad category that is the fish of every already placed fisherman except for the th one is at least two times smaller than the fish of the th fisherman So if we have already placed fishermen the last happy fisherman was the th one and we want to place a sad fisherman then the number of ways to choose this sad fisherman is exactly where is the number of fishermen such that If we can handle the first case this observation will allow us to solve the problem with dynamic programming Let be the number of ways to choose first fishermen in the order so that the th fisherman is the last happy one The case when the next fisherman is sad can be handled with a transition to the state don t forget to multiply by the number of ways to choose the next sad fisherman as described earlier What about the case when the next fisherman is happy We should iterate on the fisherman such that and transition from to but this part works in To get an solution we have to speed it up with prefix sums or something like that 
940,Vova plays a computer game known as Mages and Monsters Vova s character is a mage Though as he has just started his character knows no spells Vova s character can learn new spells during the game Every spell is characterized by two values and damage per second and mana cost per second respectively Vova doesn t have to use a spell for an integer amount of seconds More formally if he uses a spell with damage and mana cost for seconds then he will deal damage and spend mana no rounding If there is no mana left mana amount is set in the start of the game and it remains the same at the beginning of every fight then character won t be able to use any spells It is prohibited to use multiple spells simultaneously Also Vova can fight monsters Every monster is characterized by two values and monster kills Vova s character in seconds and has health points Mana refills after every fight or Vova s character revives with full mana reserve so previous fights have no influence on further ones Vova s character kills a monster if he deals damage to it in no more than seconds using his spells it is allowed to use more than one spell in a fight and spending no more mana than he had at the beginning of the fight You have to write a program which can answer two types of queries Vova s character learns new spell which deals damage per second and costs mana per second Vova fights the monster which kills his character in seconds and has health points For every query of second type you have to determine if Vova is able to win the fight with corresponding monster ,Let s represent spells as points on cartesian plane If we consider three spells and such that and is above on the cartesian plane or belongs to it then we don t need to use spell because we can replace it with a linear combination of spells and without any additional mana cost We can maintain the lower boundary of the convex hull of all points from type queries and the point Then to process type query we have to find the intersection of aforementioned lower boundary and the line our average damage in this fight has to be at least this value If there is no intersection then the answer is because even with infinite mana Vova s character can t deal that much damage before dying If there is an intersection we have to check that it is not higher than the line to ensure that we have enough mana to kill the monster in given time Model solution uses only integral calculations but it seems that precision is enough Time complexity ,Note that each unit of damage dealt by explosions save us from using one more basic spell In other words the more the damage from explosions the better So the answer will be equal to Note that in order to kill all remaining monsters with the last spell the array should have the following structure there is a monster we cast the spell onto it and is strictly increasing in and strictly decreasing in ignoring prefix and suffix of s Let s focus on the left part of array segment since solving the right part is exactly the same Maximizing the total damage is equivalent to maximizing the sum of right before the final spell Note that we can use the straight greedy strategy to kill the chosen monster we should use Explosion spell of power exactly it s not optimal to make it either more or less powerful After that monster will create an explosion of power If we must decrease it to exactly to continue the chain of explosions of maximum total damage If we also decrease it to exactly and so on The general formula is This series will stop either if or or there are no monsters left or we met the monster with The two first cases are easy to check in constant time so let s look at the last case Suppose that monster position is equal to then or That monster is interesting to us because after death it creates an explosion of damage that already doesn t depend on and next calculation is practically the same task what chain of explosion we can have if we start from That idea drives us to dp let be the maximum damage of chaining explosion we can deal if we start from and move to the left For simplicity let s include into that total damage Calculating is next let s find the first such that If there are no such or if that is too far from i e we will set Now we know that on interval the damage dealt is the arithmetic progression for it s for it s for it s In total And if such exists and not too far away we increase by as well The last question is finding for each the closest such that Note that if we define we need just need to find last and that s quite standard task that can be solved with stack Let s iterate over and maintain a stack of previous When we need to find for the current let s just look at the top of the stack if we found we wanted otherwise just pop it and check the new top again and so on until either we find or stack becomes empty that would mean that there are no After processing the th element push on top of the stack Why it works Consider some The element on top of the stack is firstly it s but we are talking about general case If we found what we want Otherwise but it also means that previous elements that was popped on previous iteration was greater than So is bigger than as well and there were no need to even consider them i e popping them out earlier doesn t break anything Since each element is pushed in the stack once and popped out once then the complexity is for all for to or amortized The answer for the chosen position then is where is dp we discussed above is the same dp but on reversed array and because we included into both and Both and are calculated in so the total comlpexity is 
941,Alexey recently held a programming contest for students from Berland students participated in a contest th of them solved problems Now he wants to award some contestants Alexey can award the students with diplomas of three different degrees Each student either will receive one diploma of some degree or won t receive any diplomas at all Let be the number of students that are awarded with diplomas of degree The following conditions must hold For each For any two degrees and Of course there are a lot of ways to distribute the diplomas Let be the degree of diploma th student will receive or if th student won t receive any diplomas Also for any such that let be the maximum number of problems solved by a student that receives a diploma of degree and be the minimum number of problems solved by a student that receives a diploma of degree Alexey wants to distribute the diplomas in such a way that If student solved more problems than student then he has to be awarded not worse than student it s impossible that student receives a diploma and doesn t receive any and also it s impossible that both of them receive a diploma but is maximum possible Among all ways that maximize the previous expression is maximum possible Among all ways that correspond to the two previous conditions is maximum possible where is the maximum number of problems solved by a student that doesn t receive any diploma or if each student is awarded with some diploma Help Alexey to find a way to award the contestants ,Let s consider naive solution make three loops to fix amounts of people to get dimplomas of each degree take the best Obviously sorting the scores will regroup optimal blocks for each degree in such a way that they come in segments of initial array We tried to make these solutions fail but underestimated the abilities of contestants to optimize this kind of stuff and couple of such made it to the end of contest To be honest we just need to get rid of the last loop Let be the difference between and is sorted Then let be the position of the last diploma of second degree and be the amounts of diplomas of the first ans the second degrees Thus the best position to put the separator between the third degree and no diploma is the postion with the maximum number in array over segment This are the borders of possible amount of the dimplomas of the third degree Maximum over segment can be implemented with segment tree sparse table or even naive square matrix with precalc time and memory Overall complexity ,The problem can be solved in the following dynamic programming manner Let be the smallest number of hours Ivan can spend in university in the first days while having lessons skipped To calculate it we can store minimal number of hours Ivan is required to spend in the th day so that he attends lessons Then we can iterate over all lengths from to and update with Precalc works in and dp can be processed in 
942,You are given a non degenerate triangle a non degenerate triangle is a triangle with positive area The vertices of the triangle have coordinates and You want to draw a straight line to cut the triangle into Furthermore the line you draw should be Can you draw the line to meet all the constraints Here are some suitable ways to draw the line However these ways to draw the line are not suitable the first line cuts the triangle into a triangle and a quadrangle the second line doesn t cut the triangle at all the third line is neither horizontal nor vertical ,The line we draw must go through a triangle s vertex otherwise two sides of the triangle are split and one of the resulting parts becomes a quadrilateral So we need to check if it is possible to make a horizontal or vertical cut through a vertex A horizontal cut is possible if all y coordinates are different we can draw it through a vertex with the median y coordinate a vertical cut is possible if all x coordinates are different we can draw it through a vertex with the median x coordinate So all we need to check is the following pair of conditions all x i are different all y i are different ,Notice that the square covers the point if and only if Using this fact let s reformulate the problem the following way we have to find the segment such that the sum of the segments fully covered by it is maximal Let s build a segment tree the th of its leaves stores the sum of the segments covered by the segment Initially it s built for some such that it is to the right of all segments Other nodes store the maximum in them Now let s iterate over the values of in descending order Let there be some segment starting in with the cost All the answers for won t change because they don t cover that new segment And the values on the suffix from the position will increase by The only thing left is to learn how to handle the subtraction of the length of the side That term is and the thing we are looking for is Rewrite it in form and you ll see that you can just subtract from the value of the th leaf of the segment tree at the beginning to get the correct result Surely you ll need to add that after you ask the maximum of all the segtree to obtain the answer You ll probably need to compress the coordinates leave only such positions that there is at least one or Implicit segtree might work but neither ML nor TL are not friendly to it Also be careful with the case with all points being negative 
943,Vasya is preparing a contest and now he has written a statement for an easy problem The statement is a string of length consisting of lowercase Latin latters Vasya thinks that the statement can be considered hard if it contains a subsequence otherwise the statement is easy For example can be considered hard statements while and are easy statements Vasya doesn t want the statement to be hard He may remove some characters from the statement in order to make it easy But of course some parts of the statement can be crucial to understanding Initially the of the statement is and removing th character increases the by the index of each character is considered as it was in the original statement so for example if you delete character from and then character the index of is still even though you delete it from the string Vasya wants to calculate the minimum of the statement if he removes some characters possibly zero so that the statement is easy Help him to do it Recall that subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements ,Denote string as We will solve this problem with dynamic programming Denote the minimum possible ambiguity if we considered first letters of statement and got prefix having length as a subsequence of the string If th letter of the statement is not equal to then we don t have to change it Otherwise we either change the letter or let it stay as it is and the length of the prefix we found so far increases ,We set up a DP on start index end index number of consecutive digits matching our start index In other words the current string we are solving is the substring from start index to end index plus some number of additional digits all equal to S start added as a prefix to our substring We then have two choices from any given state Cash in on our consecutive digits at the start and recurse on Pick an index such that S start S i and collapse everything between those two indices in order to merge them together for an even larger prefix This results in a score of and we can loop over all to take the maximum The runtime is with a very good constant factor Code 49036191 Does anybody have 
944,Polycarp plays Game 23 Initially he has a number and his goal is to transform it to In one move he can multiply by or multiply by He can perform any number of moves Print the number of moves needed to transform to Print if it is impossible to do so It is easy to prove that any way to transform to contains the same number of moves i e number of moves doesn t depend on the way of transformation ,If is not divisible by then just print and stop the program Otherwise calculate denoting the required number of times to multiply It is easy to see that should be a product of zero or more s and of zero or more s i e for integers To find just use a loop to divide by while it is divisible by Similarly to find just use a loop to divide by while it is divisible by After the divisions the expected value of is If print Otherwise print the total number of the loop iterations ,Consider n in this canonical form p 1 a 1 cdot p 2 a 2 cdot ldots cdot p k a k just find the prime factorization of n Let i be such an index that a i is the maximum among all values of a Then the answer length can not exceed a i This is because if the answer has greater length then some number doesn t have p i in its representation thus there will be problems with divisibility because we are considering primes So let s create the answer of length a i consisting of p i Then let s just multiply the last element by all other primes in their degrees So we satisfied the divisibility rule and the length of the answer is the maximum possible 
945,Four players participate in the playoff tournament The tournament is held according to the following scheme the first player will play with the second and the third player with the fourth then the winners of the pairs will play in the finals of the tournament It is known that in a match between two players the one whose skill is greater will win The skill of the th player is equal to and all skill levels are pairwise different i e there are no two identical values in the array The tournament is called if the two players with the highest skills meet in the finals Determine whether the given tournament is ,It is easier to determine the case when the players with the maximum skills will not meet in the finals It means that they met in the semifinals and in the other semifinals both players are weaker It s easy to check this case with the following formula or ,For each game we want to seat people at tables of them will be big and will sit at them and will be small Each round people will sit at the big tables Let s put people with numbers at large tables in the first round for convenience we index from zero and the rest for small ones in the second round we will seat people at large tables with numbers and so on We cycle through the players from to in blocks of Since no one person can be ahead of any other by 2 or more large tables 
946,Recently Petya walked in the forest and found a magic stick Since Petya really likes numbers the first thing he learned was spells for changing numbers So far he knows only two spells that can be applied to a integer If the chosen number is even then the spell will turn it into If the chosen number is greater than one then the spell will turn it into Note that if the number is even and greater than one then Petya can choose which spell to apply Petya now has only one number He wants to know if his favorite number can be obtained from using the spells he knows The spells can be used any number of times in any order It is not required to use spells Petya can leave as it is , cannot be transformed into any other number can be transformed into or and can be transformed only into It means that if then only is reachable and if or then should be less than Otherwise we can make as large as we want so if any is reachable ,Let s prove that if is then is too Since the sum of digits of let s call it is not greater than then and if then So if is then is This observation allows us to use binary search to find the minimum number let s call it And if then all numbers in the segment are and not greater than so the quantity of these numbers is the answer to the problem 
947,You are given a problemset consisting of problems The difficulty of the th problem is It is guaranteed that all difficulties are distinct and are given in the increasing order You have to assemble the contest which consists of some problems of the given problemset In other words There is only one condition that should be satisfied for each problem but the hardest one the problem with the maximum difficulty there should be a problem with the difficulty greater than the difficulty of this problem but not greater than twice the difficulty of this problem In other words let be the difficulties of the selected problems in increasing order Then for each from to should hold Among all contests satisfying the condition above you have to assemble one with the maximum number of problems Your task is to find this number of problems ,The answer is always a segment of the initial array The authors solution uses two pointers technique let s iterate over all left bounds of the correct contests and try to search maximum by inclusion correct contest Let s iterate over all from to and let the current left bound be Let be the maximum right bound of the correct contest starting from the position Initially Now while and let s increase Try to update the answer with the value It is obvious that all positions from to cannot be left bounds of the maximum by inclusion correct contests so let s set and go on Because each element will be processed once time complexity is ,One of the key observations to this problem is that after the first operations the first elements of the array are fixed and cannot be changed afterwards Also after the th operation the elements on positions from to are the same as they were before applying the operations This allows us to write the following dynamic programming the number of different prefixes our array can have if we have performed operations the th element is and the th element is The elements after are the same as in the original array and the elements before won t be changed anymore so we are interested only in these two elements Let s analyze the transitions in this dynamic programming We apply the operation to the elements and If we add to then we subtract it from so we transition into state Otherwise we transition into state The element we leave behind is either or and if these two transitions give us different prefixes But if we need to make only one of these transitions because adding or subtracting actually makes no difference Okay now we ve got a solution with dynamic programming in where is up to and is up to This is too slow But we can notice that the value of actually does not affect our transitions at all we can just discard it so our dynamic programming becomes which easily fits into TL Small implementation note elements can become negative and in order to store dynamic programming with negative states in an array we need to do something about that I don t recommend using maps neither ordered nor unordered you either get an extra log factor or make your solution susceptible to hacking Instead let s say that the value of where can be a negative number will be stored as in the array where is some constant which is greater than the maximum possible for example in this problem That way all array indices will be non negative Solution complexity 
948,Vasya has got an undirected graph consisting of vertices and edges This graph doesn t contain any self loops or multiple edges Self loop is an edge connecting a vertex to itself Multiple edges are a pair of edges such that they connect the same pair of vertices Since the graph is undirected the pair of edges and is considered to be multiple edges Isolated vertex of the graph is a vertex such that there is no edge connecting this vertex to any other vertex Vasya wants to know the minimum and maximum possible number of isolated vertices in an undirected graph consisting of vertices and edges ,Vasya can decrease number of isolated vertices up to using one edge and pairing them So minimum number of isolated vertices is To calculate maximum number of isolated vertices let s keep number of non isolated vertices knowing that each pair connected by edge i e size of clique Let we have size of clique and edges remained unassigned at current step If then answer is Otherwise we need to increase clique with one vertex Maximum number of edges we can add to connect this vertex is So subtract it from and increase by one Repeat this step while greater than zero Answer is One corner case is next if then answer is not ,We prove that the answer always always exists by constructing it Graph for is a single vertex Graph for is a clique of vertices Graph for some is obtained from the graph by adding vertices initially connected to nothing and vertices connected to all previously mentioned ones The vertices connected to nothing got degrees the vertices from the previous step increased their degrees by and finally there appeared vertices of degree The number is vertices is as needed 
949,You are given a rooted tree Let s denote as depth of node depth of the root is depth of any other node is where is a parent of The tree has the following property every node with has exactly children Maximum possible depth of a node is and We define as the number of unordered pairs of vertices in the tree such that the number of edges on the simple path between them is equal to Calculate modulo for every ,At first when we read the problem a simple solution comes to our mind take a look at the LCA Lowest Common Ancestor of that starting and ending vertices of the path and then use combinatorics to calculate the number of the paths but after trying to implement this or solve this on paper it doesn t seem to be easy at all and it may even be impossible to implement this So lets try to solve this problem in a different way For calculating the answer we count the number of times each path starts or ends at every vertex and then divide them by to get the answer for each vertex For calculating the answer to the above it is easy to see that all vertices with the same height have the same number of paths going through them so if we calculate the number of paths going through one of them and then multiply it by the number of the vertices in that height let it be it gets equal to our answer We can calculate the answer for a certain height So to do that we divide the paths into two types paths that go only into the subtree of a vertex let s call it and paths that go up let s call it For the ones that are in the subtree it is easy to see if there are at least other vertices that go down we can go all paths going down let the number of them be and the answer for this part equals to For the ones that go up we use dynamic programming and we define the number of paths that start at a vertex with height and have length and do not use the leftmost edge exiting the vertex at height To update this either we go down on one of the paths and then we go through a path of length or we go up and get a path of length starting at a vertex from height so the answer for this one equals to Now And the final complexity of the solution will be but because of the large constant of the solution the time limit is higher ,Consider the undirected complete graph with nodes with an edge between nodes with cost Let denote the minimum possible value of the max edge of a path from to We know that by definition If the matrix is magic we can choose arbitrary such that by repeating invocations of the inequality given Also you can show that if this inequality is satisfied then the matrix is magic by choosing an and arbitrary So this shows that the matrix is magic if and only if Thus combining with we have We need a fast way to compute for all pairs This can be computed as the MST as the path in the MST minimizes the max edge between all pairs of nodes So the algorithm works as follows First find the MST on the complete graph Then the matrix is magic if and only if the max edge on the path between in the MST is exactly equal to Also you shouldn t forget to check symmetry of the matrix and diagonal for zeros P S Unfortunately we couldn t increase the value in this problem the tests already had the size about 67MB and they couldn t be given with generator So most of the users who solved this problem uses bitset s The complexity of their solution is where or 
950,Vova plans to go to the conference by train Initially the train is at the point and the destination point of the path is the point The speed of the train is length unit per minute i e at the first minute the train is at the point at the second minute at the point and so on There are lanterns on the path They are placed at the points with coordinates divisible by i e the first lantern is at the point the second is at the point and so on There is also one standing train which occupies all the points from to inclusive Vova can see the lantern at the point if is divisible by and there is no standing train at this position Thus if the point with the lantern is one of the points covered by the standing train Vova can t see this lantern Your problem is to say the number of lanterns Vova will see during the path Vova plans to go to different conferences so you should answer queries ,What is the number of lanterns Vova will see from to This number is Now we have to subtract the number of lanters in range from this number This number equals to So the answer is ,You need to implement what is given in the statement for example you can use an if statement to output if and otherwise 
951,An is a string yes in the real world accordions are musical instruments but let s forget about it for a while which can be represented as a concatenation of an opening bracket ASCII code a colon ASCII code some possibly zero vertical line characters ASCII code another colon and a closing bracket ASCII code The length of the accordion is the number of characters in it For example and are accordions having length and are not accordions You are given a string You want to transform it into an accordion by removing some possibly zero characters from it Note that you may not insert new characters or reorder existing ones Is it possible to obtain an accordion by removing characters from and if so what is the maximum possible length of the result ,No cases No any special thoughts Just greedy The solution consists of six steps Remove the prefix of the string until the position of leftmost character If there is no such character print Remove the prefix of the string until the position of leftmost character If there is no such character print Reverse the string Remove the prefix of the string until the position of leftmost character If there is no such character print Remove the prefix of the string until the position of leftmost character If there is no such character print Print the number of characters in the remaining string plus four ,If we represent letters with digits then the answer can be represented as There is no substring containing more than distinct characters and each substring of length contains exactly distinct characters because of the condition Time complexity 
952,Luba is surfing the Internet She currently has opened tabs in her browser indexed from to from left to right The mouse cursor is currently located at the th tab Luba needs to use the tabs with indices from to inclusive for her studies and she wants to close all the tabs that don t belong to this segment as fast as possible Each second Luba can either try moving the cursor to the left or to the right if the cursor is currently at the tab then she can move it to the tab or to the tab or try closing all the tabs to the left or to the right of the cursor if the cursor is currently at the tab she can close all the tabs with indices from segment or from segment In the aforementioned expressions and denote the minimum and maximum index of an unclosed tab respectively For example if there were tabs initially and tabs and are closed then What is the minimum number of seconds Luba has to spend in order to leave opened ,If and then the answer is If and or and then answer is or respectively And in the other case when and the answer is ,To solve the problem you need to understand two facts The answer can t be greater than If current distance between rivaling student if less then we always can increment this distance by one swap In means that answer is equal to 
953,You are given a function written in some basic language The function accepts an integer value which is immediately written into some variable is an integer variable and can be assigned values from to The function contains three types of commands for for loop end every command between for and corresponding end is executed times add adds to After the execution of these commands value of is returned Every for is matched with end thus the function is guaranteed to be valid for can be immediately followed by end add command can be outside of any for loops Notice that add commands might overflow the value of It means that the value of becomes greater than after some add command Now you run and wonder if the resulting value of is correct or some overflow made it incorrect If overflow happened then output OVERFLOW otherwise print the resulting value of ,One can notice or actually derive using some maths that the answer is the sum of products of nested for loops iterations for every add command Let s learn to simulate that in linear complexity Maintain the stack of multipliers on for push the top of stack multiplied by to the stack on end pop the last value on add add the top of the stack to the answer The problem however is the values are really large Notice that once you add the value greater or equal to to the answer it immediately becomes OVERFLOW Thus let s push not the real multiplier to the stack but min multiplier That way the maximum value you can achieve is about which fits into the 64 bit integer Overall complexity ,Let s rewrite the original equality a bit a j a i j i a j j a i i Let s replace each a i with b i a i i Then the answer is the number of pairs i j such that i j and b i b j To calculate this value you can use or sorting 
954,There is a rectangular grid of size Each cell has a number written on it the number on the cell is Your task is to calculate the number of paths from the upper left cell to the bottom right cell meeting the following constraints You can move to the right or to the bottom only Formally from the cell you may move to the cell or to the cell The target cell can t be outside of the grid The of all the numbers on the path from the cell to the cell must be equal to operation is the bitwise exclusive OR it is represented as in Java or C and in Pascal Find the number of such paths in the given grid ,This is a typical problem on the technique The number of moves we will made equals So if would be small enough 25 is the upper bound I think then we can just run recursive backtracking in or in to iterate over all binary masks of lengths containing exactly ones and check each path described by such mask in this mask is the move to the bottom and is the move to the right if its is But it is too slow So let s split this mask of bits into two parts the left part will consist of bits and the right part will consist of bits Note that each left mask and each right mask too uniquely describes the endpoint of the path and the path itself Let s carry associative arrays where for the endpoint and will denote the number of paths which end in the cell having Let s run recursive backtracking which will iterate over paths starting from the cell and move to the right or to the bottom and maintain of the path If we made moves and we are currently in the cell with right now set and return from the function Otherwise try to move to the bottom or to the right changing as needed Let s run another recursive backtracking which will iterate over paths starting from the cell and move to the left or to the top and maintain of the path except the last cell The same if we made moves and we are currently in the cell with right now let s add to the answer obvious that way we complement our from the right part of the path with the suitable from the left part of the path Otherwise try to move to the left or to the top changing as needed So this is the technique at least the way I code it Overall complexity is ,You can notice that moves of kind and are changing value to and Thus you can determine by checking adjacent nodes in the path The answer is if there are one or zero distinct values of differences not counting difference of You can also set to arbitrary big value it doesn t really matter until you can fit all values will work just fine Finally knowing and simulate the process and check that all moves are valid Overall complexity 
955,You are given switches and lamps The th switch turns on some subset of the lamps This information is given as the matrix consisting of rows and columns where if the th switch turns on the th lamp and if the th switch is not connected to the th lamp Initially all lamps are turned off Switches change state only from off to on It means that if you press two or more switches connected to the same lamp then the lamp will be turned on after any of this switches is pressed and will remain its state even if any switch connected to this lamp is pressed afterwards It is guaranteed that if you push all switches then Your think that you have too many switches and you would like to ignore one of them Your task is to say if there exists such a switch that if you will ignore not use it but press all the other switches then all the lamps will be turned on ,Let s maintain an array of size where will be equal to the number of switches that are connected to the th lamp Then answer will be if and only if there exists some switch such that for each lamp that is connected to this switch Otherwise the answer will be ,There are lots of ways to check correctness For example you can keep boolean array with already used colors check stripes naively and mark the color used if the stripe has single color If all the colors are used in the end then the answer is Overall complexity 
956,You are given an array consisting of integers For each the following inequality is true You can remove any number possibly of elements from the beginning of the array and any number possibly of elements from the end of the array You are allowed to delete the whole array You need to answer the question how many elements should be removed from the beginning of the array and how many elements should be removed from the end of the array so that the result will be an array whose product multiplication of elements is If there is more than one way to get an array with the maximum product of elements on it you are allowed to output of them The product of elements of an array array of length should be assumed to be ,First we can always get a product value equal to if we remove all elements of the array Then we need to know what maximal value of the product we can get Consequently the remaining array after removing the corresponding prefix and suffix should have no elements We can find maxima in all sections between zeros Now we are left with a set of nonzero numbers If the value of the product on the current segment is positive it makes no sense to remove any more elements Otherwise the product is negative then we must remove one negative number from the product either to the left or to the right Compare the values of the product on the prefix and suffix to the nearest negative value and remove either the suffix or the prefix respectively ,Let s prove that next greedy solution works each step we will find prefixes of minimal length of arrays such that its sums are equal and we will cut them forming next block If we will get valid partition in result so it is an optimal solution otherwise there is no solution Since length of prefix proportional to its sum so prefixes are minimal since its sums are minimal Let s prove this algorithm let optimal solution have alternative partition Since our solution cuts minimal possible prefixes so at some step optimal solution cuts prefix with greater sum and greater length But this prefixes in optimal solutions contain smaller prefixes found by greedy solution so it can be divided on two parts contradiction So we can keep prefixes and increase one which have smaller sum Result complexity is 
957,Polycarp likes numbers that are divisible by 3 He has a huge number Polycarp wants to cut from it the maximum number of numbers that are divisible by To do this he makes an arbitrary number of vertical cuts between pairs of adjacent digits As a result after such cuts there will be parts in total Polycarp analyzes each of the obtained numbers and finds the number of those that are divisible by For example if the original number is then Polycarp can cut it into three parts with two cuts As a result he will get two numbers that are divisible by Polycarp can make an arbitrary number of vertical cuts where each cut is made between a pair of adjacent digits The resulting numbers cannot contain extra leading zeroes that is the number can begin with if and only if this number is exactly one character For example and are not valid numbers but and are valid What is the maximum number of numbers divisible by that Polycarp can obtain ,There are multiple approaches to solve this problem We will use dynamic programming approach Let s calculate values of the array where is the answer for prefix of the length Obviously since for the empty string the prefix of the length the answer is For you can find in the following way Let s look in the last digit of the prefix of length It has index Either it doesn t belong to segment divisible by or it belongs If it doesn t belongs it means we can t use the last digit so If it belongs we need to find shortest that is divisible by and try to update with the value It means that we bite off the shortest divisible by suffix and reduce the problem to a previous A number is divisible by if and only if sum of its digits is divisible by So the task is to find the shortest suffix of with sum of digits divisible by If such suffix is then and have the same remainder of sum of digits modulo Let s maintain array of the length where is the length of the longest processed prefix with sum of digits equal to modulo Use if there is no such prefix It is easy to see that where is the sum of digits on the th prefix modulo So to find the maximal that substring is divisible by just check that and use where is the sum of digits on the th prefix modulo It means that to handle case that the last digit belongs to divisible by segment you should try to update with value In other words just do Sequentially calculating the values of we obtain a linear solution ,There are many possible approaches in this problem I will describe one of the easiest Let s print the initial string by the following algorithm firstly init the variable Then while the encrypted string isn t empty print the first character of this string remove first characters from it and increase by one 
958,Recall that of an array is a that does not belong to the array Examples for the array MEX equals to because numbers and are presented in the array and is the minimum non negative integer not presented in the array for the array MEX equals to because is the minimum non negative integer not presented in the array for the array MEX equals to because is the minimum non negative integer not presented in the array You are given an empty array in other words a zero length array You are also given a positive integer You are also given queries The th query consists of one integer and means that you have to append one element to the array The array length increases by after a query In one move you can choose any index and set or i e increase or decrease any element of the array by The only restriction is that Since initially the array is empty you can perform moves only after the first query You have to maximize the minimum excluded of the array if you can perform any number of such operations you can even perform the operation multiple times with one element You have to find the answer after each of queries i e the th answer corresponds to the array of length ,Firstly let s understand what the operation does It changes the element but holds the remainder modulo So we can consider all elements modulo Let be the number of elements with the value modulo be the number of elements with the value modulo and so on Let s understand where is the bottleneck of MEX Obviously we can always fill exactly full blocks so MEX is at least MEX will be among all elements such that Among all such elements MEX will be the minimum such Let it be So the final value of MEX is How to deal with queries Let s maintain the sorted set of pairs for all and change it with respect to appended values During each query let s change the set correspondingly and take the answer as the first element of this set using the formula above Time complexity There is also an easy linear solution that uses the same idea but in a different way ,We will use the Contribution to the Sum technique to solve this problem for every integer from to let s calculate the number of ways to choose the operators so it belongs to the result and add all of the results For a fixed integer the number of ways to choose the operators so that belongs to the result can be done as follows let be the number of ways to choose the first operators so that after applying them the resulting set contains if and does not contain if The transitions from to depend on whether the number belongs to the segment Obviously this is too slow if we compute the dynamic programming from scratch for every integer Instead we can notice that the transitions from to are linear combinations both and are linear combinations of and with coefficients depending on whether the element belongs to the set or not So transitioning from to can be written in terms of multiplying by a matrix Let s build a segment tree where each vertex stores a transition matrix and operations are calculate the product of matrices on a segment and replace a matrix at some index We can build a sequence of these transition matrices for and store them in the segment tree for this sequence of transition matrices will change only in positions such that either belongs to and does not belong to it or vice versa So we can go from to by replacing these transition matrices in the segment tree For the only changes from are in positions such that either belongs to and does not belong to it or vice versa and we can replace the matrices in these positions as well In total there will be only such replacements so we solve the problem in where is the constraint on the numbers belonging to the sets 
959,Recently your friend discovered one special operation on an integer array Choose two indices and Set After playing with this operation for a while he came to the next conclusion For every array of integers where you can find a pair of indices such that the total sum of will after performing the operation This statement sounds fishy to you so you want to find a counterexample for a given integer Can you find such counterexample and prove him wrong In other words find an array consisting of integers such that for all pairs of indices performing the operation won t decrease the total sum it will increase or not change the sum ,Suppose the initial sum of is equal to If we perform the operation the new sum will be equal to We want the sum not to decrease or If we will get If we ll get analogically In other words array you need if sorted will have and so on And one of the variants and obviously an optimal one is just As a result since we just need to check if then we found an answer otherwise there is no counterexample ,Let s estimate the smallest possible achievable answer Let the number of the arrays of size greater than or equal to i be g i The answer is maximum lceil frac g i c i rceil over all i from 1 to k You can prove that you can t fit g i arrays in less than lceil frac g i c i rceil testcases with the pigeonhole principle Let that be called ans Ok let s now construct the solution for that estimate Sort arrays in the increasing or decreasing order and assign the i th array 0 indexed in that order to the i mod ans testcase It s easy to see that for any i the number of arrays of size greater than or equal to i is always restricted by lceil frac g i c i rceil Overall complexity O n log n k or O n k if you care enough to do counting sort 
960, You are given a string consisting of characters each character is or You are also given an integer Your task is to change the minimum number of characters in the initial string so that after the changes there will be a string of length that is a substring of and is also a substring of the infinite string A string is a substring of string if there exists a positive integer such that For example strings are substrings of the infinite string while and are not You have to answer independent queries ,You can just implement what is written in the problem statement and solve this problem this way Let s iterate over all starting positions of the substring from to and over all possible offsets of the string from to inclusive Then let s iterate over all position of the current substring from to and carry the variable which denotes the answer for the current starting position and the current offset And if then let s increase by After iterating over all positions let s update the answer with the value of ,Let s solve this problem by subset dynamic programming Let s denote as the number of adjacent characters and in such that or Let s be some intermediate result further it will be explained what kind of intermediate result if we already added letters corresponding to subset to the keyboard and we don t care about the order of these letters Now let s consider how to recalculate values of this dynamic programming using some Let s iterate over a new letter on keyboard and we know the position of this letter on the keyboard it s equal to the number of elements in After adding this new letter we want to calculate what it added to the Let consider some letter and calculate how much time will be spent on moving and There are two cases If letter is already on current keyboard then we should add to answer and otherwise where is the position of character on the keyboard But we don t know the position of the letter Let s fix it as follows We will add the contribution of some letter when it will be added to the keyboard So when we added letter we should add the value So the total complexity is 
961,There are bags each bag contains balls with numbers from to For every there is exactly one ball with number in each bag You have to take exactly one ball from each bag all bags are different so for example taking the ball from the first bag and the ball from the second bag is not the same as taking the ball from the first bag and the ball from the second bag After that you calculate the number of balls with numbers among the ones you have taken Let the number of these balls be Your task is to calculate the sum of over all possible ways to take balls one from each bag ,The main idea of this problem is to use a technique similar to contribution to the sum We will model the value of as the number of tuples where each element is an index of a bag from which we have taken an odd ball Let be the number of ways to take balls from bags so that all elements from tuple are indices of bags with odd balls then the answer to the problem can be calculated as the sum of over all possible tuples First of all let s obtain a solution in per test case We need to answer the following questions while designing a solution to the problem How do we calculate for a given tuple How do we group tuples and iterate through them The first question is not that difficult Every element from the tuple should be an index of a bag from which we have taken an odd ball so for every bag appearing in the tuple we can take only a ball with odd number but for every bag not appearing in the tuple we can choose any ball So if the number of elements in a tuple is then for the tuple can be calculated as This actually gives as a hint for the answer to the second question since depends on the number of distinct elements in the tuple let s try to group the tuples according to the number of distinct elements in them So the answer will be calculated as where is the number of tuples with exactly different elements How do we calculate First of all if then is obviously Otherwise we can use the following recurrence let be the number of tuples of elements with distinct ones then if and for a tuple with one element there are ways to choose it if and if and there is only one distinct element and it was already chosen if and we either add an element which did not belong to the tuple and there are ways to choose it or we add an already existing element and there are ways to choose it Obviously this recurrence can be calculated in with dynamic programming so we get a solution in per test case How do we speed this up Let s change the way we calculate Instead of considering tuples with values from to we will consider only tuples where values are from to and the first appearance of a value is only after the first appearance of the value So these tuples actually represent a way to split a set of integers into several subsets so they are the Stirling numbers of the second kind and we can calculate them in with dynamic programming outside of processing the test cases How do we calculate using these values If we use distinct integers as the elements of the tuple there are ways to choose the first one ways to choose the second one etc so where is the Stirling number of the second kind for the parameters and We can maintain the values of and while iterating on from to and that gives us a way to solve the problem in per test case Overall complexity for precalculation and per test case ,Because we can only eat candies from boxes The only way to make all boxes have the same quantity of candies in them would be to make all candies contain a number of candies equal to the minimum quantity of candies a box initially has So we should find this minimum number let s denote it as and then for each box there should be eaten candies So the answer would be the sum of over all s 
962,There are trees in a park numbered from to The initial height of the th tree is You want to water these trees so they all grow to the height The watering process goes as follows You start watering trees at day During the th day you can Choose a tree and water it If the day is odd e g then the height of the tree increases by If the day is even e g then the height of the tree increases by Or skip a day without watering any tree Note that you can t water more than one tree in a day Your task is to determine the number of days required to water the trees so they grow to the same height You have to answer independent test cases ,The first observation we need to solve this problem the required height is either or where is the maximum initial height of some tree We don t need heights greater than because for example if the height is we can remove some moves and get the answer for the height The same thing applies to all heights greater than Why do we even need the height In some cases like the answer for the height is better than the answer for the height in this particular case it is vs Now we have two ways to solve the problem either use some gross formulas or just write a binary search on the answer I won t consider the solution with formulas but we have one so let s assume we use binary search Let the current answer be Then let be the number of operations we can do and be the number of operations we can do We can use operations greedily and then just check if the number of operations is sufficient to grow up the remaining heights Time complexity per test case ,Let s calculate answer in two steps At first let s calculate for each vertex what we can gain if we must return from subtree of in the end We need only pair of values minimal possible depth we can acquire to move up from subtree of and maximal number of different leaves we can visit Note that this two values are independent since we must return from and if for some child of we can return from it it s profitable to visit and return But if we can t return from so we are prohibited to descent to So number of visited leaves is just a sum of all if Also note that we can always reorder all children in such way that last visited vertex will have minimal So minimal possible depth is a minimum over all At second let s calculate maximal number of different leaves we can visit if we don t need to return from subtree of It can be calculated quite easy using array We just need to choose child we will not return from so from vertex we will take value and from other childen which we can return from value Result complexity is 
963,You have an array of integers of size Initially all elements of the array are equal to You can perform the following operation choose two integers and and then increase the value of by i e make After performing all operations you will receive coins for all such that Your task is to determine the maximum number of coins that you can receive by performing no more than operations ,Let s calculate the minimum number of operations to get the number from To do this it is enough to use BFS or dynamic programming Edges in the graph transitions in dynamic programming have the form for all Now the problem itself can be reduced to a knapsack problem there are items th item weighs and costs you have to find a set of items with the total weight of no more than of the maximum cost This is a standard problem that can be solved in but it is too slow although some participants passed all the tests with such a solution However we can notice that the values of should not grow too fast namely the maximum value of for does not exceed This means that the maximum possible weight is no more than and we can limit to this number i e make ,Let s split a given string into blocks of consecutive zeros Then in each such block you can independently put the maximum number of people who fit in it But there are three cases to consider If the current block is not the first and not the last then there are ones at the border and this means that the first tables of the current block and the last are prohibited Therefore remove these zeroes from the string If the current block is the first then the one is at the end and you need to delete the last zeros If the current block is the last then in the beginning there is one and you need to delete the first zeros Also as a separate case you need to consider a string consisting only of zeros Then there is exactly one block from which you do not need to remove zeros Now all the tables in each block are free then in each block we can put Sum these values over all blocks 
964,So you decided to hold a contest on Codeforces You prepared the problems statements solutions checkers validators tests Suddenly your coordinator asks you to change all your tests to multiple testcases in the easiest problem Initially each test in that problem is just an array The maximum size of an array is For simplicity the contents of arrays don t matter You have tests the th test is an array of size Your coordinator asks you to distribute all of your arrays into multiple testcases Each testcase can include multiple arrays However each testcase should include no more than arrays of size no more than arrays of size no more than arrays of size Also So now your goal is to create the new testcases in such a way that each of the initial arrays appears in testcase for each testcase the given conditions hold the number of testcases is minimum possible Print the minimum possible number of testcases you can achieve and the sizes of arrays included in each testcase ,Let s estimate the smallest possible achievable answer Let the number of the arrays of size greater than or equal to i be g i The answer is maximum lceil frac g i c i rceil over all i from 1 to k You can prove that you can t fit g i arrays in less than lceil frac g i c i rceil testcases with the pigeonhole principle Let that be called ans Ok let s now construct the solution for that estimate Sort arrays in the increasing or decreasing order and assign the i th array 0 indexed in that order to the i mod ans testcase It s easy to see that for any i the number of arrays of size greater than or equal to i is always restricted by lceil frac g i c i rceil Overall complexity O n log n k or O n k if you care enough to do counting sort ,Let s reformulate this problem in next form we can sort only subarray of length 2 swap two consecutive elements and if It is simular tasks because we can sort any array by sorting subbarray of length 2 for example bubble sort does exactly that Now lets look at elements and If then we will solve this task for arrays and Otherwise lets look at minimum position such that if there is no such position then answer to the problem is We can move element to the beginning of array only if all elements greater then In other words any index such that must be greater then And if this condition holds then we just delete element and solve task for arrays and But instead of deleting this element we will change information about minimum index such that This index will be the minimum index such that and For do this we will maintain stacks such that for any element of stack condition holds and moreover all elements in stacks are sorted in ascending order the top element of stack is minimal For example if then For finding minimum element on top of stacks we can use some data structure for example segment tree 
965,For the given integer let s write down all the strings of length which contain letters and two letters in alphabetical order Recall that the string of length is lexicographically less than string of length if there exists such that and for any The lexicographic comparison of strings is implemented by the operator in modern programming languages For example if the strings are the order does matter It is easy to show that such a list of strings will contain exactly strings You are given and Print the th string from the list ,Let s try to find the position of the leftmost occurrence of iterate over all positions from to If then this is the required position of the leftmost occurrence of Then the position of rightmost occurrence is so we can print the answer Otherwise let s decrease by remove all strings which have the leftmost at the current position and proceed to the next position It is obvious that in such a way we consider all possible strings in lexicographic order ,We will construct the string starting with the largest letters Note that if then the th letter of the string is maximal so we know that the th letter affect all While the string is not completely constructed we will do the following Find all such that and the th character of string is not placed Put on all these positions in the string the maximum letter not used in the string there should be a sufficient number of letters in the string Subtract from all 
966, Ivan plays a computer game that contains some microtransactions to make characters look cooler Since Ivan wants his character to be really cool he wants to use some of these microtransactions and he won t start playing until he gets all of them Each day during the Ivan earns exactly one burle There are types of microtransactions in the game Each microtransaction costs burles usually and burle if it is on sale Ivan has to order exactly microtransactions of the th type he orders microtransactions during the Ivan can order possibly zero number of microtransactions of types during any day of course If the microtransaction he wants to order is on sale then he can buy it for burle and otherwise he can buy it for burles There are also special offers in the game shop The th offer means that microtransactions of the th type are on sale during the th day Ivan wants to order all microtransactions as soon as possible Your task is to calculate the minimum day when he can buy all microtransactions he want and actually start playing ,The main idea of this problem is the same as in the easy version The only thing we should replace is the search method Replacing linear search with binary search leads to reducing time complexity from to And it is obvious that we can apply binary search here because if we can order all microtransactions during some day then we can order all of them during day even using the answer for days and doing nothing during day ,Let s start by learning how to answer a query all red pepper and black pepper options are available Let s iterate over all options to put the peppers and choose the maximum of them First let s use the red pepper for all dishes Now we want to select some of them to use black pepper instead of red pepper Which ones do we choose When we switch from the red pepper to the black pepper the total tastiness changes by for the th dish They are completely independent of each other so we want to choose largest of these values Let be the sequence of values of in a non increasing order Thus black peppers will yield the result of We can answer a query by looking for a maximum in the sequence Now consider an arbitrary query Let be all options for the amount of available black peppers for the query Naively we could iterate over all of them and choose the maximum one However notice an interesting thing about the sequence of the answers By definition it is non strictly convex In particular one idea that can be extracted from this is the following Find the position of an arbitrary maximum in this sequence Then everything to the left of is is non increasing Everything to the right of it is non increasing Thus for a query it s enough to consider only two options the one closest to the maximum from the left and from the right Now we only have to learn how to get these options fast enough For a query we want to solve what s called a diophantine equation An arbitrary solution can be obtained by using extended Euclid algorithm Let it be some Then we would want to check the answer for black peppers The amount of solutions to the equation is either infinite or zero If it s infinite all solutions will be of the form for any integer Remember that not all the solutions will be in a range Finally find the two solutions that are the closest to the maximum check that they are in the range and print the best answer of them Overall complexity 
967,There are frogs sitting on the coordinate axis For each frog two values are known the position and the initial length of the tongue of the th frog it is guaranteed that all positions are different mosquitoes one by one are landing to the coordinate axis For each mosquito two values are known the coordinate of the position where the th mosquito lands and the size of the th mosquito Frogs and mosquitoes are represented as points on the coordinate axis The frog can eat mosquito if mosquito is in the same position with the frog or to the right and the distance between them is not greater than the length of the tongue of the frog If at some moment several frogs can eat a mosquito the leftmost frog will eat it with minimal After eating a mosquito the length of the tongue of a frog increases with the value of the size of eaten mosquito It s possible that after it the frog will be able to eat some other mosquitoes the frog should eat them in this case For each frog print two values the number of eaten mosquitoes and the length of the tongue after landing all mosquitoes and after eating all possible mosquitoes by frogs Each mosquito is landing to the coordinate axis only after frogs eat all possible mosquitoes landed before Mosquitoes are given in order of their landing to the coordinate axis ,Let s maintain the set of not eaten mosquitoes for example with set in C or with TreeSet in Java and process mosquitoes in order of their landing Also we will maintain the set of segments ai bi where ai is the position of the i th frog and bi ai li where li is the current length of the tongue of the i th frog Let the current mosquito landed in the position x Let s choose segment ai bi with minimal ai such that bi x If the value ai x we found the frog that will eat mosquito Otherwise the current mosquito will not be eaten and we should add it to our set If the i th frog will eat mosquito then it s tongue length will be increased by the size of mosquito and we should update segment ai bi After that we should choose the nearest mosquito to the right the from frog and if it s possible eat that mosquito by the i th frog this can be done with lower bound in C Possibly we should eat several mosquitoes so we should repeat this process several times Segments ai bi we can store in segment tree by position ai and value bi Now to find segment we need we can do binary search by the value of ai and check the maximum bi value on the prefix to be at least x This will work in O nlog2n time We can improve this solution Let s go down in segment tree in the following manner if the maximum value bi in the left subtree of segment tree is at least x then we will go to the left otherwise we will go to the right Complexity O n m log n m ,The main idea of the solution is to calculate the following dynamic programming is the maximum prefix we can fully cover with first lanterns Let s look at how can we solve it in with this kind of dynamic programming First of all let s write it forward Which transitions from do we have iterate on the lantern facing left that will cover the lantern Let this lantern be It should cover all lanterns in so all lanterns from can be turned to the right and we need a max query to determine the new covered prefix if lantern is already covered we can just extend the prefix by turning the th lantern to the right Note that turning it to the right when it is not covered yet will be modeled by the first transition It is obviously how can we optimize it Let s write this dynamic programming backward The second transition is changed to backward dp easily what about the first one Suppose we want to turn some lantern to the left Let s iterate on the prefix that we will connect to it for this prefix should be at least and we update with the maximum of since it is covered by lantern and the result of max query on In fact we need only one such prefix the one with the minimum among those which have So we build a minimum segment tree where each pair is interpreted as the value of in position and with min query on the suffix from we find this optimal prefix from which we should update and to update we can use any DS that allows max queries on segment in my solution it s another segment tree 
968,There is a river of width The left bank of the river is cell and the right bank is cell more formally the river can be represented as a sequence of cells numbered from to There are also wooden platforms on a river the th platform has length so the th platform takes consecutive cells of the river It is guaranteed that the sum of lengths of platforms does not exceed You are standing at and want to reach somehow If you are standing at the position you can jump to any position in the range you don t really like the water so you can jump only to such cells that belong to some wooden platform For example if you can jump only to the next position if it belongs to the wooden platform You want to know if it is possible to reach from if you can move any platform to the left or to the right arbitrary number of times possibly zero as long as they do not intersect each other but two platforms can touch each other It also means that you cannot change the relative order of platforms in other words you first move the platforms and then start jumping For example if and then one of the ways to reach from is follow ,This problem has a very easy idea but requires terrible implementation Firstly let s place all platforms as rightmost as we can Thus we will have the array in which the first elements are zeros and other elements are Now let s start the algorithm Firstly we need to jump to the position or less If we could jump to the position then we don t need to jump to some position to the left from But if we cannot do it let s take the leftmost platform to the right from the position and move it in such a way that its left border will be at the position Now we can jump to the position and then jump by right to reach the position Let s repeat the same algorithm and continue jumping If after some move we can jump to the position at least then we are done Time complexity but I m sure it can be implemented in or ,In this problem we first need to consider all points adjacent to at least one Christmas tree then all points at the distance two from the nearby Christmas tree and so on What it looks like Yes well known multi source bfs Let s maintain a queue of positions and the set of used positions and the distance to each vertex of course In the first step we add all positions of the Christmas tree with a zero distance as initial vertices Let the current vertex is If this is the Christmas tree then just add and to the queue if these vertices aren t added already and continue Otherwise increase the answer by and add to the array of positions of people When the length of this array reaches interrupt bfs and print the answer Don t forget about some special cases as using in Java or using in C because this can lead to the quadratic complexity Time complexity 
969,Monocarp had a sequence consisting of integers He painted the elements into two colors red and blue elements were painted red all other elements were painted blue After painting the elements he has written two sequences and The sequence consisted of all red elements of similarly the sequence consisted of all blue elements of Unfortunately the original sequence was lost and Monocarp only has the sequences and He wants to restore the original sequence In case there are multiple ways to restore it he wants to choose a way to restore that maximizes the value of Help Monocarp to calculate the maximum possible value of ,Denote as the sum of first elements of and as the sum of first elements of These values can be calculated in with prefix sums The first solution is to use dynamic programming Let be the maximum value of if we placed the first elements of and the first elements of Transitions can be performed in we either place an element from then we go to and update it with or place an element from then we go to and update it with The answer is stored in and this solution works in The second solution observe that the sum of several first elements of is the sum of several first elements of and several first elements of So each prefix sum of and the answer itself is not greater than It s easy to show how to obtain exactly this answer let be the value of such that is maximized and be the value of such that is maximized Let s place the first elements of then the first elements of so the current sum is exactly and place all of the remaining elements in any possible order So the answer is This solution works in ,We have for each we can rewrite this as follows or From here we can see that for each there is a segment of values that can be assigned to So we have to match each number from to with one of these segments To solve this problem we can iterate from to Let the current number be then it can be paired with a segment without a pair such that and the right bound is minimum among all such segments because it will be the first to end among these segments To do this it is enough to maintain a set with open segments that have not yet been assigned a pair and choose from it a segment with the minimum right bound Before running this method you can sort the segments by their left border so they can be easily added to this set when we go from to we will need to insert all segments that begin with that s why it s convenient to have them sorted by their left border beforehand 
970,You are given two very long integers leading zeroes are allowed You should check what number or is greater or determine that they are equal The input size is very large so don t use the reading of symbols one by one Instead of that use the reading of a whole line or token As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in Don t use the function in instead of it use the function ,Note that solutions in Java with BigInteger class or input function in Python2 will fail in this problem The reason is the next standard objects stores numbers not in decimal system and need a lot of time to convert numbers from decimal system Actually they are working in where is the legth of the number To solve this problem you should simply read the numbers to strings and add leading zeroes to the shorter one until the numbers will be of the same length After that you should simply compare them alphabetically ,Firstly let s parse both strings to four integers Just read them and then use some standard functions to transform them into integers or we can do it manually The second part is to obtain and Then let It is the answer We have to print and where is divided by rounding down and is modulo The only thing we should do more carefully is to print one leading zero before if it is less than and do the same for 
971,You are given lengths of segments that need to be placed on an infinite axis with coordinates The first segment is placed on the axis so that one of its endpoints lies at the point with coordinate Let s call this endpoint the of the first segment and let s call its as that endpoint that is not the start The start of each following segment must coincide with the end of the previous one Thus if the length of the next segment is and the end of the previous one has the coordinate the segment can be placed either on the coordinates and then the coordinate of its end is or on the coordinates in which case its end coordinate is The total of the axis by these segments is defined as their overall union which is basically the set of points covered by at least one of the segments It s easy to show that the coverage will also be a segment on the axis Determine the minimal possible length of the coverage that can be obtained by placing all the segments on the axis without changing their order ,One possible solution involves the method of dynamic programming As a state of DP we will use the number of already placed segments and the distance from the end of the last segment to the current left boundary of the coverage and in the DP we will store the minimal possible distance from the end of the last segment to the current right boundary of the coverage We can prove that the answer never exceeds where is the maximal length of the segments To do this let us define a region of length specifically the segment If the end of the last segment has a coordinate we put the next segment to the left otherwise we put it to the right With this algorithm none of the end endpoints of the segments will go beyond the marked boundaries because to do so the segment must be placed from the coordinate of one sign beyond the boundary of the opposite sign and thus must have a length greater than which contradicts how we defined Using this fact we will consider the DP for and as the minimum distance between the end of the th segment and the right boundary of the axis coverage of the first segments when the distance to the left boundary of the coverage equals to The end of the th segment here is the beginning of the first one that is the point The base of DP is since when no segments are placed the coverage boundaries and the current point are all coincident Next we consider the forward dynamic programming relaxation for every there are two cases to consider the case of the next segment being placed to the left and the case of it being placed to the right value below refers to the distance to the right boundary of the coverage and is an alias for If a segment of length is placed to the left side then the new distance to the left boundary will be equal to and distance to the right boundary will always be which gives us the relaxation formula If a segment of length is placed to the right side then the new distance to the right boundary will be equal to and distance to the left boundary will always be which gives us the relaxation formula The values in array can be calculated in ascending order by Then the answer for the problem can be found as the minimum sum of and in the last row of that is The time complexity is ,Let s call the segment good if it contains no more than zeroes Note if segment is good than the segment is also good So we can use the method of two pointers the first pointer is and the second is Let s iterate over from the left to the right and move while we can to do that we should simply maintain the number of zeroes in the current segment 
972,A string is called palindrome if it reads the same from left to right and from right to left For example and are palindroms but strings and are not You are given string consisting of lowercase Latin letters At once you can choose any position in the string and change letter in that position to any other lowercase letter So after each changing the length of the string doesn t change At first you can change some letters in Then you can permute the order of letters as you want Permutation doesn t count as changes You should obtain palindrome with the minimal number of changes If there are several ways to do that you should get the lexicographically alphabetically smallest palindrome So firstly you should minimize the number of changes and then minimize the palindrome lexicographically ,Let s denote cntc the number of occurences of symbol c Let s consider odd values cntc Palindrome can not contain more than one symbol c with odd cntc Let s denote symbols with odd cntc as a1 a2 ak in alphabetical order Let s replace any one of symbols ak with symbol a1 ak 1 with a2 and so on until the middle of a Now we have no more than one odd symbol If we have some let s place it in the middle of the answer First half of answer will contain occurences of symbol c in alphabetical order The second half will contain the same symbols in reverse order For example for string s aabcd at first we will replace d by Unable to parse markup type CF TEX abcba Compexity O n ,Let s find the first and the last position of characters denote them as and respectively Since the can t delete characters all characters between and will remain So we have to delete all characters between and 
973,You are given a two dimensional plane and you need to place chips on it You can place a chip only at a point with integer coordinates The cost of placing a chip at the point is equal to where is the absolute value of The cost of placing chips is equal to the among the costs of each chip You need to place chips on the plane in such a way that the Euclidean distance between each pair of chips is than and the cost is the minimum possible ,Suppose the answer is What s the maximum number of chips we can place Firstly the allowed points to place chips are such that We can group them by coordinate for there is only one for possible are for possible are in segment and so on For possible are in The negative s are the same Let s calculate the maximum number of chips we can place at each row for it s for there are three s but since we can t place chips at the neighboring s we can place at most chips for we have places but can place only chips for we have places but can occupy only points In total for we can place at most chips Analogically for we can place at most chips In total we can place at most chips with cost at most Note that can actually be reached since the distance between chips on the different rows is greater than So to solve our task it s enough to find minimum such that that can be done with Binary Search Or we can calculate Note that can lose precision since is cast to before taking the square root for example transforms to when converted to So you should either cast to that consists of bits in some C compilers or check value as a possible answer ,The main idea is to read and process each row of the matrix separately To do this we will use DSU data structure The answer will be equal to the difference between the number of 1 s and the number of operations in DSU When processing the row we will keep the DSU for the previous row When processing a certain index in the row we will try to merge it with the element to the left of it and with the element to the top that s all we have to check here You also have to handle the fact that we cannot store the whole DSU since the number of components can be up to and it s impossible to store all required information for them So each time we process a row we have to renumerate all components in this row to ensure that every time we are operating with indices of components not greater than 
974,You are a coach at your local university There are students under your supervision the programming skill of the th student is You have to form teams for yet another new programming competition As you know the more students are involved in competition the more probable the victory of your university is So you have to form no more than and at least one teams so that the number of students in them is maximized But you also know that team should be It means that the programming skill of each pair of students in team should differ by no more than Teams are independent from one another it means that the difference between programming skills of two students from two different teams does not matter It is possible that some students not be included in any team at all Your task is to report the maximum possible number of students in no more than and at least one teams ,Firstly let s sort all students in order of non decreasing their programming skill Then let s calculate the following dynamic programming is the maximum number of students in at most non empty teams if we consider first students How to do transitions from The first transition is pretty intuitive just skip the th indexed student Then we can set The second possible transition is to take some team starting from the th student The only assumption we need to do it is the following take the maximum by number of students team starting from the th student is always optimally Why it is so If we consider the student with the maximum programming skill in the team we can take him to this team instad of forming the new team with this student because this is always not worse So the second transition is the following let be the number of students in a team if the th student is the first in it We can calculate this part in naively or in using two pointers We can set Time complexity ,Let s found two athletes with numbers and the strength of is not greater than the strength of which have the minimal modulus of the difference of their strength Obviously we cannot get an answer less than this Let s show how to get the partition with exactly this answer Sort all athletes by strength Our two athletes will stand in neighboring positions otherwise we can decrease the answer Let the first team contains all athletes who stand on positions not further than and the second team contains other athletes We got a partition in which the athlete with number has the maximal strength in the first team and the athlete with number has the minimal strength in the second team 
975,You are given a positive decimal number Your task is to convert it to the Let where then in general case the looks like If equals to zero the part should be skipped If is an integer it should be written without decimal point Also there should not be extra zeroes in and ,This is an implementation problem You should do exactly what is written in the problem statement On my mind the simplest way is to find the position of the first not zero digit and the position of the dot The difference between that positions is the value of if the value is positive you should also decrease it by one ,One of the possible approaches to this problem is to try multiplying only by the largest digit in it Unfortunately this doesn t work quite well since it gives WA on one of the examples That example is too big to consider but a smaller version of it can prove that this is an incorrect solution let If we multiply by we get and there s no way to obtain a number with digits using the next action But if we multiply by we get which can then be multiplied by to obtain a digit number So considering only the largest digit is not enough This implies that we somehow need to consider the options that are not optimal locally but optimal globally i e choose a lower digit right now to obtain a higher digit in the future Let s try to estimate the number of possible integers that can be obtained using these operations to see if we can consider all possible options The key observation is that each integer we obtain will have the form since only one digit primes can be added to the factorization Since we consider only numbers less than is not greater than is not greater than is not greater than and is not greater than and the number of reachable integers is about million note that this is a very generous bound since not all combinations of yield an integer less than and not all such integers can be reached with the operations This allows us to use BFS or dynamic programming to calculate the answer 
976,You are given two strings and consisting of small Latin letters string can also contain characters of string is calculated by following metric Any two letters can be swapped positions these operations can be performed arbitrary number of times over any pair of positions Among all resulting strings you choose the one with the largest number of occurrences of string is this number of occurrences You should replace all characters with small Latin letters in such a way that the of string is maximal ,Notice that the order of letters doesn t matter at all depends only on amount of each letter Let be the possibility that string will occur in at least times after replacing all signs and after some swaps If is true then is also true That leads to binary search over the answer Let be the amount of letters in and the amount of letters in is the number of signs is true if If some letter appears in less times than needed then replace some signs with it Answer can be restored greedily by replacing signs with the letters needed Overall complexity where is the size of the alphabet ,Firstly let s calculate the length of the prefix of equal letters let it be and the length of the suffix of equal letters let it be It can be done with two cycles with breaks It is obvious that this prefix and suffix wouldn t overlap Then let s consider two cases the first one is when and the second one is when In the first case we can only remain either prefix or suffix of consisting only of equal letters Then the answer is because we can remain from to letters on the prefix from to on the suffix or empty string In the second case we can remain from to letters on the prefix and from to letters on the suffix But now because we can combine these ways so the answer is And the bonus this case is not belong to the given problem if all letters in the string are equal then then answer is because we can choose any substring of of length at least and any substring of length 
977,You are given an array of integers This array is called a if there exists subarray such that or or Here are three examples The first image shows the array it because only subarray with indices satisfies the condition The second image shows the array it because only subarray with indices satisfies the codition The third image shows the array it because two subarrays and that satisfy the condition You are asked whether the given array is a valley or not ,One possible solution is to represent a range of equal element as a single element with that value Construct this array and loop through it and check how many element satisfy the conditions or and or If exactly one index satisfies these conditions print YES and othewise NO Complexity , Okay we need more definitions Here they come This way we can transform the formula for to the following Or even this since This is almost the convolution of the sequences and with a bit extra additional operations after the convolution so to compute the sequence we just need to compute the sequences and and then calculate their convolution with NTT All that s left is to multiply every element by the corresponding factorial But wait that s not so easy In order to calculate and we need to know Note that we can ignore the fact that and appear in the formula for since they are multiplied by so at least we don t have a dependency cycle Unfortunately we cannot just straightforwardly use convolution if we don t know the sequences and The model solution handles it using the following approach Let s generate and in parallel on the th iteration calculate then calculate and using it And we will calculate the convolution of the sequences and Suppose we want to calculate and the last time we calculated the convolution of and was after the iteration Back then we knew all elements from to and from to So the th term in the convolution of and contained the sum of over all such that and So in order to calculate we have to pick this value from the convolution and then add the sum of over all such that or and there are such values Suppose we compute the convolution every iterations Then the maximum value of is and every value of is calculated in We also make convolutions so the total complexity of this solution will be which can be transformed into if we pick 
978,The sequence of integers is called a good array if and For example the sequences are good arrays and the sequences are not A sequence of integers is called good if it can be divided into a positive number of good arrays Each good array should be a subsegment of sequence and each element of the sequence should belong to exactly one array For example the sequences are good and the sequences are not For a given sequence of numbers count the number of its that are good sequences and print the number of such subsequences modulo ,The problem is solved by the dynamic programming Let be the answer for the prefix of the array starting at it contains the indices If then Otherwise let s go over the position with which the next good array begins Then we need to select positions among positions which will be elements of the array The number of ways to choose an unordered set of items from of different objects is calculated using the formula Thus the dynamics is as follows The basis of dynamics is the value ,Notice that we can keep solved tasks and then submit all at once So the solution goes down to this you should find the first moment of time that the site works at that moment and Also it s convinient that the intervals are already sorted in increasing order Let s sum up all elements of array and write it to some variable The answer is obtained this way if the sum lies in the current interval then the answer is the sum Otherwise there are two cases If there exists some interval that then the answer is In other case the answer is 1 
979,You are given a string consisting of lowercase Latin letters is even For each position in string you are required to change the letter on this position either to the previous letter in alphabetic order or to the next one letters and have only one of these options Letter in every position must be changed For example letter should be changed either to or to letter should be changed to and letter should be changed to That way string for example can be changed to String is called a palindrome if it reads the same from left to right and from right to left For example strings and are palindromes and strings and are not Your goal is to check if it s possible to make string a palindrome by applying the aforementioned changes to every position Print if string can be transformed to a palindrome and otherwise Each testcase contains several strings for each of them you are required to solve the problem separately ,If some string can t be transformed to palindrom then it has some pair of positions with different letters on them as no such pair affects any other pair Thus you need to check each pair for from to and verify that the distance between the corresponding letters is either or Overall complexity ,There are just a few general cases in the task to consider If the password is already valid nothing has to be changed just print Try to change exactly one character iterate over all positions in and all three options for character any digit any lowercase or uppercase Latin letter After the replacement the string is checked for the validity and printed if it turned out to be valid We weren t able to replace a substring of length 0 or 1 then the answer is at least 2 We can obtain it in a following manner replace the first two characters to if the third character is an uppercase Latin letter to if the third character is a lowercase Latin letter and to if the third character is a digit 
980,You are given a system of pipes It consists of two rows each row consists of pipes The top left pipe has the coordinates and the bottom right There are six types of pipes two types of straight pipes and four types of curved pipes Here are the examples of all six types Types of pipes You can turn each of the given pipes degrees clockwise or counterclockwise so the types and can become each other and types can become each other You want to turn some pipes in a way that the water flow can start at to the left of the top left pipe move to the pipe at flow somehow by to the pipe at and flow right to Pipes are connected if they are adjacent in the system and their ends are connected Here are examples of connected pipes Examples of connected pipes Let s describe the problem using some example The first example input And its solution is below The first example answer As you can see the water flow is the poorly drawn blue line To obtain the answer we need to turn the pipe at degrees clockwise the pipe at degrees the pipe at degrees the pipe at degrees and the pipe at degrees Then the flow of water can reach from You have to answer independent queries ,Let s see how the water can flow when it meets the pipe of type or and in the other case When the water meets the pipe of type or we cannot do anything but let it flow to the right of the current cell Otherwise if the current pipe is curved then there are two cases if the pipe on the same position but in the other row is not curved then the answer is because the water has to change the row but we cannot turn the next pipe to allow it to move to the right or to the left So the current pipe is curved and the pipe on the same position in the other row is also curved let s change the row and move to the right it is obvious that we never need to move to the left So the answer and the sequence of pipes is uniquely defined by types of pipes If after iterating over all positions we didn t meet the case of and the current row is second then the answer is ,There are many ways to solve the problem One way is to look for the following pattern There can only be one such pattern if there is one bishop and it s not on the edge of the board We can iterate through all cells and see if we can match this pattern and if we can we output the centre cell You can also look at the positions of the two diagonals and intersect them but it requires more implementation Time complexity per testcase 
981,You have a bag of size Also you have boxes The size of th box is where each is an integer non negative power of two You can divide boxes into two parts of equal size Your goal is to fill the bag completely For example if and then you have to divide the box of size into two parts of size and then divide the box of size So you can fill the bag with boxes of size and Calculate the minimum number of divisions required to fill the bag of size ,If then the answer is because the just can divide all boxes to size and then fill the bag Otherwise the answer is If the answer is let s calculate the minimum number of divisions Let s consider all boxes from small to large Presume that now we consider boxes of size Then there are three cases if in binary representation of the th bit is equal to then we don t need boxes of size and we can merge it into boxes of size if in binary representation of the th bit is equal to and we have at most one box of size then we have to put it box in the bag and then merge the remaining boxes of size into boxes of size if in binary representation of the th bit is equal to and we have not boxes of size then we have to divide the large box into box of size let s presume that it s box of size After that we just continue this algorithm with box of size ,Let s maintain the pointer to the topmost non deleted book and whether each book whether is removed from the stack or not Initially all books are in a stack and is 0 if we store the array 0 indexed We will process the array in the order If the current book is removed from the stack then the answer for it is zero Otherwise we will increment the pointer until the equality is satisfied while marking all the intermediate books in the array After that the answer for the book will be the number of marked books in the array including itself Since the pointer shifts times at total we get a solution with an complexity 
982, There is a deck of cards each of which is characterized by its power There are two types of cards a hero card the power of such a card is always equal to a bonus card the power of such a card is always positive You can do the following with the deck take a card from the top of the deck if this card is a bonus card you can put it of your bonus deck or discard if this card is a hero card then the power of card from your bonus deck is added to his power if it is not empty after that the hero is added to your army and the used bonus discards Your task is to use such actions to gather an army with the maximum possible total power ,To solve it it should be noted that despite the way the deck with bonuses works the order in which they will be applied is not important Then when we meet the hero card we just need to add to the answer the maximum of the available bonuses Constraints allow you to sort the current array with bonus values each time and remove the maximum element ,Here are two ways to implement what s given in the problem Take input as an array a 1 a 2 a 3 and sort it Output the middle element Write two if statements The first if a b text and a c text or a b text and a c output a Else if b a text and b c text or b a text and b c output b Else output c 
983,You are given an acyclic directed graph consisting of vertices and edges The graph contains no multiple edges and no self loops The vertex is called a if it has no incoming edges The vertex is called a if it has no outgoing edges These definitions imply that some vertices can be both source and sink The number of sources in the given graph is equal to the number of sinks in it and each of these numbers doesn t exceed The following algorithm is applied to the graph if the graph has no sources and sinks then quit choose arbitrary source arbitrary sink add an edge from to to the graph and go to step that operation pops out of sources and out of sinks Note that and may be the same vertex then a self loop is added At the end you check if the graph becomes strongly connected that is any vertex is reachable from any other vertex Your task is to check that the graph becomes strongly connected no matter the choice of sources and sinks on the second step of the algorithm ,Since the graph is acyclic then for every vertex there exists a path to some sink and to every vertex there exists a path from some source So our problem can be reduced to the following check that after running our algorithm all vertices from the initial set of sources and sinks belong to the same strongly connected component Let be the number of sources or sinks in the initial graph First of all let s run DFS or any other graph traversal from every source to form a set of reachable sinks for every source This part of solution has complexity of If is some set of sources of the original graph let be the set of sinks such that every sink from is reachable from at least one source from It s easy to see that there exists some set such that and then the answer is if we connected the sinks from with the sources from then any sink not belonging to would be unreachable from any sink belonging to Checking every possible set can be done in or in Let s prove that there is no such set then the answer is Let be an arbitrary sink of the original graph Also if is some set of sinks let be the set of sources containing every source directly connected to some sink from We can use mathematical induction to prove that every source and every sink is reachable from in the resulting graph Initially we state that is reachable from quite obvious If there is a set of sinks reachable from then either and the whole graph is reachable from or the number of sinks reachable from is at least so some set of sinks is reachable from So in fact checking every possible subset of sources is enough ,When a problem asks us to calculate the number of combinatorial objects that meet some constraints we can sometimes use inclusion exclusion formula Let s try to apply it in this problem We could use constraints that should not be violated The th constraint is formulated as follows there will be a constraint of this type for each Suppose we violated of these constraints and have chosen which constraints to violate then the number of colorings that meet these violations is for vertices the colors on them depend on some other independent vertices so we can assign only colors for independent vertices So the answer can be calculated as follows where is the number of ways to choose constraints to violate One initial guess how to calculate is that as it would be calculated in other more usual inclusion exclusion problems Unfortunately in this problem the constraints we violate are not independent For example if a vertex has several sons we can violate the constraint only on at most one edge leading from a vertex to its son simultaneously we cannot violate two or more such constraints Let s take care of this issue as follows we can write a dynamic programming of the form is the number of ways to process first vertices of the tree and choose exactly edges leading from these nodes to their sons so that no vertex has more than one edge leading to its sons chosen Then is exactly the number of ways to choose edges in the tree so that no vertex has more than one chosen edge leading to its sons and that will be equal to We can calculate this dynamic programming in a knapsack fashion in but it is too slow Instead let s optimize this knapsack DP with FFT for each vertex introduce a polynomial where is the number of children of the vertex Coefficients of this polynomial for the first vertex are the values of coefficients of the product of this polynomial with the polynomial for the second vertex are the values of and so on to obtain the values of we have to multiply all these polynomials and using FFT divide and conquer we can do it in 
984,You have a list of numbers from to written from left to right on the blackboard You perform an algorithm consisting of several steps steps are indexed On the th step you wipe the th number considering only numbers You wipe not one digit When there are less than numbers remaining you stop your algorithm Now you wonder what is the value of the th remaining number after the algorithm is stopped ,After some simulation of the given algorithm in your head on paper or on a computer we can realize that exactly all odd numbers are erased So all even numbers remain and the answer is ,The solution is simple let s create an integer variable initially set to that will contain the number of considered liked integers Let s iterate over all positive integers starting with Let s increase the variable only when the considered number is liked If the variable is equal to let s stop the iteration and output the last considered number Since the answer for is the count of considered numbers is at most so the solution will work on the specified limitations fast enough 
985,Codehorses has just hosted the second Codehorses Cup This year the same as the previous one organizers are giving T shirts for the winners The valid sizes of T shirts are either or from to followed by or For example sizes are valid and are not There are winners to the cup for both the previous year and the current year Ksenia has a list with the T shirt sizes printed for the last year cup and is yet to send the new list to the printing office Organizers want to distribute the prizes as soon as possible so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter Ksenia can t remove or add letters in any of the words What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one That means two lists are considered equal if and only if the number of occurrences of any string is the same in both lists ,At first let s remove all coinciding entries of both lists The most convinient way is to use map hashmap but it s not the only option Now divide entries into categories by their length You can notice that it takes exactly one second to remove an entry in each category to make it equal to an entry of the opposing list Thus the answer is Overall complexity or , Okay we need more definitions Here they come This way we can transform the formula for to the following Or even this since This is almost the convolution of the sequences and with a bit extra additional operations after the convolution so to compute the sequence we just need to compute the sequences and and then calculate their convolution with NTT All that s left is to multiply every element by the corresponding factorial But wait that s not so easy In order to calculate and we need to know Note that we can ignore the fact that and appear in the formula for since they are multiplied by so at least we don t have a dependency cycle Unfortunately we cannot just straightforwardly use convolution if we don t know the sequences and The model solution handles it using the following approach Let s generate and in parallel on the th iteration calculate then calculate and using it And we will calculate the convolution of the sequences and Suppose we want to calculate and the last time we calculated the convolution of and was after the iteration Back then we knew all elements from to and from to So the th term in the convolution of and contained the sum of over all such that and So in order to calculate we have to pick this value from the convolution and then add the sum of over all such that or and there are such values Suppose we compute the convolution every iterations Then the maximum value of is and every value of is calculated in We also make convolutions so the total complexity of this solution will be which can be transformed into if we pick 
986,Vova s family is building the Great Vova Wall named by Vova himself Vova s parents grandparents grand grandparents contributed to it Now it s totally up to Vova to put the finishing touches The current state of the wall can be respresented by a sequence of integers with being the height of the th part of the wall Vova can only use bricks to put in the wall he has infinite supply of them however Vova can put bricks on the neighboring parts of the wall of equal height It means that if for some the current height of part is the same as for part then Vova can put a brick there and thus increase both heights by 1 Obviously Vova can t put bricks in such a way that its parts turn out to be off the borders to the left of part of the wall or to the right of part of it Vova can also put bricks vertically That means increasing height of any part of the wall by 2 Vova is a perfectionist so he considers the wall completed when all parts of the wall has the same height the wall has no empty spaces inside it Can Vova complete the wall using any amount of bricks possibly zero ,Fairly enough solutions of both versions of the problem are pretty similar The major difference between them are the vertical bricks As you aren t required to minimize the total height you can work not with the heights themselves but with their parities instead Vertical brick now does nothing and horizontal brick changes the parity of neighbouring parts of the same parity Now imagine the following greedy solution While you have some segment of the same parities of even length fill it with horizontal bricks This operation merges this segment with one to the left and to the right If there is a single segment left then the answer is Otherwise it s The proof is left to the readers Implementing this as it is will be at best You ll need to keep the whole set of segments and the set with only even length ones But there exists more fun approach We don t even need the lengths of the segments just the parities of the lengths Then merging the even segment with something will just erase that segment and xor the length of the left and right ones Moreover you don t even need to erase the whole even segment you can do it brick by brick as this operations are now the same Let s simulate this with a stack When the new number comes push its parity to the stack If the topmost two elements of the stack have the same parity pop them both Now the answer is if at the end stack has no more than one element When I heard of this problem I actually had not that stack itself in mind but the correct bracket sequences Like let s define parity 0 as and and parity 1 as and Now the operations we perform with stack are greedily put the closing bracket if the last unclosed bracket was of the same type and put opening otherwise Then the stack will have like all the brackets which are still to be closed and you ll close them as early as you can This idea helped to both prove the correctness of algo and implement it Overall complexity ,We will process the elements of the sequence starting from the end of the sequence Each element will be divided by until it is less than If at some point it turns out that it is impossible to obtain the desired sequence 
987,You are asked to watch your nephew who likes to play with toy blocks in a strange way He has boxes and the th box has blocks His game consists of two steps he chooses an arbitrary box he tries to move blocks from the th box to other boxes If he can make the same number of blocks in each of other boxes then he will be happy otherwise will be sad Note that your nephew can only move the blocks from the chosen box to the other boxes he cannot move blocks from the other boxes You don t want to make your nephew sad so you decided to put several extra blocks into some boxes in such a way that no matter which box he chooses he won t be sad What is the minimum number of extra blocks you need to put ,Since nephew emptying the box he s chosen and wants to make all other box equal then it means that at least the of all array should be divisible by and the number of blocks in each other box should be at least ceiling function On the other side since nephew chooses not you then he can choose a box which is a maximum and since he makes empty the only box then the final number in each other block should be at least In total the resulting number of blocks in each of other boxes should be at least and we need to add at least elements to the initial array We can always reach this lower bound if we will put each block in the box with the current minimum number of blocks ,There are many possible solutions to this problem The simplest one is to notice that using several flats of size and one flat of some size possibly also possibly not we can get any equal to or The only numbers that don t belong to these lists are and and it s easy to see that there is no answer for that numbers So the solution is to try all possible sizes of one flat and if the remaining number of windows is non negative and divisible by then take the required number of three room flats 
988,You have an array where In one step you can choose two indices and and set ceiling function Your goal is to make array consist of ones and two in no more than steps Note that you don t have to minimize the number of steps ,There are many different approaches We will describe a pretty optimal one Let s solve the problem recursively Let s say we need to process segment If we don t need to do anything Otherwise Let s find the minimum such that The chosen is convenient because it allows making equal to in two divisions and it s the minimum number of divisions to get rid of Now we can firstly make all equal to in one step by division on and then make equal to with two divisions on As a result we ve spent operations and can solve our task recursively for In total we will spend and since the segments are like There will be at most segments and operations are enough for ,We can see that the answer is if and only if there are no more than two gaps of length between the given points If there is no gap the answer is obviously If there is only one gap of length we can just move the left or the right part of the set to this gap When there are two gaps we can move the part before the first gap to the right and the part after the second gap to the left Of course if there is a gap of length at least or multiple gaps with the total length we can t move the points from the left and the right part to satisfy the middle gap Time complexity 
989,Your favorite shop sells Kinder Surprise chocolate eggs You know that exactly stickers and exactly toys are placed in eggs in total Each Kinder Surprise can be one of three types it can contain a single sticker and it can contain a single toy and it can contain both a single sticker a single toy But you which type a particular Kinder Surprise has All eggs look identical and indistinguishable from each other What is the minimum number of Kinder Surprise Eggs you have to buy to be sure that whichever types they are you ll obtain at least one sticker and at least one toy Note that you do not open the eggs in the purchasing process that is you just buy some number of eggs It s guaranteed that the answer always exists ,Note that there are exactly eggs with only a sticker and analogically exactly with only a toy So we need to buy more than eggs or exactly ,Let s consider the optimal answer Suppose we take items of weight Let be the least common multiple of all weights that is Then we may represent as where Let s do the following trick we will take items of weight and all the remaining items of this weight can be merged into some items of weight Then we can write a brute force solution that picks less than items of each weight transforms the remaining ones into items of weight as much as possible and when we fix the whole subset adds maximum possible number of items of weight to the answer This works in something like operations which is too much How can we speed it up Rewrite it using dynamic programming When we have fixed the number of items we take from first sets the only two things that matter now are the current total weight of taken items and the number of items of weight we can use and it s obvious that the more items of weight we can use the better So let s write the following dynamic programming solution maximum number of items of weight we can have if we processed first types of items and current total weight is Note that the second dimension should have size 
990,You are given a string consisting of the characters and You need to replace all the characters with in the string by or so that the string becomes a palindrome and has characters and characters Note that each of the characters is replaced from the others A string of length is called a palindrome if the equality is true for all For example if and then you can replace the characters in the following ways For the given string and the numbers and replace all the characters with in the string by or so that the string becomes a palindrome and has characters and characters ,First let s find such positions i 1 le i le n such that s i ne symbols in symmetric positions are uniquely determined If s n i 1 then s n i 1 s i If s i ne s n i 1 then at the end we will not get a palindrome in any way so the answer is Note that after such a replacement the remaining characters are split into pairs except maybe the central one If the center character is then it is necessary to put the character if a is odd or if b is odd if neither a nor b is odd then the answer is Now the remaining characters are split into pairs i e if s i then s n i 1 This allows the remaining characters and to be replaced greedily If s i and a 1 then s i s n i 1 and decrease a for 2 If s i and b 1 then s i s n i 1 and decrease b for 2 Otherwise the answer is ,Let s find the first and the last position of characters denote them as and respectively Since the can t delete characters all characters between and will remain So we have to delete all characters between and 
991,Recenlty Luba got a credit card and started to use it Let s consider consecutive days Luba uses the card In the of th day a transaction occurs If then bourles are deposited to Luba s account If then bourles are withdrawn And if then the amount of money on Luba s account is checked In the of any of days Luba can go to the bank and deposit any integer amount of burles to her account But there is a limitation the amount of money on the account can never exceed Luba must not exceed this limit and also she wants that the days when the amount of money on her account is non negative It takes a lot of time to go to the bank so Luba wants to know the minimum number of days she needs to deposit some money to her account if it is possible to meet all the requirements Help her ,The following greedy solution works Firstly deposite money only on days with Secondly every time the balance is negative to the day with refill it to maximal possible value such that it won t go over later Days with can only lead to invalid state by going over card limit We can only add money to the balance Adding zero money in those days won t make invalid states if all were valid previously Finally if it s possible to get valid state in every day then it s possible to get it by refilling the same day the check happens For example you can make balance in those days Then you will never have negative balance there Though it s not the most optimal way Let be some value you deposite in some day with to pass all conditions till the next day with I state that function of number of game s moves dependancy on is monotonious Let s check it for some fixed Define minimum balance you will get on any suffix from now as Obviously taking will make it If it goes negative then you will need an extra move to finish the game Thus taking maximal will lead to the lowest score possible And last but not least realization part What will be the maximum possible value to deposite Actually it s such a value that optimal game after this will lead to maximum balance of in some day Thus you want to check what will be the maximum balance if you add zero money and take as Obviously if it s negative then output Naively this still works on per day and lead to overall Notice that by depositing you increase maximums on each suffix for now by So you can calculate it as you will do nothing and add sum of your s to get actual value You store prefix sum of up to in Then take maximum on suffix for every is the maxumum for from to I hope I made it clear enough DOverall comlpexity ,Let s find an answer for a little different version of the game Let s say that is the final score if the first player has stamina and the second has stamina The first player can either hit the ball or How to calculate Obviously and Otherwise the first player can either hit the ball then the player spent stamina and now it s to the second player to decide hit or lose So basically we moved to the state and the answer in this case is where or lose the play then the player doesn t spend any stamina but the opponent serve the ball He serves the ball spend stamina and return to the state where the first player decides hit or lose Formally the answer in this case is Looking at and one of transitions we can guess that and prove it by induction is either or but and and is better than so The final step is to note that since Alice starts the first play and serve ball the answer is 
992,You are given two integers and You can perform two types of operations Pay dollars and increase or decrease any of these integers by For example if and there are four possible outcomes after this operation Pay dollars and increase or decrease both integers by For example if and there are two possible outcomes after this operation Your goal is to make both given integers equal zero simultaneously i e There are no other requirements In particular it is possible to move from to Calculate the minimum amount of dollars you have to spend on it ,Let s presume that x ge y Then there are two cases in the problem If a a le b then we have to x y times perform the first operation So the answer is x y cdot a If a a b then we have to y times perform the second operation and pass the remaining distance by performing the first operation So the answer is y cdot b x y cdot a ,This task was inspired by an older edu task and another task proposed by RockyB Let s learn to solve the problem for at least one starting vertex for Alice Let this vertex be In general Alice s strategy is basically this run to some vertex as fast as possible and stay in it until Bob reaches Hesitation on a way to this vertex won t be optimal Visiting the same vertex multiple times won t as well I guess that can be proven more formally by analyzing the set of possible solutions after each move What properties should vertex have for Alice to be able to escape to it There shouldn t be a way for Bob to catch her midway However it s not necessary to check any midway intersections If Bob can catch her anywhere on a path she can also follow her to the end by moving the same path and catch her at the destination Thus this vertex should be further from any Bob s chips than from So you can precalculate the distance to the closest Bob s chip to each vertex Just push all chips to a queue and run a bfs We ve learned to solve the problem in for each vertex Just iterate over all vertices and take the maximum of over such of them that have greater than the distance from to Now the solution can go two ways You can stop thinking here and obtain an one or think more and get an The first one goes like that Notice that the function if the Alice can make at least moves from vertex is monotonous in regard to So we can binary search the answer The check query transforms to the following Consider all vertices with distance less or equal to from There should exist at least one vertex with value for the check to return true So at least the maximum value of them should be greater than That is basically a centroid exercise Let each centroid store such an array that is the maximum value of over all such that belong to this centroid s subgraph and are no further than distance from the centroid That array can be constructed in for all centroids in total You can easily see that the length of this array doesn t exceed the number of vertices in the subgraph of the corresponding centroid that is be definition For the query iterate over all centroids belongs to and check the value from some cell of each one s array For the second solution let s reverse the problem Consider the vertex Alice escapes to If there is a starting vertex no further than from it then the answer for can be updated with So we can update the subgraph of vertices with distance no more than with the maximum of their current answer and The solution will be almost the same centroid Iterate over all centroids belongs to and write into the cell of each one s array where is the distance from to this centroid Then build an array of prefix maximums over this array Finally for each collect the best answer over all centroids belongs to Overall complexity or 
993,You are creating a level for a video game The level consists of rooms placed in a circle The rooms are numbered through Each room contains exactly one exit completing the th room allows you to go the th room and completing the th room allows you to go the st room You are given the description of the multiset of chests the th chest has treasure value Each chest can be of one of two types regular chest when a player enters a room with this chest he grabs the treasure and proceeds to the next room mimic chest when a player enters a room with this chest the chest eats him alive and he loses The player starts in a random room with each room having an equal probability of being chosen The players earnings is equal to the total value of treasure chests he d collected before he lost You are allowed to choose the order the chests go into the rooms For each from to place the chests into the rooms in such a way that each room contains one chest chests are mimics the expected value of players earnings is possible Please note that for each the placement is chosen independently It can be shown that it is in the form of where and are non negative integers and Report the values of ,At first let s say that the expected value is equal to the average of total earnings over all positions and is equal to the sum of earnings over all positions divided by So we can trasition to minimizing the sum Let s learn how to solve the task for some fixed Fix some arrangement and rotate the rooms so that the last room contains a mimic So now you have regular chests then a single mimic regular chests single mimic regular chests single mimic All and Take a look at some of these intervals of length The last chest in the interval is taken from starting positions the second to last is taken times and so on Now let s find the optimal way to choose Fix some values of Take a look at the smallest of these values and the largest of them Let the values be and If they differ by at least then the smaller result can always be achieved by moving a regular chest from the larger one to the smaller one ProofConsider two sequences of coefficients for both intervals and However if you remove one chest then they will be equal to and If you only consider the difference between the numbers of both sequences then you can see that only coefficient got removed and coefficient was added So you can rearrange the chests in such a way that all chests are assigned to the same value and only the chest that was assigned to becomes assigned to thus decreasing the total value Now we have all set now The only thing left is to assign chests optimally Write down the union of all the coefficient sequences from all the intervals and sort them in the non decreasing order It s easy to show that the chests should be sorted in the non increasing order really classical thing you can try proving that by showing that any other arrangement can easily be improved once again That allows us to write a solution in Sort all the chests in the beginning after that for some multiply the value of the th chest by and sum up the results Finally let s speed this up with prefix sums Notice that the first values are multiplied by the second values by and so on If is not divisible by then the last block just has length smaller than Thus we can calculate the answer for some in And that s equal to Overall complexity ,Let s consider the optimal answer Suppose we take items of weight Let be the least common multiple of all weights that is Then we may represent as where Let s do the following trick we will take items of weight and all the remaining items of this weight can be merged into some items of weight Then we can write a brute force solution that picks less than items of each weight transforms the remaining ones into items of weight as much as possible and when we fix the whole subset adds maximum possible number of items of weight to the answer This works in something like operations which is too much How can we speed it up Rewrite it using dynamic programming When we have fixed the number of items we take from first sets the only two things that matter now are the current total weight of taken items and the number of items of weight we can use and it s obvious that the more items of weight we can use the better So let s write the following dynamic programming solution maximum number of items of weight we can have if we processed first types of items and current total weight is Note that the second dimension should have size 
994,Buses run between the cities and the first one is at 05 00 AM and the last one departs not later than at 11 59 PM A bus from the city departs every minutes and arrives to the city in a minutes and a bus from the city departs every minutes and arrives to the city in a minutes The driver Simion wants to make his job diverse so he counts the buses going towards him Simion doesn t count the buses he meet at the start and finish You know the time when Simion departed from the city to the city Calculate the number of buses Simion will meet to be sure in his counting ,Consider the time interval when Simion will be on the road strictly between cities Let s iterate over the oncoming buses Let be the time interval when the oncoming bus will be strictly between two cities If the intersection of that intervals is not empty than Simion will count that bus ,So I have two slightly different approaches to the problem There is a straightforward no brain one and a bit smarter one The minimum place is the same in both solutions For the th friend it s just if he never moves and otherwise Obtaining the maximum place is trickier For the first approach take a look what happens with some friend after he gets moved to the first position Or what s more useful what happens after he gets moved to the first position and before he gets moved again afterwards or the queries end Notice how every other friend is to the right of him initially Thus if anyone sends a message then the position of the friend increases by one However if that friend moves again nothing changes That should remind of a well known problem already You are just required to count the number of distinct values on some segments The constraints allow you to do whatever you want segtree with vectors in nodes Mo persistent segtree I hope ML is not too tight for that Unfortunately for each friend we have missed the part before his first move In that case for each you need to count the number of distinct values greater than as only friends with greater index will matter Luckily you can do it in a single BIT Let th its value be set to zero if the friend hasn t sent messages and one otherwise Let s process messages from left to right If the friend sends a message for the first time then update the BIT with in his index and update his answer with the suffix sum of values greater than his index Finally there are also friends who haven t sent messages at all As we have built the BIT already the only thing left is to iterate over these friends and update the answers for them with a suffix sum Overall complexity The attached solutions are and The second solution requires a small observation to be made Notice that for each friend you can only check his position right before his moves and at the end of the messages That works because the position can decrease only by his move so it s either increases or stays the same between the moves So let s learn to simulate the process quickly The process we are given requires us to move someone to the first position and then shift some friends Let s not shift And let s also reverse the list it s more convenient to append instead of prepending So initially the list is and the message moves a friend to the end of the list Allocate positions in a BIT for example Initially the first positions are taken the rest are free mark them with ones and zeroes respectively For each friend his position in this BIT is known initially they are because we reversed the list On the th message sent count the number of taken positions to the right of set in update and set in And don t forget to update each friend s maximum after all the messages are sent that is the number of taken positions to the right of his final one as well Overall complexity 
995,Alice and Bob are playing a game They have an array of positive integers of size Before starting the game Alice chooses an integer The game lasts for stages the stages are numbered from to During the th stage Alice must remove an element from the array that is less than or equal to After that if the array is not empty Bob must add to an arbitrary element of the array Note that both Alice s move and Bob s move are two parts of the same stage of the game If Alice can t delete an element during some stage she loses If the th stage ends and Alice hasn t lost yet she wins Your task is to determine the maximum value of such that Alice can win if both players play optimally Bob plays against Alice so he tries to make her lose the game if it s possible ,Note that if Bob has increased some element then Alice can t remove it on the next stages Obviously it is more profitable for Bob to prohibit the smallest element of the array Using this fact we can iterate over the value of and then simulate the game process To simulate the game we can maintain the set of elements that Alice can remove On the th stage Alice removes the maximum element such that if there are no such elements then Alice lost Bob always removes the minimum element of the set Thus the complexity of the solution is for each test case There is another possible solution we can notice that if Alice wins Bob will prohibit the elements on positions of the sorted array So Alice has to delete the next elements So if the segment of the sorted array can be deleted by Alice during the game phases she wins with this value of ,First of all let s understand how to solve the problem without upgrades To do this it is enough to compare two numbers and the number of attacks that the character needs to kill the monster and the number of attacks that the monster needs to kill the character respectively So if the first number is not greater than the second number then the character wins Note that the number of coins is not very large which means we can iterate over the number of coins that we will spend on weapon upgrades and the remaining coins will be spent on armor upgrades After that we can use the formula described above to check whether the character will win The complexity of the solution is 
996,You are given a number and an array obtained according to the following algorithm some array was guessed array was written to array i e The th element of the array is the sum of the numbers in the array i e The th element of the array was written some number i e The array was shuffled For example the array it could be obtained in the following ways and and For the given array find any array that could have been guessed initially ,What is the sum of all the elements in b This is twice the sum of all the elements in a x Denote by B the sum of all the elements of b Let s iterate over which of the array elements was added as the sum of the elements a let s denote for a Then x B 2 cdot A It remains to check that the element x is present in the array b this can be done using a hash table or a binary search tree ,Let s use dynamic programming to solve this task Obviously the of the number is determined by minimum of powers of and in the number Let be the maximal power of in the number and be the maximal power of Let be the maximum amount of twos we can collect by checking first numbers taking of them with total power of five equal to It is usually called the knapsack problem There are two types of transitions You can either take current element or skip it The answer will be maximum of for every Also keeping this many states can cause ML the first dimension should be stored in two layers and recalced on the fly Overall complexity 
997,You are given a string of lowercase Latin letters The following operation can be used select one character from to that occurs at least once in the string And replace all such characters in the string with the previous one in alphabetical order on the loop For example replace all with or replace all with And you are given the integer the maximum number of operations that can be performed Find the minimum lexicographically possible string that can be obtained by performing no more than operations The string is lexicographically smaller than the string if there exists an index such that but ,Greedy idea To minimize the string we will go from left to right and maintain a variable maximal character from which we will reduce everything to a Initially it is a and we spend of operations on it Then at the next symbol we can either reduce it to a in no more than operations or reduce to a the prefix we have already passed and minimize the next character in the remaining operations ,There are many different approaches to this problem but I think the model solution has the most elegant one First of all let s construct an RBS from the given string it always exists so it is always possible By calculating the number of opening brackets closing brackets and questions in the given string we can compute the number of question marks that should be replaced with opening brackets it is easy since exactly half of the characters in each RBS are opening brackets Then let s form the RBS greedily replace the first several question marks with opening brackets and all remaining ones with closed brackets Okay then what about finding a second RBS Recall that a bracket sequence is an RBS when for each of its positions the number of closing brackets before it is not greater than the number of opening brackets before it and these two values should be equal at the end of the sequence but it is less important now Consider the segment between the last question mark replaced with an opening bracket and the first question mark replaced by the closing bracket If we try to change the order of characters corresponding to question marks the balance on this segment will decrease at least by since at least one opening bracket to the left of it will become a closing bracket Is there a way to affect only this segment and change the balance on it only by Yes just swap the endpoints of this segment i e the last opening bracket that was a question mark and the first closing bracket that was also a question mark If it yields an RBS then the answer is Otherwise the answer is since any other permutation of characters that were replacing question marks will also decrease the balance on this segment by at least 
998,You are given a string consisting of lowercase Latin letters Let s define a substring as a contiguous subsegment of a string For example is a substring of it starts in position and ends in position but or aren t substrings of this string So the substring of the string from position to position is You have to choose one of the substrings of the given string and reverse it i e make to obtain a string that is lexicographically Note that it to obtain the minimum possible string If it is impossible to reverse some substring of the given string to obtain a string that is less print Otherwise print and suitable substring String is lexicographically less than string if either is a prefix of and or there exists such that and for any Here denotes the length of the string The lexicographic comparison of strings is implemented by operator in modern programming languages ,If the answer is then we always can reverse a substring of length So we need to check only pairs of adjacent characters in If there is no such pair of characters for all from to then the answer is Why is it so Consider the substring we have to reverse It is obvious that otherwise it is pointless to reverse this substring Then consider two cases then by transitivity and then we can go to a smaller substring otherwise and it means that we can take the substring ,We will act greedily we will make an array consisting of elements in which we will mark if the letter is already encountered in the string and otherwise In the variable we will store the length of the even string that can be obtained from We will go through the string by executing the following algorithm if mark if then we already have a pair of repeating characters to add to an even string add to the number and clear the array Clearing is necessary because both characters that will make up the next pair must be in the string after the current character In other words if the last character in the current pair was then the first character in the new pair can be where Then we calculate the answer as 
999,You are given a multiset consisting of integers You have to process queries of two types add integer into the multiset find the th order statistics in the multiset and remove it th order statistics in the multiset is the th element in the sorted list of all elements of the multiset For example if the multiset contains elements and then you have to find the rd element in which is If you try to delete an element which occurs multiple times in the multiset only one occurence is removed After processing all queries print number belonging to the multiset or say that it is empty ,First solution write some data structure that would simulate the operations as they are given for example a segment tree or a Fenwick tree Probably will require optimization since the limits are strict Second solution notice that we have to find only one number belonging to the multiset For example let s find the minimum element We can do it with binary search as follows let s write a function that for a given element tells the number of elements not greater than in the resulting multiset To implement it use the fact that all elements are indistinguishable and all elements are indistinguishable too so the multiset can be maintained with just two counters Okay how does this function help The minimum in the resulting multiset is the minimum such that this function returns non zero for it and since the function is monotonous we can find the answer with binary search ,Let s say we remove applications with and applications with Obviously among all the applications with it was necessary to take maximum in memory so we will clear the most memory Let s split all the applications into two arrays with and and sort them Then you need to take a prefix from each array Let s iterate over which prefix we take from the first array For it we can uniquely find the second prefix we remove applications until the sum exceeds If we now increase the first prefix by taking a new application then we don t need to take any applications in the second array This means that when the first prefix is increased the second one can only decrease To solve the problem you can use the two pointer method 
1000,Suppose you have an integer In one operation you can either set or set You are given integers What is the minimum number of operations you need to make each equal to ,Note that so you can make any value equal to by multiplying it by two times since So the answer for each value is at most Now let s note that there is always an optimal answer that consists of at first add one times then multiply by two times and is the minimum answer In other words let s just iterate over all and and check that The answer is minimum among them To prove that it s optimal to add at first and only then to multiply note that it s not optimal to add more than once after muptiplying can be replaced by So there is at most one between two but it s not optimal to make even one since we need to make divisible by and break divisibility There are many other approaches to this task except this one for example since you can write bfs to find the shortest paths from to all ,The problem directly tells you do solve some kind of Dynamic Connectivity Problem You could use the online approach with Link Cut Tree if you d had its implementation beforehand There is also a nice modification to the solution of the offline version of DCP check out the comment I d tell the solution which is probably the easiest to come up with and to code Let s recall the sqrt optimization method of solving DCP Process blocks of queries of size one at a time Split the edges into two groups The edges which were added on queries before the block and aren t touched by the queries in the block the edges modified by the queries in the block The first type of edges can be added to the graph before the block processing starts You can use DSU for that The second type contains no more than edges Maintain the list of those of them which exist in the graph On each ask query add them to graph then delete them This can be done explicitly by doing DFS only over these edges and the vertices which correspond to the connected components on the edges of the first type Implicitly doing DSU merges for these edges and rolling them back is a viable option as well costs extra log factor but has lower constant It s easy to see that it isn t hard to modify this solution to our problem Let s define the edges of the first type more generally the edges which were added on queries before the block and touched by the queries in the block So neither from the add query nor could be of the first type Now there might be edges of the second type in the list However that doesn t make the complexity any worse Process block the same way rebuild the DSU with the edges of the first type every queries The overall complexity can be if you use DFS or if you use DSU notice how the rebuild is and the query is and set the size of the block so that these parts are about the same 
1001,You have an array Let s call some subarray of this array a if it contains all integers from to exactly once For example array contains subarrays which are subpermutations You are asked to calculate the number of subpermutations ,At first let s represent permutations in the next form We assign to all numbers from to random 128 bit strings so the th number gets the string Then the permutation of length can be hashed as where is bitwise exclusive OR for example This representation is convenient because if we have two sets of numbers with a total number of elements equal to let s represent them as and we can easily check whether their union is a permutation of length condition must be hold Let s denote as Now let s iterate over position such that and calculate the number of permutations that contain this element To do it let s iterate over the right boundary and suppose that maximum element of permutation and its length at the same time is one of positions If it s true then the subpermutation should be on the positions And to check that this segment is a subpermutation we should just compare and Thus we will calculate all permutations in which the position of the maximum is to the right of the position of the To calculate all permutations we need to reverse array and repeat this algorithm and then add the number of ones in the array ,First of all if is even then there is no solution since the number of calls is always odd one call in the beginning and each call makes either or recursive calls Then if is odd let s try to start with a sorted permutation and try to unsort it Let s make a function that will do it When we unsort a segment we can either keep it sorted if we already made enough calls or make it non sorted and then call and if we need more calls When we make a segment non sorted it s better to keep its both halves sorted an easy way to handle this is to swap two middle element It s easy to see that the number of calls is equal to the number of calls to sort the resulting permutation so we can use this approach to try getting exactly calls 
1002, You are given a positive integer number You really love so you want to find the smallest greater than or equal to The positive integer is called if it can be represented as a sum of powers of i e no duplicates of powers of are allowed For example is a is a is a but is a you can t represent it as a sum of distinct powers of is a you can t represent it as a sum of distinct powers of for example the representations are invalid is also a you can t represent it as a sum of distinct powers of for example the representation is invalid Note that there exist other representations of and as sums of powers of but none of them consists of powers of For the given positive integer find such smallest that is a You have to answer independent queries ,Let s see the representation of in the ternary numeral system If it has no twos then the answer is Otherwise let be the maximum position of in the ternary representation Then we obviously need to replace it with and add some power of three to the right from it Let be the leftmost position of to the right from We can add and replace all digits from the position to the position with Then the resulting number will be because we replaced all twos with zeros and the minimum because in fact we added only one power of three and this power is the minimum one we could add Time complexity is per query ,Firstly let s parse both strings to four integers Just read them and then use some standard functions to transform them into integers or we can do it manually The second part is to obtain and Then let It is the answer We have to print and where is divided by rounding down and is modulo The only thing we should do more carefully is to print one leading zero before if it is less than and do the same for 
1003,You are given an array consisting of integers Initially you are standing at index and have a score equal to You can perform two kinds of moves move right go from your current index to and add to your score This move can only be performed if move left go from your current index to and add to your score This move can only be performed if You want to perform moves Also there should be no more than moves to the left among them What is the maximum score you can achieve ,Notice that your final position is determined by the number of moves to the left you make Let there be exactly moves to the left that leaves us with moves to the right However let s interpret this the other way You have pairs of moves right left to insert somewhere inside the sequence of moves to the right Easy to see that all the positions from to will always be visited And the extra pairs can also increase the score by visiting some positions for some from to Notice that it s always optimal to choose exactly the same for all the pairs right left And that should be such that is maximum possible You can implement this idea in a straightforward manner iterate over and calculate the sum of values from to and the maximum value of over from to That will lead to a solution per testcase You can optimize it to with prefix sums or with some clever order to iterate over It s also possible to iterate over the final position and restore the number of left moves required to achieve it Overall complexity or per testcase ,The first observation if all the ants are indistinguishable we can consider that there are no collisions and all the ants are passing one through another So we can easily determine the final positions of all the ants but we can t say which ant will be in which position The second observation the relative order of the ants will be the same all the time So to solve the problem we should only find the position of one ant after seconds Let s solve that problem in the following way Consider the positions of all the ants after time units Easy to see that by the first observation all the positions of the ants will left the same but the order will be different we will have some cyclic shift of the ants If we find that cyclic shift we can apply it times After that we will have only time units So the problem now is to model the process for the one ant with and time units Note that in that time interval the fixed ant will have no more than two collisions with each other ant So if we model the process with ignoring all collisions except the ones that include the fixed ant we will have no more than collisions Let s model that process with two queues for the ants going to the left and to the right Each time we should take the first ant in the queue with opposite direction process the collision and add that ant to the end of the other queue Hint you will have a problem when the fixed ant can be in two different positions at the end but it s easy to fix with doing the same with the next ant 
1004, You are given an array consisting of integers The value of the th element of the array is You are also given a set of segments The th segment is where You can choose some subset of the given set of segments and decrease values on each of the chosen segments by one For example if the initial array and the given segments are and then you can choose both of them and the array will become You have to choose some subset of the given segments in such a way that if you apply this subset of segments to the array and obtain the array then the value will be possible Note that If there are multiple answers you can print ,This tutorial is based on the previous problem easy version tutorial At first I want to say I know that this problem and this approach can be implemented in with segment tree So we iterate over all supposed maximums in the array and trying to apply all segments not covering our current element How do we can calculate the answer for element if this element is the supposed maximum Let s divide all segments we apply into two parts the first part consists of segments such that their right endpoints is less than the current position and the second part consists of segments such that their left endpoints is greater than the current position Then let s independently calculate answers for the left and for the right parts and merge them to obtain the answer I will consider only first part of the solution first part of segments because the second part is absolutely symmetric with it Let s maintain the minimum value on prefix of the array let it be and initially it equals to maintain the array of length initially its values are and means the answer if the th element of the array will be supposed maximum and the array of length where will be the value for which we decrease the th element in other words the number of segments we apply to the th element What do we do for the current position Firstly let s update the answer for it with the value in other words set Then let s apply all segments with right endpoints equals to the current position straight forward and update the value with each new value of covered elements Just iterate over all positions of each segment ends in the current position make and set And don t forget to update the value with the value after all changes because we need to update this value with each element not covered by segments too So then let s do the same from right to left and then will mean the answer if the th element is the supposed maximum in the resulting array Then we can find any position of the maximum in the array and apply all segments which don t cover this position What is time complexity of the solution above We iterate over all elements in the array this is and apply each segment in so the final time complexity is ,To begin with let s understand that an array is bipartite if and only if there is no decreasing subsequence of length in the array Now we can write dynamic programming is there an array of length such that is the maximum last element of a decreasing subsequence of length and is the maximum last element of a subsequence of length Note that Let s consider all possible transitions from the state if we are trying to put the number on the th position where if then the new state will be if then the new state will be if then such a transition is not valid because a decreasing subsequence of length is formed in the array With a naive implementation such dynamic programming works in We can note that for fixed values of and and it is enough for us to store only the minimum available value of So we can write dynamic programming which is defined similarly to the above but now instead of being Boolean stores the minimum value of or infinity if the state is not valid We have speeded up our solution to but it is still too slow To speed up the solution even more we have to look at the transitions in dynamics and notice that for a fixed either or is always equal to So we can rewrite our dynamic programming in the following form Here the flag says which of the numbers and is equal to and the flag is responsible for the sign of and the minimum value of or is stored in the value itself depending on Thus we got a solution with a linear running time In fact this solution can be simplified if we see the following relation the number we use on position is not less than and not greater than This allows us to get rid of one of the states in our dynamic programming altogether so we get an easier solution This optimization wasn t required to get AC but the code becomes shorter 
1005,Calculate the value of the sum As the result can be very large you should print the value modulo the remainder when divided by The modulo operator stands for the remainder after dividing by For example ,Unfortunately my solution for this problem had overflow bug It was fixed on contest Even so I hope you enjoyed the problem because I think it s very interesting Let s transform the sum Note that the last sum can be accumulated to only value because for all the values will be equal to Note in the last sum either or Let s carefully accumulate both cases The first sum can be simply calculated by iterating over all We will accumulate the second sum independently for all different values Firstly we should determine for which values we will have the value Easy to see that for the values from the interval Also we can note that the sum of the second factors in with fixed first factor can be calculaed in constant time it s simply a sum of arithmetic progression So we have solution with complexity ,Denote as the sum of first elements of and as the sum of first elements of These values can be calculated in with prefix sums The first solution is to use dynamic programming Let be the maximum value of if we placed the first elements of and the first elements of Transitions can be performed in we either place an element from then we go to and update it with or place an element from then we go to and update it with The answer is stored in and this solution works in The second solution observe that the sum of several first elements of is the sum of several first elements of and several first elements of So each prefix sum of and the answer itself is not greater than It s easy to show how to obtain exactly this answer let be the value of such that is maximized and be the value of such that is maximized Let s place the first elements of then the first elements of so the current sum is exactly and place all of the remaining elements in any possible order So the answer is This solution works in 
1006,The FB string is formed as follows Initially it is empty We go through all positive integers starting from in ascending order and do the following for each integer if the current integer is divisible by append to the end of the FB string if the current integer is divisible by append to the end of the FB string Note that if an integer is divisible by both and we append and then not in the opposite order The first characters of the FB string are the first comes from the integer the next character comes from the next comes from the integer and so on It s easy to see that this string is infinitely long Let be the th character of FB string so is is is is and so on You are given a string consisting of characters and or You have to determine whether it is a substring contiguous subsequence of the FB string In other words determine if it is possible to choose two integers and so that the string is exactly For example is a substring of the FB string if we pick and the string is exactly is a substring of the FB string if we pick and the string is exactly is not a substring of the FB string ,It s easy to see that the FB string repeats every characters after processing every numbers we will get the same remainders modulo and as numbers ago and when we process consecutive numbers we get characters So This means that if we want to find a substring no longer than characters in the FB string we don t need to consider more than first characters of the FB string the substring of length starting with the th character ends with the th character and we don t need to consider substrings starting on positions greater than So the solution is to generate at least first characters of the FB string and then check if the substring occurs in the generated string using a standard function like ,The general idea of the solution is to check that string contains some substring which is a permutation of The constraints were so low you could do it with any algorithm even per test case could pass The most straightforward way was to iterate over the substring of sort it and check if it s equal to sorted That s Next you could notice than only substrings of length matter and shave another off the complexity to get After that you might remember that the size of the alphabet is pretty low And one string is a permutation of another one if the amounts of letters a letters b and so on in them are equal So you can precalculate array where is equal to the amount of the th letter of the alphabet in Calculating this array for substrings will be each so that makes it Then notice how easy it is to recalculate the letter counts going from some substring to Just subtract from the amount of the th letter and add to the amount of the th letter Comparing two array every time will still lead to though The final optimization is to maintain the boolean array such that means that is equal to the current value of of the substring You are updating just two values of on each step thus only two values of might change You want all the values to be so keep the number of values in that array and say if that number is equal to That finally makes the solution per test case 
1007,A telephone number is a sequence of exactly digits where the first digit is For example the sequence is a telephone number but the sequences and are not You are given a string of length consisting of digits In one operation you can delete any character from string For example it is possible to obtain strings or from string You need to determine whether there is such a sequence of operations possibly empty after which the string becomes a telephone number ,To solve this problem we just need to find the first occurrence of the digit let s denote it as Now if then answer is otherwise ,Let s iterate from left to right over the digits of If the current digit is either or then we can set or correspondingly There are no better choices And if the current digit is then the optimal choise is to set and What happens after the first occurrence of Because of this choice is greater than even if all remaining digits in are So for each set and and print the answer The case without is even easier and in fact we handle it automatically 
1008,You are fighting with Zmei Gorynich a ferocious monster from Slavic myths a huge dragon like reptile with multiple heads Initially Zmei Gorynich has heads You can deal types of blows If you deal a blow of the th type you decrease the number of Gorynich s heads by there is the current number of heads But if after this blow Zmei Gorynich has at least one head he grows new heads If then Gorynich is defeated For example if then the number of heads changes to you cut heads off but then Zmei grows new ones but if then number of heads changes to and Zmei Gorynich is considered defeated Calculate the minimum number of blows to defeat Zmei Gorynich You have to answer independent queries ,Lets divide all dealing blows into two parts the last blow and others blows The last hit should be with maximum value of The others blows should be with the maximum value of So lets denote as and as Then if the we can beat Zmei Gorynich with one blow Otherwise if then we cannot defeat Zmei Gorynich Otherwise if and the answer is ,At any time we have three possible choices wait and shoot the first laser the second laser and both lasers Sometimes it makes sense to wait to both because you can deal more damage than you would do by shooting both lasers separately The first claim greedy won t work Maybe there is a sufficiently smart greedy we weren t able to come up with it The second claim bruteforce won t work The funny thing is that it actually worked on the constraints up to but again we couldn t code any sufficiently fast one for Thus let s try some dynamic programming Since all the times are huge we d want to avoid having them as the states What is small however is the durability of the enemy ship and the number of shots we have to make to destroy it Ideally we d like to have some the smallest time to deal damage to the enemy ship This way would be the answer Sadly it s not immediately clear how to get rid of reload times completely There might be states with different times until the charge with the same damage dealt and we don t know which of those we want to keep Thus let s make the dp state more complicated Let be the smallest time it takes to deal damage if the last shot was from both lasers at the same time This way we know the reload times of both lasers they are full and as moment has both lasers zero charged as if after a shot What are the transitions Well now we have to shoot each laser multiple times then wait until both are charged and shoot both Both lasers can now be considered independent of each other Let the time between the previous double shot and the next one be some value During this time it never made sense to wait until shooting each laser So we waited shot the first laser waited another shot again until we couldn t shoot anymore since the laser wouldn t recharge in time before the double shot Same for the second laser Notice that if both and then you could just decrease by and shoot each laser the same number of times Thus only that are multiples of either or are optimal Thus we can iterate over all possible waiting times Just iterate over and for all from to Having a fixed calculate the number of shots of each laser calculate the damage go into the corresponding dp state It could also happen that the last shot before destroying the ship wasn t a double one However it still follows the same ideas It means that each laser was shooting non stop until the ship was destroyed Thus the destruction time is still a multiple of either of the reload times Overall complexity 
1009,You are given two integers and In one move you can choose some from to and add it to or subtract it from In other words you choose an integer and perform or You may use values of in different moves Your task is to find the number of moves required to obtain from You have to answer independent test cases ,We can add or subtract until the difference between and becomes less than And if it is not after all such moves we need one additional move Let is the absolute difference between and The final answer is plus one if This formula can be represented as divided by rounded up in other words ,At first lets place gon in such way that the lowest side of gon is horizontal Now we can without loss of generality think that the square has horizontal and vertical sides and we just rotate gon around its center If we rotate the gon at angle then it will move on itself Moreover after rotating at angle we ll get left and right sides vertical and the following rotation is meaningless since it s the same as if we just swap and coordinates So we don t we to rotate more than Also we can see that while rotating the difference between max and min decreasing while the distance between max and min increasing The answer is obviously the maximum among these differences So for example we can just ternary search the optimal answer Or we can note that the behavior of differences is symmetrical just swap and coordinates so the answer is in the middle angle i e we just need to rotate gon at angle Finally observing several right triangles we can come up with quite an easy answer 
1010,Hideo Kojima has just quit his job at Konami Now he is going to find a new place to work Despite being such a well known person he still needs a CV to apply for a job During all his career Hideo has produced games Some of them were successful some were not Hideo wants to remove several of them possibly zero from his CV to make a better impression on employers As a result there should be no unsuccessful game which comes right after successful one in his CV More formally you are given an array of zeros and ones Zero corresponds to an unsuccessful game one to a successful one Games are given in order they were produced and Hideo can t swap these values He should remove some elements from this array in such a way that no zero comes right after one Besides that Hideo still wants to mention as much games in his CV as possible Help this genius of a man determine the maximum number of games he can leave in his CV ,The statement literally asks for the longest subsequence which looks like Let s find out how many zeroes will be in this sequence and then take all ones which come after the last zero On each step take the next zero from the beginning of the sequence and count ones after it Update answer with the maximum value You can precalc number of ones on suffix with partial sums but it was not necessary in this task Overall complexity naively or with partial sums ,Suppose the string consists of characters and each character is different from the adjacent ones so the string looks like or It s easy to see that we can t make more than operations each operation deletes at least two characters except for the case when the string consists of only one character And there is an easy way to perform exactly operations always choose the last character and delete it Okay what about the case when some adjacent characters in the string are equal It s never optimal to delete a character that s different from both adjacent characters since the second part of each operation always deletes the left block of equal characters this action merges two blocks so they will be deleted in one second part of the operation which decreases the total number of operations So we should always delete a character from a block with at least two equal characters From which of the blocks if there are more than one It s easy to see that we should choose a character from the leftmost such block since that block is the earliest to be deleted and if we want to make the same action later we might be unable to do it So the solution is greedy during each action we have to find the leftmost block consisting of at least equal characters and delete a character from it or the last character of the string if there are no such blocks Since the length of the string is up to and the number of operations is up to we should do it efficiently for example by storing the eligible blocks in some data structure 
1011,You are given string consists of opening and closing brackets of four kinds There are two types of brackets opening and closing You can replace any bracket by another of the same type For example you can replace by the bracket but you can t replace it by or The following definition of a regular bracket sequence is well known so you can be familiar with it Let s define a regular bracket sequence RBS Empty string is RBS Let and be a RBS then the strings are also RBS For example the string is RBS but the strings and are not Determine the least number of replaces to make the string RBS ,If we forget about bracket kinds the string s should be RBS otherwise the answer doesn t exist If the answer exists each opening bracket matches to exactly one closing bracket and vice verse Easy to see that if two matching brackets have the same kind we don t need to replace them In other case we can change the kind of the closing bracket to the kind of the opening So we can build some answer Obviously the answer is minimal because the problems for some pair of matching pairs are independent and can be solved separately The only technical problem is to find the matching pairs To do that we should store the stack of opening brackets Let s iterate from left to right in s and if the bracket is opening we would simply add it to the stack Now if the bracket is closing there are three cases 1 the stack is empty 2 at the top of the stack is the opening bracket with the same kind as the current closing 3 the kind of the opening bracket differs from the kind of the closing bracket In the first case answer doesn t exist in the second case we should simply remove the opening bracket from the stack and in the third case we should remove the opening bracket from the stack and increase the answer by one Complexity O n ,We can consider all tries independently During the th try we press first buttons so it makes on the prefix of length So the th character of the string will be pressed the number of plus times We can use sorting and some kind of binary search to find this number for each character but we also can build suffix sums to find all required numbers We can build suffix sums using the following code vector int cnt n for int i 0 i m i cnt p i for int i n 1 i 0 i cnt i 1 cnt i So as you can see the th element of will add in each position from to So we got what we need After that we can calculate the answer for each character in the following way vector int ans 26 for int i 0 i n i ans s i a cnt i 1 Time complexity or 
1012,You are given a number and an array In one move you can increase any of the array elements by one Formally you choose the index and with You can choose the same index multiple times for different moves Let s denote by and the number of numbers from the array that have remainders and when divided by the number respectively Let s say that the array has balanced remainders if and are equal For example if and then the following sequence of moves is possible initially and these values are not equal to each other Let s increase now the array and these values are not equal Let s increase now the array and these values are not equal Let s increase now the array and these values are equal to each other which means that the array has balanced remainders Find the minimum number of moves needed to make the array have balanced remainders ,Note that the numbers in the array are not important to us so initially we will calculate the values of Now applying a move for the number is equivalent to decreasing by and increasing by We will perform the following greedy algorithm while the array have no balanced remainders find any such that we apply the move for that is replace with and with It is easy to prove the correctness of this greedy algorithm by cyclically shifting the values and so that the first element is equal to the maximum of them ,Fairly enough solutions of both versions of the problem are pretty similar Read the second part of the previous tutorial first This problem can also be implemented in the strightforward manner The greedy solution now is searching for the first minimum in array and putting a brick in there If it s impossible then the answer is This can also be simulated with sets a bit more tedious but still ok and also Now back to the stack approach Here you can t go to parities of the numbers like tests and lead to different results You push the number itself However you will also need an extra condition on the stack You can t push to it the number greater than the current topmost element The only problem with this are maximums of array Obviously the resulting wall if the answer exists will be of height equal to the maximum initial height And it means that you shouldn t care about the ability to match all maximums in stack They way I suggest to take around the issue is to process separately each segment between two consecutive maximums One can easily prove the correctness of it by construction Overall complexity 
1013,Monocarp has forgotten the password to his mobile phone The password consists of digits from to note that it can start with the digit Monocarp remembers that his password had exactly two different digits and each of these digits appeared exactly two times in the password Monocarp also remembers some digits which were definitely not used in the password You have to calculate the number of different sequences of digits that could be the password for Monocarp s mobile phone i e these sequences should meet all constraints on Monocarp s password ,There are two possible solutions for the problem The first solution is basically brute force Each password can be obtained from an integer from to If the number is from to then it s already a password of length Otherwise you have to prepend it with enough zeros so that it becomes length Then you have to check if the password is valid First check if it consists of exactly two different digits make a set of all its characters set char in case of C for example and check its size Then check if the first digit of the password appears exactly twice It would mean that the other digits appears exactly twice as well Finally check if neither of the found digits are forbidden The second solution is based on combinatorics First choose the two digits that will appear in the password Since digits are prohibited the remaining are allowed Second choose the positions that will be taken by the first one The answer is the product of these two values ,The key fact in this problem is that the answer is not very large in fact it s not greater than 91 Why is it so Every 10 times we apply function f to our current number it gets divided by 10 at least and the number of such divisions is bounded as O log n So we can just do the following store all reachable numbers somewhere and write a loop that adds current number n to reachable numbers and sets n f n we should end this loop when n already belongs to reachable numbers The most convenient way to store reachable numbers is to use any data structure from your favourite programming language that implemenets a set but in fact the constrains were so small that it was possible to store all reachable numbers in an array 
1014, Polycarp is a very famous freelancer His current rating is units Some very rich customers asked him to complete some projects for their companies To complete the th project Polycarp needs to have at least units of rating after he completes this project his rating will change by his rating will increase or decrease by can be positive or negative Polycarp s rating should not fall below zero because then people won t trust such a low rated freelancer Is it possible to complete all the projects Formally write a program to check if such an order of the projects exists that Polycarp has enough rating before starting each project and he has non negative rating after completing each project In other words you have to check that there exists such an order of projects in which Polycarp will complete them so he has enough rating before starting each project and has non negative rating after completing each project ,Firstly let s divide all projects into two sets all projects giving us non negative rating changes let this set be and all projects giving up negative rating changes let this set be Firstly let s take all projects from the set How do we do that Let s sort them by in non decreasing order because each project we take cannot make our rating less and we need to consider them in order of their requirements If we can take the current project set and go further otherwise print and terminate the program Okay what do we do with the projects that has negative Firstly let s set This means the tighter requirement of this project obviously Then let s sort all projects in order of in non increasing order and go from left to right and take all of them If we cannot take at least one project the answer is Otherwise the answer is ,The problem can be solved in the following dynamic programming manner Let be the smallest number of hours Ivan can spend in university in the first days while having lessons skipped To calculate it we can store minimal number of hours Ivan is required to spend in the th day so that he attends lessons Then we can iterate over all lengths from to and update with Precalc works in and dp can be processed in 
1015,You are given a string consisting only of characters and You perform some process with this string This process can be described by the following pseudocode Note that the denotes infinity and the characters of the string are numbered from to You have to calculate the value of the after the process ends ,Let s replace all with and all with After that let s create a preffix sum array Also lets create array such that is equal minimum index such that if there is no such index Let s consider the first iteration of loop If then process ends and Otherwise the condition fulfilled then the value of will be equal to So the value of is equal to after first iteration Now let s consider the second iteration of loop If then process ends and Otherwise the condition fulfilled then the value of will be equal to So the value of is equal to after second iteration In this way we can calculate the value of after the process ends ,First of all let s rewrite the answer using expectation linearity The expected number of students who read their respective messages is equal to where is a random value which is if the th student reads the message and if the th student doesn t do it Let s analyze the expected value of Suppose Monocarp pins the messages There are three cases if then the th student won t read the message so if and then the th student will definitely read the message so if and then If we iterate on the number of messages we pin we can calculate the sum of for each message considering that we pin it sort all of the messages and pick best of them So we have a solution working in The only thing we need to improve this solution sufficiently is the fact that we don t have to consider the case Since every is not greater than the sum of for a message in the case is the same as this sum of in the case but multiplied by the coefficient and we pick best values their sum multiplied by is not greater than the sum of best values The same holds for and greater 
1016,As the name of the task implies you are asked to do some work with segments and trees Recall that a tree is a connected undirected graph such that there is exactly one simple path between every pair of its vertices You are given segments for every It is guaranteed that all segments endpoints are integers and all endpoints are unique there is no pair of segments such that they start in the same point end in the same point or one starts in the same point the other one ends Let s generate a graph with vertices from these segments Vertices and are connected by an edge if and only if segments and intersect and neither of it lies fully inside the other one For example pairs and will induce the edges but pairs and will not Determine if the resulting graph is a tree or not ,The main idea of the solution is to find a linear number of intersections of segments Intersections can be found with sweep line approach We will maintain a set for the endpoints open segments When we add a segment we find all segments which intersect with it that is all segments that end earlier than it Obviously if the number of intersections are greater than then the answer is So as soon as we find intersections we stop our algorithm After that it is necessary to check the connectivity of the resulting graph You can use DFS or DSU to do this ,Let s understand when two points and coincide Let Then they are coincide when Otherwise these two points will never coincide and the distance between them will only increase So we need to consider only the initial positions of points Let s sort all points by and consider them one by one from left to right Let the th point be the rightmost in the pair of points that we want to add to the answer We need to find the number of points such that and and the sum of for such points as well We can do this using two BITs Fenwick trees if we compress coordinates all values and do some kind of scanline by values Let the number of such points be and the sum of coordinates of such points be Then we can increase the answer by and add our current point to the Fenwick trees add to the position in the first tree and to the position in the second tree When we want to find the number of required points and the sum of its coordinates we just need to find the sum on the prefix two times in Fenwick trees Note that you can use any online logarithmic data structure you like in this solution such as treap and segment tree There is also another solution that uses pbds Let s do the same thing but there is one problem Such data structure does not have sum on prefix function so we have to replace it somehow To do this let s calculate only part when we go from left to right Then let s clear our structure go among all points again but from right to left and calculate the same thing but with the opposite sign find the number of points such that and When we go from right to left we need to decrease the answer by It is some kind of contribution to the sum technique Time complexity 
1017,Suppose you have two strings and and their length is equal You may perform the following operation any number of times choose two different characters and and replace every occurence of in both strings with Let s denote the between strings and as the minimum number of operations required to make these strings equal For example if is and is the between them is we may replace every occurence of with so becomes and then we may replace every occurence of with so both strings become You are given two strings and For every substring of consisting of characters you have to determine the between this substring and ,Unfortunately it seems we failed to eliminate bitset solutions The approach in our model solution is the following Firstly let s try to find some naive solution for calculating the distance between two strings We may build an undirected graph where vertices represent letters and edges represent that one letter must be transformed into another Then all letters in the same component should become one letter so the answer is the number of distinct letters minus the number of components Then let s get back to original problem For every substring of we have to find which letters have to be merged to make it equal with This can be done with the help of FFT to find all positions in substrings of with character that coincide with occurences of in we may compute a convolution of two following arrays set to every position in where occurs and to every position in where occurs all other elements should be After trying these convolutions for every pair of different characters we compute the answer for every substring using DFS or any other method ,Let s consider a very special case of equal distances What if all distances were equal to It implies that if some letter appears exactly twice both occurrences are placed right next to each other That construction can be achieved if you sort the string for example first right down all letters a then all letters b and so on If a letter appears multiple times all its occurrences will be next to each other just as we wanted Overall complexity or per testcase 
1018,Polycarp is practicing his problem solving skill He has a list of problems with difficulties respectively His plan is to practice for exactly days Each day he has to solve at least one problem from his list Polycarp solves the problems in the order they are given in his list he cannot skip any problem from his list He has to solve all problems in exactly days Thus each day Polycarp solves a contiguous sequence of consecutive problems from the start of the list He can t skip problems or solve them multiple times As a result in days he will solve all the problems The of the th day of Polycarp s practice is the maximum among all the difficulties of problems Polycarp solves during the th day i e if he solves problems with indices from to during a day then the of the day is The of his practice is the sum of the over all days of his practice You want to help Polycarp to get the maximum possible over all valid ways to solve problems Your task is to distribute all problems between days satisfying the conditions above in such a way that the is maximum For example if and one of the possible distributions with maximum is Here the equals ,The maximum possible you can obtain is the sum of the largest values of the given array This is obvious because we can always separate these maximums and then extend the segments corresponding to them to the left or to the right and cover the entire array I suggest the following extract largest values of the given array and place a separator right after each of them except the rightmost one Overall complexity is ,Let s denote for the sum of all the elements of the array and for the array of its prefix sums If the drive runs for seconds the sum is This formula immediately shows that if and then the disk will run indefinitely Otherwise the answer exists The disk cannot make less than full spins otherwise the required amount simply will not be achived The disk can t make more spins either because when it reaches the position of the maximum prefix sum will already be achived So we know how to determine the number of full spins of the disk Let s make these spins Now we have a new problem given find the first position in the array such that This problem can be solved using binary search If is not sorted into the array that is there is such that then can simply be thrown out of the array the answer will never be reached on it 
1019,Maxim wants to buy some games at the local game shop There are games in the shop the th game costs Maxim has a wallet which can be represented as an array of integers His wallet contains bills the th bill has value Games in the shop are ordered from left to right Maxim tries to buy game in that order When Maxim stands at the position in the shop he takes the first bill from his wallet if his wallet is empty then he proceeds to the next position immediately and tries to buy the th game using this bill After Maxim tried to buy the th game he leaves the shop Maxim buys the th game if and only if the value of the first bill which he takes from his wallet is greater or equal to the cost of the th game If he successfully buys the th game the first bill from his wallet disappears and the next bill becomes first Otherwise Maxim leaves the first bill in his wallet and proceeds to the next game For example for array and array the following process takes place Maxim buys the first game using the first bill its value is the bill disappears after that the second bill with value becomes the first one in Maxim s wallet then Maxim doesn t buy the second game because the same with the third game then he buys the fourth game using the bill of value the third bill becomes the first one in Maxim s wallet and buys the fifth game using the bill of value Your task is to get the number of games Maxim will buy ,Let s keep the variable which will represent the number of games Maxim buy Initially Assume that arrays and are 0 indexed Then let s iterate over all and if and make So will be the answer after this cycle ,The maximum number of rounds Alice can win is pretty easy to calculate greedily What about the minimum number of rounds It can be shown that if we started using some combination we are better to end it before using the other one There are six possible combinations to not win the round and and and and and and We can iterate over all permutations of these combinations there are possible permutations and greedily apply them Use the first while it is possible then the second and so on and find the best answer It is also possible that the order of these combinations does not matter but we didn t prove that fact Time complexity 
1020,You are given a weighted tree consisting of vertices Recall that a tree is a connected graph without cycles Vertices and are connected by an edge with weight You are given queries The th query is given as an integer In this query you need to calculate the number of pairs of vertices such that the maximum weight of an edge on a simple path between and doesn t exceed ,Let s carry the value that means the answer for the current set of edges Initially it is Let s sort all edges by their weight and all queries by their weight also both in non decreasing order Let s merge components of the tree using disjoint set union We need to carry sizes of components also it is easy if we use Then let s iterate over all queries in order of non decreasing their weights If the current query has weight then let s merge all components connected by edges with weight When we merge two components with sizes and the answer changes like that The value equals to It is so because we subtract all old paths corresponding to these components and add all new paths in the obtained component So the answer for the current query will be after all required merges Time complexity ,If the answer exists you can hang the tree by some vertex such that the distances and can be expressed through the sums of distances to vertices and Then from the system of equations we express the required values of distances to vertices and construct a suitable tree If the distance to a vertex is then that vertex is the root There cannot be two roots nor can there be negative distances If none of the vertices of is the root then make vertex the root Next we build the required tree add the required number of unique vertices on the path from the root to vertices Note also that if the sum of distances is greater than or equal to then we cannot build the tree either The remaining vertices can be simply joined to the root 
1021,You are asked to build an array consisting of integers each element should be from to The array should be non decreasing for all from to You are also given additional constraints on it Each constraint is of one of three following types be equal to should be less than or equal to should be greater than or equal to Build any non decreasing array that satisfies all constraints or report that no such array exists ,Imagine there were no constraints of the second or the third types Then it would be possible to solve the problem with some greedy algorithm Unfortunately when both these constraints are present it s not immediately clear how to adapt the greedy Dynamic programming is probably also out of question because you can t maintain all possible cuts between equal values on each prefix Thus let s try to make a graph problem out of this Who knows maybe a flow or something else could work Create nodes for each position Let the th of them on the th position represent the condition of kind is equal to Then all constraints can be described as edges on this graph Binary variables restrictive edges Surely this is 2 SAT Connect the pairs of values that satisfy each constraint Add the edges between the adjacent positions to enforce the restriction on the non decreasing order Prohibit each position to be assigned to multiple values Force each position to be assigned at least one value Huh it s not that easy That s where the 2 SAT idea fails We want the conditions of form But that is not allowed since 2 SAT has to have two variables in a clause That s where the main idea of the problem comes up Instead of making our nodes represent let s make them and try building the graph again If then all nodes for will be true and the rest will be false So if is false then is false That will enforce the validity of the nodes themselves First the order If is true then is true The first type of constraints is basically the same as or For our conditions it s rather not or The second type of constraints Let be greater than or equal to some Then for this constraint to hold should be no greater than Thus if is true then should be false Same for and swapped The third type of constraints is similar Let be less than or equal to some Then for this constraint to hold should be greater than or equal to Thus if is false then should be true Same for and swapped And that s it Solve the 2 SAT and restore the answer I can advise making not but actually nodes for and force the values to be between and That will simplify the checks while adding the constraints Overall complexity ,If and then the answer is If and or and then answer is or respectively And in the other case when and the answer is 
1022,You are playing one RPG from the 2010s You are planning to raise your smithing skill so you need as many resources as possible So how to get resources By stealing of course You decided to rob a town s blacksmith and you take a follower with you You can carry at most units and your follower at most units In the blacksmith shop you found swords and war axes Each sword weights units and each war axe units You don t care what to take since each of them will melt into one steel ingot What is the maximum number of weapons both swords and war axes you and your follower can carry out from the shop ,First iterate on the number of swords we will personally take Then we should greedily take as many war axes as we can until we run out of money At this point our follower needs to take as many items as possible They can do this by greedily taking whichever of swords or war axes are cheaper until they run out followed by taking the more expensive of the two Code 90918673 ,Note that there are exactly eggs with only a sticker and analogically exactly with only a toy So we need to buy more than eggs or exactly 
1023,Your friend is developing a computer game He has already decided how the game world should look like it should consist of locations connected by passages The passages are designed in such a way that it should be possible to get from any location to any other location Of course some passages should be guarded by the monsters if you just can go everywhere without any difficulties then it s not fun right Some crucial passages will be guarded by really fearsome monsters requiring the hero to prepare for battle and designing his own tactics of defeating them commonly these kinds of monsters are called And your friend wants you to help him place these bosses The game will start in location and end in location but these locations are not chosen yet After choosing these locations your friend will place a boss in each passage such that it is impossible to get from to without using this passage Your friend wants to place as much bosses as possible because more challenges means more fun right so he asks you to help him determine the maximum possible number of bosses considering that any location can be chosen as or as ,It s quite obvious that we can place bosses only on the bridges of the given graph if an edge is not a bridge then removing it doesn t make the graph disconnected so there still exists a path between any pair of vertices And if we fix two vertices and and then find some simple path between them then we will place the bosses on all bridges belonging to this path since the set of bridges would stay the same no matter which simple path between and we choose If we find bridges in the given graph and compress all 2 edge connected components two vertices belong to the same 2 edge connected component iff there exists a path between these vertices such that there are no bridges on this path into single vertices we will obtain a special tree called bridge tree Every edge of a bridge tree corresponds to a bridge in the original graph and vice versa Since we want to find the path with maximum possible number of bridges we only need to find the diameter of the bridge tree and this will be the answer to the problem ,Suppose we want to minimize the number of traversed edges of the second type edges that connect odd vertices to each other or even vertices to each other and minimizing the length of the path has lower priority Then we exactly know the number of edges of the second type we will use to get from one vertex to another and when building a path we each time either jump from one tree to another using an edge of the first type or use the only edge of the second type that brings us closer to the vertex we want to reach So in this case problem can be solved either by binary lifting or by centroid decomposition The model solution uses the latter merge the graph into one tree vertices and of the original graph merge into vertex in the tree build its centroid decomposition and for each centroid and vertex of its centroid subtree calculate the length of the shortest path from and to and using dynamic programming Then the answer for each pair of vertices and may be calculated as follows find the deepest centroid controlling the both vertices and try either shortest path or shortest path But this solution won t work in the original problem because sometimes we want to choose an edge of the second type that leads us further from the vertex we want to reach in the merged tree but allows us to use a cheaper edge of the first type to jump from one tree to another Let s make this situation impossible We may change the weights of all edges of the second type so that the weight of edge between and becomes the length of the shortest path between and This can be done by solving a SSSP problem build a graph of vertices where each vertex from to represents the path between from and Add a directed edge with weight equal to going from vertex to vertex And finally for every pair such that and are connected by edge of weight and and are connected by edge of weight add an undirected edge connecting and in the new graph its weight should be Then the distance from to in this graph will be equal to the length of the shortest path from to in the original graph 
1024,Adilbek s house is located on a street which can be represented as the OX axis This street is really dark so Adilbek wants to install some post lamps to illuminate it Street has positions to install lamps they correspond to the integer numbers from to on the OX axis However some positions are blocked and no post lamp can be placed there There are post lamps of different types which differ only by their power When placed in position post lamp of power illuminates the segment The power of each post lamp is always a positive integer number The post lamp shop provides an infinite amount of lamps of each type from power to power Though each customer is only allowed to order post lamps of type Post lamps of power cost each What is the minimal total cost of the post lamps of type Adilbek can buy to illuminate the entire segment of the street If some lamps illuminate any other segment of the street Adilbek does not care so for example he may place a lamp of power in position even though its illumination zone doesn t completely belong to segment ,Let s start with learning how to place lamps of fixed power to cover the segment with the minimal number of them The following greedy strategy works find the rightmost non blocked position that is covered by lamps and place lamp there until either everything is covered or rightmost free position is to the left of the last placed lamp Initially you only consider to be covered Function the minimal number of post lamps to cover segment is clearly monotonous thus you want to update states as early as possible Okay now you iterate over all and update the answer with the results multiplied by cost Now why will this work fast You obviously precalculate the rightmost free position for each prefix segment If there are any free positions to the right of last placed lamp then the rightmost of them will always be the rightmost for the entire prefix segment Finally any two consecutive iterations of the algorithm will either move you by positions or return This can be easily proven by contradiction Overall complexity as you do about steps for each and that is a common series sum ,Firstly we obviously don t need coordinates at all because we can place both platforms at Let s sort all coordinates in non decreasing order Calculate for each point two values and where is the number of points to the left from the point including that are not further than from the th point i e the number of such points that And is the number of points to the right from the point including that are not further than from the th point Both these parts can be done in using two pointers Then let s build suffix maximum array on and prefix maximum array on For just iterate over all from to and do For just iterate over all from to and do The question is what What did we do We did the following thing the answer always can be represented as two non intersecting segments of length such that at least one endpoint of each segment is some input point Now let s fix this border between segments Iterate over all from to and update the answer with So we took segment that starts at some point to the left from including and goes to the left and took some segment that starts further than including and goes to the right With this model we considered all optimal answers that can exist Time complexity 
1025,Slavic has an array of length consisting only of zeroes and ones In one operation he removes either the first or the last element of the array What is the minimum number of operations Slavic has to perform such that the total sum of the array is equal to after performing all the operations In case the sum can t be obtained after any amount of operations you should output ,Note that the remaining array is a subarray of the original array There are many ways to approach the problem Here is one solution which the main solution uses Compute prefix sums on the array so we can find out the value of quickly Let s iterate through the left endpoint from to Afterwards we can binary search on the smallest value of such that since this sum is strictly increasing The time complexity is ,We can see that because the multiplier in the formula is the position of the number and we want to minimize the sum of such formulas the following greedy solution comes up to mind because we want to count greater values as earlier as possible let s sort the array in non increasing order saving initial indices of elements calculate the answer and print the permutation of indices in order from left to right 
1026,You are given one integer number Find three such that and or say that it is impossible to do it If there are several answers you can print any You have to answer independent test cases ,Suppose Let s try to minimize and maximize Let be the minimum divisor of greater than Then let be the minimum divisor of that isn t equal and If isn t equal and then the answer is otherwise the answer is Time complexity per query ,As you can see from the example the maximum answer doesn t exceed So we can run some precalculation before all queries which will find all less than The number is if it has no in the ternary numeral system When you read the next query you can increase until you find some precalculated Time complexity is You also can implement the solution which doesn t use any precalculations and just increase each time in each query and checks if the number is inside this loop Then time complexity will be 
1027,You are given two integers and In one turn you can do one of the following operations Take an integer and and replace with Take an integer and and replace with Your goal is to make equal to using exactly turns For example the numbers and can be made equal in moves divide by divide by divide by divide by For the given numbers and determine whether it is possible to make them equal using exactly turns ,Let s denote for the maximum number of moves for which the numbers and can be made equal It is easy to understand that the number of moves is maximum when and each time we divided or by a prime number That is sum of exponents of prime divisors of sum of exponents of prime divisors of Let s denote by the minimum number of moves for which the numbers and can be made equal Consider a few cases If then If or then Otherwise then Then the answer is possible in the following cases and and or and ,Let s use binary searching to find the answer Denote as the number of positive integers such that and the answer is the smallest integer such that We may use for example as the right border of segment where we use binary searching although the answers are a lot smaller than this number for it is obvious that will be really large for any from How can we calculate fastly Let s factorize and use inclusion exclusion Let be a subset of the set of prime divisors of and be the product of all numbers from For each possible subset we have to add to the result since there are exactly integers from divisible by every prime from Since any number from has at most prime divisors there are at most subsets to process 
1028,Polycarp is going to participate in the contest It starts at and ends at It is guaranteed that the contest lasts an even number of minutes i e where is modulo It is also guaranteed that the entire contest is held during a single day And finally it is guaranteed that the contest lasts at least two minutes Polycarp wants to know the time of the midpoint of the contest For example if the contest lasts from to then the answer is if the contest lasts from to then the answer is ,Firstly let s parse both strings to four integers Just read them and then use some standard functions to transform them into integers or we can do it manually The second part is to obtain and Then let It is the answer We have to print and where is divided by rounding down and is modulo The only thing we should do more carefully is to print one leading zero before if it is less than and do the same for ,Let s use the greedy solution we will go through the digits in decreasing order If the sum of we need to dial is greater than the current digit we add the current digit to the end of the line with the answer Note that in this way we will always get an answer consisting of the minimum possible number of digits because we are going through the digits in descending order Suppose that the resulting number is not optimal Then some digit can be reduced and some digit that comes after it can be increased in order to save the sum we can not increase the digit before it as then we get a number greater than the current one Two variants are possible We want to increase the digit to but then it becomes equal to the digit following it or exceeds the value Then we can t increment that digit Otherwise in the first step we can get instead of but since we are going through the digits in decreasing order we cannot get the value of in that case Contradiction 
1029, You are messaging in one of the popular social networks via your smartphone Your smartphone can show at most most recent conversations with your friends Initially the screen is empty i e the number of displayed conversations equals Each conversation is between you and some of your friends There is at most one conversation with any of your friends So each conversation is uniquely defined by your friend You suddenly have the ability to see the future You know that during the day you will receive messages the th message will be received from the friend with ID If you receive a message from in the conversation which is currently displayed on the smartphone then nothing happens the conversations of the screen do not change and do not change their order you read the message and continue waiting for new messages Otherwise i e if there is no conversation with on the screen Firstly if the number of conversations displayed on the screen is the last conversation which has the position is removed from the screen Now the number of conversations on the screen is guaranteed to be less than and the conversation with the friend is not displayed on the screen The conversation with the friend appears on the first the topmost position on the screen and all the other displayed conversations are shifted one position down Your task is to find the list of conversations in the order they are displayed on the screen after processing all messages ,The solution to this problem is just the implementation of what is written in the problem statement Let s carry the array which shows the current smartphone screen When we receive the new message from the friend with ID let s do the following sequence of moves Firstly let s try to find him on the screen If he is found just do nothing and continue Otherwise let s check if the current number of conversations is If it is so then let s remove the last conversation Now the number of conversations is less than and the current friend is not shown on the screen Let s insert him into the first position After processing all messages the answer is just the array ,Let s fix the number of leg length increases we do Let the final length be k Notice that for all i from 1 to k there is some time when the length is exactly i Thus we can perform jumps of form x y rightarrow x i y or x y rightarrow x y i What s the jumping strategy then Obviously we can solve the problem independently for a and b Consider a We would love to just make jumps of length k as that s the maximum possible length Unfortunately that only works when a is divisible by k Otherwise we are left with some remainder which is smaller than k But we have already figured out how to jump to any value from 1 to k So that only adds another jump You can say that the total number of jumps is lceil frac a k rceil Same for b Finally for a fixed k the answer is lceil frac a k rceil lceil frac b k rceil k 1 The constraints tell us that we are not allowed to iterate over all k from 1 to max a b It feels like huge k will never be optimal but let s try to base our intuition on something Try to limit the options by studying the formula Let s simplify Assume a b and also get rid of the ceil Not like that changes the formula a lot Now it becomes 2 frac a k k 1 We can see that when we increase k 2 frac a k becomes smaller and k 1 becomes larger However we care more about how fast they become smaller and larger You can just guess or write down the derivative explicitly and figure out that the first term shrinks faster than the second term grows until around sqrt a cdot c for some constant c apparently c sqrt 2 Thus their sum decreases until then then increases Thus you can search for the best k around sqrt a or sqrt b or sqrt max a b It doesn t really matter since for implementation you can basically try all k until around 10 5 which is safely enough 
1030,Polycarp has recently got himself a new job He now earns so much that his old wallet can t even store all the money he has Berland bills somehow come in lots of different sizes However all of them are shaped as rectangles possibly squares All wallets are also produced in form of rectangles possibly squares A bill fits into some wallet if either and or and Bills can overlap with each other in a wallet and an infinite amount of bills can fit into a wallet That implies that all the bills Polycarp currently have fit into a wallet if every single one of them fits into it independently of the others Now you are asked to perform the queries of two types Polycarp earns a bill of size Polycarp wants to check if all the bills he has earned to this moment fit into a wallet of size It is guaranteed that there is at least one query of type before the first query of type and that there is at least one query of type in the input data For each query of type print if all the bills he has earned to this moment fit into a wallet of given size Print otherwise ,Let s find the smallest wallet to fit all bills One its side is the maximum side of any bill Now we orient the bills in such a way that their longer side is put against this side of the wallet The second side of the wallet is the maximum of the other sides More formally for set of bills for each the minimum wallet is The minimum wallet fits all sufficient wallets So the solution is maintaining the maximum of all and and checking if and Choose your i o functions wisely Overall complexity ,Let s solve the problem with just one query Greedily we should pick the candies with the most sugar first since there is no benefit to picking a candy with less sugar So the solution is as follows sort the candies in descending order and then find the prefix whose sum is This is per query which is too slow for us To speed it up notice that we just need to find a prefix sum at least So if we compute the prefix sums of the reverse sorted array we need to find the first element that is at least Since all elements of are positive the array of prefix sums is increasing Therefore you can binary search the first element This solves the problem in per query Total time complexity 
1031,You are given points with integer coordinates on a coordinate axis The coordinate of the th point is All points coordinates are distinct and given in strictly increasing order For each point you can do the following operation take this point and move it by to the left or to the right i e you can change its coordinate to or to In other words for each point you choose separately its new coordinate For the th point it can be either or Your task is to determine if you can move some points as described above in such a way that the new set of points forms a of integers i e for some integer the coordinates of points should be equal to Note that the resulting points should have coordinates You have to answer independent test cases ,We can see that the answer is if and only if there are no more than two gaps of length between the given points If there is no gap the answer is obviously If there is only one gap of length we can just move the left or the right part of the set to this gap When there are two gaps we can move the part before the first gap to the right and the part after the second gap to the left Of course if there is a gap of length at least or multiple gaps with the total length we can t move the points from the left and the right part to satisfy the middle gap Time complexity ,One of the possible answers is always a pair of endpoints of the given segments So we can add all endpoints to the array and iterate over all pairs of elements of this array and check if the current pair is suitable or not 
1032,You are given a tree connected graph without cycles consisting of vertices The tree is unrooted it is just a connected undirected graph without cycles In one move you can choose exactly leaves leaf is such a vertex that is connected to only one another vertex connected and remove them with edges incident to them I e you choose such leaves that there are edges and remove these leaves and these edges Your task is to find the number of moves you can perform if you remove leaves optimally You have to answer independent test cases ,This is mostly implementation problem We can notice that all leaves are indistinguishable for us So if we have some vertex with at least k leaves attached to it we can choose it remove these leaves from the tree and continue the algorithm The rest is just an implementation let s maintain for each vertex v the list of all leaves which are connected to it leaves v and the set of vertices which is sorted by the size of leaves v So let s take any vertex which Is connected with at least k leaves we can just take the vertex with the maximum value in the set and remove any k leaves attached to it If it has zero leaves after the current move let s mark is as a leaf and append it to the list of the corresponding vertex you also need to remove edges from the graph fast to find the required vertex so you may need to maintain the graph as the list of sets And don t forget about the case k 1 because it may be special for your solution so you could handle it in a special way Time complexity O n log n ,For each vertex we will build the following structure for its children the segment for the second child is nested in the segment for the first child the nested for the third child is nested in the segment for the second child and so on and the children of different vertices do not intersect at all Let s solve the problem recursively for each of the children create a set of segments with endpoints from to where is the size of the subtree After that combine them To do this you can use small to large technique and change the coordinates of the segments or use the necessary offset in the function call for the next child After that it remains to cross children s segments with the segment of the vertex itself To do this you can move the right ends of all segments of the children by to the right and add a segment that starts before the first one and ends immediately after the last one 
1033,Let s define a multiset the following way Write down the sum of all elements of the multiset in its decimal representation For each position of that number check if the multiset includes at least one element such that the digit of the element and the digit of the sum at that position are the same If that holds for every position then the multiset is Otherwise it s For example multiset is and multiset is The red digits mark the elements and the positions for which these elements have the same digit as the sum The sum of the first multiset is every position has the digit required The sum of the second multiset is and the second to last digit doesn t appear in any number thus making the multiset You are given an array consisting of integers You are asked to perform some queries on it The queries can be of two types replace with the value find the subset of the multiset of the numbers with the minimum sum or report that no subset exists Note that the empty multiset is For each query of the second type print the lowest sum of the subset Print if no subset exists ,We are given the definition of the balanced multiset but let s instead fix the criteria to determine if the multiset is unbalanced Take an empty multiset and start adding numbers to it until it becomes unbalanced Empty set to the set of one number is trivial Now for the second number If there is some position such that both numbers have non zero digits in it then the multiset becomes unbalanced let these be non zero digits and then can be neither nor After that let s prove that you can never make an unbalanced multiset balanced again by adding numbers to it Let there be such multisets and such is unbalanced is balanced and Take a look at the lowest position which has non zero digits in several numbers from The sum of these digits should be equal to at least one of them modulo to satisfy the condition of balance That can only mean their sum is greater or equal to thus is make a carry to the next position The sum of digits on the next position plus carry should also be equal to some digit of them thus pushing some other carry value to the next one And so on until the carry makes it to the position greater than any position in any of the numbers But the carry is non zero and there is no number with any non zero digit in this position That makes our assumption incorrect After all it implies that any unbalanced multiset of size greater than two has an unbalanced multiset of size two The problem now got reduced to find a pair of numbers and such that there is at least one position such that both and have non zero digits on it and is minimal possible That can be easily maintained in a segment tree Let a node corresponding to the interval keep the best answer on an interval the sum of such a pair and an array the smallest number on an interval which has a non zero digit at position or if none exists The update is easy Iterate over the digits of a new number and update the values in the array in the corresponding nodes The merge is done the following way push the best answers from children to the parent and then iterate over the positions and try to combine the smallest numbers at each one from the left child and the right child Idea wise this is the same as storing a segtree and calculating the answer by each position separately However these approaches differ by a huge constant factor performance wise The former one accesses the memory in a much more cache friendly way You might want to take that as a general advice on implementing multiple segtrees Overall complexity ,Let s denote as the largest of the terms of the sum and is the smaller one Consider cases or If then So we need to find two consecutive substrings of length such that if we convert these substrings into integers their sum is equal to If let be the largest common prefix of and if we consider them as strings Then or So it is necessary to check only these two cases and whether goes before or after in the string Thus we have reduced the number of variants where the substrings for and are located to It remains to consider how to quickly check whether the selected substrings are suitable To do this you can use hashes preferably with several random modules 
1034,Polycarp got an array of integers as a gift Now he wants to perform a certain number of operations possibly zero so that all elements of the array become the same that is to become In one operation he can take some indices in the array and increase the elements of the array at those indices by For example let He can perform the following operation select indices 1 2 and 4 and increase elements of the array in those indices by As a result in one operation he can get a new state of the array What is the minimum number of operations it can take so that all elements of the array become equal to each other that is to become ,Let s sort the numbers in ascending order It becomes immediately clear that it is not profitable for us to increase the numbers that are equal to the last number the maximum of the array It turns out that every time you need to take such a subset of the array in which all the numbers except the maximums And once for each operation the numbers in the subset are increased by one then how many times can the operation be performed on the array Accordingly ,We use zero indexing in this solution We also use half closed interval so subarray is Let s precalculate the array where so if sum of first elements of Then subarray is good if so Thus we have to group all prefix by value for from to And if the have prefix with same value of then we have to add to the answer 
1035,You are playing a game where your character should overcome different obstacles The current problem is to come down from a cliff The cliff has height and there is a moving platform on each height from to Each platform is either hidden inside the cliff or moved out At first there are moved out platforms on heights The platform on height is moved out and the character is initially standing there If you character is standing on some moved out platform on height then he can pull a special lever which switches the state of In other words the platform you are currently standing on will hide in the cliff and the platform one unit below will change it state it will hide if it was moved out or move out if it was hidden In the second case you will safely land on it Your character is quite fragile so it can safely fall from the height no more than In other words falling from the platform to platform is okay but falling from to or lower is certain death Sometimes it s not possible to come down from the cliff but you can always buy for donate currency several magic crystals Each magic crystal can be used to change the state of any single platform except platform on height which is unaffected by the crystals After being used the crystal disappears What is the minimum number of magic crystal you need to buy to safely land on the ground level ,You are given the input data in compressed format let s decompress it in binary string where the th character is if the th platform is hidden and otherwise For example the third query is Let s look how our string changes if we had then after pulling the lever it becomes and if we had then we d get The underlined index is the platform we are currently on So it looks like we are standing on and move it to the left until it clashes with the next one So we can determine that we should look only at subsegments on s Now we can note that the good string should have all subsegments of ones with even length except two cases the subsegment that starts from should have odd length and subsegment which ends in can have any length Now we can say that the answer is equal to number of subsegments which doesn t match the pattern of the good string since we can fix each subsegment with one crystal And we can prove that it s optimal since the only way to fix two subsegments with one crystal is to merge them but it does not help Finally we can understand that we have no need in decompressing the input and can determine subsegments of ones straightforwardly ,Let s iterate over the length of the first segment of the split Having fixed it we actually fixed the sum that needs to be collected on all other segments Since each element must belong to exactly one segment we can build other segments greedily If we have found a solution we will remember the length of the longest segment in it and try to update the answer We have possible lengths of the first segment for each of which we greedily built the answer for Thus the asymptotics of the solution will be 
1036, You are given a positive integer number You really love so you want to find the smallest greater than or equal to The positive integer is called if it can be represented as a sum of powers of i e no duplicates of powers of are allowed For example is a is a is a but is a you can t represent it as a sum of distinct powers of is a you can t represent it as a sum of distinct powers of for example the representations are invalid is also a you can t represent it as a sum of distinct powers of for example the representation is invalid Note that there exist other representations of and as sums of powers of but none of them consists of powers of For the given positive integer find such smallest that is a You have to answer independent queries ,As you can see from the example the maximum answer doesn t exceed So we can run some precalculation before all queries which will find all less than The number is if it has no in the ternary numeral system When you read the next query you can increase until you find some precalculated Time complexity is You also can implement the solution which doesn t use any precalculations and just increase each time in each query and checks if the number is inside this loop Then time complexity will be ,If we will no compress songs the sum of the sizes will be equal Let it be Now if we will compress the th song how do will change It will decrease by This suggests that the optimal way to compress the songs is the compress it in non increasing order of Let s create the array of size where Let s sort it in non increasing order and then iterate over all from to If at the current step we print and terminate the program Otherwise we set After all we have to check again if then print otherwise print Time complexity is because of sorting 
1037,You are given an array All are pairwise distinct Let s define function as follows let s define array where sort array in increasing order result of the function is Calculate i e total sum of for all subsegments of modulo ,Let s define some functions at first indicator function if is true and otherwise is a number of that and Good observation Another observation Now it s time to transform what we d like to calculate Since transformation of the second sum was standard we ll look at the first sum So we can iterate over and we d like to calculate this two sums fast enough So more transformations So while iterating over we need to make queries of two types set value in position and calculate It can be done by BIT with coordinate compression can be calculated in the same way iterating over in reverse order Result complexity is ,Let s sort all numbers in a Now let s iterate over elements of b and for element bj find the index of lowest number that is greater than bj We can do that using binary search That index will be the answer for value bj Complexity O nlogn 
1038,Ivan is a student at Berland State University BSU There are days in Berland week and each of these days Ivan might have some classes at the university There are working hours during each Berland day and each lesson at the university lasts exactly one hour If at some day Ivan s first lesson is during th hour and last lesson is during th hour then he spends hours in the university during this day If there are no lessons during some day then Ivan stays at home and therefore spends hours in the university Ivan doesn t like to spend a lot of time in the university so he has decided to skip some lessons He cannot skip more than lessons during the week After deciding which lessons he should skip and which he should attend every day Ivan will enter the university right before the start of the first lesson he does not skip and leave it after the end of the last lesson he decides to attend If Ivan skips all lessons during some day he doesn t go to the university that day at all Given and Ivan s timetable can you determine the minimum number of hours he has to spend in the university during one week if he cannot skip more than lessons ,The problem can be solved in the following dynamic programming manner Let be the smallest number of hours Ivan can spend in university in the first days while having lessons skipped To calculate it we can store minimal number of hours Ivan is required to spend in the th day so that he attends lessons Then we can iterate over all lengths from to and update with Precalc works in and dp can be processed in ,To solve it it should be noted that despite the way the deck with bonuses works the order in which they will be applied is not important Then when we meet the hero card we just need to add to the answer the maximum of the available bonuses Constraints allow you to sort the current array with bonus values each time and remove the maximum element 
1039,You are given a positive integer Let s build the following graph from it each vertex is a divisor of not necessarily prime and itself are also included two vertices and have an undirected edge between them if is divisible by and is a prime the weight of an edge is the number of divisors of that are not divisors of For example here is the graph for Edge has weight because has divisors and has divisors Thus there are divisors of that are not divisors of There is no edge between and because is not divisible by There is no edge between and because is not a prime Let the length of the path between some vertices and in the graph be the total weight of edges on it For example path has length The empty path has length So the shortest path between two vertices and is the path that has the minimal possible length Two paths and are different if there is either a different number of edges in them or there is a position such that and are different edges You are given queries of the following form calculate the between vertices and The answer for each query might be large so print it modulo ,Let s define the semantics of moving along the graph On each step the current number is either multiplied by some prime or divided by it I claim that the all shortest paths from to always go through Moreover the vertex numbers on the path first only decrease until and only increase after it Let s watch what happens to the divisors list on these paths At first all the divisors of that are not divisors of are removed from the list Now we reach gcd and we start adding the divisors of that are missing from the list The length of the path is this total number of changes to the list That shows us that these paths are the shortest by definition If we ever take a turn off that path we either will add some divisor that we will need to remove later or remove some divisor that we will need to add later That makes the length of the path not optimal Now let s learn to calculate the number of paths The parts before gcd and after it will be calculated separately the answer is the product of answers for both parts How many paths are there to gcd Well let s divide by that will give us the primes that should be removed from You can remove them in any order because the length of the path is always the same That is just the number of their permutations with repetitions you might also know that formula as multinomial coefficient The number of paths from to is calculated the same way To find the primes in you can factorize beforehand and only iterate over the primes of Overall complexity ,One important fact is that when we subtract from new will be divisible by old And of course is always divisible by Let s factorize Consider the moment when changes If we denote old value of by the new value of will be divisible by some where is a prime divisor of Let s check all prime divisors of and for each of these divisors find the number of times we need to subtract from to get divisible by that is just don t forget that also has to be divisible by Among all prime divisors of pick one with the minimum required number of operations let this number of operations be add to answer subtract from and repeat the process 
1040,Hasan loves playing games and has recently discovered a game called TopScore In this soccer like game there are players doing penalty shoot outs Winner is the one who scores the most They have just finished the game and now are waiting for the result But there s a tiny problem The judges have lost the paper of scores Fortunately they have calculated sum of the scores before they get lost and also for some of the players they have remembered a lower bound on how much they scored However the information about the bounds is private so Hasan only got to know his bound According to the available data he knows that his score is at least and sum of the scores is Thus the final state of the game can be represented in form of sequence of integers player s scores Hasan is player number so Also Two states are considered different if there exists some position such that the value of differs in these states Help Hasan find the probability of him winning It can be shown that it is in the form of where and are non negative integers and Report the value of ,An straightforward dp solution is to calculate number of states at the end of the game in which no one has scored more than goals where is the number of total goals to be scored and is the number players in the game Fix the score of Hasan in the game and by using this dp the rest is easy also described below But as long as the time needed to calculate is this solution won t fit in the constraints With a little help from combinatorics we can calculate the value of mentioned dp function without using recursions Define by inclusion exclusion principle it can be easily seen that the value of equals to the above And the complexity of calculation for is with a preprocess for calculating binomial coefficients This formula is a well known modification of Star and Bars problem but with the upper limit on terms Now we can calculate the answer firstly fix Hasan s score and number of top scorers then use to calculate each state By using modulus arithmetic the answer can be reported in the requested form Overall complexity ,Firstly let s prove that the order of characters in s is interchangeable Suppose we have a tournament of four teams with skills a b c and d such that a b c d and this tournament has the form 01 or 10 It s easy to see that a and d cannot be winners since a will be eliminated in the round with type 1 and d will be eliminated in the round with type 0 However it s easy to show that both with s 10 and with s 01 b and c can be winners Using this argument to matches that go during phases i and i 1 a group of two matches during phase i and a match during phase i 1 between the winners of those matches can be considered a tournament with n 2 we can show that swapping s i and s i 1 does not affect the possible winners of the tournament So suppose all phases of type 1 happen before phases of type 0 there are x phases of type 1 and y phases of type 0 x y n 2 x y 2 y teams will be eliminated in the first part phases of type 1 and the team with the lowest skill that wasn t eliminated in the first half will win the second half It s easy to see that the teams with skills 1 2 x 1 cannot pass through the first part of the tournament since to pass the first part a team has to be the strongest in its subtree of size 2 x Furthermore since the minimum of 2 y teams passing through the first half wins the winner should have skill not greater than 2 x y 2 y 1 the winner should have lower skill than at least 2 y 1 teams so teams with skills higher than 2 x y 2 y 1 cannot win Okay now all possible winners belong to the segment 2 x 2 n 2 y 1 Let s show that any integer from this segment can be winning Suppose k in 2 x 2 n 2 y 1 let s construct the tournament in such a way that only team with skill k and 2 y 1 teams with the highest skill pass through the first part of the tournament obviously then team k wins There are 2 y independent tournaments of size 2 x in the first part let s assign teams with skills from 1 to 2 x 1 and also the team k to one of those tournaments for all other 2 y 1 tournaments let s assign the teams in such a way that exactly one team from the 2 y 1 highest ones competes in each of them It s easy to see that the team k will win its tournament and every team from the 2 y 1 highest ones will win its tournament as well so the second half will contain only teams with skills k and 2 n 2 y 2 2 n and obviously k will be the winner of this tournament So the answer to the problem is the segment of integers 2 x 2 n 2 y 1 
1041,You are given words of length consisting of lowercase Latin alphabet letters The th word is denoted In one move you can choose and change the letter at that position to the previous or next letter in alphabetical order For example you can change to or to can only be changed to can only be changed to The between two words is the number of moves required to make them equal For example the between and is Find the minimum of and such that In other words find the minimum over all possible pairs of the words ,Firstly given any pair of strings of length we should be able to tell the difference between them It s enough to find the sum of absolute differences between each character from the same position Now we should go through all possible pairs and pick the minimum value over all of them using the function we use to calculate the difference ,Let s look at the first and the last characters of Note that if where then is always equal to It can be proved for example by induction if consists of equal characters then if has a structure like or then Otherwise there is at least one character in the middle that equal to and So we can split string in and Both these string has by induction so our string also has As a result if then the answer is and we print the string untouched Otherwise we replace either or and get the desired string It also can be proved that if then 
1042,You are given points on the plane the coordinates of the th point are No two points have the same coordinates The distance between points and is defined as For each point you have to choose a color represented by an integer from to For every ordered triple of different points the following constraints should be met if and have the same color then if and have the same color and the color of is different from the color of then and Calculate the number of different ways to choose the colors that meet these constraints ,Let s call a point if its color does not match the color of any other point If a point is not isolated then it has the same color as the points with minimum distance to it and only these points should have this color Let s build a directed graph where the arc means that the point is one of the closest to the point i e If there is a path from the vertex to the vertex it means that if the vertex is not isolated the vertex should have the same color as vertex Suppose the set of vertices reachable from including itself is Finding is easy just run DFS from the vertex Let s analyze two cases there exists a pair of vertices such that and there is no arc from to for every pair of vertices such that and there is an arc Why do we need to analyze these two cases In the first case the vertex be isolated because painting it and some other vertex into the same color means that every vertex from will have this color and it will break the condition in the statement In the second case the vertex may be isolated or it may have the same color as all vertices in and if it is isolated then the whole set should consist of isolated vertices Let s find all such set of vertices that meet the second case Each vertex will belong to at most one of these sets if it doesn t belong to any it must be isolated otherwise either the whole its set consists of isolated vertices or the whole set has the same color So for each set we either use color or colors This allows us to implement a knapsack like dynamic programming let be the number of ways to paint first sets into colors such that the colors are not ordered After running this dynamic programming we can get the answer by simple combinatorics iterate on the number of colors we use in these sets in total multiply the dynamic programming for it by the ordered number of ways to choose these colors from and then by the number of ways to choose the colors for points that must be isolated This dynamic programming can even be implemented a bit easier if we treat every vertex that must be isolated as a set of size and this is the way it s written in the model solution ,Let s consider what the sequence of removals looks like in general We will base some intuition on a fact that at least one valid sequence is guaranteed to exist Remove all vertices that have their degree correct from the start at once There surely be such vertices since a valid sequence would have to start with some of them Notice that there can t be any adjacent vertices among them If there were we wouldn t be able to remove such a pair regardless of the order we choose since removing one of them makes another one s degree too low Now remove the vertices that just got their degrees correct from removing the first layer Once again these must exist if the graph is not empty yet because otherwise any valid sequence would get stuck Process until nothing is left This algorithm is basically a bfs and you can implement it like one Note that each vertex becomes available to be removed only after a certain subset of its neighbours is removed No matter what order you choose to remove the vertices in these vertices will always be the same Huh so for each vertex some of its neighbours have to be removed before it and the rest have to be removed after it since otherwise the degree of that vertex will become too low That actually means that our graph is not as undirected as it seemed We can direct each edge from a vertex that is removed before the other This makes a valid sequence of removals just a topological sort of that directed graph So a pair is nice if there exist two topological orders such that and go one before another in them We can make a bold but perfectly reasonable guess about all nice pairs A pair is nice if neither of and are reachable from each other The necessity of this condition is obvious Let s show sufficiency Let s show the construction such that goes before To remove we first have to remove all vertices that have edges to To remove them we have to remove vertices with edge to them And so on Basically to remove we have to remove all vertices that are reachable from on the transposed directed graph Since is not reachable from it doesn t have to be removed before So we can first remove all the required vertices then remove then continue removing vertices until we are able to remove By switching and in the description of that construction we can obtain the construction for before Thus we reduced the problem to a rather well known one Calculate the number of reachable pairs of vertices in a directed graph As far as I know it s not known to be solvable in sub quadratic time And we are not given a specific graph Yes it s obviously acyclic but turns out every acyclic graph can be made into a test for this problem You just have to make equal to the number of the outgoing edges for each Somehow we are still given vertices and edges If you are more familiar with that problem you might know that you can use bitset to solve it In particular let be a bitset such that if if reachable from Then you can initialize for all vertices and propagate the knowledge in reverse topological order by applying for all edges Unfortunately that requires memory and bits is over a gigabyte Let s use of my favorite tricks to make a solution with memory and the same complexity Man I love that trick Process vertices in batches of Let s calculate which vertices can reach vertices from to The algorithm is basically the same For each vertex store a smaller bitset of size also known as an unsigned long long Initialize the bitset for vertices from the batch and propagate the same way for all vertices Now just add up the number of ones in each bitset builtin popcountll Proceed to the next batch That makes it iterations of a algorithm This might require some constant optimizations In particular I suggest not to use dfs inside the iteration since the recursion makes it really slow You might iterate over a vertex in reverse topological order and its outgoing edges Or which is way faster unroll that graph into a list of edges and iterate over it directly 
1043,Polycarp s phone book contains phone numbers each of them is described by the number itself and the number of times Polycarp dials it in daily Polycarp has just bought a brand new phone with an amazing feature More precisely buttons on it can have a number assigned to it not necessary from the phone book To enter some number Polycarp can press one of these buttons and then finish the number using usual digit buttons entering a number with only digit buttons is also possible button can only be used when no digits are entered No button can have its number reassigned What is the minimal total number of Polycarp can achieve after he assigns numbers to buttons and enters each of the numbers from his phone book the given number of times in an optimal way ,The first thing to come to one s mind is dynamic programming on a trie The most naive of the solutions take where is the total length of strings I ll introduce the faster approach Let be the solution for subtree of the vertex with buttons remaining and is the closest ancestor vertex with the button used in it This dp will be recalced via the other dp Let be the same thing as but only first children of is taken into consideration and doesn t have a button in it Give buttons to the current child then update with will then have two options for having button in it and for not having button in it has transitions and states has total transitions and also states ,First of all let s try to find a simple way to evaluate the difficulty of a given set of towers I claim that the difficulty is equal to the number of pairs of discs that belong to different towers during each operation we can merge at most one such pair if we move discs to the tower with disk on top of it only the pair can be affected we can always take the first several discs belonging to the same tower and move them to the tower containing disc thus merging exactly one pair in exactly one operation After that there are two main approaches LCA and small to large merging The model solution uses LCA so I ll describe it For each pair we have to find the first moment these discs belong to the same tower To do so let s build a rooted tree on vertices The vertices to will be the leaves of the tree and will represent the original towers The vertex will represent the tower created during the th query and will have two children the vertices representing the towers we merge during the th query The vertex is the root Now if some vertex is an ancestor of vertex it means that the tower represented by vertex contains all the discs from the tower represented by vertex So to find the first tower containing two discs and we have to find the lowest common ancestor of the vertices representing the towers and The easiest way to do it is to implement something like binary lifting which allows us to solve the problem in 
1044,You are given an array consisting of integers Each position of the array is either locked or unlocked You can take the values on the unlocked positions rearrange them in any order and place them back into the unlocked positions You are not allowed to remove any values add the new ones or rearrange the values on the locked positions You are allowed to leave the values in the same order as they were For example let the underlined positions are locked You can obtain the following arrays and some others Let be a sequence of prefix sums of the array after the rearrangement So Let be the maximum such that If there are no such that then Your goal is to rearrange the values in such a way that is minimum possible Output the array after the rearrangement such that the value for it is minimum possible If there are multiple answers then print any of them ,Let s collect the prefix sums of the initial array How do they change if you swap two values in the array Let s swap values on positions and Prefix sums from to aren t changed Prefix sums from to are increased by note that if then these sums become smaller Finally prefix sums from to aren t changed as well Thus swapping two values will only increase some prefix sums but never decrease any of them That helps us see that the array such that all values on the unlocked positions are sorted in a non increasing order is the most optimal one Overall complexity per testcase ,Let s consider one of the possible solutions Let s put the first element in the th permutation equal to and sort all the other elements in descending order Thus we get permutations of the form In such a construction for all and hence 
1045,You are given a weighted tree with vertices Recall that a tree is a connected graph without any cycles A weighted tree is a tree in which each edge has a certain weight The tree is undirected it doesn t have a root Since trees bore you you decided to challenge yourself and play a game on the given tree In a move you can travel from a node to one of its neighbors another node it has a direct edge with You start with a variable which is initially equal to When you pass through edge changes its value to where is the weight of the th edge Your task is to go from vertex to vertex but you are allowed to enter node if and only if after traveling to it the value of will become In other words you can travel to node only by using an edge such that Once you enter node the game ends and you win Additionally you can teleport at any point in time to any vertex except vertex You can teleport from any vertex even from Answer with if you can reach vertex from and otherwise Note that represents the bitwise XOR operation ,Let s ignore the teleporting and decide how to find the answer Note that we don t need to ever go over an edge more than once since going over an edge twice cancels out since for all In other words the only possible value of equals the of the edges on the unique path from to We can find it through a BFS from continuing to keep track of s as we move to each adjacent node and ing it by the weight of the corresponding edge as we travel across it Now let s include the teleport It means that we travel from then teleport to and go from for some nodes and Also we cannot pass on the path from Again note that the value of is fixed on each of the paths from and since there is a unique path between them Let be the of the first path and be the of the second Then we need So we need to find if there are two nodes such that the s from and to those nodes are the same To do this we can do our BFS from before but instead run one BFS from and another from and check if any two values are the same Make sure not to include nodes past while we look for on our BFS from The time complexity is ,It s easy to see that it s optimal to only move right or to use a portal once we are at it We can notice that when we teleport back the problem is independent of the previous choices We still are at point and have some portals left Thus we can just find out the individual cost of each portal sort portals by individual costs and take them from smallest to largest by cost as long as we can The cost of portal is since we pay to use it and need moves to get to it 
1046,You are given a tree consisting exactly of vertices Tree is a connected undirected graph with edges Each vertex of this tree has a value assigned to it Let be the distance between the vertices and The distance between the vertices is the number of edges on the simple path between them Let s define the cost of the tree as the following value firstly let s fix some vertex of the tree Let it be Then the cost of the tree is Your task is to calculate the of the tree if you can choose arbitrarily ,Firstly let s calculate the answer let it be for some fixed vertex Let this vertex be the vertex Just run simple and calculate the result using the formula from the problem statement Also let s calculate the sum of values let the sum in the subtree of the vertex be in each subtree of the given tree if its root is the vertex It can be easily done with simple dynamic programming And now the magic part let s apply the technique which is called at least we called it so Let s maintain the correct values in subtrees at each step of our algorithm How will values and the answer change if we will go through the edge The following sequence of changes will change all values correctly Firstly it can be seen that will decrease by because the distance to each vertex in this subtree will decrease by one then will decrease by because we change the root of the tree we need this step to maintain the correct values then will increase by because the distance to each vertex in this subtree will increase by one and then will increase by because we change the root of the tree we need this step to maintain the correct values So we can recalculate all the values we need if we go through the edge So now we can write another one to try to update the answer for each vertex as a root as the chosen vertex ,Let s store for each vertex the minimum distance from it to the nearest one let s call it We will also store the global answer which for obvious reasons does not increase we will call it Let s now color the vertex let s set and run a depth first search from it This DFS will visit the vertices with Let us consider the vertex and its neighbour If we can relax through let s do it and start from Otherwise has a closer neighbour let s try to update the answer through it Also do not forget to update the answer via from all vertices that we visited The correctness of the algorithm is obvious let s evaluate its time complexity It is easy to notice that after the first operations We enter only the vertices from which firstly does not exceed and secondly was relaxed by the parent that is decreased by at least So we allowed ourselves a complete tree bypassing for the first operations and then amortized performed no more than operations The final asymptotics will be 
1047,You are given a tree an undirected connected acyclic graph consisting of vertices and edges A number is written on each edge each number is either let s call such edges edges or those are edges Let s call an ordered pair of vertices if while traversing the simple path from to we never go through a edge after going through a edge Your task is to calculate the number of pairs in the tree ,Let s divide all valid pairs into three categories the ones containing only edges on the path the ones containing only edges and the ones containing both types of edges To calculate the number of pairs containing only edges we may build a forest on the vertices of the original graph and edges and choose all pairs of vertices belonging to the same connected components of this forest we can find all connected components with DSU or any graph traversal algorithm The same can be done for the pairs containing only edges If a path from to is valid and contains both types of edges then there exists a vertex such that the simple path from to goes only through edges and the simple path from to goes only through edges So let s iterate on this vertex and choose some other vertex from its component in graph as and some other vertex from its component in graph as and add the number of ways to choose them to the answer ,We prove that the answer always always exists by constructing it Graph for is a single vertex Graph for is a clique of vertices Graph for some is obtained from the graph by adding vertices initially connected to nothing and vertices connected to all previously mentioned ones The vertices connected to nothing got degrees the vertices from the previous step increased their degrees by and finally there appeared vertices of degree The number is vertices is as needed 
1048,You are given an integer array of length You have to choose some subsequence of this array of maximum length such that this subsequence forms a increasing sequence of consecutive integers In other words the required sequence should be equal to for some value and length Subsequence of an array can be obtained by erasing some possibly zero elements from the array You can erase any elements not necessarily going successively The remaining elements preserve their order For example for the array the following arrays are subsequences but the array is not ,Let be the answer for our problem if the last element of our subsequence equals to Then we have an easy solution let s store as a C or Java Initially for each Then let s iterate over all in order of input and try to update with a Then the maximum element of will be our answer Let it be Then let s find any such that Let it be Then for restoring the answer we need to iterate over all elements of our array in reverse order and if the current element then push to the array of positions of our subsequence and make ,There are several solutions Here is one If we fix the value of then let s make a new array as follows if and otherwise Then the total amount of money earned will just be so we only need to maximize In other words we need to find the maximum sum of a subarray This is a standard problem that can be solved using segment tree Note that we need to iterate over all values of of which there are possibilities So we have to update elements of the segment tree times and query once for each which means overall the solution runs in 
1049,There are points marked on the plane The points are situated in such a way that they form a regular polygon marked points are its vertices and they are numbered in counter clockwise order You can draw segments each connecting any two marked points in such a way that all points have to be connected with each other directly or indirectly But there are some restrictions Firstly some pairs of points cannot be connected directly and have to be connected undirectly Secondly the segments you draw must not intersect in any point apart from the marked points that is if any two segments intersect and their intersection is not a marked point then the picture you have drawn is invalid How many ways are there to connect all vertices with segments Two ways are considered different iff there exist some pair of points such that a segment is drawn between them in the first way of connection but it is not drawn between these points in the second one Since the answer might be large output it modulo ,We can use dynamic programming to solve this problem but we need to choose the states we maintain very carefully One of the approaches might be the number of ways to connect the vertices between and to vertices or if and are already connected so there is no possibility to connect any vertex between and to some vertex outside What values should we access if we for example try to connect th vertex to some vertex To get everything connected we then have to connect vertices from interval to these two and vertices from to or and connections to from the second interval are difficult to handle We need to somehow get rid of them and the solution is to And vice versa if we connect something to then we choose the index of vertex to be connected with directly But that s not all we have to handle Suppose we have four vertices and is already connected to One of the possibilities to finish it is to connect to and to but if we process current dynamic programming as it is we will count it twice if we choose to connect to firstly or if we connect to To get rid of this problem we will use a flag that will denote whether we can connect anything to vertex and if we choose to pick the first connection from then we don t connect anything to So the solution is the number of ways to connect the vertices from interval to and and denotes if we can connect anything to How to calculate it If then there is nothing left to connect Otherwise set If then iterate on vertex we connect to and add Iterate on vertex we connect to and add The answer is if vertices are indexed Vertex is actually vertex so don t forget to update the matrix for it ,We can take vertex with the maximum degree and all its neighbours To implement it just run from vertex with the maximum degree See the authors solution for better understanding 
1050,Mishka is trying really hard to avoid being kicked out of the university In particular he was doing absolutely nothing for the whole semester miraculously passed some exams so that just one is left There were classes of that subject during the semester and on th class professor mentioned some non negative integer to the students It turned out the exam was to tell the whole sequence back to the professor Sounds easy enough for those who attended every class doesn t it Obviously Mishka didn t attend any classes However professor left some clues on the values of to help out students like Mishka was sorted in non decreasing order was even the following sequence consisting of elements was formed and given out to students Professor also mentioned that any sequence which produces sequence with the presented technique will be acceptable Help Mishka to pass that last exam Restore any sorted sequence of non negative integers which produces sequence with the presented technique It is guaranteed that there exists at least one correct sequence which produces the given sequence ,Let s present the following greedy approach The numbers will be restored in pairs and so on Thus we can have some limits on the values of the current pair satisfying the criteria about sort Initially and they are updated with Let be minimal possible in the answer Take and That way was chosen in such a way that both and are within the restrictions and is also minimal possible If was any greater than we would move both limit up and limit down leaving less freedom for later choices Overall complexity Funnily enough I coded some naive solution just to test main correct and with restriction of on numbers it passed all tests in 300 ms at max After I saw that I guessed why it worked in but it looked fun nonetheless ,At first array contains a palindromic subarray of length is equivalent to array contains a palindromic subarray of length So we need to calculate number of arrays without palindromes of length It s equivalent to finding arrays where for all appropriate Note that and have same parity so all odd and all even positions in array are independent and answer is the product of the number of ways to choose numbers for odd positions and the number of ways to choose numbers for even positions In terms of same parity our condition morphs to and we need to calculate all ways to replace s in such way that all pairs of consecutive elements are different To calculate it let s look at sequences of consecutive s They will look like with s where and are positive case where is empty can be considered as case with empty is solved the same way In the end we need to find a way to calculate the number of those sequences There are only two fundamental types of sequences same value from both ends and Exact values of and don t really matter Let s find a way to calculate both values name them and for consecutive s in time Base values Let s try to choose value of in the middle of sequence if then we can split sequence in two sequences of length and and If then just iterate over value of last then and Resulting complexity is 
1051,You are given a tree consisting of vertices Initially each vertex has a value You need to perform queries of two types You are given a vertex index Print the value of the vertex You are given two vertex indices and and values and You need to add to the value of each vertex such that the distance from that vertex to the path from to is less than or equal to The between two vertices and is equal to the number of on the path from to For example the distance from to itself is equal to The distance from the vertex to some path from to is equal to the minimum among distances from to any vertex on the path from to ,For the purpose of solving the task let s choose some root in the tree and introduce another operation to the tree add to all vertices that are in the subtree of the given vertex and on the distance from For example if it s itself or if then it s all children of Let s be the parent of vertex and so on So how to perform this operation Instead of adding to all vertices in the subtree we can add only to the vertex And when we need to get the answer for some vertex we will get it from Of course since there are different s we ll create different arrays for each possible So the answer for the vertex will be equal to Now let s discuss how to use the introduced operation to perform the given one We can make the given operation using ours in the following way Let s find using any standard algorithm binary lifting for example Let s split all affected vertices in three groups subtrees of path inclusive exclusive subtrees of path and subtrees of path Note that in such way all affected vertices belong to at least one group Let s look at group of path The lowest vertices are on distance from the next level are on distance from the next level are on distance from and so on The last level we ll consider in this group is the vertices in the subtree of the on distance from it In such a way all we need to do is add to all on the path from The group of the path is handled in the same way What s left It s vertices in subtree of on distances in subtree of on distances in subtree of on distances in subtree of on distance Note that vertices in subtree of on distance are included in vertices in subtree of on distance Analogically vertices on distance from are included in vertices on distance from Moreover vertices on distance from are included in from that are included in from and so on In other words all we need to proccess are vertices in subtree of on distances and in subtree of on distances and in subtree of on distances and In total it s at most operations add to some vertex As a result all we need to do is add on path from to some ancestor of add in some vertex can be done as operation on path ask value in some vertex We can do all of these operations in using Fenwick tree BIT on s and s we can get from binary lifting So the first statement operation will work in time and the second one also in In total complexity is time and space P S the second operation can be further optimized to but it s not really necessary ,This problem is about the rerooting technique Firstly let s calculate the answer for some fixed root How can we do this Let be the maximum possible difference between the number of white and black vertices in some subtree of yes the subtree of the rooted tree i e and all its direct and indirect children that the vertex We can calculate this dynamic programming by simple dfs for the vertex it will look like this Okay we can store the answer for the root somewhere What s next Let s try to change the root from the vertex to some adjacent to it vertex Which states of dynamic programming will change Only and Firstly we need to remove the child from the subtree of the vertex Then we need to attach the vertex and make it a child of the vertex Then we need to run this process recursively from store the answer reroot the tree and so on and when it ends we need to rollback our changes Now is the root again and we can try the next child of as the root Time complexity 
1052,You are given a regular polygon with vertices it s convex and has equal sides and equal angles and all its sides have length Let s name it as gon Your task is to find the square of the minimum size such that you can embed gon in the square Embedding gon in the square means that you need to place gon in the square in such way that each point which lies inside or on a border of gon should also lie inside or on a border of the square You can rotate gon and or the square ,It s not hard to come up with a solution if you just imagine how gon looks when is even The solution is to rotate gon in such way that several its sides are parallel to sides of the square And the answer is equal to the distance from center to any side multiplied by two or ,Consider some corner of the picture If it s colored black then it contributes to counts to both of the adjacent sides Otherwise it contributes to none All the remaining cells can contribute only to the side they are on There are of such cells on each side So let s try all options of coloring the corners After fixing the colors of the corners we can calculate the number of cells that have to be colored on each side That is calculated by taking the initial requirement and subtracting the adjacent colored corners from it If any of the numbers is below or above then that corner coloring doesn t work Otherwise you can always color the cells in some way Overall complexity per testcase 
1053,For a square matrix of integers of size let s define its as follows for each pair of side adjacent elements and write out the number and then find the number of different numbers among them For example for the matrix the numbers we consider are and there are different numbers among them and which means that its beauty is equal to You are given an integer You have to find a matrix of size where each integer from to occurs exactly once such that its is the maximum possible among all such matrices ,The first step is to notice that beauty doesn t exceed because the minimum difference between two elements is at least and the maximum difference does not exceed the difference between the maximum element and the minimum element At first finding a matrix with maximum beauty seems to be a quite difficult task So let s try to find an array of elements of maximum beauty In this case it is not difficult to come up with an array of the form In such an array there are all possible differences from to So we found an array with the maximum possible beauty It remains to find a way to convert the array to the matrix i e to find such a sequence of matrix cells that each two adjacent cells in it are side adjacent One of the ways is the following traverse the first row of the matrix from left to right go down to the second row traverse it from right to left go down to the third row traverse it from left to right and so on Thus we constructed a matrix with the maximum possible beauty ,The main idea is to read and process each row of the matrix separately To do this we will use DSU data structure The answer will be equal to the difference between the number of 1 s and the number of operations in DSU When processing the row we will keep the DSU for the previous row When processing a certain index in the row we will try to merge it with the element to the left of it and with the element to the top that s all we have to check here You also have to handle the fact that we cannot store the whole DSU since the number of components can be up to and it s impossible to store all required information for them So each time we process a row we have to renumerate all components in this row to ensure that every time we are operating with indices of components not greater than 
1054,Monocarp has got an array consisting of integers Let s denote as the mathematic mean of these elements note that it s possible that is not an integer The mathematic mean of an array of elements is the sum of elements divided by the number of these elements i e sum divided by Monocarp wants to delete exactly two elements from so that the mathematic mean of the remaining elements is still equal to Your task is to calculate the number of pairs of positions such that if the elements on these positions are deleted the mathematic mean of remaining elements is equal to that is it is equal to the mathematic mean of elements of the original array ,First of all instead of the mathematic mean let s consider the sum of elements If the mathematic mean is then the sum of elements of the array is Let s denote the sum of elements in the original array as Note is always an integer If we remove two elements from the array the resulting sum of elements should become So the sum of the elements we remove should be exactly If is not an integer the answer is to check that you can simply compare with Otherwise we have to find the number of pairs such that and This is a well known problem To solve it you can calculate the number of occurrences of each element and store it in some associative data structure for example in C Let be the number of occurrences of element Then you should iterate on the element you want to remove and check how many elements match it that is how many elements give exactly if you add to them The number of these elements is just Let s sum up all these values for every element in the array Unfortunately this sum is not the answer yet We need to take care of two things if for some index then matches itself so you have to subtract the number of such elements from the answer every pair of elements is counted twice the first time when we consider the first element of the pair and the second time when we consider the second element of the pair So don t forget to divide the answer by ,We will calculate the answer by subtracting the number of arrays which have only one removal sequence from the total number of arrays The latter is very simple it s just How do we calculate the number of unambiguous arrays We can always delete the st element of an array so is a removal sequence for each array So we have to calculate the number of arrays which have no other removal sequences How do we check if the array has no removal sequences other than If at any time it s possible to remove some element other than the st from the array it creates another removal sequence since we can always complete that sequence Let s analyze the constraints on each element of the array can be any integer from to should be divisible by otherwise we can remove it on the first step should be divisible by otherwise we can remove it on the first step and by otherwise we can remove it on the second step should be divisible by and but not necessarily by since an element which is divisible by already has a common divisor with And so on using induction we can show that the th element should be divisible by where are all of the primes in Obviously the number of such elements is So we can easily calculate the number of possible elements for each index of the array and that allows us to count all unambiguous arrays 
1055,You are given a binary matrix of size Let s denote an compression of the given matrix as a matrix of size such that for every the condition is met Obviously compression is possible only if divides but this condition is not enough For example the following matrix of size does not have any compression For the given matrix find maximum such that an compression of this matrix is possible ,After some tinkering with the given condition we notice that an compression is possible iff divides and the matrix is divisible into matrices such that each matrix is either all 1 or all 0 We can loop over all such and check the condition in time per but this is potentially too slow To speed this up we can precompute rectangle sums for every rectangle containing the upper left corner which enables us to compute the sum of any rectangle in This improves our time complexity to Since really this means our solution is Code 49028814 ,At first let s sort broken pixels in non descending order by times they appear Obviously if the first broken pixels make monitor broken pixel won t fix it Thus binary search on answer will work Let s search for the first moment in time when the monitor becomes broken The function to check if in some moment monitor is broken looks the following way As we want to check if there is a submatrix of size which consists only of broken pixels let s precalc the array of partial sums is the number of broken pixels on submatrix from to is calculated as if is broken pixel otherwise Sum on submatrix of size then looks like Check all possible and from to and find out if there exists submatrix with sum equal to Overall complexity 
1056, is a set of numbers in which there can be equal elements and the order of the numbers does not matter Two multisets are equal when each value occurs the same number of times For example the multisets and are equal but the multisets and are not You are given two multisets and each consisting of integers In a single operation any element of the multiset can be doubled or halved rounded down In other words you have one of the following operations available for an element of the multiset replace with or replace with round down Note that you cannot change the elements of the multiset See if you can make the multiset become equal to the multiset in an arbitrary number of operations maybe For example if then the answer is yes We can proceed as follows Replace with We get Replace with We get Replace with We get Replace with We get Got equal multisets and ,We divide each number from the multiset by as long as it is divisible without a remainder Because if we can get a new number from the multiset we can also increase it to the original number by multiplication by Now notice that it does not make sense to use the first operation multiplication by because we get an even number and only odd numbers remain in the multiset Then we take the largest number from and if it is in we remove this number from both multisets Otherwise we use the second operation if the number is greater than If it is equal to then it is impossible to equalize the multisets and ,We will calculate the answer by subtracting the number of arrays which have only one removal sequence from the total number of arrays The latter is very simple it s just How do we calculate the number of unambiguous arrays We can always delete the st element of an array so is a removal sequence for each array So we have to calculate the number of arrays which have no other removal sequences How do we check if the array has no removal sequences other than If at any time it s possible to remove some element other than the st from the array it creates another removal sequence since we can always complete that sequence Let s analyze the constraints on each element of the array can be any integer from to should be divisible by otherwise we can remove it on the first step should be divisible by otherwise we can remove it on the first step and by otherwise we can remove it on the second step should be divisible by and but not necessarily by since an element which is divisible by already has a common divisor with And so on using induction we can show that the th element should be divisible by where are all of the primes in Obviously the number of such elements is So we can easily calculate the number of possible elements for each index of the array and that allows us to count all unambiguous arrays 
1057,A permutation of size is an array such that every integer from to occurs exactly once in this array Let s call a permutation an iff there exist at least indices such that Your task is to count the number of permutations for given numbers and ,Let s iterate on the number of indices such that Obviously How to count the number of permutations with fixed First of all we need to choose the indices that have the property there are ways to do this Secondly we need to construct a permutation for chosen indices such that for every chosen index permutations with this property are called and the number of derangements of fixed size can be calculated using exhaustive search since So the answer is where is the number of derangements of size ,The first observation if we have an answer where the first row is inverted we can inverse all rows and columns then the matrix will remain the same and the first row is not inverted in the new answer So we can suppose that the first row is never inverted Note that this will be true only for slow solution The second observation if we consider a sorted matrix its first row either consists only of s or has at least one and then all other rows consist only of s This observation can be extended to the following one user wrote a comment about it and I pinned the link to it above which can improve time complexity of the solution a lot in the sorted matrix either the first row consists only of s or the last row consists only of s the corner case is n 1 but for n 1 we can obtain both answers So what should we do with these observations I will explain a slow solution a faster solution can be obtained by mirroring one of cases of this one Let s iterate over the number of s in the first row Let it be cnt Then the first cnt elements of the first string should be s and all others should be s We can do it by inverting the columns with elements among first cnt elements of the first row and columns with elements among remaining elements So it s case handling time The first case when cnt m is pretty easy We have to check if all rows from 2 to n that they consist only of s or only of s and if some row consists of s then we should invert it If it is true then we found the answer Otherwise the first row consists only of s So we have to find the transitional row the row with some s on the prefix and s on the suffix or vice versa If the number of such rows among all rows from 2 to n is greater than 1 then this configuration is bad If the number of such rows is 1 then let idx be the index of this row Then we should inverse all rows above it consisting only of s and all rows consisting only of s below it And we have to check if the current row is really transitional We know that its sum is neither 0 nor m so there is at least one and at least in it If the first element is then let s inverse it Then we just should check if this row is sorted and if it is then we found the answer And the last case is if there are no transitional rows in the matrix Then we should invert all rows from 2 to n consisting only of s or only of s it does not matter So we have a solution with time complexity O n 3 Each number of s in the first row is processed in O n 2 and there are O n such numbers But we can see that if we apply the last case when the number of is m to the first row and then do the same but with the last row consisting of m we can get a solution in O n 2 
1058,You are given segments on a line There are no ends of some segments that coincide For each segment find the number of segments it contains ,This problem is a standard two dimensional problem that can be solved with one dimensional data structure In the same way a lot of other problems can be solved for example the of finding the maximal weighted chain of points so that both coordinates of each point are greater than the coordinates of the predecessing point Rewrite the problem formally for each we should count the number of indices so that the following conditions are hold and Let s sort all segments by the left ends from right to left and maintain some data structure Fenwick tree will be the best choice with the right ends of the processed segments To calculate the answer for the current segment we should simple take the prefix sum for the right end of the current segment So the condition is hold by sorting and iterating over the segments from the right to the left the first dimension of the problem The condition is hold by taking the prefix sum in data structure the second dimension ,Intersection of some segments is If this segment has its left bound greater than its right bound then the intersection is empty Removing some segment makes the original sequence equal to That can be split up to a prefix of length and a suffix of length Intersections for them can be precalced separately and stored in some partial sum like arrays Finally you have to iterate over the position of the removed segment and calculate the intersection of prefix and suffix without this segment Overall complexity 
1059,You are given a bipartite graph is the set of vertices of the first part is the set of vertices of the second part and is the set of edges There might be multiple edges Let s call some subset of its edges iff the graph has each of its vertices incident to at least edges is such a covering that the size of the subset is minimal possible Your task is to find minimal covering for each where is the minimal degree of any vertex in graph ,To get the answer for some we can build the following network connect the source to every vertex of the first part with edge with capacity where is the degree of vertex then transform every edge of the original graph into a directed edge with capacity and then connect each vertex from the second part to the sink with capacity Then edges saturated by the maxflow are not present in the answer and all other edges are in the answer To solve it fastly we might just iterate on from its greatest value to and each time augment the flow we found on previous iteration Since maxflow in the network is at most and we will do not more than searches that don t augment the flow this solution is ,You can use straightforward way and calculate answer with l r dp with But there is a easier claim it s optimal to split gon with diagonals coming from so answer is Proof let s look at the triange which contains edge Let s name it If we can delete this triangle and go to gon Otherwise Let s look at triangle It always exists and Finally if we change pair of triangles to answer will decrease since and that s why Note that triangle changes to and so repeating this step will eventually lead us to situation As a result we can morph any triangulation into one mentioned above and its weight won t increase 
1060,Recently Luba bought a monitor Monitor is a rectangular matrix of size But then she started to notice that some pixels cease to work properly Luba thinks that the monitor will become broken the first moment when it contains a square consisting entirely of broken pixels She knows that pixels are already broken and for each of them she knows the moment when it stopped working Help Luba to determine when the monitor became broken or tell that it s still not broken even after all pixels stopped working ,At first let s sort broken pixels in non descending order by times they appear Obviously if the first broken pixels make monitor broken pixel won t fix it Thus binary search on answer will work Let s search for the first moment in time when the monitor becomes broken The function to check if in some moment monitor is broken looks the following way As we want to check if there is a submatrix of size which consists only of broken pixels let s precalc the array of partial sums is the number of broken pixels on submatrix from to is calculated as if is broken pixel otherwise Sum on submatrix of size then looks like Check all possible and from to and find out if there exists submatrix with sum equal to Overall complexity ,We can see that the only information we need is the parity of the coordinate of each chip because we can move all chips that have the same parity to one coordinate for free So if the number of chips with odd coordinate is then the answer is 
1061,Alice and Bob received candies from their parents Now they want to divide all candies among themselves fairly so that the total weight of Alice s candies is equal to the total weight of Bob s candies Check if they can do that Note that candies ,If the sum of all the weights is not divisible by two then it is impossible to divide the candies between two people If the sum is divisible then let s count the number of candies with a weight of and Now if we can find a way to collect half the sum with some candies then these candies can be given to Alice and all the rest can be given to Bob Simple solution let s iterate through how many candies of weight we will give to Alice then the remaining weight should be filled by candies of weight If there are enough of them then we have found a way of division In fact if the sum is even and there are at least two candies with weight there can t be one candy then the answer is always we can collect the weight as close to half as possible with weight and then add weight If there are no candies with weight then you need to check whether is even since all the candies have the same weight you just need to divide them in half ,The main idea of this problem is the same as in the easy version The only thing we should replace is the search method Replacing linear search with binary search leads to reducing time complexity from to And it is obvious that we can apply binary search here because if we can order all microtransactions during some day then we can order all of them during day even using the answer for days and doing nothing during day 
1062,Let s call a sequence of integers if for all holds Where is the minimum non negative integer that doesn t belong to the set For example and You are given an array consisting of non negative integers Calculate the number of non empty subsequences of a given array The number of subsequences can be very large so print it modulo Note a subsequence of an array is a sequence meeting the constraints If two different ways to choose the sequence of indices yield the same subsequence the resulting subsequence should be counted twice i e two subsequences are different if their sequences of indices are not the same ,Let s understand what MEX correct sequences look like It turns out there are only two types and For example the sequences and the empty sequence are MEX correct sequences of the first type and and of the second one Let s calculate the dynamic programming the number of MEX correct subsequences of the first type on the prefix of length with equal to and similarly the number of MEX correct subsequences of the second type on the prefix of length with equal to Let s look at the transitions in these dps and show that there are no other MEX correct sequences at the same time Let the current state be and we are trying to add an element equal to if then such an element cannot be added if then the value of will not change and the sequence is still of the first type which means we have a transition to if then the value of will increase by but it will still be of the first type which means we have a transition to if then the value of will not change but the sequence will become of the second type which means we have a transition to if then such an element cannot be added Let the current state be and we are trying to add an element equal to if then such an element cannot be added if then the value of will not change and the sequence is still of the second type which means we have a transition to if then such an element cannot be added because will increase by which means the absolute difference between and is greater than if then the value of will not change and the sequence is still of the second type which means we have a transition to if then such an element cannot be added Thus we considered all possible transitions adding a new element to the already MEX correct sequences and made sure that there are only two types While the solution itself works in time because each element has possible transitions in the dps it uses memory which does not allow us to write that solution as is However note that and similarly for differ in only a few positions in those that the element allowed us to make which means we can store only one dimensional arrays and Thus the final complexity of the solution is ,There are several ways to solve this problem The model solution does it as follows Restore the characters of from left to right The first character is restored by query For each of the next characters let s ask if this character is new by querying and comparing the result with the number of different characters on the segment If it s new ask to obtain the th character there will be at most such queries Otherwise we can find the previous occurrence of the th character with binary search Let be the number of different characters from position to position If we want to find the previous occurrence of the th character we need to find the last index such that Since the value does not decrease when we increase we can find the last such that with binary search Unfortunately the number of queries of type will be too large if we just use binary search over the whole segment To decrease the number of queries we can use the fact that the value of we are interested in is the last occurrence of some character we already met there are at most such values and binary search among them will need only iterations 
1063,You are given two arrays of length and You can perform the following operation any number of times Choose integer index Swap and What is the minimum possible sum in other words you can achieve after performing several possibly zero operations ,Let s look at our arrays and Note that for any position such that we can always fix it by swapping positions from to In that case contribution from all won t change contribution of pair will decrease and contribution from all won t change again since we swapped all of them It means that we already can use the following algorithm while exists such that just swap all from to This solution works for per test that should be enough But we can optimize our approach by realizing that we can instead of searching each time just go from to and fix pairs one by one if then swap with next if then swap with and so on In such way solution works in ,Let s count the number of occurrences of each element in the Because the maximum possible element is it can be done without any data structures Then let s check if is greater than for some from to and if it is then the answer is because this element should occur at least twice in one of the sequences Now let s output the increasing sequence The number of elements in it is the number of elements such that Let s iterate from left to right print the suitable elements and decrease their The number of elements in the decreasing sequence is just the number of elements with non zero So let s iterate from right to left and just print suitable elements 
1064,You are given a special undirected graph It consists of vertices numbered from to The following properties hold for the graph there are exactly edges in the graph edges connect vertices having odd numbers with vertices having even numbers edges connect vertices having odd numbers with each other and edges connect vertices having even numbers with each other for each edge between a pair of vertices with odd numbers there exists an edge and vice versa for each odd number there exists an edge the graph is connected moreover if we delete all vertices with even numbers from it and all edges incident to them the graph will become a tree the same applies to deleting odd vertices So the graph can be represented as two trees having the same structure and edges connecting each vertex of the first tree to the corresponding vertex of the second tree Edges of the graph are weighted The length of some simple path in the graph is the sum of weights of traversed edges You are given queries to this graph in each query you are asked to compute the length of the shortest path between some pair of vertices in this graph Can you answer all of the queries ,Suppose we want to minimize the number of traversed edges of the second type edges that connect odd vertices to each other or even vertices to each other and minimizing the length of the path has lower priority Then we exactly know the number of edges of the second type we will use to get from one vertex to another and when building a path we each time either jump from one tree to another using an edge of the first type or use the only edge of the second type that brings us closer to the vertex we want to reach So in this case problem can be solved either by binary lifting or by centroid decomposition The model solution uses the latter merge the graph into one tree vertices and of the original graph merge into vertex in the tree build its centroid decomposition and for each centroid and vertex of its centroid subtree calculate the length of the shortest path from and to and using dynamic programming Then the answer for each pair of vertices and may be calculated as follows find the deepest centroid controlling the both vertices and try either shortest path or shortest path But this solution won t work in the original problem because sometimes we want to choose an edge of the second type that leads us further from the vertex we want to reach in the merged tree but allows us to use a cheaper edge of the first type to jump from one tree to another Let s make this situation impossible We may change the weights of all edges of the second type so that the weight of edge between and becomes the length of the shortest path between and This can be done by solving a SSSP problem build a graph of vertices where each vertex from to represents the path between from and Add a directed edge with weight equal to going from vertex to vertex And finally for every pair such that and are connected by edge of weight and and are connected by edge of weight add an undirected edge connecting and in the new graph its weight should be Then the distance from to in this graph will be equal to the length of the shortest path from to in the original graph ,Please also refer to the tutorial for the easy version If we are not at the first taken portal the problem is still independent for each portal but this time the cost of a portal is since we can come to a portal either from point or point So we again sort the portals by their costs But this time we need to make sure that the first taken portal is taken from point so we will iterate over all portals and check the maximum amount of portals we can take if we use it as the first one We can check this using prefix sums over the minimum cost array and binary searching checking if the amount of considered portals taken doesn t exceed the number of coins we initially have we also have to deal with the case when the portal we are considering is included both times as the initial portal and in the minimum cost prefix 
1065,Ivan likes to learn different things about numbers but he is especially interested in numbers Ivan thinks that a positive integer number is if the difference between and the sum of its digits in decimal representation is not less than To prove that these numbers may have different special properties he wants to know how rare or not rare they are in fact he needs to calculate the quantity of numbers that are not greater than Ivan tried to do the calculations himself but soon realized that it s too difficult for him So he asked you to help him in calculations ,Let s prove that if is then is too Since the sum of digits of let s call it is not greater than then and if then So if is then is This observation allows us to use binary search to find the minimum number let s call it And if then all numbers in the segment are and not greater than so the quantity of these numbers is the answer to the problem ,Let s decode the number digit by digit starting from the leftmost When you meet in the string increase the value of the current digit For print current digit and proceed to the next one Don t forget to print the last digit when the string is over Overall complexity 
1066,Timofey came to a famous summer school and found a tree on vertices A tree is a connected undirected graph without cycles Every vertex of this tree except is colored The vertex is colored Timofey wants to color all the vertices of this tree in To do this he performs operations During the th operation he selects the vertex which is currently and paints it Let s call the of tree the minimum distance between all pairs of different vertices in it The distance between the vertices and is the number of edges on the path from to After each operation Timofey wants to know the of the current tree ,Let s store for each vertex the minimum distance from it to the nearest one let s call it We will also store the global answer which for obvious reasons does not increase we will call it Let s now color the vertex let s set and run a depth first search from it This DFS will visit the vertices with Let us consider the vertex and its neighbour If we can relax through let s do it and start from Otherwise has a closer neighbour let s try to update the answer through it Also do not forget to update the answer via from all vertices that we visited The correctness of the algorithm is obvious let s evaluate its time complexity It is easy to notice that after the first operations We enter only the vertices from which firstly does not exceed and secondly was relaxed by the parent that is decreased by at least So we allowed ourselves a complete tree bypassing for the first operations and then amortized performed no more than operations The final asymptotics will be ,To begin with we will hang the tree by the vertex In fact we want to go from the root to the top of going off this path to do things and coming back At one vertex of the path it is advantageous to get off it in all the necessary directions and follow it further So we will go once for each edge leading to and times for each edge leading to some of the cases but not leading to Let s match each vertex with an edge to its ancestor If the edge of a vertex leads to then is in the subtree of this vertex similarly with vertices with cases It is necessary for each vertex to determine whether there is a vertex in its subtree and whether there is a vertex from the array this can be done using a depth first search then we will calculate the answer according to the rules described above 
1067,Given a positive integer find integers not necessary distinct such that all these integers are strictly greater than and their product is equal to ,There are many approaches to this problem You can for example factorize store all multipliers in a list and while size of this list is greater than take any two elements of this list and replace them with their product If the initial size of this list is less than then answer is ,This problem can be solved using inclusion exclusion Let be the number of subsequences such that all elements of the subsequence are divisible by We can calculate which is the number of elements divisible by by factorizing all elements of the sequence and generating their divisors and Then we can apply the inclusion exclusion principle and get the resulting formula where is the M bius function 
1068,You are given an undirected graph with vertices and edges You have to write a number on each vertex of this graph each number should be either or After that you write a number on each edge equal to the sum of numbers on vertices incident to that edge You have to choose the numbers you will write on the vertices so that there is at least one edge with written on it at least one edge with and at least one edge with How many ways are there to do it Two ways to choose numbers are different if there exists at least one vertex which has different numbers written on it in these two ways ,Let be the number of ways to paint the graph so that all numbers on edges belong to the set Using inclusion exclusion we may get that the answer is Okay let s analyze everything separatedly is because every number is allowed will be analyzed later is where is the number of connected components in each component we have to use the same number is where is the number of isolated vertices every non isolated vertex should have number on it and all isolated vertices may have any numbers since these cases are symmetric is the number of bipartite colorings of the graph It is if the graph contains an odd cycle or if it is bipartite since these cases are symmetric is if there are no edges in the graph otherwise it is So the only thing left to consider is Actually it is easier to calculate it is the number of independent sets of this graph This problem is NP complete but when we may apply meet in the middle technique as follows divide all vertices into two sets and of roughly equal size for find all its independent subsets and for each such subset find which vertices from can be added to it without breaking its independency for each subset of find the number of independent subsets of such that no vertex from chosen subset of is adjacent to any vertex from chosen subset of you may use subset DP and OR convolution here find all independent subsets of and for every such subset add the number of subsets of that can be merged with it so the resulting set is independent The most time consuming part is counting all independent sets so the time complexity is ,Firstly let s run bfs on the given graph and calculate distances for all vertices In fact we don t need distances we need their parities The second part is to find all vertices with an even distance all vertices with and odd distance and print the smallest by size part Why is it always true Firstly it is obvious that at least one of these sizes will not exceed And secondly because we are checking just parities of distances it is obvious that each vertex of some parity is connected with at least one vertex of the opposite parity because it has this parity from some vertex of the opposite parity 
1069,You are playing a new famous fighting game Kortal Mombat XII You have to perform a brutality on your opponent s character You are playing the game on the new generation console so your gamepad have buttons Each button has a single lowercase Latin letter from to written on it All the letters on buttons are pairwise distinct You are given a sequence of hits the th hit deals units of damage to the opponent s character To perform the th hit you have to press the button on your gamepad Hits are numbered from to You know that if you press some button times then it ll break You cherish your gamepad and don t want to break any of its buttons To perform a brutality you have to land some of the hits of the given sequence The total damage dealt is the sum of over all for the hits which weren t skipped Your task is to skip some hits to deal the possible total damage to the opponent s character and not break your gamepad buttons ,Since we are only allowed to push the same button times in a row let s do a two pointer sweep to find all segments of consisting of just one button Within each segment we ll sort and take the highest values See the code for details on the two pointer sweep 48994498 ,In this problem we first need to consider all points adjacent to at least one Christmas tree then all points at the distance two from the nearby Christmas tree and so on What it looks like Yes well known multi source bfs Let s maintain a queue of positions and the set of used positions and the distance to each vertex of course In the first step we add all positions of the Christmas tree with a zero distance as initial vertices Let the current vertex is If this is the Christmas tree then just add and to the queue if these vertices aren t added already and continue Otherwise increase the answer by and add to the array of positions of people When the length of this array reaches interrupt bfs and print the answer Don t forget about some special cases as using in Java or using in C because this can lead to the quadratic complexity Time complexity 
1070,Let s define the value of the permutation of integers a permutation is an array where each element from to occurs exactly once as follows initially an integer variable is equal to if then add to set otherwise assign to if then add to set otherwise assign to if then add to set otherwise assign to the value of the permutation is at the end of this process For example for the value of changes as follows so the value of the permutation is You are given an integer Find a permutation of size with the maximum possible value among all permutations of size If there are several such permutations you can print any of them ,Let be the value of the variable after steps Note that should be less than for to be not equal to It means that does not exceed It turns out that for there is always a permutation such that is equal to The only thing left is to find out how to build such a permutation There are many suitable permutations let s consider one of the possible options For an even a suitable permutation is You can see that in such a permutation changes as follows For an odd there is a similar permutation where changes as follows ,Let s present the following greedy approach The numbers will be restored in pairs and so on Thus we can have some limits on the values of the current pair satisfying the criteria about sort Initially and they are updated with Let be minimal possible in the answer Take and That way was chosen in such a way that both and are within the restrictions and is also minimal possible If was any greater than we would move both limit up and limit down leaving less freedom for later choices Overall complexity Funnily enough I coded some naive solution just to test main correct and with restriction of on numbers it passed all tests in 300 ms at max After I saw that I guessed why it worked in but it looked fun nonetheless 
1071,Let s call an array consisting of positive greater than integers if the following condition is held for every from to either or at least one of the numbers and exists in the array as well For example the array is beautiful for the number exists in the array for the number exists in the array for the condition holds the array is beautiful for the condition holds for every other number the number exists in the array the array is not beautiful for neither nor exists in the array and the array is not beautiful for neither nor exists in the array and the array is beautiful for the number exists in the array for the condition holds for the number exists in the array You are given a positive integer Find the minimum possible size of a beautiful array with the sum of elements equal to ,The maximum sum we can construct with elements is so we need at least elements to construct the sum equal to Let s show how to express with exactly elements Let By taking we achieve a sum of using elements is not less than and not greater than since and Thus we can just add to our array and the sum becomes exactly So the solution is to find the minimum such that ,Let s prove that next greedy solution works each step we will find prefixes of minimal length of arrays such that its sums are equal and we will cut them forming next block If we will get valid partition in result so it is an optimal solution otherwise there is no solution Since length of prefix proportional to its sum so prefixes are minimal since its sums are minimal Let s prove this algorithm let optimal solution have alternative partition Since our solution cuts minimal possible prefixes so at some step optimal solution cuts prefix with greater sum and greater length But this prefixes in optimal solutions contain smaller prefixes found by greedy solution so it can be divided on two parts contradiction So we can keep prefixes and increase one which have smaller sum Result complexity is 
1072,You are given a rooted tree consisting of vertices numbered from to The root of the tree is the vertex You have to color all vertices of the tree into colors also numbered from to so that there is exactly one vertex for each color Let be the color of vertex and be the parent of vertex in the rooted tree The coloring is considered beautiful if there is no vertex such that i e no vertex such that its color is less than the color of its parent by Calculate the number of beautiful colorings and print it modulo ,When a problem asks us to calculate the number of combinatorial objects that meet some constraints we can sometimes use inclusion exclusion formula Let s try to apply it in this problem We could use constraints that should not be violated The th constraint is formulated as follows there will be a constraint of this type for each Suppose we violated of these constraints and have chosen which constraints to violate then the number of colorings that meet these violations is for vertices the colors on them depend on some other independent vertices so we can assign only colors for independent vertices So the answer can be calculated as follows where is the number of ways to choose constraints to violate One initial guess how to calculate is that as it would be calculated in other more usual inclusion exclusion problems Unfortunately in this problem the constraints we violate are not independent For example if a vertex has several sons we can violate the constraint only on at most one edge leading from a vertex to its son simultaneously we cannot violate two or more such constraints Let s take care of this issue as follows we can write a dynamic programming of the form is the number of ways to process first vertices of the tree and choose exactly edges leading from these nodes to their sons so that no vertex has more than one edge leading to its sons chosen Then is exactly the number of ways to choose edges in the tree so that no vertex has more than one chosen edge leading to its sons and that will be equal to We can calculate this dynamic programming in a knapsack fashion in but it is too slow Instead let s optimize this knapsack DP with FFT for each vertex introduce a polynomial where is the number of children of the vertex Coefficients of this polynomial for the first vertex are the values of coefficients of the product of this polynomial with the polynomial for the second vertex are the values of and so on to obtain the values of we have to multiply all these polynomials and using FFT divide and conquer we can do it in ,Let s solve the problem in reverse Imagine we have already removed some edges so that the conditions hold When is some set of vertices considered Since the graph is acyclic we can topologically sort the vertices in the set The vertices are reachable from each other so there exists a path from the th vertex in the set to the st vertex Thus there exists a path that goes through all chosen vertices However we can make this conclusion even stronger In the optimal answer not just the path goes from the th vertex to the st one but a single edge That can be shown by contradiction Let there be some vertices and that are adjacent in the chosen set There exists a path between them but not a single edge We want to show that this set is not optimal and can be made larger The vertices on that path don t belong to the set If they did they would be between and in the set because of the topological order We can add them to the set Every vertex that can reach can reach them too and every vertex that can be reached from can be reached from them Thus it will still be a set Now every vertex from to has an edge between them and the size of the set is larger Thus we showed that the maximum set in the answer is always some path in the graph So the task is to choose some path then remove some edges so that this path still exists and the conditions hold Note that if the conditions hold for some set of remaining edges then we can remove any edge from it and the conditions will still be met Thus we can only leave this path Let s look closer into the conditions What they actually tell is the following If a vertex has incoming edges then remove at least one of them The same for the outgoing edges Since we are looking for a path it s enough to leave one outgoing edge for all vertices except the last one and leave one incoming edge for all vertices except the first one In order to achieve that every vertex except the last one should have at least two outgoing edges and every vertex except the first one should have at least two incoming edges We can see that this condition is not only necessary but sufficient as well Just remove the outgoing edges which don t go to the next vertex and the incoming edges which don t go from the previous vertex Now we can wrap this up into the dynamic programming Initialize the answer with since you can always remove all edges and get a set with one vertex Then let be the longest path such that it starts in vertex all vertices in it have at least two incoming edges and all vertices except maybe the final one have at least two outgoing edges Initialize the for the vertices that can be the final in the path have at least two incoming edges with Then update for all that can be internal vertices have at least two outgoing and two incoming edges with for all outgoing edges Finally update the answer from the vertices that can be the first one in the path For each vertex that has at least two outgoing edges take the value of for all outgoing edges Overall complexity 
1073,Polycarp found the string and the permutation Their lengths turned out to be the same and equal to A permutation of elements is an array of length in which every integer from to occurs exactly once For example and are permutations but and are not In one operation he can multiply by so he replaces with string in which for any from to it is true that For example with and after operation the string will turn to Polycarp wondered after how many operations the string would become equal to its initial value for the first time Since it may take too long he asks for your help in this matter It can be proved that the required number of operations always exists It can be very large so use a 64 bit integer type ,To begin with let s understand why the string will return to its original form In fact the graph that the permutation sets consists of simple cycles and it turns out that after a certain number of operations each character will return to its place Consider each cycle as a string that is cyclically shifted every turn It may seem that the answer is the smallest common multiple of the cycle lengths but to become equal to the initial string it is not necessary to go through the entire cycle The constraints allow us to calculate the length of the minimum suitable shift in where is the length of the cycle so just iterate over the desired shift Note that after operations the cycle will return to its original form and this will happen again after operations The answer will be of all since each cycle individually comes to its original form after the number of operations is a multiple of its ,Let s iterate through the given string from the left to the right In a variable we will store the number of letters which were before the current letter in a row If the current letter does not equal to we should make In the other case the current letter equals to If we should increase by one In the other case we should add one to the answer because the current letter should be removed 
1074,You are given a rectangular field of cells Each cell is either empty or impassable contains an obstacle Empty cells are marked with impassable cells are marked with Let s call two empty cells if they share a side Let s call a any non extendible set of cells such that any two of them are connected by the path of adjacent cells It is a typical well known definition of a connected component For each impassable cell imagine that it is an empty cell all other cells remain unchanged and find the size the number of cells of the connected component which contains You should do it for each impassable cell independently The answer should be printed as a matrix with rows and columns The th symbol of the th row should be if the cell is empty at the start Otherwise the th symbol of the th row should contain the only digit the answer modulo The matrix should be printed without any spaces To make your output faster it is recommended to build the output as an array of strings having length and print it as a sequence of lines It will be much faster than writing character by character As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,Let s enumerate all the connected components store their sizes and for each empty cell store the number of it s component It can be done with a single dfs Now the answer for some impassable cell is equal to one plus the sizes of all different adjacent connected components Adjacent means the components of cells adjacent to the current impassable cell in general case each unpassable cell has four adjacent cells ,What if there were no blocked cells Then the movement is easy From cell we can go to cells or Thus we can visit all cells that have the same remainder modulo over both dimensions The answer would be if and Let s choose the following path from start to finish Let be less or equal to If that isn t the case swap the cells First move up until the row is the same then move to the side until the column is the same What stops us from doing the same on a grid with blocked cells The first part of the part can remain the same we can always move up from the cell Only cells below the start cell can be blocked The second part is trickier If there is a column with too many blocked cells between the start and the finish column then we won t be able to pass through it Let s adjust the path for that Move up as high as possible to the highest cell with the same remainder modulo in this column Then move to the finish column and go down to the finish cell If there still exists a column with too many blocked cells then the answer is No matter what we do we won t be able to go around that column Otherwise the answer is Thus the solution is to check for remainders then find the largest number of blocked cells between the query columns and compare it to the highest row with the same remainder modulo as the start or the finish You can use any RMQ data structure you want Overall complexity with sparse table for RMQ for example 
1075,You have a statistic of price changes for one product represented as an array of positive integers where is the initial price of the product and is how the price was increased during the th month Using these price changes you are asked to calculate the inflation coefficients for each month as the ratio of current price increase to the price at the start of this month Your boss said you clearly that the inflation coefficients must not exceed so you decided to some values in such a way that all remain integers and the inflation coefficients for each month don t exceed You know that the bigger changes the more obvious cheating That s why you need to minimize the total sum of changes What s the minimum total sum of changes you need to make all inflation coefficients not more than ,Suppose we decided to increase some by How does it affect all inflation coefficients Let s the th inflation coefficient be We now that If then doesn t change If then it s denominator increases by and decreases If then it s numerator increases and increases as well But if we increase instead of then all decreased will decrease as well and also will decrease Finally if we increase then all decrease and there is no that increases so it s always optimal to increase only Now we need to calculate what is minimum we should add to There are two ways we can either binary search this value knowing that is always enough Then we just need to check that all that is equivalent to checking that Or we can note that each and we need to make or that or Since we should fulfill all conditions then we should take as maximum over all fractions Since is just a prefix sum we can check condition for each in It total the time complexity is either or per test case ,Notice that you need to check just two numbers the closest one less or equal to and the closest one greater than Distances to them are and respectively Now you should multiply the first result by the second result by and compare the products Overall complexity 
1076,Monocarp has a dictionary of words consisting of first letters of the Latin alphabet The words are numbered from to In every pair of adjacent characters in each word the characters are different For every word Monocarp also has an integer denoting how often he uses this word Monocarp wants to design a keyboard that would allow him to type some of the words easily A keyboard can be denoted as a sequence of first letters of the Latin alphabet where each letter from to appears exactly once A word can be typed with the keyboard easily if for every pair of adjacent characters in the word these characters are adjacent in the keyboard as well The of the keyboard is the sum of over all words that can be typed easily with it Help Monocarp to design a keyboard with the maximum possible optimality ,For each word let s consider a graph on vertices where the th and the th vertices are connected by an edge iff the th character of the alphabet is adjacent to the th character of the alphabet in this string Obviously this graph is connected except for the isolated vertices If there is a vertex of degree or more in this graph or if there is a cycle in this graph it is impossible to design a keyboard to type the word easily in the first case the letter represented by that vertex must have at least three neighbors on the keyboard but can have only at most two in the second case the keyboard must be cyclic and it is not So the word can be typed easily only if the graph representing it consists of one path and several isolated vertices Let s write the letters along the path we constructed for the word in a single string For example for the word we get edges and in the graph so the letters along the path are either or and obviously one can be obtained from the other by reversing the string Let and be the two strings we obtain from the word using this method Now we claim that the word can be typed easily if and only if one of these two strings and is a substring of the keyboard this would mean that every pair of letters that should be on adjacent positions are actually on adjacent positions Okay now we construct and for each word and our goal is to find the permutation of the first characters of Latin alphabet such that the sum of over all words having either or as a substring is the maximum possible There are two key observations that allow us to solve this problem and cannot be the substrings of the same keyboard the proof is simple if is a substring its first character must be before its second character and if is a substring its second to last character which is the second character of must be before its last character which is the first character of neither nor can appear in the keyboard twice it s obvious since the keyboard is a permutation So we can reformulate the problem as follows let be the cost of the string and the cost of the string as well find the permutation of the first characters of the Latin alphabet so that its cost which is the sum of costs of its substrings is the maximum possible To solve this problem we can store the strings in an Aho Corasick automaton and for every state of the automaton precalculate the total cost of all string ending in this state that is the cost of this state and all states reachable from it via the suffix links Then run a dynamic programming of the form the maximum possible cost of a partial keyboard if we used a of characters and the Aho Corasick automaton is currently in the state This dynamic programming runs in where is the size of the alphabet and is the size of the automaton up to ,The idea is as follows we will go from the end of the string and get the original string Note that if the current digit is then a letter with a two digit number has been encoded Then we take a substring of length three from the end discard and get the number of the original letter Otherwise the current number then a letter with a one digit number was encoded We easily reconstruct the original letter Next discard the already processed characters and repeat the process until the encoded string is complete 
1077,You are given a binary string of length i e a string consisting of characters and In one move you can swap two adjacent characters of the string What is the lexicographically minimum possible string you can obtain from the given one if you can perform than moves It is possible that you do not perform any moves at all Note that you can swap the same pair of adjacent characters with indices and arbitrary possibly zero number of times Each such swap is considered a separate move You have to answer independent test cases ,This problem has a very standard solution let s take the leftmost zero place it as left as possible and solve the problem without this zero and all operations we spent But we should do it fast Let s go from left to right and carry the number of ones on the prefix If we meet let s just increase and continue the algorithm It is obvious that if we meet we need to make exactly swaps to place it before all ones If we can do it let s just add to the answer decrease by and continue Otherwise this zero will be between some of these ones and we can place it naively In this case the suffix of the string will not change If after all operations we didn t meet the case above let s add all ones to the suffix of the resulting string Time complexity ,Let s denote as the number of substrings of having length exactly so The first and crucial observation is that if then the answer always exists Each of substrings forbids one of the strings from being the answer a string is forbidden if every each character differs from the corresponding character in one of the substrings we can forbid at most strings from being the answer and the number of possible candidates for the answer is This observation leads us to a more strong fact that actually allows us to find a solution we can set the first characters in the answer to all the remaining characters are enough to find the answer There are at most possible combinations of the last characters and this number is not greater than Let s iterate on each substring of of length and check which combination it forbids by inverting the last characters of the substring After that find the minimum unforbidden combination Note that there may be a case when a substring doesn t actually forbid any combination if there are zeroes in the first characters of the substring it is to the answer no matter which combination we choose This can be checked by precalculating the closest position of zero to the left right of each index The whole solution works in per test case the hardest part is inverting the suffix of each substring we are interested in 
1078, You are given a sequence consisting of integers You are making a sequence of moves During each move you must take either the leftmost element of the sequence or the rightmost element of the sequence write it down and remove it from the sequence Your task is to write down a increasing sequence and among all such sequences you should take the longest the length of the sequence is the number of elements in it For example for the sequence the answer is you take and the sequence becomes then you take the rightmost element and the sequence becomes then you take and the sequence becomes and then you take and the sequence becomes the obtained increasing sequence is ,In this problem the following greedy solution works let s maintain the last element of the increasing sequence we got and on each turn choose the minimum element greater than this last element among the leftmost and the rightmost Such turns will maximize the answer You can find details of implementation in the authors solution ,Firstly let s extract maximum by inclusion segments of the array that consists of the numbers with the same sign For example if the array is 1 1 2 1 5 2 1 3 then these segments are 1 1 2 1 5 2 1 and 3 We can do it with any two pointers like algorithm The number of these segments is the maximum possible length of the alternating subsequence because we can take only one element from each block And as we want to maximize the sum we need to take the maximum element from each block Time complexity O n 
1079,You are given a sequence of length consisting of integers from to Find the number of tuples of elements such that the maximum number in the tuple differs from the minimum by no more than Formally you need to find the number of tuples of indices such thatFor example if then there are two such triples and If then all six possible pairs are suitable ,The key idea that allows us to move from the previous version to this one is that the values of the numbers themselves are not important to us The main idea is to consider all numbers in the interval x x k Let s also as in the previous version iterate over the minimum element x in the tuple Now let s find the count of numbers cnt that lie in the interval x x k this can be done with a binary search two pointers or prefix sums using an array of occurrences Then it remains to add to the answer the number of ways to choose m 1 numbers from cnt 1 we fixed one of the numbers as the minimum You have to sum these values over all possible values of x even the same because now you are not fixing the value of the minimum element as in the previous problem but its index in the sorted array To calculate binomial coefficients quickly you can pre compute all factorial values and all frac 1 n values by modulo If you do not know how to calculate the inverse element by modulo then you could pre compute the part of Pascal s triangle in mathcal O nm ,Alice wants to choose such a segment that is maximum possible There is a well known problem where you have to find a segment with maximum That problem is solved with Kadane algorithm Let s learn how to reduce our problem to that one Notice that the values in the array are unusually small Let s iterate over the maximum value on segment Let be the current value If we make all such that equal to then it will never be optimal to take them in a segment Find the maximum sum subarray in that modified array and update the answer with its Notice that you can ignore the fact if there is a value exactly equal to on the maximum sum segment If there isn t then you ll update the answer with a smaller value than the actual one Let the actual maximum on the maximum sum segment be some You can see that for any value between and the maximum sum segment will always be that chosen one Thus when you reach you ll update the answer with the correct value Overall complexity 
1080,Recently Luba learned about a special kind of numbers that she calls numbers The number is called iff its binary representation consists of consecutive ones and then consecutive zeroes Some examples of beautiful numbers More formally the number is beautiful iff there exists some positive integer such that the number is equal to Luba has got an integer number and she wants to find its greatest beautiful divisor Help her to find it ,Let s notice that there are only beautiful numbers less than Generate them all and select the greatest one which is also divisor of Overall complexity ,Let be the number of elements of with the remainder modulo Then the initial answer can be represented as and we have to compose numbers with remainders and somehow optimally It can be shown that the best way to do it is the following firstly while there is at least one remainder and at least one remainder let s compose them into one After this at least one of the numbers will be zero then we have to compose remaining numbers into numbers divisible by If then the maximum remaining number of elements we can obtain is because and in the other case the maximum number of elements is because 
1081,A binary string is a string where each character is either or Two binary strings and of equal length are if they have the same character in some position there exists an integer such that For example and are they have the same character in position and are and are and are not You are given an integer and a binary string consisting of characters Let s denote as the contiguous substring of starting with th character and ending with th character in other words You have to construct a binary string of length which is to ,We just need to make sure our string of characters matches each of the substrings in at least one spot The easiest way to do this is to take every other character from Code 90908018 Another fun solution we can generate random strings and check them until we find one that matches everything This works because the probability of failing to match any particular substring is so as gets bigger the probability of failing gets extremely low Code 90999219 ,First of all let s think about how we should rearrange the two strings in such a way that if that is ever possible It s always optimal to arrange s characters increasingly in lexicographic order and s characters decreasingly Since initially both and contain a character the first time receives any other letter than the answer will always be because that character will always be lexicographically larger than s first character which should be In the other case we know that doesn t have any other characters than so we can compare the string with multiple characters and we know that will be smaller if and only if it s only formed of s and has a smaller size than 
1082,You are given an unweighted tree with vertices Recall that a tree is a connected undirected graph without cycles Your task is to choose vertices on this tree such that the number of edges which belong to one of the simple paths between and and or and is the maximum possible See the notes section for a better understanding The simple path is the path that visits each vertex at most once ,There is some obvious dynamic programming solution that someone can describe in the comments but I will describe another one that in my opinion much easier to implement Firstly let s find some diameter of the tree Let and be the endpoints of this diameter and first two vertices of the answer You can prove yourself why it is always good to take the diameter and why any diameter can be taken in the answer Then there are two cases the length of the diameter is or the length of the diameter is less than In the first case you can take any other vertex as the third vertex of the answer it will not affect the answer anyway Otherwise we can run multi source bfs from all vertices of the diameter and take the farthest vertex as the third vertex of the answer It is always true because we can take any diameter and the farthest vertex will increase the answer as much as possible Time complexity ,After the first query make the vertex that we painted black the root of the tree and for each other vertex calculate the minimum index on the path to the root This can be done by simple DFS Then suppose we are painting some vertex black In can easily proved that for every vertex and every vertex that is on a path form to the root there exists a path from to some black vertex coming through So we have to store the minimum index among all vertices such that belongs to the path from the root to some black vertex it is a global value let s call it and the answer to every query of type is just the minimum of the value we calculated in DFS and To update quickly after painting vertex black we ascend from to the root until we arrive to some node that was visited during previous queries and we stop there because this node and all nodes on the path from it to the root were used to update in previous queries This solution works in time 
1083,Petya studies at university The current academic year finishes with special days Petya needs to pass exams in those special days The special days in this problem are numbered from to There are three values about each exam the day when questions for the th exam will be published the day of the th exam number of days Petya needs to prepare for the th exam For the th exam Petya should prepare in days between and inclusive There are three types of activities for Petya in each day to spend a day doing nothing taking a rest to spend a day passing exactly one exam or to spend a day preparing for exactly one exam So he can t pass prepare for multiple exams in a day He can t mix his activities in a day If he is preparing for the th exam in day then It is allowed to have breaks in a preparation to an exam and to alternate preparations for different exams in consecutive days So preparation for an exam is not required to be done in consecutive days Find the schedule for Petya to prepare for all exams and pass them or report that it is impossible ,If in the current day there is no exam we should prepare for an exam for which questions already given for which we prepare less than needed and which will be before other remaining exams For this we will use array where equals to the number of days which we already prepared for exam Initially array consists of zeroes Let s iterate through the days Suppose exam is in the current day If we did not have time to prepare for it and we should print In the other case in this day we will pass the exam In the other case let iterate through all exams and choose exam for which we need still to prepare i e for which already given the questions and which will be before other remaining exams If there is no such exam we should relax in this day else in this day we should prepare for exam Also we should increase by one ,Imagine there were no constraints of the second or the third types Then it would be possible to solve the problem with some greedy algorithm Unfortunately when both these constraints are present it s not immediately clear how to adapt the greedy Dynamic programming is probably also out of question because you can t maintain all possible cuts between equal values on each prefix Thus let s try to make a graph problem out of this Who knows maybe a flow or something else could work Create nodes for each position Let the th of them on the th position represent the condition of kind is equal to Then all constraints can be described as edges on this graph Binary variables restrictive edges Surely this is 2 SAT Connect the pairs of values that satisfy each constraint Add the edges between the adjacent positions to enforce the restriction on the non decreasing order Prohibit each position to be assigned to multiple values Force each position to be assigned at least one value Huh it s not that easy That s where the 2 SAT idea fails We want the conditions of form But that is not allowed since 2 SAT has to have two variables in a clause That s where the main idea of the problem comes up Instead of making our nodes represent let s make them and try building the graph again If then all nodes for will be true and the rest will be false So if is false then is false That will enforce the validity of the nodes themselves First the order If is true then is true The first type of constraints is basically the same as or For our conditions it s rather not or The second type of constraints Let be greater than or equal to some Then for this constraint to hold should be no greater than Thus if is true then should be false Same for and swapped The third type of constraints is similar Let be less than or equal to some Then for this constraint to hold should be greater than or equal to Thus if is false then should be true Same for and swapped And that s it Solve the 2 SAT and restore the answer I can advise making not but actually nodes for and force the values to be between and That will simplify the checks while adding the constraints Overall complexity 
1084,You have an array All are positive integers In one step you can choose three distinct indices and and assign the sum of and to i e make Can you make all lower or equal to using the operation above any number of times possibly zero ,Let s note that since all are positive any It means that we can t make the first and second minimums lower than they already are suppose the first and second minimums are and if we choose any other element to replace we can t make it less than and if we choose to replace or we will only make them bigger As a result it means that we can choose for each element either not to change it or make it equal to So to be able to make all elements we need just check that either or maximum We can do it for example by sorting our array in increasing order and checking that either or ,It is easy to see that we always have to remove either minimum or maximum of the array So we can sort the array and the answer will be We also can do it without sort because two minimal and two maximal elements of the array can be found in linear time 
1085,We had a really tough time generating tests for problem D In order to prepare strong tests we had to solve the following problem Given an undirected labeled tree consisting of vertices find a set of segments such that both endpoints of each segment are integers from to and each integer from to should appear as an endpoint of exactly one segment all segments are non degenerate for each pair such that and the vertices and are connected with an edge if and only if the segments and intersect but neither segment is fully contained in segment nor segment is fully contained in segment Can you solve this problem too ,For each vertex we will build the following structure for its children the segment for the second child is nested in the segment for the first child the nested for the third child is nested in the segment for the second child and so on and the children of different vertices do not intersect at all Let s solve the problem recursively for each of the children create a set of segments with endpoints from to where is the size of the subtree After that combine them To do this you can use small to large technique and change the coordinates of the segments or use the necessary offset in the function call for the next child After that it remains to cross children s segments with the segment of the vertex itself To do this you can move the right ends of all segments of the children by to the right and add a segment that starts before the first one and ends immediately after the last one ,Let s calculate answer in two steps At first let s calculate for each vertex what we can gain if we must return from subtree of in the end We need only pair of values minimal possible depth we can acquire to move up from subtree of and maximal number of different leaves we can visit Note that this two values are independent since we must return from and if for some child of we can return from it it s profitable to visit and return But if we can t return from so we are prohibited to descent to So number of visited leaves is just a sum of all if Also note that we can always reorder all children in such way that last visited vertex will have minimal So minimal possible depth is a minimum over all At second let s calculate maximal number of different leaves we can visit if we don t need to return from subtree of It can be calculated quite easy using array We just need to choose child we will not return from so from vertex we will take value and from other childen which we can return from value Result complexity is 
1086,There are lanterns in a row The lantern is placed in position and has power equal to Each lantern can be directed to illuminate either some lanterns to the left or some lanterns to the right If the th lantern is turned to the left it illuminates all such lanterns that Similarly if it is turned to the right it illuminates all such lanterns that Your goal is to choose a direction for each lantern so each lantern is illuminated by at least one other lantern or report that it is impossible ,The main idea of the solution is to calculate the following dynamic programming is the maximum prefix we can fully cover with first lanterns Let s look at how can we solve it in with this kind of dynamic programming First of all let s write it forward Which transitions from do we have iterate on the lantern facing left that will cover the lantern Let this lantern be It should cover all lanterns in so all lanterns from can be turned to the right and we need a max query to determine the new covered prefix if lantern is already covered we can just extend the prefix by turning the th lantern to the right Note that turning it to the right when it is not covered yet will be modeled by the first transition It is obviously how can we optimize it Let s write this dynamic programming backward The second transition is changed to backward dp easily what about the first one Suppose we want to turn some lantern to the left Let s iterate on the prefix that we will connect to it for this prefix should be at least and we update with the maximum of since it is covered by lantern and the result of max query on In fact we need only one such prefix the one with the minimum among those which have So we build a minimum segment tree where each pair is interpreted as the value of in position and with min query on the suffix from we find this optimal prefix from which we should update and to update we can use any DS that allows max queries on segment in my solution it s another segment tree ,It s known that the diagonals of a parallelogram split each other in the middle Let s iterate over the pairs of points and consider the middle of the segment Let s calculate the value for each middle is the number of segments with the middle Easy to see that the answer is 
1087,You have a robot that can move along a number line At time moment it stands at point You give commands to the robot at time seconds you command the robot to go to point Whenever the robot receives a command it starts moving towards the point with the speed of unit per second and he stops when he reaches that point However while the robot is moving it all the other commands that you give him For example suppose you give three commands to the robot at time move to point at time move to point and at time move to point Then the robot stands at until time then starts moving towards ignores the second command reaches at time and immediately starts moving to to execute the third command At time it reaches and stops there You call the command successful if there is a time moment in the range i e after you give this command and before you give another one both bounds inclusive we consider when the robot is at point Count the number of successful commands Note that it is possible that an ignored command is successful ,The main idea in the problem is not how to solve it but how to code it neatly I ve come up with the following way Let s store three variables where is the robot now what direction does it move or and how much time is left until it stops moving The processing of the commands looks becomes pretty easy If there is no time left to move then the command is executed and we tell the robot the direction and the time left for the current command Then there are two cases either the robot stops before the next command or after it However they can be processed simultaneously Let be the minimum of the time left before the robot stops moving and the time before the next command We sure know that before the next command the robot will visit exactly the segment of positions between the current position and the current position plus direction multiplied by If the destination for the current command is in this segment then that command is successful After the command is processed subtract from the time left and increase the position by direction multiplied by Overall complexity per testcase ,Let s write a function which will try to restore the circle if kid with number comes right after kid with number If comes right after then we can determine the number of kid who is next to kid So now we have comes right after comes right after Let s determine kid who is next to kid If we repeat this operation times then we can the answer if comes right after But it can be wrong so we have to check that our answer corresponds to the input So if we have this function we can apply it two times to determine the correct answer Just call and 
1088, You are messaging in one of the popular social networks via your smartphone Your smartphone can show at most most recent conversations with your friends Initially the screen is empty i e the number of displayed conversations equals Each conversation is between you and some of your friends There is at most one conversation with any of your friends So each conversation is uniquely defined by your friend You suddenly have the ability to see the future You know that during the day you will receive messages the th message will be received from the friend with ID If you receive a message from in the conversation which is currently displayed on the smartphone then nothing happens the conversations of the screen do not change and do not change their order you read the message and continue waiting for new messages Otherwise i e if there is no conversation with on the screen Firstly if the number of conversations displayed on the screen is the last conversation which has the position is removed from the screen Now the number of conversations on the screen is guaranteed to be less than and the conversation with the friend is not displayed on the screen The conversation with the friend appears on the first the topmost position on the screen and all the other displayed conversations are shifted one position down Your task is to find the list of conversations in the order they are displayed on the screen after processing all messages ,The idea of this solution is the same as in the easy version but now we need to do the same sequence of moves faster We can notice that the smartphone screen works as a queue so let store it as a queue When the new message appears we have to check if the friend with this ID is in the queue already but we need to check it somehow fast Let s use some logarithmic structure that stores the same information as the queue but in other order to find add and remove elements fast In C this structure is So let s check if the current friend is in the queue and if no let s check if the size of the queue is If it is so then let s remove the first element of the queue from it and the same element from the set also Then add the current friend to the queue and to the set After processing all messages the reversed queue the queue from tail to head is the answer to the problem Time complexity And don t forget that and other standard hashmaps can work in linear time in the worst case so you need to redefine the hash function to use them You can read more about this issue here https codeforces com blog entry 62393 ,Let s denote by the number of sheep in the string and by their positions in the string Note that in the optimal solution the sheep with the number will not make moves This can be proved by considering the optimal solution in which the sheep with the number makes at least one move and come to the conclusion that this solution is not optimal Consider sheep with numbers from to Then the final position of the th sheep will be and the answer will be 
1089,You are given an undirected unweighted graph consisting of vertices and edges which represents the map of Bertown and the array of prices of length It is guaranteed that there is a path between each pair of vertices districts Mike has planned a trip from the vertex district to the vertex district and then from the vertex district to the vertex district He can visit the same district twice or more But there is one issue authorities of the city want to set a price for using the road so if someone goes along the road then he should pay the price corresponding to this road The list of prices that will be used is ready and they just want to distribute it between all roads in the town in such a way that each price from the array corresponds to exactly one road You are a good friend of Mike and suddenly a mayor of Bertown and want to help him to make his trip as cheap as possible So your task is to distribute prices between roads in such a way that if Mike chooses the optimal path then the price of the trip is the possible You have to answer independent test cases ,If we distribute costs optimally then this pair of paths a rightarrow b and b rightarrow c can look like just a straight path that doesn t visit the same vertex twice or like three straight paths with one intersection point x The first case is basically a subcase of the second one with the intersection point a b or c So if we fix the intersection point x then these two paths a rightarrow b and b rightarrow c become four paths a rightarrow x x rightarrow b b rightarrow x and x rightarrow c We can notice that each path we denoted should be the shortest possible because if it isn t the shortest one then we used some prices that we couldn t use Let the length of the shortest path from u to v be dist u v Then it is obvious that for the fixed intersection point x we don t need to use more than dist a x dist b x dist c x smallest costs Now we want to distribute these costs between these three paths somehow We can see that the path from b to x is used twice so it is more optimally to distribute the smallest costs along this part So let pref i be the sum of the first i smallest costs just prefix sums on the sorted array p Then for the intersection point x the answer is pref dist b x pref dist a x dist b x dist c x if dist a x dist b x dist c x le m We can calculate distances from a b and c to each vertex with three runs of bfs Time complexity O m log m ,Let s try to analyze how many times we traverse each edge in the style of Contribution to the Sum technique For each edge the number of times it is traversed must be even since for every chip that goes from the part of the graph 1 i to the part i 1 n there should be a chip that goes in the opposite direction the number of chips on vertices 1 n should be unchanged For each vertex at least one incident edge should be traversed at least twice otherwise the chip from this vertex cannot be moved to any other vertex We would also like to traverse the edges as rarely as possible Is it possible to find an answer where if we traverse any edge we traverse it only twice It turns out it is possible Let s split the graph into several parts by removing the edges we don t traverse If we don t break the constraint that each vertex has at least one incident edge which is traversed by some chip then each part of the graph will contain at least two vertices And in each part we can make sure that each edge is traversed only twice as follows let the part represent the segment l r of vertices if we move the chip r to the vertex l the chip l to the vertex l 1 the chip l 1 to the vertex l 2 the chip r 1 to the vertex r then every edge in that part will be traversed exactly twice So we have shown that if we pick a subset of edges which we traverse that meets the constraint on each vertex having an incident traversed edge then it is enough to traverse each chosen edge only twice Now the problem becomes the following choose a subset of edges in such a way that every vertex has at least one incident chosen edge minimize the total weight of this subset and print the integer which is double that total weight Since the structure of the graph is specific we can run dynamic programming of the form dp i f the minimum total weight of the subset if we considered the first i edges and f is 0 if we haven t taken the last edge or 1 if we have Obviously this dynamic programming works in O n which is too slow because we have to process queries We will employ a classical technique of storing the dynamic programming in segment tree build a segment tree on n 1 leaves in every vertex of the segment tree we store a 2 times 2 matrix d if the segment represented by the node of the segment tree is l r then the value of d f 1 f 2 is the minimum total weight of the subset of edges between l and r such that among every pair of adjacent edges at least one is chosen f 1 and f 2 represent the status of the first last edge on the segment respectively And when some element changes we need to recalculate only O log n nodes of the segment tree so this solution works in O n log n q log n albeit with a very big constant factor Implementation note don t use dynamic size arrays like in C to store the values in the matrices it might slow your solution very seriously Instead use static size arrays 
1090,Monocarp and Polycarp are learning new programming techniques Now they decided to try pair programming It s known that they have worked together on the same file for minutes Every minute exactly one of them made one change to the file Before they started there were already lines written in the file Every minute exactly one of them does one of two actions adds a new line to the end of the file or changes one of its lines Monocarp worked in total for minutes and performed the sequence of actions If then he adds a new line to the end of the file If then he changes the line with the number Monocarp performed actions strictly in this order then Polycarp worked in total for minutes and performed the sequence of actions If then he adds a new line to the end of the file If then he changes the line with the number Polycarp performed actions strictly in this order then Restore their common sequence of actions of length such that all actions would be correct there should be no changes to lines that do not yet exist Keep in mind that in the common sequence Monocarp s actions should form the subsequence and Polycarp s subsequence They can replace each other at the computer any number of times Let s look at an example Suppose Monocarp first changed the line with the number and then added a new line thus Polycarp first added a new line and then changed the line with the number thus Since the initial length of the file was in order for Polycarp to change line number two new lines must be added beforehand Examples of correct sequences of changes in this case would be and Changes wrong order of actions and line cannot be edited yet are not correct ,The solution is that if we can do something let s do it It doesn t make sense not to act because neither adding a new row nor modifying an existing one can prevent the existing row from being changed in the future Therefore we will iterate over the actions and eagerly act Monocarp or Polycarp Let s create two pointers and in arrays and index of possible action of Monocarp and Polycarp and the current length of the file Suppose that or on current iteration Then we take the appropriate zero element and increase by one We can do that because appending a new line cannot make a new answer prefix incorrect if the previous prefix was correct Suppose that and If and then there is no answer because we can potentially do only two actions and both make the answer incorrect If one number is greater than and the other is less than or equals then we take the one that less than or equals If one of the sequences or ends then only one potential action needs to be checked at each iteration ,The solution can be got from the second sample testcase Easy to see that if we place all odd numbers in the center in form of rhombus we will get a magic square 
1091,You are given a tree consisting of vertices A number is written on each vertex the number on vertex is equal to Let s denote the function as the greatest common divisor of the numbers written on the vertices belonging to the simple path from vertex to vertex including these two vertices Also let s denote as the number of vertices on the simple path between vertices and including the endpoints for every vertex Your task is calculate the maximum value of among such pairs of vertices that ,I know there exists solution and author of the problem promises to tell it to you here he explained it I d love to tell easier to code and about the same time to work solution At first notice that it is only enough to check the paths such that all vertices on it is divisible by some prime Let s for each calculate the path of the maximum length to pass through it That means that one part of this path goes down to one child of it and another part goes down to another child For each vertex we will store the lengths of maximum paths through vertices with values divisible by each prime in That is memory To recalc the answer we will store all values of children nodes sort them and update the answer with two pointers technique Don t forget about the case of Overall complexity ,The first idea is the following it is always profitable to add the edges from the vertex to any other vertex The proof is the following if we will add two edges and then the distance to the vertex will be the distance to the vertex will be But we can add edges and and this will be better in fact you cannot obtain the less answer by adding two edges in the other way The main idea is the following Let s carry all vertices of the tree with the distance more than in the set Let the vertex with the maximum distance be What we will obtain if we will add the edge The distance to the vertex will be and the distance to the vertex where is the parent of the vertex if we will root the tree by the vertex will be So we will make reachable at most two vertices if the vertex is already reachable then it will be not counted in the answer Now what we will obtain if we will add the edge We will make reachable all the vertices adjacent to the vertex and the vertex the number of such vertices is not less than so this move won t make the answer greater instead of any other way to add the edge After adding such edge let s remove the vertex and all vertices adjacent to it from the set We need to repeat this algorithm until the set will not become empty Time complexity is I sure that there exists the solution with the dynamic programming in the linear time I will be very happy if someone will explain it to other participants 
1092,You re given a matrix of size Let s call the matrix with nonnegative elements magic if it is symmetric so and for all triples Note that do not need to be distinct Determine if the matrix is magic As the input output can reach very huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,Consider the undirected complete graph with nodes with an edge between nodes with cost Let denote the minimum possible value of the max edge of a path from to We know that by definition If the matrix is magic we can choose arbitrary such that by repeating invocations of the inequality given Also you can show that if this inequality is satisfied then the matrix is magic by choosing an and arbitrary So this shows that the matrix is magic if and only if Thus combining with we have We need a fast way to compute for all pairs This can be computed as the MST as the path in the MST minimizes the max edge between all pairs of nodes So the algorithm works as follows First find the MST on the complete graph Then the matrix is magic if and only if the max edge on the path between in the MST is exactly equal to Also you shouldn t forget to check symmetry of the matrix and diagonal for zeros P S Unfortunately we couldn t increase the value in this problem the tests already had the size about 67MB and they couldn t be given with generator So most of the users who solved this problem uses bitset s The complexity of their solution is where or ,The main observation is that you don t need more than smallest by weight edges among all edges with the maximum weights you can choose any Maybe there will be a proof later but now I ask other participant to write it So you sort the initial edges and after that you can construct a graph consisting of no more than vertices and no more than edges You just can build the new graph consisting only on these vertices and edges and run Floyd Warshall algorithm to find the matrix of shortest paths Then sort all shorted distances and print the th element of this sorted array Time complexity I know that there are other approaches that can solve this problem with greater but to make this problem easily this solution is enough 
1093, You are given a string and a string both consisting only of lowercase Latin letters It is guaranteed that can be obtained from by removing some possibly zero number of characters not necessary contiguous from without changing order of remaining characters in other words it is guaranteed that is a subsequence of For example the strings and are subsequences of the string But the strings are not subsequences of the string You want to remove some substring contiguous subsequence from of such that after removing this substring will remain a subsequence of If you want to remove the substring then the string will be transformed to where is the length of Your task is to find the maximum possible length of the substring you can remove so that is still a subsequence of ,In this problem we can just iterate over all possible substrings and try to remove each of them After removing the substring we can check if remains the subsequence of in linear time Let we remove the substring Let s maintain a pointer the initial value of the pointer is and iterate over all possible from to If and let s increase by one If after all iterations then let s update the answer with the length of the current substring ,Let be the number of zeroes and the number of ones on prefix of length also let The interesting property of is that the substring is balanced iff That leads to a solution for each value of maintain the minimum where this is obtained let it be called and for each index in the string update answer with 
1094, Vlad built a maze out of rooms and bidirectional corridors From any room any other room can be reached through a sequence of corridors Thus the room system forms an undirected tree Vlad invited friends to play a game with them Vlad starts the game in the room and wins if he reaches a room other than into which exactly one corridor leads Friends are placed in the maze the friend with number is in the room and no two friends are in the same room that is for all Friends win if one of them meets Vlad in any room or corridor before he wins For one unit of time each participant of the game can go through one corridor All participants move at the same time Participants may not move Each room can fit all participants at the same time Friends know the plan of a maze and intend to win They don t want to waste too much energy They ask you to determine if they can win and if they can what number of friends must remain in the maze so that they can always catch Vlad In other words you need to determine the size of the minimum by the number of elements subset of friends who can catch Vlad or say that such a subset does not exist ,Let s learn how to find an answer for the subtree rooted in vertex At first it is obvious from E1 tutorial that if the nearest to vertex with a friend from this subtree is no further from it than the root of the entire tree from then the answer for the entire subtree is since a friend can come to and catch Vlad in it not allowing him to go to any leaf of this subtree Else we will find the answer leaning on its children If a solution does not exist for at least one child then it does not exist for the entire subtree because after reaching Vlad will be able to go to such child and reach any exit Otherwise the answer for is the sum of the answers of its children since we need to beat it in each subtree to win and for each subtree we have found the minimum answer ,Consider the cases when it is impossible to form a given permutation 1 For root it is true that For any other vertex the value of will be positive since there is at least one edge of positive weight on the path to it 2 In a rooted tree there is exactly one path from the root to any vertex and it goes through its parent so it must always be true Let us start filling the array where Consider a vertex The vertex whose distance at the current time is maximal is Then is at least We assign a value to remembering to check that has already been counted After counting all values we can output the lengths of the edges 
1095,You might have heard about the next game in Lara Croft series coming out this year You also might have watched its trailer Though you definitely missed the main idea about its plot so let me lift the veil of secrecy Lara is going to explore yet another dangerous dungeon Game designers decided to use good old 2D environment The dungeon can be represented as a rectangle matrix of rows and columns Cell is the cell in the th row in the th column Lara can move between the neighbouring by side cells in all four directions Moreover she has even chosen the path for herself to avoid all the traps She enters the dungeon in cell that is top left corner of the matrix Then she goes down all the way to cell the bottom left corner Then she starts moving in the snake fashion all the way to the right one cell up then to the left to the cell in nd column one cell up She moves until she runs out of non visited cells and given are such that she always end up in cell Lara has already moved to a neighbouring cell times Can you determine her current position ,Naive solution would be just simulate the tranversal and break when steps are made Obviously this won t fit into time limit Then we can decompose the path to some parts which can be calculated separately Walk from the top left to the bottom left corner Walk from second column to th on even rows Walk from th column to second on odd rows If then it s the first part Otherwise you can use the fact that rows are of the same length will tell you the row and will get you the number of steps Lara have made along this row Overall complexity ,The constraints tell us that the solution should be linear or pretty close to it Well in particular that implies that the solution almost certainly isn t dynamic programming since we have both and to care about Thus we ll think about something greedy When we know the number of move the game will last we can tell how many steps each chip should make Well since the more moves the game last the more steps each ship makes the answer is a monotonic function Let s apply binary search and think if we can check if each chip can make some known number of steps A common idea in the problems where you have to do something greedily on a tree is to root the tree arbitrarily and process everything bottom up Consider the bottommost chip If it can move its number of moves downwards it s always optimal to do that Since it s the bottommost chip it can only make things worse for chips above it And any of them can t pass through the initial vertex of this chip anyway If it can t it has to move to its parent vertex Let s move it there and deal with this chip later when it becomes the bottommost again If it can t move to its parent it can t move at all Thus the game can t last for this many steps Since we only apply either the move which is guaranteed to not interrupt any other moves or the move which is forced the greedy strategy is correct As for implementation details it s not too tricky Basically for each vertex we should maintain these values if this vertex has been visited the number of steps the chip in this vertex still has to make if any chip is in this vertex the longest path downwards from this vertex via non visited vertices The second value can be initialized beforehand and pushed to the parent when needed The rest of them are easily maintained with a single dfs Overall complexity per testcase 
1096,You are given two circles Find the area of their intersection ,If the circles don t intersect than the answer is 0 We can check that case with only integer calculations simply by comparing the square of distance between centers with square of the sum of radiuses If one of the circles is fully in other then the answer is the square of the smaller one We can check this case also with only integer calculations simply by comparing the square of distance between centers with square of the difference of radiuses So now let s consider the general case The answer will be equal to the sum of two circular segments Let s consider the triangle with apexes in centers if circles and in some intersecting point of the circles In that triangle we know all three sides so we can compute the angle of the circular segment So we can compute the square of circular sector And the only thing that we should do now is to subtract the square of triangle with apexes in the center of circle and in the intersecting points of circles We can do that by computing the half of absolute value of cross product So we have the following formulas where d is the distance between centers of the circles And also we should do the same thing with second circle by replacing of indices 1 ftrightarrow2 Complexity O 1 ,There are at least two solution to the problem I ll describe both of them The first solution firstly let s notice that the point we search can have non integer coordinates but if the answer exists then there will be the answer such that its point has at most half integer coordinates So let s multiply all coordinates by two and solve the problem with integer coordinates The second thing is that for some there is only two points we need to check top point with this and bottom point with this The same for some So we can iterate over all possible values of and check if the point lies outside of both black rectangles The same with point Then do the same for points and should be in range and should be in range Time complexity is linear on size of the white rectangle The second solution is most tricky but has the better time complexity Let be the intersection of white rectangle and the first black rectangle the same but with the second black rectangle and be the intersection of and Then it is obvious that the answer exists if and doesn t cover the whole white rectangle Time complexity 
1097,You are given an array with elements Each element of is either or Let s denote the length of the longest subsegment of consecutive elements in consisting of only numbers one as You can change no more than zeroes to ones to maximize ,Let s call the segment good if it contains no more than zeroes Note if segment is good than the segment is also good So we can use the method of two pointers the first pointer is and the second is Let s iterate over from the left to the right and move while we can to do that we should simply maintain the number of zeroes in the current segment ,Intersection of some segments is If this segment has its left bound greater than its right bound then the intersection is empty Removing some segment makes the original sequence equal to That can be split up to a prefix of length and a suffix of length Intersections for them can be precalced separately and stored in some partial sum like arrays Finally you have to iterate over the position of the removed segment and calculate the intersection of prefix and suffix without this segment Overall complexity 
1098,Let s denote that some array is if it contains a subarray of odd length more than and is odd such that If an array is not bad it is Now you are given an array Some elements are replaced by Calculate the number of good arrays you can obtain by replacing each with some integer from to Since the answer can be large print it modulo ,At first array contains a palindromic subarray of length is equivalent to array contains a palindromic subarray of length So we need to calculate number of arrays without palindromes of length It s equivalent to finding arrays where for all appropriate Note that and have same parity so all odd and all even positions in array are independent and answer is the product of the number of ways to choose numbers for odd positions and the number of ways to choose numbers for even positions In terms of same parity our condition morphs to and we need to calculate all ways to replace s in such way that all pairs of consecutive elements are different To calculate it let s look at sequences of consecutive s They will look like with s where and are positive case where is empty can be considered as case with empty is solved the same way In the end we need to find a way to calculate the number of those sequences There are only two fundamental types of sequences same value from both ends and Exact values of and don t really matter Let s find a way to calculate both values name them and for consecutive s in time Base values Let s try to choose value of in the middle of sequence if then we can split sequence in two sequences of length and and If then just iterate over value of last then and Resulting complexity is ,Ideally we would want the fixedness values to be That would make a chain of length However it s impossible to have fixedness of after one swap The first swap always makes a permutation with fixedness Okay how about then That turns out to always be achievable For example swap elements and then elements and then and and so on Overall complexity per testcase 
1099,You find yourself on an unusual crossroad with a weird traffic light That traffic light has three possible colors red yellow green It is known that the traffic light repeats its colors every seconds and at the th second the color is on That way the order of the colors is described by a string For example if then the traffic light works as the following red green green red yellow red green green red yellow and so on More formally you are given a string of length At the first second the color is on at the second at the th second the color is on at the st second the color is on and so on You need to cross the road and that can only be done when the green color is on You know which color is on the traffic light at the moment but you don t know the current moment of time You need to find the minimum amount of time in which you are guaranteed to cross the road You can assume that you cross the road immediately For example with and the current color there are two options either the green color will be on after second or after That way the answer is equal to that is the number of seconds that we are guaranteed to cross the road if the current color is ,Let s note that for each second of color in the traffic light we need to find the rightmost green time and then find the largest distance between color and the nearest green Also let s not forget that traffic light states are cyclical To get rid of cyclicity you can write the string twice and for each cell of color from the first half find the nearest green color thus we solved the problem with cyclicity And now we can just follow this line from right to left and maintain the index of the last occurrence of green If we encounter color then we try to update our answer where is our answer is the nearest time that green was on color current time ,There are some solutions based on case analysis but in my opinion the most elegant one is the following Let s pick a color with the maximum possible number of pixels and repaint all other pixels into it We will try to pick all pixels of some other color and repaint them in one operation and we can ignore the constraint that we can repaint no more than pixels since we will never need to repaint or pixels in one operation So the number of operations is just the number of colors other than the one we chosen or just where is the number of different colors in the image To calculate this we can use a set or an array of size where we mark which colors are present 
1100,Alice and Bob have a rectangular board consisting of rows and columns Alice and Bob play the following game They choose two integers and such that and cut the board in such a way that only the part of it between column and column inclusive remains So all columns to the left of column and all columns to the right of column no longer belong to the board After cutting the board they move chips on the remaining part of the board the part from column to column They make alternating moves and the player which cannot make a move loses the game The first move is made by Alice the second by Bob the third by Alice and so on During their move the player must choose one of the chips from the board and move it any positive number of cells to the left so if the chip was in column it can move to any column and the chips in the leftmost column cannot be chosen Alice and Bob have pairs of numbers and For each such pair they want to determine who will be the winner of the game if and Note that these games should be considered independently they don t affect the state of the board for the next games and both Alice and Bob play optimally ,The model solution is where but it seems that there are faster ones I ll explain the model solution nevertheless It s easy to see using simple Nim theory that the answer for a query is iff the xor of for all chips such that is equal to Let s calculate this xor for every query This number contains at most bits and we will process these bits differently we will choose some number and use one solution to calculate lowest bits and another solution to compute highest bits One idea is common in both solutions we split each query into two queries a query can be represented as a combination of two queries and where is the xor of all numbers such that After converting the queries for every store each query of the form in some sort of vector or any other data structure We will use an approach similar to sweep line iterate on and solve the queries for the current These ideas will be used both for the solution calculating lowest bits and for the solution calculating highest bits How to find lowest bits in each query Iterate on from to and maintain the number of occurrences of each number we met so far Then at a moment we want to calculate simply iterate on all of the values of and process each value in if the number of occurrences of some value is odd update the current answer to the query by xoring the number with otherwise just skip it And since we are interested only in lowest bits for each we need only the remainder so the number of different values is Thus this part of the solution runs in Okay what about highest bits in each query We can see that for every number the highest bits of don t change too often when we iterate on there will be about segments where the highest bits of have different values We can build a data structure that allows use to process two queries xor all numbers on a segment with some value and get the value in some position Fenwick trees and segment trees can do it Then we again iterate on from to When we want to process a number we find the segments where the highest bits of have the same value and perform updates on these segments in our data structure When we process a query of the form we simply get the value in the position from our data structure This part of the solution works in By choosing optimally we can combine these two parts into a solution with complexity of ,Let s firstly try to come up with some naive solution Suppose we have a list and want to calculate for it Let s sort this list comparing the pairs by their values of and then process them one by one We will divide this list into some parts we will call them with the following process when processing the first pair in the sorted order let s iterate on the next pairs also in the sorted order and add them to the first pair s component until the following condition is met where is the index of the first pair we added and is the index of the pair we are currently trying to add to s component remember that we consider all these pairs in the sorted order What is the meaning of this condition means that the number of pairs between and including these two is not less that the number of integers in and while this condition is met we can use the first operation in order to make a pair having for every And the first time when the condition is met we obviously cannot expand the segment in such a way It means that the value of will always be greater than value of and won t belong to the same component with and will start creating its own component instead These components we form have one special property Suppose we expanded the component so that there are no two equal values of in it Then we may reorder the pairs in this component as we wish to do so we may contract the component using the second operation and then expand it again Of course the best course of action is to sort the pairs in the component by their values of in descending order After doing this for every component we will obtain an optimal configuration such that all values of are distinct and it s easy to calculate the answer Okay now we need to do it fast The following will help us DSU Some implicit logarithmic data structure the operations we need are count the sum of elements less than and count the number of elements greater than your implementation might use other operations Small to large merging DSU will help us maintain the components A data structre will be built for each component containing the values of in it it will help us to maintain the sum of where is the optimal index of in this component Depending on your implementation you may or may not need to store the minimum value of in the component When inserting some element having into some component the elements having don t change their position the new element will be added right after them and the remaining elements will be shifted to the right so the sum of can be maintained if we query the number of elements greater than and the sum of elements less than Okay but we still don t know how we create the components and how we determine if two components are to merge We will keep these components in expanded form that is when processing a pair let s find the leftmost unoccupied position after or if it is not occupied and occupy it with the new pair creating a new component for it If the newly occupied index is let s try to merge new component with components occupying and if there are any to merge two components do the required operations in DSU and unite the data structures built in these components with small to large method All this works in the most time consuming part is merging the data structures 
1101,Oh New Year The time to gather all your friends and reflect on the heartwarming events of the past year friends live in a city which can be represented as a number line The th friend lives in a house with an integer coordinate The th friend can come celebrate the New Year to the house with coordinate or stay at Each friend is allowed to move no more than once For all friends holds however they can come to houses with coordinates and if their houses are at or respectively For example let the initial positions be The final ones then can be and so on The number of occupied houses is the number of distinct positions among the final ones So all friends choose the moves they want to perform After that the number of occupied houses is calculated What is the minimum and the maximum number of occupied houses can there be ,At first treat the two subtasks as completely independent problems For both solutions the array of frequences is more convinient to use so let s build it is the number of friends living in house 1 MinimumCollect the answer greedily from left to right If then proceed to otherwise add to the answer and proceed to To prove that let s maximize the number of merges of houses instead of minimizing the actual count of them It s easy to show that the final number of houses is the initial one minus the number of merges So if there are people in all consecutive houses starting from then merges is the absolute best you can do with them skipping any of the merges won t get the better answer For only of them occupied merge is the best and we can achieve that merge And a single occupied house obviously will do merges 2 MaximumAlso greedy but let s process the houses in segments of consecutive positions with positive Take a look at the sum of some segment of houses If the sum is greater than the length then you can enlarge that segment house to the left or to the right If the sum is greater by at least than you can enlarge it both directions at the same time Thus the following greedy will work Let s update the segments from left to right For each segments check the distance to the previous one if it was enlarged to the right then consider the new right border If you can enlarge the current segment and there is space on the left then enlarge it And if you still have possibility to enlarge the segment then enlarge it to the right Notice that it doesn t matter which of any pair of consecutive segments will take the spot between them as the answer changes the same The initial segments can be obtained with two pointers Overall complexity ,Firstly note that if we want to buy as many packs as possible then it s optimal to buy the cheapest packs In other words if we sort all packs we ll always buy a prefix of array Next note that each day we buy some number of packs so instead of iterating through the days we can iterate through the number of packs and for each calculate the number of days we ll buy exactly packs Since the prices increasing and at day the price is then exists last day such that as days we could buy packs and at days we can t And we can find as maximum possible integer solution to inequation or We can calculate all using prefix sums in linear time As a result we buy packs in days in total packs in days in total packs in days in total and so on The resulting complexity is because of sort 
1102,You got a job as a marketer in a pet shop and your current task is to boost sales of cat food One of the strategies is to sell cans of food in packs with discounts Suppose you decided to sell packs with cans in a pack with a discount and some customer wants to buy cans of cat food Then he follows a greedy strategy he buys packs with a discount then he wants to buy the remaining cans one by one But customers are greedy in general so if the customer wants to buy cans one by one and it happens that he decides to buy the whole pack of cans instead of buying cans It makes you as a marketer happy since the customer bought more than he wanted initially You know that each of the customers that come to your shop can buy any number of cans from to inclusive Can you choose such size of pack that each customer buys more cans than they wanted initially ,Note that if then exists such that and obviously a customer who wants to buy cans won t buy more than he wants That s why and we can rephrase our task as finding such that The longer the segment is the better and the maximum we can take is As a result we need to check that ,Let be the total number of candies with all bags with an even number of candies and the total of all bags with an odd number of candies If then the answer is because at the end Mihai who takes only even numbers of candies will have less candies than Bianca Otherwise if the answer is The construction is to simply put all even bags first and then all odd bags since all even bags come before all odd bags and at any point in time Mihai will have more candies than Bianca The time complexity is 
1103,A sequence of numbers is called if it contains all numbers from to exactly once For example the sequences and are permutations but and are not For a permutation of even length you can make an array of length such that for For example if then As a result we made For a given array find the permutation such that you can make the given array from it If then the lexicographically minimal permutation from which it can be made is since A permutation is lexicographically smaller than a permutation if and only if there exists such that and ,First let s check the array for correctness that is that it has no repeating elements Then let s look at the following ideas each number must be paired with another permutation element with by the definition of array Then since we want a lexicographically minimal permutation it is always more advantageous to put element before for the permutation to be lexicographically minimal the smallest possible numbers must be placed at the beginning Consequently the largest numbers must be placed at the end Let s proceed as follows Let s select the set of numbers that are not included in the array For an element find the maximum number of the set such that and put that number in front of the element moving from the end of the array to its beginning each element will be matched with such an element If at some point can not be matched array is not composed correctly and the answer to the query Otherwise print and the resulting permutation ,Suppose we want to move an element from the prefix to the suffix if we need to move an element from the suffix to the prefix we can just reverse the array and do the same thing Suppose the resulting prefix will contain elements Then we need to check that the prefix with elements contains an element such that the sum of this prefix without this element is equal to the half of the sum of the whole array and then we can move this element to the suffix To check all the prefixes we can scan the array from left to right while maintaining the set of elements on the prefix and the sum of these elements 
1104,Each evening Roma plays online poker on his favourite website The rules of poker on this website are a bit strange there are always two players in a hand there are no bets and the winner takes virtual bourle from the loser Last evening Roma started to play poker He decided to spend no more than virtual bourles he will stop immediately if the number of his loses exceeds the number of his wins by Also Roma will leave the game if he wins enough money for the evening i e if the number of wins exceeds the number of loses by Next morning Roma found a piece of paper with a sequence on it representing his results Roma doesn t remember the results exactly and some characters in the sequence are written in a way such that it s impossible to recognize this character so Roma can t recall whether he won bourles or he lost The sequence written by Roma is a string consisting of characters Roma won the corresponding hand Roma lost draw and unknown result Roma wants to restore any sequence by changing all characters to or The sequence is called if all these conditions are met In the end the absolute difference between the number of wins and loses is equal to There is no hand such that the absolute difference before this hand was equal to Help Roma to restore any such sequence ,This problem can be solved using dynamic programming is if Roma could play first games with balance is and for each such that and we update if if if and all three states if If either of and is then we can restore the sequence Time and memory complexity is As an exercise you can think about linear solution ,Note that if Bob has increased some element then Alice can t remove it on the next stages Obviously it is more profitable for Bob to prohibit the smallest element of the array Using this fact we can iterate over the value of and then simulate the game process To simulate the game we can maintain the set of elements that Alice can remove On the th stage Alice removes the maximum element such that if there are no such elements then Alice lost Bob always removes the minimum element of the set Thus the complexity of the solution is for each test case There is another possible solution we can notice that if Alice wins Bob will prohibit the elements on positions of the sorted array So Alice has to delete the next elements So if the segment of the sorted array can be deleted by Alice during the game phases she wins with this value of 
1105,There are points on a plane The th point has coordinates You have two horizontal platforms both of length Each platform can be placed anywhere on a plane but it should be placed on the same coordinate and have If the left border of the platform is then the right border is and all points between borders including borders belong to the platform Note that platforms can share common points overlap and it is not necessary to place both platforms on the same coordinate When you place both platforms on a plane all points start falling down decreasing their coordinate If a point collides with some platform at some moment the point stops and is Points which never collide with any platform are lost Your task is to find the maximum number of points you can if you place both platforms optimally You have to answer independent test cases For better understanding please read the section below to see a picture for the first test case ,Firstly we obviously don t need coordinates at all because we can place both platforms at Let s sort all coordinates in non decreasing order Calculate for each point two values and where is the number of points to the left from the point including that are not further than from the th point i e the number of such points that And is the number of points to the right from the point including that are not further than from the th point Both these parts can be done in using two pointers Then let s build suffix maximum array on and prefix maximum array on For just iterate over all from to and do For just iterate over all from to and do The question is what What did we do We did the following thing the answer always can be represented as two non intersecting segments of length such that at least one endpoint of each segment is some input point Now let s fix this border between segments Iterate over all from to and update the answer with So we took segment that starts at some point to the left from including and goes to the left and took some segment that starts further than including and goes to the right With this model we considered all optimal answers that can exist Time complexity ,There is a solution in but in fact a solution that checks all points with coordinate from to and coordinate from to is fast enough There s no need to check any other points since implies that point is on one of the shortest paths between and 
1106,You are given two integers and Calculate the number of integers such that and Note is the greatest common divisor of and ,The Euclidean algorithm is based on the next fact if then So if then So we can declare that we are looking at different integers with so all forms a segment So we need to find the number of such that Let s denote then and So or Since so we also can represent and therefore Since then or we need to calaculate the number of such that Since so we can consider and this is the definition of Euler s totient function which is the answer Euler s totient function can be calculated using factorization of Then ,Let be the number of elements of with the remainder modulo Then the initial answer can be represented as and we have to compose numbers with remainders and somehow optimally It can be shown that the best way to do it is the following firstly while there is at least one remainder and at least one remainder let s compose them into one After this at least one of the numbers will be zero then we have to compose remaining numbers into numbers divisible by If then the maximum remaining number of elements we can obtain is because and in the other case the maximum number of elements is because 
1107,You are given an integer array and integer In one step you can either choose some index and decrease by one make or choose two indices and and set equal to make What is the minimum number of steps you need to make the sum of array You are allowed to make values of array negative ,First we can prove that the optimal way to perform operations is first decrease the minimum value several maybe zero times then take several maybe zero maximums and make them equal to the minimum value The proof consists of several steps Prove that first we make decreases only then sets if some is done after some then if there were no modification of then you can just move earlier Otherwise there were and you can replace with We demonstrated how to move decrease operations before set operations Prove that it s optimal to decrease only one element instead of decreasing by and by where we can decrease by and replace all with It s optimal to decrease the minimum element it follows from proof of previous step If we make set operations it s optimal to set minimum value to maximum elements should be obvious To use the strategy we ll firstly sort array in non decreasing order In this case we ll decrease by and perform set to elements The question is how to minimize value of Note that since setting the same position multiple times has no sense Let s iterate over all possible values of and determine the minimum needed The resulting array will consists of Let s say that and all can be precomputed beforehand Then the sum of array will become and we need or since we need minimum possible Using the formula above we can for each calculate minimum required But to be accurate value may be negative and usually in programming languages integer division for negative returns instead of There is an alternative solution note that if then Note that if then resulting value of is in and there are at most possible value for So you can iterate over all possible and for each calculate minimum required either with binary search or two pointers ,Let s replace each number with the number of unique numbers less than For example the array will be replaced by Note that the values of the numbers themselves were not important to us only the order between them was important Let s sort such an array Let s see what maximum length of the segment from the array is already sorted it forms a subsequence This segment can be left in place and all other numbers can be moved either to the beginning or to the end That is the task came down to finding the maximum sorted subsequence in the array This problem can be solved with the help of simple dynamic programming Let be the maximum length of a subsequence ending in position To calculate it we will find the closest past position which also has the value and the position with value lower numbers cannot be used since must stand between them Any of these positions can be extended so we take the maximum out of them and add 1 It is necessary to separately consider the first numbers in the subsequence and the last since the first should include their suffix and the last should have their prefix 
1108,Recently Petya learned about a new game Slay the Dragon As the name suggests the player will have to fight with dragons To defeat a dragon you have to kill it and defend your castle To do this the player has a squad of heroes the strength of the th hero is equal to According to the rules of the game exactly one hero should go kill the dragon all the others will defend the castle If the dragon s defense is equal to then you have to send a hero with a strength of at least to kill it If the dragon s attack power is then the total strength of the heroes defending the castle should be at least The player can increase the strength of any hero by for one gold coin This operation can be done any number of times There are dragons in the game the th of them has defense equal to and attack power equal to Petya was wondering what is the minimum number of coins he needs to spend to defeat the th dragon Note that the task is solved improvements are not saved ,It is enough to consider two cases whether we will increase the strength of the hero who will kill the dragon or not If you do not increase the hero s strength then you have to choose such that Obviously among such you have to choose with the minimum value because the strength of defending heroes is equal to It remains to increase the total strength of the remaining heroes to So the required number of coins is equal to If you increase the hero s strength then you have to choose the maximum value of which is less than In this case the required number of coins is to increase the strength of the hero who will kill the dragon plus to increase the strength of the defending heroes To find the heroes with strength as close to as possible you can use binary search don t forget to sort the heroes beforehand ,For each game we want to seat people at tables of them will be big and will sit at them and will be small Each round people will sit at the big tables Let s put people with numbers at large tables in the first round for convenience we index from zero and the rest for small ones in the second round we will seat people at large tables with numbers and so on We cycle through the players from to in blocks of Since no one person can be ahead of any other by 2 or more large tables 
1109,You are playing a variation of game Initially you have a multiset of integers Every integer in this multiset is a power of two You may perform any number possibly zero operations with this multiset During each operation you choose two integers from remove them from and insert the number equal to their sum into For example if and you choose integers and then the multiset becomes You win if the number belongs to your multiset For example if you can win as follows choose and your multiset turns into Then choose and your multiset turns into and you win You have to determine if you can win this game You have to answer independent queries ,It s obvious that we don t need elements that are larger than If the sum of the remaining elements is greater than or equal to 2048 then the answer is and otherwise It s true because for getting a integer that wasn t in the multiset initially we first need to get integer ,The only fact required to solve this problem is just to notice that the answer array is just an arithmetic progression After that we can fix the first element fix the difference construct the array check if and are in this array and if yes update the answer with This is solution There are faster solutions though Other author s solution is but I didn t want to make this problem harder so I allowed solutions It is obvious that the difference of the progression is some divisor of Let it be Let s add some elements starting from to the left and so on and stop if we reach elements or the next element is less than If we didn t find among these elements just skip this difference it is useless for us Otherwise if we have less than elements let s add and so on until we get elements And then update the answer with the maximum element of the array There is also a solution in with some greedy observations 
