statement,editorial
You are given an expression of the form where and are integers from to You have to evaluate it and print the result ,There are multiple ways to solve this problem Most interpreted languages have some function that takes the string evaluates it as code and then returns the result One of the examples is the function in Python If the language you use supports something like that you can read the input as a string and use it as the argument of such a function Suppose you use a language where this is impossible There are still many approaches to this problem The most straightforward one is to take the first and the last characters of the input string calculate their ASCII codes and then subtract the ASCII code of the character from them to get these digits as integers not as characters Then you can just add them up and print the result 
You are given two positive integers and In one move you can in the following way Choose any positive integer and replace with choose any positive integer and replace with You can perform as many such operations as you want You can choose the same numbers and in different moves Your task is to find the minimum number of moves required to obtain from It is guaranteed that you can always obtain from You have to answer independent test cases ,If then the answer is Otherwise if and is even or and is odd then the answer is Otherwise the answer is you can always make case in one move 
Mishka got an integer array of length as a birthday present what a surprise Mishka doesn t like this present and wants to change it somehow He has invented an algorithm and called it Mishka s Adjacent Replacements Algorithm This algorithm can be represented as a sequence of steps Replace each occurrence of in the array with Replace each occurrence of in the array with Replace each occurrence of in the array with Replace each occurrence of in the array with Replace each occurrence of in the array with Replace each occurrence of in the array with Replace each occurrence of in the array with Replace each occurrence of in the array with Note that the dots in the middle of this algorithm mean that Mishka applies these replacements for each pair of adjacent integers for each as described above For example for the array the following sequence of arrays represents the algorithm replace all occurrences of with replace all occurrences of with replace all occurrences of with replace all occurrences of with replace all occurrences of with replace all occurrences of with replace all occurrences of with The later steps of the algorithm do not change the array Mishka is very lazy and he doesn t want to apply these changes by himself But he is very interested in their result Help him find it ,It is easy to see that for the odd elements there is no changes after applying the algorithm described in the problem statement and for the even elements there is only one change each of the even elements will be decreased by So we can iterate over all the elements of the array and print where is taking modulo Overall complexity is 
You are given an array consisting of integers In one move you can choose two indices such that and set You can perform such moves any number of times possibly zero You can choose different indices in different operations The operation is the operation of assignment i e you choose and and replace with Your task is to say if it is possible to obtain an array with an odd not divisible by sum of elements You have to answer independent test cases ,Firstly if the array already has an odd sum the answer is Otherwise we need to change the parity of the sum so we need to change the parity of some number We can do in only when we have at least one even number and at least one odd number Otherwise the answer is 
There is a building consisting of apartments numbered from to inclusive Call an apartment if its number consists of Examples of boring apartments are and so on Our character is a troublemaker and he calls the intercoms of all apartments till someone answers the call in the following order First he calls all apartments consisting of digit in increasing order Next he calls all apartments consisting of digit in increasing order And so on The resident of the boring apartment answers the call and our character calling anyone further Our character wants to know how many digits he pressed in total and your task is to help him to count the total number of keypresses For example if the resident of boring apartment answered then our character called apartments with numbers and the total number of digits he pressed is You have to answer independent test cases ,This problem has a lot of solutions You could even hard code all possible tests to solve it But this problem has solution Let the digit of be Then our character pressed each digit before exactly times And the amount of times he pressed the digit depends on the length of Let be the length of then the amount of times he pressed the digit is So the final answer is 
There are two sisters Alice and Betty You have candies You want to distribute these candies between two sisters in such a way that Alice will get candies Betty will get candies each sister will get some number of candies Alice will get a greater amount of candies than Betty i e all the candies will be given to one of two sisters i e Your task is to calculate the number of ways to distribute exactly candies between sisters in a way described above Candies are indistinguishable Formally find the number of ways to represent as the sum of where and are positive integers and You have to answer independent test cases ,The answer is where is rounded down 
Recently Vova found candy wrappers He remembers that he bought candies during the first day candies during the second day candies during the third day candies during the th day But there is an issue Vova remembers neither nor but he is sure that and are positive integers and Vova will be satisfied if you tell him integer so there is an integer that It is guaranteed that at least one solution exists You have to answer independent test cases ,Notice that sum limits i 0 k 1 2 i 2 k 1 Thus we can replace the initial equation with the following 2 k 1 x n So we can iterate over all possible k in range 2 29 because 2 30 1 10 9 and check if n is divisible by 2 k 1 If it is then we can print x frac n 2 k 1 P S I know that so many participants found the formula sum limits i 0 k 1 2 i 2 k 1 using geometric progression sum but there is the other way to understand this and it is a way more intuitive for me Just take a look at the binary representation of numbers we can notice that 2 0 1 2 1 10 2 2 100 and so on Thus 2 0 1 2 0 2 1 11 2 0 2 1 2 2 111 and so on And if we add one to this number consisting of k ones then we get 2 k 
For the New Year Polycarp decided to send postcards to all his friends He wants to make postcards with his own hands For this purpose he has a sheet of paper of size which can be cut into pieces Polycarp can cut any sheet of paper that he has in only two cases If is even then he can cut the sheet in half and get two sheets of size If is even then he can cut the sheet in half and get two sheets of size If and are even at the same time then Polycarp can cut the sheet according to any of the rules above After cutting a sheet of paper the total number of sheets of paper is increased by Help Polycarp to find out if he can cut his sheet of size at into or more pieces using only the rules described above ,If we cut the sheet in width we will reduce its width by half without changing the height Therefore the width and height dimensions do not affect each other in any way Let s calculate the maximum number of sheets that we can get by cutting Let s say that initially this number is Let s cut the sheet in width Then the sheets number will become but they will be the same If we can cut the sheet again it is more profitable to cut all the sheets we have because this way we will get more new sheets and their size will still be the same So we can maintain the current number of identical sheets and as long as either the width or height is divided by divide it and multiply the number of sheets by two 
Casimir has a string which consists of capital Latin letters and only Each turn he can choose to do one of the two following actions he can either erase exactly one letter exactly one letter from arbitrary places of the string these letters don t have to be adjacent or he can erase exactly one letter exactly one letter from arbitrary places in the string these letters don t have to be adjacent Therefore each turn the length of the string is decreased exactly by All turns are independent so for each turn Casimir can choose any of two possible actions For example with he can obtain a string in one turn by erasing the first occurrence of and the second occurrence of There are also many other options for a turn aside from this particular example For a given string determine whether there is a sequence of actions leading to an empty string In other words Casimir s goal is to erase all letters from the string Is there a way to do this ,Note that no matter which action is chosen after this action is performed one letter is erased from the string two letters in total are erased from the string Let s denote the length of the string by If is odd then described turns can not erase all the characters from the strings because if he is deleting two letters on each turn the length will always remain odd For example if the original length of the string is then after one turn it will be equal to and after two moves it will be equal to in which case the next turn is impossible Thus if the length of the row is odd the answer is If is even it will take exactly steps to erase all characters from the string Since each action removes exactly one letter from the string the string can become empty only if there are exactly letters Let us show that this condition is sufficient that is if a string has exactly half of the letters equal to then there always exists a sequence of actions leading to an empty string Indeed if a string of length has exactly letters exactly letters and exactly letters then Then Casimir can make moves of the first type each time removing the first occurrence of and the first occurrence of and moves of the second type each time removing the first occurrence of and the first occurrence of After such moves the string will become empty Thus checking that the number of letters in the string is exactly half of its length was enough to solve the problem 
You are given chips on a number line The th chip is placed at the integer coordinate Some chips You can perform each of the two following types of moves any possibly zero number of times on any chip Move the chip by to the left or to the right i e replace the current coordinate with or with move the chip by to the left or to the right and pay for this move i e replace the current coordinate with or with Note that it s allowed to move chips to any integer coordinate including negative and zero Your task is to find the minimum total number of coins required to move all chips to the same coordinate i e all should be equal after some sequence of moves ,We can see that the only information we need is the parity of the coordinate of each chip because we can move all chips that have the same parity to one coordinate for free So if the number of chips with odd coordinate is then the answer is 
There are students standing in a circle in some order The index of the th student is It is guaranteed that all indices of students are distinct integers from to i e they form a permutation Students want to start a round dance A round dance can be started if the student comes right after the student in clockwise order there are no students between them the student comes right after the student in clockwise order and so on and the student comes right after the student in clockwise order A round dance is almost the same thing the only difference is that the student should be right after the student in counterclockwise order this condition should be met for every from to For example if the indices of students listed in clockwise order are then they can start a clockwise round dance If the students have indices in clockwise order then they can start a counterclockwise round dance Your task is to determine whether it is possible to start a round dance Note that the students cannot change their positions before starting the dance they cannot swap or leave the circle and no other student can enter the circle You have to answer independent queries ,We just need to find the position of the in the array and then check if the sequence is going counterclockwise or clockwise from the position or correspondingly We can do this by two cycles Total complexity 
Polycarp has three sisters Alice Barbara and Cerene They re collecting coins Currently Alice has coins Barbara has coins and Cerene has coins Recently Polycarp has returned from the trip around the world and brought coins He wants to distribute these coins between his sisters in such a way that the number of coins Alice has is equal to the number of coins Barbara has and is equal to the number of coins Cerene has In other words if Polycarp gives coins to Alice coins to Barbara and coins to Cerene then that A B or C the number of coins Polycarp gives to Alice Barbara and Cerene correspondingly can be 0 Your task is to find out if it is possible to distribute coins between sisters in a way described above You have to answer independent test cases ,Suppose If it isn t true then let s rearrange our variables Then we need at least coins to make and equal So if then the answer is Otherwise the answer if if the number is divisible by This is true because after making and equal we need to distribute all remaining candies between three sisters 
Two T shirt sizes are given and The T shirt size is either a string or a string consisting of several possibly zero characters and one of the characters or For example strings could be the size of some T shirts And the strings are not sizes The letter stands for medium for small for large The letter refers to the degree of size from eXtra For example is extra extra large bigger than and smaller than You need to compare two given sizes of T shirts and The T shirts are compared as follows any small size no matter how many letters is smaller than the medium size and any large size any large size regardless of the number of letters is larger than the medium size and any small size the more letters before the smaller the size the more letters in front of the larger the size For example ,Let are the last characters of lines and respectively And are the sizes of these strings then the answer depends only on and and is uniquely defined as the inverse of to if if since the characters are in reverse order in the alphabet Then the answer is This also covers the case Then the larger the size of the string the smaller the size of the t shirt That is the answer is if and if Then the larger the size of the string the smaller the size of the t shirt That is the answer is if and if 
The string is given the string length is number The string consists of lowercase letters of the Latin alphabet As long as the string length is greater than the following operation can be performed on it select any two adjacent letters in the string and delete them from the string For example from the string in one operation you can get any of the four strings or In particular in one operation the length of the string reduces by Formally let the string have the form During one operation you choose an arbitrary index and replace For the given string and the letter determine whether it is possible to make such a sequence of operations that in the end the equality will be true In other words is there such a sequence of operations that the process will end with a string of length which consists of the letter ,There will be one character left in the end so we have to delete all the characters going before and after it That is delete some prefix and suffix Since we always delete some substring of length we can only delete the prefix and suffix of even length it means the answer is in the case when there is an odd position in with the character and otherwise 
Polycarp doesn t like integers that are divisible by or end with the digit in their decimal representation Integers that meet both conditions are disliked by Polycarp too Polycarp starts to write out the positive greater than integers which he likes Output the th element of this sequence the elements are numbered from ,The solution is simple let s create an integer variable initially set to that will contain the number of considered liked integers Let s iterate over all positive integers starting with Let s increase the variable only when the considered number is liked If the variable is equal to let s stop the iteration and output the last considered number Since the answer for is the count of considered numbers is at most so the solution will work on the specified limitations fast enough 
A string is called if it contains consecutive adjacent letters of the Latin alphabet and each letter occurs exactly once For example the following strings are diverse and The following string are diverse and Note that the letters and are not adjacent Formally consider positions of all letters in the string in the alphabet These positions should form contiguous segment i e they should come one by one without any gaps And all letters in the string should be distinct duplicates are not allowed You are given a sequence of strings For each string if it is diverse print Otherwise print ,The string is diverse if it is a permutation of some substring of the Latin alphabet In other words the string is diverse if all letters in it are distinct we can check it using some structure like or array of used elements and if the number of letters between the letter with the maximum alphabet position and the letter with the minimum alphabet position plus one is exactly the length of the string For example the position in alphabet of letter is one the position of letter is six and so on 
There are students in a school class the rating of the th student on Codehorses is You have to form a team consisting of students such that the ratings of all team members If it is impossible to form a suitable team print without quotes Otherwise print and then print distinct numbers which should be the indices of students in the team you form If there are multiple answers print any of them ,Let s write our unique function Keep the array of the taken elements Iterate over all elements in the array and if the current element is not used then add its index to the answer and set When finished check the number of distinct values that is the size of answer array If it is less than print Otherwise print and output the first elements of the answer 
You are given an integer You can perform any of the following operations with this number an arbitrary possibly zero number of times Replace with if is divisible by Replace with if is divisible by Replace with if is divisible by For example you can replace with using the first operation with using the second operation or with using the third operation Your task is to find the minimum number of moves required to obtain from or say that it is impossible to do it You have to answer independent queries ,What if the given number cannot be represented as It means that the answer is because all actions we can do are remove one power of two remove one power of three and add one power of two and remove one power of five and add two powers of two So if the answer is not then it is If this formula isn t pretty clear for you you can just simulate the process performing actions from third to first 
You are given two positive integers and In one move you can increase by replace with Your task is to find the minimum number of moves you need to do in order to make divisible by It is possible that you have to make moves as is already divisible by You have to answer independent test cases ,If is divisible by just print Otherwise we need exactly moves to make zero remainder of modulo is modulo operation 
Polycarp has tasks Each task is designated by a capital letter of the Latin alphabet The teacher asked Polycarp to solve tasks in the following way if Polycarp began to solve some task then he must solve it to the end without being distracted by another task After switching to another task Polycarp cannot return to the previous task Polycarp can only solve one task during the day Every day he wrote down what task he solved Now the teacher wants to know if Polycarp followed his advice For example if Polycarp solved tasks in the following order then the teacher will see that on the third day Polycarp began to solve the task then on the fifth day he got distracted and began to solve the task on the eighth day Polycarp returned to the task Other examples of when the teacher is suspicious and If Polycarp solved the tasks as follows then the teacher cannot have any suspicions Please note that Polycarp is not obligated to solve all tasks Other examples of when the teacher doesn t have any suspicious and Help Polycarp find out if his teacher might be suspicious ,The simplest solution go through the problem because of which the teacher might have suspicions Now you can find the first day when Polycarp solved this problem and the last such day Between these two days all problems should be the same If this is not the case the answer is 
The elections in which three candidates participated have recently ended The first candidate received votes the second one received votes the third one received votes For each candidate solve the following problem how many votes should be added to this candidate so that he wins the election i e the number of votes for this candidate was strictly greater than the number of votes for any other candidate Please note that for each candidate it is necessary to solve this problem i e the added votes for any candidate affect the calculations when getting the answer for the other two candidates ,Let s solve the problem for the first candidate To win the election he needs to get at least more votes than every other candidate Therefore the first candidate needs to get at least votes If is already greater than this value then you don t need to add any votes otherwise you need to add votes So the answer for the first candidate is Similarly the answer for the second candidate is and for the third one the answer is 
You are both a shop keeper and a shop assistant at a small nearby shop You have goods the th good costs coins You got tired of remembering the price of each product when customers ask for it thus you decided to simplify your life More precisely you decided to set the same price for all goods you have However you don t want to lose any money so you want to choose the price in such a way that the sum of new prices is not less than the sum of the initial prices It means that if you sell all goods for the new price you will receive at least the same or greater amount of money as if you sell them for their initial prices On the other hand you don t want to lose customers because of big prices so among all prices you can choose you need to choose the minimum one So you need to find the minimum possible equal price of all goods so if you sell them for this price you will receive at least the same or greater amount of money as if you sell them for their initial prices You have to answer independent queries ,In this problem we need to find the minimum possible such that where is the sum of all equals to where is divided by rounded up 
Vlad like everyone else loves to sleep very much Every day Vlad has to do things each at a certain time For each of these things he has an alarm clock set the th of them is triggered on hours minutes every day Vlad uses the hour time format so after comes and after comes This time Vlad went to bed at hours minutes and asks you to answer how much he will be able to sleep until the next alarm clock If any alarm clock rings at the time when he went to bed then he will sleep for a period of time of length ,To begin with let s learn how to determine how much time must pass before the alarm to trigger If the alarm time is later than the current one then obviously minutes should pass Otherwise this value will be negative and then it should pass since a full day must pass not including the time from the alarm to the current time We just need to find the minimum number of minutes among all the alarm clocks Due to small constrains the problem can also be solved by stimulating the sleep process increase the answer by and check whether any alarm will work after this time 
Polycarp has a favorite sequence consisting of integers He wrote it out on the whiteboard as follows he wrote the number to the left side at the beginning of the whiteboard he wrote the number to the right side at the end of the whiteboard then as far to the left as possible but to the right from he wrote the number then as far to the right as possible but to the left from he wrote the number Polycarp continued to act as well until he wrote out the entire sequence on the whiteboard For example if and then Polycarp will write a sequence on the whiteboard You saw the sequence written on the whiteboard and now you want to restore Polycarp s favorite sequence ,In this problem you can implement an algorithm opposite to that given in the condition Let s maintain two pointers to the left most and right most unhandled element Then restoring the original array you put the left most unhandled item in the first position put the right most unhandled item in the second position put the left most unhandled item in the third position put the right most unhandled item in the fourth position That is in general you put the leftmost elements on all odd positions and the rightmost ones on all even positions After processing each element you either move the left pointer forward by one or the right one backward by one 
Vasya goes to visit his classmate Petya Vasya knows that Petya s apartment number is There is only one entrance in Petya s house and the distribution of apartments is the following the first floor contains apartments every other floor contains apartments each Apartments are numbered starting from one from the first floor I e apartments on the first floor have numbers and apartments on the second floor have numbers from to apartments on the third floor have numbers from to and so on Your task is to find the number of floor on which Petya lives Assume that the house is always high enough to fit at least apartments You have to answer independent test cases ,If then the answer is Otherwise you can remove the first floor and then the answer is 
In the pet store on sale there are packs of dog food packs of cat food packs of universal food such food is suitable for both dogs and cats Polycarp has dogs and cats Is it possible that he will be able to buy food for all his animals in the store Each of his dogs and each of his cats should receive one pack of suitable food for it ,Obviously the best way to buy food for every pet is to buy maximum possible food for dogs and cats then dogs and cats will not get food We will buy universal food for these dogs and cats Then the answer is if and else 
A frog is currently at the point on a coordinate axis It jumps by the following algorithm the first jump is units to the right the second jump is units to the left the third jump is units to the right the fourth jump is units to the left and so on Formally if the frog has jumped an even number of times before the current jump it jumps from its current position to position otherwise it jumps from its current position to position Your task is to calculate the position of the frog after jumps But One more thing You are watching different frogs so you have to answer independent queries ,With each pair of jumps of kind to the right to the left the frog jumps So the answer is almost Almost because there can be one more jump to the right So if is odd then we have to add to the answer 
Polycarp plays Game 23 Initially he has a number and his goal is to transform it to In one move he can multiply by or multiply by He can perform any number of moves Print the number of moves needed to transform to Print if it is impossible to do so It is easy to prove that any way to transform to contains the same number of moves i e number of moves doesn t depend on the way of transformation ,If is not divisible by then just print and stop the program Otherwise calculate denoting the required number of times to multiply It is easy to see that should be a product of zero or more s and of zero or more s i e for integers To find just use a loop to divide by while it is divisible by Similarly to find just use a loop to divide by while it is divisible by After the divisions the expected value of is If print Otherwise print the total number of the loop iterations 
You have a number of length and one additional digit You can insert this digit anywhere in the number including at the beginning or at the end Your task is to make the result as large as possible For example you have the number and the additional digit is Then the maximum number you can get is and it can be obtained in two ways by inserting a digit after the th or after the th digit of the number ,Note that numbers of the same length are compared lexicographically That is until some index the numbers will match and then the digit in our number should be greater Let s write out the numbers until As soon as this condition is false or the line ends insert the digit We got the lexicographically maximum number which means just the maximum number 
You are given an integer sequence You have to divide it into two sets and in such a way that each element belongs to set and is minimum possible The value is the absolute value of and is the sum of elements of the set ,The first solution take modulo and solve the problem manually then for cases and the answer is and for and the answer is Prove Let s see what can we make for numbers and We can add and in and add and in Then the difference between sums will be We can consider last four numbers this way until we have at least four numbers And then we have a case We can prove the solution for these four cases using bruteforce The second solution if is even then the answer is otherwise the answer is The formula above is just Prove if we have an integer sequence then we can obtain every number from to as the sum of some elements of this sequence How Greedily You can see how this greedy works and prove if you want yourself So what s next If is even then we can obtain the sum in and in Otherwise we can only obtain in and in or vice versa 
You were walking down the street and heard a sound The sound was described by the string consisting of lowercase and uppercase Latin characters Now you want to find out if the sound was a cat meowing For the sound to be a meowing the string can only contain the letters and in either uppercase or lowercase Also string must start with non empty sequence consisting only of characters or it must be immediately followed by non empty sequence consisting only of characters or it must be immediately followed by non empty sequence consisting only of characters or it must be immediately followed by non empty sequence consisting only of characters or this sequence ends the string after it immediately comes the string end For example strings describe a meowing but strings do not Determine whether the sound you heard was a cat meowing or something else ,To solve the problem you may convert the string to lower case strip all duplicated characters from it and compare the result to meow string To exclude duplicate characters you can for example use the function in C 
You are given a keyboard that consists of keys The keys are arranged sequentially in one row in a certain order Each key corresponds to a unique lowercase Latin letter You have to type the word on this keyboard It also consists only of lowercase Latin letters To type a word you need to type all its letters consecutively one by one To type each letter you must position your hand exactly over the corresponding key and press it Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys the keys are numbered from left to right No time is spent on pressing the keys and on placing your hand over the first letter of the word For example consider a keyboard where the letters from to are arranged in consecutive alphabetical order The letters and then are on the positions and respectively Therefore it will take units of time to type the word Determine how long it will take to print the word ,Since it does not take time to place your hand over the first letter you need to calculate the sum of the distances between the keyboard keys corresponding to each pair of adjacent letters of the word that is where is the position of the keyboard key corresponding to the letter In order to calculate this sum let s just iterate through the word with the loop and find the differences between the positions of and on the keyboard To find the position of a character on the keyboard you could either use the built in strings functions such as in Python or in C or precalculate each letter s position on the keyboard into a separate array using another loop over a keyboard 
Polycarp has an integer that doesn t contain the digit He can do the following operation with his number several possibly zero times Reverse the prefix of length in other words leftmost digits of So the leftmost digit is swapped with the th digit from the left the second digit from the left swapped with th left etc For example if and then the new value of will be Note that for different operations the values of can be different The number can be equal to the length of the number in this case the whole number is reversed Polycarp loves even numbers Therefore he wants to make his number even At the same time Polycarp is very impatient He wants to do as few operations as possible Help Polycarp Determine the minimum number of operations he needs to perform with the number to make it even or determine that this is impossible You need to answer independent test cases ,If the number is already even then nothing needs to be done so the answer in this case is Now let s recall the divisibility by a number is divisible by if and only if its last digit is divisible by It follows that if there are no even digits in our number then the answer is Let s take a look at our operation What is going on The first digit always changes with the digit numbered In particular when we reverse the entire number the first digit is swapped with the last Note that no other digit except for the first one at the current moment can t be the last Therefore you can do this if the first digit of a number is divisible by then we reverse the whole number The first digit will become the last and the number will become even Therefore you only need to do one operation Now what if the first digit of a number is odd In this case we can find the first even digit in the number let it be at position and reverse the prefix of length in one operation Now the first digit of our number has become even and we can use the previous case one more operation Thus we will do only operations 
You are given a string consisting of lowercase Latin letters and an integer number Let s define a substring of some string with indices from to as Your task is to construct such string of minimum possible length that there are exactly positions such that In other words your task is to construct such string of minimum possible length that there are exactly substrings of equal to It is guaranteed that the answer is always unique ,Let s carry the current answer as the last position we re checked as and the number of occurrences as Initially the answer is is and is 0 indexed We don t need to check the position because there is the beginning of the occurrence of at this position Also is by the same reason Let s repeat the following algorithm while if where ans is the length of the answer let s add to the answer increase and by In the other case let s check if there is a prefix of starting from If it is let be its length Then we need to add the suffix of starting from till the end of increase and by If there is no prefix of starting from the we just increase The other idea is the following we have to find the period of the string Let this period will be Then the answer is repeated times and The period of the string is the minimum prefix of this string such that we can repeat this prefix infinite number of times so the prefix of this infinite string will be For example the period of the string is the period of the string is and the period of the string is The period of the string can be found using prefix function of the string or in naively 
Polycarp is going to participate in the contest It starts at and ends at It is guaranteed that the contest lasts an even number of minutes i e where is modulo It is also guaranteed that the entire contest is held during a single day And finally it is guaranteed that the contest lasts at least two minutes Polycarp wants to know the time of the midpoint of the contest For example if the contest lasts from to then the answer is if the contest lasts from to then the answer is ,Firstly let s parse both strings to four integers Just read them and then use some standard functions to transform them into integers or we can do it manually The second part is to obtain and Then let It is the answer We have to print and where is divided by rounding down and is modulo The only thing we should do more carefully is to print one leading zero before if it is less than and do the same for 
Find the minimum area of a land on which you can place two identical rectangular houses The sides of the houses should be parallel to the sides of the desired square land Formally You are given two identical rectangles with side lengths and positive integers you are given just the sizes but their positions Find the square of the minimum area that contains both given rectangles Rectangles can be rotated both or just one moved but the sides of the rectangles should be parallel to the sides of the desired square Two rectangles can touch each other side or corner but cannot intersect Rectangles can also touch the sides of the square but must be completely inside it You can rotate the rectangles Take a look at the examples for a better understanding ,Obviously that both rectangles should completely touch by one of the sides Otherwise you can move them closer to each other so that the total height or total width decreases and the other dimension does not change Thus there are only two options The rectangles touch by width we get the side of the square equal to The rectangles touch by height we get the side of the square equal to Thus the minimum side of the square is equal to the minimum of these two options Then the answer is 
New Year is coming and you are excited to know how many minutes remain before the New Year You know that currently the clock shows hours and minutes where and Your task is to find the number of minutes before the New Year You know that New Year comes when the clock shows hours and minutes You have to answer independent test cases ,In this problem we just need to print 
Mishka started participating in a programming contest There are problems in the contest Mishka s problem solving skill is equal to Mishka arranges all problems from the contest into a list Because of his weird principles Mishka only solves problems from one of the ends of the list Every time he chooses which end left or right he will solve the next problem from Thus each problem Mishka solves is either the leftmost or the rightmost problem in the list Mishka cannot solve a problem with difficulty greater than When Mishka solves the problem it disappears from the list so the length of the list decreases by Mishka stops when he is unable to solve any problem from any end of the list How many problems can Mishka solve ,You can iterate over all the elements of the array from left to right Count the number of problems Mishka will solve from the left end of the list and break if he cannot solve the next one Let s denote the number of problems Mishka will solve from the left end of the list by Do the same thing independently from right to left Denote the number of problems Mishka will solve from the right end of the list by Then the answer is Time complexity 
You are given two integers and You have to construct the array of length consisting of i e integers greater than or equal to zero such that the sum of elements of this array is and the value is the maximum possible Recall that is the absolute value of In other words you have to maximize the sum of absolute differences between adjacent consecutive elements For example if the array then the value above for this array is Note that this example but it shows how the required value for some array is calculated You have to answer independent test cases ,If then the answer is Otherwise the best way is to construct the array For we can t reach answer more than and for we can t reach the answer more than because each unit can t be used more than twice So the answer can be represented as 
Polycarp knows that if the sum of the digits of a number is divisible by then the number itself is divisible by He assumes that the numbers the sum of the digits of which is divisible by are also somewhat interesting Thus he considers a positive integer interesting if its sum of digits is divisible by Help Polycarp find the nearest larger or equal interesting number for the given number That is find the interesting number such that and is minimal ,Even if we will iterate over all possible numbers starting from and check if sum of digits of the current number is divisible by we will find the answer very fast The maximum possible number of iterations is no more than 
An integer array is being transformed into an array of lowercase English letters using the following prodecure While there is at least one number in the array Choose any number from the array and any letter of the English alphabet Replace all occurrences of number with the letter For example if we initially had an array then we could transform it the following way Choose the number and the letter After that Choose the number and the letter After that Choose the number and the letter After that Choose the number and the letter After that After the transformation all letters are united into a string in our example we get the string Having the array and the string determine if the string could be got from the array after the described transformation ,Let s note that if then must be equal to since we must change the same value to the same letter If we check this for all pairs of and and find no such contradictions then the answer is otherwise We got the solution for for one test case 
You are given two integers and You want to choose two greater than zero integers and and then apply the following operation to times replace with You want to find two positive integers and such that becomes equal to after this process If there are multiple possible pairs you can choose If there is no such pair report it For example if and you may choose and so that becomes equal to if and you may choose and so that becomes equal to if and there is no answer since you cannot decrease with the given operations ,The process in the statement can be rephrased as multiply by will be divisible by so if is not divisible by there is no answer Otherwise and can be used 
You are given an integer Check if has an divisor greater than one does there exist such a number that is divisible by and is odd For example if then there is If then such a number does not exist ,If the number has an odd divisor then it has an odd prime divisor To understand this fact we can consider what happens when multiplying even and odd numbers even even even even odd even odd even even odd odd There is only one even prime number So if a number has no odd divisors then it must be a power of two To check this fact for example you can divide by as long as it is divisible If at the end we got then the power of two You can also use the following condition to check If the number is a power of two then it contains only one unit in the binary notation Then contains units in all positions except the one in which the unit in is located So their bitwise AND does not contain units 
You have coins of value and coins of value You always pay in exact change so you want to know if there exist such and that if you take coins of value and coins of value then the total value of taken coins will be You have to answer independent test cases ,Firstly we obviously need to take at least coins of value If we cannot do it the answer it Otherwise we always can obtain the required sum if 
Polycarp got an array of integers as a gift Now he wants to perform a certain number of operations possibly zero so that all elements of the array become the same that is to become In one operation he can take some indices in the array and increase the elements of the array at those indices by For example let He can perform the following operation select indices 1 2 and 4 and increase elements of the array in those indices by As a result in one operation he can get a new state of the array What is the minimum number of operations it can take so that all elements of the array become equal to each other that is to become ,Let s sort the numbers in ascending order It becomes immediately clear that it is not profitable for us to increase the numbers that are equal to the last number the maximum of the array It turns out that every time you need to take such a subset of the array in which all the numbers except the maximums And once for each operation the numbers in the subset are increased by one then how many times can the operation be performed on the array Accordingly 
You are given a set of segments on the axis each segment has integer endpoints between and inclusive Segments may intersect overlap or even coincide with each other Each segment is characterized by two integers and coordinates of the left and of the right endpoints Consider all integer points between and inclusive Your task is to print all such points that don t belong to any segment The point belongs to the segment if and only if ,In this problem all you need is to check for each point from to if it cannot belongs to any segment It can be done in by two nested loops or in by easy prefix sums calculation Both solutions are below 
Polycarp must pay burles at the checkout He has coins of two nominal values burle and burles Polycarp likes both kinds of coins equally So he doesn t want to pay with more coins of one type than with the other Thus Polycarp wants to minimize the difference between the count of coins of burle and burles being used Help him by determining two non negative integer values and which are the number of coins of burle and burles respectively so that the total value of that number of coins is i e and the absolute value of the difference between and is as little as possible i e you must minimize ,Let s initialize variables and by the same value of Then we need to gather additionally the remainder of dividing by If the remainder is equal to we don t need to gather anything else because the variables and have been already set to the correct answer because and no absolute value can be less than Otherwise because and in this case but that s impossible if isn t divisible by 3 If the remainder is equal to then we need to gather additionally burle using one coin of burle so let s increase by In this case hence this value cannot be less than as it was proved above If the remainder is equal to then we need to gather additionally burles using one coin of burles so let s increase by In this case hence this value cannot be less than There are no other remainders of dividing by so these cases cover the whole solution 
Polycarp had an array of integers He wrote out the sums of all non empty subsequences of this array sorted them in non decreasing order and got an array of integers For example if then Polycarp wrote out After sorting he got an array Unfortunately Polycarp lost the array He only has the array left Help him to restore the array ,The order of elements in doesn t matter If there is at least one correct array then we can sort it and get the answer in which Therefore we can always find a sorted array Suppose that Then We can find as 
On March 14 the day of the number is celebrated all over the world This is a very important mathematical constant equal to the ratio of the circumference of a circle to its diameter Polycarp was told at school that the number is irrational therefore it has an infinite number of digits in decimal notation He wanted to prepare for the Day of the number by memorizing this number as accurately as possible Polycarp wrote out all the digits that he managed to remember For example if Polycarp remembered as he wrote out Polycarp was in a hurry and could have made a mistake so you decided to check how many first digits of the number Polycarp actually remembers correctly ,In the problem you had to find the largest common prefix LCP of the first characters of the number and the string To do this we will go from the beginning and compare the characters until we find a non matching one or until the string ends 
Polycarp has coins the value of the th coin is Polycarp wants to distribute all the coins between his pockets but he cannot put two coins with the same value into the same pocket For example if Polycarp has got six coins represented as an array he can distribute the coins into two pockets as follows Polycarp wants to distribute all the coins with the minimum number of used pockets Help him to do that ,We have to find the maximum number of elements with the same value it can be done by counting This number will be the answer because if there are no more than elements with the same value in the array it is obvious that we cannot use less than pockets but we also doesn t need to use more than pockets because of the other values can be also distributed using pockets Overall complexity is 
Nikolay got a string of length which consists only of lowercase Latin letters and Its positions are numbered from to He wants to modify his string so that every its prefix of length has an equal amount of letters and To achieve that Nikolay can perform the following operation arbitrary number of times possibly zero choose some position in his string and replace the letter on this position with the other letter i e replace with or replace with Nikolay can use no letters except and The prefix of string of length is a string For example for the string abba there are two prefixes of the even length The first is ab and the second abba Both of them have the same number of and Your task is to calculate the minimum number of operations Nikolay has to perform with the string to modify it so that every its prefix of length has an equal amount of letters and ,The problem can be solved like this firstly let s iterate over all from to If characters and are the same then we obviously need to replace one of them with the other character We can see that such replacements are enough to make the string suitable 
Given the integer the number of available blocks You must use blocks to build a The consists of platforms for nd st and rd places respectively The platform for the st place must be higher than for the nd place and the platform for the nd place must be higher than for the rd place Also the height of each platform must be greater than zero that is each platform must contain at least one block Among all possible pedestals of blocks deduce one such that the platform height for the st place as possible If there are several of them output any of them ,In the constraints the problem can be solved by brute force we will go through the value for the height for the first place and then select suitable values for and Since we divide the remaining blocks equally between and If it turns out that then we try to decrease by and increase by 1 If we get the right answer output the heights and stop the process We will go through the value of in order of increasing 
Let s denote a function in such a way we add to then while there is at least one trailing zero in the resulting number we remove that zero For example We say that some number is from if we can apply function to some possibly zero times so that we get as a result For example is reachable from because and any number is reachable from itself You are given a number your task is to count how many different numbers are reachable from ,The key fact in this problem is that the answer is not very large in fact it s not greater than 91 Why is it so Every 10 times we apply function f to our current number it gets divided by 10 at least and the number of such divisions is bounded as O log n So we can just do the following store all reachable numbers somewhere and write a loop that adds current number n to reachable numbers and sets n f n we should end this loop when n already belongs to reachable numbers The most convenient way to store reachable numbers is to use any data structure from your favourite programming language that implemenets a set but in fact the constrains were so small that it was possible to store all reachable numbers in an array 
You are given a huge decimal number consisting of digits It is guaranteed that this number has no leading zeros Each digit of this number is either or You may perform several possibly zero operations with this number During each operation you are allowed to change any digit of your number you may change to or to It is possible that after some operation you can obtain a number with leading zeroes but it does not matter for this problem You are also given two integers Your task is to calculate the minimum number of operations you should perform to obtain the number that has remainder modulo In other words the obtained number should have remainder when divided by ,As we can see last digits of the resulting number will be zeros except the th So we need to change all ones to zeros if needed among last digits if the position of the digit is not and change zero to one if needed otherwise It can be done with simple cycle 
Petya has an array consisting of integers He wants to remove duplicate equal elements Petya wants to leave only the rightmost entry occurrence for each element of the array The relative order of the remaining unique elements should not be changed ,We will store integers which we already met in a set Let s iterate through the given array from the right to the left Let the current element is equal to So if does not contain in we add in a vector answer and add in After we considered all elements the answer sequence contains in the vector in reversed order So we should reverse the vector and simply print all its elements 
You are given the array consisting of positive greater than zero integers In one move you can choose two indices and such that the absolute difference between and is no more than one and remove the smallest of these two elements If two elements are equal you can remove any of them but exactly one Your task is to find if it is possible to obtain the array consisting of using several possibly zero such moves or not You have to answer independent test cases ,Firstly let s sort the initial array Then it s obvious that the best way to remove elements is from smallest to biggest And if there is at least one such that and then the answer is because we have no way to remove Otherwise the answer is 
Polycarp loves ciphers He has invented his own cipher called Repeating cipher is used for strings To encrypt the string Polycarp uses the following algorithm he writes down ones he writes down twice he writes down three times he writes down times For example if the process is So the encrypted is Given string the result of encryption of some string Your task is to decrypt it i e find the string ,There are many possible approaches in this problem I will describe one of the easiest Let s print the initial string by the following algorithm firstly init the variable Then while the encrypted string isn t empty print the first character of this string remove first characters from it and increase by one 
You are given three integers and Your task is to find the integer such that that where is modulo operation Many programming languages use percent operator to implement it In other words with given and you need to find the maximum possible integer from to that has the remainder modulo You have to answer independent test cases It is guaranteed that such exists for each test case ,There are two cases in this problem If we try to maximize the answer we need to consider only two integers and Of course the first one is better we get rid of the existing remainder and trying to add to this number If it s too big then we can and need to take the second one this number is just the first one but decreased by The answer can be always found between these numbers Time complexity 
Polycarp has guessed three positive integers and He keeps these numbers in secret but he writes down four numbers on a board in arbitrary order their pairwise sums three numbers and sum of all three numbers one number So there are four numbers on a board in random order and You have to guess three numbers and using given numbers Print three guessed integers in any order Pay attention that some given numbers and can be equal it is also possible that ,Let and Then we can construct the following answer and Because all numbers in the answer are positive we can assume that the maximum element of is So let s sort the input array consisting of four elements and just print and 
At the store the salespeople want to make all prices In this problem a number that is a power of is called a number For example the numbers are numbers but and are not numbers So if an item is worth bourles the value of the item is not greater than the sellers want to change its value to the nearest number that is not greater than They ask you by how many bourles should you the value of the item to make it worth exactly bourles where the value of is the maximum possible any non negative integer For example let the item have a value of bourles Then the new price of the item will be and the answer will be ,Note that the number and the nearest round number not exceeding have the same size consist of the same number of digits in the record Denote the size of by Then we can construct the nearest round number It will consist of one and zeros 
Alice guesses the strings that Bob made for her At first Bob came up with the secret string consisting of lowercase English letters The string has a length of or more characters Then from string he builds a new string and offers Alice the string so that she can guess the string Bob builds from as follows he writes all the substrings of length of the string in the order from left to right and then joins them in the same order into the string For example if Bob came up with the string then all the substrings of length of the string are Therefore the string You are given the string Help Alice to guess the string that Bob came up with It is guaranteed that was built according to the algorithm given above It can be proved that the answer to the problem is unique ,Note that the first two characters of match the first two characters of The third character of the string again matches the second character of since it is the first character in the second substring which contains the second and the third character of The fourth character matches with the third character of It is easy to notice that such a pattern continues further That is the string consists of the first character and all characters at even positions in 
You are given one integer Recall that a permutation of length is an array consisting of distinct integers from to in arbitrary order For example is a permutation of length but is not a permutation appears twice in the array and is also not a permutation but there is in the array Your task is to find a permutation of length that there is no index such that so for all from to the condition should be satisfied You have to answer independent test cases If there are several answers you can print any It can be proven that the answer exists for each ,There are many possible solutions One of them is just to print 2 3 ldots n 1 
You are given an array consisting of positive integers It is known that in this array all the numbers except one are the same for example in the array all numbers except one are equal to Print the index of the element that does not equal others The numbers in the array are numbered from one ,To find a number that differs from the rest of the numbers in the array you need to iterate through the array maintaining two pairs of numbers x 1 c 1 and x 2 c 2 where x i is a number from the array c i is how many times the number x i occurs in the array Then to get an answer you need to find the position of the x i that occurs in the array exactly once i e c i 1 
A string is called if it is some string written twice in a row For example the strings and are square But the strings and are not square For a given string determine if it is square ,If the length of the given string is odd then the answer is since adding two strings cannot do that Otherwise let be the length of the string Let s go through the first half of the string comparing whether its first and characters are equal its second and characters are equal and so on If the characters in any pair are not equal the answer is otherwise 
Polycarp is playing a new computer game This game has stones in a row The stone on the position has integer power Each turn Polycarp can destroy either stone on the first position or stone on the last position in other words either the leftmost or the rightmost stone When Polycarp destroys the stone it does not exist any more Now Polycarp wants two achievements He gets them if he destroys the stone with the power and the stone with the power Help Polycarp find out what is the minimum number of moves he should make in order to achieve his goal For example if and then Polycarp could make the following moves Destroy the leftmost stone After this move Destroy the rightmost stone After this move Destroy the leftmost stone After this move Polycarp destroyed the stones with the greatest and least power so he can end the game Please note that in the example above you can complete the game in two steps For example Destroy the leftmost stone After this move Destroy the leftmost stone After this move Polycarp destroyed the stones with the greatest and least power so he can end the game ,If we want to destroy the largest and smallest stone then there are only four options Destroy the stones on the left until we destroy the smallest stone Then destroy the stones on the right until we destroy the largest stone Destroy the stones on the right until we destroy the smallest stone Then destroy the stones on the left until we destroy the largest stone Destroy the stones on the left until we destroy both stones Destroy the stones on the right until we destroy both stones You need to check all four options and choose the minimum answer 
Little girl Tanya climbs the stairs inside a multi storey building Every time Tanya climbs a stairway she starts counting steps from to the number of steps in this stairway She speaks every number aloud For example if she climbs two stairways the first of which contains steps and the second contains steps she will pronounce the numbers You are given all the numbers pronounced by Tanya How many stairways did she climb Also output the number of steps in each stairway The given sequence will be a valid sequence that Tanya could have pronounced when climbing one or more stairways ,The answer contains such elements that Also add to the answer the last element 
Three friends are going to meet each other Initially the first friend stays at the position the second friend stays at the position and the third friend stays at the position on the coordinate axis In one minute from other friends can change the position by to the left or by to the right i e set or or even don t change it Let s introduce the total pairwise distance the sum of distances between each pair of friends Let and be the final positions of the first the second and the third friend correspondingly Then the total pairwise distance is where is the absolute value of Friends are interested in the minimum total pairwise distance they can reach if they will move optimally So more formally they want to know the minimum total pairwise distance they can reach after one minute You have to answer independent test cases ,This problem can be solved with simple simulation Let be the new position of the first friend and are new positions of the second and the third friends correspondingly For the fixed positions you can update the answer with the value And iterating over three positions can be implemented with nested loops Time complexity per test case 
You are given three positive i e strictly greater than zero integers and Your task is to find positive integers and such that and or determine that it is impossible to find such and You have to answer independent test cases Print required and in any arbitrary order ,Suppose If then the answer is because is the overall maximum among all three integers and and it appears in two pairs so it should appear at most twice among and Otherwise the answer exists and it can be and it is easy to see that this triple fits well 
Alice and Bob have received three big piles of candies as a gift Now they want to divide these candies as fair as possible To do this Alice takes one pile of candies then Bob takes one of the other two piles The last pile is split between Alice and Bob as they want for example it is possible that Alice takes the whole pile and Bob gets nothing from it After taking the candies from the piles if Alice has more candies than Bob she discards some candies so that the number of candies she has is equal to the number of candies Bob has Of course Bob does the same if he has more candies Alice and Bob want to have as many candies as possible and they plan the process of dividing candies accordingly Please calculate the maximum number of candies Alice can have after this division process of course Bob will have the same number of candies You have to answer independent queries Let s see the following example Then Alice can choose the third pile Bob can take the second pile and then the only candy from the first pile goes to Bob then Alice has candies and Bob has candies Another example is Then Alice can choose the second pile Bob can choose the first pile and candies from the third pile can be divided in such a way that Bob takes candies and Alice takes candies Now Bob has candies and Alice has candies so she has to discard one candy and after that she has candies too ,The answer is always Let s understand why it is so Let Then let Bob take the pile with candies and Alice take the pile with candies Then because of we can see that Bob s pile always can reach size of Alice s pile and remaining candies can be divided between them fairly except one candy if is odd 
You are given two segments and on the axis It is guaranteed that and Segments Your problem is to find two and such that and In other words you have to choose two integer points in such a way that the first point belongs to the segment and the second one belongs to the segment It is guaranteed that If there are multiple answers you can print of them You have to answer independent queries ,One of the possible answers is always a pair of endpoints of the given segments So we can add all endpoints to the array and iterate over all pairs of elements of this array and check if the current pair is suitable or not 
Vlad went into his appartment house entrance now he is on the th floor He was going to call the elevator to go up to his apartment There are only two elevators in his house Vlad knows for sure that the first elevator is currently on the floor it is currently motionless the second elevator is located on floor and goes to floor Please note if then the elevator is already leaving the floor and Vlad does not have time to enter it If you call the first elevator it will immediately start to go to the floor If you call the second one then first it will reach the floor and only then it will go to the floor It takes seconds for each elevator to move from floor to floor Vlad wants to call an elevator that will come to him faster Help him choose such an elevator ,You had to to calculate the time that each elevator would need and compare them Let the time required by the first elevator be and the time required by the second one be Then the answer is if if and if 
You are given two integers and Your task is to construct such a string of length that for each from to there is at least one th letter of the Latin alphabet in this string the first letter is a the second is b and so on and there are no other letters except these You have to of some letter the frequency of a letter is the number of occurrences of this letter in a string If there are several possible answers you can print You have to answer queries ,The only thing you need to do is to place letters by blocks and so on The last block can contain less than letters but it is ok It is easy to see that this letters distribution is always not worse than others 
Vasya decided to go to the grocery store He found in his wallet coins of burle and coins of burles He does not yet know the total cost of all goods so help him find out the positive integer amount of money he pay without change or pay at all using only his coins For example if and he has one burle coin and one burle coin then he can pay burle without change paying with one burle coin he can pay burle without change paying with one burle coin he can pay burle without change by paying with one burle coin and one burle coin he cannot pay burle without change moreover he cannot pay this amount at all So for and the answer is ,If Vasya has coins of burles then he can collect amounts of burls If Vasya does not have burles coins then he cannot collect the amount of burle If he has at least one coin in burl he can score odd amounts up to The following burl coins increase the maximum amount he can make If Vasya has coins for burle he can make up the amount of burles and not anymore 
Vova plans to go to the conference by train Initially the train is at the point and the destination point of the path is the point The speed of the train is length unit per minute i e at the first minute the train is at the point at the second minute at the point and so on There are lanterns on the path They are placed at the points with coordinates divisible by i e the first lantern is at the point the second is at the point and so on There is also one standing train which occupies all the points from to inclusive Vova can see the lantern at the point if is divisible by and there is no standing train at this position Thus if the point with the lantern is one of the points covered by the standing train Vova can t see this lantern Your problem is to say the number of lanterns Vova will see during the path Vova plans to go to different conferences so you should answer queries ,What is the number of lanterns Vova will see from to This number is Now we have to subtract the number of lanters in range from this number This number equals to So the answer is 
Polycarp wants to cook a soup To do it he needs to buy exactly liters of water There are only two types of water bottles in the nearby shop liter bottles and liter bottles There are infinitely many bottles of these two types in the shop The bottle of the first type costs burles and the bottle of the second type costs burles correspondingly Polycarp wants to spend as few money as possible Your task is to find the minimum amount of money in burles Polycarp needs to buy exactly liters of water in the nearby shop if the bottle of the first type costs burles and the bottle of the second type costs burles You also have to answer independent queries ,The answer can be calculated by easy formula where is divided by rounded down and is modulo 
Little girl Tanya is learning how to decrease a number by one but she does it wrong with a number consisting of two or more digits Tanya subtracts one from a number by the following algorithm if the last digit of the number is non zero she decreases the number by one if the last digit of the number is zero she divides the number by 10 i e removes the last digit You are given an integer number Tanya will subtract one from it times Your task is to print the result after all subtractions It is guaranteed that the result will be positive integer number ,In this problem you just need to simulate the process described in the statement i e times repeat the following operation if then else and print the result 
You talked to Polycarp and asked him a question You know that when he wants to answer yes he repeats many times in a row Because of the noise you only heard part of the answer some substring of it That is if he answered then you could hear but you couldn t or Determine if it is true that the given string is a substring of repeated many times in a row ,Note that it is enough to consider the string where is written times since and our substring has size Then we just use the built in function to find out if our string is a substring of the string 
You are a coach of a group consisting of students The th student has programming skill You want to divide them into teams in such a way that No two students and such that belong to the same team i e skills of each pair of students in the same team have the difference strictly greater than the number of teams is the minimum possible You have to answer independent queries ,The answer is always or Why it is so Because if there is no such pair among all students that then we can take all students into one team Otherwise we can divide them into two teams by their programming skill parity 
You are given some Tetris field consisting of columns The initial height of the th column of the field is blocks On top of these columns you can place figures of size i e the height of this figure is blocks and the width of this figure is block Note that you rotate these figures Your task is to say if you can clear the whole field by placing such figures More formally the problem can be described like this The following process occurs while You place one figure choose some from to and replace with then while all are greater than zero replace each with And your task is to determine if it is possible to clear the whole field i e finish the described process choosing the places for new figures properly You have to answer independent test cases ,The answer is only if all have the same parity i e all are odd or all are even That s because placing the block doesn t change the parity of the element and the operation changes the parity of all elements in the array 
You are given two integers and In one move you can choose some from to and add it to or subtract it from In other words you choose an integer and perform or You may use values of in different moves Your task is to find the number of moves required to obtain from You have to answer independent test cases ,We can add or subtract until the difference between and becomes less than And if it is not after all such moves we need one additional move Let is the absolute difference between and The final answer is plus one if This formula can be represented as divided by rounded up in other words 
There is a square field of size in which two cells are marked These cells can be in the same row or column You are to mark two more cells so that they are the corners of a rectangle with sides parallel to the coordinate axes For example if and a rectangular field looks like this there are asterisks in the marked cells Then you can mark two more cells as followsIf there are several possible solutions then print any of them ,f two asterisks are in the same row then it is enough to select any other row and place two asterisks in the same columns in it If two asterisks are in the same column then you can do the same If none of the above conditions are met and the asterisks are at positions x1 y1 x2 y2 then you can place two more asterisks at positions x1 y2 x2 y1 
A string of length is called if it can be obtained using the following algorithm first write an empty string to i e perform the assignment then perform the next step times at the th step take th lowercase letter of the Latin alphabet and write it either to the left of the string or to the right of the string i e perform the assignment or where is the th letter of the Latin alphabet In other words iterate over the first letters of the Latin alphabet starting from and etc Each time we prepend a letter to the left of the string or append a letter to the right of the string Strings that can be obtained in that way are alphabetical For example the following strings are alphabetical and The following strings alphabetical and From the given string determine if it is alphabetical ,For a start let s find the position of the letter in string If this position does not exist then the answer would be Suppose that this position exists and equals Let s create two pointers and Initially We will try to build string using the algorithm from the statement Suppose that we have built substring in iterations Consider the next letter of the Latin alphabet Let s look at cases find position of the letter in if it does not exist then if then make an assignment and process the next letter if then make an assignment and process the next letter otherwise string is not alphabetical and the answer is So if we have built the string in iteration then string is alphabetical and the answer is 
Kristina has two arrays and each containing non negative integers She can perform the following operation on array any number of times apply a decrement to each non zero element of the array that is replace the value of each element such that with the value If was its value does not change Determine whether Kristina can get an array from an array in some number of operations probably zero In other words can she make after some number of operations for each For example let and In this case she can apply the operation twice after the first application of the operation she gets after the second use of the operation she gets Thus in two operations she can get an array from an array ,For all elements of the arrays to become equal after subtraction of units for must be satisfied In addition if there exists then the equality can be obtained only by subtracting exactly units from Since the equality must be satisfied for all the problem is reduced to checking that for all differences are equal and for the difference does not exceed 
You are given an array consisting of integer numbers You have to color this array in colors in such a way that Each element of the array should be colored in some color For each from to there should be element colored in the th color in the array For each from to all elements colored in the th color should be Obviously such coloring might be impossible In this case print Otherwise print and coloring i e numbers where and is the color of the th element of the given array satisfying the conditions above If there are multiple answers you can print ,How can we solve this problem Firstly let s sort the initial array but maintain the initial order of the elements in the array to restore the answer Then let s just distribute all the colors Let s color the first element in the first color the second one in the second the th element in the th color the th in the first color and so on So we color the th element in the color is just modulo operation We can see that the answer is if there is an element with frequency at least in the array by pigeonhole principle Otherwise our solution builds the correct answer So we can try to find such element in the array naively using counting sort or many other approaches Time complexity or 
You are given an array consisting of integer numbers Let of the array be the following value You have to remove element from this array to minimize of the resulting elements array Your task is to calculate the minimum possible ,It is easy to see that we always have to remove either minimum or maximum of the array So we can sort the array and the answer will be We also can do it without sort because two minimal and two maximal elements of the array can be found in linear time 
Polycarp analyzes the prices of the new berPhone At his disposal are the prices for last days where is the price of berPhone on the day Polycarp considers the price on the day to be bad if later that is a day with a greater number berPhone was sold at a lower price For example if and then the number of days with a bad price is these are days and Print the number of days with a bad price You have to answer independent data sets ,Let be the minimum price of the berPhone during days We can precalculate this array moving from right to left and carrying the minimum price we met in other words if we iterate over all from to then if otherwise Then the answer is the number of such days from to that 
You are given a positive integer it is guaranteed that is even i e divisible by You want to construct the array of length such that The first elements of are even divisible by the second elements of are odd not divisible by the sum of the first half equals to the sum of the second half If there are multiple answers you can print any It is that the answer exists You have to answer independent test cases ,Firstly if n is not divisible by 4 then the answer is because the parities of halves won t match Otherwise the answer is always Let s construct it as follows firstly let s create the array 2 4 6 dots n 1 3 5 dots n 1 This array is almost good except one thing the sum in the right half is exactly frac n 2 less than the sum in the left half So we can fix it easily just add frac n 2 to the last element 
You are given a number and an array In one move you can increase any of the array elements by one Formally you choose the index and with You can choose the same index multiple times for different moves Let s denote by and the number of numbers from the array that have remainders and when divided by the number respectively Let s say that the array has balanced remainders if and are equal For example if and then the following sequence of moves is possible initially and these values are not equal to each other Let s increase now the array and these values are not equal Let s increase now the array and these values are not equal Let s increase now the array and these values are equal to each other which means that the array has balanced remainders Find the minimum number of moves needed to make the array have balanced remainders ,Note that the numbers in the array are not important to us so initially we will calculate the values of Now applying a move for the number is equivalent to decreasing by and increasing by We will perform the following greedy algorithm while the array have no balanced remainders find any such that we apply the move for that is replace with and with It is easy to prove the correctness of this greedy algorithm by cyclically shifting the values and so that the first element is equal to the maximum of them 
You are given three integers and Your task is to construct a binary string of length such that there are exactly zeroes exactly ones and exactly indices where such that It is guaranteed that the answer always exists For example for the string there are four indices such that and For the string there are two such indices Recall that binary string is a non empty sequence of characters where each character is either or ,This problem has several general cases x is even and a b then the answer is repeated frac x 2 times then b frac x 2 ones and a frac x 2 zeroes x is even and a le b then the answer is repeated frac x 2 times then a frac x 2 zeroes and b frac x 2 ones x is odd and a b then the answer is repeated lfloor frac x 2 rfloor times then a lfloor frac x 2 rfloor zeroes and b lfloor frac x 2 rfloor ones x is odd and a le b then the answer is repeated lfloor frac x 2 rfloor times then b lfloor frac x 2 rfloor ones and a lfloor frac x 2 rfloor zeroes I am sure that there are other more beautiful solution but for me the easiest way to solve this problem is to extract general cases and handle it Overall complexity is O a b 
Santa has candies and he wants to gift them to kids He wants to divide as many candies as possible between all kids Santa can t divide one candy into parts but he is allowed to not use some candies at all Suppose the kid who recieves the minimum number of candies has candies and the kid who recieves the maximum number of candies has candies Then Santa will be if the both conditions are met at the same time it means or the number of kids who has candies does not exceed less than or equal to is divided by and rounded to the nearest integer For example if then Your task is to find the maximum number of candies Santa can give to kids so that he will be You have to answer independent test cases ,Firstly we can notice that we always can distribute where is the modulo operation candies between kids In this case and the answer is at least And then we can add the value to the answer Why Because there is only candies remain and the maximum number of kids to whom we can give one more candy is 
There is a robot in a warehouse and packages he wants to collect The warehouse can be represented as a coordinate grid Initially the robot stays at the point The th package is at the point It is guaranteed that there are no two packages at the same point It is also guaranteed that the point doesn t contain a package The robot is semi broken and only can move up and right In other words in one move the robot can go from the point to the point or to the point As we say above the robot wants to collect all packages He wants to do it with the minimum possible number of moves If there are several possible traversals the robot wants to choose the lexicographically smallest path The string of length is lexicographically less than the string of length if there is some index that for all from to and It is the standard comparison of string like in a dictionary Most programming languages compare strings in this way ,It is obvious that if there is a pair of points and such that and then the answer is It means that if the answer is then there is some ordering of points such that and because we can only move right or up But what is this ordering it is just sorted order of points firstly by then by So we can sort all points check if this ordering is valid and traverse among all these points For each from to firstly do moves to the right then do moves to the up because this order minimizing the answer lexicographically Time complexity or 
You are given three positive integers and You have to construct a string of length consisting of lowercase Latin letters such that of length has distinct letters It is guaranteed that the answer exists You have to answer independent test cases Recall that the substring is the string and its length is In this problem you are only interested in substrings of length ,If we represent letters with digits then the answer can be represented as There is no substring containing more than distinct characters and each substring of length contains exactly distinct characters because of the condition Time complexity 
Conveyor matrix is matrix of size where is an number The matrix consists of concentric ribbons moving clockwise In other words the conveyor matrix for is simply a matrix whose cells form a cycle of length clockwise For any natural the matrix is obtained by adding to the matrix an outer layer forming a clockwise cycle You are standing in a cell with coordinates and you want to get into a cell with coordinates A cell has coordinates if it is located at the intersection of the th row and the th column Standing on some cell every second you will move to the cell next in the direction of movement of the tape on which you are You can also move to a neighboring cell by spending one unit of energy Movements happen instantly and you can make an unlimited number of them at any time Your task is to find the minimum amount of energy that will have to be spent to get from the cell with coordinates to the cell with coordinates For example initially you are in a cell with coordinates and you want to get into a cell with coordinates You can immediately make movements once you are in a cell with coordinates and then after seconds you will be in the right cell ,Note that the conveyor matrix consists of cycles through each of which we can move without wasting energy Now you need to find the distance between the cycles where the start and end cells are located In one step from any cycle you can go either to the cycle that is closer to the edge of the matrix or to the cycle that is further from the edge of the matrix It turns out that it is enough to find on which cycles there are cells on the edge and take their difference modulo 
Kristina has a string of length consisting only of lowercase and uppercase Latin letters For each pair of lowercase letter and its matching uppercase letter Kristina can get burl However pairs of characters cannot overlap so each character can only be in one pair For example if she has the string aAaaBACacbE she can get a burl for the following character pairs a and A a and A B and b C and c Kristina wants to get more burles for her string so she is going to perform no more than operations on it In one operation she can either select the lowercase character and make it uppercase or select uppercase character and make it lowercase For example when 2 and aAaaBACacbE it can perform one operation choose a and make it uppercase Then she will get another pair of A and a Find number of burles Kristina can get for her string ,Count two arrays and such that contains the number of occurrences of th letter of the alphabet in the string in upper case while in lower case Let s add all existing pairs to the answer so let s add to it for each letter Subtract this minimum from and to get the number of unpaired identical letters Next we will act greedily if there is some set of at least two identical letters in the same case we can apply the operation to half of them and get new pairs Therefore for each letter we will add to the answer and decrease by that amount 
You are given a problemset consisting of problems The difficulty of the th problem is It is guaranteed that all difficulties are distinct and are given in the increasing order You have to assemble the contest which consists of some problems of the given problemset In other words There is only one condition that should be satisfied for each problem but the hardest one the problem with the maximum difficulty there should be a problem with the difficulty greater than the difficulty of this problem but not greater than twice the difficulty of this problem In other words let be the difficulties of the selected problems in increasing order Then for each from to should hold Among all contests satisfying the condition above you have to assemble one with the maximum number of problems Your task is to find this number of problems ,The answer is always a segment of the initial array The authors solution uses two pointers technique let s iterate over all left bounds of the correct contests and try to search maximum by inclusion correct contest Let s iterate over all from to and let the current left bound be Let be the maximum right bound of the correct contest starting from the position Initially Now while and let s increase Try to update the answer with the value It is obvious that all positions from to cannot be left bounds of the maximum by inclusion correct contests so let s set and go on Because each element will be processed once time complexity is 
Polycarp has a string consisting of lowercase Latin letters He encodes it using the following algorithm He goes through the letters of the string from left to right and for each letter Polycarp considers its number in the alphabet if the letter number is single digit number less than then just writes it out if the letter number is a two digit number greater than or equal to then it writes it out and adds the number after For example if the string is then Polycarp will encode this string as follows is the rd letter of the alphabet Consequently Polycarp adds to the code the code becomes equal to is the th letter of the alphabet Consequently Polycarp adds to the code and also the code becomes is the th letter of the alphabet Consequently Polycarp adds to the code the code becomes is the th letter of the alphabet Therefore Polycarp adds to the code the code becomes Thus code of string is You are given a string resulting from encoding the string Your task is to decode it get the original string by ,The idea is as follows we will go from the end of the string and get the original string Note that if the current digit is then a letter with a two digit number has been encoded Then we take a substring of length three from the end discard and get the number of the original letter Otherwise the current number then a letter with a one digit number was encoded We easily reconstruct the original letter Next discard the already processed characters and repeat the process until the encoded string is complete 
You are given two strings and In a single move you can choose any of two strings and delete the first that is the leftmost character After a move the length of the string decreases by You can t choose a string if it is empty For example by applying a move to the string the result is the string by applying a move to the string the result is an empty string You are required to make two given strings equal using the fewest number of moves It is possible that in the end both strings will be equal to the empty string and so are equal to each other In this case the answer is obviously the sum of the lengths of the initial strings Write a program that finds the minimum number of moves to make two given strings and equal ,Let s find the value the length of the longest common suffix of and You can easily find it in one linear loop just compare the last letters of and If they are equal then compare before the last letters of and And so on The last letters of and are two equal strings which will be the result of after optimal moves So the answer is 
The Berland language consists of words having Moreover Any combination of two different Berland letters which by the way are the same as the lowercase letters of Latin alphabet is a correct word in Berland language The Berland dictionary contains all words of this language The words are listed in a way they are usually ordered in dictionaries Formally word comes earlier than word in the dictionary if one of the following conditions hold the first letter of is less than the first letter of the first letters of and are the same and the second letter of is less than the second letter of So the dictionary looks like that Word Word Word Word Word Word Word You are given a word from the Berland language Your task is to find its index in the dictionary ,There are many different ways to solve this problem generate all Berland words with two for loops and store them in an array then for each test case go through the array of words to find the exact word you need generate all Berland words with two for loops and store them in a dictionary like data structure in C in Python etc using words as keys and their numbers as values This allows to search for the index of the given word quickly for each test case run two for loops to iterate over the words count the number of words we skipped and stop at the word from the test case try to invent some formulas that allow counting the number of words before the given one 
There is a house with flats situated on the main street of Berlatov Vova is watching this house every night The house can be represented as an array of integer numbers where if in the th flat the light is on and otherwise Vova thinks that people in the th flats are disturbed and cannot sleep if and only if and and Vova is concerned by the following question what is the minimum number such that if people from exactly pairwise distinct flats will turn off the lights then nobody will be disturbed Your task is to find this number ,The first observation is that we are interested only in patterns of kind All other patterns don t make sense at all So let s build a greedy approach Let s iterate over the given array from the left to the right and maintain that the prefix of the given answer is already correct If now we are at some position and and the prefix from to is already correct then which one we have to replace When we replace the left one then we cannot do better in the future but when we replace the right one then we can fix some on the suffix of the array The easiest example is If now we are at the position then we will do better if we will set 
Not so long ago Vlad came up with an interesting function where is rounded the remainder of the integer division of by For example with and the value The number is fixed and known to Vlad Help Vlad find the maximum value of if can take any integer value from to inclusive ,Consider Note that is maximal over the entire segment from to so if there is in which gives a greater result then Note that numbers from to that have an incomplete quotient when divided by equal to do not fit this condition and are guaranteed to have a value less than And the number Has the maximum possible remainder Has the maximum possible among numbers less than So there are two candidates for the answer these are and The second candidate is suitable only if it is at least It remains only to compare the values of and select the maximum 
Recently you have received two integer numbers and You forgot them but you remembered a list containing all divisors of including and and all divisors of including and If is a divisor of both numbers and at the same time there are two occurrences of in the list For example if and then the given list can be any permutation of the list Some of the possible lists are or Your problem is to restore suitable integer numbers and that would yield the same list of divisors possibly in different order It is guaranteed that the answer exists i e the given list of divisors corresponds to some integers and ,Let s take a look on the maximum element of the given array Suddenly this number is or the order doesn t matter Okay what would we do if we know and merged list of divisors of and Let s remove all divisors of and see what we got The maximum element in the remaining array is So the problem is solved 
You are given sticks the length of the th stick is You have to create rectangles each rectangle will consist of exactly sticks from the given set The rectangle consists of four sides opposite sides should have equal length and all angles in it should be right Note that each stick can be used in only one rectangle Each stick should be used as a side you cannot break the stick or use it not to the full length You want to all rectangles to have equal area The area of the rectangle with sides and is Your task is to say if it is possible to create exactly rectangles of equal area or not You have to answer independent queries ,After sorting we can observe that if the answer is then the area of each rectangle is Then we just need to check for each from to that and and If all conditions are satisfied for all then the answer is Otherwise the answer is 
There are products in the shop The price of the th product is The owner of the shop wants to equalize the prices of all products However he wants to change prices smoothly In fact the owner of the shop can change the price of some product in such a way that the difference between the old price of this product and the new price is at most In other words the condition should be satisfied is the absolute value of He can change the price for each product Note that he can leave the old prices for some products The new price of each product should be positive i e should be satisfied for all from to Your task is to find out the possible price of productts with the restriction that for all products the condiion should be satisfied where is the old price of the product and is the same new price of all products or report that it is impossible to find such price You should answer independent queries ,It is very intuitive that the maximum price we can obtain is where is the minimum value in the array For this price we should check that we can change prices of all products to it It can be done very easily we can just check if each segment covers the point But this is not necessary because if we can change the price of the maximum to this value then we can change each price in the segment to this value So we just need to check that and if it is then print otherwise print 
You are given an array of length which consists of non negative integers An array is called if the parity of each index matches the parity of the element at that index More formally an array is good if for all the equality holds where is the remainder of dividing by 2 For example the arrays and are good and the array is bad because for the parities of and are different but In one move you can take two elements of the array and swap them these elements are not necessarily adjacent Find the minimum number of moves in which you can make the array good or say that this is not possible ,We split all the positions in which the parity of the index does not match with the parity of the element into two arrays If there is an odd number in the even index add this index to the array Otherwise if there is an even number in the odd index add this index to the array Note that if the sizes of the and arrays are not equal then there is no answer Otherwise the array can be made by doing exactly operations by simply swapping all the elements in the and arrays 
You are given of integers Process queries of two types query of the form add the value to all even elements of the array query of the form add the value to all odd elements of the array Note that when processing the query we look specifically at the odd even value of not its index After processing each query print the sum of the elements of the array Please note that the answer for some test cases won t fit into 32 bit integer type so you should use at least 64 bit integer type in your programming language like for C ,Let the initial sum in the array the number of even numbers the number of odd numbers Let s see how these values change with each action In fact we can consider four main options Add an even number to all even numbers Then will increase by and the number of even and odd numbers will remain the same Add an odd number to all even numbers Then will increase by the number of even numbers will become all numbers will become odd so Add an even number to all odd numbers Then will increase by and the number of even and odd numbers will remain the same Add an odd number to all odd numbers Then will increase by the number of odd numbers will become all numbers will become even so 
Alice and Bob received candies from their parents Now they want to divide all candies among themselves fairly so that the total weight of Alice s candies is equal to the total weight of Bob s candies Check if they can do that Note that candies ,If the sum of all the weights is not divisible by two then it is impossible to divide the candies between two people If the sum is divisible then let s count the number of candies with a weight of and Now if we can find a way to collect half the sum with some candies then these candies can be given to Alice and all the rest can be given to Bob Simple solution let s iterate through how many candies of weight we will give to Alice then the remaining weight should be filled by candies of weight If there are enough of them then we have found a way of division In fact if the sum is even and there are at least two candies with weight there can t be one candy then the answer is always we can collect the weight as close to half as possible with weight and then add weight If there are no candies with weight then you need to check whether is even since all the candies have the same weight you just need to divide them in half 
You can not just take the file and send it When Polycarp trying to send a file in the social network Codehorses he encountered an unexpected problem If the name of the file contains three or more lowercase Latin letters in a row the system considers that the file content does not correspond to the social network topic In this case the file is not sent and an error message is displayed Determine the minimum number of characters to remove from the file name so after that the name does not contain as a substring Print if the file name does not initially contain a forbidden substring You can delete characters in arbitrary positions not necessarily consecutive If you delete a character then the length of a string is reduced by For example if you delete the character in the position from the string then the resulting string is ,Let s iterate through the given string from the left to the right In a variable we will store the number of letters which were before the current letter in a row If the current letter does not equal to we should make In the other case the current letter equals to If we should increase by one In the other case we should add one to the answer because the current letter should be removed 
Mishka wants to buy some food in the nearby shop Initially he has burles on his card Mishka can perform the following operation any number of times possibly zero choose some buy food that costs exactly burles and obtain burles as a cashback in other words Mishka spends burles and obtains back The operation means divided by rounded down It is guaranteed that you can always buy some food that costs for any possible value of Your task is to say the maximum number of burles Mishka can spend if he buys food optimally For example if Mishka has burles then the maximum number of burles he can spend is Firstly he can spend burles obtain burle as a cashback Now he has burles so can spend burles obtain burle as a cashback and spend it too You have to answer independent test cases ,Let s do the following greedy solution it is obvious that when we buy food that costs exactly for we don t lose any burles because of rounding Let s take the maximum power of that is not greater than let it be buy food that costs and add this number to the answer and add to Apply this process until and then add to the answer Time complexity per test case 
Polycarp has friends the th of his friends has candies Polycarp s friends do not like when they have different numbers of candies In other words they want all to be the same To solve this Polycarp performs the following set of actions exactly Polycarp chooses arbitrary friends let s say he chooses friends with indices Polycarp distributes their candies among all friends During distribution for each of candies he chooses new owner That can be any of friends Note that any candy can be given to the person who has owned that candy before the distribution process Note that the number is not fixed in advance and can be arbitrary Your task is to find the minimum value of For example if and then Polycarp could make the following distribution of the candies Polycarp chooses friends with indices and distributes candies to make two candies go to person Note that in this example Polycarp cannot choose friend so that he can redistribute candies so that in the end all are equal For the data and determine the value With this value Polycarp should be able to select friends and redistribute their candies so that everyone will end up with the same number of candies ,Let s denote for the number of candies all friends have Note that at the end each friend must have of candy If is not completely divisible by then there is no answer How to get the answer if it exists If the th friend has more candies than then he must be chosen by Polycarp otherwise this friend will have more candies than the others If the th friend has no more than then Polycarp may not choose it Then if the answer exists it is equal to the number of 
A sequence of numbers is called if it contains all numbers from to exactly once For example the sequences and are permutations but and are not For a given number you need to make a permutation such that two requirements are satisfied at the same time For each element at least one of its neighbors has a value that differs from the value of by one That is for each element at least one of its neighboring elements standing to the left or right of must be or the permutation must have no fixed points That is for every must be satisfied Let s call the permutation that satisfies these requirements For example let Then is a permutation since to the right of is to the left of is to the right of is to the left of is for all is For a given positive integer output permutation of length or output if permutation of length does not exist ,We cannot make a funny permutation only when because one of the neighboring elements of must be equal to Any permutation made in this way will not satisfy the conditions The permutation will have a fixed point The permutation will have a fixed point The permutation will not have a neighbor equal to for For the remaining values of make the following observations For the only funny permutation is When permutations of the form will always be funny because all elements will have a neighbor equal to or and the permutation will have no fixed points and for will always be true 
You have gifts and you want to give all of them to children Of course you don t want to offend anyone so all gifts should be equal between each other The th gift consists of candies and oranges During one move you can choose some gift and do one of the following operations eat exactly from this gift decrease by one eat exactly from this gift decrease by one eat exactly and exactly from this gift decrease both and by one Of course you can not eat a candy or orange if it s not present in the gift so neither nor can become less than zero As said above all gifts should be equal This means that after some sequence of moves the following two conditions should be satisfied and and equals is Your task is to find the number of moves required to equalize all the given gifts You have to answer independent test cases ,At first consider the problems on candies and oranges independently Then it s pretty obvious that for candies the optimal way is to decrease all to the value we need obtain at least this value to equalize all the elements and there is no point to decrease elements further The same works for the array Then if we unite these two problems we need to take the maximum moves we need for each because we need exactly that amount of moves to decrease to and to simultaneously So the answer is 
Vova s house is an array consisting of elements yeah this is the first problem I think where someone in the array There are heaters in some positions of the array The th element of the array is if there is a heater in the position otherwise the th element of the array is Each heater has a value is the same for all heaters This value means that the heater at the position can warm up all the elements in range Vova likes to walk through his house while he thinks and he hates cold positions of his house Vova wants to switch some of his heaters on in such a way that each element of his house will be warmed up by at least one heater Vova s target is to warm up the whole house all the elements of the array i e if and heaters are at positions and then Vova can warm up the whole house if he switches all the heaters in the house on then the first elements will be warmed up by the first heater and the last elements will be warmed up by the second heater Initially all the heaters are off But from the other hand Vova didn t like to pay much for the electricity So he wants to switch the number of heaters on in such a way that each element of his house is warmed up by at least one heater Your task is to find this number of heaters or say that it is impossible to warm up the whole house ,Let s solve this problem greedily Let be the last position from the left covered by at least one heater Initially equals While lets repeat the following process firstly we have to find the rightmost heater in range It can be done in time because of given constrains or in using precalculated prefix values for each in range If there is no such heater then the answer is otherwise let s set increase the answer by and repeat the process if There is another one solution to this problem Assume that the initial answer equals to the total number of heaters Let s calculate an array of length where means the number of heaters covering the th element It can be done in This array will mean that we are switch all the heaters on and we know for each element the number of heaters covers this element Now if for at least holds then the answer is Otherwise let s switch useless heaters off Let s iterate over all heaters from left to right Let the current heater have position We need to check if it is useless or not Let s iterate in range and check if there is at least one element in this segment such that If there is then the current heater is not useless and we cannot switch it off Otherwise we can decrease the answer by switch this heater off decrease for all in range and continue the process 
There are athletes in front of you Athletes are numbered from to from left to right You know the strength of each athlete the athlete number has the strength You want to split all athletes into two teams Each team must have at least one athlete and each athlete must be exactly in one team You want the strongest athlete from the first team to differ as little as possible from the weakest athlete from the second team Formally you want to split the athletes into two teams and so that the value is as small as possible where is the maximum strength of an athlete from team and is the minimum strength of an athlete from team For example if and the strength of the athletes is then one of the possible split into teams is first team second team In this case the value will be equal to This example illustrates one of the ways of optimal split into two teams Print the minimum value ,Let s found two athletes with numbers and the strength of is not greater than the strength of which have the minimal modulus of the difference of their strength Obviously we cannot get an answer less than this Let s show how to get the partition with exactly this answer Sort all athletes by strength Our two athletes will stand in neighboring positions otherwise we can decrease the answer Let the first team contains all athletes who stand on positions not further than and the second team contains other athletes We got a partition in which the athlete with number has the maximal strength in the first team and the athlete with number has the minimal strength in the second team 
For the given integer let s write down all the strings of length which contain letters and two letters in alphabetical order Recall that the string of length is lexicographically less than string of length if there exists such that and for any The lexicographic comparison of strings is implemented by the operator in modern programming languages For example if the strings are the order does matter It is easy to show that such a list of strings will contain exactly strings You are given and Print the th string from the list ,Let s try to find the position of the leftmost occurrence of iterate over all positions from to If then this is the required position of the leftmost occurrence of Then the position of rightmost occurrence is so we can print the answer Otherwise let s decrease by remove all strings which have the leftmost at the current position and proceed to the next position It is obvious that in such a way we consider all possible strings in lexicographic order 
Polycarp has a string of length consisting of decimal digits Polycarp performs the following operation with the string i e he can perform operation or time Polycarp selects two numbers and and removes characters from the string at the positions i e removes substring More formally Polycarp turns the string into the string For example the string Polycarp can turn into strings in this case or in this case in this case other operations are also possible only a few of them are listed above Polycarp likes the string very much so he is wondering if it is possible to turn the string into a string in no more than one operation Note that you can perform zero operations ,Let s see how the deleted substring t should look so that after deleting it the string s turns into the string The length of the string t must be n 4 Then we can iterate over all substrings of the string s of length n 4 there are no more than five such substrings and look at the string obtained after deleting the substring That is we need to check that one of the following character sequence matches the 2 0 2 0 s 1 s 2 s 3 s 4 s 1 s 2 s 3 s n s 1 s 2 s n 1 s n s 1 s n 2 s n 1 s n s n 3 s n 2 s n 1 s n 
You are given a long decimal number consisting of digits from to You also have a function that maps every digit from to to some possibly the same digit from to You can perform the following operation choose a non empty of digits in and replace each digit from this segment with For example if and you choose the segment consisting of three rightmost digits you get as the result What is the maximum possible number you can obtain applying this operation no more than once ,Let s find the first digit in a that becomes greater if we replace it obviously if there is no such digit then the best solution is to leave a unchanged In the optimal solution we will replace this digit and maybe some digits after this Why is it so It is impossible to make any of the previous digits greater since we found the first digit that can be replaced with a greater one Then let s analyze all digits to the right of it We should not replace any digit with a lower digit because it is better not to replace it and all digits to the right of it at all but there s nothing wrong with replacing any other digits So the segment we need to replace begins with the first digit that can become greater after replacing and includes this digit and goes to the right until the first digit that becomes less after replacing and this digit is excluded 
A sequence of numbers is called a permutation if it contains all integers from to exactly once For example the sequences and are permutations but and are not Polycarp lost his favorite permutation and found only some of its elements the numbers He is sure that the sum of the lost elements equals Determine whether one or more numbers can be appended to the given sequence such that the sum of the added numbers equals and the resulting new array is a permutation ,Let us add to the sum of the elements of the array and try to find a suitable permutation To do this greedily add elements until their sum is less than And at the end we will check that the sum has matched Also check that the maximal element from and that the total elements in 
Polycarp has positive integers and He can perform the following operation Choose a integer and multiply of the integers or by Can Polycarp make it so that after performing the operation the sequence of three numbers forms an arithmetic progression Note that you the order of and Formally a sequence is called an arithmetic progression AP if there exists a number called common difference such that for all from to In this problem For example the following sequences are AP and The following sequences are not AP and You need to answer independent test cases ,Let s iterate over the number that we want to multiply by How can we check that we can multiply the current number so that an AP is formed Note that those numbers that we do not touch should form an AP themselves For instance let at the current operation we want somehow multiply the number Then and Note that Thus we know what is Also we know that Let s check if is divisible by If yes then we have found the answer if not then move on to the next number We do the same for and Be careful with non positive numbers integer divisions and other edge cases 
It is given a positive integer In move one can select any single digit and remove it i e one selects some position in the number and removes the digit located at this position The operation cannot be performed if only one digit remains If the resulting number contains leading zeroes they are automatically removed E g if one removes from the number the rd digit the resulting number will be If one removes from the number the first digit the resulting number will be the zeroes going next to the first digit are automatically removed What is the minimum number of steps to get a number such that it is divisible by and It is guaranteed that for each occurring in the input the answer exists It is guaranteed that the number has no leading zeros ,A number is divisible by if and only if its last two digits represent one of the following strings Let s solve for each string the following subtask what is the minimum number of characters to be deleted so that the string becomes a suffix of the number Then choosing the minimum of the answers for all subtasks we solve the whole problem Let s solve the subtask for a string where and are digits We can do it using the following algorithm let s delete the last digit of the number until it is equal to then the second to last digit of the number until it is equal to If it is not possible then this subtask has no solution i e its result will not affect the answer 
Given integers You can perform the following operation on them select any element and divide it by round down In other words you can replace any selected element with the value where is round down the real number Output the minimum number of operations that must be done for a sequence of integers to become strictly increasing that is for the condition to be satisfied Or determine that it is impossible to obtain such a sequence Note that elements be swapped The only possible operation is described above For example let and a sequence of numbers be given Then it is enough to perform two operations on it Write the number instead of the number and get the sequence Then replace with and get the sequence The resulting sequence is strictly increasing because ,We will process the elements of the sequence starting from the end of the sequence Each element will be divided by until it is less than If at some point it turns out that it is impossible to obtain the desired sequence 
You are given a sequence consisting of integers You can choose any non negative integer i e and for each you can add only once i e perform or subtract only once i e perform or leave the value of unchanged It is possible that after an operation the value becomes negative Your goal is to choose such and perform changes in such a way that all are equal i e Print the required or if it is impossible to choose such value print For example for array the value is minimum possible because you can obtain the array if you will add to and subtract from And for array the value is also minimum possible You can add it to and subtract it from and obtain the array ,Let s leave only unique values of the given array in the array i e construct an array that is actually array without duplicate element and sort it in ascending order Then let s consider the following cases If the length of is greater than then the answer is if the length of is then there are two cases if then the answer is otherwise the answer is if the length of is then there are also two cases if is even then the answer is otherwise the answer is and if the length of is then the answer is 
You have a matrix filled with integers You want your matrix to become beautiful The matrix is beautiful if the following two conditions are satisfied in each row the first element is smaller than the second element in each column the first element is smaller than the second element You can perform the following operation on the matrix any number of times rotate it clockwise by degrees so the top left element shifts to the top right cell the top right element shifts to the bottom right cell and so on Determine if it is possible to make the matrix beautiful by applying zero or more operations ,Sure you can just implement the rotation operation and check all possible ways to rotate the matrix but it s kinda boring The model solution does the different thing If a matrix is beautiful then its minimum is in the upper left corner and its maximum is in the lower right corner and vice versa If you rotate it the element from the upper left corner goes to the upper right corner and the element from the lower right corner goes to the lower left corner so these elements are still in the opposite corners No matter how many times we rotate a beautiful matrix its minimum and maximum elements will be in the opposite corners and the opposite is true as well if you have a matrix with minimum and maximum elements in opposite corners it can be rotated in such a way that it becomes beautiful So all we need to check is that the minimum and the maximum elements are in the opposite corners There are many ways to do it in my opinion the most elegant one is to read all four elements in an array of size then the opposite corners of the matrix correspond either to positions and or to positions and in this array So we check that the sum of positions of minimum and maximum is exactly 
Each day in Berland consists of hours Polycarp likes time management That s why he has a fixed schedule for each day it is a sequence each is either or where if Polycarp works during the th hour of the day and if Polycarp rests during the th hour of the day Days go one after another endlessly and Polycarp uses the same schedule for each day What is the maximal number of continuous hours during which Polycarp rests It is guaranteed that there is at least one working hour in a day ,At first consider we process the only day In this case just iterate over hours and maintain the length of the current rest block i e if the element equals then increase if the element equals then reset to The maximum intermediate value of is the answer In case of multiple days consider the given sequence as a cyclic sequence Concatenate the sequence twice and solve the previous case Sure not it is no necessary to concatenate it in explicit way just use instead of and process 
You are given an array consisting of integers In one operation you can choose two elements of the array and replace them with the element equal to their sum it does not matter where you insert the new element For example from the array you can obtain the following arrays and Your task is to find the maximum possible number of elements divisible by that are in the array after performing this operation an arbitrary possibly zero number of times You have to answer independent queries ,Let be the number of elements of with the remainder modulo Then the initial answer can be represented as and we have to compose numbers with remainders and somehow optimally It can be shown that the best way to do it is the following firstly while there is at least one remainder and at least one remainder let s compose them into one After this at least one of the numbers will be zero then we have to compose remaining numbers into numbers divisible by If then the maximum remaining number of elements we can obtain is because and in the other case the maximum number of elements is because 
You are given a permutation of length Recall that the permutation is an array consisting of distinct integers from to in arbitrary order For example is a permutation but is not a permutation appears twice in the array and is also not a permutation but there is in the array You can perform at most operations with the given permutation it is possible that you don t perform any operations at all The th operation allows you to swap elements of the given permutation on positions and The operations can be performed in arbitrary order Your task is to find the lexicographically minimum possible permutation obtained by performing some of the given operations in some order You can see the definition of the lexicographical order in the notes section You have to answer independent test cases For example let s consider the permutation The minimum possible permutation we can obtain is and we can do it in the following way perform the second operation swap the second and the third elements and obtain the permutation perform the fourth operation swap the fourth and the fifth elements and obtain the permutation perform the third operation swap the third and the fourth elements and obtain the permutation perform the first operation swap the first and the second elements and obtain the permutation Another example is The minimum possible permutation we can obtain is by performing the third operation swap the third and the fourth elements ,The following greedy solution works let s take the minimum element and move it to the leftmost position we can With this algorithm all forbidden operations are form the prefix of operations and so on So we can carry the position of the leftmost operation we can perform Initially it is We repeat the algorithm until Let s find the position of the minimum element among elements Let this position be If then let s increase and continue the algorithm Otherwise we need to move the element from the position to the position and then set Time complexity 
You are given four integers and Initially and You can do the following operation times Choose either or and decrease it by one However as a result of this operation value of cannot become less than and value of cannot become less than Your task is to find the possible product of and you can achieve by applying the given operation no more than times You have to answer independent test cases ,The only fact required to solve the problem if we start decreasing the number we are better to end decreasing it and only then decrease the other number So we can just consider two cases when we decrease first and after that and vice versa and just take the minimum product of these two results The rest is just implementation 
Polycarp has come up with a new game to play with you He calls it A missing bigram A of a word is a sequence of two adjacent letters in it For example word contains bigrams and The game goes as follows First Polycarp comes up with a word consisting only of lowercase letters a and b Then he writes down all its bigrams on a whiteboard After that he wipes one of them off the whiteboard Finally Polycarp invites you to guess what the word that he has come up with was Your goal is to find any word such that it s possible to write down all its bigrams and remove one of them so that the resulting sequence of bigrams is the same as the one Polycarp ended up with The tests are generated in such a way that the answer exists If there are multiple answers you can print any of them ,Consider a full sequence of bigrams for some word The first bigram consists of letters and of the word The second bigram consists of letters and The th bigram consists of letters and After one bigram is removed there becomes two adjacent bigrams such that one consists of letters and and the other consists of letters and Thus we can find the position of the removed bigram by looking for a pair of adjacent bigrams such that the second letter of the first one differs from the first letter of the second one If there is no such pair then the sequence of bigrams represents a valid word of length We can append it with any bigram that starts with the second letter of the last bigram to make it a valid word of length If there exists such a pair then all letters of the word can be recovered We can find the position of the removed bigram determine the letters it consisted of and insert it into the sequence After that we have a full sequence of bigrams and we can restore the word from it Overall complexity per testcase 
You are given an integer In one move you can either multiply by two or divide by if it is divisible by without the remainder Your task is to find the minimum number of moves needed to obtain from or determine if it s impossible to do that You have to answer independent test cases ,If the number consists of other primes than and then the answer is Otherwise let be the number of twos in the factorization of and be the number of threes in the factorization of If then the answer is because we can t get rid of all twos Otherwise the answer is Time complexity 
Polycarp remembered the th year and he is happy with the arrival of the new th year To remember such a wonderful moment Polycarp wants to represent the number as the sum of a certain number of and a certain number of For example if then the number can be represented as the sum then the number can be represented as the sum then the number can be represented as the sum then the number cannot be represented as the sum of the numbers and Help Polycarp to find out whether the number can be represented as the sum of a certain number of numbers and a certain number of numbers ,Let the number of the number of Let us write the required decomposition of the number Then we get that is divisible by Take equal to the remainder of divided by Then is uniquely determined from the formula above Then if the result is that because the remainder of dividing by is non negative then can be represented as the sum of a certain number of and a certain number of 
You are given two strings and Both strings have length and consist of lowercase Latin letters The characters in the strings are numbered from to You can successively perform the following move any number of times possibly zero swap any two adjacent neighboring characters of i e for any you can swap and You can t apply a move to the string The moves are applied to the string one after another Your task is to obtain the string from the string Find any way to do it with at most such moves ,This problem can be solved using the next greedy approach let s iterate over all from to If go further Otherwise let s find any position such that and move the character from the position to the position If there is no such position in the answer is Upper bound on time complexity and the size of the answer of this solution is 
The grasshopper is located on the numeric axis at the point with coordinate Having nothing else to do he starts jumping between integer points on the axis Making a jump from a point with coordinate with a distance to the left moves the grasshopper to a point with a coordinate while jumping to the right moves him to a point with a coordinate The grasshopper is very fond of positive integers so for each integer starting with the following holds exactly minutes after the start he makes a jump with a distance of exactly So in the first minutes he jumps by then by and so on The direction of a jump is determined as follows if the point where the grasshopper was before the jump has an coordinate the grasshopper jumps to the he jumps to the For example if after consecutive jumps he arrives at the point with a coordinate he will jump by a distance of to the right since is an odd number and will end up at a point Since is an even number the next jump the grasshopper will make to the left by a distance of and it will move him to the point Find exactly which point the grasshopper will be at after exactly jumps ,Consider the first four actions that the grasshopper will perform starting at a point with coordinate coordinate is jumping to leads to coordinate is jumping to leads to coordinate is jumping to leads to coordinate is jumping to leads to If you look closely at the next four jumps they follow the same pattern jump to the left two jumps to the right jump to the left In general making jumps with numbers the grasshopper will start from coordinate and move as Thus if were always zero the answer would be if if if if is divisible by Let s find an answer for the cases when But if is even then all steps will follow the same directions and the answer will be where is the answer for the same and starting point described above And if is odd then all steps will have opposite directions and the answer will be 
You are given an array consisting of integers You want to split it into exactly such that each subsegment has odd sum i e for each subsegment the sum of all elements that belong to this subsegment is odd It is impossible to rearrange shuffle the elements of a given array Each of the elements of the array must belong to exactly one of the subsegments Let s see some examples of dividing the array of length into subsegments not necessarily with odd sums is the initial array then all possible ways to divide it into non empty non intersecting subsegments are described below Of course it can be impossible to divide the initial array into exactly subsegments in such a way that each of them will have odd sum of elements In this case print Otherwise print and possible division of the array See the output format for the detailed explanation You have to answer independent queries ,Firstly let be the number of odd elements in the array Note that even elements are don t matter at all because they cannot change the parity of the sum If then it is obviously impossible to split the given array into subsegments with odd sum And if then it is impossible to split the array into subsegments with odd sum also because at least one of segments will have even number of odd elements so will have odd sum In other cases the answer is always and you can print leftmost positions of odd elements and as right borders of segments it means that when you find one odd element you end one segment Because now the last segment will have odd number of odd elements so it will have odd sum also 
Let s call a positive integer ordinary if in the decimal notation all its digits are the same For example and are ordinary numbers but and are not ordinary numbers For a given number find the number of ordinary numbers among the numbers from to ,Note that every ordinary number can be represented as Therefore to count all ordinary numbers among the numbers from to it is enough to count the number of pairs such that In the given constraints it is enough to iterate over from to and from to 
Polycarp has an array consisting of integers He wants to play a game with this array The game consists of several moves On the first move he chooses any element and deletes it after the first move the array contains elements For each of the next moves he chooses any element with the only restriction its parity should differ from the parity of the element deleted on the previous move In other words he alternates parities even odd even odd or odd even odd even of the removed elements Polycarp stops if he can t make a move Formally If it is the first move he chooses any element and deletes it If it is the second or any next move if the last deleted element was Polycarp chooses any element and deletes it if the last deleted element was Polycarp chooses any element and deletes it If after some move Polycarp cannot make a move the game ends Polycarp s goal is to the sum of elements of the array after end of the game If Polycarp can delete the whole array then the sum of elements is zero Help Polycarp find this value ,Let s calculate the sum of the whole array and then divide all its elements into two arrays and by their parity for odd for even Sort both of them in non increasing order Then what can we see We always can delete first elements from both arrays where is the size of So let s decrease by the sum of first elements of the array and the same for the array If one the arrays has more than elements both arrays cannot have more than elements because if it is so then should be greater then let s decrease by the th element of this array because this is the maximum possible element we can remove Now is the answer for the problem 
Polycarp wants to train before another programming competition During the first day of his training he should solve exactly problem during the second day exactly problems during the third day exactly problems and so on During the th day he should solve problems Polycarp has a list of contests the th contest consists of problems During each day Polycarp has to choose of the contests he didn t solve yet and solve it He solves Other problems are discarded from it If there are no contests consisting of at least problems that Polycarp didn t solve yet during the th day then Polycarp stops his training How many days Polycarp can train if he chooses the contests optimally ,After sorting the array we can maintain the last day Polycarp can train in the variable Initially it is Let s iterate over all elements of the sorted array in non decreasing order and if the current element then let s increase by one The answer will be 
Polycarp has a poor memory Each day he can remember no more than of different letters Polycarp wants to write a non empty string of consisting of lowercase Latin letters taking number of days In how many days will he be able to do it Polycarp initially has an empty string and can only add characters to the end of that string For example if Polycarp wants to write the string he will do it in days on the first day Polycarp will memorize the letters and write On the second day Polycarp will remember the letters add to the resulting line and get the line If Polycarp wants to write the string he will do it in days in the first day will be written part on day two will be written part on the third day part of will be written on the fourth day part of will be written For a given string print the minimum number of days it will take Polycarp to write it ,Let us simulate the process We store a set consisting of letters that Polycarp memorizes on one day Gradually dial the set If the size of exceeds we add to the day counter and clear 
Polycarp is practicing his problem solving skill He has a list of problems with difficulties respectively His plan is to practice for exactly days Each day he has to solve at least one problem from his list Polycarp solves the problems in the order they are given in his list he cannot skip any problem from his list He has to solve all problems in exactly days Thus each day Polycarp solves a contiguous sequence of consecutive problems from the start of the list He can t skip problems or solve them multiple times As a result in days he will solve all the problems The of the th day of Polycarp s practice is the maximum among all the difficulties of problems Polycarp solves during the th day i e if he solves problems with indices from to during a day then the of the day is The of his practice is the sum of the over all days of his practice You want to help Polycarp to get the maximum possible over all valid ways to solve problems Your task is to distribute all problems between days satisfying the conditions above in such a way that the is maximum For example if and one of the possible distributions with maximum is Here the equals ,The maximum possible you can obtain is the sum of the largest values of the given array This is obvious because we can always separate these maximums and then extend the segments corresponding to them to the left or to the right and cover the entire array I suggest the following extract largest values of the given array and place a separator right after each of them except the rightmost one Overall complexity is 
International Women s Day is coming soon Polycarp is preparing for the holiday There are candy boxes in the shop for sale The th box contains candies Polycarp wants to prepare the maximum number of gifts for girls Each gift will consist of boxes The girls should be able to share each gift equally so the total amount of candies in a gift in a pair of boxes should be divisible by In other words two boxes and can be combined as a gift if is divisible by How many boxes will Polycarp be able to give Of course each box can be a part of no more than one gift Polycarp cannot use boxes partially or redistribute candies between them ,Let be the number of boxes with candies modulo Firstly the number of of boxes we can obtain using two boxes with remainder modulo is Secondly if is even then we also can obtain of boxes using two boxes with remainder modulo and its number is And for any other remainder from to the number of pairs of boxes is So if we sum up all these values the answer is this sum multiplied by two because we have to print the number of boxes not pairs 
Polycarp was presented with some sequence of integers of length A sequence can make Polycarp happy only if it consists of numbers i e distinct numbers In order to make his sequence like this Polycarp is going to make some possibly zero number of moves In one move he can remove the first leftmost element of the sequence For example in one move the sequence will produce the sequence which consists of different numbers Determine the minimum number of moves he needs to make so that in the remaining sequence all elements are different In other words find the length of the smallest prefix of the given sequence after removing which all values in the sequence will be unique ,Let s turn the problem around we ll look for the longest suffix that will make Polycarp happy since it s the same thing Let s create an array in which we will mark the numbers already encountered Let s go along from right to left and check if does not occur to the right in this case it is marked in if it occurs to the right then removing any prefix that does not include we get an array where occurs twice so we have to delete prefix of length 
A permutation of length is a sequence of integers from to of length containing each number exactly once For example are permutations and are not There was a permutation It was merged with itself In other words let s take two instances of and insert elements of the second into the first maintaining relative order of elements The result is a sequence of the length For example if some possible results are The following sequences are not possible results of a merging For example if the possible results are The following sequences are not possible results of a merging Your task is to restore the permutation by the given resulting sequence It is guaranteed that the answer You have to answer independent test cases ,The solution is pretty simple it s obvious that the first element of a is the first element of the permutation p Let s take it to p remove it and its its copy from a So we just have the smaller problem and can solve it in the same way It can be implemented as go from left to right if the current element isn t used take it and mark it s used 
A string of length can be encrypted by the following algorithm iterate over all divisors of in decreasing order i e from to for each divisor reverse the substring i e the substring which starts at position and ends at position For example the above algorithm applied to the string leads to the following changes obviously the last reverse operation doesn t change the string because You are given the encrypted string Your task is to decrypt this string i e to find a string such that the above algorithm results in string It can be proven that this string always exists and is unique ,To solve the problem we can implement the encryption algorithm with a single change we have to iterate over all divisors of in increasing order Time complexity where is a divisor count function for For example 
The new generation external memory contains an array of integers This type of memory does not support changing the value of an arbitrary element Instead it allows you to cut out any segment of the given array rotate it by any offset and insert it back into the same place Technically each cyclic shift consists of two consecutive actions You may select arbitrary indices and as the boundaries of the segment Then you replace the segment with it s to the by an arbitrary offset The concept of a can be also explained by following relations the sequence is a cyclic shift of the sequence to the left by the offset and the sequence is a cyclic shift of the sequence to the left by the offset For example if then choosing and yields a segment This segment is then shifted by the offset to the and you get a segment which then takes the place of of the original elements of the segment In the end you get Sort the given array using no more than cyclic shifts of any of its segments Note that you don t need to minimize the number of cyclic shifts Any method that requires or less cyclic shifts will be accepted ,In this problem it was enough to implement an analogue of standard or Here is an example of a solution based on selection sort Let s find the minimum element in the array by simply iterating over it Let s denote its index in the array by If we apply a shift to it the following happens Once again please note that all shifts are made in the left direction so shifting by to the left will put the element that was previously at index in the first place Let us perform a similar shift for the second largest element of the array putting it in second place for the third largest element of the array putting it in third place and so on More formally let s describe the th iteration as follows At the beginning of the th iteration the first elements of the array are its minimal elements already in their correct places in sorted order During the th iteration the th largest element of the array is placed in the th place in the array Since the first minimal elements are already in their places the th largest element of the array is simply the smallest element among Let s find it by iterating over these elements and denote its index in the array by Make a shift The first elements will not change and the element from the th place in the array will move to the th It is worth noting that the output format forbids shifting segments with Regarding this case we should check the equality separately If these two indexes coincide then the th element is already in its place and no shift should be done on this iteration Let us repeat this algorithm for At each iteration the new element will be shifted into its place in sorted order and each iteration performs no more than one shift operation Thus in strictly less than shifts the array will be completely sorted The time complexity is 
Recently Vasya decided to improve his pistol shooting skills Today his coach offered him the following exercise He placed cans in a row on a table Cans are numbered from left to right from to Vasya has to knock down each can exactly once to finish the exercise He is allowed to choose in which he will knock the cans down Vasya knows that the of the th can is It means that if Vasya has already knocked cans down and is now about to start shooting the th one he will need shots to knock it down You can assume that if Vasya starts shooting the th can he will be shooting it until he knocks it down Your task is to choose such an order of shooting so that the number of shots required to knock each of the given cans down exactly once is minimum possible ,We can see that because the multiplier in the formula is the position of the number and we want to minimize the sum of such formulas the following greedy solution comes up to mind because we want to count greater values as earlier as possible let s sort the array in non increasing order saving initial indices of elements calculate the answer and print the permutation of indices in order from left to right 
Recently you have bought a snow walking robot and brought it home Suppose your home is a cell on an infinite grid You also have the sequence of instructions of this robot It is written as the string consisting of characters and If the robot is in the cell right now he can move to one of the adjacent cells depending on the current instruction If the current instruction is then the robot can move to the left to if the current instruction is then the robot can move to the right to if the current instruction is then the robot can move to the top to if the current instruction is then the robot can move to the bottom to You ve noticed the warning on the last page of the manual if the robot visits some cell twice then it breaks So the sequence of instructions is valid if the robot starts in the cell performs the given instructions visits no cell other than two or more times and ends the path in the cell Also cell should be visited two times at the beginning and at the end if the path is empty then it is visited only once For example the following sequences of instructions are considered valid and the following are considered invalid the endpoint is not and the cell is visited twice The initial sequence of instructions however might be not valid You don t want your robot to break so you decided to reprogram it in the following way you will remove some possibly all or none instructions from the initial sequence of instructions then rearrange the remaining instructions as you wish and turn on your robot to move Your task is to remove as few instructions from the initial sequence as possible and rearrange the remaining ones so that the sequence is valid Report the valid sequence of the maximum length you can obtain Note that you can choose order of remaining instructions you don t need to minimize the number of swaps or any other similar metric You have to answer independent test cases ,Let be the number of occurrences of the character in the initial string the number of occurrences of the character and are the same things for remaining characters It is obvious that in every answer the number of equals the number of and the same for and The maximum theoretic answer we can obtain has length And We almost always can obtain this answer If there is at least one occurrence of each character then we can construct some kind of rectangular path moves right then moves up and the completing part But there are some corner cases when some characters are missing If then our answer is empty or if it is possible it is The same if Time complexity per test case 
Polycarp likes squares and cubes of positive integers Here is the beginning of the sequence of numbers he likes For a given number count the number of integers from to that Polycarp likes In other words find the number of such that is a square of a positive integer number or a cube of a positive integer number or both a square and a cube simultaneously ,We ll search for positive integers not larger than and add their squares or cubes to the set if they don t exceed If the maximum number Polycarp will like is so the running time will be within the time limit The answer to the problem is the length of the resulting set 
You are given strings Each string consists of lowercase English letters Rearrange reorder the given strings in such a way that for every string all strings that are placed before it are its String is a of string if it is possible to choose several letters in in such a way that they form For example string is contained as a in strings and but is not contained as a in strings and ,Firstly sort all the strings by their lengths if there are several strings of the same length their order does not matter because if the answer is then all the strings of the same length should be equal Then for each check that is a substring of If it doesn t hold for some then the answer is Otherwise the answer is and the sorted array is the correct order of strings 
Masha has types of tiles of size Each cell of the tile contains one integer Masha has an of tiles of each type Masha decides to construct the square of size consisting of the given tiles This square also has to be a and each cell of this square has to be covered with exactly one tile cell and also sides of tiles should be parallel to the sides of the square All placed tiles cannot intersect with each other Also each tile should lie inside the square See the picture in Notes section for better understanding Symmetric with respect to the main diagonal matrix is such a square that for each pair the condition holds I e it is true that the element written in the row and th column equals to the element written in the th row and th column Your task is to determine if Masha can construct a square of size which is a symmetric matrix and consists of tiles she has Masha can use any number of tiles of each type she has to construct the square Note that she rotate tiles she can only place them in the orientation they have in the input You have to answer independent test cases ,Firstly if is odd then the answer is by obvious reasons Otherwise we can notice that the top left and the bottom right values of the tile do not matter since we can place tiles symmetrically So we only need to check that there is some tile that its top right value equals its bottom left value because this is how we get main diagonal symmetry 
Taisia has six sided dice Each face of the die is marked with a number from to each number from to is used once Taisia rolls all dice at the same time and gets a sequence of values where is the value on the upper face of the th dice The sum of this sequence is equal to Suddenly Taisia s pet cat steals exactly dice with value and calculates the sum of the values on the remaining dice which is equal to You only know the number of dice and the values of Restore a possible sequence that fulfills the constraints ,It is easy to find the value on the cube that the cat stole it is equal All other values must be Let s try to get by taking times and adding the remainder there if it is non zero We could not get more than cubes this way because otherwise but we are guaranteed that the answer exists Now until we get the cube let s find the cube with the maximum value reduce it by and add the cube with the value of We can definitely get dice because otherwise but we are guaranteed that the answer exists It remains only to add a cube with the value of to our cubes We obtained a solution with asymptotics 
Tanya has candies numbered from to The th candy has the weight She plans to eat exactly candies and give the remaining candy to her dad Tanya eats candies in order of increasing their numbers Your task is to find the number of such candies let s call these candies that if dad gets the th candy then the sum of weights of candies Tanya eats in even days will be equal to the sum of weights of candies Tanya eats in odd days Note that at first she will give the candy after it she will eat the remaining candies one by one For example and weights are Consider all possible cases to give a candy to dad Tanya gives the st candy to dad the remaining candies are She will eat in the first day in the second day in the third day So in odd days she will eat and in even days she will eat Since this case shouldn t be counted to the answer this candy isn t Tanya gives the nd candy to dad the remaining candies are She will eat in the first day in the second day in the third day So in odd days she will eat and in even days she will eat Since this case shouldn t be counted to the answer this candy isn t Tanya gives the rd candy to dad the remaining candies are She will eat in the first day in the second day in the third day So in odd days she will eat and in even days she will eat Since this case to the answer this candy is Tanya gives the th candy to dad the remaining candies are She will eat in the first day in the second day in the third day So in odd days she will eat and in even days she will eat Since this case to the answer this candy is In total there cases which should counted these candies are so the answer is ,Let s maintain four variables and which will mean the sum of with odd on prefix even on prefix odd on suffix and even on suffix Initially and are equals to the sum of with odd in a whole array and equals to the sum of with even in a whole array Let s iterate from left to right over all elements of the array Let s consider the current element If is even then set otherwise let s set Then let s consider we give the current candy to dad Then we have to increase the answer if and Then if is even then let s set otherwise let s set 
The All Berland Team Programming Contest will take place very soon This year teams of four are allowed to participate There are programmers and mathematicians at Berland State University How many maximum teams can be made if each team must consist of exactly students teams of mathematicians or programmers are unlikely to perform well so the decision was made not to compose such teams Thus each team must have at least one programmer at least one mathematician Print the required maximum number of teams Each person can be a member of no more than one team ,If necessary change the values of and so that is always true Consider two cases 1 Let Then This means that the set is at least times larger than and we can form teams of the form where one participant will be a programmer and three will be mathematicians 2 Let Then assume that Let s substitute this value into the inequality Then we compose commands of the form Since making such a command decreases the value of by 2 The new value The condition still holds Then make commands of the form The total number of commands is That s what we wanted to get 
There are students in a university The number of students is even The th student has programming skill equal to The coach wants to form teams Each team should consist of exactly two students and each student should belong to exactly one team Two students can form a team only if their skills are equal otherwise they cannot understand each other and cannot form a team Students can solve problems to increase their skill One solved problem increases the skill by one The coach wants to know the minimum total number of problems students should solve to form exactly teams i e each pair of students should form a team Your task is to find this number ,If we sort the students in order of non decreasing their skill we can see that the minimum cost of the team with the lowest skill let s call it the first team is equal to if is already sorted the cost of the second team is and so on So if we sort in non decreasing order then the answer is 
You are given two arrays and both consisting of positive greater than zero integers You are also given an integer In one move you can choose two indices and and swap and i e becomes and vice versa Note that and can be equal or different in particular swap with or swap and both are acceptable moves Your task is to find the possible sum you can obtain in the array if you can do no more than i e at most such moves swaps You have to answer independent test cases ,Each move we can choose the minimum element in the maximum element in and swap them if the minimum in is less than maximum in If we repeat this operation times we get the answer This can be done in but authors solution is 
Two gram is an ordered pair i e string of length two of capital Latin letters For example three distinct two grams You are given a string consisting of capital Latin letters Your task is to find two gram contained in the given string i e two consecutive characters of the string maximal number of times For example for string the answer is two gram which contained in three times In other words find any most frequent two gram Note that occurrences of the two gram can overlap with each other ,There are at least two different approaches to this problem You can iterate over all substrings of of length and calculate for each of them the number of its occurrences in and try to update the result with the current substring Also you can iterate over all two grams in the alphabet and do the same as in the aforementioned solution 
There is a game called Unique Bid Auction You can read more about it here https en wikipedia org wiki Unique bid auction though you don t have to do it to solve this problem Let s simplify this game a bit Formally there are participants the th participant chose the number The winner of the game is such a participant that the number he chose is i e nobody else chose this number except him and is i e among all unique values of the minimum one is the winning one Your task is to find the of the participant who won the game or if there is no winner Indexing is based i e the participants are numbered from to You have to answer independent test cases ,This is a simple implementation problem Let s calculate two values for each i from 1 to n cnt i the number of occurrences of i in a and idx i any position of i in a Then let s iterate through i from 1 to n and if cnt i 1 just print idx i because if it is the only such element then we found the winner If we didn t find any such element we have to print 
Not so long ago Vlad had a birthday for which he was presented with a package of candies There were types of candies there are candies of the type Vlad decided to eat exactly one candy every time choosing any of the candies of a type that is currently the most frequent if there are several such types he can choose of them To get the maximum pleasure from eating Vlad to eat two candies of the same type in a row Help him figure out if he can eat all the candies without eating two identical candies in a row ,There will be three cases in total let s consider them on two types of candies then we will eat candies in this order then we will eat a candy of the type and then we will eat in this order almost as in the case above then we will eat a candy of the type but there will still be more of them than candies of the type and we will have to eat a candy of the type again So the answer is Now we prove that it is enough to check these conditions on two maximums of the array If the third condition is true the answer is obvious Otherwise we will by turns eat candies of the two maximum types until their number is equal to the third maximum after which we will by turns eat candies of these three types and so on 
You are given an array of length You are also given a set of positions where The position means that you can swap elements and You can apply this operation any number of times for each of the given Your task is to determine if it is possible to sort the initial array in non decreasing order using only allowed swaps For example if and then we can first swap elements and because position is contained in the given set We get the array Then we swap and position is also contained in We get the array Finally we swap and again and get the array sorted in non decreasing order You can see that if and then you cannot sort the array You have to answer independent test cases ,The simple simulation works here while there is at least one inversion such a pair of indices and that we can fix let s fix it we can fix this inversion if If there are inversions but we cannot fix any of them the answer is Otherwise the answer is There is also a solution it is obvious that we have some segments in which we can change the order of elements as we want And it is also obvious that we cannot move elements between these allowed segments So each of them is independent of each other We can just find all these segments of indices using two pointers and sort them independently Then we just need to check if the array becomes sorted Time complexity is or 
Some number of people this number is even have stood in a circle The people stand in the circle evenly They are numbered clockwise starting from a person with the number Each person is looking through the circle s center at the opposite person You don t know the exact number of people standing in the circle but this number is even no doubt It is known that the person with the number is looking at the person with the number and vice versa of course What is the number associated with a person being looked at by the person with the number If for the specified and no such circle exists output ,The person with the number looks at the person with the number so the count of people standing to the left of between and is equal to the count of people standing to the right of between and Therefore both counts are equal to hence must be a solution of the equation The only solution of the equation is Let s check that in the circle of people can occur the numbers and i e let s check that If it s false there s no solution output Since the person with the number looks at the person with the number the condition must be met Let s solve the equation for There are two solutions We can output any of such that It s easy to prove that exactly one of the solutions meets the condition 
There is a bookshelf which can fit books The th position of bookshelf is if there is a book on this position and otherwise It is guaranteed that there is on the bookshelf In one move you can choose some contiguous segment consisting of books i e for each from to the condition holds and Shift it to the right by move the book at index to for all This move can be done only if and there is no book at the position Shift it to the left by move the book at index to for all This move can be done only if and there is no book at the position Your task is to find the number of moves required to collect all the books on the shelf as a consecutive segment i e the segment without any gaps For example for there is a gap between books when and for there are no gaps between books and for there are also no gaps between books You have to answer independent test cases ,We can notice that the answer is the number of zeros between the leftmost occurrence of and the rightmost occurrence of Why is it true Let s take the leftmost maximum by inclusion segment of and just shift it right We can see that using this algorithm we will do exactly described amount of moves and there is no way improve the answer 
You are given an array consisting of integers Your task is to determine if has some of length at least that is a palindrome Recall that an array is called a of the array if can be obtained by removing some possibly zero elements from not necessarily consecutive without changing the order of remaining elements For example and are subsequences of but and are not Also recall that a palindrome is an array that reads the same backward as forward In other words the array of length is the palindrome if for all from to For example arrays and are palindromes but arrays and are not You have to answer independent test cases ,The first observation is that we can always try to find the palindrome of length otherwise we can remove some characters from the middle until its length becomes The second observation is that the palindrome of length is two equal characters and some other maybe the same character between them Now there are two ways find the pair of equal non adjacent characters in or do it in for each character we only need to consider its left and right occurrences 
 There are kids each of them is reading a unique book At the end of any day the th kid will give his book to the th kid in case of the kid will give his book to himself It is guaranteed that all values of are distinct integers from to i e is a permutation The sequence doesn t change from day to day it is fixed For example if and then at the end of the first day the book of the st kid will belong to the th kid the nd kid will belong to the th kid and so on At the end of the second day the book of the st kid will belong to the th kid the nd kid will belong to the th kid and so on Your task is to determine the number of the day the book of the th child is returned back to him for the first time for every from to Consider the following example The book of the st kid will be passed to the following kids after the st day it will belong to the th kid after the nd day it will belong to the rd kid after the rd day it will belong to the nd kid after the th day it will belong to the st kid So after the fourth day the book of the first kid will return to its owner The book of the fourth kid will return to him for the first time after exactly one day You have to answer independent queries ,In this problem you just need to implement what is written in the problem statement For the kid the following pseudocode will calculate the answer indices of the array and its values are indexed pos p i ans 1while pos i ans 1 pos p pos 
 You are messaging in one of the popular social networks via your smartphone Your smartphone can show at most most recent conversations with your friends Initially the screen is empty i e the number of displayed conversations equals Each conversation is between you and some of your friends There is at most one conversation with any of your friends So each conversation is uniquely defined by your friend You suddenly have the ability to see the future You know that during the day you will receive messages the th message will be received from the friend with ID If you receive a message from in the conversation which is currently displayed on the smartphone then nothing happens the conversations of the screen do not change and do not change their order you read the message and continue waiting for new messages Otherwise i e if there is no conversation with on the screen Firstly if the number of conversations displayed on the screen is the last conversation which has the position is removed from the screen Now the number of conversations on the screen is guaranteed to be less than and the conversation with the friend is not displayed on the screen The conversation with the friend appears on the first the topmost position on the screen and all the other displayed conversations are shifted one position down Your task is to find the list of conversations in the order they are displayed on the screen after processing all messages ,The solution to this problem is just the implementation of what is written in the problem statement Let s carry the array which shows the current smartphone screen When we receive the new message from the friend with ID let s do the following sequence of moves Firstly let s try to find him on the screen If he is found just do nothing and continue Otherwise let s check if the current number of conversations is If it is so then let s remove the last conversation Now the number of conversations is less than and the current friend is not shown on the screen Let s insert him into the first position After processing all messages the answer is just the array 
Paul and Mary have a favorite string which consists of lowercase letters of the Latin alphabet They want to paint it using pieces of chalk of two colors red and green Let s call a coloring of a string wonderful if the following conditions are met each letter of the string is either painted in exactly one color red or green or isn t painted each two letters which are painted in the same color are different the number of letters painted in red is equal to the number of letters painted in green the number of painted letters of this coloring is among all colorings of the string which meet the first three conditions E g consider a string equal to One of the wonderful colorings of the string is shown in the figure Paul and Mary want to learn by themselves how to find a wonderful coloring of the string But they are very young so they need a hint Help them find the number of red or green these numbers are equal letters in a wonderful coloring ,Let s calculate the number of letters which occur exactly once in the string and letters that occur more than once and respectively If a letter occurs more than once one of its occurrences may be painted in red and another one may be painted in green We cannot paint all other occurrences because there will be two equal letters painted in one color but this is unacceptable by the statement So there are no more than occurrences of letters that occur more than once to be painted in red Let s select such occurrences and paint them We need to paint additionally the letters which occur exactly once by meeting the same conditions as we meet painting the whole string There s no way to paint these letters and not meet the first two conditions So we must select the maximal count of the letters so that we will be able to paint some set of remaining letters in green so that the number of red letters will be equal to the number of green letters This number is equal to So the final answer is equal to 
 There are kids each of them is reading a unique book At the end of any day the th kid will give his book to the th kid in case of the kid will give his book to himself It is guaranteed that all values of are distinct integers from to i e is a permutation The sequence doesn t change from day to day it is fixed For example if and then at the end of the first day the book of the st kid will belong to the th kid the nd kid will belong to the th kid and so on At the end of the second day the book of the st kid will belong to the th kid the nd kid will belong to the th kid and so on Your task is to determine the number of the day the book of the th child is returned back to him for the first time for every from to Consider the following example The book of the st kid will be passed to the following kids after the st day it will belong to the th kid after the nd day it will belong to the rd kid after the rd day it will belong to the nd kid after the th day it will belong to the st kid So after the fourth day the book of the first kid will return to its owner The book of the fourth kid will return to him for the first time after exactly one day You have to answer independent queries ,In this problem we can notice that when we calculate the answer for the kid we also calculate the answer for kids and so on So we can a little bit modify the pseudocode from the easy version to calculate answers faster pos p i ans 1cycle i while pos i cycle append pos ans 1 pos p pos for el in cycle res el ansAnd of course we don t need to run this while for all elements for which we already calculated the answer Total time complexity is because you ll process each element exactly once 
 You are messaging in one of the popular social networks via your smartphone Your smartphone can show at most most recent conversations with your friends Initially the screen is empty i e the number of displayed conversations equals Each conversation is between you and some of your friends There is at most one conversation with any of your friends So each conversation is uniquely defined by your friend You suddenly have the ability to see the future You know that during the day you will receive messages the th message will be received from the friend with ID If you receive a message from in the conversation which is currently displayed on the smartphone then nothing happens the conversations of the screen do not change and do not change their order you read the message and continue waiting for new messages Otherwise i e if there is no conversation with on the screen Firstly if the number of conversations displayed on the screen is the last conversation which has the position is removed from the screen Now the number of conversations on the screen is guaranteed to be less than and the conversation with the friend is not displayed on the screen The conversation with the friend appears on the first the topmost position on the screen and all the other displayed conversations are shifted one position down Your task is to find the list of conversations in the order they are displayed on the screen after processing all messages ,The idea of this solution is the same as in the easy version but now we need to do the same sequence of moves faster We can notice that the smartphone screen works as a queue so let store it as a queue When the new message appears we have to check if the friend with this ID is in the queue already but we need to check it somehow fast Let s use some logarithmic structure that stores the same information as the queue but in other order to find add and remove elements fast In C this structure is So let s check if the current friend is in the queue and if no let s check if the size of the queue is If it is so then let s remove the first element of the queue from it and the same element from the set also Then add the current friend to the queue and to the set After processing all messages the reversed queue the queue from tail to head is the answer to the problem Time complexity And don t forget that and other standard hashmaps can work in linear time in the worst case so you need to redefine the hash function to use them You can read more about this issue here https codeforces com blog entry 62393 
Recently Paul and Mary have found a new favorite sequence of integers They want to paint it using pieces of chalk of colors The coloring of a sequence is called if the following conditions are met each element of the sequence is either painted in one of colors or isn t painted each two elements which are painted in the same color are different i e there s no two equal values painted in the same color let s calculate for each of colors the number of elements painted in the color all calculated numbers must be equal the total number of painted elements of the sequence is the among all colorings of the sequence which meet the first three conditions E g consider a sequence and One of the wonderful colorings of the sequence is shown in the figure Help Paul and Mary to find a wonderful coloring of a given sequence ,Since we must use exactly colors each element that occurs in the sequence may have no more than painted occurrences for each element its occurrences where is the number of all its occurrences in the sequence Let be a sequence of all elements that occur in the sequence but in the sequence they will occur only once Let s create a indexed array in which we will add indices of occurrences of in the sequence then the selected occurrences of and so on till Currently is a set of occurrences which wonderful coloring is a wonderful coloring of the whole sequence because if we want to paint an occurrence outside we can do it only by selecting an occurrence of the same element in which we will not paint so that no more than occurrences will be painted We must use exactly colors and paint for each color an equal number of occurrences hence if we want to paint all occurrences from we must remove from it the minimum number of occurrences so that the size of the array will be divided by i e remove the number of occurrences equal to the remainder of dividing the size of by We can remove any occurrences for example let s delete it from the suffix of Currently we can paint all occurrences from using the following rule the occurrence we must paint in the color with a number where takes the remainder of dividing the left operand by the right operand So all occurrences from will be painted and all colors will be used Since all occurrences of one element belong to one subsegment of and their number isn t greater than they will be painted in different colors It may be so that the array before painting will be empty In this case the wonderful coloring of doesn t contain any painted element 
You are given a string consisting of the characters and You need to replace all the characters with in the string by or so that the string becomes a palindrome and has characters and characters Note that each of the characters is replaced from the others A string of length is called a palindrome if the equality is true for all For example if and then you can replace the characters in the following ways For the given string and the numbers and replace all the characters with in the string by or so that the string becomes a palindrome and has characters and characters ,First let s find such positions i 1 le i le n such that s i ne symbols in symmetric positions are uniquely determined If s n i 1 then s n i 1 s i If s i ne s n i 1 then at the end we will not get a palindrome in any way so the answer is Note that after such a replacement the remaining characters are split into pairs except maybe the central one If the center character is then it is necessary to put the character if a is odd or if b is odd if neither a nor b is odd then the answer is Now the remaining characters are split into pairs i e if s i then s n i 1 This allows the remaining characters and to be replaced greedily If s i and a 1 then s i s n i 1 and decrease a for 2 If s i and b 1 then s i s n i 1 and decrease b for 2 Otherwise the answer is 
You are given a string consisting of lowercase Latin letters Polycarp wants to remove exactly characters from the string Polycarp uses the following algorithm times if there is at least one letter remove the leftmost occurrence and stop the algorithm otherwise go to next item if there is at least one letter remove the leftmost occurrence and stop the algorithm otherwise go to next item remove the leftmost occurrence of the letter and stop the algorithm This algorithm removes a single letter from the string Polycarp performs this algorithm exactly times thus removing exactly characters Help Polycarp find the resulting string ,Let the lowercase Latin letters be indexed from to There are exists at least two different solutions If exit the program Otherwise count the number of occurrences of each letter from to Let it be Now find the alphabetically smallest letter that will be in the resulting string It can be done as follows iterate over all from to and if then subtract it from otherwise will be the smallest letter that will be in the resulting string But we possibly need to remove some number of its leftmost occurrences It is obvious that letters smaller than will not appear in the resulting string Also the leftmost occurrences of letter will be removed Now let s iterate over all letters in string from left to right and construct the resulting string If the current character of let it be is smaller than then do nothing If is greater than then add it to Otherwise If then decrease by one otherwise add to The time complexity is Another solution is the following Let s carry the vector of pairs where is the th character of and is its position If we sort this vector with the standard compare function it is easy to see that the first elements of this vector will be removed from the input string Then if we will sort the last elements of this vector by its positions in the input string in increasing order we will obtain the answer The time complexity is 
Recall that the sequence is a a subsequence of the sequence if can be derived from by removing zero or more elements without changing the order of the remaining elements For example if then possible subsequences are and but not and You are given a sequence consisting of positive and negative elements there is no zeros in the sequence Your task is to choose length subsequence of the given sequence i e the sign of each next element is the opposite from the sign of the current element like positive negative positive and so on or negative positive negative and so on Among all such subsequences you have to choose one which has the of elements In other words if the maximum length of subsequence is then your task is to find the of elements of some subsequence of length You have to answer independent test cases ,Firstly let s extract maximum by inclusion segments of the array that consists of the numbers with the same sign For example if the array is 1 1 2 1 5 2 1 3 then these segments are 1 1 2 1 5 2 1 and 3 We can do it with any two pointers like algorithm The number of these segments is the maximum possible length of the alternating subsequence because we can take only one element from each block And as we want to maximize the sum we need to take the maximum element from each block Time complexity O n 
You are a coach at your local university There are students under your supervision the programming skill of the th student is You have to create a team for a new programming competition As you know the more students some team has the more probable its victory is So you have to create a team with the maximum number of students But you also know that a team should be It means that the programming skill of each pair of students in a created team should differ by no more than Your task is to report the maximum possible number of students in a team ,Let s sort all values in non decreasing order Then we can use two pointers to calculate for each student the maximum number of students such that This is pretty standard approach We also can use binary search to do it or we can store for each programming skill the number of students with this skill and just iterate from some skill to and sum up all numbers of students 
At the school where Vasya is studying preparations are underway for the graduation ceremony One of the planned performances is a ball which will be attended by pairs of boys and girls Each class must present two couples to the ball In Vasya s class boys and girls wish to participate But not all boys and not all girls are ready to dance in pairs Formally you know possible one boy one girl pairs You need to choose two of these pairs so that no person is in more than one pair For example if and the couples are ready to dance together in each pair the boy s number comes first then the girl s number then the following combinations of two pairs are possible not all possible options are listed below and and But the following combinations are not possible and the first boy enters two pairs and the second girl enters two pairs Find the number of ways to select two pairs that match the condition above Two ways are considered different if they consist of different pairs ,We can think that it is given a bipartite graph Boys and girls are the vertices of the graph If a boy and a girl are ready to dance together then an edge is drawn between them In this graph you need to select two edges that do not intersect at the vertices Let the number of edges included in the vertex Iterate over the first edge It will block of other edges all adjacent to vertex to vertex but the edge will be blocked twice All non blocked edges do not intersect with at the vertices So you can add to the answer 
You are given a board of size where is not divisible by Initially each cell of the board contains one figure In one move you can select presented in some cell and move it to one of the cells i e from the cell you can move the figure to cells Of course you move figures to cells out of the board It is allowed that after a move there will be several figures in one cell Your task is to find the minimum number of moves needed to get into cell i e cells should contain figures and one cell should contain figures You have to answer independent test cases ,It is intuitive and provable that the best strategy is to move each figure to the center cell Now with some paperwork or easy observations we can notice that we have exactly cells with the shortest distance cells with the shortest distance cells with the shortest distance and so on So we have cells with the shortest distance So the answer is It can be rewritten as so we can just calculate the sum of squares of all integers from to using loop or formula and multiply the answer by Time complexity or 
There are people who want to participate in a boat competition The weight of the th participant is Only teams consisting of people can participate in this competition As an organizer you think that it s fair to allow only teams with So if there are teams where is the weight of the first participant of the th team and is the weight of the second participant of the th team then the condition where is the total weight of team should be satisfied Your task is to choose such that the number of teams people can create is the possible Note that each participant can be in team You have to answer independent test cases ,This is just an implementation problem Firstly let s fix it can be in range find the maximum number of boats we can obtain with this and choose the maximum among all found values To find the number of pairs let s iterate over the smallest weight in the team in range Let this weight be Then because the sum of weights is the biggest weight is And the number of pairs we can obtain with such two weights and the total weight is where is the number of occurrences of in And the additional case if is even we need to add Don t forget that there is a case so you need to assume that these values are zeros 
Polycarp is reading a book consisting of pages numbered from to Every time he finishes the page with the number divisible by he writes down the last digit of this page number For example if and pages divisible by are Their last digits are correspondingly their sum is Your task is to calculate the sum of all digits Polycarp has written down You have to answer independent queries ,Let be the number of integers from to divisible by We can notice that because we write down only the last digit of each number divisible by then the length of the cycle of digits does not exceed In fact we can always suppose that it is because for all from to So let for all from to Then the answer is 
You have got a shelf and want to put some books on it You are given queries of three types put a book having index on the shelf to the left from the leftmost existing book put a book having index on the shelf to the right from the rightmost existing book calculate the minimum number of books you need to pop from the left or from the right in such a way that the book with index will be leftmost or rightmost You can assume that the first book you will put can have any position it does not matter and queries of type are always valid it is guaranteed that the book in each such query is already placed You can also assume that you don t put the same book on the shelf twice so s don t repeat in queries of first two types Your problem is to answer all the queries of type in order they appear in the input Note that after answering the query of type all the books remain on the shelf and the relative order of books does not change ,Let imagine our shelf as an infinite array Let s carry the rightmost free position from the left of our shelf let it be and initially it equals to and the leftmost free position from the right of our shelf let it be and initially it equals to Also let s carry the array of length where will be equal to the position in our imaginary array of the book with a number Let s put the first book to the position Also let s save that where is the number of the first book equals to How will change and will become and will become Now let s process queries one by one If now we have the query of type with a book with a number then let s set and set The query of type can be processed similarly Now what about queries of type The answer to this query equals to where is the absolute value of 
You are given an array consisting of integers Your task is to say the number of such positive integers such that divides number from the array In other words you have to find the number of common divisors of all elements in the array For example if the array will be then and divide each number from the array so the answer for this test is ,Let is the greatest common divisor of all elements of the array You can find it by Euclidean algorithm or some standard library functions Then the answer is just the number of divisors of You can find this value in 
Vova is playing a computer game There are in total turns in the game and Vova really wants to play all of them The initial charge of his laptop battery i e the charge before the start of the game is During each turn Vova can choose what to do If the current charge of his laptop battery is strictly greater than Vova can and then the charge of his laptop battery will decrease by if the current charge of his laptop battery is strictly greater than Vova can his laptop and then the charge of his laptop battery will decrease by if the current charge of his laptop battery is less than or equal to and at the same time then Vova cannot do anything and loses the game Vova wants to complete the game Vova can complete the game if after each of turns the charge of the laptop battery is Vova has to play Among all possible ways to complete the game Vova wants to choose the one where the number of turns when he is the possible It is possible that Vova cannot complete the game at all Your task is to find out the possible number of turns Vova can make the or report that Vova cannot complete the game You have to answer independent queries ,Firstly about the problem description Vova really needs to i e play Exactly turns Among all possible ways to do it he need choose one where the number of turns when he this is the first type turn is Suppose the answer is Then the charge of the battery after turns will be If this value is greater than then the answer is Otherwise we need to replace some turns when Vova with turns when Vova The charge of the battery will increase by avfter one replacement We have to obtain with some replacements The number of turns to do it is equals to where is divided by rounded up If then the answer is Otherwise the answer is 
Polycarp bought a new expensive painting and decided to show it to his friends He hung it in his room of his friends entered and exited there one by one At one moment there was no more than one person in the room In other words the first friend entered and left first then the second and so on It is known that at the beginning before visiting friends a picture hung in the room At the end after the th friend it turned out that it disappeared At what exact moment it disappeared there is no information Polycarp asked his friends one by one He asked each one if there was a picture when he entered the room Each friend answered one of three response encoded with response encoded as response is encoded with Everyone except the thief either doesn t remember or told the The thief can say anything any of the three options Polycarp cannot understand who the thief is He asks you to find out the number of those who can be considered a thief according to the answers ,First let s note that we will have a transition from to only once otherwise it turns out that first the picture disappeared then it appeared and disappeared back but we can consider that a friend in the middle who answered lied to us but this is not true because even before him the picture disappeared So we need to find this transition Since we can also meet we find the index of the leftmost in case of absence we take and mark it as and the index of rightmost in case of absence we take and mark as Answer the number of indices between them inclusive because only they could lie There could not be a thief to the left of since either the friend under the index lied or the picture was not stolen before There could not be a thief to the right of since either the painting had already been stolen in the presence of s friend or it was he who lied 
An array consisting of integers is if For example the arrays are strictly increasing the arrays are not For a strictly increasing array of elements let s denote the as the number of different elements in the array For example the characteristic of the array is since the array contains different elements and You are given two integers and Construct an increasing array of integers from to with characteristic ,We can transform the problem as follows Let We need to find an array so that the sum of elements in it is not greater than all elements are positive integers and the number of different elements is the maximum possible Suppose we need different elements in What can be the minimum possible sum of elements in It s easy to see that should have the following form This array contains exactly different elements these different elements are as small as possible so their sum is as small as possible and all duplicates are s So if the sum of this array is not greater than then it is possible to have the number of different elements in equal to The rest is simple We can iterate on find the maximum possible construct the difference array and then use it to construct the array itself 
You are given an array consisting of positive integers You can perform operations on it In one operation you can replace any element of the array with that is by an integer part of dividing by rounding down See if you can apply the operation some number of times possible to make the array become a permutation of numbers from to that is so that it contains all numbers from to each exactly once For example if then the answer is yes You could do the following Replace with then Replace with then Replace with then Replace with then ,Let s sort the array in descending order of the values of its elements Then let s create a logical array where will have the value if we already got element of the permutation we are looking for and the value otherwise We loop through the elements of the array and assign We ll divide by as long as it exceeds or as long as is If it turns out that then all the numbers that could be obtained from have already been obtained before Since each element of the array must produce a new value from to the answer cannot be constructed output Otherwise assign a value of this means that the number which is an element of the permutation we will get exactly from the original number After processing all elements of the array we can output 
There are piranhas with sizes in the aquarium Piranhas are numbered from left to right in order they live in the aquarium Scientists of the Berland State University want to find if there is piranha in the aquarium The piranha is called if it can eat all the other piranhas in the aquarium except itself of course Other piranhas will do nothing while the piranha will eat them Because the aquarium is pretty narrow and long the piranha can eat only one of the adjacent piranhas during one move Piranha can do as many moves as it needs or as it can More precisely The piranha can eat the piranha if the piranha exists and The piranha can eat the piranha if the piranha exists and When the piranha eats some piranha its becomes Your task is to find piranha in the aquarium or determine if there are no such piranhas Note that you have to find exactly one dominant piranha you don t have to find all of them For example if then the third piranha can be Consider the sequence of its moves The piranha eats the second piranha and becomes the underlined piranha is our candidate The piranha eats the third piranha and becomes The piranha eats the first piranha and becomes The piranha eats the second piranha and becomes You have to answer independent test cases ,If all the piranhas have the same size then the answer is Otherwise there are at least two different sizes of piranhas and the answer always exists Claim that the answer is such a piranha with the maximum size that one of the adjacent piranhas has the size less than a maximum Why is it true and why the answer always exists First if the piranha with the maximum size eats some other piranha it becomes the only maximum in the array and can eat all other piranhas Why is there always such a pair of piranhas Let s change our array a bit replace every maximum with and every non maximum with There is always some pair or pair in such array because we have at least two different elements 
You are policeman and you are playing a game with Slavik The game is turn based and each turn consists of two phases During the first phase you make your move and during the second phase Slavik makes his move There are doors the th door initially has durability equal to During your move you can try to break one of the doors If you choose door and its current durability is then you reduce its durability to the value is given During Slavik s move he tries to repair one of the doors If he chooses door and its current durability is then he increases its durability to the value is given The game lasts turns If some player cannot make his move then he has to skip it Your goal is to maximize the number of doors with durability equal to at the end of the game You can assume that Slavik the number of such doors What is the number of such doors in the end if you both play optimally ,Let s consider two cases If then the answer is because we can make opposite moves to the Slavik s moves and it always will reduce durability of some door so at some point we will reach the state when all doors will have durability Otherwise and we have to realize the optimal strategy for us If we have some door with durability then let s break it immediately why shouldn t we do this If we don t do it then Slavik will repair this door during his move So what Slavik will do now He will repair some door Which door he has to repair Of course the one with durability because otherwise we will break it during our next move So we can realize that doors with durability are not interesting for us because Slavik will make opposite moves to our moves And what is the answer if the number of doors with durability equals to It is 
You are given sequences of integers The length of the th sequence equals to You have to choose exactly two sequences and such that you can remove exactly one element in each of them in such a way that the sum of the changed sequence its length will be equal to equals to the sum of the changed sequence its length will be equal to Note that it s to remove exactly one element in each of the two chosen sequences Assume that the sum of the empty of the length equals sequence is ,Let s calculate the array of triples Triple means that the sum of the sequence without the element at position will be equal to Triples can be easily calculated in a following manner for each sequence find its sum then iterate over all its elements and subtract each of them one after another Now sort array with the standard compare function Finally the answer is if and only if there exist two adjacent elements with equal sums and different sequences it is very easy to see So if we find such a pair then the answer will be otherwise the answer will be Time complexity of the solution is 
There are friends who want to give gifts for the New Year to each other Each friend should give one gift and receive one gift The friend give the gift to himself For each friend the value is known it is either if the th friend doesn t know whom he wants to give the gift to or if the th friend wants to give the gift to the friend You want to fill in the unknown values in such a way that each friend gives one gift and receives one gift and there is friend who gives the gift to himself It is guaranteed that the initial information isn t contradictory If there are several answers you can print any ,In this problem we need to print the permutation without fixed points without values but some values are known in advance Let s consider the permutation as a graph We know that the permutation is the set of non intersecting cycles In this problem we are given such a graph but some edges are removed How to deal with it Firstly let s find isolated vertices in the graph Let its number be If then all is ok and we skip the current step If then let s pin this isolated vertex to any vertex to which we can pin it Otherwise and we can create the chine consisting of all isolated vertices Now and we can finally construct the remaining part of the graph We can notice that we have the same number of vertices with zero incoming and zero outcoming degrees And because we got rid of all possible loops in the graph we can match these vertices as we want Time complexity 
There is a frog staying to the left of the string consisting of characters to be more precise the frog initially stays at the cell Each character of is either or It means that if the frog is staying at the th cell and the th character is the frog can jump only to the left If the frog is staying at the th cell and the th character is the frog can jump only to the right The frog wants to reach the th cell The frog chooses some value and cannot change it later and jumps by no more than cells at once I e if the th character is then the frog can jump to any cell in a range and if the th character is then the frog can jump to any cell in a range The frog doesn t want to jump far so your task is to find the minimum possible value of such that the frog can reach the cell from the cell if it can jump by no more than cells at once You have to answer independent test cases ,The only observation we need is that we don t need to jump left at all This only decreases our position so we have less freedom after the jump to the left Then to minimize we only need to jump between the closest cells So if we build the array where is the position of the th cell from left to right indexed then the answer is Time complexity 
A string is called if it consists of a concatenation joining of strings of length consisting of the same characters In other words a string is even if two conditions are satisfied its length is even for all odd is satisfied For example the following strings are even empty string and The following strings are not even and Given a string consisting of lowercase Latin letters Find the minimum number of characters to remove from the string to make it even The deleted characters do not have to be consecutive ,We will act greedily we will make an array consisting of elements in which we will mark if the letter is already encountered in the string and otherwise In the variable we will store the length of the even string that can be obtained from We will go through the string by executing the following algorithm if mark if then we already have a pair of repeating characters to add to an even string add to the number and clear the array Clearing is necessary because both characters that will make up the next pair must be in the string after the current character In other words if the last character in the current pair was then the first character in the new pair can be where Then we calculate the answer as 
Let s call an array if there is an element in the array that equals to the sum of all other elements For example the array is good because there is the element which equals to the sum You are given an array consisting of integers Your task is to print all indices of this array such that after removing the th element from the array it will be let s call such indices For example if the indices are and if you remove the array will look like and it is if you remove the array will look like and it is You have to consider all removals i e remove the element check if the resulting array is and return the element into the array ,The first part calculate the sum of the whole array be careful it can be The second part let s maintain an array of size where will be equal to the number of elements in the given array equals to The third part iterate over the array let the current position be Set make If is even and then the index is otherwise it doesn t And after all make and set 
Let s call yet again a string if its length is even and every character in odd position of this string is different from the next character the first character is different from the second the third is different from the fourth and so on For example the strings and are good strings and the strings and are not good You are given a string you have to delete minimum number of characters from this string so that it becomes good ,The following greedy solution works let s iterate over all characters of the string from left to right and if the last block of two consecutive characters in the resulting string is full just add the current character to the resulting string otherwise add this character if it is not equal to the first character of the last block And don t forget about the parity of length remove last character if the length is odd 
Polycarp has a cat and his cat is a real gourmet Dependent on a day of the week he eats certain type of food on Mondays Thursdays and Sundays he eats on Tuesdays and Saturdays he eats on other days of week he eats Polycarp plans to go on a trip and already packed his backpack His backpack contains daily rations of daily rations of daily rations of Polycarp has to choose such day of the week to start his trip that his cat can eat without additional food purchases as long as possible Print the maximum number of days the cat can eat in a trip without additional food purchases if Polycarp chooses the day of the week to start his trip optimally ,Let the number of rations of fish food be the number of rations of rabbit stew be and the number of rations of chicken stakes be so we have an array consisting of elements Let be the maximum number of full weeks cat can eat if the starting day of the trip can be any day of the week The value of is Let s subtract the value from and from and We can see that we cannot feed the cat at least one more full week So the final answer is where Now it s time for some good implementation Of course you can try to analyze all cases and handle them using ifs or something similar but I will try to suggest you a good enough way to implement the remaining part of the problem Let s create an array of length where means the type of the food cat eats during the th day of the week for fish food for rabbit stew and for chicken stake It will be Now let s iterate over the day we will start our trip Let it be For the current starting day let be the number of rations cat has eaten already initially it is zero be the current day of the trip initially it is and the array be the copy of the array Then let s do the following sequence of the operations while is greater than zero decrease by one increase by one and set take it modulo and add one After this cycle we can update the answer with the value of 
Initially you have the array consisting of one element In one move you can do one of the following things Increase some element of by choose some from to the current length of and increase by one Append the copy of some element of to the end of the array choose some from to the current length of and append to the end of the array For example consider the sequence of five moves You take the first element append its copy to the end of the array and get You take the first element increase it by and get You take the second element append its copy to the end of the array and get You take the first element append its copy to the end of the array and get You take the fourth element increase it by and get Your task is to find the number of moves required to obtain the array with the sum at least You have to answer independent test cases ,It is pretty intuitive that we firstly need to do all increments and only then copy numbers because otherwise we can swap the order of moves and the sum will not decrease You could notice that the answer does not exceed so we can just iterate from to and fix the number we will copy Let it be Then we need moves to obtain it and also need moves to get the enough number of copies So we can update the answer with this number of moves Time complexity per test case Actually the required number is always pretty near to so it is enough to try a few options in range to get the optimal answer This is solution 
You are given a string consisting only of Latin letters a and a string consisting of lowercase Latin letters In one move you can replace any letter a in the string with a string Note that after the replacement string might contain letters other than a You can perform an arbitrary number of moves including zero How many different strings can you obtain Print the number or report that it is infinitely large Two strings are considered different if they have different length or they differ at some index ,Let s consider some cases If there are letters a in string then the moves can be performed endlessly If itself is equal to a then the string won t change so the answer is Otherwise the length of is least so string will be increasing in length after each move and the answer is If there are no letters a in string then the resulting string is only determined by whichever letters a we chose to replace with That s because once we replace a letter a with string we can do nothing with the new letters anymore We can actually imagine that is equal to b and the answer won t change Now it s easy to see that the answer is equal to the number of strings of length consisting only of letters a and b There are two options for each position and there are positions so the answer is Overall complexity per testcase 
Polycarp has found a table having an infinite number of rows and columns The rows are numbered from starting from the topmost one The columns are numbered from starting from the leftmost one Initially the table hasn t been filled and Polycarp wants to fix it He writes integers from and so on to the table as follows The leftmost topmost cell of the table is filled with the number Then he writes in the table all positive integers beginning from sequentially using the following algorithm First Polycarp selects the leftmost non filled cell in the first row and fills it Then while the left neighbor of the last filled cell is filled he goes down and fills the next cell So he goes down until the last filled cell has a non filled neighbor to the left look at the vertical arrow going down in the figure above After that he fills the cells from the right to the left until he stops at the first column look at the horizontal row in the figure above Then Polycarp selects the leftmost non filled cell in the first row goes down and so on A friend of Polycarp has a favorite number He wants to know which cell will contain the number Help him to find the indices of the row and the column such that the intersection of the row and the column is the cell containing the number ,Let s call a set of cells being filled from the topmost row to the leftmost column a E g the st layer consists of the single number the nd layer consists of the numbers and the rd layer consists of the numbers and etc The number of cells in layers forms an arithmetic progression The first layer consists of cells the th layer consists of cells The minimum number in the th layer is equal to the sum of sizes of all layers from the st to the th plus Suppose that belongs to the th layer Consider the value of Polycarp fills exactly cells on the th layer before he starts filling the cells from the right to the left i e while he goes down Therefore if the number belongs to the th row and the th column Otherwise the number belongs to the th row and the th column Consider a way to find the coordinates of a given number Let s iterate by the layer number to which given the number belongs calculating the values of and going to the next layer let s calculate the next layer parameters as follows The iteration must be stopped if the layer number is such that Using the values of and we can calculate the given number s coordinates in the described way in The total time of calculating the coodrinates for one given is where is the number of the layer to which the given belongs Let s represent the value of as hence Therefore the coordinates of one number may be calculated in At the same time as it follows from the formulas the layer number can be calculated as follows the square root of rounded up To avoid accuracy problems you can calculate the value using a loop 
The heat during the last few days has been really intense Scientists from all over the Berland study how the temperatures and weather change and they claim that this summer is abnormally hot But any scientific claim sounds a lot more reasonable if there are some numbers involved so they have decided to actually calculate some value which would represent how high the temperatures are Mathematicians of Berland State University came up with a special This value is calculated as follows Suppose we want to analyze the segment of consecutive days We have measured the temperatures during these days the temperature during th day equals We denote the of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days So if we want to analyze the from day to day we calculate it as note that division is performed without any rounding The is the maximum of over all segments of not less than consecutive days For example if analyzing the measures and we are interested in segments and we want to find the maximum value of over these segments You have been hired by Berland State University to write a program that would compute the of a given period of days Are you up to this task ,This task is very straight forward implementation problem So we can iterate over all segments of the given array calculate their sum and if the length of the current segment is not less than k try to update the answer with the mean of this segment Overall complexity is O n 2 
Stephen Queen wants to write a story He is a very unusual writer he uses only letters and To compose a story Stephen wrote out words consisting of the first lowercase letters of the Latin alphabet He wants to select the number of to make an story Let a story be a sequence of words that are not necessarily different A story is called if there exists a letter which occurs among all words of the story more times than all other letters together For example the story consisting of three words is interesting the letter occurs times all other letters occur times in total But the story consisting of two words is not no such letter that it occurs more than all other letters in total You are given a sequence of words consisting of letters and Your task is to choose the maximum number of them to make an interesting story If there s no way to make a non empty story output ,Let be the number of the occurrences of the letter in the word minus the number of the occurrences of all other letters in total Since for each two words and the number of the occurrences of a letter in the word is the sum of the numbers of its occurrences in and the equality is true means the concatenation of and Consider a sequence of words A story consisting of words is interesting if and only if there s a letter such that it exactly means that there s a letter which occurs more times than all other in total So we are interested in searching for a letter such that exists a positive integer a maximal number of words such that Suppose we have a set of words that form an interesting story and where is the letter having more occurrences than all other letters in total Suppose we can add to it one of few words We had better add a word such that is maximal to be able to add more words in the future So the problem has the following solution for each letter of the Latin alphabet and for each word let s calculate Then let s iterate over all letters take a sequence and sort it in descending order Let s initialize an interesting story by a set of a single word corresponding to the first element of the sequence If there s no word such that then there s no non empty interesting story containing some words of the given set Otherwise let s take the next elements of the sequence sequentially until the sum of over all taken words is greater than zero Let s select a letter such that the corresponding taken set is maximal over all letters Finally we should print the set s size The solution consists of two phases the calculation of all works in where is the alphabet s size is the lengths of a string and building a maximal interesting story for each letter sorting and a greedy algorithm 
Polycarp was given a row of tiles Each tile contains one lowercase letter of the Latin alphabet The entire sequence of tiles forms the string In other words you are given a string consisting of lowercase Latin letters Initially Polycarp is on the tile of the row and wants to get to the tile by jumping on the tiles Jumping from th tile to th tile has a cost equal to where is the index of the letter in the alphabet for example Polycarp wants to get to the th tile for the minimum total cost but at the same time make number of jumps In other words among all possible ways to get to the last tile for the total cost he will choose the one with the number of jumps Polycarp can visit each tile Polycarp asks you to help print the sequence of indices of string on which he should jump ,It s worth knowing that ways like and have the same cost That is first you need to understand the letter on the first tile and the last one conditionally the letters and Then you just need to find all such tiles on which the letters are between the letters and inclusive We go through each letter from to and for each letter we visit every tile that has a given letter but we must not forget to start exactly at tile and end at tile 
You are given a sequence of integers of length and integer number You should print number in the range of i e such that exactly elements of given sequence are less than or equal to Note that the sequence can contain equal elements If there is no such print without quotes ,In this problem you can do the following thing firstly let s sort our array Let will be the answer Then you have two cases if then otherwise for 0 indexed array Then you need to calculate the number of the elements of the array that are less than or equal to Let it be Then if or then print otherwise print 
There are dormitories in Berland State University they are numbered with integers from to Each dormitory consists of rooms there are rooms in th dormitory The rooms in th dormitory are numbered from to A postman delivers letters Sometimes there is no specific dormitory and room number in it on an envelope Instead of it only a room number among all rooms of all dormitories is written on an envelope In this case assume that all the rooms are numbered from to and the rooms of the first dormitory go first the rooms of the second dormitory go after them and so on For example in case and an envelope can have any integer from to written on it If the number is written on an envelope it means that the letter should be delivered to the room number of the second dormitory For each of letters by the room number among all dormitories determine the particular dormitory and the room number in a dormitory where this letter should be delivered ,We should use that the letter queries are given in increasing order of room numbers We will store in a variable the number of rooms in already considered dormitories this variable should have 64 bit type and in a variable we will store the minimum number of dormitory where the room from the current letter possibly is Initially and We will iterate through the letters Let the current letter should be delivered to the room While we increase by and increase by one So we got the dormitory number where room is It only remains to print two integers the dormitory number and the room number in this dormitory 
Polycarp found under the Christmas tree an array of elements and instructions for playing with it At first choose index starting position in the array Put the chip at the index on the value While add to your score and move the chip positions to the right i e replace with If then Polycarp ends the game For example if and then the following game options are possible Polycarp chooses Game process The score of the game is Polycarp chooses Game process The score of the game is Polycarp chooses Game process The score of the game is Polycarp chooses Game process The score of the game is Polycarp chooses Game process The score of the game is Help Polycarp to find out the maximum score he can get if he chooses the starting index in an optimal way ,Let be the result of the game if we chose as the starting position Let s look at some starting position After making a move from it we will get points and move to the position continuing the same game This means that by choosing the position we can assume that we will get a result more than if we chose the position Formally Let s calculate all the results of and store them in an array Let s start iterating through the positions from the end then being in the position we will know for all Using the formula above we can calculate in one operation It remains only to choose the maximum of all such values 
You are given an array consisting of integers Each is one of the six following numbers Your task is to remove the minimum number of elements to make this array An array of length is called if is divisible by and it is possible to split it into Examples of good arrays the whole array is a required sequence the first sequence is formed from first second fourth fifth seventh and tenth elements and the second one is formed from remaining elements Examples of bad arrays the order of elements should be exactly the length of the array is not divisible by the first sequence can be formed from first six elements but the remaining array cannot form the required sequence ,Let be the number of subsequences be the number of subsequences the number of subsequences and so on and is the number of completed subsequences Let s iterate over all elements of in order from left to right If the current element is then let s increase by one we staring the new subsequence Otherwise it is always better to continue some existing subsequence just because why not If the current element is then we can continue some subsequence if it is then we can continue some subsequence and the same for remaining numbers Let be the indexed position of the current element of in list Then the case is described above and in other case if then let s set and we continue some of existing subsequences The answer can be calculated as after all iterations 
You are given an array consisting of integers You have to find the length of the smallest shortest of elements you need to erase from to make it a array Recall that the prefix of the array is a subarray consisting several first elements the prefix of the array of length is the array The array of length is called if you can obtain a array from it repeating the following operation times initially is empty select either the first or the last element of remove it from and append it to the end of the array For example if we do operations take then then and at last then becomes and Consider the following example This array is because we can obtain array from it by the following sequence of operations take the first element of so take the last element of so take the last element of so take the first element of so take the first element of so take the last element of so take the only element of so is non decreasing Note that the array consisting of one element is Print the length of the shortest prefix of to delete erase to make to be a array Note that the required length can be You have to answer independent test cases ,Consider the maximum element a mx of the good array a of length k Then we can notice that the array a looks like a 1 le a 2 le dots le a mx ge dots ge a k 1 ge a k And this is pretty obvious that if the array doesn t have this structure then it isn t good you can see it yourself So we need to find the longest such suffix It s pretty easy doable with pointer initially the pointer pos is at the last element Then while pos 1 and a pos 1 ge a pos decrease pos by one If we re done with the previous step we do the same but while pos 1 and a pos 1 le a pos The answer is pos 1 
You are given segments on a number line each endpoint of every segment has integer coordinates Some segments can degenerate to points Segments can intersect with each other be nested in each other or even coincide The intersection of a sequence of segments is such a maximal set of points not necesserily having integer coordinates that each point lies within every segment from the sequence If the resulting set isn t empty then it always forms some continuous segment The length of the intersection is the length of the resulting segment or in case the intersection is an empty set For example the intersection of segments and is length the intersection of segments and is length and the intersection of segments and is an empty set length Your task is to remove exactly one segment from the given sequence in such a way that the intersection of the remaining segments has the maximal possible length ,Intersection of some segments is If this segment has its left bound greater than its right bound then the intersection is empty Removing some segment makes the original sequence equal to That can be split up to a prefix of length and a suffix of length Intersections for them can be precalced separately and stored in some partial sum like arrays Finally you have to iterate over the position of the removed segment and calculate the intersection of prefix and suffix without this segment Overall complexity 
You are given a sequence consisting of integers Let s call a group of consecutive elements a Each is characterized by two indices the index of its left end and the index of its right end Denote by a of the sequence with the left end in and the right end in i e For example if then are We split the given sequence into so that each element is in one the sums of elements for all are For example if then such a sequence can be split into three Each element belongs to exactly the sum of the elements of each is Let s define of split as the length of the longest For example the thickness of the split from the example above is Find the minimum thickness among all possible splits of the given sequence of into in the required way ,Let s iterate over the length of the first segment of the split Having fixed it we actually fixed the sum that needs to be collected on all other segments Since each element must belong to exactly one segment we can build other segments greedily If we have found a solution we will remember the length of the longest segment in it and try to update the answer We have possible lengths of the first segment for each of which we greedily built the answer for Thus the asymptotics of the solution will be 
Yelisey has an array of integers If has length strictly greater than then Yelisei can apply an operation called to it First Yelisei finds the minimal number in the array If there are several identical minima Yelisey can choose any of them Then the selected minimal element is removed from the array After that is subtracted from each remaining element Thus after each operation the length of the array is reduced by For example if then the minimum element in it is which means that after this operation the array will be equal to Since Yelisey likes big numbers he wants the numbers in the array to be as big as possible Formally speaking he wants to make the of the numbers in array to be i e he want to maximize a minimum To do this Yelisey can apply the operation to the array as many times as he wants possibly zero Note that the operation cannot be applied to an array of length Help him find what maximal value can the minimal element of the array have after applying several possibly zero operations to the array ,Note that the order of numbers in the array does not affect anything If you swap two elements in the original array the set of elements at each step will not change in any way Let s sort the original array and denote it by We denote by the state of array after applying operations of The minimum element in is so the elements of array will be equal to and therefore the minimum of them will be Constructing an array we can notice that its elements are equal to We know that the elements of are the difference between corresponding elements of the array and so Thus the elements of the array are the differences between elements of starting with third and the minimum of which is It is not difficult to show in a similar way for example by induction that the elements of are equal to the minimum of which is So the candidates for the answer are simply differences of adjacent elements of the array Indeed if we look at it will undergo changes as follows You can notice that the minimum elements starting with after the first operation are exactly and respectively Thus to solve the problem it was sufficient to sort the array in ascending order then take the maximum of the original first element and the differences of all adjacent elements 
Find the minimum number with the given sum of digits such that digits in it are distinct i e all digits are unique For example if then the answer is This is the minimum number in which all digits are different and the sum of the digits is For the given print the required number ,Let s use the greedy solution we will go through the digits in decreasing order If the sum of we need to dial is greater than the current digit we add the current digit to the end of the line with the answer Note that in this way we will always get an answer consisting of the minimum possible number of digits because we are going through the digits in descending order Suppose that the resulting number is not optimal Then some digit can be reduced and some digit that comes after it can be increased in order to save the sum we can not increase the digit before it as then we get a number greater than the current one Two variants are possible We want to increase the digit to but then it becomes equal to the digit following it or exceeds the value Then we can t increment that digit Otherwise in the first step we can get instead of but since we are going through the digits in decreasing order we cannot get the value of in that case Contradiction 
You are given a bracket sequence of length where is even divisible by two The string consists of opening brackets and closing brackets In one move you can choose and move it to the beginning of the string or to the end of the string i e you choose some index remove the th character of and insert it before or after all remaining characters of Your task is to find the minimum number of moves required to obtain from It can be proved that the answer always exists under the given constraints Recall what the regular bracket sequence is is regular bracket sequence if is regular bracket sequence then is regular bracket sequence if and are regular bracket sequences then is regular bracket sequence For example and are regular bracket sequences but and are not You have to answer independent test cases ,Let s go from left to right over characters of maintaining the current bracket balance for the position the balance is the number of opening brackets on the prefix till the th character minus the number of closing brackets on the same prefix If the current balance becomes less than zero then let s just take some opening bracket after the current position it obviously exists because the number of opening equals the number of closing brackets and move it to the beginning so the negative balance becomes zero again and the answer increases by one Or we can move the current closing bracket to the end of the string because it leads to the same result Time complexity 
You have a garland consisting of lamps Each lamp is colored red green or blue The color of the th lamp is and colors of lamps in the garland You have to recolor some lamps in this garland recoloring a lamp means changing its initial color to another in such a way that the obtained garland is A garland is called if any two lamps of the same color have distance divisible by three between them I e if the obtained garland is then for each such that should be satisfied The value means absolute value of the operation means remainder of when divided by For example the following garlands are The following garlands are not Among all ways to recolor the initial garland to make it you have to choose one with the number of recolored lamps If there are multiple optimal solutions print of them ,It is easy to see that any garland has one of the following patterns We can hard code all all this patterns or iterate over all these permutations of letters using three nested loops or standard language functions We can calculate for each pattern the cost to obtain such pattern from the given string and choose one with the minimum cost 
We will consider the numbers and as adjacent if they differ by exactly one that is We will consider cells of a square matrix as adjacent if they have a common side that is for cell cells and are adjacent to it For a given number construct a square matrix such that Each integer from to occurs in this matrix exactly once If and are adjacent cells then the numbers written in them ,Note that is the only case where there is no answer For other cases consider the following construction Let s say that the cell is white if is an even number otherwise we will say that the cell is black Let s arrange the cells so that all white cells are first and if the colors are equal the cells will be compared lexicographically Arrange numbers from to in ordered cells For example for the following matrix will be constructed 
You are given an array of integers Find the number of pairs where the sum of is greater than or equal to and less than or equal to that is For example if and then two pairs are suitable and and ,The problem can be divided into two classic ones Count the number of pairs Count the number of pairs Let be the answer to the first problem and be the answer to the second problem Then is the answer to the original problem The new problem can be solved by binary search Iterate over the first element of the pair Then you need to count the number of elements such that If you sort the array this value can be calculated by running a single binary search 
You are given an array consisting of positive integers You have to choose a positive integer and paint all elements into two colors All elements which are divisible by will be painted red and all other elements will be painted blue The coloring is called beautiful if there are no pairs of adjacent elements with the same color in the array Your task is to find any value of which yields a beautiful coloring or report that it is impossible ,What does it mean that no pair of adjacent elements should have the same color It means that either all elements on odd positions are blue and all elements on even positions are red or vice versa So we need to check these two cases Let s try to solve a case when we have to find a number such that are divisible by and are not What does it mean that divides all of the numbers It means that divides the where represents the greatest common divisor Let s calculate this using Euclidean algorithm or some built in functions in Okay now we need to check all divisors of the and find if any of them does not divide So we have to factorize and generate all of its divisors or do we In fact if divides any of the numbers then every divisor of also divides that number So the only two numbers we have to check as canditates for the answer are and 
Monocarp and Polycarp are learning new programming techniques Now they decided to try pair programming It s known that they have worked together on the same file for minutes Every minute exactly one of them made one change to the file Before they started there were already lines written in the file Every minute exactly one of them does one of two actions adds a new line to the end of the file or changes one of its lines Monocarp worked in total for minutes and performed the sequence of actions If then he adds a new line to the end of the file If then he changes the line with the number Monocarp performed actions strictly in this order then Polycarp worked in total for minutes and performed the sequence of actions If then he adds a new line to the end of the file If then he changes the line with the number Polycarp performed actions strictly in this order then Restore their common sequence of actions of length such that all actions would be correct there should be no changes to lines that do not yet exist Keep in mind that in the common sequence Monocarp s actions should form the subsequence and Polycarp s subsequence They can replace each other at the computer any number of times Let s look at an example Suppose Monocarp first changed the line with the number and then added a new line thus Polycarp first added a new line and then changed the line with the number thus Since the initial length of the file was in order for Polycarp to change line number two new lines must be added beforehand Examples of correct sequences of changes in this case would be and Changes wrong order of actions and line cannot be edited yet are not correct ,The solution is that if we can do something let s do it It doesn t make sense not to act because neither adding a new row nor modifying an existing one can prevent the existing row from being changed in the future Therefore we will iterate over the actions and eagerly act Monocarp or Polycarp Let s create two pointers and in arrays and index of possible action of Monocarp and Polycarp and the current length of the file Suppose that or on current iteration Then we take the appropriate zero element and increase by one We can do that because appending a new line cannot make a new answer prefix incorrect if the previous prefix was correct Suppose that and If and then there is no answer because we can potentially do only two actions and both make the answer incorrect If one number is greater than and the other is less than or equals then we take the one that less than or equals If one of the sequences or ends then only one potential action needs to be checked at each iteration 
Let s call some square matrix with integer values in its cells if it doesn t change after the order of rows is reversed and it doesn t change after the order of columns is reversed For example the following matrices are The following matrices are because they change after the order of rows is reversed The following matrices are because they change after the order of columns is reversed You are given integers Put them into a matrix of rows and columns so that each number is used exactly once each cell contains exactly one number and the resulting matrix is If there are multiple answers print any If there is no solution print ,Basically what does the matrix being palindromic imply For each values in cells and are equal all zero indexed You can easily prove it by reversing the order of rows or columns and checking the overlapping cells in them Thus all cells can be split up into equivalence classes The even case is simple all classes have size The odd case has classes of sizes and Let s fill the classes one by one Obviously the order between the classes of the same size doesn t matter I claim that filling the classes in order in sizes construct the answer if any exists The key observation is that each next size is divisible by the previous one The implementation can come in lots of different forms and complexities Mine works in you can refer to it in attachment 
You want to perform the combo on your opponent in one popular fighting game The combo is the string consisting of lowercase Latin letters To perform the combo you have to press all buttons in the order they appear in I e if then you have to press then and again You know that you will spend wrong tries to perform the combo and during the th try you will make a mistake right after th button i e you will press first buttons right and start performing the combo from the beginning It is guaranteed that during the th try you press all buttons right and finally perform the combo I e if and then the sequence of pressed buttons will be you re making a mistake and start performing the combo from the beginning you re making a mistake and start performing the combo from the beginning Your task is to calculate for each button letter the number of times you ll press it You have to answer independent test cases ,We can consider all tries independently During the th try we press first buttons so it makes on the prefix of length So the th character of the string will be pressed the number of plus times We can use sorting and some kind of binary search to find this number for each character but we also can build suffix sums to find all required numbers We can build suffix sums using the following code vector int cnt n for int i 0 i m i cnt p i for int i n 1 i 0 i cnt i 1 cnt i So as you can see the th element of will add in each position from to So we got what we need After that we can calculate the answer for each character in the following way vector int ans 26 for int i 0 i n i ans s i a cnt i 1 Time complexity or 
You are given a system of pipes It consists of two rows each row consists of pipes The top left pipe has the coordinates and the bottom right There are six types of pipes two types of straight pipes and four types of curved pipes Here are the examples of all six types Types of pipes You can turn each of the given pipes degrees clockwise or counterclockwise so the types and can become each other and types can become each other You want to turn some pipes in a way that the water flow can start at to the left of the top left pipe move to the pipe at flow somehow by to the pipe at and flow right to Pipes are connected if they are adjacent in the system and their ends are connected Here are examples of connected pipes Examples of connected pipes Let s describe the problem using some example The first example input And its solution is below The first example answer As you can see the water flow is the poorly drawn blue line To obtain the answer we need to turn the pipe at degrees clockwise the pipe at degrees the pipe at degrees the pipe at degrees and the pipe at degrees Then the flow of water can reach from You have to answer independent queries ,Let s see how the water can flow when it meets the pipe of type or and in the other case When the water meets the pipe of type or we cannot do anything but let it flow to the right of the current cell Otherwise if the current pipe is curved then there are two cases if the pipe on the same position but in the other row is not curved then the answer is because the water has to change the row but we cannot turn the next pipe to allow it to move to the right or to the left So the current pipe is curved and the pipe on the same position in the other row is also curved let s change the row and move to the right it is obvious that we never need to move to the left So the answer and the sequence of pipes is uniquely defined by types of pipes If after iterating over all positions we didn t meet the case of and the current row is second then the answer is 
There is a river of width The left bank of the river is cell and the right bank is cell more formally the river can be represented as a sequence of cells numbered from to There are also wooden platforms on a river the th platform has length so the th platform takes consecutive cells of the river It is guaranteed that the sum of lengths of platforms does not exceed You are standing at and want to reach somehow If you are standing at the position you can jump to any position in the range you don t really like the water so you can jump only to such cells that belong to some wooden platform For example if you can jump only to the next position if it belongs to the wooden platform You want to know if it is possible to reach from if you can move any platform to the left or to the right arbitrary number of times possibly zero as long as they do not intersect each other but two platforms can touch each other It also means that you cannot change the relative order of platforms in other words you first move the platforms and then start jumping For example if and then one of the ways to reach from is follow ,This problem has a very easy idea but requires terrible implementation Firstly let s place all platforms as rightmost as we can Thus we will have the array in which the first elements are zeros and other elements are Now let s start the algorithm Firstly we need to jump to the position or less If we could jump to the position then we don t need to jump to some position to the left from But if we cannot do it let s take the leftmost platform to the right from the position and move it in such a way that its left border will be at the position Now we can jump to the position and then jump by right to reach the position Let s repeat the same algorithm and continue jumping If after some move we can jump to the position at least then we are done Time complexity but I m sure it can be implemented in or 
Polycarp wrote on a whiteboard an array of length which is a permutation of numbers from to In other words in each number from to occurs exactly once He also prepared a resulting array which is initially empty that is it has a length of After that he did exactly Each looked like this Look at the leftmost and rightmost elements of and pick the smaller of the two If you picked the leftmost element of append it to the left of otherwise if you picked the rightmost element of append it to the right of The picked element is erased from Note that on the last step has a length of and its minimum element is both leftmost and rightmost In this case Polycarp can choose what role the minimum element plays In other words this element can be added to both on the left and on the right at the discretion of Polycarp Let s look at an example Let Initially Then During the first step the minimum is on the right with a value of so after this step and he added the value to the right During the second step the minimum is on the left with a value of so after this step and he added the value to the left During the third step the minimum is on the left with a value of so after this step and he added the value to the left During the fourth step the minimum is both left and right this value is Let s say Polycarp chose the right option After this step and he added the value to the right Thus a possible value of after steps could be You are given the final value of the resulting array Find possible initial value for that can result the given or determine that there is no solution ,The maximum element is always added last so if it is not in the first or last position then there is no answer Let us prove that if the permutation has its maximum element in the first or last position then after actions we can get an expanded permutation Indeed the maximum element will be added last at the desired end and all the others will be added in reverse order Then if the answer exists it is sufficient to simply unfold the permutation 
An array of integers is called a if it contains each number from to exactly once For example the following arrays are permutations and The following arrays are permutations Polycarp invented a really cool permutation of length It is very disappointing but he forgot this permutation He only remembers the array of length where Given and help Polycarp restore the invented permutation ,Let s Thus It means that the sequence of partial sums is the required permutation if we do to each element The value of is unknown yet Find such that is minimum Thus Exactly this value will change to be after you add So add to each element of and check that now it is a permutation Probably you need to use to avoid possible integer overflows 
A positive integer is called a if it can be represented as where is a non negative integer So the are You are given two positive integers and Your task is to represent as the of ,First of all let s analyze how can we calculate the minimum number of powers of two needed to get as the sum We can use binary representation of each bit in it which is equal to becomes a summand in the answer Firstly if the number of summands is greater than then the answer is Okay what if we don t have enough summands Every summand can be broken down into two summands equal to Let s maintain all summands greater than somewhere stack array queue multiset anything you want and pick an arbitrary summand and break it into two until we have exactly summands If then this process will terminate since we will have some summand to pick until all of them are equal to 
Ivan wants to play a game with you He picked some string of length consisting only of lowercase Latin letters You don t know this string Ivan has informed you about all its improper prefixes and suffixes i e prefixes and suffixes of lengths from to but he didn t tell you which strings are prefixes and which are suffixes Ivan wants you to guess which of the given strings are prefixes of the given string and which are suffixes It may be impossible to guess the string Ivan picked since multiple strings may give the same set of suffixes and prefixes but Ivan will accept your answer if there is at least one string that is consistent with it Let the game begin ,The first observation if we will take two strings of length then we can restore the initial string Why Because there are two possible options when the first string of length is a prefix and the second one is the suffix and vice versa Let s write a function which will check if the first string can be the prefix of the guessed string and the second one can be the suffix After we write this function we can run it two times depending on the order of strings of length and find any suitable answer If the first string is the prefix and the second one is the suffix then the whole string indexed where is the concatenation of strings Let s check if we have all prefixes and suffixes of this string in the input We can easy do it with two nested loops and some boolean array which can say us if some string is already used or not Firstly let s iterate over the length of the prefix or suffix and inside let s find any string from the input matching to the current prefix or suffix If we find all strings then the current string is one of the guessed and we can print the answer 
A sequence of numbers is called if it contains all integers from to exactly once For example the sequences and are permutations but and are not Kristina had a permutation of elements She wrote it on the whiteboard times in such a way that while writing the permutation at the th time she skipped the element So she wrote in total sequences of length each For example suppose Kristina had a permutation of length Then she did the following Wrote the sequence skipping the element from the original permutation Wrote the sequence skipping the element from the original permutation Wrote the sequence skipping the element from the original permutation Wrote the sequence skipping the element from the original permutation You know all of sequences that have been written on the whiteboard but you do not know the order in which they were written They are given in Reconstruct the original permutation from them For example if you know the sequences then the original permutation will be ,When Kristina writes sequences on the whiteboard she removes an element with each index exactly once Thus the first element of the permutation will be deleted only once on the first step All sequences except one will start with itTo solve the problem find a sequence such that it starts with some element all sequences other than this one begin with some element Then this permutation will describe the sequence of numbers remaining after removing the th element and the first element itself will be equal to the number The initial permutation will look like 
You are given one integer number Find three such that and or say that it is impossible to do it If there are several answers you can print any You have to answer independent test cases ,Suppose Let s try to minimize and maximize Let be the minimum divisor of greater than Then let be the minimum divisor of that isn t equal and If isn t equal and then the answer is otherwise the answer is Time complexity per query 
Kristina had an array of length consisting of non negative integers She built a new array of length such that For example suppose Kristina had an array of length Then she did the following Calculated Calculated Calculated Calculated As a result she got an array of length You only know the array Find any matching array that Kristina may have originally had ,To solve the problem you can build an array as follows at Let s show that from the constructed array we can get an array equal to the original array If then If then So at If and then If then If then By the construction of the array it is not possible that and So If then If then So We get that for so and array is built correctly 
Recently Polycarp completed successive tasks For each completed task the time is known when it was given no two tasks were given at the same time Also given is the time when the task was completed For each task there is an unknown value It is known that the tasks were completed in the order in which they came Polycarp performed the tasks as follows As soon as the very first task came Polycarp immediately began to carry it out If a new task arrived before Polycarp finished the previous one he put the new task at the end of the queue When Polycarp finished executing the next task and the queue was not empty he took a new task from the head of the queue if the queue is empty he just waited for the next task Find duration of each task ,Accordingly as it was said in the task we put all tasks into the queue in the order of their arrival then we fix the time at the beginning as So while there is a task in the queue we proceed as follows Take the task from the queue Take as time the maximum from the current and from the arrival time of the task We subtract the current time from the time when the task was done Replace the current time with the time the task was done If there is a task in the queue go to item 
 robots have escaped from your laboratory You have to find them as soon as possible because these robots are experimental and their behavior is not tested yet so they may be really dangerous Fortunately even though your robots have escaped you still have some control over them First of all you know the location of each robot the world you live in can be modeled as an infinite coordinate plane and the th robot is currently located at the point having coordinates Furthermore you may send exactly one command to all of the robots The command should contain two integer numbers and and when each robot receives this command it starts moving towards the point having coordinates The robot stops its movement in two cases either it reaches or it cannot get any closer to Normally all robots should be able to get from any point of the coordinate plane to any other point Each robot usually can perform four actions to move Let s denote the current coordinates of the robot as Then the movement system allows it to move to any of the four adjacent points the first action allows it to move from to the second action allows it to move from to the third action allows it to move from to the fourth action allows it to move from to Unfortunately it seems that some movement systems of some robots are malfunctioning For each robot you know which actions it can perform and which it cannot perform You want to send a command so all robots gather at the same point To do so you have to choose a pair of integer numbers and so that each robot can reach the point Is it possible to find such a point ,In fact we have some restrictions on axis and axis for example if some robot stays at the position and cannot move to the left then the answer point should have So we can take the minimum among all coordinates of robots that cannot go up and save it into maximum among all coordinates of robots that cannot go down and save it into minimum among all coordinates of robots that cannot go right and save it into and maximum among all coordinates of robots that cannot go right and save it into Initially So these restrictions are describe some rectangle possibly incorrect with or Let be the bottom left point of this rectangle and be the top right point of this rectangle In case if this rectangle have or the answer is Otherwise this rectangle describes all integer points which can be reachable all robots and you can print any of them 
There are one cat mice and one hole on a coordinate line The cat is located at the point the hole is located at the point All mice are located between the cat and the hole the th mouse is located at the point At each point many mice can be located In one second the following happens First mouse moves to the right by If the mouse reaches the hole it hides i e the mouse will not any more move to any point and will not be eaten by the cat Then the mouse has finished its move the cat moves to the right by If at the new cat s position some mice are located the cat eats them they will not be able to move after that The actions are performed until any mouse hasn t been hidden or isn t eaten In other words the first move is made by a mouse If the mouse has reached the hole it s saved Then the cat makes a move The cat eats the mice located at the pointed the cat has reached if the cat has reached the hole it eats nobody Each second you can select a mouse that will make a move What is the maximum number of mice that can reach the hole without being eaten ,Let s solve the problem using a linear search Let be the number of mice we are trying to save Then it is more efficient to save mice such that they are the closest ones to the hole Let be the distance from the th mouse to the hole Denote Let s prove that these mice will be saved if and only if The necessary condition Suppose we can save the mice and Since only one mouse can be moved in one second the following will happen of mice will already be saved and one mouse will have to be saved When it s been seconds then the distance from the cat to the hole will be equal to and the distance from the mouse to the hole will be equal to since all other mice are already in the hole their distances to the hole are equal to so the sum of the distances from all mice to the hole at the current time is exactly equal to the distance to the hole from one remaining mouse Since the distance from the mouse to the hole is greater than or equal to the distance from the cat to the hole But this cannot be because both the mice and the cat move only to the right and all mice met by the cat are eaten So Sufficient condition Suppose If then all the mice are already in the hole i e they are saved Suppose Let s move any mouse then the cat Suppose the cat ate at least one of the mice This mouse is definitely not the one that was moved Then the distance from it to the eaten mouse was equal to i e the distance from it to the hole was equal to the distance from the eaten mouse to the hole plus The distance from the moved mouse to the hole was at least So where is the distance from the eaten mouse to the hole is the distance from the moved mouse to the hole So but it s false Therefore none of the mice will be eaten on the first move Then the distance from the cat to the hole will be equal to the total distance from the mice to the hole will be equal to i e now we have to solve a similar problem for smaller and So will be gradually decreased to while no mouse will be eaten So if all the mice will be saved Thus to solve the problem we need to find the maximum such that the sum of the distances from the nearest mice to the hole is less than 
You are given a sequence initially consisting of integers You want to transform this sequence so that all elements in it i e it contains several occurrences of the same element To achieve this you choose some integer and then perform the following operation any number of times possibly zero choose some segment of the sequence and remove it But there is one exception More formally you choose some contiguous subsequence such that if and remove it After removal the numbering of elements to the right of the removed segment changes the element that was the th is now th the element that was th is now th and so on i e the remaining sequence just collapses Note that you after you chose it For example suppose Then one of the ways to transform it in two operations is to choose then choose so the resulting sequence is choose so the resulting sequence is Note that choosing is not an operation Also note that you remove any occurrence of Your task is to find the number of operations required to transform the sequence in a way described above You have to answer independent test cases ,Firstly let s remove all consecutive equal elements just keep one occurrence of each such element For example the array 1 1 2 3 3 3 2 becomes 1 2 3 2 Now the answer for each a i is the number of its occurrences plus one Why is it so Because we need to remove all segments of elements between every pair of consecutive occurrences of a i The number of such segments is the number of occurrences of a i minus one There is also a segment before the first occurrence of a i and a segment after the last occurrence of a i But the first segment doesn t exist for the first element and the last segment doesn t exist for the last element So after removing consecutive elements let s calculate for each a i the number of its occurrences plus one subtract one from the value of the first element and from the value of the last element Then the answer is the minimum among these values for all a i 
We call two numbers and if they have the same parity the same remainder when divided by or if For example in each of the pairs the numbers are similar to each other and in the pairs they are not You are given an array of is even positive integers Check if there is such a partition of the array into pairs that each element of the array belongs to exactly one pair and the numbers in each pair are similar to each other For example for the array there is a partition into pairs and The numbers in the first pair are similar because they differ by one and in the second pair because they are both even ,Let be the number of even numbers in the array and be the number of odd numbers in the array Note that if the parities of and of do not equal then the answer does not exist Otherwise we consider two cases and are even numbers Then all numbers can be combined into pairs of equal parity and are odd numbers Then you need to check whether there are two numbers in the array such that the modulus of their difference is If there are two such numbers then combine them into one pair and will decrease by and become even then the solution exists as shown in the previous case 
Polycarp and his friends want to visit a new restaurant The restaurant has tables arranged along a straight line People are already sitting at some tables The tables are numbered from to in the order from left to right The state of the restaurant is described by a string of length which contains characters the table is occupied and the table is empty Restaurant rules prohibit people to sit at a distance of or less from each other That is if a person sits at the table number then all tables with numbers from to except for the th should be free In other words the absolute difference of the numbers of any two occupied tables must be strictly greater than For example if and then strings satisfy the rules of the restaurant strings do not satisfy to the rules of the restaurant since each of them has a pair of with a distance less than or equal to In particular if the state of the restaurant is described by a string without or a string with one then the requirement of the restaurant is satisfied You are given a binary string that describes the current state of the restaurant It is guaranteed that the rules of the restaurant are satisfied for the string Find the maximum number of free tables that you can occupy so as not to violate the rules of the restaurant Formally what is the maximum number of that can be replaced by such that the requirement will still be satisfied For example if then the answer to the problem will be since only the table at position can be occupied such that the rules are still satisfied ,Let s split a given string into blocks of consecutive zeros Then in each such block you can independently put the maximum number of people who fit in it But there are three cases to consider If the current block is not the first and not the last then there are ones at the border and this means that the first tables of the current block and the last are prohibited Therefore remove these zeroes from the string If the current block is the first then the one is at the end and you need to delete the last zeros If the current block is the last then in the beginning there is one and you need to delete the first zeros Also as a separate case you need to consider a string consisting only of zeros Then there is exactly one block from which you do not need to remove zeros Now all the tables in each block are free then in each block we can put Sum these values over all blocks 
Ivan has songs on his phone The size of the th song is bytes Ivan also has a flash drive which can hold at most bytes in total Initially his flash drive is empty Ivan wants to copy all songs to the flash drive He can compress the songs If he compresses the th song the size of the th song reduces from to bytes Ivan can compress any subset of the songs possibly empty and copy all the songs to his flash drive if the sum of their sizes is at most He can compress subset of the songs not necessarily contiguous Ivan wants to find the minimum number of songs he needs to compress in such a way that all his songs fit on the drive i e the sum of their sizes is less than or equal to If it is impossible to copy all the songs even if Ivan compresses all the songs print Otherwise print the minimum number of songs Ivan needs to compress ,If we will no compress songs the sum of the sizes will be equal Let it be Now if we will compress the th song how do will change It will decrease by This suggests that the optimal way to compress the songs is the compress it in non increasing order of Let s create the array of size where Let s sort it in non increasing order and then iterate over all from to If at the current step we print and terminate the program Otherwise we set After all we have to check again if then print otherwise print Time complexity is because of sorting 
You are given a positive integer Check whether the number is representable as the sum of the cubes of two positive integers Formally you need to check if there are two integers and such that For example if then the numbers and are suitable If then no pair of numbers and is suitable ,In this problem we need to find and such that and Since and are positive and are also positive Hence Therefore the number can be iterated from to Since in all tests then For each you can find by the formula This is a positive number It remains to check that is an integer 
A sequence is called good if for each element there exists an element such that is a power of two that is for some non negative integer For example the following sequences are good for example for we can choose Note that their sum is a power of two Similarly such an element can be found for and Note that by definition an empty sequence with a length of is good For example the following sequences are not good for it is impossible to find another element such that their sum is a power of two for it is impossible to find another element such that their sum is a power of two for it is impossible to find another element such that their sum is a power of two You are given a sequence What is the minimum number of elements you need to remove to make it good You can delete an arbitrary set of elements ,You should delete only such for which there is no such that is a power of For each value let s find the number of its occurrences You can use simple standard data structure Do for each element Now you can easily check that doesn t have a pair Let s iterate over all possible sums and for each find calculate If for some or then a pair exists Note that in C solutions it s better to first check that is a key in and only after it calculate This needs to be done since in C when you access a key using the square brackets operator a default mapping key value is created on the absence of the key This increases both the running time and the memory consumption 
A number is if it contains only digits and For example the following numbers are ternary You are given a long ternary number The first leftmost digit of is guaranteed to be the other digits of can be or Let s define the ternary XOR operation of two ternary numbers and both of length as a number of length where where is modulo operation In other words add the corresponding digits and take the remainders of the sums when divided by For example Your task is to find such ternary numbers and both of length and both without leading zeros that and is the minimum possible You have to answer independent test cases ,Let s iterate from left to right over the digits of If the current digit is either or then we can set or correspondingly There are no better choices And if the current digit is then the optimal choise is to set and What happens after the first occurrence of Because of this choice is greater than even if all remaining digits in are So for each set and and print the answer The case without is even easier and in fact we handle it automatically 
Vlad came home and found out that someone had reconfigured the old thermostat to the temperature of The thermostat can only be set to a temperature from to inclusive the temperature cannot change by less than Formally in one operation you can reconfigure the thermostat from temperature to temperature if and You are given and Find the minimum number of operations required to get temperature from temperature or say that it is impossible ,First let s consider the cases when the answer exists If then the thermostat is already set up and the answer is else if then it is enough to reconfigure the thermostat in operation else if exist such temperature that and then you can configure the thermostat in operations If such exists between and we can chose one of bounds or we need to make operations if times if we cannot reconfigure through one of the boundaries as above but we can through both or If we can t get the temperature in one of these ways the answer is 
You are given an array consisting of integer numbers Your task is to split this array into three parts some of which may be empty in such a way that each element of the array belongs to exactly one of the three parts and each of the parts forms a consecutive contiguous subsegment possibly empty of the original array Let the sum of elements of the first part be the sum of elements of the second part be and the sum of elements of the third part be Among all possible ways to split the array you have to choose a way such that and is maximum possible More formally if the first part of the array contains elements the second part of the array contains elements and the third part contains elements then The sum of an empty array is Your task is to find a way to split the array such that and is maximum possible ,Since the given array consists of positive integers for each value of there can be at most one value of such that We can use binary search on the array of prefix sums of to find the correct value of given that it exists If it does exist and this is a candidate solution so we store it Alternatively we can use the two pointers trick when increases cannot decrease Be careful to use 64 bit integers to store sums Overall complexity is or 
Casimir has a rectangular piece of paper with a checkered field of size Initially all cells of the field are white Let us denote the cell with coordinates vertically and horizontally by The upper left cell will be referred to as and the lower right cell as Casimir draws of different sizes on the field A tick of size with its center in cell is drawn as follows First the center cell is painted black Then exactly cells on the top left diagonally to the center and exactly cells on the top right diagonally to the center are also painted black That is all the cells with coordinates for all between and are painted In particular a tick consists of black cells An already painted cell will remain black if painted again Below you can find an example of the box with two ticks of sizes and You are given a description of a checkered field of size Casimir claims that this field came about after he drew some possibly ticks on it The ticks could be of different sizes but the size of each tick is at least that is for all the ticks Determine whether this field can indeed be obtained by drawing some possibly none ticks of sizes or not ,For each painted cell we will determine whether it can be part of some tick of the allowed size If some of the cells cannot be a part of any tick the answer is obviously Otherwise let s match each colored cell with an arbitrary valid entirely contained in the field under consideration and of size tick containing it Let s draw all such ticks then the following holds no empty white cell of the field will be painted since only ticks that do not contradict the field in question have been considered every colored cell of the field will be covered by at least one drawn tick at least the one we matched it with Basically this process gives us a field in which the set of painted cells matches the data in the input which means that the field given in the input could have been obtained in particular in the way described above and the answer is In order to check that all painted cells are parts of some ticks let s go through all possible ticks of size and for each tick mark all the cells included in it If there is at least one unmarked painted cell in the end it can t be a part of any valid tick and the answer is To consider all possible ticks we can iterate through all their possible center cells that is all the painted cells Since smaller ticks are subsets of larger ticks with the same center cell it is sufficient to find the maximal size tick that can be constructed from that center cell So for each painted cell we aim to find the maximal possible size of a tick with its center in this very cell Let us now consider a painted cell as a possible center of some tick By the definition of a tick this cell can be a center of a tick of size if for all from to both cells and exist are not out of bounds and are painted Let s iterate through from to and stop when the described condition is no longer satisfied The largest for which the condition is still satisfied gives us the maximum possible size of a tick with its center in Now if then such a tick is valid and all the cells included in it should be marked Otherwise it could not have been drawn and none of its cells should be marked After a complete check of all possible ticks in a given field either there will be no unchecked painted cells and then the answer is or at least one painted cell is not covered by any valid checkbox and then the answer is The time complexity is 
You find yourself on an unusual crossroad with a weird traffic light That traffic light has three possible colors red yellow green It is known that the traffic light repeats its colors every seconds and at the th second the color is on That way the order of the colors is described by a string For example if then the traffic light works as the following red green green red yellow red green green red yellow and so on More formally you are given a string of length At the first second the color is on at the second at the th second the color is on at the st second the color is on and so on You need to cross the road and that can only be done when the green color is on You know which color is on the traffic light at the moment but you don t know the current moment of time You need to find the minimum amount of time in which you are guaranteed to cross the road You can assume that you cross the road immediately For example with and the current color there are two options either the green color will be on after second or after That way the answer is equal to that is the number of seconds that we are guaranteed to cross the road if the current color is ,Let s note that for each second of color in the traffic light we need to find the rightmost green time and then find the largest distance between color and the nearest green Also let s not forget that traffic light states are cyclical To get rid of cyclicity you can write the string twice and for each cell of color from the first half find the nearest green color thus we solved the problem with cyclicity And now we can just follow this line from right to left and maintain the index of the last occurrence of green If we encounter color then we try to update our answer where is our answer is the nearest time that green was on color current time 
Along the railroad there are stations indexed from to An express train always travels along a route consisting of stations with indices where The train travels along the route from left to right It starts at station then stops at station then at and so on Station the terminus It is possible that the train will visit the same station more than once That is there may be duplicates among the values You are given queries each containing two different integers and For each query determine whether it is possible to travel by train from the station with index to the station with index For example let the train route consist of of stations with indices and give of the following queries It is possible to travel from station to station by taking a section of the route consisting of stations Answer You cannot travel from station to station because the train cannot travel in the opposite direction Answer It is not possible to travel from station to station because station is not part of the train s route Answer ,To solve the problem we will use the dictionary Each station will be matched with a pair of integers the indices of its first and last entries in the route Then we will sequentially process queries If at least one of the stations or is missing in the dictionary the answer is Otherwise check If the index of the first entry of station in the route is strictly less than the index of the last entry of station in the route the answer is Otherwise the answer is 
Two integer sequences existed initially one of them was increasing and the other one decreasing Strictly increasing sequence is a sequence of integers And strictly decreasing sequence is a sequence of integers Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing They were merged into one sequence After that sequence got shuffled For example some of the possible resulting sequences for an increasing sequence and a decreasing sequence are sequences or This shuffled sequence is given in the input Your task is to find two suitable initial sequences One of them should be increasing and the other one decreasing Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing If there is a contradiction in the input and it is impossible to split the given sequence to increasing and decreasing sequences print ,Let s count the number of occurrences of each element in the Because the maximum possible element is it can be done without any data structures Then let s check if is greater than for some from to and if it is then the answer is because this element should occur at least twice in one of the sequences Now let s output the increasing sequence The number of elements in it is the number of elements such that Let s iterate from left to right print the suitable elements and decrease their The number of elements in the decreasing sequence is just the number of elements with non zero So let s iterate from right to left and just print suitable elements 
You have students under your control and you have to compose consisting of some subset of your students Each student had his own skill the th student skill is denoted by an integer different students can have the same skills So about the teams Firstly these two teams should have the same size Two more constraints The first team should consist of students with skills i e all skills in the first team are unique The second team should consist of students with skills i e all skills in the second team are equal Note that it is permissible that some student of the first team has the same skill as a student of the second team Consider some examples skills are given is not a good pair of teams because sizes should be the same is not a good pair of teams because the first team should not contain students with the same skills is not a good pair of teams because the second team should contain students with the same skills is a good pair of teams is a good pair of teams Your task is to find the maximum possible size for which it is possible to compose a valid pair of teams where each team size is skills in the first team needed to be unique skills in the second team should be the same between them A student cannot be part of more than one team You have to answer independent test cases ,Let the number of students with the skill is and the number of different skills is Then the size of the first team can not exceed and the size of the second team can not exceed So the answer is not greater than the minimum of these two values Moreover let s take a look at the skill with a maximum value of Then there are two cases all students with this skill go to the second team then the sizes of teams are at most and correspondingly Otherwise at least one student with this skill goes to the first team and the sizes are at most and correspondingly So the answer is Time complexity 
You are given a positive number Find the smallest positive integer number that has the sum of digits equal to and all digits are unique ,First of all let s understand that the answer to the problem should not contain zeros leading zeros are useless while others increase the number but do not change the sum It is also clear that the number we found should have the minimum possible length since the longer the numbers without leading zeros the larger they are Numbers of the same length are compared lexicographically that is first by the first digit then by the second and so on This means that the digits in the number must go in sorted order the order of the digits does not affect the sum but does affect the value Let s minimize the length of the number first We need to get the specified sum in as few digits as possible So we should use as large digits as possible Then let s start with the number 9 and add the digits from 8 to 1 to the beginning of the number in turn until the sum of the digits exceeds the specified sum Obviously you can t get an answer for fewer digits Now we minimize the number itself First we must minimize the first digit The first digit is uniquely determined as the difference between the sum of the remaining digits and the required sum So you need to maximize the sum of all digits except the first one which has already been done in the previous paragraph It only remains to correct the first digit and print the answer 
On the number line there are points th of which has integer coordinate and integer weight The coordinates of all points are different and the points are numbered from to A sequence of segments is called if for each pair the condition is satisfied In other words the second segment is strictly inside the first one the third segment is strictly inside the second one and so on For a given number find a system of nested segments such that both ends of each segment are one of given points the sum of the weights of the points used as ends of the segments is For example let The given points are marked in the picture their weights are marked in red their coordinates are marked in blue Make a system of three nested segments weight of the first segment weight of the second segment weight of the third segment sum of the weights of all the segments in the system ,We create a structure that stores for each point its coordinate weight and index in the input data Sort the array by increasing weight The sum of weights of the first points will be minimal so we use them to construct a system of nested segments We save the weights of the first points in the variable and remove the remaining points from the array Now sort the points in ascending order of coordinates and form a system of nested segments such that the endpoints of th segment are and for Thus the endpoints of the first segment are and the endpoints of the th segment are and For each test case we first output then pairs of numbers the indices under which the endpoints of the current segment were written in the input data 
There is a white sheet of paper lying on a rectangle table The sheet is a rectangle with its sides parallel to the sides of the table If you will take a look from above and assume that the bottom left corner of the table has coordinates and coordinate axes are left and bottom sides of the table then the bottom left corner of the white sheet has coordinates and the top right After that two black sheets of paper are placed on the table Sides of both black sheets are also parallel to the sides of the table Coordinates of the bottom left corner of the first black sheet are and the top right Coordinates of the bottom left corner of the second black sheet are and the top right Determine if some part of the white sheet can be seen from the above after the two black sheets are placed The part of the white sheet can be seen if there is at least one point lying the white sheet and of both black sheets ,There are at least two solution to the problem I ll describe both of them The first solution firstly let s notice that the point we search can have non integer coordinates but if the answer exists then there will be the answer such that its point has at most half integer coordinates So let s multiply all coordinates by two and solve the problem with integer coordinates The second thing is that for some there is only two points we need to check top point with this and bottom point with this The same for some So we can iterate over all possible values of and check if the point lies outside of both black rectangles The same with point Then do the same for points and should be in range and should be in range Time complexity is linear on size of the white rectangle The second solution is most tricky but has the better time complexity Let be the intersection of white rectangle and the first black rectangle the same but with the second black rectangle and be the intersection of and Then it is obvious that the answer exists if and doesn t cover the whole white rectangle Time complexity 
Tanya is learning how to add numbers but so far she is not doing it correctly She is adding two numbers and using the following algorithm If one of the numbers is shorter than the other Tanya adds leading zeros so that the numbers are the same length The numbers are processed from right to left that is from the least significant digits to the most significant In the first step she adds the last digit of to the last digit of and writes their sum in the answer At each next step she performs the same operation on each pair of digits in the same place and writes the result to the side of the answer For example the numbers and Tanya adds up as follows calculates the sum of and writes in the answer calculates the sum of and writes the result to the left side of the answer to get calculates the sum of and writes the result to the left side of the answer to get calculates the sum of and writes the result to the left side of the answer to get calculates the sum of and writes the result to the left side of the answer and get As a result she gets You are given two positive integers and Find the number such that by adding and as described above Tanya will get Or determine that no suitable exists ,Let s compute the answer to the array where is the digit at the position in the number we are looking for Let be the position of the last digit in number be the position of the last digit in number Then denote and consider the cases if then the sum of was exactly then if then the sum was greater than and we need to look at the next digit of the number If there isn t one we can t get the answer we ll output Otherwise we recalculate and reduce by one if now and then Otherwise we deduce since we cannot get more than when adding two digits and the cases where have already been considered before After considering the cases reduce and by one and repeat the checks as long as or In the situation where but we will still have uncheked digits of number so we will also output Otherwise we output an array with the answer without leading zeros 
We have a secret array You don t know this array and you have to restore it However you know some facts about this array The array consists of greater than integers The array contains two elements and these elements are for you such that If you sort the array in increasing order such that differences between all adjacent consecutive elements are equal i e It can be proven that such an array always exists under the constraints given below Among all possible arrays that satisfy the given conditions we ask you to restore one which has the maximum element In other words you have to minimize You have to answer independent test cases ,The only fact required to solve this problem is just to notice that the answer array is just an arithmetic progression After that we can fix the first element fix the difference construct the array check if and are in this array and if yes update the answer with This is solution There are faster solutions though Other author s solution is but I didn t want to make this problem harder so I allowed solutions It is obvious that the difference of the progression is some divisor of Let it be Let s add some elements starting from to the left and so on and stop if we reach elements or the next element is less than If we didn t find among these elements just skip this difference it is useless for us Otherwise if we have less than elements let s add and so on until we get elements And then update the answer with the maximum element of the array There is also a solution in with some greedy observations 
Recently Norge found a string consisting of lowercase Latin letters As an exercise to improve his typing speed he decided to type all substrings of the string Yes all of them A substring of is a non empty string For example and are substrings of Shortly after the start of the exercise Norge realized that his keyboard was broken namely he could use only Latin letters out of After that Norge became interested in how many substrings of the string he could still type using his broken keyboard Help him to find this number ,Let s replace all characters of with zeros and ones zero if the character is unavailable and one otherwise Then we have the binary string and we have to calculate the number of contiguous segments of this string consisting only of ones It can be done with two pointers approach If we are staying at the position and its value is zero just skip it Otherwise let s find the leftmost position such that and the th value is zero Then we have to add to the answer the value and set Time complexity 
There is a robot on a coordinate plane Initially the robot is located at the point Its path is described as a string of length consisting of characters Each of these characters corresponds to some move left means that the robot moves from the point to the point right means that the robot moves from the point to the point up means that the robot moves from the point to the point down means that the robot moves from the point to the point The company that created this robot asked you to optimize the path of the robot somehow To do this you can remove of the path But this company doesn t want their customers to notice the change in the robot behavior It means that if before the optimization the robot ended its path at the point then after optimization i e removing some single substring from the robot also ends its path at the point This optimization is a low budget project so you need to remove possible substring to optimize the robot s path such that the endpoint of his path doesn t change It is possible that you can t optimize the path Also it is possible that after the optimization the target path is an empty string i e deleted substring is the whole string Recall that the substring of is such string that can be obtained from by removing some amount of characters possibly zero from the prefix and some amount of characters possibly zero from the suffix For example the substrings of are but not and You have to answer independent test cases ,Formally the problem asks you to remove the shortest cycle from the robot s path Because the endpoint of the path cannot be changed the number of s should be equal to the number of s and the same with and How to find the shortest cycle Let s create the associative array for C which will say for each point of the path the maximum number of operations such that if we apply first operations we will stay at this point Initially this array will contain only the point with the value Let s go over all characters of in order from left to right Let the current point be we applied first operations indexed If this point is in the array already let s try to update the answer with the value and left and right borders with values and correspondingly Then let s assign and continue If there were no updates of the answer the answer is Otherwise you can print any substring you found Time complexity per test case 
 You are given a positive integer number You really love so you want to find the smallest greater than or equal to The positive integer is called if it can be represented as a sum of powers of i e no duplicates of powers of are allowed For example is a is a is a but is a you can t represent it as a sum of distinct powers of is a you can t represent it as a sum of distinct powers of for example the representations are invalid is also a you can t represent it as a sum of distinct powers of for example the representation is invalid Note that there exist other representations of and as sums of powers of but none of them consists of powers of For the given positive integer find such smallest that is a You have to answer independent queries ,As you can see from the example the maximum answer doesn t exceed So we can run some precalculation before all queries which will find all less than The number is if it has no in the ternary numeral system When you read the next query you can increase until you find some precalculated Time complexity is You also can implement the solution which doesn t use any precalculations and just increase each time in each query and checks if the number is inside this loop Then time complexity will be 
 You are given a sequence consisting of integers You are making a sequence of moves During each move you must take either the leftmost element of the sequence or the rightmost element of the sequence write it down and remove it from the sequence Your task is to write down a increasing sequence and among all such sequences you should take the longest the length of the sequence is the number of elements in it For example for the sequence the answer is you take and the sequence becomes then you take the rightmost element and the sequence becomes then you take and the sequence becomes and then you take and the sequence becomes the obtained increasing sequence is ,In this problem the following greedy solution works let s maintain the last element of the increasing sequence we got and on each turn choose the minimum element greater than this last element among the leftmost and the rightmost Such turns will maximize the answer You can find details of implementation in the authors solution 
 There is a deck of cards each of which is characterized by its power There are two types of cards a hero card the power of such a card is always equal to a bonus card the power of such a card is always positive You can do the following with the deck take a card from the top of the deck if this card is a bonus card you can put it of your bonus deck or discard if this card is a hero card then the power of card from your bonus deck is added to his power if it is not empty after that the hero is added to your army and the used bonus discards Your task is to use such actions to gather an army with the maximum possible total power ,To solve it it should be noted that despite the way the deck with bonuses works the order in which they will be applied is not important Then when we meet the hero card we just need to add to the answer the maximum of the available bonuses Constraints allow you to sort the current array with bonus values each time and remove the maximum element 
 You are given a positive integer number You really love so you want to find the smallest greater than or equal to The positive integer is called if it can be represented as a sum of powers of i e no duplicates of powers of are allowed For example is a is a is a but is a you can t represent it as a sum of distinct powers of is a you can t represent it as a sum of distinct powers of for example the representations are invalid is also a you can t represent it as a sum of distinct powers of for example the representation is invalid Note that there exist other representations of and as sums of powers of but none of them consists of powers of For the given positive integer find such smallest that is a You have to answer independent queries ,Let s see the representation of in the ternary numeral system If it has no twos then the answer is Otherwise let be the maximum position of in the ternary representation Then we obviously need to replace it with and add some power of three to the right from it Let be the leftmost position of to the right from We can add and replace all digits from the position to the position with Then the resulting number will be because we replaced all twos with zeros and the minimum because in fact we added only one power of three and this power is the minimum one we could add Time complexity is per query 
 You are given a sequence consisting of integers You are making a sequence of moves During each move you must take either the leftmost element of the sequence or the rightmost element of the sequence write it down and remove it from the sequence Your task is to write down a increasing sequence and among all such sequences you should take the longest the length of the sequence is the number of elements in it For example for the sequence the answer is you take and the sequence becomes then you take the rightmost element and the sequence becomes then you take and the sequence becomes and then you take and the sequence becomes the obtained increasing sequence is ,The solution of the previous problem works for this problem also Almost works What if the leftmost element is equal the rightmost element Which one should we choose Let s analyze it If we take the leftmost element then we will take any other element from the right and vice versa So we can t meet this case more than once because after meeting it once we can take only leftmost elements or only rightmost elements The only thing we should understand is which of these two cases is better take the leftmost element or take the rightmost element To do it we can just iterate from left to right and calculate the number of elements we can take if we will take the leftmost element each time If we cannot take the current element then just stop the cycle And do the same thing for the rightmost element and take the best case 
 There is a deck of cards each of which is characterized by its power There are two types of cards a hero card the power of such a card is always equal to a bonus card the power of such a card is always positive You can do the following with the deck take a card from the top of the deck if this card is a bonus card you can put it of your bonus deck or discard if this card is a hero card then the power of card from your bonus deck is added to his power if it is not empty after that the hero is added to your army and the used bonus discards Your task is to use such actions to gather an army with the maximum possible total power ,To solve it it should be noted that despite the way the deck with bonuses works the order in which they will be applied is not important Then when we meet the hero card we just need to add to the answer the maximum of the available bonuses Constraints make you use structures such as a priority queue to quickly find and extract the maximum 
You are given three arrays and Initially array consists of elements arrays and are empty You are performing the following algorithm that consists of two steps Step while is not empty you take from and move it of array If currently has odd length you can choose place the element from to the left or to the right of the middle element of As a result becomes empty and consists of elements Step while is not empty you take from and move it of array If currently has even length you can choose which of two middle elements to take As a result becomes empty and now consists of elements Refer to the Note section for examples Can you make array sorted in non decreasing order ,Let s look at elements and After the first step they will always move to positions and it s up to you to choose and or vice versa because all remaining for will be placed between and After the second step elements and will always be placed at positions and it s also up to you to decide the exact order because it s easy to see that you first take all for and only after that and In other words elements and are moved to positions and We can analogically prove that each pair is moved to a pair of positions you first take all elements for and place them at positions and then you move and finally you move all remaining elements from between and Step just does everything in reverse order to step It means that array is basically array but you can swap elements in pairs for And to make sorted we can try to sort each pair and check is it enough to sort the whole array or not 
You are given a string consisting of lowercase Latin letters It is guaranteed that for some integer The string is called if of the following three conditions is satisfied The length of is and it consists of the character i e The length of is greater than the first half of the string consists of only the character i e and the second half of the string i e the string is a string The length of is greater than the second half of the string consists of only the character i e and the first half of the string i e the string is a string For example is is In one move you can choose one index from to and replace with any lowercase Latin letter any character from to Your task is to find the minimum number of moves required to obtain an string from i e for It is guaranteed that the answer always exists You have to answer independent test cases Another example of an string is as follows Consider the string It is an string because the second half of the string consists of only the character the first half of the string is string because the second half of the string consists of only the character the first half of the string is string because the first half of the string consists of only the character the second half of the string is string ,Consider the problem in 0 indexation Define the function calc l r c which finds the minimum number of changes to make the string s l dots r Let mid frac l r 2 Then let cnt l frac r l 2 count s l dots mid c calc mid r c 1 and cnt r frac r l 2 count s mid dots r c calc l mid c 1 where count s c is the number of occurrences of the character c in s We can see that cnt l describes the second condition from the statement and cnt r describes the third one So calc l r c returns min cnt l cnt r except one case When r l 1 we need to return 1 if s l ne c and 0 otherwise This function works in O n log n each element of s belongs to exactly log n segments like segment tree You can get the answer if you run calc 0 n a 
You are given an array consisting of integers The array is sorted if You want to make the array sorted by applying the following operation choose an integer then for every replace by Find any value of that will make the array sorted or report that there is no such value ,What does it actually mean for an array to be sorted That means and and so on For each pair of adajacent elements let s deduce which values put them in the correct order Any value of that puts all pairs in the correct order will be the answer Consider any and and solve the inequality If then any value of works Let be smaller than If is smaller than or equal to then the inequality becomes Thus they don t change their order and any works If is greater than or equal to then the inequality becomes Thus they always change their order and none of work If is between and then the inequality becomes Thus they only remain in the same order for any integer such that In union that tells us that all values of that work for such a pair are The similar analysis can be applied to which results in the required being for such pairs Finally how to find out if some value of passes all conditions Among all conditions of form in order for some to work it should be less than or equal to even the smallest of them Similarly among all conditions of form in order for some to work it should be greater than or equal to even the largest of them Thus take the minimum over the pairs of one type Take the maximum over the pairs of another type If two resulting values are contradictory then there is no answer Otherwise any value inside the resulting range of works Overall complexity per testcase 
Polycarp was given an array of of integers He can perform the following operation with the array no more than times Polycarp selects the index and adds the value to of its neighbors More formally Polycarp adds the value of to or to if such a neighbor does not exist then it is impossible to add to it After adding it Polycarp removes the th element from the array During this step the length of is decreased by The two items above together denote one single operation For example if Polycarp has an array then it can perform the following sequence of operations with it Polycarp selects and adds the value to th element Polycarp selects and adds the value to th element Polycarp selects and adds the value to th element Polycarp selects and adds the value to th element Note that Polycarp could stop performing operations at any time Polycarp wondered how many minimum operations he would need to perform to make all the elements of equal i e he wants all are equal to each other ,Let k be the number of operations performed by Polycarp Let s see how to check if k is the answer Let s denote by s the sum of numbers in the array a Note that after each operation s does not change Since we know that after k operations all elements must be the same and the sum of the numbers in the array does not change then each of the remaining elements must be equal to frac s n k Let s check if it is possible to perform k operations so that at the end all elements are equal to frac s n k Note that the process described in the condition is equivalent to the following process Choose a set of n k 1 indices i 1 i 2 dots i n k 1 1 i 1 i 2 dots i n k i n k 1 n 1 partitions Create a new array b of n k elements where b j sum limits t i j i j 1 1 b t For example the array a of 8 elements after 4 operations could turn into an array b a 1 a 2 a 3 a 4 a 5 a 6 a 7 a 8 In this case the set of indices is i 1 5 6 8 9 Then to check if k is the answer it is necessary to split the a array into n k subarrays in which the sum of all elements is equal to frac s n k Such a check can be implemented greedily in mathcal O n It is enough to go through the array from left to right and take an element into the current subarray until the sum in it exceeds frac s n k The resulting solution works in mathcal O n cdot sigma s or mathcal O n 2 where sigma s is the number of divisors s 
We guessed some integer number You are given a list of its divisors means that there are in the list Your task is to find the minimum possible integer that can be the guessed number or say that the input data is contradictory and it is impossible to find such number You have to answer independent queries ,Suppose the given list of divisors is a list of divisors of some in other words suppose that the answer exists Then the minimum divisor multiplied by maximum divisor should be This is true because if we have a divisor we also have a divisor Let s sort all divisors and let Now we need to check if all divisors of except and are the permutation of the array check that our answer is really correct We can find all divisors of in sort them and compare with the array If arrays are equal then the answer is otherwise the answer is 
Polycarp likes arithmetic progressions A sequence is called an arithmetic progression if for each the value is the same For example the sequences and are arithmetic progressions but and are not It follows from the definition that any sequence of length one or two is an arithmetic progression Polycarp found some sequence of positive integers He agrees to change each element by at most one In the other words for each element there are exactly three options an element can be decreased by an element can be increased by an element can be left unchanged Determine a minimum possible number of elements in which can be changed by exactly one so that the sequence becomes an arithmetic progression or report that it is impossible It is possible that the resulting sequence contains element equals ,If we can print because each such sequence is an arithmetic progression Note that an arithmetic progression is uniquely determined by the first two terms So we should brute from to the change of the first element of the given sequence and from to the change of the second element of the given sequence Then and Also we will store the number of changed elements in the sequence Initially Now we need to iterate through the sequence from the third element to th Let current element in the position It should be equals to If then such arithmetic progression is unreachable Else if we should increase on one After we considered all elements we should update the answer with the value of if for all it was true that 
You are given two integers and In one turn you can do one of the following operations Take an integer and and replace with Take an integer and and replace with Your goal is to make equal to using exactly turns For example the numbers and can be made equal in moves divide by divide by divide by divide by For the given numbers and determine whether it is possible to make them equal using exactly turns ,Let s denote for the maximum number of moves for which the numbers and can be made equal It is easy to understand that the number of moves is maximum when and each time we divided or by a prime number That is sum of exponents of prime divisors of sum of exponents of prime divisors of Let s denote by the minimum number of moves for which the numbers and can be made equal Consider a few cases If then If or then Otherwise then Then the answer is possible in the following cases and and or and 
You are given a correct solution of the sudoku puzzle If you don t know what is the sudoku you can read about it here The picture showing the correct sudoku solution Blocks are bordered with bold black color Your task is to change elements of this field i e choose some and change the number at the position to any other number in range to make it The is the field in which Any number in this field is in range each row contains at least two equal elements each column contains at least two equal elements each block you can read what is the block in the link above contains at least two equal elements It is guaranteed that the answer exists You have to answer independent test cases ,Well if we replace all occurrences of the number with the number then the initial solution will be anti sudoku It is easy to see that this replacement will make exactly two copies of in every row column and block There are also other correct approaches but I found this one the most pretty 
You are given an array of integers and another integer such that You have to perform operations with this array In one operation you have to choose two elements of the array let them be and they can be equal or different but remove them from the array and add to your where is the maximum integer not exceeding Initially your is After you perform exactly operations you add all the remaining elements of the array to the Calculate the minimum possible you can get ,It s kinda obvious that we have to choose the greatest elements of the array as the denominators in the operations suppose we haven t chosen one of them but have chosen a lesser element as a denominator if we swap them the total score won t decrease It is a bit harder to prove that the numerators of the fractions should be the next greatest elements the elements on positions from to in sorted order It can be proved as follows each fraction we will get in such a way rounds down to either or to and if we choose a lesser element as a numerator we can decrease a fraction from to but we ll increase the sum of elements that remain in the array so this is not optimal All that s left is to pair the numerators and denominators A fraction with numerator equal to denominator rounds down to any other fraction will round down to so our goal is to minimize the number of fractions having the numerator equal to the denominator It can be done by pairing the numbers into fractions in the following way assuming is sorted So the solution of the problem is the following sort the array then calculate 
You are given a string consisting of exactly characters and each character is either or Such strings are called Your task is to in this string with other characters to obtain a ternary string ternary string is a ternary string such that the number of characters in this string is equal to the number of characters and the number of characters and obviously is equal to the number of characters Among all possible ternary strings you have to obtain the lexicographically alphabetically smallest Note that you can neither remove characters from the string nor add characters to the string Also note that you can replace the given characters only with characters and It is that the answer exists ,Let s count how many characters and we have in the string and store it in the array Also let s count our goal array Firstly the array is The main idea of this problem is a pretty standard lexicographically greedy approach We go from left to right and try to place the minimum possible character at the current position in such a way that placing this character is not breaking conditions of our problem How can we apply this approach to this problem Firstly let s define a function What does the value of this function mean It means the number of replacements we need to reach from Let at the beginning of the program This value means the minimum number of replacements to obtain some balanced ternary string Let s maintain the variable which initially is and means the number of replacements we already made So we iterate over all positions from to Firstly let s decrease So the array maintains the current amount of characters on suffix of the string Now let s iterate over characters from to and try to place every character If the current character is needed then let s decrease and if the number of replacements will still be minimum possible after such replacement then let s place this character set and go to the next position This will form lexicographically minimum possible answer with minimum number of replacements There is another simpler solution from PikMike you can call him to explain it I just will add his code to the editorial 
You are given a binary string of length i e a string consisting of characters and In one move you can swap two adjacent characters of the string What is the lexicographically minimum possible string you can obtain from the given one if you can perform than moves It is possible that you do not perform any moves at all Note that you can swap the same pair of adjacent characters with indices and arbitrary possibly zero number of times Each such swap is considered a separate move You have to answer independent test cases ,This problem has a very standard solution let s take the leftmost zero place it as left as possible and solve the problem without this zero and all operations we spent But we should do it fast Let s go from left to right and carry the number of ones on the prefix If we meet let s just increase and continue the algorithm It is obvious that if we meet we need to make exactly swaps to place it before all ones If we can do it let s just add to the answer decrease by and continue Otherwise this zero will be between some of these ones and we can place it naively In this case the suffix of the string will not change If after all operations we didn t meet the case above let s add all ones to the suffix of the resulting string Time complexity 
You are given a binary string consisting of zeros and ones Your task is to divide the given string into the number of in such a way that of the string belongs to exactly and each subsequence looks like or i e the subsequence should not contain two adjacent zeros or ones Recall that a subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements For example subsequences of are but not and You have to answer independent test cases ,Let s iterate over all characters of from left to right maintaining two arrays and where stores indices of all subsequences which end with and stores indices of all subsequences which end with If we met then the best choice is to append it to some existing subsequence which ends with If there are no such sequences we need to create new one which ends with Otherwise we need to convert one of sequences to sequence The same works with characters So when we don t need to create the new sequence we try to don t do that And values in arrays and help us to determine the number of sequence we assign to each character And also there is a cute proof of this solution from Gassa let be the difference between the number of and the number of on the prefix of of length We claim that the answer is and let s show why is it true Let s build a function on a plane with points Then we can match each between and with some subsequence 
You have a stripe of checkered paper of length Each cell is either white or black What is the minimum number of cells that must be recolored from white to black in order to have a segment of consecutive black cells on the stripe If the input data is such that a segment of consecutive black cells already exists then print ,To obtain a segment of cells of black color we need to paint all the white cells of the segment black Then go through all the segments of length there are only and choose such a segment among them that the number of white cells on it is minimal You can quickly find out the number of white cells in the segment by prefix sums 
You are given an array of integers of length The elements of the array can be either different or the same Each element of the array is colored either blue or red There are no unpainted elements in the array One of the two operations described below can be applied to an array in a single step either you can select any blue element and decrease its value by or you can select any red element and increase its value by Situations in which there are no elements of some color at all are also possible For example if the whole array is colored blue or red one of the operations becomes unavailable Determine whether it is possible to make or more steps such that the resulting array is a permutation of numbers from to In other words check whether there exists a sequence of steps possibly empty such that after applying it the array contains in some order all numbers from to inclusive each exactly once ,Note the following fact if a number in a permutation was obtained from a blue number and a number in a permutation was obtained from a red number and then by decreasing the blue number and increasing the red number exactly times each we will obtain the same permutation in which the two numbers have swapped places Thus if a permutation can be obtained at all some permutation can be obtained by making all the red numbers equal to and the blue ones equal to where is the total count of red numbers Now consider separately two red numbers and such that If is produced by increasing and is produced by increasing and in the same time then and the following is also true and So we just showed that if an answer exists it also exists if greater numbers are produced by greater values from the input The same holds for the blue numbers Let us sort all elements by the key where the color of th element and blue comes before red It remains to check that for any from to we can get the number from the th element of the obtained sorted array To do this we iterate through it and check that either and so it can be reduced to or symmetrically and 
Maksim has objects and boxes each box has size exactly Objects are numbered from to in order from left to right the size of the th object is Maksim wants to pack his objects into the boxes and he will pack objects by the following algorithm he takes one of the empty boxes he has goes from left to right through the objects and if the th object fits in the current box the remaining size of the box is greater than or equal to he puts it in the box and the remaining size of the box decreases by Otherwise he takes the new empty box and continues the process above If he has no empty boxes and there is at least one object not in some box then Maksim cannot pack the chosen set of objects Maksim wants to know the maximum number of objects he can pack by the algorithm above To reach this target Your task is to say the maximum number of objects Maksim can pack in boxes he has Each time when Maksim tries to pack the objects into the boxes he will make empty all the boxes he has before do it and the relative order of the remaining set of objects will not change ,The first solution is some kind of a straight forward understanding the problem Let s do binary search on the answer So our problem is to find the smallest such that the suffix of the array starting from the position can be packed in boxes It is easy to see that if we can do it for some then we always can do it for And to find the answer for the fixed we have to simulate the process described in the problem statement starting from the position Okay this is solution The second solution is more interesting than the first one The approach is to reverse the initial array simulate the process from the first position of reversed array and then all the objects we can pack are in the best answer and there is no better answer at all Why it works Let s take a look on the last box in the best answer if we will go from left to right in the initial array Let objects in this box be What do we see So all these objects are fit in the last box obviously Now if we will iterate over objects from right to left these objects will fit also It means that we cannot do worse by such a transform reversing at least for the last box But what will happen if we can put some of the previous objects in this box Well it will not make worse for this box but what about next boxes previous boxes in straight notation Let objects in the penultimate box be What do we see These objects are fit in this box obviously again What will happen if we will put in the last box one or more objects of this box Then the border of objects which we will put in it will not increase because we the number of object in this box So we can see that for previous boxes this condition is also satisfied So we can solve the problem with this approach Time complexity of this solution is 
Polycarp wants to buy shovels The shop sells packages with shovels The store has types of packages the package of the th type consists of exactly shovels The store has an infinite number of packages of each type Polycarp wants to choose type of packages and then buy several one or more packages of this type What is the smallest number of packages Polycarp will have to buy to get exactly shovels For example if and then Polycarp will buy packages of shovels Help Polycarp find the minimum number of packages that he needs to buy given that he will buy exactly shovels in total the sizes of packages he will buy are all the same and the number of shovels in each package is an integer from to inclusive ,If Polycarp buys packages of shovels and gets exactly shovels in total then that is and are divisors of Then the problem reduces to the following you need to find the maximum divisor of the number not greater than To do this iterate over all the numbers from to inclusive and check whether is divisible by If so then and are both divisors of and you can use them to try to improve the answer 
There are candies in a candy box The type of the th candy is You have to prepare a gift using some of these candies with the following restriction the numbers of candies of each type presented in a gift should be all distinct i e for example a gift having two candies of type and two candies of type is bad It is also possible that of some types will be taken to a gift Your task is to find out the possible size of the single gift you can prepare using the candies you have You have to answer independent queries ,Let s calculate the array where is the number of candies of the th type Let s sort it in non ascending order Obviously now we can take because this is the maximum number of candies of some type in the array Let be the last number of candies we take Initially it equals and the answer is initially the same number Then let s iterate over all values of in order from left to right If the current number is greater than or equal to the last taken number of candies then we cannot take more candies than because we iterating over values of in non ascending order so let s increase answer by and set Otherwise and we can take all candies of this type increase the answer by and set 
The round carousel consists of figures of animals Figures are numbered from to in order of the carousel moving Thus after the th figure the figure with the number follows Each figure has its own type the type of the animal corresponding to this figure the horse the tiger and so on The type of animal of the th figure equals You want to color each figure in one of the colors You think that it s boring if the carousel contains two different figures with the distinct types of animals going one right after another and colored in the same color Your task is to color the figures in such a way that the number of distinct colors used is the minimum possible and there are no figures of the different types going one right after another and colored in the same color If you use exactly distinct colors then the colors of figures should be denoted with integers from to ,The answer to this problem is at most Let s prove it by construction Firstly if all are equal then the answer is Otherwise there are at least two different values in the array so the answer is at least If is even then the answer is always because you can color figures in the following way If is odd then consider two cases The first case is when some pair of adjacent figures have the same type Then the answer is because you can merge these two values into one and get the case of even Otherwise all pairs of adjacent figures have different types and if you consider this cyclic array as a graph cycle of length then you can notice that it isn t bipartite so you need at least colors to achieve the answer color all vertices in such a way that any two adjacent vertices have different colors And the answer looks like 
There are Christmas trees on an infinite number line The th tree grows at the position All are guaranteed to be distinct Each point can be either occupied by the Christmas tree by the human or not occupied at all Non integer points cannot be occupied by anything There are people who want to celebrate Christmas Let be the positions of people note that all values should be and all should be You want to find such an arrangement of people that the value is the minimum possible in other words the sum of distances to the nearest Christmas tree for all people should be minimized In other words let be the distance from the th human to the nearest Christmas tree Then you need to choose such positions that is the minimum possible ,In this problem we first need to consider all points adjacent to at least one Christmas tree then all points at the distance two from the nearby Christmas tree and so on What it looks like Yes well known multi source bfs Let s maintain a queue of positions and the set of used positions and the distance to each vertex of course In the first step we add all positions of the Christmas tree with a zero distance as initial vertices Let the current vertex is If this is the Christmas tree then just add and to the queue if these vertices aren t added already and continue Otherwise increase the answer by and add to the array of positions of people When the length of this array reaches interrupt bfs and print the answer Don t forget about some special cases as using in Java or using in C because this can lead to the quadratic complexity Time complexity 
There are kids numbered from to dancing in a circle around the Christmas tree Let s enumerate them in a clockwise direction as all these numbers are from to and are distinct so is a permutation Let the next kid for a kid be kid if and otherwise After the dance each kid remembered two kids the next kid let s call him and the next kid for Each kid told you which kids he she remembered the kid remembered kids and However the order of and can differ from their order in the circle You have to restore the order of the kids in the circle using this information If there are several answers you may print any It is guaranteed that at least one solution exists ,Let s write a function which will try to restore the circle if kid with number comes right after kid with number If comes right after then we can determine the number of kid who is next to kid So now we have comes right after comes right after Let s determine kid who is next to kid If we repeat this operation times then we can the answer if comes right after But it can be wrong so we have to check that our answer corresponds to the input So if we have this function we can apply it two times to determine the correct answer Just call and 
Polycarp often uses his smartphone He has already installed applications on it Application with number takes up units of memory Polycarp wants to free at least units of memory by removing some applications Of course some applications are more important to Polycarp than others He came up with the following scoring system he assigned an integer to each application regular application important application According to this rating system his phone has convenience points Polycarp believes that if he removes applications with numbers then he will free units of memory and lose convenience points For example if then Polycarp can uninstall the following application sets not all options are listed below applications with numbers and In this case it will free units of memory and lose convenience points applications with numbers and In this case it will free units of memory and lose convenience points applications with numbers and In this case it will free memory units and lose convenience points Help Polycarp choose a set of applications such that if removing them will free at least units of memory and lose the minimum number of convenience points or indicate that such a set does not exist ,Let s say we remove applications with and applications with Obviously among all the applications with it was necessary to take maximum in memory so we will clear the most memory Let s split all the applications into two arrays with and and sort them Then you need to take a prefix from each array Let s iterate over which prefix we take from the first array For it we can uniquely find the second prefix we remove applications until the sum exceeds If we now increase the first prefix by taking a new application then we don t need to take any applications in the second array This means that when the first prefix is increased the second one can only decrease To solve the problem you can use the two pointer method 
A sequence of non negative integers is called if for all from to all ones of binary representation in are in the places of ones of binary representation in in other words where denotes bitwise AND If then the sequence is considered as well For example the following four sequences are growing in binary it s in binary it s in binary it s in binary it s The following three sequences are non growing in binary it s in binary it s in binary it s Consider two sequences of non negative integers and Let s call this pair of sequences if the sequence is where denotes bitwise XOR You are given a sequence of integers Find the lexicographically minimal sequence such that sequences and are co growing The sequence is lexicographically smaller than the sequence if there exists such that for any but ,In order to build lexicographically minimal co growing with sequence it is enough to build its elements iteratively beginning from and minimizing the th element assuming that have already been found Assign According to the statement all elements of the sequence are non negative so cannot be less than zero It turns out that is the minimal possible first element The existence of an answer with follows from the construction algorithm described below Let s use mathematical induction and construct under the assumption that all the previous elements of the sequence have already been constructed In order to satisfy the condition for the growth of the final sequence the number must contain one bits at all places but not necessarily limited to them on which there are one bits in the number Let s denote for and find out what bits can be in to satisfy this condition If in stands bit then independently from in at the same spot we can place any bit because there is no limit on the corresponding bit in If in stands bit and in then the corresponding bit in should be equal so that in the corresponding bit also equals one If in and in stands bit then in should be bit at the corresponding place for the same reasons The bit transformation described above can be given by the expression Indeed this expression gives us bit one at the fixed position if and only if at that place in stands bit and in stands bit For the full solution it remains only to apply this formula in a loop from to 
Polycarp has coins the value of the th coin is It is guaranteed that all the values are integer powers of i e for some integer number Polycarp wants to know answers on queries The th query is described as integer number The answer to the query is the minimum number of coins that is necessary to obtain the value using some subset of coins Polycarp can use only coins he has If Polycarp can t obtain the value the answer to the th query is The queries are independent the answer on the query doesn t affect Polycarp s coins ,We can solve the problem by the following way firstly for each power of 2 let s calculate the number of coins with the value equals this degree Let s call it cnt It is obvious that we can obtain the value b j greedily because all less values of coins are divisors of all greater values of coins Now let s iterate over all powers of 2 from 30 to 0 Let s deg be the current degree We can take min lfloor frac b j 2 deg rfloor cnt deg coins with the value equals 2 deg Let it be cur Add cur to the answer and subtract 2 deg cdot cur from b j If after iterating over all powers b j still be non zero print Otherwise print the answer Overall complexity O n q log maxAi 
You are given some text and a set of strings In one step you can choose any occurrence of any string in the text and color the corresponding characters of the text in red For example if and you can get or in one step You want to color all the letters of the text in red When you color a letter in red again it stays red In the example above three steps are enough Let s color in red we get Let s color in red we get Let s color in red we get Each string can be applied any number of times or not at all Occurrences for coloring can intersect arbitrarily Determine the minimum number of steps needed to color all letters in red and how to do it If it is impossible to color all letters of the text in red output ,The first step is to find the word that covers the maximum length prefix If there is no such word we cannot color the string Then go through the positions inside the found prefix and find the next word which is a tweak of has the maximal length and ends not earlier than the previous found word and not later than the text If there is no such word it is impossible to color After the second word is found similarly continue looking for the next ones 
There are left boots and right boots Each boot has a color which is denoted as a lowercase Latin letter or a question mark Thus you are given two strings and both of length The character stands for the color of the th left boot and the character stands for the color of the th right boot A lowercase Latin letter denotes a specific color but the question mark denotes an indefinite color Two specific colors are if they are exactly the same An indefinite color is with any specific or indefinite color For example the following pairs of colors are compatible and The following pairs of colors are compatible and Compute the maximum number of pairs of boots such that there is one left and one right boot in a pair and their colors are compatible Print the maximum number of such pairs and the pairs themselves A boot can be part of at most one pair ,Use greedy approach in this problem At first match such pairs that colors are exactly the same and they are specific not indefinite After it match each indefinite colored left boot if any with any specific colored right boot Possibly some indefinite colored left boots stay unmatched Similarly match each indefinite colored right boot if any with any specific colored left boot And finally match indefinite colored left and right boots if any 
You are given an array consisting of positive integers Let s call a concatenation of numbers and the number that is obtained by writing down numbers and one right after another without changing the order For example a concatenation of numbers and is a number Count the number of ordered pairs of positions in array such that the concatenation of and is divisible by ,Let s rewrite concatenation in a more convenient form where is the number of digits in Then this number is divisible by if and only if the sum of and is either or Let s calculate arrays of remainders For each adds to That s the first term of the sum Now iterate over the second term for and for you binary search for in The number of its occurrences should be added to answer You also might have calculated some pairs iterate over them and subtract them naively Overall complexity 
You are given an array consisting of integers it is guaranteed that is even i e divisible by All does not exceed some integer Your task is to replace the number of elements replacement is the following operation choose some index from to and replace with some integer in range to satisfy the following conditions after all replacements all are positive integers not greater than for all from to the following equation is true where should be for all pairs of elements You have to answer independent test cases ,It is obvious that if we fix the value of x then there are three cases for the pair of elements We don t need to change anything in this pair we can replace one element to fix this pair we need to replace both elements to fix this pair The first part can be calculated easily in O n k we just need to create the array of frequencies cnt where cnt x is the number of such pairs a i a n i 1 that a i a n i 1 x The second part is a bit tricky but still doable in O n k For each pair let s understand the minimum and the maximum sum we can obtain using at most one replacement For the i th pair all such sums belong to the segment min a i a n i 1 1 max a i a n i 1 k Let s make 1 on this segment using prefix sums make 1 in the left border 1 in the right border plus one and then just compute prefix sums on this array Let this array be pref Then the value pref x tells the number of such pairs that we need to replace element in this pair to make it sum equals x And the last part can be calculated as frac n 2 pref x So for the sum x the answer is pref x cnt x frac n 2 pref x cdot 2 We just need to take the minimum such value among all possible sums from 2 to 2k There is another one solution that uses scanline not depends on k and works in O n log n but it has no cool ideas to explain it here anyway the main idea is almost the same as in the solution above 
You are given a number and an array obtained according to the following algorithm some array was guessed array was written to array i e The th element of the array is the sum of the numbers in the array i e The th element of the array was written some number i e The array was shuffled For example the array it could be obtained in the following ways and and For the given array find any array that could have been guessed initially ,What is the sum of all the elements in b This is twice the sum of all the elements in a x Denote by B the sum of all the elements of b Let s iterate over which of the array elements was added as the sum of the elements a let s denote for a Then x B 2 cdot A It remains to check that the element x is present in the array b this can be done using a hash table or a binary search tree 
You are given an array consisting of integers You have to find array of length such that you can cut out maximum number of copies of array from array Cutting out the copy of means that for each element of array you have to find in and remove it from If for some you cannot find such element in then you cannot cut out one more copy of The both arrays can contain duplicate elements For example if and then one of the possible answers is This array can be cut out times To cut out the first copy of you can use the elements use the highlighted elements After cutting out the first copy of the array can look like To cut out the second copy of you can use the elements After cutting out the second copy of the array will be Your task is to find such array that you can cut out the copy of from maximum number of times If there are multiple answers you may choose of them ,Let s solve the problem using binary search by the answer It is easy to see that if we can construct the answer for some number of copies then we also can do it for The only thing we need is to write the function which will say can we cut off copies of some array from or not Let s imagine copies of string as a matrix of size Obviously each row of this matrix should be equal to each other row Let s fill not rows but columns of this matrix For some element of we can easy notice that we can take exactly columns containing this element where is the number of such elements in So overall number of columns we can fill in this matrix will be If this value is greater than or equal to then is true otherwise it is false It is easy to construct the answer using all things we described above Overall complexity is where is the size of the alphabet 
You are given a positive integer In one move you can increase by one i e make Your task is to find the minimum number of moves you need to perform in order to make the sum of digits of be less than or equal to You have to answer independent test cases ,Firstly let s check if the initial fits the conditions If it is print and continue Otherwise let s solve the problem greedily At first let s try to set the last digit to zero Let We need exactly moves to do that Let s add this number to and to the answer and check if the current fits the conditions If it isn t let s try to set the previous last digit to zero Let Then we need moves to do that Let s add this number to and to the answer and check if the current fits the conditions If it isn t repeat the same with the third digit and so on This cycle can do no more than iterations And we can fing the sum of digits of in at most iterations too decimal logarithm of So the total time complexity is 
You are given a string consisting of lowercase Latin letters and queries for this string Recall that the substring of the string is the string For example the substrings of are but not and There are two types of queries is lowercase Latin letter replace with set calculate the number of distinct characters in the substring ,Let s store for each letter all positions in which it appears in some data structure We need such a data structure that can add remove and find the next element greater than or equal to our element fast enough Suddenly this data structure is again in C When we meet the first type query let s just modify two elements of corresponding sets one remove one add When we meet the second type query let s iterate over all letters If the current letter is in the segment then the first element greater than or equal to in the corresponding set should exist and be less than or equal to If it is so let s increase the answer by one After iterating over all letters just print the answer Time complexity when is the size of the alphabet 
There are districts in the town the th district belongs to the th bandit gang Initially no districts are connected to each other You are the mayor of the city and want to build two way roads to connect all districts two districts can be connected directly or through other connected districts If two districts belonging to the same gang are connected with a road this gang will revolt You don t want this so your task is to build two way roads in such a way that all districts are reachable from each other possibly using intermediate districts and of directly connected districts belong to or determine that it is impossible to build roads to satisfy all the conditions You have to answer independent test cases ,If all districts belong to the same gang then the answer is Otherwise the answer is always yeah as in the previous problem How to construct it Let s choose the first root as the district and connect all such districts that to the district So all disconnected districts that remain are under control of the gang Let s find any district that and just connect all remaining districts of the gang to this district This district always exists because we have at least two different gangs and it is connected to the remaining structure because its gang is not So all conditions are satisfied 
You have a garland consisting of lamps Each lamp is colored red green or blue The color of the th lamp is and colors of lamps in the garland You have to recolor some lamps in this garland recoloring a lamp means changing its initial color to another in such a way that the obtained garland is A garland is called if any two adjacent consecutive lamps i e such lamps that the distance between their positions is have distinct colors In other words if the obtained garland is then for each from to the condition should be satisfied Among all ways to recolor the initial garland to make it you have to choose one with the number of recolored lamps If there are multiple optimal solutions print of them ,Let s divide the initial string into blocks of consecutive equal letters For example if we have the string then have blocks the first block is two letters the second one is three letters the third one is two letters and the last one is four letters Let s see at the current block let it has the length and consider two cases The first case is when this block has odd length Then it seems like So what is the minimum number of recolors we need to make this block correct It is Why can we always make this block correct for such number of recolors Because we can recolor all at even positions to any which differs from So our block will be look like The second case is when this block has even length Then it seems like where is the next block letter if the next block exists because the last block doesn t have the next one What is the minimum number of recolors in this case It is How can we recolor this block to make it correct Let s recolor all at even positions again to any which differs from and differs from So our block will be look like So all we have to do is to iterate over all blocks from left to right and apply the algorithm above to recolor them 
Polycarp likes to play with numbers He takes some integer number writes it down on the board and then performs with it operations of the two kinds divide the number by must be divisible by multiply the number by After each operation Polycarp writes down the result on the board and replaces by the result So there will be numbers on the board after all You are given a sequence of length the numbers that Polycarp wrote down This sequence is given in arbitrary order i e the order of the sequence can mismatch the order of the numbers written on the board Your problem is to rearrange reorder elements of this sequence in such a way that it can match possible Polycarp s game in the order of the numbers written on the board I e each next number will be exactly two times of the previous number or exactly one third of previous number It is guaranteed that the answer exists ,Let be the maximum integer such that is divisible by Our problem is to rearrange the given array in such a way that easy to see it if we look at our operations if it looks like then for each the next inequality will be satisfied And if then numbers must be placed in increasing order because of our operations So we can store an array of pairs when Then if we sort it in lexicographical order we can just print the second elements of the sorted array 
You are given an array of positive integers Make the product of all the numbers in the array that is divisible by You can perform the following operation as many times as you like select an arbitrary index and replace the value with You cannot apply the operation repeatedly to a single index In other words all selected values of must be different Find the smallest number of operations you need to perform to make the product of all the elements in the array divisible by Note that such a set of operations does not always exist ,Let s notice that if we multiply the numbers then the power of two of the product is equal to the sum of the powers of two in each of the numbers Let s calculate the initial sum of the powers of twos in the product This can be done as follows let s take the element and divide it by as long as we can while remembering to increase our counter by the number of occurrences of a power of two Now let s move on to operations and note that choosing the index will increase the degree of occurrence of two by a fixed number that is it does not matter when to apply this operation Choosing an index will increment the counter by a number such that is divisible by but not by you can find this again by dividing by while we can Since we want to minimize the number of operations used at each moment of time we will try to use an index that increases the counter by the largest number To do this it is enough to sort the indices by this index of increase and take them greedily from the largest increase to the smallest We get the solution in 
You are given an array consisting of integers and a positive integer It is guaranteed that is a divisor of In a single move you can choose any position between and and increase by Let s calculate the number of elements having remainder when divided by In other words for each remainder let s find the number of corresponding elements in with that remainder Your task is to change the array in such a way that Find the minimum number of moves to satisfy the above requirement ,For each from to find all elements of the array that are congruent to modulo and store their indices in a list Also create a vector called and let be We have to cycle from to twice For each from to if there are in list too many i e elements congruent to modulo remove the extra elements from this list and add them to If instead there are too few i e elements congruent to modulo remove the last few elements from the vector For every removed index increase by After doing so after two passes we print the total increase and the updated array It is obvious that after the first iterations every list will have size at most and after more iterations all lists will have the same sizes It can be easily proved that this algorithm produces an optimal answer The time complexity is 
You are given an array consisting of integers You can perform the following operations arbitrary number of times possibly zero Choose a pair of indices such that indices and are adjacent and set Choose a pair of indices such that indices and are adjacent and set The value means the absolute value of For example Your task is to find the minimum number of operations required to obtain the array of equal elements and print the order of operations to do it ,Let s find the most frequent element in the array using the array of frequencies of course Let this element be If we will see the operations more carefully we can see that the part of these operations means if then this operation is otherwise it is Now let s consider the number of operations in the optimal answer It is obvious that we need at least operations to equalize all the elements And it is also obvious that we can always do it with such operations we have How to restore the answer There is an easy way to do it find the first occurrence of Let it be Then let s go from to and set each element to the next element element at the position to to and so on And don t forget to print right type of operation Then let s go from left to right from to and if the th element don t equal to then set it to th element using right operation 
During their New Year holidays Alice and Bob play the following game using an array of integers Players take turns Alice moves first Each turn a player chooses any element and removes it from the array If Alice chooses then she adds it to her score If the chosen value is odd Alice s score does not change Similarly if Bob chooses then he adds it to his score If the chosen value is even then Bob s score does not change If there are no numbers left in the array then the game ends The player with the highest score wins If the scores of the players are equal then a draw is declared For example if and then the game could go as follows there are other options On the first move Alice chooses and get two points Her score is now The array is now On the second move Bob chooses and get five points His score is now The array is now On the third move Alice chooses and get no points Her score is now The array is now On the last move Bob chooses and get three points His score is now The array is empty now Since Bob has more points at the end of the game he is the winner You want to find out who will win if both players play optimally ,Let s look at an analogy for this game If Alice takes an even number she adds points to the global result otherwise If Bob takes an odd number he adds points to the global result otherwise Alice wants to maximize the global result and Bob wants to minimize it Obviously this game is completely equivalent to the conditional game Suppose now it s Alice s move Let s look at some number in the array If this number is even then taking it will add points and giving it to Bob will add points If this number is odd then taking it will add points and giving it to Bob will add points So taking the number by points is more profitable than not taking it regardless of the parity To maximize the result Alice should always take the maximum number in the array Similar reasoning can be done for Bob In the task it was necessary to sort the array and simulate the game 
There are monsters standing in a row numbered from to The th monster has health points hp You have your attack power equal to hp and your opponent has his attack power equal to hp You and your opponent are fighting these monsters Firstly you and your opponent go to the first monster and fight it till his death then you and your opponent go the second monster and fight it till his death and so on A monster is considered dead if its hp is less than or equal to The fight with a monster happens in turns You hit the monster by hp If it is dead after your hit and you both proceed to the next monster Your opponent hits the monster by hp If it is dead after his hit and you both proceed to the next monster You have some secret technique to force your opponent to skip his turn You can use this technique at most times for example if there are two monsters and then you can use the technique times on the first monster and time on the second monster but not times on the first monster and times on the second monster Your task is to determine the maximum number of points you can gain if you use the secret technique optimally ,Let s calculate the minimum number of secret technique uses we need to kill each of the monsters Let the current monster has hp Firstly it is obvious that we can take modulo except one case If it becomes zero let s rollback it by one pair of turns Then the number of uses of the secret technique we need is Let s sort all monsters by this value and take the cheapest set of monsters prefix of the sorted array with the sum of values less than or equal to Time complexity 
A group of friends decide to go to a restaurant Each of the friends plans to order meals for burles and has a total of burles The friends decide to split their visit to the restaurant into several days Each day some group of friends goes to the restaurant Each of the friends visits the restaurant no more than once that is these groups do not intersect These groups must satisfy the condition that the total budget of each group must be than the amount of burles that the friends in the group are going to spend at the restaurant In other words the sum of all values in the group must not exceed the sum of values in the group What is the maximum number of days friends can visit the restaurant For example let there be friends for whom and Then first and sixth friends can go to the restaurant on the first day They will spend burles at the restaurant and their total budget is burles Since they can actually form a group friends with indices can form a second group They will spend burles at the restaurant and their total budget will be burles It can be shown that they will not be able to form more groups so that each group has at least two friends and each group can pay the bill So the maximum number of groups the friends can split into is Friends will visit the restaurant for a maximum of two days Note that the rd friend will not visit the restaurant at all Output the maximum number of days the friends can visit the restaurant for given and ,First we sort the friends in descending order of Now for each friend we know the amount of money he lacks or vice versa which he has in excess In order to maximize the number of days it is most advantageous for friends to break into pairs It is the number of groups that matters not the number of people in the group so adding a third person to the pair won t improve the answer in any way Let s solve the problem using two pointers for the richest friend find the first friend from the end such that the sum of their values exceeds the sum of their values Then repeat this for all subsequent friends until the pointers meet If no pair could be formed or none of the friends has a value greater than then the answer is Otherwise print the number of pairs formed 
You are given an integer In move you can do one of the following actions erase any digit of the number it s acceptable that the number before the operation has exactly one digit and after the operation it is empty add one digit The actions may be performed in any order any number of times Note that if after deleting some digit from a number it will contain leading zeroes they will be deleted E g if you delete from the number the digit the result is the number not You need to perform the number of actions to make the number any power of i e there s an integer such that the resulting number is equal to E g consider The answer is equal to First let s add to the right one digit the result will be Then let s erase the digit so the result will be which is a power of E g consider The answer is equal to Let s erase any of the digits three times The result will be which is a power of ,Suppose we must turn into some number In this case we can use the following greedy algorithm Consider the string forms and of the numbers and respectively Let s make a pointer pointing at the first character of the string and a pointer pointing at the first character of the string Let s initialize a variable in which we will store a number of selected characters Until any of the pointers points at the place that is out of the corresponding string let s do the following procedure if the characters to which the pointers point are equal we will take the character increase by and move both pointers character to the right otherwise the only action we must perform is to move character to the right The variable will contain after the whole process the length of the longest subsequence of equal to a prefix of i e the maximum number of original characters of that we will not erase We must add to the resulting string all remaining characters of to turn it into Therefore we must erase digits and add digits so the answer for this subproblem is where means the length of a string Suppose we have a set of powers of two such that it s enough to consider to get the problem s answer The problem can be solved as follows for each let s calculate the answer for the subproblem described above and select the value of as the answer What set of powers of two we can take Suppose the number consists of no more than digits The answer for each consisting of digits doesn t exceed hence we can get this value by turning the number into in move adding to the right of the number and erasing all other digits Suppose there s a number such that So it consists of no more than digits this value can be reached as follows we must not erase any digit and add digits Therefore if each number such that consists of no more than digits hence Suppose consists of more than digits Then because according to the input format The answer for the number doesn t exceed we can get this answer if we erase all from the number to turn it into Suppose there s a number such that This number can consist of no more than digits digits of plus digits hence Therefore it s enough to consider all powers of two that are less than 
Inflation has occurred in Berlandia so the store needs to change the price of goods The current price of good is given It is allowed to increase the price of the good by times with k is an integer Output the roundest possible new price of the good That is the one that has the maximum number of zeros at the end For example the number is more round than the number three zeros at the end of and only one at the end of If there are several possible variants output the one in which the new price is maximal If it is impossible to get a rounder price output that is the maximum possible price ,The answer is First count two numbers which denote the degree of occurrence of and in the number respectively that is Where is not divisible by either or Now while we will increase the corresponding value For example if then as long as and at that we will increase by and multiply by times That way we can get the most round number possible by spending the least possible Now we either have or or Then in the first case we will multiply the number by as long as we can That is until Now in either case we have Then Then we multiply by times and get our desired answer In the last step we can no longer get a rounder number but just find the maximal possible number 
The girl named Masha was walking in the forest and found a complete binary tree of height and a permutation of length A complete binary tree of height is a rooted tree such that every vertex except the leaves has exactly two sons and the length of the path from the root to any of the leaves is The picture below shows the complete binary tree for A permutation is an array consisting of different integers from to For example is a permutation but is not occurs twice and is also not a permutation but there is in the array Let s enumerate leaves of this tree from left to right The leaf with the number contains the value For example if the tree will look like this Masha considers a tree if the values in its leaves are ordered from left to right in increasing order In one operation Masha can choose any non leaf vertex of the tree and swap its left and right sons along with their subtrees For example if Masha applies this operation to the root of the tree discussed above it will take the following form Help Masha understand if she can make a tree in a certain number of operations If she can then output the minimum number of operations to make the tree ,Let some vertex be responsible for a segment of leaves Then her left son is responsible for the segment and the right for the segment Note that if we do not apply the operation to this vertex then it will not be possible to move some element from the right son s segment to the left son s segment It remains to understand when we need to apply the operation to the vertex Let the maximum on the segment be the minimum on the same segment is Then if lies in the right son and in the left then we should obviously apply the operation for the reason described above In the case when lies in the left son and in the right the application of the operation will definitely not allow you to get a solution Let s continue to act in a similar way recursively from the children of the current vertex At the end we should check whether we have received a sorted permutation The above solution works for since there are levels in the tree and at each level vertexes are responsible for sheets in total You can optimize this solution to if you pre calculate the maximum and minimum for each vertex 
 is a wooden toy in the form of a painted doll inside which you can put a similar doll of a smaller size A set of nesting dolls contains one or more nesting dolls their sizes are consecutive positive integers Thus a set of nesting dolls is described by two numbers the size of a smallest nesting doll in a set and the number of dolls in a set In other words the set contains sizes of for some integer and You had one or more sets of nesting dolls Recently you found that someone mixed all your sets in one and recorded a sequence of doll sizes integers You do not remember how many sets you had so you want to find the number of sets that you could initially have For example if a given sequence is Initially there could be sets the first set consisting of nesting dolls with sizes a second set consisting of nesting dolls with sizes According to a given sequence of sizes of nesting dolls determine the minimum number of nesting dolls that can make this sequence Each set is completely used so all its nesting dolls are used Each element of a given sequence must correspond to exactly one doll from some set ,First for each size let s count the number of dolls of this size Then let s create a set in which for each doll of size we add the numbers and This will allow you to process all the segments as well as the dimensions adjacent to them We will iterate over the set in ascending order of size Let be the number of matryoshkas of the current size of the previous one considered at the beginning If the numbers do not match then you need to close if or open if segments It is enough to add only the opening of the segments to the answer 
You are given an array consisting of integers For each the following inequality is true You can remove any number possibly of elements from the beginning of the array and any number possibly of elements from the end of the array You are allowed to delete the whole array You need to answer the question how many elements should be removed from the beginning of the array and how many elements should be removed from the end of the array so that the result will be an array whose product multiplication of elements is If there is more than one way to get an array with the maximum product of elements on it you are allowed to output of them The product of elements of an array array of length should be assumed to be ,First we can always get a product value equal to if we remove all elements of the array Then we need to know what maximal value of the product we can get Consequently the remaining array after removing the corresponding prefix and suffix should have no elements We can find maxima in all sections between zeros Now we are left with a set of nonzero numbers If the value of the product on the current segment is positive it makes no sense to remove any more elements Otherwise the product is negative then we must remove one negative number from the product either to the left or to the right Compare the values of the product on the prefix and suffix to the nearest negative value and remove either the suffix or the prefix respectively 
Recall that of an array is a that does not belong to the array Examples for the array MEX equals to because numbers and are presented in the array and is the minimum non negative integer not presented in the array for the array MEX equals to because is the minimum non negative integer not presented in the array for the array MEX equals to because is the minimum non negative integer not presented in the array You are given an empty array in other words a zero length array You are also given a positive integer You are also given queries The th query consists of one integer and means that you have to append one element to the array The array length increases by after a query In one move you can choose any index and set or i e increase or decrease any element of the array by The only restriction is that Since initially the array is empty you can perform moves only after the first query You have to maximize the minimum excluded of the array if you can perform any number of such operations you can even perform the operation multiple times with one element You have to find the answer after each of queries i e the th answer corresponds to the array of length ,Firstly let s understand what the operation does It changes the element but holds the remainder modulo So we can consider all elements modulo Let be the number of elements with the value modulo be the number of elements with the value modulo and so on Let s understand where is the bottleneck of MEX Obviously we can always fill exactly full blocks so MEX is at least MEX will be among all elements such that Among all such elements MEX will be the minimum such Let it be So the final value of MEX is How to deal with queries Let s maintain the sorted set of pairs for all and change it with respect to appended values During each query let s change the set correspondingly and take the answer as the first element of this set using the formula above Time complexity There is also an easy linear solution that uses the same idea but in a different way 
Polycarp has to solve exactly problems to improve his programming skill before an important programming competition But this competition will be held very soon most precisely it will start in days It means that Polycarp has exactly days for training Polycarp doesn t want to procrastinate so he wants to solve at least one problem during each of days He also doesn t want to overwork so if he solves problems during some day he should solve no more than problems during the next day And at last he wants to improve his skill so if he solves problems during some day he should solve at least problem during the next day More formally let be the array of numbers of problems solved by Polycarp The th element of this array is the number of problems Polycarp solves during the th day of his training Then the following conditions must be satisfied sum of all for from to should be should be for each from to the condition should be satisfied for each from to Your problem is to find array of length satisfying the conditions above or say that it is impossible to do it ,I suppose there are some solutions without cases handling but I ll describe my own it handling approximately 5 cases Firstly let nn n frac k k 1 2 If nn 0 then the answer is already Otherwise let s construct the array a where all a i are lfloor frac nn k rfloor except rightmost nn k values they are lceil frac nn k rceil It is easy to see that the sum of this array is nn it is sorted in non decreasing order and the difference between the maximum and the minimum elements is not greater than 1 Let s add 1 to a 1 2 to a 2 and so on this is what we subtract from n at the beginning of the solution Then if nn ne k 1 or k 1 then this answer is correct Otherwise we got some array of kind 1 3 dots a k How do we fix that For k 2 or k 3 there is no answer for this case you can try to prove it or try to find answers for cases n 4 k 2 and n 8 k 3 Otherwise k 3 and we can subtract one from a 2 and add it to a k and this answer will be correct this also can be proved with some easy formulas Time complexity O k 
Vlad has friends for each of whom he wants to buy gift for the New Year There are shops in the city in each of which he can buy a gift for any of his friends If the th friend receives a gift bought in the shop with the number then the friend receives units of joy The rectangular table is given in the input Vlad has time to visit at most shops where is the number of He chooses which shops he will visit and for which friends he will buy gifts in each of them Let the th friend receive units of joy from Vlad s gift Let s find the value Vlad s goal is to buy gifts so that the value of is as large as possible In other words Vlad wants to maximize the minimum of the joys of his friends For example let Let the joy from the gifts that we can buy in the first shop in the second shop Then it is enough for Vlad to go only to the second shop and buy a gift for the first friend bringing joy and for the second bringing joy In this case the value will be equal to Help Vlad choose gifts for his friends so that the value of is as high as possible Please note that each friend must receive one gift Vlad can visit at most shops where is the number of In the shop he can buy any number of gifts ,Note that if we cannot get joy then we cannot get and if we can get at least then we can get at least These facts allow us to use binary search to find the answer Now we need to understand how exactly we can recognize whether we can gain joy at least or not We can enter at most shops so we always need to take two gifts from some store which means there must be a store in which we can find two or more gifts with pleasure at least Also each friend should receive a gift which means that we should be able to buy each gift with pleasure at least It takes O nm to check that both of these conditions are met The total solution works in O nm log nm 
Kolya got an integer array The array can contain both positive and negative integers but Kolya doesn t like so the array doesn t contain any zeros Kolya doesn t like that the sum of some subsegments of his array can be The subsegment is some consecutive segment of elements of the array You have to help Kolya and change his array in such a way that it doesn t contain any subsegments with the sum To reach this goal you can insert any integers between any pair of adjacent elements of the array integers can be really any positive negative any by absolute value even such a huge that they can t be represented in most standard programming languages Your task is to find the minimum number of integers you have to insert into Kolya s array in such a way that the resulting array doesn t contain any subsegments with the sum ,Firstly let s understand that the sum of the segment is zero if is zero in other words where is the sum of the first elements Let s iterate over elements from left to right and add all prefix sums in the set If we get the sum that is already in the set we get some segment with sum and we need to fix it somehow Let s insert some huge number before the current element in such a way that all prefix sums starting from the current element to the end will be significantly bigger than all prefix sums to the left In words of implementation we just get rid of all prefix sums to the left clear the set and continue doing the same process starting from the current element so we just cut off the prefix of the array This way is optimal because we remove all segments with sum ending at the current element using only one insertion and we need to use at least one insertion to do that Time complexity 
Let be a string of lowercase Latin letters Its price is the sum of the indices of letters an integer between 1 and 26 that are included in it For example the price of the string is The string and the integer are given Remove the minimal number of letters from so that its price becomes less than or equal to and print the resulting string Note that the resulting string may be empty You can delete arbitrary letters they do not have to go in a row If the price of a given string is less than or equal to then nothing needs to be deleted and must be output Note that when you delete a letter from the order of the remaining letters is preserved For example if you delete the letter from the string you get ,The main idea is that it is always better to remove the most expensive symbol To do this quickly we will count all the symbols and remove them from the most expensive to the cheapest counting how many times we have removed each During the output we will skip the characters the number of times that we deleted 
You are given an integer Your task is to find a sequence of integers such that each is strictly greater than i e the product of this sequence is is divisible by for each from to is the possible i e the length of this sequence is the possible If there are several such sequences any of them is acceptable It can be proven that at least one valid sequence always exists for any integer You have to answer independent test cases ,Consider n in this canonical form p 1 a 1 cdot p 2 a 2 cdot ldots cdot p k a k just find the prime factorization of n Let i be such an index that a i is the maximum among all values of a Then the answer length can not exceed a i This is because if the answer has greater length then some number doesn t have p i in its representation thus there will be problems with divisibility because we are considering primes So let s create the answer of length a i consisting of p i Then let s just multiply the last element by all other primes in their degrees So we satisfied the divisibility rule and the length of the answer is the maximum possible 
The next lecture in a high school requires two topics to be discussed The th topic is interesting by units for the teacher and by units for the students The pair of topics and is called if i e it is more interesting for the teacher Your task is to find the number of pairs of topics ,Let s rewrite the inequality from to This looks much simpler Let s build the array where and sort this array Now our problem is to find the number of pairs such that Let s iterate over all elements of from left to right For simplicity we consider only greater summands Because our sum must be greater than then at least one of these summands will be positive So if just skip it Now and we need to calculate the number of such that and It means that each for some will be okay Such leftmost position can be found with or binary search Then add the value to the answer and consider the next element Time complexity 
You have a string consisting of lowercase Latin alphabet letters You can color some letters in colors from to It is not necessary to paint all the letters But for each color there must be a letter painted in that color Then you can swap any two symbols painted in the same color as many times as you want After that strings will be created th of them will contain all the characters colored in the color written in the order of their sequence in the string Your task is to color the characters of the string so that all the resulting strings are palindromes and the length of the shortest of these strings is as as possible Read the note for the first test case of the example if you need a clarification Recall that a string is a palindrome if it reads the same way both from left to right and from right to left For example the strings and are palindromes but the strings and are not ,We will solve the problem greedily First we will try to add pairs of identical characters to palindromes As long as there are at least pairs let s add them After that it is no longer possible to add a couple of characters but you can try to add one character in the middle This can be done if there are at least characters left There is no need to paint other characters 
A permutation is a sequence of length integers from to in which all the numbers occur exactly once For example permutations and no Polycarp was recently gifted a permutation of length Polycarp likes trees more than permutations so he wants to transform permutation into a rooted binary tree He transforms an array of different integers into a tree as follows the maximum element of the array becomes the root of the tree all elements to the left of the maximum form a left subtree which is built according to the same rules but applied to the left part of the array but if there are no elements to the left of the maximum then the root has no left child all elements to the right of the maximum form a right subtree which is built according to the same rules but applied to the right side of the array but if there are no elements to the right of the maximum then the root has no right child For example if he builds a tree by permutation then the root will be the element and the left subtree will be the tree that will be built for the subarray and the right one for the subarray As a result the following tree will be built Another example let the permutation be In this case the tree looks like this Let us denote by the depth of the vertex that is the number of edges on the path from the root to the vertex numbered Note that the root depth is zero Given the permutation for each vertex find the value of ,We will construct the required tree recursively Let us describe the state of tree construction by three values where is the segment of the permutation and is the current depth Then the following transitions can be described find the position of the maximum element on the segment that is the depth of the vertex is equal to if then make the transition to the state if then make the transition to the state Then in order to construct the required tree it is necessary to take as the initial state 
There are distinct points on a coordinate line the coordinate of th point equals to Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two It is necessary to consider each pair of points not only adjacent Note that any subset containing one element satisfies the condition above Among all these subsets choose a subset with maximum possible size In other words you have to choose the maximum possible number of points such that for each pair it is true that where is some non negative integer number not necessarily the same for each pair of points ,Firstly let s prove that the size of the answer is not greater than Suppose that the answer equals to Let be coordinates of the points in the answer and Let and Then because of the condition It means that Conditions must hold for a triple too Now it is easy to see that if then that is not a power of two So the size of the answer is not greater than Firstly let s check if the answer is Iterate over all middle elements of the answer and over all powers of two from to inclusively Let be the middle element of the answer and the current power of two Then if there are elements and in the array then the answer is Now check if the answer is Do the same as in the previous solution but now we have left point and right point If we did not find answer of lengths or then print any element of the array The solution above have time complexity because of we can check if the element is in the array with some data structure in 
Polycarp likes numbers that are divisible by 3 He has a huge number Polycarp wants to cut from it the maximum number of numbers that are divisible by To do this he makes an arbitrary number of vertical cuts between pairs of adjacent digits As a result after such cuts there will be parts in total Polycarp analyzes each of the obtained numbers and finds the number of those that are divisible by For example if the original number is then Polycarp can cut it into three parts with two cuts As a result he will get two numbers that are divisible by Polycarp can make an arbitrary number of vertical cuts where each cut is made between a pair of adjacent digits The resulting numbers cannot contain extra leading zeroes that is the number can begin with if and only if this number is exactly one character For example and are not valid numbers but and are valid What is the maximum number of numbers divisible by that Polycarp can obtain ,There are multiple approaches to solve this problem We will use dynamic programming approach Let s calculate values of the array where is the answer for prefix of the length Obviously since for the empty string the prefix of the length the answer is For you can find in the following way Let s look in the last digit of the prefix of length It has index Either it doesn t belong to segment divisible by or it belongs If it doesn t belongs it means we can t use the last digit so If it belongs we need to find shortest that is divisible by and try to update with the value It means that we bite off the shortest divisible by suffix and reduce the problem to a previous A number is divisible by if and only if sum of its digits is divisible by So the task is to find the shortest suffix of with sum of digits divisible by If such suffix is then and have the same remainder of sum of digits modulo Let s maintain array of the length where is the length of the longest processed prefix with sum of digits equal to modulo Use if there is no such prefix It is easy to see that where is the sum of digits on the th prefix modulo So to find the maximal that substring is divisible by just check that and use where is the sum of digits on the th prefix modulo It means that to handle case that the last digit belongs to divisible by segment you should try to update with value In other words just do Sequentially calculating the values of we obtain a linear solution 
An important meeting is to be held and there are exactly people invited At any moment any two people can step back and talk in private The same two people can talk several as many as they want times per meeting Each person has limited The sociability of the th person is a non negative integer This means that after exactly talks this person leaves the meeting and does not talk to anyone else anymore If the th person leaves the meeting immediately after it starts A meeting is considered most if the maximum possible number of talks took place during it You are given an array of sociability determine which people should talk to each other so that the total number of talks is as large as possible ,For the first conversation let s choose two people and with maximal values of sociability Note that after this conversation takes place we move on to a similar problem but in which and are decreased by After decreasing and by we repeat the choice of the two people with the maximum values of sociability Let us repeat such iterations while at least two people with positive sociability parameters remain Let us prove that this solution leads to the optimal answer Let s denote the sum by and consider two fundamentally different cases The maximal element is greater than or equal to the sum of all remaining elements That is there exists such that In this case note that the th person can not possibly have more than conversations because by that point all other people already reached their sociability limits and left the meeting Thus if the answer cannot be more than Note that this estimation is accurate since an example exists in which th person talks to all other people as many times as possible that is times with th person for all And the algorithm described above will just choose the th person as one of the participants of a conversation every time because for every conversation both and decrease by exactly so the inequality holds and it follows that Otherwise we can prove that the maximum number of conversations is always Obviously it is impossible to get more than this number since each conversation requires exactly two units of sociability one from two people while a larger answer would mean that which is obviously wrong Let us prove that this answer is achieved by the described algorithm Let s look at the last conversation held If there are at least two more people left in the meeting after it we can hold another conversation which means there is a more optimal answer If there are zero people left in the meeting then an estimate of of conversations has been achieved And if there is one person with a remaining sociability then an estimate of of conversations has been achieved If there is exactly one remaining person with a sociability residual then we can guarantee that this person has participated in all previous conversations Indeed let s look at the last conversation it was held between two people with the maximum parameters of the remaining sociability But the th person has at least sociability remaining so it couldn t have been the other two people with residuals of who left right after that Thus analyzing all conversations in reverse order we can prove that at any time which means that it is in fact the case considered above We have proven that the described greedy algorithm works This algorithm can be implemented by using any balanced search tree such as By storing pairs of elements in it we could for each time choose the next two people to talk to and update the sociability values The time complexity is 
Authors guessed an array consisting of integers each integer is not less than and not greater than You don t know the array but you know the array which is formed from it with the following sequence of operations Firstly let the array be equal to the array Secondly for each from to if is a number then one integer is appended to array where is an infinite sequence of prime numbers otherwise if is not a number the greatest divisor of which is not equal to is appended to Then the obtained array of length is shuffled and given to you in the input Here means the th prime number The first prime the second one is and so on Your task is to recover suitable array that forms the given array It is guaranteed that the answer exists so the array is obtained from some suitable array If there are multiple answers you can print any ,Firstly let s generate first primes It can be done in almost naively just check all elements in range It also can be done with Eratosthenes sieve in or We also can calculate for each number in this range the maximum its divisor non equal to it if this number is not a prime And in other case we can calculate the index of this prime Using all this information we can restore the array Let s maintain a multiset a set in which multiple copies of the same element are allowed of all elements in While it is not empty let s take the maximum element from this set If it is prime we can check it using the information calculated earlier then it is some Let s find the index of this prime using calculated information remove this element and push in and continue Otherwise this element is not a prime and then it is some Let s remove it and its maximum divisor non equal to it from the multiset push in and continue 
You are given an array consisting of integers You can remove element from this array Thus the final length of the array is or Your task is to calculate the maximum possible length of the contiguous subarray of the remaining array Recall that the contiguous subarray with indices from to is The subarray is called strictly increasing if ,Firstly let s calculate for each from to two following values and means the maximum length of the increasing sequence starting in the position and means the maximum length of the increasing sequence ending in the position Initially all values are the element itself The array can be calculated in order from right to left with the following condition if then otherwise it still remain The same with the array but we have to calculate its values in order from left to right and if then otherwise it still remain Having these arrays we can calculate the answer The initial answer if we don t remove any element is the maximum value of the array And if we remove the th element where then we can update the answer with the value if Time complexity 
Dmitry has a string consisting of lowercase Latin letters Dmitry decided to remove two characters from the string and you are wondering how many different strings can be obtained after such an operation For example Dmitry has a string You can get the following different strings by deleting the first two or second and third characters by deleting the third and fourth characters by deleting the fourth and the fifth character and by deleting the last two ,Consider deleting characters with numbers and as well as characters with numbers and In the first case the symbol with the number remains in the second Symbols with numbers less than or more than remain in both cases Therefore the same strings will be obtained if the characters with the numbers and match Therefore we just need to count the number of and subtract this value from 
You are given an array of integers Count the number of pairs of indices such that and ,Let s rewrite the original equality a bit a j a i j i a j j a i i Let s replace each a i with b i a i i Then the answer is the number of pairs i j such that i j and b i b j To calculate this value you can use or sorting 
There were types of swords in the theater basement which had been used during the plays Moreover there were swords of each type people have broken into the theater basement and each of them has taken exactly swords of some Note that different people might have taken different types of swords Note that the values and are unknown for you The next morning the director of the theater discovers the loss He counts all swords exactly swords of the th type are left untouched The director has no clue about the initial number of swords of each type in the basement the number of people who have broken into the basement and how many swords each of them have taken For example if then one of the possible situations is and Then the first three people took swords of the first type and the other two people took swords of the third type Note that you don t know values and beforehand but know values of and Thus he seeks for your help Determine the number of people which could have broken into the theater basement and the number of swords each of them has taken ,Firstly let s notice that for the fixed value of our problem is reduced to the following we are given numbers We need to choose such values that And among all such values we need to choose values in a way to minimize And the sum of is Of course for the fixed value the minimum sum of can be only one Let s start with It is obvious that if the maximum value in the array is the value equals for Assume that each from to has some divisor Then if we multiply by and divide each by the answer will only become better How to calculate this value of fast We can see that this value equals to And it can be proven that this value of is always optimal and we can easily determine for such Time complexity 
Polycarp wrote on the board a string containing only lowercase Latin letters This string is known for you and given in the input After that he erased some letters from the string and he rewrote the remaining letters in order As a result he got some new string You have to find it with some additional information Suppose that the string has length and the characters are numbered from left to right from to You are given a sequence of integers where is the sum of the distances from the index to all such indices that consider that In other words to calculate Polycarp finds all such indices that the index contains a letter that is later in the alphabet than and sums all the values For example if then since all other indices contain letters which are later in the alphabet that is since only the index contains the letter which is later in the alphabet that is since then there are no indexes such that thus since only the index contains the letter which is later in the alphabet that is Thus if then Given the string and the array find any possible string for which the following two requirements are fulfilled simultaneously is obtained from by erasing some letters possibly zero and then writing the rest in order the array constructed from the string according to the rules above equals to the array specified in the input data ,We will construct the string starting with the largest letters Note that if then the th letter of the string is maximal so we know that the th letter affect all While the string is not completely constructed we will do the following Find all such that and the th character of string is not placed Put on all these positions in the string the maximum letter not used in the string there should be a sufficient number of letters in the string Subtract from all 
You are given three integers In one move you can add or to of these integers i e increase or decrease any number by one You can perform such operation any possibly zero number of times you can even perform this operation several times with one number You have to perform the minimum number of such operations in order to obtain three integers such that is divisible by and is divisible by You have to answer independent test cases ,Let s iterate over all possible values of from to It is obvious that cannot be bigger than else we can just move to Then let s iterate over all possible multiples of from to Let this number be Then we can find as the nearest number to that is divisible by we can check two nearest numbers to be sure These numbers are and Then we can update the answer with the found triple Note that the only condition you need to check is that Time complexity because of the sum of the harmonic series 
Petya got an array of numbers from to where He performed operations sequentially In the end he received a new state of the array At the th operation Petya chose the first elements of the array and cyclically shifted them to the right an arbitrary number of times elements with indexes and more remain in their places One cyclic shift to the right is such a transformation that the array becomes equal to the array For example if and that is this is the third operation then as a result of this operation he could get any of these three arrays makes cyclic shifts or any number that is divisible by makes cyclic shift or any number that has a remainder of when divided by makes cyclic shifts or any number that has a remainder of when divided by Let s look at an example Let i e initially A possible scenario is described below no matter how many cyclic shifts Petya makes the array does not change let s say Petya decided to make a cyclic shift then the array will look like let s say Petya decided to make cyclic shift then the array will look like let s say Petya decided to make cyclic shifts the original array will look like let s say Petya decided to make cyclic shifts then the array won t change let s say Petya decided to make cyclic shifts the array will look like You are given a final array state after all operations Determine if there is a way to perform the operation that produces this result In this case if an answer exists print the numbers of cyclical shifts that occurred during each of the operations ,The first thing to notice the answer always exists For numbers answer choices as well as permutation combinations It remains only to restore the answer from this permutation We will restore by performing reverse operations On the th operation will be selectd the first elements of the array and rotate them times to the left elements with numbers and more remain in their places Where is equal to if otherwise and is the index of the number Thus for each from right to left performing a left cyclic shift operation we move the number at index As a result we move numbers times The time complexity 
You are given two strings and consisting of lowercase English letters both of length The characters of both strings have indices from to inclusive You are allowed to do the following Choose any index and swap characters and Choose any index and swap characters and Choose any index and swap characters and Note that if is odd you are formally allowed to swap with and the same with the string but this move is useless Also you can swap two equal characters but this operation is useless as well You have to make these strings equal by applying any number of described above in any order But it is obvious that it may be impossible to make two strings equal by these swaps In one you can replace a character in with another character In other words in a single you can choose any index any character and set Your task is to find the minimum number of to apply in such a way that after them you can make strings and equal by applying some number of described in the list above Note that the number of you make after the does not matter Also note that you cannot apply to the string or make any after the first is made ,Let s divide all characters of both strings into groups in such a way that characters in each group can be swapped with each other with So there will be following groups and so on Since these groups don t affect each other we can calculate the number of in each group and then sum it up How to determine if a group does not need any preprocess moves For a group consisting of characters there will be one such group if is odd it will contain and that s easy if the characters in this group are equal the answer is otherwise it s To determine the required number of preprocess moves for a group consising of four characters we may use the following fact this group doesn t require preprocess moves iff the characters in this group can be divided into pairs So if the group contains four equal characters or two pairs of equal characters then the answer for this group is Otherwise we may check that replacing only one character of and will be enough if so then the answer is otherwise it s Overall complexity is 
The girl Umka loves to travel and participate in math olympiads One day she was flying by plane to the next olympiad and out of boredom explored a huge checkered sheet of paper Denote the th Fibonacci number as A checkered rectangle with a height of and a width of is called a Fibonacci rectangle Umka has a Fibonacci rectangle Someone colored a cell in it at the intersection of the row and the column It is necessary to cut this rectangle into squares in such way that the painted cell was in a square with a side of there was pair of squares with equal sides the side of each square was equal to a Fibonacci number Will Umka be able to cut this rectangle in that way , which can be proved by induction If the partition exists it has the form since the area of the rectangle with another partition will be greater than We will cut the rectangles in the order Denote the coordinates of the colored cell at the step as If and then there is no partition since the square at any location overlaps the colored cell Cut off the square from the right or left edge depending on the location of the colored cell that is or Suppose that it was advantageous to cut it not from the edge then it is necessary to cut the rectangles and where using the set Then will not enter the partition but so We came to a contradiction 
You are given a rooted tree consisting of vertices Vertices are numbered from to Any vertex can be the root of a tree A is a connected undirected graph without cycles A is a tree with a selected vertex which is called the The tree is specified by an array of parents containing numbers is a parent of the vertex with the index The of a vertex is a vertex that is the next vertex on the shortest path from to the root For example on the simple path from to the root the next vertex would be so the parent of is The root has no parent so for it the value of is the root is the only vertex for which Find such a set of paths that each vertex belongs to exactly one path each path can contain one or more vertices in each path each next vertex is a son of the current vertex that is paths always lead down from parent to son number of paths is For example if and then the tree can be divided into three paths path of vertices path of vertices path of vertices ,Let s find a set of leaves of a given tree From each leaf we will climb up the tree until we meet a vertex already visited Having met such a vertex start a new path from the next leaf The sequence of vertices in the found paths must be deduced in reverse order because the paths must go from bottom to top It also follows from this solution that the number of paths will always be equal to the number of leaves in the tree 
There are houses in a row They are numbered from to in order from left to right Initially you are in the house You have to perform moves to other house In one move you go from your current house to some other house You can t stay where you are i e in each move the new house differs from the current house If you go from the house to the house the total distance you walked increases by units of distance where is the absolute value of It is possible to visit the same house multiple times but you can t visit the same house in sequence Your goal is to walk exactly units of distance in total If it is impossible print Otherwise print and any of the ways to do that Remember that you should do exactly moves ,The solution for this problem is very simple at first if or the answer is Otherwise let s do the following thing times let be we have to greedily decrease the remaining distance but we also should remember about the number of moves which we need to perform We have to walk to possible house which is located at distance from the current house also don t forget to subtract from The proof of the fact that we can always walk to the house at distance is very simple one of the possible answers which is obtained by the algorithm above will looks like several moves of distance possibly one move of random distance less than and several moves of distance The first part of the answer can be obtained if we are stay near the leftmost or the rightmost house second and third parts always can be obtained because distances we will walk in every of such moves is less than Time complexity is 
There is a robot staying at on the axis He has to walk to You are controlling this robot and controlling how he goes The robot has a battery and an accumulator with a solar panel The th segment of the path from to can be exposed to sunlight or not The array denotes which segments are exposed to sunlight if segment is exposed then otherwise The robot has one battery of capacity and one accumulator of capacity For each segment you should choose which type of energy storage robot will use to go to the next point it can be either battery or accumulator If the robot goes using the battery the current charge of the battery is decreased by one the robot can t use the battery if its charge is zero And if the robot goes using the accumulator the current charge of the accumulator is decreased by one and the robot also can t use the accumulator if its charge is zero If the current segment is and the robot goes through it the charge of the accumulator increases by one of course its charge can t become higher than it s maximum capacity If accumulator is used to pass some segment its charge decreases by 1 no matter if the segment is exposed or not You understand that it is not always possible to walk to You want your robot to go as far as possible Find the maximum number of segments of distance the robot can pass if you control him optimally ,Let s simulate the process of walking and maintain the current charges of the battery and the accumulator carefully choosing which to use each time we want to pass a segment Obviously if at the beginning of some segment our battery is exhausted its current charge is we must use the accumulator to continue and vice versa What if we can use both types of energy storage If we can recharge the accumulator the current segment is exposed the current charge of accumulator is lower than its initial charge let s do it because it only consumes one charge of the battery and there is no better way to spend it And if we cannot recharge the accumulator it s optimal to use it instead of the battery suppose it s not right our solution uses the accumulator during current moment of time and the battery during some moment in future but optimal solution does vice versa Then the usage of the battery in optimal solution does not grant us any additional charges so we can instead swap our decisions in these moments use the accumulator right now and the battery later and the answer won t get worse So what s left is to carefully implement the simulation keeping track of charges and choosing what to use according to aforementioned rules 
You are given a rooted tree consisting of vertices Vertices are numbered from to Any vertex can be the root of a tree A is a connected undirected graph without cycles A is a tree with a selected vertex which is called the The tree is specified by an array of ancestors containing numbers is an ancestor of the vertex with the number The of a vertex is a vertex that is the next vertex on a simple path from to the root For example on the simple path from to the root the next vertex would be so the ancestor of is The root has no ancestor so for it the value of is the root is the only vertex for which For example if and then the tree looks like this You are given an array a permutation of the vertices of the tree If it is possible assign any integer weights on the edges so that the vertices sorted by distance from the root would form the given permutation In other words for a given permutation of vertices it is necessary to choose such edge weights so that the condition is true for each from to is a sum of the weights of the edges on the path from the root to In particular if the vertex is the root of the tree For example assume that In this case the following edge weights satisfy this permutation the edge has a weight of the edge has weight of the edge has a weight of the edge has a weight of The array of distances from the root looks like The vertices sorted by increasing the distance from the root form the given permutation Print the required edge weights or determine that there is no suitable way to assign weights If there are several solutions then print any of them ,Consider the cases when it is impossible to form a given permutation 1 For root it is true that For any other vertex the value of will be positive since there is at least one edge of positive weight on the path to it 2 In a rooted tree there is exactly one path from the root to any vertex and it goes through its parent so it must always be true Let us start filling the array where Consider a vertex The vertex whose distance at the current time is maximal is Then is at least We assign a value to remembering to check that has already been counted After counting all values we can output the lengths of the edges 
You are given two arrays and each contains integers You want to create a new array as follows choose some real i e not necessarily integer number and then for every let Your goal is to maximize the number of zeroes in array What is the largest possible answer if you choose optimally ,For each index let s try to find which we should use in order to make th element of equal to zero If then no matter which we choose So we should just ignore this index and add to the answer if Otherwise we should choose Let s calculate the required fraction for each index and among all fractions find one that fits most indices this can be done for example by storing all fractions in a The only thing that s left to analyze is how to compare the fractions because floating point numbers may be not precise enough Let s store each fraction as a pair of integers where is the numenator and is the denominator We should normalize each fraction as follows firstly we reduce it by finding the greatest common divisor of and and then dividing both numbers by this divisor Secondly we should ensure that numenator is non negative and if numenator is zero then denominator should also be non negative this can be achieved by multiplying both numbers by 
You are given an array consisting of positive integers Initially you have an integer During one move you can do one of the following two operations Choose from to and increase by then increase by Just increase by The first operation can be applied to each from to Your task is to find the minimum number of moves required to obtain such an array that each its element is the value is given You have to answer independent test cases ,Firstly we can understand that during each full cycle of from to we can fix each remainder only once Notice that when we add some then we fix the remainder and we don t need to fix elements which are already divisible by So let be the number of such elements for which the condition holds i e the number of such elements that we can fix if we add the value to them We can count this using some logarithmic data structure like in C So what s the number of full cycles It equals to the amount of most frequent element in minus one So the answer is at least And there can be one last cycle which will be incomplete So what is the remanining number of moves It equals to the maximum possible among all So if is the maximum such that then the answer is Time complexity 
Polycarp has an array of is even integers Polycarp conceived of a positive integer After that Polycarp began performing the following operations on the array take an index and reduce the number by After Polycarp performed some possibly zero number of such operations it turned out that numbers in the array became the same Find the maximum at which such a situation is possible or print if such a number can be arbitrarily large , can be arbitrarily large if and only if all numbers in the array are the same In this case we can choose any number and subtract it from all the numbers for example exactly once Suppose we fix some Let be the number of subtractions of the number from the number In this case all numbers will be equal if and only if for any two numbers and from the array Let be the minimum of Then all numbers in the array become the same if for each index we subtract from not but times Then we will never subtract from the element This means that there is always an element in the array from which we can never subtract This element is the minimum on the array Then from we will subtract exactly times Thus with the current it is possible to make all elements equal if and only if for all elements the value where is the minimum on the array is divisible by So the maximum is the greatest common divisor of all values of 
 Polycarp has to write a coursework The coursework consists of pages Polycarp also has cups of coffee The coffee in the th cup has caffeine in it Polycarp can drink some cups of coffee each one no more than once He can drink cups in Polycarp drinks each cup and i e he cannot split any cup into several days Surely courseworks are not usually being written in a single day in a perfect world of Berland at least Some of them require multiple days of hard work Let s consider some day of Polycarp s work Consider Polycarp drinks cups of coffee during this day and caffeine dosages of cups Polycarp drink during this day are Then the first cup he drinks gives him energy to write pages of coursework the second cup gives him energy to write pages the third cup gives him energy to write pages the th cup gives him energy to write pages If Polycarp doesn t drink coffee during some day he cannot write coursework at all that day Polycarp has to finish his coursework as soon as possible spend the minimum number of days to do it Your task is to find out this number of days or say that it is impossible ,Since the number of days doesn t exceed let s iterate over this value from to So now we have to check somehow if the current number of days is enough to write a coursework Let the current number of days be The best way to distribute first cups of coffee for each day is to take maximums in the array Then we have to distribute second cups for each day Let s also take the next maximums in the remaining array and so on How do we can calculate such a thing easily Let s sort the array in the reversed order before iterating over all numbers of days then the following formula will work fine for the current number of days So if the value of the formula above is greater than or equal to then the current number of days is enough If there is no any suitable number of days the answer is 
 You are given an array consisting of integers In one move you can choose any and divide it by rounding down in other words in one move you can set You can perform such an operation possibly zero number of times with Your task is to calculate the minimum possible number of operations required to obtain at least equal numbers in the array ,Let be the number such that after some sequence of moves there will be at least elements in the array We can see that there is always possible candidates because all values are among all possible values of for some from to So we need to check each candidate separately and try to update the answer with it How to do this Let the current number we trying to obtain is Then let s iterate over all in any order Let be the current value of Let s divide it by while its value is greater than and carry the number of divisions we made If after all divisions then let s remember the value of in some array If after iterating over all elements of the size of is greater than or equal to then let s sort it and update the answer with the sum of smallest values of Time complexity or depends on sorting method 
Vova s family is building the Great Vova Wall named by Vova himself Vova s parents grandparents grand grandparents contributed to it Now it s totally up to Vova to put the finishing touches The current state of the wall can be respresented by a sequence of integers with being the height of the th part of the wall Vova can only use bricks to put in the wall he has infinite supply of them however Vova can put bricks on the neighboring parts of the wall of equal height It means that if for some the current height of part is the same as for part then Vova can put a brick there and thus increase both heights by 1 Obviously Vova can t put bricks in such a way that its parts turn out to be off the borders to the left of part of the wall or to the right of part of it Vova can also put bricks vertically That means increasing height of any part of the wall by 2 Vova is a perfectionist so he considers the wall completed when all parts of the wall has the same height the wall has no empty spaces inside it Can Vova complete the wall using any amount of bricks possibly zero ,Fairly enough solutions of both versions of the problem are pretty similar The major difference between them are the vertical bricks As you aren t required to minimize the total height you can work not with the heights themselves but with their parities instead Vertical brick now does nothing and horizontal brick changes the parity of neighbouring parts of the same parity Now imagine the following greedy solution While you have some segment of the same parities of even length fill it with horizontal bricks This operation merges this segment with one to the left and to the right If there is a single segment left then the answer is Otherwise it s The proof is left to the readers Implementing this as it is will be at best You ll need to keep the whole set of segments and the set with only even length ones But there exists more fun approach We don t even need the lengths of the segments just the parities of the lengths Then merging the even segment with something will just erase that segment and xor the length of the left and right ones Moreover you don t even need to erase the whole even segment you can do it brick by brick as this operations are now the same Let s simulate this with a stack When the new number comes push its parity to the stack If the topmost two elements of the stack have the same parity pop them both Now the answer is if at the end stack has no more than one element When I heard of this problem I actually had not that stack itself in mind but the correct bracket sequences Like let s define parity 0 as and and parity 1 as and Now the operations we perform with stack are greedily put the closing bracket if the last unclosed bracket was of the same type and put opening otherwise Then the stack will have like all the brackets which are still to be closed and you ll close them as early as you can This idea helped to both prove the correctness of algo and implement it Overall complexity 
 You are given a string and a string both consisting only of lowercase Latin letters It is guaranteed that can be obtained from by removing some possibly zero number of characters not necessary contiguous from without changing order of remaining characters in other words it is guaranteed that is a subsequence of For example the strings and are subsequences of the string But the strings are not subsequences of the string You want to remove some substring contiguous subsequence from of such that after removing this substring will remain a subsequence of If you want to remove the substring then the string will be transformed to where is the length of Your task is to find the maximum possible length of the substring you can remove so that is still a subsequence of ,In this problem we can just iterate over all possible substrings and try to remove each of them After removing the substring we can check if remains the subsequence of in linear time Let we remove the substring Let s maintain a pointer the initial value of the pointer is and iterate over all possible from to If and let s increase by one If after all iterations then let s update the answer with the length of the current substring 
 You are given a string consisting of characters each character is or You are also given an integer Your task is to change the minimum number of characters in the initial string so that after the changes there will be a string of length that is a substring of and is also a substring of the infinite string A string is a substring of string if there exists a positive integer such that For example strings are substrings of the infinite string while and are not You have to answer independent queries ,You can just implement what is written in the problem statement and solve this problem this way Let s iterate over all starting positions of the substring from to and over all possible offsets of the string from to inclusive Then let s iterate over all position of the current substring from to and carry the variable which denotes the answer for the current starting position and the current offset And if then let s increase by After iterating over all positions let s update the answer with the value of 
 You are given segments on the coordinate axis Segments can intersect lie inside each other and even coincide The th segment is and it covers all integer points such that The integer point is called if it is covered by than segments Your task is to remove the minimum number of segments so that there are no points at all ,In this problem the following greedy solution works let s find the leftmost point covered by more than segments We should fix it somehow How to do it Let s find some segment that was not removed already it covers this point and its rightmost end is maximum possible and remove this segment You can implement it in any time you want even in naively 
 Polycarp has to write a coursework The coursework consists of pages Polycarp also has cups of coffee The coffee in the th cup Polycarp has caffeine in it Polycarp can drink some cups of coffee each one no more than once He can drink cups in Polycarp drinks each cup and i e he cannot split any cup into several days Surely courseworks are not being written in a single day in a perfect world of Berland at least Let s consider some day of Polycarp s work Consider Polycarp drinks cups of coffee during this day and caffeine dosages of cups Polycarp drink during this day are Then the first cup he drinks gives him energy to write pages of coursework the second cup gives him energy to write pages the third cup gives him energy to write pages the th cup gives him energy to write pages If Polycarp doesn t drink coffee during some day he cannot write coursework at all that day Polycarp has to finish his coursework as soon as possible spend the minimum number of days to do it Your task is to find out this number of days or say that it is impossible ,Well the main idea is described in the previous D1 problem editorial Read it firstly So now we have to improve our solution somehow How can we do it Wait What is it We iterate over all numbers of days And the number of pages Polycarp can write when we consider days instead of is strictly increases because we always can drink any cup even with the minimum value of as a first during the new day and the number of pages will increase So what is it Oh this is binary search So all we need is to replace linear search to binary search submit the written code and get AC 
There s a table of cells rows and columns The value of is even A domino is a figure that consists of two cells having a common side It may be horizontal one of the cells is to the right of the other or vertical one of the cells is above the other You need to place dominoes on the table so that exactly of them are horizontal and all the other dominoes are vertical The dominoes cannot overlap and must fill the whole table ,Suppose and are even A necessary and sufficient condition of existence of the answer is that is even Let s prove the sufficient condition If the count of the horizontal dominoes is even then we can combine them and vertical dominoes to blocks of size the number of the vertical dominoes is even too if is even If and are even we can fill the table with these blocks The description of the locations of the dominoes may be printed as follows consider the table is a chessboard where a cell is a block of two dominoes Consider the leftmost topmost cell of the board is black If a cell of the board is black let s mark one of the dominoes of the block with the letter and the other one with the letter If a cell of the board is white let s mark one of the dominoes of the block with the letter and the other one with the letter There will be no situation that some two cells of the table are marked with one letter but belong to different dominoes Let s prove the necessary condition The number of cells in a column is even so the number of cells that belong to vertical dominoes is even because cells of each vertical domino may be either belong to the column or not belong at the same time So the number of cells that belong to horizontal dominoes is even Let s cross out all cells that belong to vertical dominoes and let s find the leftmost column having cells that haven t been crossed out It s the leftmost column with such cells so the pairwise cells of the non crossed out cells belong to the column to the right of the found one The number of such cells in the right column is equal to the number of found cells so it s even and the number of found horizontal dominoes is even too Let s cross out the found cells and the pairwise cells The number of non crossed out cells in the right column will be even The number of crossed out horizontal dominoes will be even too Let s repeat this procedure until all the dominoes will be crossed out In every step we have crossed out the even number of horizontal dominoes hence the total count of horizontal dominoes is even Suppose is odd hence is even In this case every column contains an odd number of cells whereas the number of cells that belong to vertical dominoes is even So the number of cells that belong to horizontal dominoes is odd Consider the leftmost column and find a cell of it that belongs to a horizontal domino it must be found because the number of such cells is odd so it isn t equal to Let s find the pairwise cell and cross out both cells Currently the two columns will have an even number of non crossed out cells Let s repeat the procedure until all columns will have even non crossed out cells We will cross out cells and dominoes So the necessary condition is that the number of horizontal dominoes is at least Let s extend the necessary condition with the following condition the value of is even Consider the table that we ve become after the previous procedure where each column has exactly one crossed out cell Let s start the procedure we ve done in the case of even both and The procedure can be started on our table because each column of the table has an even number of non crossed out cells As a result of the procedure we will cross out an even count of horizontal dominoes so the value of is even Let s build an answer if the conditions and is even are met Let s place in the topmost row horizontal dominoes and mark their cells as follows the first domino will be marked with the second one with the third one with and so on As the result the region of rows and columns will be unfilled Both values are even and the value of is even too So let s fill the region as if it s a separate table having even numbers of rows and columns As it was proved above it s possible to do The set of letters used for the region and set of the letters used for the topmost row don t have common elements so there will be no cells that are marked with one letter but belong to different dominoes The case of odd hence is even is similar to the previous one let s transpose the table it will have rows and columns swap the values of and solve the case above and transpose the table back to have rows and columns 
 You are given an array consisting of integers In one move you can choose any and divide it by rounding down in other words in one move you can set You can perform such an operation possibly zero number of times with Your task is to calculate the minimum possible number of operations required to obtain at least equal numbers in the array ,In this problem we need to write almost the same solution as in the previous one easy version but faster Observe that we calculate the value of too many times Let for all from to be the array of numbers of divisions we need to obtain from every possible from which we can We can calculate these arrays in time How Let s iterate over all and divide it by while it is positive and carry the number of divisions Then let s add to the array the number before each division Then we can see that we obtain the array from the tutorial of the previous problem for each from to Let s iterate over all possible values of and try to update the answer with the sum of smallest values of if there is at least elements in this array Time complexity or depends on sorting method 
Vova s family is building the Great Vova Wall named by Vova himself Vova s parents grandparents grand grandparents contributed to it Now it s totally up to Vova to put the finishing touches The current state of the wall can be respresented by a sequence of integers with being the height of the th part of the wall Vova can only use bricks to put in the wall he has infinite supply of them however Vova can put bricks on the neighbouring parts of the wall of equal height It means that if for some the current height of part is the same as for part then Vova can put a brick there and thus increase both heights by 1 Obviously Vova can t put bricks in such a way that its parts turn out to be off the borders to the left of part of the wall or to the right of part of it Vova is a perfectionist so he considers the wall completed when all parts of the wall has the same height the wall has no empty spaces inside it Can Vova complete the wall using any amount of bricks possibly zero ,Fairly enough solutions of both versions of the problem are pretty similar Read the second part of the previous tutorial first This problem can also be implemented in the strightforward manner The greedy solution now is searching for the first minimum in array and putting a brick in there If it s impossible then the answer is This can also be simulated with sets a bit more tedious but still ok and also Now back to the stack approach Here you can t go to parities of the numbers like tests and lead to different results You push the number itself However you will also need an extra condition on the stack You can t push to it the number greater than the current topmost element The only problem with this are maximums of array Obviously the resulting wall if the answer exists will be of height equal to the maximum initial height And it means that you shouldn t care about the ability to match all maximums in stack They way I suggest to take around the issue is to process separately each segment between two consecutive maximums One can easily prove the correctness of it by construction Overall complexity 
Polycarp has an array of is even integers Polycarp conceived of a positive integer After that Polycarp began performing the following operations on the array take an index and reduce the number by After Polycarp performed some possibly zero number of such operations it turned out that of the numbers in the array became the same Find the maximum at which such a situation is possible or print if such a number can be arbitrarily large , can be arbitrarily large if and only if at least half of the numbers in the array are the same In this case we can choose any number and subtract it from all numbers for example exactly once Let s iterate over the element it will be the minimum among the numbers that we want to make the same Let s calculate the number of numbers in the array that are equal to this element If this number is at least then the answer is Otherwise we will iterate over numbers which are strictly greater than the selected minimum and for each number we will iterate over the divisors of the number For each of the found divisors let s calculate the number of for which this divisor was found Among all such divisors for which the sum of the found number and the number of numbers equal to is greater than or equal to we will choose the maximum one The greatest found divisor will be the desired This solution works in where is the absolute value of the maximum on the array 
 You are given a string and a string both consisting only of lowercase Latin letters It is guaranteed that can be obtained from by removing some possibly zero number of characters not necessary contiguous from without changing order of remaining characters in other words it is guaranteed that is a subsequence of For example the strings and are subsequences of the string But the strings are not subsequences of the string You want to remove some substring contiguous subsequence from of such that after removing this substring will remain a subsequence of If you want to remove the substring then the string will be transformed to where is the length of Your task is to find the maximum possible length of the substring you can remove so that is still a subsequence of ,Let be such rightmost position in that the substring is the subsequence of We need values for all from to We can calculate it just iterating from right to left over all characters of and maintaining the pointer to the string as in easy version Then let s iterate over all positions from to and maintain the pointer as in the easy version which tells us the maximum length of the prefix of we can obtain using only the substring exclusively Suppose we want to remove the substring of starting from Then if then let be otherwise let be tells us the farthest rightmost character of the substring we can remove So we can update the answer with the value and go to the next position and don t forget to increase if needed 
 You are given a string consisting of characters each character is or You are also given an integer Your task is to change the minimum number of characters in the initial string so that after the changes there will be a string of length that is a substring of and is also a substring of the infinite string A string is a substring of string if there exists a positive integer such that For example strings are substrings of the infinite string while and are not You have to answer independent queries ,In this problem you should make the same as in the previous one but faster Let s consider three offsets of string and Let s copy the current offset of the string so that it will has the length possibly without some trailing characters and save it in the string Then let s compare the string with this offset of length and build an array of length where if Then let s iterate over all possible continuous subsegments of this array and maintain the variable denoting the current answer Firstly for the current position let s add to Then if the current position is greater than or equal to indexed let s decrease by So now we have the continuous subsegment of the array of length no more than Then if the current position is greater than or equal to indexed again the current subsegment has the length then let s update the answer with Then let s do the same with two remaining offsets 
 You are given segments on the coordinate axis Segments can intersect lie inside each other and even coincide The th segment is and it covers all integer points such that The integer point is called if it is covered by than segments Your task is to remove the minimum number of segments so that there are no points at all ,In this problem we need to implement the same greedy solution as in the easy version but faster Firstly let s calculate for each point the number of segments covering it We can do it using standard trick with prefix sums increase decrease and build prefix sums on the array Let s maintain the set of segments that cover the current point sorted by the right endpoint We can do this with almost the same trick append to the array the index that says us that in the point the th segment is opened And add to the the index that says us that in the point the th segment is closed Note that you need to add indexed values because and are the same thing actually We can change the array to carry the number of segments covering each point using some structure but we don t need to do it Let s maintain the variable that will say us the number of segments covering the current point that was already removed Also let s carry another one array which will say us when we need to decrease the variable So we calculated the array of arrays the array and we can solve the problem now For the point let s remove and add all segments we need using the array and add to Now we know that the set of segments is valid is also valid and we can fix the current point if needed While let s repeat the following sequence of operations take the segment with the maximum right border from the set remove it increase by one and decrease by one Note that when we remove segments from the set at the beginning of the sequence of moves for the point we don t need to remove segments that we removed by fixing some previous points and we need to pay attention to it Time complexity 
A championship is held in Berland in which players participate The player with the number has tokens The championship consists of games which are played according to the following rules in each game two random players with non zero tokens are selected the player with more tokens is considered the winner of the game in case of a tie the winner is chosen randomly the winning player takes all of the loser s tokens The last player with non zero tokens is the winner of the championship All random decisions that are made during the championship are made equally probable and independently For example if then one of the options for the game there could be other options is during the first game the first and fourth players were selected The fourth player has more tokens so he takes the first player s tokens Now during the second game the fourth and third players were selected They have the same number of tokens but in a random way the third player is the winner Now during the third game the second and third players were selected The third player has more tokens so he takes the second player s tokens Now the third player is declared the winner of the championship Championship winners will receive personalized prizes Therefore the judges want to know in advance which players have a chance of winning i e have a non zero probability of winning the championship You have been asked to find all such players ,How can a player be checked if he can win the championship Obviously he must participate in all the games otherwise we will increase the number of tokens of the opponents So you can sort out all the people and play greedily with the weakest ones Such a check will work in linear time after sorting so we got a solution for The simplest solution to this problem is binary search for the answer We will sort all the players by the number of tokens they have Let s prove that if player can win then player can also win the numbers are dealt after sorting If the player was able to win then based on the strategy above he was able to defeat all the players on the prefix The player can also defeat all these players since he has at least as many tokens Now both players have to defeat all opponents with numbers and the number of chips both players have is equal to the sum of the first numbers in the array So if the player has a strategy then the player can use the same strategy Hence the answer to the problem is sorted suffix of the input array You can find this suffix using binary search and linear time checking Bonus this problem also has a fully linear after sorting solution 
You are given an array of integers You can apply the following operation an arbitrary number of times select an index and replace the value of the element with the value where is the remainder of the integer dividing by For a single index value this operation can be applied multiple times If the operation is applied repeatedly to the same index then the current value of is taken into account each time For example if then after the first operation we get and after the second operation we get Check if it is possible to make array elements equal by applying multiple possibly zero operations For example you have an array Let s apply this operation to the first element of the array Let s replace with We get the array Then apply this operation to the second element of the array Let s replace with We get the array Thus by applying operations you can make all elements of an array equal ,Let s see which remainders modulo change into which ones If the array contains a number divisible by then it cannot be changed If there is a number that has a remainder of modulo then it can only be replaced once Thus if the array contains a number divisible by then we apply this operation to all elements of the array once and check that all its elements are equal The remaining odd balances immediately turn into even ones The even remainders change in a cycle while the array element increases by in operations Thus we will apply the operation to each element of the array until its remainder modulo becomes for example and then check that the array does not contain both remainders and modulo 
Masha works in an advertising agency In order to promote the new brand she wants to conclude contracts with some bloggers In total Masha has connections of different bloggers Blogger numbered has followers Since Masha has a limited budget she can only sign a contract with different bloggers Of course Masha wants her ad to be seen by as many people as possible Therefore she must hire bloggers with the maximum total number of followers Help her find the number of ways to select bloggers so that the total number of their followers is maximum possible Two ways are considered different if there is at least one blogger in the first way which is not in the second way Masha believes that all bloggers have different followers that is there is no follower who would follow two different bloggers For example if then Masha has two ways to select bloggers with the maximum total number of followers conclude contracts with bloggers with numbers and In this case the number of followers will be equal to conclude contracts with bloggers with numbers and In this case the number of followers will be equal to Since the answer can be quite large ,It is obvious that Masha will enter into agreements only with bloggers that have the most subscribers You can sort all the bloggers and greedily select the prefix Let be the minimum number of subscribers for the hired blogger Then we must hire all the bloggers who have more subscribers Let the number of bloggers who have more than subscribers the number of bloggers who have exactly subscribers Then we should select bloggers from The number of ways to do this is equal to the binomial coefficient of by You could calculate it by searching for the inverse element modulo Then you could calculate the factorials and use the equality Alternatively you can use the equation and calculate it using dynamic programming This method is better known as the Pascal triangle 
You are given a bracket sequence consisting of opening and closing brackets A bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences are regular the resulting expressions are and and are not You can change the type of some bracket It means that if then you can change it to and vice versa Your task is to calculate the number of positions such that if you change the type of the th bracket then the resulting bracket sequence becomes ,In this problem we have to calculate the number of positions such that if we change the type of the bracket at this position then the obtained bracket sequence will become regular Let s calculate the balance of each prefix of the bracket sequence and store it in the array Just iterate from left to right over the string and if the current bracket is opening then increase the current balance by one otherwise decrease it by one For each prefix let s also calculate whether it can be a prefix of a regular bracket sequence RBS and store it in the array The prefix of length can be the prefix of RBS if and only if the prefix of length can be the prefix of RBS and Let s calculate the same arrays for all suffixes and call they and correspondingly but now the closing bracket will increase the balance by one and the opening will decrease it by one and we consider the characters from right to left Now if we have these arrays let s iterate over all positions in the initial bracket sequence If we now at the position then let s do the following things firstly if or then skip this position Otherwise if the current bracket is opening then we have to increase the answer if and only in this case the bracket sequence will become regular And if the current bracket is closing then we have to increase the answer if 
You are playing the game Arranging The Sheep The goal of this game is to make the sheep line up The level in the game is described by a string of length consisting of the characters empty space and sheep In one move you can move any sheep one square to the left or one square to the right if the corresponding square The game ends as soon as the sheep are lined up that is there should be no empty cells between any sheep For example if and the level is described by the string then the following game scenario is possible the sheep at the position moves to the right the state of the level the sheep at the position moves to the right the state of the level the sheep at the position moves to the right the state of the level the sheep at the position moves to the right the state of the level the sheep at the position moves to the right the state of the level the sheep are lined up and the game ends For a given level determine the minimum number of moves you need to make to complete the level ,Let s denote by the number of sheep in the string and by their positions in the string Note that in the optimal solution the sheep with the number will not make moves This can be proved by considering the optimal solution in which the sheep with the number makes at least one move and come to the conclusion that this solution is not optimal Consider sheep with numbers from to Then the final position of the th sheep will be and the answer will be 
You are given two huge binary integer numbers and of lengths and respectively You will repeat the following process if then add to the answer the value and divide by rounding down i e remove the last digit of and repeat the process again otherwise stop the process The value means bitwise of and Your task is to calculate the answer modulo Note that you should add the value to the answer in decimal notation not in binary So your task is to calculate the answer in decimal notation For example if and then the value will be equal to not to ,To solve this problem let s take a look which powers of in will be affected by powers of in Firstly let s reverse numbers Let s carry the current power of let it be the current sum of powers of in from the position to the current position inclusive let it be and the answer is Initially and Let s iterate over all bits of from to Let the current bit in have the number Firstly if and then set in other words we add to the sum of powers of in the current power of If then this bit will add to the answer all the powers of in from to inclusive in other words so if it is then set And after all we can set and go on to And don t forget to take all values modulo to avoid overflow 
There are boxers the weight of the th boxer is Each of them can change the weight by no more than before the competition the weight cannot become equal to zero that is it must remain positive Weight is always an integer number It is necessary to choose the largest boxing team in terms of the number of people that all the boxers weights in the team are different i e unique Write a program that for given current values will find the maximum possible number of boxers in a team It is possible that after some change the weight of some boxer is but no more ,Let be the last weight of the boxer taken into the team Initially Let s sort all boxers in order of non increasing their weights and iterate over all boxers in order from left to right If the current boxer has the weight then let s try to take him with weight we can do it if If we cannot do it let s try to take him with weight And in case of fault let s try to take him with weight If we cannot take him even with weight then let s skip him And if we take him let s replace with him weight The answer is the number of boxers we took 
Monocarp plays Rage of Empires II Definitive Edition a strategic computer game Right now he s planning to attack his opponent in the game but Monocarp s forces cannot enter the opponent s territory since the opponent has built a wall The wall consists of sections aligned in a row The th section initially has durability If durability of some section becomes or less this section is considered broken To attack the opponent Monocarp needs to break at least two sections of the wall any two sections possibly adjacent possibly not To do this he plans to use an onager a special siege weapon The onager can be used to shoot any section of the wall the shot deals damage to the target section and damage to adjacent sections In other words if the onager shoots at the section then the durability of the section decreases by and the durability of the sections and if they exist decreases by each Monocarp can shoot at any sections any number of times Monocarp wants to calculate the minimum number of onager shots needed to break at least two sections Help him ,Let s analyze three cases based on the distance between two sections we are going to break break two neighboring sections and break two sections with another section between them and break two sections with more than one section between them Why exactly these cases Because the damage from the shots and the possibility to hit both sections with the same shot depends on the distance between them If there is more than one section between the two we want to break then any shot hits only one of these sections so each shot should be aimed at one of those sections and we break them independently Let s pick two sections with minimum durability and calculate the number of shots required to break them if these sections are and then the required number of shots is It actually does not matter if the distance between them is less than if it is so these sections will be analyzed in one of the other cases Okay now let s deal with two sections having exactly one section between them We can iterate on all combinations of these sections iterate on from to and pick sections and Let s analyze how can we damage them If we shoot at the section between them we deal damage to both sections if we shoot at one of those sections we deal damage to it and damage to the other section So each shot distributes damage between these two sections the way we want to distribute it and the number of shots required to break these two sections is The case when we try to break two adjacent sections is the trickiest one Let s say that these sections are and and If we target one of these sections we deal damage to it and damage to the other section Let s try to run the following algorithm shoot at the section with higher durability until both of them break It can be slow but we can see that after the first shots the durabilities of the sections become equal and each pair of shots after that deals damage to both sections So we can model the first shots subtract from and from and then we ll need shots The only case when this doesn t work is if we break both sections before we equalize their durabilities it means that and we need to do only shots 
The busses in Berland are equipped with a video surveillance system The system records information about changes in the number of passengers in a bus after stops If is the number of passengers in a bus just before the current bus stop and is the number of passengers in the bus just after current bus stop the system records the number So the system records show how number of passengers changed The test run was made for single bus and bus stops Thus the system recorded the sequence of integers exactly one number for each bus stop where is the record for the bus stop The bus stops are numbered from to in chronological order Determine the number of possible ways how many people could be in the bus before the first bus stop if the bus has a capacity equals to that is at any time in the bus there should be from to passengers inclusive ,Firstly we should find the minimum and maximum numbers of passengers which could be in a bus if initially it was empty Let We should iterate through the bus stops For the th bus stop we add to and update with a value of the minimum number of passengers and the maximum number of passengers If it is an invalid case and we should print because the maximum number of passengers should be less or equal to Let is a minimum possible number of passengers in the bus before the first stop and maximum possible If then in the bus initially were at least passengers Because we should make else If then else After that we should compare and If print In the other case print because each of those values is correct 
You are planning to buy an apartment in a floor building The floors are numbered from to from the bottom to the top At first for each floor you want to know the minimum total time to reach it from the first the bottom floor Let for all from to be the time required to go from the th floor to the th one and from the th to the th as well using the for all from to be the time required to go from the th floor to the th one and from the th to the th as well using the also there is a value time overhead for elevator usage you need to wait for it the elevator doors are too slow In one you can go from the floor you are staying at to any floor in two different ways If you are using the stairs just sum up the corresponding values of Formally it will take time units If you are using the elevator just sum up and the corresponding values of Formally it will take time units You can perform as many as you want possibly zero So your task is for each to determine the minimum total time it takes to reach the th floor from the st bottom floor ,This is easy dynamic programming problem It is easy to understand that we don t need to go down at all otherwise your solution will be Dijkstra s algorithm not dynamic programming Let be the minimum required time to reach the floor if we not in the elevator right now and be the minimum required time to reach the floor if we in the elevator right now Initially all values are except and Transitions are pretty easy we was not in the elevator and going to the next floor using stairs we was in the elevator and going to the next floor using stairs we was not in the elevator and going to the next floor using elevator we was in the elevator and going to the next floor using elevator The answer for the th floor is Time complexity 
You are given two integers and You have a chessboard of size with the top left cell at the cell is painted Your task is to find a connected component on this chessboard that contains exactly black cells and exactly white cells Two cells are called connected if they share a side i e for the cell there are at most four connected cells A set of cells is called a connected component if for every pair of cells and from this set there exists a sequence of cells such that all from to are belong to this set of cells and for every cells and are connected Obviously it can be impossible to find such component In this case print Otherwise print and suitable connected component You have to answer independent queries ,I ll consider the case when the other case is symmetric and the answer I construct is the same but shifted by to the right Consider the given field as a matrix where is the number of row and is the number of column Firstly let s build the line of length from the cell to the cell Then will decrease by and will become Then we have two black cells to the left and to the right and and black cells to the up all cells for all from to and black cells to the down all cells for all from to Let s add the required number of cells to the answer If even after adding all these cells still be greater than then the answer is maybe there will be a proof why it is so but you can read it already from other participants Otherwise the answer is and we constructed the required component 
You are given two integers and You need to construct a rooted binary tree consisting of vertices with a root at the vertex and the sum of depths of all vertices equals to A tree is a connected graph without cycles A rooted tree has a special vertex called the root A parent of a vertex is the last different from vertex on the path from the root to the vertex The depth of the vertex is the length of the path from the root to the vertex Children of vertex are all vertices for which is the parent The binary tree is such a tree that no vertex has more than children You have to answer independent test cases ,This problem has an easy constructive solution We can find lower and upper bounds on the value of for the given If the given does not belong to this segment then the answer is Otherwise the answer is for any in this segment How to construct it Let s start from the chain The answer for the chain is the upper bound of and it is Then let s try to decrease the answer by in one move Let s take some leaf the vertex without children with the smallest depth that is not and try to move it up The definition of badness will be below To do this let s find such vertex that its depth is less than the depth of by and it has less than children If we found such vertex then let s make the child of and decrease the answer by one If we didn t find such vertex I claim that the vertex has the minimum possible depth it can have and we should not consider it in the future Let s mark this vertex as and continue our algorithm If at some moment we cannot find any not leaf then the answer is Otherwise the answer is Time complexity 
Polycarp has invited friends to celebrate the New Year During the celebration he decided to take a group photo of all his friends Each friend can stand or lie on the side Each friend is characterized by two values their height and their width On the photo the th friend will occupy a rectangle if they are standing or if they are lying on the side The th friend can be placed in front of the th friend on the photo if his rectangle is lower and narrower than the rectangle of the th friend Formally of the following conditions must be fulfilled both friends are standing or both are lying one of the friends is standing and the other is lying For example if and then the first friend can be placed in front of the second and one of the them is standing and the other one is lying the third friend can be placed in front of the second and both friends are standing or both are lying In other cases the person in the foreground will overlap the person in the background Help Polycarp for each find any such that the th friend can be located in front of the th friend i e at least one of the conditions above is fulfilled Please note that you do not need to find the arrangement of all people for a group photo You just need to find for each friend any other friend who can be located in front of him Think about it as you need to solve separate independent subproblems ,Let s sort all people by their height in descending order Now let s go through all the people and look for the position of the person in the sorted array the height of which is strictly less than ours for example by binary search Obviously only those people who are in the sorted array later than the found person can stand in front of us all of them have a height strictly less than ours Among all these people it is more profitable for us to take a person with minimum width In order to find such a person quickly we can find a person with the minimum width for each suffix of the sorted array To handle a situation where a person is lying down we need to swap the width and height and repeat the algorithm above 
You are given an undirected unweighted connected graph consisting of vertices and edges It is guaranteed that there are no self loops or multiple edges in the given graph Your task is to choose vertices in this graph so unchosen vertex is adjacent in other words connected by an edge to at least one of chosen vertices It is guaranteed that the answer exists If there are multiple answers you can print any You will be given multiple independent queries to answer ,Firstly let s run bfs on the given graph and calculate distances for all vertices In fact we don t need distances we need their parities The second part is to find all vertices with an even distance all vertices with and odd distance and print the smallest by size part Why is it always true Firstly it is obvious that at least one of these sizes will not exceed And secondly because we are checking just parities of distances it is obvious that each vertex of some parity is connected with at least one vertex of the opposite parity because it has this parity from some vertex of the opposite parity 
You are given an undirected graph consisting of vertices and edges Your task is to find the number of connected components which are cycles Here are some definitions of graph theory An undirected graph consists of two sets set of nodes called vertices and set of edges Each edge connects a pair of vertices All edges are bidirectional i e if a vertex is connected with a vertex a vertex is also connected with a vertex An edge can t connect vertex with itself there is at most one edge between a pair of vertices Two vertices and belong to the same connected component if and only if there is at least one path along edges connecting and A connected component is a cycle if and only if its vertices can be reordered in such a way that the first vertex is connected with the second vertex by an edge the second vertex is connected with the third vertex by an edge the last vertex is connected with the first vertex by an edge all the described edges of a cycle are distinct A cycle doesn t contain any other edges except described above By definition any cycle contains three or more vertices ,Let s solve this problem for each connected component of the given graph separately It is easy to see that the connected component is a cycle iff the degree of each its vertex equals to So the solution is to count the number of components such that every vertex in the component has degree The connected components of the graph can be easily found by simple dfs or bfs 
You are given a graph consisting of vertices and edges It is not guaranteed that the given graph is connected Some edges are already directed and you can t change their direction Other edges are undirected and you have to choose some direction for all these edges You have to direct undirected edges in such a way that the resulting graph is directed and acyclic i e the graph with all edges directed and having no directed cycles Note that you have to direct undirected edges You have to answer independent test cases ,Firstly if the graph consisting of initial vertices and only directed edges contains at least one cycle then the answer is Otherwise the answer is always Let s build it Let s build the topological sort of the graph without undirected edges Then let s check for each directed edge if it s going from left to right in order of topological sort If it isn t true then there is a cycle and the answer is Otherwise let s direct each edge from left to right in order of the topological sort 
You are given an integer from to without leading zeroes In one move you can swap any two adjacent digits in the given number in such a way that the resulting number will not contain leading zeroes In other words the number you have cannot contain any leading zeroes What is the minimum number of moves you have to make to obtain a number that is divisible by Print if it is impossible to obtain a number that is divisible by ,Let s iterate over all pairs of digits in the number Let the first digit in the pair be at position and the second at position Let s place these digits to the last two positions in the number The first greedily goes to the last position and then the second goes to the position next to that Now the number can contain a leading zero Find the leftmost non zero digit and move it to the first position Then if the current number is divisible by try to update the answer with the number of swaps It is easy to show that the number of swaps is minimal in this algorithm The only difference we can introduce is the number of times digit digit and the leftmost non zero digit swap among themselves And that is minimized You can also notice that the order of swaps doesn t matter and you can rearrange them in such a way that no leading zero appears on any step This solution has time complexity You can also solve this problem with complexity because you have to check only four options of the two last digits It is always optimal to choose both rightmost occurrences of the corresponding digits You can show that even if you are required to swap the chosen ones there will be no other pair with smaller total amount of moves 
Consider a sequence of integers In one move you can select any element of the sequence and delete it After an element is deleted all elements to the right are shifted to the left by position so there are no empty spaces in the sequence So after you make a move the sequence s length decreases by The indices of the elements after the move are recalculated E g let the sequence be Let s select the element in a move Then after the move the sequence will be equal to so the rd element of the new sequence will be and the th element will be You are given a sequence and a number You need to find the minimum number of moves you have to make so that in the resulting sequence there will be elements that are equal to their indices i e the resulting sequence will contain at least indices such that ,Let s use the concept of dynamic programming Let s create an array indexed with size of will contain the maximal number of the elements equal to their indices if we have considered the first elements of the sequence and have elements Let s fill the array with zeroes then we will increase the elements of the array for different and Let s start the loop with parameter from to and the internal one with parameter from to Consider an element We can delete or not delete it If we delete this element the number of the elements equal to their indices will not be increased and the number of the non deleted element will not be increased too It means that the answer for may be updated with Since we are interested in a maximum answer we rewrite only if is greater than Suppose we don t delete this element We haven t deleted previously elements so will have the index and there will be non deleted elements if we consider elements so we must update If i e an element equal to its index is found let s update with Otherwise we should update it with Remember that update may be done only if we rewrite the less value with the greater value Let s build the answer as follows We need to minimize the number of deleted elements maximize the number of non deleted elements so that the number of the elements equal to their indices is at least Consider only the elements of having the first index Let s start a loop in the descending order of If is the maximum number of elements that we will not delete so the answer is If we will not find such that there s no desired sequence of moves so the answer is The algorithm works in 
Polycarp came up with a new programming language There are only two types of statements in it assign the variable named the value where is a string For example the statement assigns the variable named the value Note that is the value of a string not the name of a variable Between the variable name the operator and the string contains exactly one space each assign the variable named the concatenation of values of two variables and For example if the program consists of three statements then the variable will contain the string It is guaranteed that the program is correct and the variables and were previously defined There is exactly one space between the variable names and the and operators All variable names and strings only consist of lowercase letters of the English alphabet and do not exceed characters The result of the program is the number of occurrences of string in the string that was written to the variable in the last statement Polycarp was very tired while inventing that language He asks you to implement it Your task is for given program statements calculate the number of occurrences of string in the last assigned variable ,We can t model this process directly since the maximum string length reaches look at the second example from the statements To optimize this process you can store each row as a set of the following values Number of occurrences of in the string String length The first three characters of the string are The last three characters of the string are Then to process the second type of request and combine the two strings and into the string you need New occurrences may be added at the junction of two words However if the string length is less than then you need to handle this case carefully with your hands Similarly you need to process small strings separately 
A tree is an undirected connected graph in which there are no cycles This problem is about non rooted trees A leaf of a tree is a vertex that is connected to vertex The gardener Vitaly grew a tree from vertices He decided to trim the tree To do this he performs a number of operations In one operation he removes leaves of the tree For example consider the tree shown in the figure above The figure below shows the result of applying exactly one operation to the tree Note the special cases of the operation applying an operation to an empty tree of vertices does not change it applying an operation to a tree of one vertex removes this vertex this vertex is treated as a leaf applying an operation to a tree of two vertices removes both vertices both vertices are treated as leaves Vitaly applied operations sequentially to the tree How many vertices remain ,Let s create two arrays of length The element of the array will contain the operation number at which the vertex which is the index of the array will be deleted The array will contain the number of neighbors of a given vertex at a certain time This array must be initialized with the number of neighbors in the original tree Initially we will suppose that the gardener performs an infinite number of operations and we will simply calculate for each vertex the number of the operation on which it will be deleted Let s create a queue which will store the order of deleting vertices The queue will contain only those vertices whose neighbors except maybe one have been removed i e Let s add all leaves of the original tree to it for each of them let s store the value in the array because all original leaves will be removed during the first operation Next we will take sequentially one vertex from the queue and update the data about its neighbors Consider the neighbors Since we are deleting the current vertex we need to update of its neighbors If the neighbor s is equal to then it s already in the queue and it doesn t need to be considered right now Otherwise we will decrease the neighbor s by If it becomes equal to then the neighbor must be added to the queue The number of the operation during which the neighbor will be deleted is equal to the number of the operation during which the current vertex will be deleted plus After we calculate the numbers of operations for all vertices we need to select among them those that will not be deleted during operations with numbers Thus the answer is the number of vertices such that 
You are a coach at your local university There are students under your supervision the programming skill of the th student is You have to form teams for yet another new programming competition As you know the more students are involved in competition the more probable the victory of your university is So you have to form no more than and at least one teams so that the number of students in them is maximized But you also know that team should be It means that the programming skill of each pair of students in team should differ by no more than Teams are independent from one another it means that the difference between programming skills of two students from two different teams does not matter It is possible that some students not be included in any team at all Your task is to report the maximum possible number of students in no more than and at least one teams ,Firstly let s sort all students in order of non decreasing their programming skill Then let s calculate the following dynamic programming is the maximum number of students in at most non empty teams if we consider first students How to do transitions from The first transition is pretty intuitive just skip the th indexed student Then we can set The second possible transition is to take some team starting from the th student The only assumption we need to do it is the following take the maximum by number of students team starting from the th student is always optimally Why it is so If we consider the student with the maximum programming skill in the team we can take him to this team instad of forming the new team with this student because this is always not worse So the second transition is the following let be the number of students in a team if the th student is the first in it We can calculate this part in naively or in using two pointers We can set Time complexity 
You are given a garland consisting of lamps States of the lamps are represented by the string of length The th character of the string equals if the th lamp is turned off or if the th lamp is turned on You are also given a positive integer In one move you can choose and change its state i e turn it on if it is turned off and vice versa The garland is called periodic if the distance between is Consider the case Then garlands and are good but garlands and are not Note that i e the first turned on lamp is not going after the last turned on lamp and vice versa Your task is to find the number of moves you need to make to obtain periodic garland from the given one You have to answer independent test cases ,Let be the string containing all characters of that have indices and so on i e all such positions that have the remainder modulo Suppose we choose that all turned on lamps will have remainder modulo Then we need to remove all ones at the positions that do not belong to this remainder Also considering the string we need to spend the number of moves to make this string of kind contiguous block of zeros contiguous block of ones and again contiguous block of zeros because considering the characters modulo will lead us to exactly this pattern notice that some blocks can be empty How to calculate the answer for the string in linear time Let be the number of moves we need to fix the prefix of till the th character in a way that the th character of is Let be the number of ones in on the segment Notice that we can calculate all required values in linear time using prefix sums Then we can calculate as where is the boolean value of the expression if is true and otherwise Let be the length of Then the actual answer for the string can be calculated as thus we consider the case when the obtained string doesn t contan ones at all and consider each position as the last position of some one So the actual answer can be calculated as Time complexity 
In Japan the number reads like death so Bob decided to build a contains all natural numbers that do not contain the digit For example the number is part of the sequence but the numbers are not part of the sequence Bob realized that he does not know how to quickly search for a particular number by the position in the sequence so he asks for your help For example if Bob wants to find the number at position indexing from you need to answer ,Note that any number in the sequence can be made up of possible digits all digits except Then let s find the first digit of the answer notice that it is just or where where the length of the number we re looking for and the maximum Note that simply corresponds to a digit in the base numeral system Why is this so Because without the first digit we can assemble any numbers with possible digits and we can put the digits except in the first place Thus in the answer the first digit will be if and if Note that once the first digit is determined the rest can be found the same way since the prefix does not affect anything 
Masha meets a new friend and learns his phone number She wants to remember it as soon as possible The phone number is a string of length that consists of digits from to The phone number may start with Masha already knows phone numbers all numbers have the same length It will be easier for her to remember a new number if the is represented as segments of numbers she already knows Each such segment must be of length otherwise there will be too many segments and Masha will get confused For example Masha needs to remember the number and she already knows numbers You can represent as a segment of number one of number two and of number three There are other ways to represent Masha asks you for help she asks you to break the string into segments of length or more of the numbers she already knows If there are several possible answers print of them ,The key idea is that any string of length greater than 3 can be obtained by concatenating strings of length or Then when reading the data remember all occurring substring of length and There are at most Now we will count the dynamics on the prefix if we can get the prefix of length of phone by segments of length and of the known phones Masha Then for the transition we need to look through the lengths and then take a substring of the corresponding length and find out whether such a string occurred in the phones known to Masha Then it will take or time to recalculate the dynamics depending on the implementation But it will still take more time to read the data so the final asymptotic will be or 
You are given a binary matrix of size Rows are numbered from top to bottom from to columns are numbered from left to right from to The element located at the intersection of row and column is called Consider a set of operations Cyclically shift all rows up The row with index will be written in place of the row the row with index will be written in place of the row Cyclically shift all rows down The row with index will be written in place of the row the row with index will be written in place of the row Cyclically shift all columns to the left The column with index will be written in place of the column the column with index will be written in place of the column Cyclically shift all columns to the right The column with index will be written in place of the column the column with index will be written in place of the column You can perform an arbitrary possibly zero number of operations on the matrix the operations can be performed in any order After that you can perform an arbitrary possibly zero number of new xor operations Select any element and assign it with new value In other words the value of will have to be written into element Each application of this xor operation costs one burl Note that the shift operations are free These operations can only be performed before xor operations are performed Output the minimum number of burles you would have to pay to make the matrix unitary A is a matrix with ones on the main diagonal and the rest of its elements are zeros that is if and otherwise ,Count to the variable the number of all ones in the matrix Then consider pairs of diagonals one of which starts in cell and the other in cell for Using cyclic shifts we can assemble the main diagonal from this pair Then among all such pairs and the main diagonal find the one that contains the maximal number of ones and store this number in the variable The number of zeros on the main diagonal which should be turned into ones is equal to The number of ones to be turned into zeros because they are not on the main diagonal is calculated as The total answer is calculated as 
You are given two strings and both consisting of exactly lowercase Latin letters is lexicographically less than Let s consider list of all strings consisting of exactly lowercase Latin letters lexicographically not less than and not greater than including and in lexicographical order For example for and the list will be Your task is to print the median the middle element of this list For the example above this will be ,This problem supposed to be Let s represent our strings as huge numbers with base Let be and be So if we will see more precisely in the problem statement then we can see that the answer is The operation with long numbers can be done in and division long number by two also can be done in All details of implementation are in the author s solution 
Dmitry has an array of non negative integers In one operation Dmitry can choose any index and increase the value of the element by He can choose the same index multiple times For each from to determine whether Dmitry can make the of the array equal to exactly If it is possible then determine the minimum number of operations to do it The of the array is equal to the minimum non negative integer that is not in the array For example the of the array is equal to and the array is equal to ,First let s sort the array Then we will consider its elements in non decreasing order To make MEX equal to you need to increase all zeros To make MEX at least you first need to make MEX at least and then if the number is missing in the array you need to get it If there are no extra values less than then this and all subsequent MEX values cannot be obtained Otherwise you can use the maximum of the extra array values To do this you can use a data structure such as a stack If an element occurs more than once in the array put its extra occurrences on the stack 
In this problem you will have to help Berland army with organizing their command delivery system There are officers in Berland army The first officer is the commander of the army and he does not have any superiors Every other officer has exactly one direct superior If officer is the direct superior of officer then we also can say that officer is a direct subordinate of officer Officer is considered to be a subordinate direct or indirect of officer if one of the following conditions holds officer is the direct superior of officer the direct superior of officer is a subordinate of officer For example on the picture below the subordinates of the officer are The structure of Berland army is organized in such a way that every officer except for the commander is a subordinate of the commander of the army Formally let s represent Berland army as a tree consisting of vertices in which vertex corresponds to officer The parent of vertex corresponds to the direct superior of officer The root which has index corresponds to the commander of the army Berland War Ministry has ordered you to give answers on queries the th query is given as where is some officer and is a positive integer To process the th query imagine how a command from spreads to the subordinates of Typical DFS depth first search algorithm is used here Suppose the current officer is and he spreads a command Officer chooses one of his direct subordinates i e a child in the tree who has not received this command yet If there are many such direct subordinates then chooses the one having minimal index Officer gives a command to officer Afterwards uses exactly the same algorithm to spread the command to its subtree After finishes spreading the command officer chooses the next direct subordinate again using the same strategy When officer cannot choose any direct subordinate who still hasn t received this command officer finishes spreading the command Let s look at the following example If officer spreads a command officers receive it in the following order If officer spreads a command officers receive it in the following order If officer spreads a command officers receive it in the following order If officer spreads a command officers receive it in the following order To answer the th query construct a sequence which describes the order in which officers will receive the command if the th officer spreads it Return the th element of the constructed list or if there are fewer than elements in it You should process queries independently A query doesn t affect the following queries ,Let s form the following vector we run DFS from the first vertex and push the vertex to the vector when entering this vertex Let be the position of the vertex in the vector the size of the vector in moment we call DFS from the vertex and be the position of the first vertex pushed to the vector after leaving the vertex the size of the vector in moment when we return from DFS from the vertex Then it is obvious that the subtree of the vertex lies in half interval After running such DFS we can answer the queries Let answering the th query If is greater than or equal to then answer to the th query is We need to check if the vertex lies in the subtree of the vertex The vertex is in the subtree of the vertex if and only if If the vertex is not in the subtree of the vertex then answer is Otherwise the answer is Overall complexity is 
You are given a forest an undirected graph with vertices such that each its connected component is a tree The diameter aka longest shortest path of a connected undirected graph is the maximum number of edges in the path between any pair of its vertices You task is to add some edges possibly zero to the graph so that it becomes a tree and the diameter of the tree is minimal possible If there are multiple correct answers print any of them ,Let s start with the solution and then proceed to the proof For each tree in a forest find such a vertex that the maximal distance from it to any vertex is minimal possible a center of a tree Tree may include two centers take any of them in that case Find the the tree with the maximum diameter Connect the centers of other trees with its center Overall complexity is the complexity of looking for a diameter or The center is the best vertex in a tree to connect to The diameter of merging two trees and by in and in with being the maximum shortest path from to any other vertex in being the same for in is Thus minimizing both and will produce the best result The most optimal structure is a star The center tree will be connected directly to any other tree The other trees will be connected through a single vertex among each other which leads to the answer no more than 1 worse than connecting them directly And building the answer the other way will exceed this difference as some tree will be connected to the center tree of the star through one vertex as well The previous fact implies that the center tree of the star should have the maximal diameter among all trees 
You are given two arrays and both of length All elements of both arrays are from to You can reorder elements of the array if you want you may leave the order of elements as it is After that let array be the array of length the th element of this array is where is modulo Your task is to reorder elements of the array to obtain the minimum possible array Array of length is lexicographically less than array of length if there exists such that and for any ,Let s maintain all elements of the array b in a set that allows multiple copies of equal elements for C Then let s iterate from left to right over the array a and try to minimize the current element in array c This order will minimize the resulting array by lexicographical comparing definition So for the i th element a i let s find the minimum element greater than or equal to n a i in the set because n a i will give us remainder 0 n a i 1 will give us remainder 1 and so on If there is no greater or equal element in the set then let s take the minimum element of the set and take it as a pair for a i otherwise let s take this greater or equal element and remove it from the set Time complexity O n log n 
You are given an array consisting of integers Let s denote of array as an array consisting of integers such that all of the following conditions are met for every pair of indices and such that if then note that if it is still possible that for every index either or For example if then two possible monotonic renumerations of are and Your task is to calculate the number of different monotonic renumerations of The answer may be large so print it modulo ,We are interested in such subsegments of the array that for every value belonging to this segment all occurences of this value in the array are inside this segment Let s call such segments For example if then and are closed segments We can see that the result is some partition of the given array into several closed segments if for some value all occurences of in do not form a segment in then there exists some pair such that which contradicts the statement and if the formed segment is not a closed segment then for some indices and such that it is not true that which also contradicts the statement Okay let s try to partition the array into closed segments greedily take the first prefix of the array that is a closed segment erase it take the next prefix and so on Let be the number of closed segments we got with this procedure The key fact is that To prove it suppose we partitioned the array in some other way The intersection of two closed segments if it exists is also a closed segment so there exists at least one segment in the partition we picked greedily that can be broken into two but that contradicts the algorithm we used to construct this partition So we may merge some of segments to get a valid partition There are exactly ways to do so because for every pair of adjacent segments we may choose whether we will merge it 
You are given an array consisting of integers In one move you can jump from the position to the position if or to the position if For each position from to you want to know the minimum the number of moves required to reach any position such that has the opposite parity from i e if is odd then has to be even and vice versa ,In this problem we have directed graph consisting of vertices indices of the array and at most edges Some vertices have the value some have the value Our problem is to find for every vertex the nearest vertex having the opposite parity Let s try to solve the problem for odd numbers and then just run the same algorithm with even numbers We have multiple odd vertices and we need to find the nearest even vertex for each of these vertices This problem can be solved with the standard and simple but pretty idea Let s inverse our graph and run a multi source breadth first search from all even vertices The only difference between standard bfs and multi source bfs is that the second one have many vertices at the first step vertices having zero distance Now we can notice that because of bfs every odd vertex of our graph has the distance equal to the minimum distance to some even vertex in the initial graph This is exactly what we need Then just run the same algorithm for even numbers and print the answer Time complexity 
The store sells beads The color of each bead is described by a lowercase letter of the English alphabet You want to buy some beads to assemble a necklace from them A necklace is a set of beads connected in a circle For example if the store sells beads then you can assemble the following necklaces these are not all possible options And the following necklaces cannot be assembled from beads sold in the store We call a necklace beautiful if when it is turned clockwise by beads the necklace remains unchanged For example here is a sequence of three turns of a necklace As you can see this necklace is for example beautiful beautiful beautiful and so on but it is not beautiful or beautiful In particular a necklace of length is beautiful for any integer A necklace that consists of beads of the same color is also beautiful for any You are given the integers and and also the string containing lowercase letters of the English alphabet each letter defines a bead in the store You can buy any subset of beads and connect them in any order Find the maximum length of a beautiful necklace you can assemble ,Let s iterate over the length of the beautiful necklace For each position make an edge to the position where is the remainder of dividing by What is a cyclic shift by in this construction A bead located at position will go along the edge to position Consider all the cycles of a graph constructed on You may notice that if only equal letters are found in each cycle then with a cyclic shift by the graph and the string will remain unchanged Thus in order to check whether it is possible to make a beautiful necklace of length you need to make a graph find the cycles in it and check whether it is possible to distribute the letters from the string in cycles such that each cycle have equal letters The last part of the solution can be done with simple greedy 
Oh New Year The time to gather all your friends and reflect on the heartwarming events of the past year friends live in a city which can be represented as a number line The th friend lives in a house with an integer coordinate The th friend can come celebrate the New Year to the house with coordinate or stay at Each friend is allowed to move no more than once For all friends holds however they can come to houses with coordinates and if their houses are at or respectively For example let the initial positions be The final ones then can be and so on The number of occupied houses is the number of distinct positions among the final ones So all friends choose the moves they want to perform After that the number of occupied houses is calculated What is the minimum and the maximum number of occupied houses can there be ,At first treat the two subtasks as completely independent problems For both solutions the array of frequences is more convinient to use so let s build it is the number of friends living in house 1 MinimumCollect the answer greedily from left to right If then proceed to otherwise add to the answer and proceed to To prove that let s maximize the number of merges of houses instead of minimizing the actual count of them It s easy to show that the final number of houses is the initial one minus the number of merges So if there are people in all consecutive houses starting from then merges is the absolute best you can do with them skipping any of the merges won t get the better answer For only of them occupied merge is the best and we can achieve that merge And a single occupied house obviously will do merges 2 MaximumAlso greedy but let s process the houses in segments of consecutive positions with positive Take a look at the sum of some segment of houses If the sum is greater than the length then you can enlarge that segment house to the left or to the right If the sum is greater by at least than you can enlarge it both directions at the same time Thus the following greedy will work Let s update the segments from left to right For each segments check the distance to the previous one if it was enlarged to the right then consider the new right border If you can enlarge the current segment and there is space on the left then enlarge it And if you still have possibility to enlarge the segment then enlarge it to the right Notice that it doesn t matter which of any pair of consecutive segments will take the spot between them as the answer changes the same The initial segments can be obtained with two pointers Overall complexity 
You are given an graph consisting of vertices and edges It is guaranteed that the given graph is i e it is possible to reach any vertex from any other vertex and there are no self loops and multiple edges in the graph Your task is to calculate the number of of length in the given graph Note that paths that differ only by their direction are considered the same i e you have to calculate the number of paths For example paths and are considered the same You have to answer independent test cases Recall that a path in the graph is a sequence of vertices such that each pair of adjacent consecutive vertices in this sequence is connected by an edge The length of the path is the number of edges in it A is such a path that all vertices in it are distinct ,Because our graph is just a tree with an additional edge consider it as a cycle with trees hanged on cycle vertices Consider some tree hung on a vertex v on a cycle There is only one path between each pair of its vertices including the root which is a vertex v So if the tree has cnt v vertices then frac cnt v cnt v 1 2 paths are added to the answer What about paths that go out of a tree Let s assume that there are cnt v cdot n cnt v such paths yeah we counted only a half of actual paths from this component but this is fine When we consider other trees we will take into account the other half of paths This information can lead us to the conclusion that the only information we need to know about trees hanged on cycle vertices is the number of vertices in these trees So if we know cnt v for each vertex on a cycle we can just calculate the answer as sum limits v in cycle frac cnt v cnt v 1 2 cnt v cdot n cnt v So how to find values cnt v Of course there is a simple and straight forward solution just extract and mark all cycle vertices and run dfs from every vertex of a cycle but there is another approach without any graph algorithms that works very well for such kind of graphs Initially let cnt v 1 for each v from 1 to n Let s create a queue containing all leafs of the graph Let s take the leaf x get its parent p add cnt p cnt p cnt x and remove the vertex x with all edges incident to it After that if p became a leaf let s add it to the queue We can see that after processing all leafs only cycle vertices remain in the graph and cnt v is exactly the number of the vertices in a tree and we can just calculate the answer using the formula above This approach can be implemented in O n log n or in O n there is almost no difference but O n log n one can be written a bit simpler than a linear one 
You are given a rectangular matrix of size consisting of integers from to In one move you can choose of the matrix and change its value to integer between and inclusive take and shift it one cell up cyclically see the example of such cyclic shift below A cyclic shift is an operation such that you choose some and set Example of cyclic shift of the first column You want to perform the minimum number of moves to make this matrix look like this In other words the goal is to obtain the matrix where i e with the performed ,At first let s decrease all elements by one and solve the problem in indexation The first observation is that we can solve the problem independently for each column Consider the column It consists of elements Now consider some element We don t need to replace it with some other number in only one case if we shift the column such that will coincide with the corresponding number of the required matrix Obviously there is only one cyclic shift of the column that can rid us of replacing So the idea is the following let s calculate for each cyclic shift the number of elements we don t need to replace if we use this cyclic shift Let for the th cyclic shift indexed it be Then the answer for this column can be taken as How to calculate for the element the corresponding cyclic shift Firstly if is modulo operation then there is no such cyclic shift Otherwise let If then there is such cyclic shift can be greater than or equal to because can be up to and the number of such cyclic shift is So let s increase and continue After considering all elements of this column take the answer by the formula above and go to the next column Time complexity 
A permutation is a sequence of integers from to in which all the numbers occur exactly once For example are permutations and are not Polycarp was given four integers and and asked to find a permutation of numbers from to that satisfies the following condition For example for and the following permutations are suitable not all options are listed But for example there is no permutation suitable for the condition above for and Help Polycarp for the given and find a permutation of numbers from to that fits the condition above If there are several suitable permutations print any of them ,It is easy to show that if we choose k numbers from a permutation of length n then the minimum sum of k numbers is frac k k 1 2 the maximum sum is frac k 2n 1 k 2 and any sum between them is achievable that is you can choose exactly k numbers from n so that their sum is equal to the desired one This fact allows us to implement the following greedy solution Denote for low k sum limits i 1 k i frac k k 1 2 for high n k sum limits i n k 1 n i frac k 2n 1 k 2 and for k r l 1 We will consider the numbers i n n 1 ldots 1 and determine whether to put them in the segment l r or not If k 0 high i k ge s and s i ge low k 1 then put the number i in the segment l r decrease s by i decrease k by 1 Otherwise we will not put the number i in the segment l r In the end if s 0 then we have chosen r l 1 a number with the sum of s so the remaining number can be arranged in any order If at the end s 0 then there is no way to select r l 1 a number from 1 2 ldots n with the sum of s 
Two players are playing a game They have a permutation of integers a permutation is an array where each element from to occurs exactly once The permutation is not sorted in either ascending or descending order i e the permutation does not have the form or Initially all elements of the permutation are colored red The players take turns On their turn the player can do one of three actions rearrange the elements of the permutation in such a way that all elements keep their positions note that elements can be swapped with each other but it s not obligatory change the color of one red element to blue skip the turn The first player wins if the permutation is sorted in ascending order i e it becomes The second player wins if the permutation is sorted in descending order i e it becomes If the game lasts for turns and nobody wins it ends in a draw Your task is to determine the result of the game if both players play optimally ,Note that it makes no sense to use the first type of operation if it does not lead to an instant win because the opponent can return the previous state of the array with their next move So the winner is the one who has time to color their elements in blue first Let s denote as the number of elements that only the first player needs to color as the number of elements only the second player needs to color both players needs to color To win the first player needs to have time to paint elements and they have no more than moves to do it because otherwise the second player can prevent the win of the first player So the winning condition for the first player is Similarly for the second player with the only difference that they have move less because they go second which means the condition is If none of these conditions are met then neither player has a winning strategy which means they will both reduce the game to a draw 
Polycarp has a string Polycarp performs the following actions until the string is empty is initially an empty string he adds to the right to the string the string i e he does where is a concatenation of the strings and he selects an arbitrary letter of and removes from all its occurrences Polycarp performs this sequence of actions in this order Note that after Polycarp finishes the actions the string will be empty and the string will be equal to some value that is undefined and depends on the order of removing E g consider so the actions may be performed as follows the letter is selected then the letter is selected then the letter is selected then the empty string You need to restore the initial value of the string using only the final value of and find the order of removing letters from ,Suppose it s given a string for which the answer exists Consider the last non empty value of Only letter occurs in the value and the letter is the last removed letter At the same time the value of is a suffix of so the last character of is the last removed letter Consider the second last non empty value of It contains exactly distinct letters so that one of them is the last removed letter and the other is the second last removed letter The concatenation of the second last and the last values of is a suffix of consisting only of the letters Therefore the letter which occurrence is the last of the occurrences of all letters except the last removed one is the second last removed letter Considering so other values we are proving that the order of removing the letters is the order occurrences of the letters occur in the string Suppose is the number of the step in which some letter was removed is the number of occurrences of the letter in the value of The letter occurs in exactly different values of In each of them the letter occurs exactly times So the letter occurs in exactly times Therefore using the number of the step in which the letter was removed and the number of the letter s occurrences in let s calculate the number of the letter s occurrences in the string If isn t completely divisible by there s no solution The sum of all of all letters occurring in is the length of the initial value of Since the initial value is a prefix of the possible answer is the prefix of having the length equal to the sum of all Before outputting the prefix check that you can get from the supposed value of the string the string Checking it you may use the algorithm from the statement If the resulting string is equal to the answer is correct and must be outputted otherwise there s no solution 
Polygon is not only the best platform for developing problems but also a square matrix with side initially filled with the character On the polygon military training was held The soldiers placed a cannon above each cell in the first row and a cannon to the left of each cell in the first column Thus exactly cannons were placed Cannons shoot character At any moment of time no more than one cannon is shooting When a flies out of a cannon it flies forward in the direction of the shot until it collides with a polygon border or another After that it takes the cell in which it was before the collision and remains there Take a look at the examples for better understanding More formally if a cannon stands in the row to the left of the first column and shoots with a then the starts its flight from the cell and ends in some cell if a cannon stands in the column above the first row and shoots with a then the starts its flight from the cell and ends in some cell For example consider the following sequence of shots You have a report from the military training on your desk This report is a square matrix with side length consisting of and You wonder if the training actually happened In other words is there a sequence of shots such that after the training you get the given matrix Each cannon can make an arbitrary number of shots Before the training each cell of the polygon contains ,Let s see how the matrix looks like after some sequence of shoots The matrix consists of or There is at least one at position or and any not at position or must have below or right If the second condition is violated then the in the corresponding cell would continue its flight Thus it is necessary and sufficient to verify that the matrix satisfies the condition above 
A batch of goods an even number is brought to the store th of which has weight Before selling the goods they must be packed into packages After packing the following will be done There will be packages each package contains exactly two goods The weight of the package that contains goods with indices and is With this the cost of a package of weight is always burles rounded down where a fixed and given value Pack the goods to the packages so that the revenue from their sale is maximized In other words make such pairs of given goods that the sum of the values where is the weight of the package number is For example let weights of goods Let s pack them into the following packages In the first package we will put the third and sixth goods Its weight will be The cost of the package will be burles In the second package put the first and fifth goods the weight is The cost of the package is burles In the third package put the second and fourth goods the weight is The cost of the package is burle With this packing the total cost of all packs would be burles ,Note that we do not need to consider the numbers we are only interested in the remainder of the division of by and we simply add the value to the answer We get an array where Let s sort it and greedily type index pairs such that This can be done with two pointers Then add the number of matching pairs to the answer counter This will be the answer to the problem 
There are cities and roads in Berland Each road connects a pair of cities The roads in Berland are one way What is the minimum number of new roads that need to be built to make all the cities reachable from the capital New roads will also be one way ,This problem is almost equivalent to the following count the number of sources the vertices with indegree equal to in the given graph s condensation Thus there exist solutions with complexity However the constraints in the problem are small so solutions with complexity also pass One of these solutions is the following first let s mark all the vertices reachable from as using a simple DFS Then for each bad vertex count the number of vertices reachable from it also can be done by simple DFS Let this number be Now iterate over all bad vertices in non increasing order of For the current bad vertex if it is still not marked as run a DFS from it marking all the reachable vertices as and increase the answer by in fact we are implicitly adding the edge It can be proved that this solution gives an optimal answer 
You are given a string of lowercase Latin letters The following operation can be used select one character from to that occurs at least once in the string And replace all such characters in the string with the previous one in alphabetical order on the loop For example replace all with or replace all with And you are given the integer the maximum number of operations that can be performed Find the minimum lexicographically possible string that can be obtained by performing no more than operations The string is lexicographically smaller than the string if there exists an index such that but ,Greedy idea To minimize the string we will go from left to right and maintain a variable maximal character from which we will reduce everything to a Initially it is a and we spend of operations on it Then at the next symbol we can either reduce it to a in no more than operations or reduce to a the prefix we have already passed and minimize the next character in the remaining operations 
Now Dmitry has a session and he has to pass exams The session starts on day and lasts days The th exam will take place on the day of all are different For the session schedule Dmitry considers a special value the smallest of the rest times before the exam for all exams For example for the image above In other words for the schedule he counts exactly numbers how many days he rests between the exam and for between the start of the session and the exam Then it finds the minimum among these numbers Dmitry believes that he can improve the schedule of the session He may ask to change the date of one exam change one arbitrary value of Help him change the date so that all remain different and the value of is as large as possible For example for the schedule above it is most advantageous for Dmitry to move the second exam to the very end of the session The new schedule will take the form Dmitry can leave the proposed schedule unchanged if there is no way to move one exam so that it will lead to an improvement in the situation ,To begin with we will learn how to find the optimal place for the exam that we want to move Let s imagine that it is not in the schedule in this case we have two options Put the exam at the end of the session so that there are days before it Put it in the middle of the largest break between exams let its length be so that between it and the nearest one there is because this is no worse than putting it in any part of any other break That is the answer for such an arrangement is the minimum of the larger of these options and the minimum break in schedule without the moved exam Now note that the minimum break in most variants is the same minimum in the initial schedule So in order to reduce you need to move exactly one of the two exams that form it and you need to check which of the two options is better 
The robot is located on a checkered rectangular board of size rows columns The rows in the board are numbered from to from top to bottom and the columns from to from left to right The robot is able to move from the current cell to one of the four cells adjacent by side The sequence of commands executed by the robot is given Each command is denoted by one of the symbols or and triggers the movement to left right down or up respectively The robot can start its movement in cell The robot executes the commands starting from the first one strictly in the order in which they are listed in If the robot moves beyond the edge of the board it falls and breaks A command that causes the robot to break is successfully executed The robot s task is to execute as many commands as possible without falling off the board For example on board if the robot starts a sequence of actions right right down left up up from the central cell the robot will perform one command then the next command will force him to cross the edge If the robot starts moving from the cell second row first column then all commands will be executed successfully and the robot will stop at the cell first row second column Determine the cell from which the robot should start its movement in order to execute as many commands as possible ,Let s look at the answer Let s see how many commands the robot can execute Since the robot breaks goes outside the field if any command causes it to break it either leads to its total shift relative to of exactly to the left or exactly to the right or similarly of exactly up or exactly down Denote by and the sum of the maximum positive right down and maximum negative left up shifts in the corresponding direction By adding up the above constraints we get the fact that the robot will not fall off the board only if and Note that the reverse is also true if both these conditions are satisfied then starting from the point where is the maximum shift along the direction the robot will not pass any of the board s edges Thus it is sufficient to find the number of commands which when executed hold the following invariant The horizontal shift can be calculated as the difference between the number of letters and the number of letters encountered Similarly the vertical shift as the difference of the numbers of and Let s iterate over the sequence of commands maintaining relevant values of for all After executing each command if the robot goes farther in some direction than ever before we update the corresponding Either we reach the end of or we meet a command after which either becomes equal to or becomes equal to and the robot breaks so the previous command was the last one successfully executed The possible answer is where the values are calculated one command before the robot broke 
Alice and Bob have decided to play the game Rock Paper Scissors The game consists of several rounds each round is independent of each other In each round both players show one of the following things at the same time rock paper or scissors If both players showed the same things then the round outcome is a draw Otherwise the following rules applied if one player showed rock and the other one showed scissors then the player who showed rock is considered the winner and the other one is considered the loser if one player showed scissors and the other one showed paper then the player who showed scissors is considered the winner and the other one is considered the loser if one player showed paper and the other one showed rock then the player who showed paper is considered the winner and the other one is considered the loser Alice and Bob decided to play exactly rounds of the game described above Alice decided to show rock times show scissors times and show paper times Bob decided to show rock times show scissors times and show paper times Though both Alice and Bob the sequence in which they show things It is guaranteed that and Your task is to find two numbers the minimum number of round Alice can win the maximum number of rounds Alice can win ,The maximum number of rounds Alice can win is pretty easy to calculate greedily What about the minimum number of rounds It can be shown that if we started using some combination we are better to end it before using the other one There are six possible combinations to not win the round and and and and and and We can iterate over all permutations of these combinations there are possible permutations and greedily apply them Use the first while it is possible then the second and so on and find the best answer It is also possible that the order of these combinations does not matter but we didn t prove that fact Time complexity 
The sequence is sent over the network as follows sequence is split into segments each element of the sequence belongs to exactly one segment each segment is a group of consecutive elements of sequence for each segment its length is written next to it either to the left of it or to the right of it the resulting sequence is sent over the network For example we needed to send the sequence Suppose it was split into segments as follows Then we could have the following sequences If a different segmentation had been used the sent sequence might have been different The sequence is given Could the sequence be sent over the network In other words is there such a sequence that converting to send it over the network could result in a sequence ,Let s introduce the dynamics if on the prefix the answer is Then in this sequence the numbers corresponding to the sizes of the segments from the partition into subsegments will be called A number at position in the sequence if it is is either to the right or to the left of the segment If it is to the left of the segment it can only be interesting if Then If it is on the right side of the segment then if then The answer for the whole sequence is if 
 towns are arranged in a circle sequentially The towns are numbered from to in clockwise order In the th town there lives a singer with a repertoire of minutes for each Each singer visited all towns in clockwise order starting with the town he lives in and gave exactly one concert in each town In addition in each town the th singer got inspired and came up with a song that lasts minutes The song was added to his repertoire so that he could perform it in the rest of the cities Hence for the th singer the concert in the th town will last minutes in the th town the concert will last minutes in the th town the duration of the concert will be in the town minutes You are given an array of integer numbers where is the total duration of concerts in the th town Reconstruct any correct sequence of integers or say that it is impossible ,First Consider the sum If we substitute the formula of then for every the coefficient at will be equal to so we can find the sum of all is equal to If the sum of isn t divisible by then the answer is Now let s consider the difference between two neighboring towns so If the value of we found isn t a positive integer then the answer if Otherwise we can find a single value of for every It s easy to see that these values are correct Overall complexity per testcase 
Vova had a pretty weird sleeping schedule There are hours in a day Vova will sleep exactly times The th time he will sleep exactly after hours from the time he woke up You can assume that Vova woke up exactly at the beginning of this story the initial time is Each time Vova sleeps in other words hours Vova thinks that the th sleeping time is if he starts to sleep between hours and inclusive Vova can control himself and before the th time can choose between two options go to sleep after hours or after hours Your task is to say the maximum number of sleeping times Vova can obtain if he acts optimally ,This is a very standard dynamic programming problem Let be the maximum number of sleeping times if Vova had a sleep times already and the number of times he goes to sleep earlier by one hour is exactly Then the value will be the answer Initially all and What about transitions Let the current state of the dynamic programming be and Then we can don t go to sleep earlier and make the first transition The sign is modulo operation and the notation is the boolean result of the expression if is true and otherwise And the second transition if we go to sleep earlier Don t forget to don t make transitions from unreachable states Time complexity 
Let s define as the following permutation This means that the th permutation is i e which maps every element to itself permutation but the element is on the first position Examples You are given an array Let be the position of the element in So Let s define a function where is the absolute value of This function means the sum of distances between adjacent elements of in Your task is to calculate ,Let s calculate the answer for the first permutation naively in Then let s recalculate the answer somehow and then maybe prove that it works in linear time Which summands will change when we try to recalculate the function using First of all let s notice that each pair of adjacent elements of is the segment on the permutation To calculate fast let s firstly notice that all segments that cover the element but is not their endpoint will change their length by minus one after placing at the first position because will be removed from all such segments This part can be calculated in Let s use the standard trick with prefix sums and segments Let be the array of length For each pair of adjacent elements and for all from to let s do the following sequence of moves if then there are no points that covered by this segment not being its endpoints so let s just skip this segment Otherwise let s increase the value of by one and decrease the value of by one After this let s build prefix sums on this array make for all from to And now equals to the number of segments covering the element The second part that will change is such segments that is their endpoint Let s store the array of arrays of length and will store all elements adjacent to in the array for all from to But one important thing we don t need to consider such pairs and that it broke my solution somehow so this part is important Knowing these two parts we can easily calculate using Firstly let s initialize the result as Then we need to recalculate lengths of such segments that is their endpoint Let s iterate over all elements in set remove the old segment and set add the length of the segment from to and increase by one if it means that and change their relative order and the length of the segment from to increases by one Now we can see that after iterating over all from to we make at most moves because each pair of adjacent elements in was considered at most twice Total complexity 
Polycarp was recently given a set of number even dominoes Each domino contains two integers from to Can he divide all the dominoes into two sets so that all the numbers on the dominoes of each set are different Each domino must go into exactly one of the two sets For example if he has dominoes and then Polycarp will be able to divide them into two sets in the required way The first set can include the first and third dominoes and and the second set the second and fourth ones and ,Polycarp has dominoes on each domino there are numbers it turns out there will be numbers in total We need to divide numbers each number from to into two sets so that all numbers in each set are different each set will consist of numbers It turns out that all numbers from to must occur exactly times no more and no less Let s imagine it all as a bipartite graph where there are vertices from to and dominoes are edges Since each number occurs exactly times then we have a lot of cycles In which the edges of each number must be included in different sets in other words the cycles must be of even length This can be checked in by a simple enumeration 
 A subsequence is a string that can be derived from another string by deleting some or no symbols without changing the order of the remaining symbols Characters to be deleted are not required to go successively there can be any gaps between them For example for the string the following strings are subsequences and empty string But the following strings are not subsequences and You are given a string consisting of lowercase Latin letters In one move you can take subsequence of the given string and add it to the set The set can t contain duplicates This move costs where is the length of the added subsequence i e the price equals to the number of the deleted characters Your task is to find out the minimum possible total cost to obtain a set of size or report that it is impossible to do so ,The topic of this problem is BFS Let strings be the vertices of the graph and there is a directed edge from string to string if and only if we can obtain from by removing exactly one character In this interpretation we have to find first visited vertices if we start our BFS from the initial string And then the answer will be just minus the sum of length of visited strings The last thing to mention instead of standard queue of integers we need to maintain the queue of strings and instead of array of visited vertices we have to maintain the set of visited strings Don t forget to stop BFS when you obtain exactly strings If the number of distinct subsequences is less than then the answer is 
A superhero fights with a monster The battle consists of rounds each of which lasts exactly minutes After a round ends the next round starts immediately This is repeated over and over again Each round has the same scenario It is described by a sequence of numbers The th element means that monster s hp hit points changes by the value during the th minute of each round Formally if before the th minute of a round the monster s hp is then after the th minute it changes to The monster s initial hp is It means that before the battle the monster has hit points Print the first minute after which the monster dies The monster dies if its hp is less than or equal to Print if the battle continues infinitely ,In general the answer looks like some number of complete full round cycles plus some prefix the the round Check corner case that there are no complete full rounds at all just check the first round in naive way If no solution found the answer has at least one complete full cycle and some prefix If total sum in one round is not negative then a complete full cycle doesn t help and it is again the no solution case Let s find number of complete full cycles We need such number of cycles that if your multiple by total sum and add some prefix the result with negative sign because it is not a damage will be greater or equal than So to find just add with the minimal prefix partial sum and divide the result by minus total sum Now you know the number of complete full cycles just iterate over the last round in naive way to find the answer 
There are astronauts working on some space station An astronaut with the number has An evil humanoid has made his way to this space station of this humanoid is equal to Also the humanoid took with him serums and serum In one second a humanoid can do any of three actions to absorb an astronaut with to use serum if there is still one left to use serum if there is still one left When an astronaut with is absorbed this astronaut disappears and of the humanoid increases by that is an integer part of For example if a humanoid absorbs an astronaut with its increases by and if a humanoid absorbs an astronaut with its increases by After using the serum this serum disappears and the of the humanoid doubles so it increases by times After using the serum this serum disappears and the of the humanoid triples so it increases by times The humanoid is wondering what the maximum number of astronauts he will be able to absorb if he acts optimally ,Let s make two obvious remarks If we can absorb two astronauts with then we can always first absorb an astronaut with and then an astronaut with If we can absorb some astronaut it is effective for us to do it right now Let s sort the astronauts in increasing order Now let s lock the sequence of serums we use There are only three of them serum can be the first second or third Let s absorb the astronauts in increasing order of their and if we can t then use the next serum in a locked sequence or stop This solution works for 
Polycarp has prepared competitive programming problems The topic of the th problem is and some problems topics may coincide Polycarp has to host several thematic contests All problems in each contest should have the same topic and He may not use all the problems It is possible that there are no contests for some topics Polycarp wants to host competitions on consecutive days one contest per day Polycarp wants to host a set of contests in such a way that number of problems in each contest is as much as in the previous contest one day ago the first contest can contain arbitrary number of problems the total number of problems in all the contests should be maximized Your task is to calculate the maximum number of problems in the set of thematic contests Note that you should not maximize the number of contests ,The first thing we don t need the problems we need their counts So let s calculate for each topic the number of problems with this topic and sort them in non decreasing order The counting can be done with or another one sorting The second thing the answer is not exceed very obviously So let s iterate over the number of problems in maximum by the number of problems thematic contest Now we have to calculate the maximum number of problems we can take in the set of thematic contests Let s do it greedily The number of contests in the set don t exceed Let the number of problems in the current contest be at the beginning of iteration the current contest is the maximum by the number of problems Let s take the topic with the maximum number of problems for this contest If we cannot do it stop the iteration Otherwise we can maybe continue the iteration If is even then divide it by and continue with the rest of topics otherwise stop the iteration Which topic we have to choose for the second one contest The answer is the topic with the maximum number of problems which isn t chosen already So let s carry the pointer initially it is at the end of the array of counts and decrease it when we add another one contest to our set All calculations inside the iteration are very obviously Let s notice that one iteration spends at most operations So overall complexity of the solution is The last question is why can we take the maximum by the number of problems topic each time Suppose we have two contests with numbers of problems and correspondingly Let s consider the case when Let the number of problems of the first contest topic be and the number of problems of the second contest topic be The case don t break our assumptions The only case which can break our assumptions is So if it is then we can swap these topics because and and all will be okay So this greedy approach works 
You are given three integers and Your task is to construct an undirected tree on vertices with diameter and degree of each vertex at most or say that it is impossible An undirected tree is a connected undirected graph with edges Diameter of a tree is the maximum length of a simple path a path in which each vertex appears at most once between all pairs of vertices of this tree Degree of a vertex is the number of edges incident to this vertex i e for a vertex it is the number of edges that belong to the tree where is any other vertex of a tree ,Let s construct a tree by the following algorithm if d ge n let s print and terminate the program Otherwise let s keep the array deg of the length n which will represent degrees of vertices The first step is to construct the diameter of the tree Let first d 1 vertices form it Let s add d edges to the answer increase degrees of vertices corresponding to this edges and if some vertex has degree greater than k print and terminate the program The second and the last step is to attach the remaining n d 1 vertices to the tree Let s call the vertex if its degree is less than k Also let s keep all vertices forming the diameter in some data structure which allows us to take the vertex with the minimum maximal distance to any other vertex and remove such vertices It can be done by for example set of pairs dist v v where dist v is a maximum distance from the vertex v to any other vertex Now let s add all vertices from starting from the vertex d 1 0 indexed to the vertex n 1 let the current vertex be u We get the vertex with the minimum maximal distance to any other vertex let it be v Now we increase the degree of vertices u and v add the edge between they and if v still be return it to the data structure otherwise remove it The same with the vertex u it is obvious that its maximal distance to any other vertex will be equals dist v 1 If at any step our data structure will be empty or the minimum maximal distance will be equals d the answer is Otherwise we can print the answer See my solution to better understanding Overall complexity O n log n or O n depends on implementation 
You are given a rooted tree consisting of vertices numbered from to The root of the tree is a vertex number A tree is a connected undirected graph with edges You are given queries The th query consists of the set of distinct vertices Your task is to say if there is a path from the root to some vertex such that each of the given vertices is either belongs to this path or has the distance to some vertex of this path ,Firstly let s choose some deepest farthest from the root vertex in the query among all such vertices we can choose any It is obvious that every vertex in the query should either belong to the path from the root to or the distance to some vertex of this path should be at most one Now there are two ways write some LCA algorithms and other hard stuff which is unnecessary in this problem or write about lines of code and solve the problem Let s take every non root vertex except and replace it with its parent So what s next Now the answer is if vertex after transformation belongs to the path from root to Now we just need to check if it is true We can do this using the very standard technique firstly let s run dfs from the root and calculate for each vertex the first time we visited it and the last time we visited it We can do this using the following code void dfs int v int par 1 tin v T for auto to g v if to par continue dfs to v tout v T Initially equals zero Now we have a beautiful structure giving us so much information about the tree Consider all segments We can see that there is no pair of intersecting segments The pair of segments and is either non intersecting at all or one segment lies inside the other one The second beautiful fact is that for each vertex in the subtree of the segment lies inside the segment So we can check if one vertex is the parent of the other the vertex is the parent of the vertex if and only if and the vertex is the parent of itself How do we check if the vertex lies on the path from the root to the vertex It lies on this path if the root is the parent of it is always true and is the parent of This approach can be used for each path such a path from to that is either or Time complexity 
You are given an undirected tree consisting of vertices An undirected tree is a connected undirected graph with edges Your task is to add the minimum number of edges in such a way that the length of the shortest path from the vertex to any other vertex is at most Note that you are not allowed to add loops and multiple edges ,The first idea is the following it is always profitable to add the edges from the vertex to any other vertex The proof is the following if we will add two edges and then the distance to the vertex will be the distance to the vertex will be But we can add edges and and this will be better in fact you cannot obtain the less answer by adding two edges in the other way The main idea is the following Let s carry all vertices of the tree with the distance more than in the set Let the vertex with the maximum distance be What we will obtain if we will add the edge The distance to the vertex will be and the distance to the vertex where is the parent of the vertex if we will root the tree by the vertex will be So we will make reachable at most two vertices if the vertex is already reachable then it will be not counted in the answer Now what we will obtain if we will add the edge We will make reachable all the vertices adjacent to the vertex and the vertex the number of such vertices is not less than so this move won t make the answer greater instead of any other way to add the edge After adding such edge let s remove the vertex and all vertices adjacent to it from the set We need to repeat this algorithm until the set will not become empty Time complexity is I sure that there exists the solution with the dynamic programming in the linear time I will be very happy if someone will explain it to other participants 
You are given two arrays and both of length Let s define a function Your task is to reorder the elements choose an arbitrary order of elements of the array to minimize the value of Since the answer can be very large you have to print it modulo Note that you should ,Let s use technique to solve this problem How many times the value will occur in the answer It will occur times Okay now we can see that for each position we have the value The only non constant value there is So let We should pair the minimum with the maximum the second minimum with the second maximum and so on So let s sort the array and the array reverse the array and calculate the sum of values don t forget about modulo here 
There are points on a plane The th point has coordinates You have two horizontal platforms both of length Each platform can be placed anywhere on a plane but it should be placed on the same coordinate and have If the left border of the platform is then the right border is and all points between borders including borders belong to the platform Note that platforms can share common points overlap and it is not necessary to place both platforms on the same coordinate When you place both platforms on a plane all points start falling down decreasing their coordinate If a point collides with some platform at some moment the point stops and is Points which never collide with any platform are lost Your task is to find the maximum number of points you can if you place both platforms optimally You have to answer independent test cases For better understanding please read the section below to see a picture for the first test case ,Firstly we obviously don t need coordinates at all because we can place both platforms at Let s sort all coordinates in non decreasing order Calculate for each point two values and where is the number of points to the left from the point including that are not further than from the th point i e the number of such points that And is the number of points to the right from the point including that are not further than from the th point Both these parts can be done in using two pointers Then let s build suffix maximum array on and prefix maximum array on For just iterate over all from to and do For just iterate over all from to and do The question is what What did we do We did the following thing the answer always can be represented as two non intersecting segments of length such that at least one endpoint of each segment is some input point Now let s fix this border between segments Iterate over all from to and update the answer with So we took segment that starts at some point to the left from including and goes to the left and took some segment that starts further than including and goes to the right With this model we considered all optimal answers that can exist Time complexity 
One day people is an even number met on a plaza and made two round dances each round dance consists of exactly people Your task is to find the number of ways people can make two round dances if each round dance consists of exactly people Each person should belong to exactly one of these two round dances Round dance is a dance circle consisting of or more people Two round dances are indistinguishable equal if one can be transformed to another by choosing the first participant For example round dances and are indistinguishable For example if then the number of ways is one round dance consists of the first person and the second one of the second person For example if then the number of ways is Possible options one round dance another one round dance another one round dance another Your task is to find the number of ways people can make two round dances if each round dance consists of exactly people ,Firstly we need to choose the set of people to be in the first round dance the other half is going to the second one The number of ways to do that is Then we need to set some order of people in both round dances but we don t want to forget about rotation because rotation can lead us to counting the same ways several times So the number of ways to arrange people inside one round dance is This is true because we just fixed who will be the first in the round dance and place others in every possible order So we need to multiply our initial answer by this value twice because we have two round dances And finally we have to divide our answer by because we counted ordered pairs i e we distinguish pairs of kind and but we don t have to do that So the final answer is divided by This formula can be reduced to You could also find the sequence of answers in OEIS and this can be really useful skill sometimes 
You are given two strings and and both consisting only of characters and Possible examples of strings and You have to find a string consisting of characters characters should be characters should be and characters should be and and should not occur in as substrings A substring of a string is a contiguous subsequence of that string So the strings and are substrings of the string but the strings and are not substrings of the string If there are multiple answers you can print any of them ,We can check the following solution by stress testing or maybe prove it somehow let s iterate over all possible permutations of the string Let the first character of the current permutation be the second one be and the third one be Then let s add the following two candidates to the answer the string consisting of copies of and exactly copies of then exactly copies of and exactly copies of Then the answer will be among these strings and we can check each of them naively 
There are students standing in a row Two coaches are forming two teams the first coach chooses the first team and the second coach chooses the second team The th student has integer programming skill All programming skills are and between and inclusive Firstly the first coach will choose the student with maximum programming skill among all students not taken into any team closest students to the left of him and closest students to the right of him if there are less than students to the left or to the right all of them will be chosen All students that are chosen leave the row and join the first team Secondly the second coach will make the same move but all students chosen by him join the second team Then again the first coach will make such move and so on This repeats until the row becomes empty i e the process ends when each student becomes to some team Your problem is to determine which students will be taken into the first team and which students will be taken into the second team ,Let s maintain two data structures a queue with positions of students in order of decreasing their programming skill and a set note that we need exactly set with positions of students not taken in any team To construct the first data structure we need to sort pairs in decreasing order of the first element and after that push second elements in order from left to right The second data structure can be constructed even easier we just need to insert all values from into it Also let s maintain an array where if the th student belongs to the first team and otherwise and the variable to determine whose turn is now initially it is While our set is not empty let s repeat the following algorithm firstly while the head the first element of the queue is not in the set pop it out This is how we determine which student will be taken now Let his position be And don t forget to pop him out too Create the additional dynamic array which will contain all students we will add to the team during this turn Let s find the iterator to the student with the position Then make the following sequence of moves times add the element the current iterator is pointing at to the array then if the current iterator is pointing at the first element break the cycle otherwise go to the iterator pointing at the previous element Then let s find the iterator to the student next to the student with position And then let s make almost the same sequence of moves times if the current iterator is pointing to the end of the set break the cycle otherwise add the element the current iterator is pointing at to the array and advance to the iterator pointing at the next element Then let s remove all values from the array from the set and for each student we delete let s set And change the variable to if it is now and to otherwise Time complexity 
Vlad found two positive numbers and He discovered that where means the bitwise exclusive OR and division is performed without rounding Since it is easier to remember one number than two Vlad remembered only let s denote this number as Help him find any suitable and or tell him that they do not exist ,Consider the answer by bits We know that if the th bit of the number is zero then these bits are the same for and otherwise they differ Then let s first make Note that is already equal to but is not yet So we need to dial another with matching bits we will add them to both integers greedily going from the highest bit to the lowest skipping those bits that are already one in If after this algorithm and do not satisfy the conditions then the answer is In total this solution works for You can see that in the solution above we actually just added to both numbers which could only be done with one set of bits so if the answer exists the pair 
You are given an undirected unweighted graph consisting of vertices and edges which represents the map of Bertown and the array of prices of length It is guaranteed that there is a path between each pair of vertices districts Mike has planned a trip from the vertex district to the vertex district and then from the vertex district to the vertex district He can visit the same district twice or more But there is one issue authorities of the city want to set a price for using the road so if someone goes along the road then he should pay the price corresponding to this road The list of prices that will be used is ready and they just want to distribute it between all roads in the town in such a way that each price from the array corresponds to exactly one road You are a good friend of Mike and suddenly a mayor of Bertown and want to help him to make his trip as cheap as possible So your task is to distribute prices between roads in such a way that if Mike chooses the optimal path then the price of the trip is the possible You have to answer independent test cases ,If we distribute costs optimally then this pair of paths a rightarrow b and b rightarrow c can look like just a straight path that doesn t visit the same vertex twice or like three straight paths with one intersection point x The first case is basically a subcase of the second one with the intersection point a b or c So if we fix the intersection point x then these two paths a rightarrow b and b rightarrow c become four paths a rightarrow x x rightarrow b b rightarrow x and x rightarrow c We can notice that each path we denoted should be the shortest possible because if it isn t the shortest one then we used some prices that we couldn t use Let the length of the shortest path from u to v be dist u v Then it is obvious that for the fixed intersection point x we don t need to use more than dist a x dist b x dist c x smallest costs Now we want to distribute these costs between these three paths somehow We can see that the path from b to x is used twice so it is more optimally to distribute the smallest costs along this part So let pref i be the sum of the first i smallest costs just prefix sums on the sorted array p Then for the intersection point x the answer is pref dist b x pref dist a x dist b x dist c x if dist a x dist b x dist c x le m We can calculate distances from a b and c to each vertex with three runs of bfs Time complexity O m log m 
The king of Berland organizes a ball pair are invited to the ball they are numbered from to Each pair consists of one man and one woman Each dancer either man or woman has a monochrome costume The color of each costume is represented by an integer from to inclusive Let be the color of the man s costume and be the color of the woman s costume in the th pair You have to choose a color for each dancer s costume i e values and in such a way that for every and are integers between and inclusive there are no two completely identical pairs i e no two indices such that and at the same time there is no pair such that the color of the man s costume is the same as the color of the woman s costume in this pair i e for every for each two consecutive adjacent pairs both man s costume colors and woman s costume colors differ i e for every from to the conditions and hold Let s take a look at the examples of bad and good color choosing for and man is the first in a pair and woman is the second Bad color choosing contradiction with the second rule there are equal pairs contradiction with the third rule there is a pair with costumes of the same color contradiction with the fourth rule there are two consecutive pairs such that colors of costumes of men women are the same Good color choosing You have to find suitable color choosing or say that no suitable choosing exists ,The first observation we cannot construct more than pairs at all due to second and third rules The second observation we always can construct an answer which will contain all pairs and get some prefix of this answer if we need less than pairs Ho do we do that Let man s costumes colors be in the following order and so on Now we have to set some colors to woman s costumes The first thing comes to mind is to use some cyclic shift of And it is the best thing we can do So let women s costumes colors be in the following order ans so on So we use each cyclic shift of in order from second to last The maximum number of pairs can be obtained when and the number of such pairs is So now we have to prove that second third and fourth rules are satisfied or write a stress test it is not so hard to do it The easiest way to prove all rules are satisfied is the following if some element in the left part has position let s consider all positions modulo then each element in the right part will have all positions expect in order you can see it from our placement Now we can see that all rules are satisfied because of such a placement 
There are students at your university The programming skill of the th student is As a coach you want to divide them into teams to prepare them for the upcoming ICPC finals Just imagine how good this university is if it has students ready for the finals Each team should consist of Each student should belong to The of a team is the difference between the programming skill of some student that belongs to this team and the programming skill of some student that belongs to this team in other words if the team consists of students with programming skills then the of this team is The total is the sum of of all teams formed Your task is to minimize the total of the division of students and find the optimal way to divide the students ,Let s sort all students by their programming skills but save the initial indices to restore the answer Now we can understand that we don t need to compose the team of size greater than because in this case we can split it into more teams with fewer participants and obtain the same or even less answer Now we can do the standard dynamic programming the minimum total diversity of the division if we divided the first students in sorted order Initially all other values of are Because of the fact above we can do only three transitions indexed The answer is and we can restore it by standard carrying parent values as a parent of the state we can use for example the number of participants in the team 
 You are given an array consisting of integers The value of the th element of the array is You are also given a set of segments The th segment is where You can choose some subset of the given set of segments and decrease values on each of the chosen segments by one For example if the initial array and the given segments are and then you can choose both of them and the array will become You have to choose some subset of the given segments in such a way that if you apply this subset of segments to the array and obtain the array then the value will be possible Note that If there are multiple answers you can print ,Let s divide all segments to four classes The first class contains segments which covers both minimum and maximum values the answer of the resulting array the second class contains segments which covers only minimum value of the resulting array the third class contains segments which covers only maximum value of the resulting array and the fourth class contains segments which covers neither maximum nor minimum of the resulting array We can easy see that we cannot increase the answer if we apply segments of first and third classes What is common in this two classes Right both of them are cover maximum value So we can came up with the solution in or depends on implementation Let s iterate over position of the supposed maximum value and apply all segments which not cover it It can be done in with straight forward implementation or in using prefix sums After we apply all needed segments we can try to update the answer with the value of the obtained array 
You are given a sequence of length consisting of integers from to Find the number of tuples of elements such that the maximum number in the tuple differs from the minimum by no more than Formally you need to find the number of triples of indices such thatFor example if and then there are two such triples and If and then all four possible triples are suitable ,In the easy version of the problem you can count how many times each number occurs the numbers themselves do not exceed n Note that we do not have very many options for which triples of numbers can be included in the answer Let s iterate over x the minimum number in the triples Then there are the following options x x 1 x 2 x x 1 x 1 x x 2 x 2 x x x 1 x x x 2 x x x In each option you need to multiply the number of ways to choose one two or three numbers from all occurrences of this number This is done using binomial coefficients Formally if cnt x is the number of occurrences of the number x then the formulas corresponding to the options in the list above are as follows cnt x cdot cnt x 1 cdot cnt x 2 cnt x cdot frac cnt x 1 cdot cnt x 1 1 2 cnt x cdot frac cnt x 2 cdot cnt x 2 1 2 frac cnt x cdot cnt x 1 2 cdot cnt x 1 frac cnt x cdot cnt x 1 2 cdot cnt x 2 frac cnt x cdot cnt x 1 cdot cnt x 2 6 If we sum these values over all x from 1 to n then we get the answer to the problem 
 Vlad built a maze out of rooms and bidirectional corridors From any room any other room can be reached through a sequence of corridors Thus the room system forms an undirected tree Vlad invited friends to play a game with them Vlad starts the game in the room and wins if he reaches a room other than into which exactly one corridor leads Friends are placed in the maze the friend with number is in the room and no two friends are in the same room that is for all Friends win if one of them meets Vlad in any room or corridor before he wins For one unit of time each participant of the game can go through one corridor All participants move at the same time Participants may not move Each room can fit all participants at the same time Friends know the plan of a maze and intend to win Vlad is a bit afraid of their ardor Determine if he can guarantee victory i e can he win in any way friends play In other words determine if there is such a sequence of Vlad s moves that lets Vlad win in any way friends play ,First we need to understand when it is not possible to get to some exit Let s fix a friend who is at the vertex and try to understand if he can interfere with us The paths from to and from to have a common part let it start at the vertex Then if the path from to is not more than from to it can prevent us from reaching this exit by blocking the vertex Since the path from to is common the previous condition is equivalent to the condition that the path from to is not greater than from to Note that if there is more than one such vertex then can overlap each of them simply by going as close to the root as possible Thus Vlad can win if there is such a leaf which by condition exits for which the distance to the root is less than the distance to any of the friends By running a breadth first search at the same time from each vertex with a friend we can find the shortest distance to any friend from each vertex and by running from the root the distance to the root Now let s just go through all the leaves and check if there is one among them that the distance to the root is less We can also run from the vertices with friends and from the root at the same time assigning them different colors then the color will correspond to what is closer the root or some friend this solution is attached to the tutorial There is also another solution which is a simplified version of the one we will use in E2 
You are given a permutation A permutation of length is a sequence such that each integer between and occurs exactly once in the sequence Find the number of pairs of indices such that the value of the median of is exactly the given number The median of a sequence is the value of the element which is in the middle of the sequence after sorting it in non decreasing order If the length of the sequence is even the left of two middle elements is used For example if then its median is since after sorting the sequence it will look like and the left of two middle elements is equal to The median of equals since after sorting the value will be in the middle of the sequence Write a program to find the number of pairs of indices such that the value of the median of is exactly the given number ,The segment has median equals if and only if belongs to it and or where is number of elements in that strictly less than and is number of elements in that strictly greater than Here we ve used a fact that is a permutation on there is exactly one occurrence of In other words belongs and the value equals or Calculate prefix sums where the value on the prefix of the length i e on the subarray For fixed value it is easy to calculate number of such that is suitable At first check that met on Valid values are such indices that no on and or Let s maintain number of prefix sums to the left of for each value We can use just a map where is number of such indices that and is to the left of So for each that contains do where is the current value Time complexity is if a standard map is used or if classical array for is used remember about possible negative indices just use an offset 
 You are given an sequence of form which consist of blocks of all consecutive positive integers written one after another The first block consists of all numbers from to the second one from to the third one from to the th block consists of all numbers from to So the first elements of the sequence are Elements of the sequence are numbered from one For example the st element of the sequence is the rd element of the sequence is the th element of the sequence is the th element is the th element of the sequence is Your task is to answer independent queries In the th query you are given one integer Calculate the digit at the position of the sequence ,Let s take a look on the upper bound of the number where is the maximum possible number of block which can be asked If we assume that each number has length then the sum of lengths will be equal to And as we know this value equals So the maximum value of is not greater than Now we can just iterate over all from to where is no more than and carry the length of the last block If this length is greater than or equal to indexed then let s decrease by this length increase the length of the last block and continue Otherwise our answer lies in the current block So then let s iterate over all from to and if the decimal length of is greater than or equal to then decrease by this length otherwise our answer lies in the current number and we just need to print indexed Time complexity per query 
A permutation of size is given A of size is an array of size in which each integer from to occurs exactly once For example and are correct permutations while and are not Let us consider an empty deque double ended queue A deque is a data structure that supports adding elements to both the beginning and the end So if there are elements currently in the deque adding an element to the beginning will produce the sequence and adding same element to the end will produce The elements of the permutation are sequentially added to the initially empty deque starting with and finishing with Before adding each element to the deque you may choose whether to add it to the beginning or the end For example if we consider a permutation one of the possible sequences of actions looks like this 1 add to the end of the deque deque has a sequence in it 2 add to the beginning of the deque deque has a sequence in it 3 add to the end of the deque deque has a sequence in it 4 add to the end of the deque deque has a sequence in it Find the lexicographically smallest possible sequence of elements in the deque after the entire permutation has been processed A sequence is than the sequence if there exists such that and In other words if the sequences and have some possibly empty matching prefix and the next element of the sequence is strictly smaller than the corresponding element of the sequence For example the sequence is smaller than the sequence because after the two matching elements in the start the first sequence has an element which is smaller than the corresponding element in the second sequence ,We ll process the permutation elements one by one For the first element it doesn t matter which side of the deque we add it to the result of its addition will be the same there will be a sequence of one element equal to the first permutation element in the deque Now let s consider adding the th element of a permutation to the deque First will be considered then and so on up to Let us describe the general algorithm for choosing the side of the deque for each step Note that if the elements are now in the deque then all final permutations that can be obtained in the deque from the current state can be broken down into pairs of the form where the beginning and the end of the final permutations hidden behind are obtained by the same sequences of all the following choices and thus are equal between the first and the second Note that when the first permutation will always be lexicographically smaller than the second one and vice versa Therefore regardless of the following choices if then the second permutation will never be minimal and if then the first permutation will never be minimal This means that we can make a choice about the side of the deque to add the th element to based only on its relation to if then is added to the beginning of the deque otherwise to the end The time complexity is Alternative solutions which also fit in the time limit involved finding a lexicographically minimal increasing sequence in the reversed original permutation and could be implemented either with time complexity or with time complexity if the permutation s definition was taken into consideration 
 Summer vacation has started so Alice and Bob want to play and joy but Their mom doesn t think so She says that they have to read some amount of books before all entertainments Alice and Bob will read each book to end this exercise faster There are books in the family library The th book is described by three integers the amount of time Alice and Bob need to spend to read it equals if Alice likes the th book and if not and equals if Bob likes the th book and if not So they need to choose some books from the given books in such a way that Alice likes books from the chosen set and Bob likes books from the chosen set the total reading time of these books is they are children and want to play and joy as soon a possible The set they choose is for both Alice an Bob it s shared between them and they read all books so the total reading time is the sum of over all books that are in the chosen set Your task is to help them and find any suitable set of books or determine that it is impossible to find such a set ,Let s divide all books into four groups both Alice and Bob doesn t like these books only Alice likes these books only Bob likes these books both ALice and Bob like these books Obviously group is useless now So how to solve the problem Let s iterate over the number of books we take from group Let it be Then we obviously need to take exactly books from groups and Among all books in these three groups we have to choose the cheapest ones To calculate sum of times in each group fast enought we can sort each group independently and implement prefix sums on these arrays If is less than zero or greater than the size of or group for each possible then the answer is And don t forget that the answer can be up to Time complexity 
A is a figure of the following type an asterisk character in the center of the figure and four rays to the left right top bottom of the same positive length The size of a is the length of its rays The size of a star must be a positive number i e rays of length are not allowed Let s consider empty cells are denoted by then the following figures are You are given a rectangular grid of size consisting only of asterisks and periods dots Rows are numbered from to columns are numbered from to Your task is to draw this grid using number of or find out that it is impossible can intersect overlap or even coincide with each other The number of in the output can t exceed Each star should be completely inside the grid You can use stars of same and arbitrary sizes ,Since we are almost unlimited in the number of in the answer the following solution will works We iterate over all possible centers and try to extend rays of the current as large as possible It can be done by the simple iterating and checking in If the size of the current is non zero let s add it to the answer It is obvious that the number of in such answer will not exceed Then let s try to draw all these on the empty grid Drawing of each is also can be done in If after drawing our grid equals to the input grid the answer is and our set of is the correct answer Otherwise the answer is Time complexity 
 You are given a string consisting of lowercase Latin letters You have to color its characters each character to exactly one color the same letters can be colored the same or different colors i e you can choose exactly one color for each index in After coloring you can swap two neighboring characters of the string that are colored colors You can perform such an operation arbitrary possibly zero number of times The goal is to make the string sorted i e all characters should be in alphabetical order Your task is to say if it is possible to color the given string so that after coloring it can become sorted by sequence of swaps Note that you have to restore only coloring not the sequence of swaps ,Note that the actual problem is to divide the string into two subsequences that both of them are non decreasing You can note that this is true because you cannot the relative order of the elements colored in the same color but you can write down subsequences of different colors in any order you want In this problem you can write the following dynamic programming is if you can split the prefix of the string into two non decreasing sequences such that the first one ends with the character and the second one with characters are numbered from to otherwise is zero Initially only other values are zeros Transitions are very easy if the current value of dp is then we can make a transition to if and to if Then you can restore the answer by carrying parent values But there is another very interesting solution Let s go from left to right and carry two sequences and If the current character is not less than the last character of then let s append it to otherwise if this character is not less than the last character of then append it to otherwise the answer is If the answer isn t then and are required sequences The proof and other stuff will be in the editorial of the hard version Time complexity or or 
 You are given a sequence consisting of positive integers Let s define a as the sequence consisting of distinct elements let these elements are and can be equal and is as follows There are integers greater than or equal to For example sequences and are but and are not Your task is to choose the maximum by length of that is a You have to answer independent test cases Recall that the sequence is a a subsequence of the sequence if can be derived from by removing zero or more elements without changing the order of the remaining elements For example if then possible subsequences are and but not and ,Let s precalculate for each number indexed the array of length where is the number of occurrences of the number on the prefix of length This can be done with easy dynamic programming just compute prefix sums Also let be and it s meaning is the number of occurrences of the number on the segment indexed Firstly let s update the answer with we can always take all occurrences of the same element as the answer Then let s iterate over all possible segments of the array Let the current segment be Consider that all occurrences of the element in the middle block belong to Then we can just take the most frequent number on this segment We also have to choose the number for the first and the last blocks It is obvious that for the number the maximum amount of such numbers we can take is So And we can update the answer with Time complexity where is the size of alphabet the maximum value of 
The chief wizard of the Wizengamot once caught the evil wizard Drahyrt but the evil wizard has returned and wants revenge on the chief wizard So he stole from his student Harry The is a length string of lowercase Latin letters Drahyrt wants to replace with an unforgivable curse string Drahyrt using ancient magic can swap letters at a distance or in as many times as he wants In other words Drahyrt can change letters in positions and in if or For example if and Drahyrt can act as follows swap the letters at positions and to get swap the letters at positions and to get You are given and Can Drahyrt change to ,In these constraints the problem could be solved as follows Note that for strings of length and more it is enough to check that the strings and match character by character that is up to permutation since each character can be moved to the desired half and then moved to the desired side by length by applying two operations on the length is and For example there was a string and we want to shift the character to the left then we can first get the string and then the string Well we can restore the used symbols by putting them in their place That is we were able to simply swap two adjacent characters Thus with such a clipping it was possible to solve the problem by brute force for To iterate it was possible to store of strings which we can get and iterate through all the strings using 
 You are given a weighted rooted tree vertex is the root of this tree A tree is a connected graph without cycles A rooted tree has a special vertex called the root A parent of a vertex is the last different from vertex on the path from the root to the vertex Children of vertex are all vertices for which is the parent A vertex is a leaf if it has no children The weighted tree is such a tree that each edge of this tree has some weight The weight of the path is the sum of edges weights on this path The weight of the path from the vertex to itself is You can make a sequence of zero or more moves On each move you select an edge and divide its weight by rounding down More formally during one move you choose some edge and divide its weight by rounding down Your task is to find the minimum number of required to make the from the root to each leaf at most In other words if is the weight of the path from the vertex to the vertex then you have to make where is the list of all leaves You have to answer independent test cases ,Let s define as the number of leaves in the subtree of the th edge of course in terms of vertices in the subtree of the lower vertex of this edge Values of can be calculated with pretty standard and simple dfs and dynamic programming Then we can notice that our edges are independent and we can consider the initial answer sum of weights of paths as Let be the difference between the current impact of the th edge and the impact of the th edge if we divide its weight by This value means how the sum of weights decreases if we divide the weight of the th edge by Create ordered set which contains pairs Then the following greedy solution works let s take the edge with maximum and divide its weight by Then re add it into the set with new value When the sum becomes less than or equal to just stop and print the number of divisions we made The maximum number of operations can reach so the solution complexity is each operation takes time because the size of the set is 
 You are given an array consisting of integers The value of the th element of the array is You are also given a set of segments The th segment is where You can choose some subset of the given set of segments and decrease values on each of the chosen segments by one For example if the initial array and the given segments are and then you can choose both of them and the array will become You have to choose some subset of the given segments in such a way that if you apply this subset of segments to the array and obtain the array then the value will be possible Note that If there are multiple answers you can print ,This tutorial is based on the previous problem easy version tutorial At first I want to say I know that this problem and this approach can be implemented in with segment tree So we iterate over all supposed maximums in the array and trying to apply all segments not covering our current element How do we can calculate the answer for element if this element is the supposed maximum Let s divide all segments we apply into two parts the first part consists of segments such that their right endpoints is less than the current position and the second part consists of segments such that their left endpoints is greater than the current position Then let s independently calculate answers for the left and for the right parts and merge them to obtain the answer I will consider only first part of the solution first part of segments because the second part is absolutely symmetric with it Let s maintain the minimum value on prefix of the array let it be and initially it equals to maintain the array of length initially its values are and means the answer if the th element of the array will be supposed maximum and the array of length where will be the value for which we decrease the th element in other words the number of segments we apply to the th element What do we do for the current position Firstly let s update the answer for it with the value in other words set Then let s apply all segments with right endpoints equals to the current position straight forward and update the value with each new value of covered elements Just iterate over all positions of each segment ends in the current position make and set And don t forget to update the value with the value after all changes because we need to update this value with each element not covered by segments too So then let s do the same from right to left and then will mean the answer if the th element is the supposed maximum in the resulting array Then we can find any position of the maximum in the array and apply all segments which don t cover this position What is time complexity of the solution above We iterate over all elements in the array this is and apply each segment in so the final time complexity is 
You are given an integer array Let us consider an empty deque double ended queue A deque is a data structure that supports adding elements to both the beginning and the end So if there are elements currently in the deque adding an element to the beginning will produce the sequence and adding the same element to the end will produce The elements of the array are sequentially added to the initially empty deque starting with and finishing with Before adding each element to the deque you may choose whether to add it to the beginning or to the end For example if we consider an array one of the possible sequences of actions looks like this 1 add to the beginning of the deque deque has a sequence in it 2 add to the end of the deque deque has a sequence in it 3 add to the end of the deque deque has a sequence in it 4 add to the beginning of the deque deque has a sequence in it Find the minimal possible number of inversions in the deque after the whole array is processed An in sequence is a pair of indices such that and For example the array has exactly two inversions and since and ,Let s process the array elements one by one For the first element it doesn t matter which side of the deque we add it to the result of its addition will be the same there will be a sequence of one element equal to the first array element in the deque Now let s consider adding the th element of an array into the deck First will be considered then and so on up to Let us describe the general algorithm for choosing the side of the dec for each step Note that if the elements now lie in the deck then all final sequences that can be obtained in the deck from the current state can be broken down into pairs of the form where the beginning and the end of the final sequences hidden behind are obtained by the same sequences of all the following choices and respectively coincide Note that since the prefix and suffix hidden behind the dots completely coincide in the two sequences under consideration as well as the set of numbers in the central part coincides the numbers of inversions also coincide inside the prefix and inside the suffix between elements of the prefix and elements of the suffix between elements of the prefix or suffix and elements of the central part The difference between the number of inversions in the first and second sequence consists only of the difference between the number of inversions in their central part So we can determine at the stage of adding to the deque which direction of its addition is guaranteed not to lead to the optimal answer and choose the opposite one If is added to the beginning of the deque the number of inversions in the central part will increase by the number of elements in the deque strictly smaller than and if we add it to the end of the deque it will increase by the number of elements in the deque strictly larger than Let us make a choice such that the number of inversions increases by the minimum of these two values To quickly find the number of elements smaller or larger than we will store all already processed array elements in a structure that supports the element order search operation such as Besides using this structure specifically you can write any balanced binary search tree such as a Cartesian tree sort all numbers in the input array and compress them to values preserving the relation then build a segment tree on them storing in the node the number of array numbers already processed by the deque with values between and Requests to update and get an order in such structures take time and the construction takes at worst so the time complexity of the algorithm is 
You are given a sequence of length consisting of integers from to Find the number of tuples of elements such that the maximum number in the tuple differs from the minimum by no more than Formally you need to find the number of tuples of indices such thatFor example if then there are two such triples and If then all six possible pairs are suitable ,The key idea that allows us to move from the previous version to this one is that the values of the numbers themselves are not important to us The main idea is to consider all numbers in the interval x x k Let s also as in the previous version iterate over the minimum element x in the tuple Now let s find the count of numbers cnt that lie in the interval x x k this can be done with a binary search two pointers or prefix sums using an array of occurrences Then it remains to add to the answer the number of ways to choose m 1 numbers from cnt 1 we fixed one of the numbers as the minimum You have to sum these values over all possible values of x even the same because now you are not fixing the value of the minimum element as in the previous problem but its index in the sorted array To calculate binomial coefficients quickly you can pre compute all factorial values and all frac 1 n values by modulo If you do not know how to calculate the inverse element by modulo then you could pre compute the part of Pascal s triangle in mathcal O nm 
You are given positive integers with and Find any pair of numbers and that satisfies the following conditions is divisible by Note that required and may not exist ,Let s look at the slow solution first which will lead us to the full one Let s iterate over the number from to Given a number we want to find a from to such that is divisible by Since must be divisible by the following conclusion can be drawn must be divisible by Let s denote this number as Now our task is to check if there is a multiple of between and The problem can be solved in many ways you can simply consider the largest multiple of that does not exceed it is equal to We compare this number with and if it matches then we have found a suitable pair Now let s note that we do not need to iterate over all the values of because from the number we are only interested in and this is one of the divisors of Even though the product can be large we can still consider all divisors of this number since and themselves are up to Let s find the divisors of and separately then notice that any divisor of is where is some divisor and is some divisor Let s calculate the running time We need to factorize the numbers and into prime factors this can be done in Next you need to iterate over pairs of divisors and Recall the estimate for the number of divisors of a number https oeis org A066150 the number up to has no more than divisors Therefore we can sort through the pairs for We learned how to find the optimal for We get that for each test case we have learned to solve the problem in 
 Vlad built a maze out of rooms and bidirectional corridors From any room any other room can be reached through a sequence of corridors Thus the room system forms an undirected tree Vlad invited friends to play a game with them Vlad starts the game in the room and wins if he reaches a room other than into which exactly one corridor leads Friends are placed in the maze the friend with number is in the room and no two friends are in the same room that is for all Friends win if one of them meets Vlad in any room or corridor before he wins For one unit of time each participant of the game can go through one corridor All participants move at the same time Participants may not move Each room can fit all participants at the same time Friends know the plan of a maze and intend to win They don t want to waste too much energy They ask you to determine if they can win and if they can what number of friends must remain in the maze so that they can always catch Vlad In other words you need to determine the size of the minimum by the number of elements subset of friends who can catch Vlad or say that such a subset does not exist ,Let s learn how to find an answer for the subtree rooted in vertex At first it is obvious from E1 tutorial that if the nearest to vertex with a friend from this subtree is no further from it than the root of the entire tree from then the answer for the entire subtree is since a friend can come to and catch Vlad in it not allowing him to go to any leaf of this subtree Else we will find the answer leaning on its children If a solution does not exist for at least one child then it does not exist for the entire subtree because after reaching Vlad will be able to go to such child and reach any exit Otherwise the answer for is the sum of the answers of its children since we need to beat it in each subtree to win and for each subtree we have found the minimum answer 
You are given an integer sequence Find the number of pairs of indices such that the value of median of is exactly the given number The median of a sequence is the value of an element which is in the middle of the sequence after sorting it in non decreasing order If the length of the sequence is even the left of two middle elements is used For example if then its median is since after sorting the sequence it will look like and the left of two middle elements is equal to The median of equals since after sorting the value will be in the middle of the sequence Write a program to find the number of pairs of indices such that the value of median of is exactly the given number ,Let s define a function greaterCount number of subarrays with median greater or equal than In this case the answer on the problem is greaterCount greaterCount The subarray has median greater or equal than if and only if where is the number equal or greater than elements and is the number of less than elements In other words instead of processing you can use the sequence containing or and An element if An element if Now the median of is greater or equal than if and only if Let s iterate over from left to right Maintain the current partial sum Additionally in the array let s maintain the number of partial sum for each its value It means that before increase of you should do So if is the index of the right endpoint of a subarray i e then number of suitable indices is number of such that In other words find sum of all where it is exactly number of indices with partial sum less than Each time partial sum changes on or So the value sum of all where is easy to recalculate on each change If you decrease just subtract the value If you increase before increasing just add Since indices in can be from to you can use 0 based indices using an array In this case initialize as but not as it makes to be non negative on each step This solution works in 
 You are given an sequence of form which consist of blocks of all consecutive positive integers written one after another The first block consists of all numbers from to the second one from to the third one from to the th block consists of all numbers from to So the first elements of the sequence are Elements of the sequence are numbered from one For example the st element of the sequence is the rd element of the sequence is the th element of the sequence is the th element is the th element of the sequence is Your task is to answer independent queries In the th query you are given one integer Calculate the digit at the position of the sequence ,This problem idea is not very hard Now can be up to so we need to find the number of block faster Let s do binary search on it Now using some pretty formulas we can determine if the total sum of lengths of blocks from to is greater than or equal to or not And more about these formulas let s iterate over all possible length of numbers from to and carry the sum of lengths of numbers with length less than the current length We know that the number of numbers he he of length is exactly for Let s add to the total sum of lengths and increase by What does means This formula means that we have exactly blocks ending with numbers of length and we need to add sum of lengths of all numbers with length less than exactly times And what does means It is the sum sums of lengths of all numbers of length i e previously we added sum of lengths of numbers with length less than and now we add sum of sums of lengths of numbers with length When we found the number of block let s decrease by the total length of all blocks from to and continue solving the problem This part was pretty hard to understand And the easiest part when we determined the number of block we can easily determine the number from to such that our answer lies in the number Let s iterate over all lengths from to here we go again and for the current length let for And now all we need is to increase the sum of lengths by After determining decrease by sum of lengths of numbers from to and print Time complexity 
 Summer vacation has started so Alice and Bob want to play and joy but Their mom doesn t think so She says that they have to read books before all entertainments Alice and Bob will read each book to end this exercise faster There are books in the family library The th book is described by three integers the amount of time Alice and Bob need to spend to read it equals if Alice likes the th book and if not and equals if Bob likes the th book and if not So they need to choose books from the given books in such a way that Alice likes books from the chosen set and Bob likes books from the chosen set the total reading time of these books is they are children and want to play and joy as soon a possible The set they choose is for both Alice an Bob it s shared between them and they read all books so the total reading time is the sum of over all books that are in the chosen set Your task is to help them and find any suitable set of books or determine that it is impossible to find such a set ,A little explanation this editorial will be based on the easy version editorial so I ll use some definitions from it Here we go the most beautiful problem of the contest is waiting us Well the key idea of this problem almost the same with the easy version idea Let s iterate over the number of elements in group we need to take the cheapest ones again If the number of elements we take from group is then we need to take elements from and groups But one more thing let s iterate over not from zero but from the smallest possible number which can give us any correct set of books the numeric value of the answer doesn t matter The value of can be calculated using and sizes of groups by formula or even simple loop If we can t find any suitable value of the answer is Let s call elements from group and elements from and groups we take Other elements of the whole set of books are but Let s create the set which contains all free elements and fill it beforehand So now we took some necessary elements but we need to take some free elements to complete our set Let s create the other set which contains free elements we take to the answer and maintain the variable describing the sum of elements of How do we recalculate Before the start of the first iteration our set is already filled with some elements let s update using them Update is such an operation function that tosses the elements between and It will do the following things repeatedly and stop when it cannot do anything While the size of is greater than needed so we take more than books in total let s remove the most expensive element from and add it to while the size of is less than needed so we take less than books in total let s remove the cheapest element from and add it to while the cheapest element from is cheaper than the most expensive element form let s swap them Note that during updates you need to recalculate as well So we go over all possible values updating before the first iteration and after each iteration The size of both sets changes pretty smooth if we go from to we need to remove at most one element from because we take one element from group during each iteration and we need to add at most two elements to and because we remove at most two elements from and groups during one iteration To restore the answer let s save such a value that the answer is minimum with this value let it be Then let s just run the same simulation once more from the beginning but stop when we reach Then will contain free elements we need to take to the answer describes the number of elements we need to take from group and describes which elements from and groups we need to take Of course there are some really tough technical things like case handling there is a lot of cases for example the size of can be negative at some moment and you need to carefully handle that and can be negative after some number of iterations and there are other cases because of that and so on Time complexity 
A is a figure of the following type an asterisk character in the center of the figure and four rays to the left right top bottom of the same positive length The size of a is the length of its rays The size of a star must be a positive number i e rays of length are not allowed Let s consider empty cells are denoted by then the following figures are You are given a rectangular grid of size consisting only of asterisks and periods dots Rows are numbered from to columns are numbered from to Your task is to draw this grid using number of or find out that it is impossible can intersect overlap or even coincide with each other The number of in the output can t exceed Each star should be completely inside the grid You can use stars of same and arbitrary sizes ,I am sorry that some solutions pass tests in this problem also I was supposed to increase constraints or decrease time limit The general idea of this problem is the same as in the previous problem But now we should do all what we were doing earlier faster The solution is divided by two parts The first part Let s calculate four matrices of size and will denote the distance to the nearest dot character to the top from the current position The same will denote the distance to the nearest dot character to the bottom from the current position to the left and to the right We can calculate all these matrices in using easy dynamic programming If we will iterate over all possible from to and from to we can easy see the next if the current character is dot then Otherwise if then and if then Rest two matrices can be calculated the as well as these two matrices but we should iterate over all from to and from to So this part of the solution works in After calculating all these matrices the maximum possible length of rays of the with center in position is The second part is to draw all in Let s calculate another two matrices of size and Let s iterate over all in our answer Let the center of the current is and its size is Let s increase by one and decrease by one if The same with the matrix Increase and decrease if Then let s iterate over all possible from to and from to If then set and if set How to know that the character at the position is asterisk character or dot character If either or greater than zero then the character at the position in our matrix will be the asterisk character Otherwise it is the dot character This part works also in Time complexity of the solution 
 You are given a string consisting of lowercase Latin letters You have to color its characters each character to exactly one color the same letters can be colored the same or different colors i e you can choose exactly one color for each index in After coloring you can swap two neighboring characters of the string that are colored colors You can perform such an operation arbitrary possibly zero number of times The goal is to make the string sorted i e all characters should be in alphabetical order Your task is to find the minimum number of colors which you have to color the given string in so that after coloring it can become sorted by sequence of swaps Note that you have to restore only coloring not the sequence of swaps ,The solution of this problem is based on Dilworth s theorem You can read about it on Wikipedia In two words this theorem says that the minimum number of non decreasing sequences we need to cover the whole sequence equals the length of longest decreasing subsequence Let s calculate the dynamic programming the length of longest decreasing sequence that ends in the position To recalculate this dynamic let s carry the array of length where means the maximum value of for the character on the prefix we already considered So initially all are ones all values of are zeros For the position we update with and update with Okay how to restore the answer That s pretty easy The color of the th character is exactly Why it is so If becomes greater than then we surely need to use the new color for this character because we cannot append it to the end of any existing sequence Otherwise we will append it to some existing sequence with the maximum possible number and because it has the maximum number and we didn t update the value of with the number of this sequence plus one the current character is not less than the last in this sequence Time complexity or 
 You are given a sequence consisting of positive integers Let s define a as the sequence consisting of distinct elements let these elements are and can be equal and is as follows There are integers greater than or equal to For example sequences and are but and are not Your task is to choose the maximum by length of that is a You have to answer independent test cases Recall that the sequence is a a subsequence of the sequence if can be derived from by removing zero or more elements without changing the order of the remaining elements For example if then possible subsequences are and but not and ,I ll take some definitions from the solution of the easy version so you can read it first if you don t understand something Let be the number of occurrences of on the segment We will try to do almost the same solution as in the easy version The only difference is how do we iterate over all segments corresponding to the second block of the required palindrome Consider some number which we want to use as the number for the first and third blocks If we take occurrences in the first block then we also take occurrences in the third block Let s take these occurrences greedily If we take elements in the first block and also in the third block then it is obviously better to take leftmost and rightmost elements correspondingly Define be the position of the th occurrence of the number indexed So if is the array of length and contains all occurrences of in order from left to right then let s iterate over its left half and fix the amount of numbers we will take in the first block and also in the third block Let it be Then the left border of the segment for the second block is and the right border is So let and and we can update the answer with It is easy to see that the total number of segments we consider is so the total time complexity is there are also solutions not depending on the size of the alphabet at least Mo s algorithm in but all of them are pretty hard to implement so I won t describe them here And I m also interested in solution so if you know it share it with us 
The chief wizard of the Wizengamot once caught the evil wizard Drahyrt but the evil wizard has returned and wants revenge on the chief wizard So he stole from his student Harry The is a length string of lowercase Latin letters Drahyrt wants to replace with an unforgivable curse string Dragirt using ancient magic can swap letters at a distance or in as many times as he wants In other words Drahyrt can change letters in positions and in if or For example if and Drahyrt can act as follows swap the letters at positions and to get swap the letters at positions and to get You are given and Can Drahyrt change to ,The solution of the problem hints to us that with the help of such operations it is possible to move the symbol in the right direction by using two operations Then we can show that among the symbols that we can swap with at least one other symbol we can get any permutation For example you can apply such a greedy solution we will build an answer from the boundaries of the string to the middle Since we can move the symbol by a distance of we can move it to the border and thus we can build any string Thus it is enough to check that the sets of characters that can be swapped with some other match And for the rest of the characters check that they just match 
 You are given a weighted rooted tree vertex is the root of this tree A tree is a connected graph without cycles A rooted tree has a special vertex called the root A parent of a vertex is the last different from vertex on the path from the root to the vertex Children of vertex are all vertices for which is the parent A vertex is a leaf if it has no children The weighted tree is such a tree that each edge of this tree has some weight The weight of the path is the sum of edges weights on this path The weight of the path from the vertex to itself is You can make a sequence of zero or more moves On each move you select an edge and divide its weight by rounding down More formally during one move you choose some edge and divide its weight by rounding down Each edge has an associated cost which is either or coins Each move with edge costs coins Your task is to find the minimum total to make the from the root to each leaf at most In other words if is the weight of the path from the vertex to the vertex then you have to make where is the list of all leaves You have to answer independent test cases ,Read the easy version editorial first because almost all solution is the solution to the easy version with little changes Firstly let s simulate the greedy process we used to solve the easy version problem for edges with cost and edges with cost independently But we don t stop when our sum reach something let s simulate until our sum becomes and store each intermediate result in the array for edges with cost and for edges with cost So the array contains the initial total impact of edges of cost then the impact after making one move two moves and so on The same with but for edges with cost Now let s fix how many moves on edges with cost we do Let it be and arrays and are indexed Then the sum we obtain from the cost edges is So we need to find the minimum number of moves we can do on cost edges so that This can be done using binary search or moving pointer if we iterate over in increasing order place at the end of and move it to the left while Then if we can update the answer with the value Time complexity is actually the same as in easy version of the problem 
You are given a text consisting of space separated words There is exactly one space character between any pair of adjacent words There are no spaces before the first word and no spaces after the last word The length of text is the number of letters and spaces in it is the th word of text All words consist only of lowercase Latin letters Let s denote a segment of words as a sequence of words Two segments of words and are considered if and for every For example for the text the segments and are equal they correspond to the words An abbreviation is a replacement of some segments of words with their first letters In order to perform an abbreviation you have to choose non intersecting equal segments of words and replace each chosen segment with the string consisting of first letters of the words in the segment written in uppercase For example for the text you can replace segments of words and with an abbreviation and obtain the text or you can replace segments of words and with an abbreviation and obtain the text What is the minimum length of the text after at most one abbreviation ,Let eq i j equals true if words s i and s j are equal otherwise it will be equals false We can iterate over all pairs of words and compare they just using standard string comparator constraints are really small so we can do it naively The next step is to calculate dynamic programming dp i j which will be equal to the maximum length of coinciding segments of words which starts in positions i and j respectively In other words if dp i j equals k then s i i k 1 s j j k 1 word by word We can calculate this dynamic programming in reverse order i n 1 0 j n 1 0 and dp i j 0 if s i ne s j else if i n 1 and j n 1 then dp i j dp i 1 j 1 1 otherwise dp i j 1 Let s keep the length of the text in the variable allsum Then iterate over all starting positions of the possible abbreviation and all its possible lengths Let the current starting position will be equals i 0 indexed and its length will be equal j Then we need to calculate the number of possible replacements by its abbreviation Let it be cnt and now it equals 1 Let s iterate over all positions pos at the beginning pos i j 0 indexed If dp i pos ge j then we can replace the segment of words which starts at the position pos with its abbreviation so cnt cnt 1 and pos pos j because we cannot replace intersecting segments otherwise pos pos 1 After this we need to update the answer The length of the segment of words s i j can be calculated easily let it be seglen Also let segcnt be the number of words in the current segment of words Then we can update the answer with the value allsum seglen cnt cnt segcnt Overall complexity is O n 3 n cdot sum limits i 0 n 1 s i where s i is the length of the i th word 
A positive number of length in base is written on the blackboard The number is given as a sequence the digits of in order from left to right most significant to least significant Dmitry is very fond of all the digits of this number system so he wants to see each of them at least once In one operation he can take any number written on the board increase it by and write the new value on the board For example and Initially the board contains the digits and Dmitry increases the number by and writes down the number On the board there are digits Dmitry increases the number by and writes down the number Now the board contains all the digits from to Your task is to determine the minimum number of operations required to make all the digits from to appear on the board at least once ,If all digits from to are initially present in the number then the answer is Each time we will increase the number by If the last digit is less than then only it will change Otherwise all digits equal to at the end will become equal to and the previous one will increase by or a new digit equal to will be added if all digits were equal to For a operation the last digit will run through all possible values However we can get all the numbers earlier We will solve the problem using binary search sorting through the number of operations We can have 2 options whether was at the end or not Depending on this one or two subsegments of the segment a subsegment in the middle or a prefix and a suffix remained uncovered by the last digit of the number They need to be completely covered with numbers that were already in positions except for the last one these are the original numbers and in case there was at the end the number into which the transfer was made There are at most of them 
You are given an array consisting of integers Let be the minimum value among and be the maximum value among Your task is to choose three greater than integers and such that In other words you have to split the array into three consecutive non empty parts that cover the whole array and the maximum in the first part equals the minimum in the second part and equals the maximum in the third part or determine it is impossible to find such a partition Among all such triples partitions you can choose any You have to answer independent test cases ,Let s fix the length of the first block iterate through i from 0 to n 3 Let s also try to maximize the length of the third block using the second pointer So initially the length of the first block is 1 and the maximum in the block is a 0 after that its length will be 2 and the maximum will be max a 0 a 1 and so on Let s move the left border of the third block r while a r le a 0 and the second block have at least one element After we expanded the third block consider some cases if its maximum is less than a 0 then we don t need to consider this partition we expanded the third block as much as we can but didn t find the required maximum Otherwise its maximum fits our conditions Then let s find the minimum in the second block Let it be mn If mn mx this partition is also bad If mn mx this partition is good and we can just print it Otherwise mn mx and we need to fix the second block somehow I claim that we only need to expand it by at most one element Let s see why is it true Consider we want to expand it to the right the other case just uses the same logic If we expanded our block by one element to the right and the new value in it is less than mx then this partition is bad and we can not use it this is also the reason why we are trying to maximize the length of the third block Otherwise this value is always mx because the first and the third blocks didn t have values greater than mx There are some cases in the implementation we need to consider carefully first we need to find the minimum in the second block fast enough This can be done if we store it as a multiset set with repetitions Second we can remove the only maximum in the third or the first block by expanding the second one This can be handled easily if we just store all three blocks not only the second one as multisets And the last case is that we sometimes need to move the left border of the third block to the right This happens when we expand the first block and the second block becomes empty So this happens only O n times in total Total time complexity of this solution is O n log n There is also another solution from Gassa Let us start solving by asking the following question in which segments will the maximal values end up Consider the maximum value m in the whole array If there are at least three of them a valid answer is to pick any maximum except the first and the last as the middle segment For example m 3 can be partitioned as or as where the middle segment is marked with square brackets Otherwise all m should end up in the middle segment so that maximums to the left and to the right are less For example in we have to put both threes into the middle segment Let us now calculate the minimum value v on the middle segment considering the numbers between those equal to m For example in the value v min 3 1 3 1 All numbers greater than v should also go into the middle segment and everything between them which can result in v decreasing even more We have to expand the borders of the middle segment until the minimum value is such v that there are only values not greater than v left outside Continuing with the example we see that in the middle segment should be expanded to Conversely if the maximum m was unique then v m and we didn t have to expand the middle segment at this stage For example in the current state is If the maximums to the left and to the right are exactly v we found an answer Otherwise any possible middle segment contains the middle segment that we now got So we have to expand the middle segment either to the left or to the right As a result the value v may become smaller which can cause another expansion What s left is to decide where to expand when we have a choice We would like to do it greedily Indeed consider three values the minimum on middle segment v the maximum on left segment u and the maximum on right segment w When we expand the middle segment each of them can only decrease And if we find an answer the equation u v w will be satisfied So as we make the minimum of these three values smaller we have less and less opportunities to make them equal Thus we can pick the side of expansion after which the value min u v w is larger and if these are equal pick any For example in the state we have u 3 v 4 and w 3 If we expand to the left we get where u 1 v 3 and w 3 If we expand to the right we get where u 3 v 2 and w 3 Our algorithm will pick expanding to the right however there is no valid answer in this example anyway Implementation let us precalculate the maximums on all prefixes and all suffixes of the array Then we can expand the middle segment by one element in O 1 and the total running time is linear 
You are given an array of zeroes and ones only Note that in this problem unlike the others the array indexes are numbered from zero not from one In one step the array is replaced by another array of length according to the following rules First a new array is defined as a cyclic shift of the array to the right by cells The elements of this array can be defined as where is the remainder of integer division of by It means that the whole array can be represented as a sequence Then each element of the array is replaced by where is a logical AND operator For example if and then and the value of after the first step will be that is The process ends when the array stops changing For a given array determine whether it will consist of only zeros at the end of the process If yes also find the number of steps the process will take before it finishes ,We ll consider an arbitrary index of the array and see what changes happen to during several steps of the described algorithm Let s denote by the value of the array after steps of the algorithm and prove by induction that is the logical AND of elements of the array starting from with step to the left that is Base of induction for the element of the original array is For clarity we can also show that the statement is true for during the first step is replaced by by the definition of cyclic shift by to the right For simplicity we will omit the operation in the following formulas but will keep it in mind implicitly That is will imply Induction step let the above statement be true for let us prove it for By the definition of cyclic shift And by the induction assumption these two numbers are equal to Since the logical AND is an idempotent operation that is it does not change its result when repeatedly applied to any argument then that is equal to their logical AND is also equal to which is what we wanted to prove It follows from this formula that turns to zero after the th step if and only if and Up to the th step all elements will be equal to and so their logical AND will also be equal to As soon as appears in the sequence in question the logical AND will also become zero Thus we reduced the problem to finding the maximal block of elements equal to of the pattern Note that by shifts of the array splits into cyclic sequences of this kind each of length Let s look at these cyclic sequences independently from each other and iterate over each of them in linear time complexity to find the maximal block of consecutive elements equal to this will be the answer to the problem Remember to check that if at least one of these sequences consists entirely of elements equal to its elements will never zero out and the answer in such case is The time complexity is 
You are given an array of positive integers In one step the array is replaced with another array of length in which each element is the greatest common divisor GCD of two neighboring elements the element itself and its right neighbor consider that the right neighbor of the th element is the th element Formally speaking a new array is being built from array such that where is the greatest common divisor of and and is the remainder of dividing by In one step the array is built and then the array is replaced with that is the assignment is taking place For example if then Thus after one step the array will be equal to For a given array find the minimum number of steps after which all values become equal that is If the original array consists of identical elements then consider the number of steps is equal to ,First note that the array stabilizes if and only if it consists of equal elements and the number the array will be consisted of is Indeed at the th step a number equal to will be written at the th position in the array This is easy to prove by induction if at the previous step the adjacent elements in the array were equal to of the numbers on adjacent segments of length in the original array then their greatest common divisor will be the greatest common divisor of the union of these two segments GCD is an idempotent operation Thus the algorithm will stop in no more than steps since after steps all numbers will be equal exactly to If we divide all the numbers by before starting the algorithm then the number of steps won t change but the array will stabilize at the number Since the numbers in the array after the th step will be exactly equal to of all segments of length of the original array it follows that the number of steps after which all values become the same is exactly equal to the length of the maximum segment of the original array on which There are several ways to find the length of such a segment For example you can use range GCD query and binary search The following method is based on the factorization of numbers in other words on their decomposition into prime factors Factorization in this problem could be done using both the sieve of Eratosthenes or factoring each number independently in After all the numbers have been factorized iterate over each and each prime in its factorization In linear time we can go left and right from finding the maximum segment of numbers that contain the same factor Then we can update the answer with the length of this segment and move onto the next prime in the factorization of or go to if all primes have already been iterated through Note that if a segment of numbers divisible by contains indices from to then we iterate through it times In order to avoid reiteration on each segment we remove from the factorizations of all numbers on the segment after considering only one The resulting solution works in where the maximum number of different primes in factoriztion of Considering that so the solution fits into the time limit 
There are cities in Berland Some pairs of cities are connected by roads All roads are bidirectional Each road connects two different cities There is at most one road between a pair of cities The cities are numbered from to It is known that from the capital the city with the number you can reach any other city by moving along the roads The President of Berland plans to improve the country s road network The budget is enough to repair exactly roads The President plans to choose a set of roads such that it is possible to travel from the capital to any other city along the chosen roads if is the number of roads needed to travel from the capital to city moving only along the chosen roads then is minimized i e as minimal as possible In other words the set of roads should preserve the connectivity of the country and the sum of distances from city to all cities should be minimized where you can only use the chosen roads The president instructed the ministry to prepare possible options to choose roads so that both conditions above are met Write a program that will find possible ways to choose roads for repair If there are fewer than ways then the program should output all possible valid ways to choose roads ,Use BFS to precalculate an array the array of the shortest path lengths from the Capital The condition to minimize sum of distances in each tree is equal to the fact that each tree is a shortest path tree Let s think about them as about oriented outgoing from the Capital trees Moving along edges of such trees you always move by shortest paths An edge can be included into such a tree if and only if since original edges are bidirectional you should consider each of them twice as and as Let s focus only on edges for which Call them red edges To build a tree for each city except the Capital you should choose exactly one red edge finishing in this city That s why the number of suitable trees is a product of numbers of incoming edges over all vertices cities But we need to find only of such trees Let s start from some such tree and rebuild it on each step As initial tree you can choose the first incoming red edge into each vertex except the City Actually we will do exactly increment operation for number in a mixed radix notation To rebuild a tree iterate over vertices and if the current used red edge is not the last for the vertex use the next and stop algorithm Otherwise the last red edge is used use the first red edge for this vertex and go to the next vertex and continue with the next vertex Compare this algorithm with simple increment operation for long number 
There are railway stations in Berland They are connected to each other by railway sections The railway network is connected i e can be represented as an undirected tree You have a map of that network so for each railway section you know which stations it connects Each of the sections has some integer value of the However these values are not marked on the map and you don t know them All these values are from to inclusive You asked passengers some questions the th one told you three values his departure station his arrival station minimum scenery beauty along the path from to the train is moving along the shortest path from to You are planning to update the map and set some value on each railway section the The passengers answers should be consistent with these values Print any valid set of values which the passengers answer is consistent with or report that it doesn t exist ,Firstly let s precalculate arrays The array is the array of parents if we run dfs from the vertex So is the vertex that is the previous one before on the directed path This part can be precalculated in time and we need it just for convenience Initially all values beauties of the edges are zeros Let s consider queries in order of non decreasing For the current query let s consider the whole path and update the value for each on this path in the following way After processing all queries let s replace all values with This part works also in time And the last part of the solution is to check if the data we constructed isn t contradictory We can iterate over all paths and find the minimum value on this path We have to sure if it equals If it isn t true for at least one query then the answer is Otherwise we can print the resulting tree Time complexity but it can be done in at least I hope someone can explain this solution because I am too lazy to do it now 
You are given a bracket sequence not necessarily a regular one A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and and and are not Your problem is to calculate the number of regular bracket sequences of length containing the given bracket sequence as a substring consecutive sequence of characters modulo ,At first let s calculate the matrix of size Let will denote the maximum length of the prefix of which equals to the suffix of the prefix of of length with the additional character if and otherwise In other words is denote which maximum length of the prefix of we can reach if now we have the prefix of of length and want to add the character if and otherwise and only one possible move is to remove characters from the beginning of this prefix with an additional character This matrix can be easily calculated in without any dynamic programming It can be also calculated in using prefix function and dynamic programming Now let s calculate the following dynamic programming It means that now we have gained characters of the regular bracket sequence the balance of this sequence is the last characters of the gained prefix is the prefix of of length and equals to if we obtain the full string at least once and otherwise The stored value of the is the number of ways to reach this state Initially all other values equal The following recurrence works try to add to the current prefix character if the current balance is less than then we will move to the state is the length of and is operation if at least one is true then the result is true Let s add to the number of ways to reach the destination state the number of ways to reach the current state The same with the character Try to add to the current prefix character if the current balance is greater than then we will move to the state Also add to the number of ways to reach the destination state the number of ways to reach the current state After calculating this dynamic programming the answer is Time complexity is 
A tree is a connected undirected graph without cycles Note that in this problem we are talking about not rooted trees You are given four positive integers and Construct a tree such that it contains vertices numbered from to the distance length of the shortest path from vertex to vertex is distance from vertex to vertex is the distance from vertex to vertex is Output any tree that satisfies all the requirements above or determine that no such tree exists ,If the answer exists you can hang the tree by some vertex such that the distances and can be expressed through the sums of distances to vertices and Then from the system of equations we express the required values of distances to vertices and construct a suitable tree If the distance to a vertex is then that vertex is the root There cannot be two roots nor can there be negative distances If none of the vertices of is the root then make vertex the root Next we build the required tree add the required number of unique vertices on the path from the root to vertices Note also that if the sum of distances is greater than or equal to then we cannot build the tree either The remaining vertices can be simply joined to the root 
There are players sitting at the card table Each player has a favorite number The favorite number of the th player is There are cards on the table Each card contains a single integer the th card contains number Also you are given a sequence Its meaning will be explained below The players have to distribute all the cards in such a way that each of them will hold exactly cards After all the cards are distributed each player counts the number of cards he has that contains his favorite number The joy level of a player equals if the player holds cards containing his favorite number If a player gets no cards with his favorite number i e his joy level is Print the maximum possible total joy levels of the players after the cards are distributed Note that the sequence is the same for all the players ,It is obvious that we can solve the problem separately for each favorite number because each player has only one favorite number and if the player gets a card not having his favorite number his joy will not change Let be the maximum possible total joy of players with the same favorite number it doesn t matter which one and cards containing their favorite number if the cards are distributed among the players optimally Note that and At the beginning all entries of the table are zeroes The transition in this dynamic programming depends on how many cards the th player will receive which is between and In other words the dynamic programming transition will look like for int i 0 i k i dp x 1 y i max dp x 1 y i dp x y h i where is the joy of the player if he receives exactly cards containing his favorite number Note that After filling the table the answer can be calculated very easily where is the number of players with favorite number and is the number of cards containing the number Time complexity is 
You are given an integer array of length You have to choose some subsequence of this array of maximum length such that this subsequence forms a increasing sequence of consecutive integers In other words the required sequence should be equal to for some value and length Subsequence of an array can be obtained by erasing some possibly zero elements from the array You can erase any elements not necessarily going successively The remaining elements preserve their order For example for the array the following arrays are subsequences but the array is not ,Let be the answer for our problem if the last element of our subsequence equals to Then we have an easy solution let s store as a C or Java Initially for each Then let s iterate over all in order of input and try to update with a Then the maximum element of will be our answer Let it be Then let s find any such that Let it be Then for restoring the answer we need to iterate over all elements of our array in reverse order and if the current element then push to the array of positions of our subsequence and make 
It all started with a black and white picture that can be represented as an matrix such that all its elements are either or The rows are numbered from to the columns are numbered from to Several operations were performed on the picture possibly zero each of one of the two kinds choose a cell such that it s not on the border neither row or nor column or and it s surrounded by four cells of the opposite color four zeros if it s a one and vice versa and paint it the opposite color itself make a copy of the current picture Note that the order of operations could be arbitrary they were not necessarily alternating You are presented with the outcome all copies that were made Additionally you are given the initial picture However all pictures are shuffled Restore the sequence of the operations If there are multiple answers print any of them The tests are constructed from the real sequence of operations i e at least one answer always exists ,Notice the following once you apply the recolor operation to some cell you can never recolor it again That happens because you can t recolor its neighbors too as each of them has at least one neighbor of the same color this cell itself In particular that implies that applying a recolor operation always decreases the possible number of operations that can be made currently It doesn t always decrease them by from to operations can become unavailable but it always decreases That gives us an order of copies Just sort them in the decreasing order of the number of recolor operations that can be made currently If the numbers are the same the copies must be equal so their order doesn t matter The only thing remains is to apply the operations Turns out their order doesn t matter at all Consider all different cells for a pair of adjacent pictures It s never possible that there are two different cells that are adjacent to each other Thus no operation can interfere with another one Just print all positions of different cells in any order you want and make a copy Overall complexity 
You are given an array consisting of integers In one move you can choose some index and shift the segment cyclically to the right i e replace the segment with Your task is to sort the initial array by or say that it is impossible to do that You have to answer independent test cases ,Firstly let s solve the easier version of the problem Assume we are given a permutation not an array Notice that the given operation applied to some segment of the permutation cannot change the parity of number of inversions the number of inversions is the number of such pairs of indices that and So if the number of inversions in the given permutation is odd then we can t sort this permutation we can t obtain zero inversions But if the number of inversions is even then we can always sort the permutation with the following greedy algorithm let s find the minimum element and move it to the first position If its position is then we can apply the operation to the segment and our element will move by two positions to the left So after all our element is either at the first or at the second position If it s at the second position let s just apply two additional operations to the segment Then let s just cut off the first element and solve the problem without it At the end we have only two numbers that can be not sorted and we can check all three possibilities and choose one which is suitable for us it s always exists because the number of inversions is even How do we solve the problem if we are given the array not the permutation First of all we can prove that if the array contains at least two equal elements we can always sort it we will prove it by construction Let s just renumerate the elements of the given array in a way to obtian the permutation with the even number of inversions Thus if then let s find such a permutation that We can find this permutation easily if we sort the array of pairs in increasing order But there can be one problem this permutation can have odd number of inversions Then we need to find two consecutive pairs with the same first values and swap these two elements in the permutation Because in fact these two numbers are equal in the array and have consecutive values in the permutation we guaranteed change the parity of number of inversions Then we can apply our algorithm for permutations and solve the problem for the array If we failed then the answer is Otherwise the number of operations always does not exceed because this sort works like a bubble sort so our answer is suitable Time complexity 
Dasha an excellent student is studying at the best mathematical lyceum in the country Recently a mysterious stranger brought words consisting of small latin letters to the lyceum Since that day Dasha has been tormented by Consider some pair of integers is a string for which it is true It is obtained by concatenation Its length is The number of different letters in it is The number of occurrences of each letter that is in the word is For example if abcdefg and ijklmnopqrstuvwxyz the pair creates a Dasha will stop having if she counts their number There are too many so Dasha needs your help Count the number of different are called different if the corresponding pairs are different The pairs and are called different if ,Observation the product of odd numbers is odd so the condition for the length of is automatically completed Denote by the number of ones in binary representation of Let s enumerate the letters of the Latin alphabet from to Observation for each word it is enough to know the set of letters included in it and the evenness of their numbers There are only letters in the alphabet so it is convenient to store the word characteristic as a pair of masks The bit with the number in will be responsible for the availability of the letter in The bit with the number in will be responsible for the evenness of the number of letters in Observation strings creates if and only if Let s fix the number the index of the letter that will not be in Let s throw out all the words with the letter now we can look at the words in turn and look for a pair of them among those already considered It is easy to see that the condition follows from the condition if one letter is banned To count the number of pairs that include our word we need to count the number of words with the characteristic We can do this by bin searching through a sorted array of or using standard data structures We got the solution for 
You are playing one famous sandbox game with the three dimensional world The map of the world can be represented as a matrix of size where the height of the cell is You are in the cell right now and want to get in the cell You can move only down from the cell to the cell or right from the cell to the cell There is an additional if the height of the current cell is then you can move only to the cell with height you can perform several operations During one operation you can decrease the height of cell by one I e you choose some cell and assign set Note that you make heights Also note that you decrease the height of the cell Your task is to find the number of operations you have to perform to obtain at least one suitable path from the cell to the cell It is guaranteed that the answer exists You have to answer independent test cases ,Firstly consider the field in indexation Suppose that the cell has some fixed height Let it be Then we can determine what should be the height of the cell as In fact it does not matter which way we choose we actually need only the number of moves to reach the cell and the height of the cell Then when the height of the cell is fixed we can solve the problem with the following dynamic programming is the minimum number of operations we need to reach the cell from the cell Initially all values except Then can be calculated as But one more thing if then this value of is incorrect and we cannot use it We also can t update from the incorrect values The answer for the problem with the fixed height of the cell is only when is correct and This part can be calculated in But if we iterate over all possible heights our solution obvious will get time limit exceeded verdict Now we can notice one important fact in the optimal answer the height of some cell remains unchanged Let this cell be Then we can restore the height of the cell as and run our quadratic dynamic programming to find the answer for this height Time complexity 
Your friend Ivan asked you to help him rearrange his desktop The desktop can be represented as a rectangle matrix of size consisting of characters empty cell of the desktop and an icon The desktop is called if all its icons are occupying some prefix of full columns and possibly the prefix of the next column and there are no icons outside this figure In other words some amount of first columns will be filled with icons and possibly some amount of first cells of the next after the last full column column will be also filled with icons and all the icons on the desktop belong to this figure This is pretty much the same as the real life icons arrangement In one move you can take one icon and move it to any empty cell in the desktop Ivan loves to add some icons to his desktop and remove them from it so he is asking you to answer queries what is the number of moves required to make the desktop after adding removing one icon Note that and change the state of the desktop ,I ve seen a lot of data structures solutions for this problem but author s solution doesn t use them and works in Firstly let s change our matrix to a string because it will be easier to work with a string than with a matrix The order of characters will be from top to bottom from left to right i e the outer cycle by columns and the inner by rows Then let s calculate the number of icons on the desktop the number of in Then the answer will be obviously the number of dots on the prefix of of size Now let s deal with queries It can be shown that one query changes our answer by no more than Let be the position of the cell that is being changed in zero indexed Then if there are two cases If is then we have one more icon on our prefix so the answer decreases by one because we filled one empty space in the good desktop Otherwise it increases by one because this icon is outside our prefix Then let s change the corresponding character by the opposite After that we should move our right border accordingly to the new number of icons Note that this border is exclusive If becomes then we will increase the variable But before that if is then there should be an icon and it is not here yet so the answer increases Otherwise our border will decrease Then if is then the answer decreases because there was a place for an icon and now it is not needed anymore Time complexity 
You are playing a computer card game called Splay the Sire Currently you are struggling to defeat the final boss of the game The boss battle consists of turns During each turn you will get several cards Each card has two parameters its cost and damage You may play some of your cards during each turn in some sequence you choose the cards and the exact order they are played as long as After playing some possibly zero cards you end your turn and Note that you can use each card Your character has also found an artifact that boosts the damage of some of your actions every th card you play deals double damage What is the maximum possible damage you can deal during turns ,The first and crucial observation is that we don t need all the cards that we get during each turn In fact since the total cost is limited to we may leave three best cards of cost one best card of cost and one best card of cost and all other cards may be discarded So the problem is reduced we get only cards each turn The problem may be solved with dynamic programming is the maximum damage we may deal if we played turns and the last card we played had remainder modulo Processing each turn may be done with auxiliary dp the maximum damage we can deal during the turn if we play cards and denotes whether some card there will be only one such card obviously deals double damage To calculate this auxiliary dp we may do almost anything since we are limited to cards during each turn It is possible to calculate it in a fast way using some casework but it is easier for example to try all possible permutations of cards and play some prefix of a fixed permutation By combining these two techniques we get a solution 
Polycarp has decided to decorate his room because the New Year is soon One of the main decorations that Polycarp will install is the garland he is going to solder himself Simple garlands consisting of several lamps connected by one wire are too boring for Polycarp He is going to solder a garland consisting of lamps and wires Exactly one lamp will be connected to power grid and power will be transmitted from it to other lamps by the wires Each wire connectes exactly two lamps one lamp is called for this wire the one that gets power from some other wire and transmits it to this wire the other one is called the one that gets power from this wire Obviously each lamp has at most one wire that brings power to it and this lamp is the auxiliary lamp for this wire and the main lamp for all other wires connected directly to it Each lamp has a brightness value associated with it the th lamp has brightness We define the of the wire as the sum of brightness values over all lamps that become disconnected from the grid if the wire is cut and all other wires are still working Polycarp has drawn the scheme of the garland he wants to make the scheme depicts all lamp and wires and the lamp that will be connected directly to the grid is marked the wires are placed in such a way that the power can be transmitted to each lamp After that Polycarp calculated the importance of each wire enumerated them from to in descending order of their importance and then wrote the index of the main lamp for each wire in the order from the first wire to the last one The following day Polycarp bought all required components of the garland and decided to solder it but he could not find the scheme Fortunately Polycarp found the list of indices of main lamps for all wires Can you help him restore the original scheme ,First of all we don t like the fact that importance values can be integers up to it is kinda hard to work with them Let s rephrase the problem The highest bit set to in the importance value denotes the maximum in the subtree rooted at the auxiliary lamp for the wire So we sort the wires according to the maximums in their subtrees To break ties we could consider the second maximum then the third maximum but that s not convenient We can use something much easier suppose there are two vertices with the same maximum in their subtrees these vertices belong to the path from the root to the maximum in their subtrees and the one which is closer to the root has the greater importance value So to get the order described in the problem statement we could sort the vertices according to the maximum in their subtrees and use depth as the tie breaker What does this imply All vertices of some prefix are ancestors of vertex so some prefix denotes the path from the root to excluding itself Then there are some values describing the path from some already visited vertex to if was not met before then to and so on How can we use this information to restore the original tree is the root obviously Then the sequence can be separated into several subsegments each representing a vertical path in the tree and each vertex is the parent of the next vertex in the sequence if they belong to the same subsegment How can we separate these vertices into subsegments and how to find the parents for vertices which did not appear in the sequence at all Suppose some vertex appears several times in our sequence The first time it appeared in the sequence it was in the middle of some vertical path so the previous vertex is its parent and every time this vertex appears again it means that we start a new path and that s how decomposition into paths is done Determining the parents of vertices that did not appear in the sequence is a bit harder but can also be done Let s recall that our sequence is decomposed into paths from root to from some visited vertex to from some visited vertex to and so on so each time the path changes it means that we have found the maximum vertex among unvisited ones So we should keep track of the maximum vertex that was not introduced in the sequence while we split it into paths and each time a path breaks it means that we found the vertex we were keeping track of Overall this solution can be implemented in 
Polycarp is wondering about buying a new computer which costs tugriks To do this he wants to get a job as a programmer in a big company There are positions in Polycarp s company numbered starting from one An employee in position earns tugriks every day The higher the position number the more tugriks the employee receives Initially Polycarp gets a position with the number and has tugriks Each day Polycarp can do one of two things If Polycarp is in the position of then he can earn tugriks If Polycarp is in the position of and has at least tugriks then he can spend tugriks on an online course and move to the position For example if then Polycarp can act like this On the first day Polycarp is in the st position and earns tugrik Now he has tugrik On the second day Polycarp is in the st position and move to the nd position Now he has tugriks On the third day Polycarp is in the nd position and earns tugriks Now he has tugriks On the fourth day Polycarp is in the nd position and is transferred to the rd position Now he has tugriks On the fifth day Polycarp is in the rd position and earns tugriks Now he has tugriks On the sixth day Polycarp is in the rd position and earns tugriks Now he has tugriks Six days later Polycarp can buy himself a new computer Find the minimum number of days after which Polycarp will be able to buy himself a new computer ,Since the array a does not decrease if we want to get the position x at some point it is best to get it as early as possible because if we get it earlier we will earn no less money Therefore the solution looks like this rise to some position and earn money on it for a laptop Let s go through the number of the position and use simple formulas to calculate the number of days it takes to raise to this position and the number of days it takes to buy a laptop From all the options choose the minimum one 
You are given a matrix consisting of rows and columns Each cell contains an integer in it You can change the order of rows arbitrarily including leaving the initial order but you can t change the order of cells in a row After you pick some order of rows you traverse the whole matrix the following way firstly visit all cells of the first column from the top row to the bottom one then the same for the second column and so on During the traversal you write down the sequence of the numbers on the cells in the same order you visited them Let that sequence be The traversal is acceptable if for all Find the maximum integer such that there exists some order of rows of matrix that it produces a acceptable traversal ,Really low constraints choosing some permutation Surely this will be some dp on subsets At first let s get rid of For each two rows calculate the minimum difference between the elements of the same columns let s call this for some rows This will be used to put row right after row Let s also calculate the minimum difference between the elements of the column of row and column of row This will be used to put row as the last row and row as the first one Now let s think of choosing the permutation as choosing the traversal of the following graph Vertices are rows and the weights of edges between the vertices are stored in However you can t straight up do minimum weight Hamiltonian cycle search as the edge between the first vertex and the last one should be of weight from and not Let s fix some starting vertex and find minimum weight Hamiltonian paths from it to all vertices Finally update the answer with That will lead to approach minimum weight Hamiltonian path is a well known problem solved by That s completely fine and it s the most intended solution However there exist another solution that would have worked better if the edge weight were a bit smaller Let s do binary search each time checking if the answer is greater or equal to The check is simple enough Now the graph is binary edge exists if its weight is greater or equal to thus you should check for existence of Hamiltonian path not for the minimum weight one That can be done in leading to solution The key idea of that dp is storing the vertices where the path of the current mask could have ended as a mask itself Then it becomes with transitions Overall complexity or 
Polycarp was gifted an array of length Polycarp considers an array beautiful if there exists a number such that each number in the array occurs either zero or times Polycarp wants to remove some elements from the array to make it beautiful For example if and then the following options are possible to make the array array beautiful Polycarp removes elements at positions and array becomes equal to Polycarp removes elements at positions and array becomes equal to Polycarp removes elements at positions and array becomes equal to Help Polycarp determine the minimum number of elements to remove from the array to make it beautiful ,Let s calculate the value of how many times the number occurs in the array We will iterate over the value of and look for the minimum number of moves necessary for each number to appear in the array either times or times Note that if there is no such number that then such a value of will not give the minimum answer because we have removed unnecessary elements Then for a specific the answer is calculated as follows Since the number of candidates for the value of is no more than this method works in Then there are two ways to optimize our solution you can consider only unique values of there are no more than and get a solution in you can sort the values and use prefix sums this solution works for or for if you use counting sort 
You are given two strings and both of length and both consisting of lowercase Latin letters In one move you can choose any length from to and perform the following operation Choose any contiguous substring of the string of length and reverse it choose any contiguous substring of the string of length and reverse it as well Note that during one move you reverse substring of the string and substring of the string Also note that borders of substrings you reverse in and in the only restriction is that you reverse the substrings of equal length For example if and you can reverse and and but not and Your task is to say if it is possible to make strings and equal after some possibly empty sequence of moves You have to answer independent test cases ,The necessary condition to make strings equal is that the number of occurrences of each character should be the same in both strings Let s show that if some character appears more than once we always can make strings equal How Let s sort the first string by swapping adjacent characters and it does not matter what do we do in the second string Then let s sort the second string also by swapping adjacent characters but choose the pair of adjacent equal characters in the first string it always exists because the first string is already sorted Otherwise all characters in both strings are distinct and they lengths are at most Then the answer is if the parity of the number of inversions the number inversions in the array is the number of such pairs of indices that but are the same It can be proven in the following way every swap of two adjacent elements changes the parity of the number of inversions Time complexity 
 is a set of numbers in which there can be equal elements and the order of the numbers does not matter Two multisets are equal when each value occurs the same number of times For example the multisets and are equal but the multisets and are not You are given two multisets and each consisting of integers In a single operation any element of the multiset can be doubled or halved rounded down In other words you have one of the following operations available for an element of the multiset replace with or replace with round down Note that you cannot change the elements of the multiset See if you can make the multiset become equal to the multiset in an arbitrary number of operations maybe For example if then the answer is yes We can proceed as follows Replace with We get Replace with We get Replace with We get Replace with We get Got equal multisets and ,We divide each number from the multiset by as long as it is divisible without a remainder Because if we can get a new number from the multiset we can also increase it to the original number by multiplication by Now notice that it does not make sense to use the first operation multiplication by because we get an even number and only odd numbers remain in the multiset Then we take the largest number from and if it is in we remove this number from both multisets Otherwise we use the second operation if the number is greater than If it is equal to then it is impossible to equalize the multisets and 
A tree is an undirected connected graph without cycles You are given a tree of vertices Find the number of ways to choose exactly vertices in this tree i e a element subset of vertices so that all pairwise distances between the selected vertices are equal in other words there exists an integer such that for all are in selected vertices where is the distance from to Since the answer may be very large you need to output it modulo ,If any set of two vertices may be taken so the answer is modulo Suppose Consider three vertices such that If this equality is true there s a vertex that belongs to all three paths otherwise either one of the vertices belongs to the path between two others or there is more than one simple path i e path having distinct edges between any of the vertices so the graph isn t a tree Hence the following equalities are true Then hence Suppose Let s select vertices that is a correct desired set of four vertices for the triple of paths let s select a common vertex and for the triple Because is the same vertex as The same procedure we can do for all other pairs of triples of vertices The situation will not be another if we add a new vertex in the set if the set will still meet the problem s conditions So if a vertex exists such that all vertices of the set are equidistant from it Note that for each set only one such exists Let s iterate over all vertices taking them as and hang the tree by The set of vertices equidistant from meets the problem s condition if and only if the vertices of the set are placed in different subtrees of vertices adjacent to in other words the paths from them to must intersect only in Let s calculate the number of desired sets for a given and a layer of equidistant vertices Let be the number of vertices adjacent to and it s the number of subtrees too Let s create an array indexed of size so that the th element will contain the number of the vertices of the layer in the th subtree For the layer of vertices adjacent to this array will be filled with For the other layers we can update the array as follows let s mark and vertices adjacent to as used then for every vertex of the current layer let s decrease by if is the index of the subtree of the vertex then let s increase by the number of the vertices adjacent to the current one but not used Then let s mark the vertices as used After the iteration the array will correspond to the new layer Using the array let s calculate the number of the desired sets of vertices using the concept of dynamic programming Let s create an array indexed of size will contain a number of found sets of vertices if only subtrees have been considered Let s fill the array with except Let s start a loop with parameter from to and the internal one with parameter from to In every step we can either take a vertex from th subtree or take nothing If we take a vertex from the subtree it s possible only if then we have ways to select vertices considering subtrees so that the last vertex belongs to the th subtree This value we must add to that must contain all ways to select vertices from subtrees If we ignore the subtree the number of ways to select vertices from subtrees ignoring the th subtree is It must be added to the number of ways to select vertices from subtrees The answer for the current and the current layer of equidistant vertices is The answer for the whole tree is the sum of the answers for all and for all layers of equidistant vertices Remember that all arithmetical operations must be done modulo The number of possible central vertices is For every central vertex and every layer we perform two actions recalculate the array and calculate the number of the corresponding sets using the concept of dynamic programming The recalculation of works in it s just BFS starting from so for every central vertex it works in O n The dynamic programming for the current and the current layer works in for the current and all layers in The summary time corresponding to the current is The total algorithm work time is The sum of all is a total number of the adjacent vertices to all vertices it s just a double number of edges So the total work time is 
You are given a connected undirected graph consisting of vertices and edges There are no self loops or multiple edges in the given graph You have to direct its edges in such a way that the obtained directed graph does not contain any paths of length two or greater where the length of path is denoted as the number of traversed edges ,What if the given graph will contain a cycle of odd length It will mean that some two consecutive edges of this cycle will be oriented in the same way and will form a path of length two What if there is no cycles of odd length in this graph Then it is bipartite Let s color it and see what we got We got some vertices in the left part some vertices in the right part and all edges connecting vertices from different parts Let s orient all edges such that them will go from the left part to the right part That s it 
You are given two integers and where We will add to until the result is equal to Thus there will be exactly additions performed For each such addition let s look at the number of digits that will be changed after it For example if then adding one will result in and digits will be changed if you add one to the result will be and digits will also be changed if you add one to the result will be and digits will be changed Changed digits always form a suffix of the result written in the decimal system Output the total number of changed digits if you want to get from adding each time ,For each digit we will count how many times it has changed The number of changes for the first digit the lowest is calculated using the formula The number of changes for the second digit is calculated by the formula That is it is equivalent to the number of first digit changes for numbers from to To calculate the number of changes for the remaining digits you need to apply similar reasoning with dividing the numbers by 
Vlad found a flowerbed with graphs in his yard and decided to take one for himself Later he found out that in addition to the usual graphs flowers also grew on that flowerbed A graph is called a flower if it consists of a simple cycle of length through each vertex of which passes its own simple cycle of length and these cycles do not intersect at the vertices For example flower looks like this Note that flower and flower do not exist since at least vertices are needed to form a cycle Vlad really liked the structure of the flowers and now he wants to find out if he was lucky to take one of them from the flowerbed ,Note a few things There are exactly vertices in the flower since from each of the vertices of the main cycle comes another cycle of size in the flower all vertices have degree except for the vertices of the main cycle whose degrees are it follows that in flower edges The listed properties do not take into account only the connectivity of the graph and the sizes of our cycles To check connectivity we run a bfs or dfs from any vertex and check that all vertices have been visited To check the cycle lengths we cut out the edges of the main one and make sure that the graph has fell apart into components of size 
You are given a connected undirected weighted graph consisting of vertices and edges You need to print the th smallest shortest path in this graph paths from the vertex to itself are not counted paths from to and from to are counted as one More formally if is the matrix of shortest paths where is the length of the shortest path between vertices and then you need to print the th element in the sorted array consisting of all where ,The main observation is that you don t need more than smallest by weight edges among all edges with the maximum weights you can choose any Maybe there will be a proof later but now I ask other participant to write it So you sort the initial edges and after that you can construct a graph consisting of no more than vertices and no more than edges You just can build the new graph consisting only on these vertices and edges and run Floyd Warshall algorithm to find the matrix of shortest paths Then sort all shorted distances and print the th element of this sorted array Time complexity I know that there are other approaches that can solve this problem with greater but to make this problem easily this solution is enough 
Given the string of decimal digits of length A substring is a sequence of consecutive characters of a string The substring of this string is defined by a pair of indexes with its left and right ends So each pair of indexes where corresponds to a substring of the string We will define as the numeric value of the corresponding substring leading zeros are allowed in it For example if then and You are given and an integer You need to process queries each of which is characterized by numbers The answer to the th query is such a pair of substrings of length that if we denote them as and then that is the substrings are different the remainder of dividing a number by is equal to If there are many matching substring pairs then find a pair where is as small as possible If there are many matching pairs in this case then minimize Note that the answer may not exist ,Note that the remainder of dividing a number by is equal to the remainder of dividing its sum of digits by This is easy to check because the number of digits is representable as a polynomial and gives a remainder of when divided by for any Let s count an array of prefix sums of digits for the string Now knowing we can pre calculate for each remainder modulo all possible Also for each query we can easily find the remainder of dividing by using all the same prefix sums Let s iterate over the remainder of the number when dividing by Knowing it we can easily find the remainder of the number when divided by as modulo Now using each pair of remainers let s try to update the answer then the minimum index from the pre calculated array will act as and the next largest will act as if such exist then the minimum indexes from the pre calculated array will act as and This solution works for or for 
 people gathered in a room with tables They want to play the Hat times Thus games will be played at each table Each player will play in games To do this they are distributed among the tables for each game During each game one player plays at exactly one table A player can play at different tables Players want to have the most fair schedule of games For this reason they are looking for a schedule table distribution for each game such that At any table in each game there are either people or people that is either rounded down or rounded up Different numbers of people can play different games at the same table Let s calculate for each player the value the number of times the th player played at a table with persons rounded up Any two values of must differ by no more than In other words for any two players and it must be true For example if and then at the request of the first item either two players or three players should play at each table Consider the following schedules First game are played at the first table and at the second one The second game at the first table they play and at the second This schedule is since the second player played twice at a big table and the fifth player did not play at a big table First game are played at the first table and at the second one The second game at the first table they play and at the second one This schedule is any two values of differ by no more than Find any fair game schedule for people if they play on the tables of games ,For each game we want to seat people at tables of them will be big and will sit at them and will be small Each round people will sit at the big tables Let s put people with numbers at large tables in the first round for convenience we index from zero and the rest for small ones in the second round we will seat people at large tables with numbers and so on We cycle through the players from to in blocks of Since no one person can be ahead of any other by 2 or more large tables 
You are given an undirected graph consisting of vertices A number is written on each vertex the number on vertex is Initially there are no edges in the graph You may add some edges to this graph but you have to pay for them The cost of adding an edge between vertices and is coins There are also special offers each of them is denoted by three numbers and and means that you can add an edge connecting vertices and and pay coins for it You don t have to use special offers if there is a pair of vertices and that has a special offer associated with it you still may connect these two vertices paying coins for it What is the minimum number of coins you have to spend to make the graph connected Recall that a graph is connected if it s possible to get from any vertex to any other vertex using only the edges belonging to this graph ,Suppose we have found all the edges of the graph explicitly sorted them and start running Kruskal on the sorted list of edges Each time we add some edge to MST it is either a special edge given in the input or an edge which was generated with cost whichever costs less Let s try to analyze how can we find the cheapest edge of each type that connects two components For special edges we may just maintain the number of special edges we already added or skipped and when choosing a new edge we skip some more possibly zero special edges that don t connect anything until we find an edge that connects something And for the other type of edges we may find two components having minimum numbers on the vertices in those components as small as possible and just connect the minimum vertex in the first component with the minimum vertex in the second component We may simulate this by maintaining a data structure for example a multiset where for each component we will store the vertex having minimum in this component and pick two minimums from this set We also have to be able to check if two vertices are connected this can be done with DSU and merge two components But this solution can be made easier Every time we add a non special edge one of the ends of this edge is the vertex with minimum So we may just find this vertex generate all edges connecting this vertex to all other vertices merge this set of edges with the set of special edges and run any MST algorithm on the resulting set of edges If there are multiple minimums in the array then we may pick any of them because in Kruskal algorithm it doesn t matter which of the edges with equal costs we try to add first 
You are given the array consisting of elements and the integer You want to obtain equal elements in the array In one move you can make one of the following two operations Take of the minimum elements of the array and increase its value by one more formally if the minimum value of is then you choose such index that and set take of the maximum elements of the array and decrease its value by one more formally if the maximum value of is then you choose such index that and set Your task is to calculate the minimum number of moves required to obtain equal elements in the array ,This problem is just all about the implementation Firstly let s sort the initial values and compress them to pairs where is the number of elements The first observation is pretty standard and easy some equal elements will remain unchanged So let s iterate over all elements in some order and suppose that all elements will remain unchanged Firstly we need elements which we should obtain by some moves The second observation is that we first need to take elements from one end only less or only greater and only then from the other if needed Consider the case when we first take less elements The other case is almost symmetric Let be the number of less than which we need to increase to If then skip the following step Otherwise let be the number of elements less than or equal to be the sum of all elements less than or equal to and be the previous value the maximum value less than Then we need to increase all elements less than or equal to at least to the value It costs moves And then we need moves to increase elements to And let be the number of elements greater than which we need to decrease to if we increased elements already If then skip the following step Otherwise let be the number of elements greater than or equal to be the sum of all elements greater than or equal to and be the next value the minimum value greater than Then we need to decrease all elements greater than or equal to at least to the value It costs moves And then we need moves to decrease elements to So we can update the answer with the sum of values described above and proceed to the next value Arrays are just simple prefix and suffix sums which can be calculated in using very standard and easy dynamic programming Don t forget about the overflow Total time complexity because of sorting 
There are people in a row The height of the th person is You can choose subset of these people and try to arrange them into a A is such an order of people that the difference between heights of any adjacent people is no more than For example let heights of chosen people be where is the number of people you choose Then the condition should be satisfied for all from to and the condition should be also satisfied means the absolute value of It is obvious that the circle consisting of one person is balanced Your task is to choose the maximum number of people and construct a consisting of all chosen people It is obvious that the circle consisting of one person is balanced so the answer always exists ,Let s realize what we need to construct the with heights from l to r We can represent it as l l 1 dots r 1 r r 1 dots l 1 As we can see we need one occurrence of l and r and two occurrences of all other heights from l 1 to r 1 How can we find the using this information We can find the segment of neighboring heights with at least two occurrences using the array of frequencies cnt sorted array of unique heights b and two pointers technique For the current left border l we should increase r initially it is l 1 and it is an excluded border while b r b r 1 1 and cnt b r ge 2 Then for the current left and right borders we can try to extend the segment to the left if b l b l 1 1 and to the right if b r 1 b r 1 and try to update the answer with the the current segment and go to the next segment There may be some corner cases like n 1 or all cnt are 1 but you can avoid them if you will implement the solution carefully There are almost no corner cases in my solution you can see details of implementation in authors code Time complexity O n log n or O n depends on sorting method 
You are given a tree which consists of vertices Recall that a tree is a connected undirected graph without cycles Vertices are numbered from to All vertices have weights the weight of the vertex is Recall that the distance between two vertices in the tree is the number of edges on a simple path between them Your task is to find the subset of vertices with the maximum total weight the weight of the subset is the sum of weights of all vertices in it such that there is no pair of vertices with the distance or less between them in this subset ,Let s solve this problem using dynamic programming on a tree Suppose the tree is rooted and the root of the tree is Also let s increase to find the subset in which any pair of vertices had distance or greater instead of or greater Let be the maximum total weight of the subset in the subtree of if the vertex with the minimum depth we took has depth Then the answer is Firstly let s calculate this dynamic programming for all children of Then we are ready to calculate all for all from to Let the current depth be then there are two cases if then Otherwise let s iterate over all children of and let be such child of that the vertex with the minimum depth we took is in the subtree of Then After we calculated all values of for the vertex we can notice that this is not what we wanted The current value of means the maximum total weight of the subset in the subtree of if the vertex with the minimum depth we took has depth To fix this let s push to for all depths from to Time complexity but it can be easily optimized to using some prefix and suffix maximums You can ask why this is but not because we iterating over all vertices then over all possible depths and then over children of the vertex and again over children of the vertex But in fact this is because if we change the order of multiplication we can see that we are iterating over pairs parent child then over children and possible depths and the number of such pairs is so the complexity is 
You are given a tree consisting of vertices A tree is a connected undirected graph with edges Each vertex of this tree has a color assigned to it if the vertex is white and if the vertex is black You have to solve the following problem for each vertex what is the maximum difference between the number of white and the number of black vertices you can obtain if you choose some subtree of the given tree that the vertex The subtree of the tree is the connected subgraph of the given tree More formally if you choose the subtree that contains white vertices and black vertices you have to maximize ,This problem is about the rerooting technique Firstly let s calculate the answer for some fixed root How can we do this Let be the maximum possible difference between the number of white and black vertices in some subtree of yes the subtree of the rooted tree i e and all its direct and indirect children that the vertex We can calculate this dynamic programming by simple dfs for the vertex it will look like this Okay we can store the answer for the root somewhere What s next Let s try to change the root from the vertex to some adjacent to it vertex Which states of dynamic programming will change Only and Firstly we need to remove the child from the subtree of the vertex Then we need to attach the vertex and make it a child of the vertex Then we need to run this process recursively from store the answer reroot the tree and so on and when it ends we need to rollback our changes Now is the root again and we can try the next child of as the root Time complexity 
In BerSoft programmers work the programmer is characterized by a skill A programmer can be a mentor of a programmer if and only if the skill of the programmer is strictly greater than the skill of the programmer and programmers and are not in a quarrel You are given the skills of each programmers and a list of pairs of the programmers which are in a quarrel pairs are unordered For each programmer find the number of programmers for which the programmer can be a mentor ,Firstly we should sort all programmers in non decreasing order of their skills Also we need to store initially numbers of the programmers we can user array of pairs skill and initial number of the programmer We will iterate through the programmers from the left to the right The current programmer can be a mentor of all programmers to the left of him after sort and with who he are not in a quarrel Let the number of programmers to the left is Subtract from the number of already considered programmers who skill equals to the skill of the current programmer it can be done for example with help of Also lets brute all programmers with who the current programmer in a quarrel we can initially save for each programmer the vector of programmers with who he in a quarell by analogy with the stoe of graphs and if the skill of the current programmer more than the skill of a programmers with which he in a quarrel we should decrease on one because this programmer is to the left of the current after sort and has been counted in We should store by a number of the current programmer the value as answer for him 
You are given a permutation of length of numbers Count the number of subsegments of this permutation such that of is the smallest non negative integer that does not occur in For example of the set is the median of the set i e the element that after sorting the elements in non decreasing order will be at position number array elements are numbered starting from and here denotes rounding down For example A sequence of numbers is called a permutation if it contains all the numbers from to exactly once ,Let s learn how to count the number of subsegments where for a fixed value of Let s understand on which subsegments has such a value We understand that the numbers should be in this subsegment the number should not and then does not matter Let be the index of the left most occurrence of the numbers and the right most occurrence Also let be the index of the number If then there is no subsegment with the given otherwise let s think about how many numbers can be in a subsegment It is stated that if the length of a segment is then on it otherwise it is not true Indeed if the length of a segment is then simply by the definition of the median it will be among the first numbers On the other hand if the length of the segment becomes longer then according to the same definition of the median it will no longer be among the first numbers which are equal to It turns out that we need to count the number of subsegments of length that contain the subsegment inside themselves but not This of course can be done with large formulas and the like but one more useful fact can be noticed If we iterate over in ascending order and at the same time maintain and then let s see what happens with a fixed and a position of for convenience let s assume that since the second case is similar In fact you can simply iterate over the left border of our segment from to and then use a simpler formula to calculate the number of good subsegments with such fixed values Why can this left boundary be iterated for each if correspondingly if it were then we would iterate over the right boundary Let s remember that after this step becomes equal to That is if we iterate over an element then we move the corresponding border And we can only move it times 
There are points on a coordinate axis The th point is located at the integer point and has a speed It is guaranteed that no two points occupy the same coordinate All points move with the constant speed the coordinate of the th point at the moment is calculated as Consider two points and Let be the minimum possible distance between these two points over any possible moments of time even It means that if two points and coincide at some moment the value will be Your task is to calculate the value the sum of minimum distances over all pairs of points ,Let s understand when two points and coincide Let Then they are coincide when Otherwise these two points will never coincide and the distance between them will only increase So we need to consider only the initial positions of points Let s sort all points by and consider them one by one from left to right Let the th point be the rightmost in the pair of points that we want to add to the answer We need to find the number of points such that and and the sum of for such points as well We can do this using two BITs Fenwick trees if we compress coordinates all values and do some kind of scanline by values Let the number of such points be and the sum of coordinates of such points be Then we can increase the answer by and add our current point to the Fenwick trees add to the position in the first tree and to the position in the second tree When we want to find the number of required points and the sum of its coordinates we just need to find the sum on the prefix two times in Fenwick trees Note that you can use any online logarithmic data structure you like in this solution such as treap and segment tree There is also another solution that uses pbds Let s do the same thing but there is one problem Such data structure does not have sum on prefix function so we have to replace it somehow To do this let s calculate only part when we go from left to right Then let s clear our structure go among all points again but from right to left and calculate the same thing but with the opposite sign find the number of points such that and When we go from right to left we need to decrease the answer by It is some kind of contribution to the sum technique Time complexity 
You are given an undirected weighted graph with vertices and edges The th edge is the distance between vertices and along the edge is The graph is i e for any pair of vertices there is at least one path between them consisting only of edges of the given graph A minimum spanning tree MST in case of weights is a subset of the edges of a connected weighted undirected graph that connects all the vertices together and has minimum total cost among all such subsets total cost is the sum of costs of chosen edges You can modify the given graph The only operation you can perform is the following increase the weight of some edge by You increase the weight of each edge multiple possibly zero times Suppose that the initial MST cost is Your problem is to increase weights of some edges in such a way that the cost of MST in the obtained graph remains but MST is it means that there is only one way to choose MST in the obtained graph Your problem is to calculate the number of operations required to do it ,The first and the most straight forward approach is to construct MST with any suitable algorithm build LCA with the maximum edge on a path with binary lifting technique and then we have to increase the answer for each edge such that equals to the maximum edge on a path between and in MST The second and the most pretty and easy to implement solution is the improved Kruskal algorithm Let s do Kruskal algorithm on the given edges Sort them and let s consider all edges of the same weight at once They can be divided into two classes The first class contains edges which connect nothing and the second class contains edges which can connect something Let the number of edges of current weight be edges of the current weight of the first class be and edges with of current weight of the second class be Okay we can just skip the first class because it will never increase the answer How to calculate useless edges of the second class Let s try to merge all components connected with edges of the second class Suppose we make merges Then we have to increase weights of all remaining edges by one So we add to the answer the value and go to the next weight Why is this right This is right because if the edge of the second class cannot connect anything because of the previously considered edges then the maximum on a path between endpoints of this edge equals to this edge weight So we have to increase the weight of this edge by one If we didn t do it we would be able to replace the edge connects these components with our edge And it is obvious that this edge is totally useless with the weight increased by one Time complexity is because of edges sorting 
Dmitry has segments of different colors on the coordinate axis Each segment is characterized by three integers and where and are are the coordinates of the ends of the th segment and is its color Dmitry likes to find the minimum distances between segments However he considers pairs of segments of the same color uninteresting Therefore he wants to know for each segment the distance from this segment to the nearest colored segment The distance between two segments is the minimum of the distances between a point of the first segment and a point of the second segment In particular if the segments intersect then the distance between them is equal to For example Dmitry has segments The first segment intersects with the second and these are segments of different colors so the answers for them are equal to For the rd segment the nearest segment of a different color is the nd segment the distance to which is equal to For the th segment the nearest segment of a different color is the th segment the distance to which is equal to The th segment lies inside the nd segment and these are segments of different colors so the answers for them are equal to ,Let s go through the segments times in non decreasing coordinates of the left end and then in non increasing coordinates of the right end To walk a second time just multiply the coordinates of the left and right borders by and then swap them and walk from left to right Going through the segments in non decreasing coordinates of the left end you need to find for each segment a segment that starts not to the right of the current one and ends as far to the right as possible If the coordinate of its right end is not less than the coordinate of the left end of the current segment then it intersects with it otherwise the distance between them is equal to the distance between the coordinate of the left end of the current segment and the maximum coordinate of the right end of the segment starting to the left of ours Note that it is enough for us to store no more than segments for each color we will store the maximum right coordinate of the segment of this color which has already been considered If we store the colors with the largest right coordinates then one of them is definitely not equal to the current one When considering a segment we add it to the list and if the size of the list becomes then we leave of optimal elements 
There is an infinite board of square tiles Initially all tiles are white Vova has a red marker and a blue marker Red marker can color tiles Blue marker can color tiles If some tile isn t white then you can t use marker of any color on it Each marker must be drained completely so at the end there should be exactly red tiles and exactly blue tiles across the board Vova wants to color such a set of tiles that they would form a consisting of exactly colored tiles all tiles of at least one color would also form a Here are some examples of correct colorings Here are some examples of incorrect colorings Among all correct colorings Vova wants to choose the one with the minimal perimeter What is the minimal perimeter Vova can obtain It is guaranteed that there exists at least one correct coloring , should be area of the outer rectangle It means that its sides are divisors of The same holds for the inner rectangle Let s assume that red color forms a rectangle we ll try it and then swap with and solve the same problem again Write down all the divisors of up to these are the possible smaller sides of the inner rectangle Divisors of up to are possible smaller sides of the outer rectangle Let s put inner rectangle to the left bottom corner of the outer rectangle and choose smaller sides of both of them as bottom and top ones Iterate over the divisors of for each of them choose the greatest divisor of smaller or equal to it and check that Update the answer with if it holds You can use both binary search or two pointers both get AC pretty easily The number of divisors of can usually be estimated as Overall complexity 
Polycarp got the following problem given a grid strip of size some cells of it are blocked You need to check if it is possible to tile all free cells using the and tiles dominoes For example if and the strip looks like this black cells are blocked Then it can be tiled for example using two vertical and two horizontal tiles as in the picture below different tiles are marked by different colors And if and the strip looks like this It is impossible to tile free cells Polycarp easily solved this task and received his New Year s gift Can you solve it ,If the first column is empty we can always cover it with a vertical tile if the next column is also empty then we will have to put either two vertical or two horizontal tiles but they are obtained from each other by rotating if the next column contains at least one blocked cell then we have no other options but to cover the column with a vertical board If the first column is fully blocked then we can just skip it Remove such columns from the beginning reducing the problem Now the first column contains one empty and one blocked cell Obviously in place of an empty cell we will have to place a horizontal tile If this did not work then the tiling does not exist Otherwise there are two cases if the next column is empty it will turn into a column with one occupied cell Then we continue to put horizontal tiles if the next column contains one blocked cell then it becomes fully blocked and we return to the first step It turns out the following greedy algorithm we sort all columns with at least one cell blocked there are no more than such columns by number Now if we see a column with one occupied cell then the next one must also be with one occupied cell we skipped the empty columns but this cell must have a different color in the chess coloring so that we can tile the space between them with horizontal boards This check is easy to do after sorting the columns 
You are given a string consisting of lowercase Latin letters and and question marks Let the number of question marks in the string be Let s replace each question mark with one of the letters and Here we can obtain all possible strings consisting only of letters and For example if then we can obtain the following strings Your task is to count the total number of subsequences in all resulting strings Since the answer can be very large print it modulo A subsequence of the string is such a sequence that can be derived from the string after removing some possibly zero number of letters without changing the order of remaining letters For example the string contains two subsequences a subsequence consisting of letters at positions and a subsequence consisting of letters at positions ,There are several more or less complicated combinatorial solutions to this problem but I will describe a dynamic programming one which I think is way easier to understand and to implement Suppose we have fixed the positions of and that compose the subsequence let these positions be and How many strings contain the required subsequence on these positions Obviously if some of these characters is already not a question mark and does not match the expected character on that position the number of strings containing the subsequence on that position is Otherwise since we have fixed three characters all question marks on other positions can be anything we want so the number of such strings is where is the number of question marks on positions other than and It allows us to write an solution by iterating on and and for every such triple calculating the number of strings containing the required subsequence on those positions But that s too slow Let s notice that for every such subsequence the number of strings containing it is where is the number of positions from that contain a question mark So for each integer from to let s calculate the number of subsequences matching that contain exactly question marks and that will allow us to solve the problem faster How can we calculate the required number of subsequences for every In my opinion the simplest way is dynamic programming let be the number of subsequences of that end up in position match first characters of and contain question marks The transitions in this dynamic programming are quadratic since we have to iterate on the next previous position from the subsequence but can be sped up to linear if we rewrite as the number of subsequences of that end up in position match first characters of and contain question marks Each transition is either to take the current character or to skip it so they can be modeled in and overall this dynamic programming solution works in 
Polycarp lives on a coordinate line at the point He goes to his friend that lives at the point Polycarp can move only from left to right he can pass one unit of length each second Now it s raining so some segments of his way are in the rain Formally it s raining on non intersecting segments the th segment which is in the rain is represented as There are umbrellas lying on the line the th umbrella is located at point and has weight When Polycarp begins his journey he doesn t have any umbrellas During his journey from to Polycarp can pick up and throw away umbrellas Polycarp picks up and throws down any umbrella instantly He can carry any number of umbrellas at any moment of time Because Polycarp doesn t want to get wet he must carry at least one umbrella while he moves from to if a segment is in the rain i e if there exists some such that and The condition above is the only requirement For example it is possible to go without any umbrellas to a point where some rain segment starts pick up an umbrella at this point and move along with an umbrella Polycarp can swap umbrellas while he is in the rain Each unit of length passed increases Polycarp s fatigue by the sum of the weights of umbrellas he carries while moving Can Polycarp make his way from point to point If yes find the minimum total fatigue after reaching if Polycarp picks up and throws away umbrellas optimally ,Any experienced contestant can easily guess that the problem can be solved with dynamic programming Coordinates are not really large so you can precalculate the array where is a boolean value if there exists some segment of rain to cover the segment between positions and and otherwise This can be done in with the most straightforward algorithm You can also precalculate another array where is the index of the umbrella of minimal weight at position or if there is no such umbrella Now let be the minimal total fatigue you can take if you are holding umbrella number on the end of the walk up to position If then you hold no umbrella Initially all the values are and is You can either hold your umbrella drop it or pick up the best one lying there and drop the current one if any when going from some position to So here are the transitions for these cases if if if The answer is equal to If it is then there is no answer So you have states and all the transitions are Overall complexity There is also a solution in with Convex Hull Trick using Li Chao tree You can probably even achieve with some coordinate compression Obviously this wasn t required for the problem as the constraints are small enough 
It is given a non negative integer the decimal representation of which contains digits You need to color its digit in red or black so that the number formed by the red digits is divisible by and the number formed by the black digits is divisible by digit must be colored in each of two colors Consider the count of digits colored in red is and the count of digits colored in black is Among all possible colorings of the given number you need to output any such that the value of is Note that the number and the numbers formed by digits of each color The figure above shows an example of painting the number of digits for and The red digits form the number which is divisible by and the black ones which is divisible by Note that the absolute value of the difference between the counts of red and black digits is it is impossible to achieve a smaller value ,The number is divisible by the number if and only if modulo To solve this problem let s use the concept of dynamic programming There will be four states the number of considered digits of the number the number of such considered digits that we have colored red the remainder from dividing the red number by and the black one by The value corresponding to the state will be described by three parameters the possibility of a situation described by the states the color of the last digit and the parent state Let s assume that the number that contains digits is equal to Initially let s mark the state in which digits are considered of which are red digits and both remainders are equal to as possible Next let s iterate over all states in the following order first by the number of considered digits then by the number of considered red digits then by the remainder of the division by and by From the current state if it is possible i e the corresponding mark is set you can make two transitions to new states At the first transition we paint the last digit in red at the second one in black We need also to store the current state in the new states as the previous one A solution exists if and only if some state in which exactly digits are considered of which at least and at most red digits and the remainders are equal to is marked as possible Let s find such a state Using the stored information about the color of the last digit and the previous state we can restore the colors of all digits of the number 
You are given a tree connected graph without cycles consisting of vertices The tree is unrooted it is just a connected undirected graph without cycles In one move you can choose exactly leaves leaf is such a vertex that is connected to only one another vertex connected and remove them with edges incident to them I e you choose such leaves that there are edges and remove these leaves and these edges Your task is to find the number of moves you can perform if you remove leaves optimally You have to answer independent test cases ,This is mostly implementation problem We can notice that all leaves are indistinguishable for us So if we have some vertex with at least k leaves attached to it we can choose it remove these leaves from the tree and continue the algorithm The rest is just an implementation let s maintain for each vertex v the list of all leaves which are connected to it leaves v and the set of vertices which is sorted by the size of leaves v So let s take any vertex which Is connected with at least k leaves we can just take the vertex with the maximum value in the set and remove any k leaves attached to it If it has zero leaves after the current move let s mark is as a leaf and append it to the list of the corresponding vertex you also need to remove edges from the graph fast to find the required vertex so you may need to maintain the graph as the list of sets And don t forget about the case k 1 because it may be special for your solution so you could handle it in a special way Time complexity O n log n 
We guessed a permutation consisting of integers The permutation of length is the array of length where each element from to appears exactly once This permutation is a secret for you For each position from to we chose some other index and gave you the segment in order i e we rearranged the elements of this segment in a way that the elements of this segment are sorted Thus you are given exactly segments of the initial permutation but elements inside each segment are sorted The segments are given to you in random order For example if the secret permutation is then the possible given set of segments can be Your task is to find suitable permutation i e any permutation corresponding to the given input data It is guaranteed that the input data corresponds to some permutation i e such permutation exists You have to answer independent test cases ,Let s fix the first element and then try to restore permutation using this information One interesting fact if such permutation exists with this first element then it can be restored uniquely Let s remove the first element from all segments containing it we can use some logarithmic data structure for it Then we just have a smaller problem but with one important condition there is a segment consisting of one element again if such permutation exists So if the number of segments of length 1 is zero or more than one by some reason then there is no answer for this first element Otherwise let s place this segment a single element in second place remove it from all segments containing it and just solve a smaller problem again If we succeed with restoring the permutation then we need to check if this permutation really satisfies the given input segments see the first test case of the example to understand why this case appears Let s just iterate over all i from 2 to n and then over all j from i 1 to 1 If the segment a j a j 1 dots a i is in the list remove it and go to the next i If we can t find the segment for some i then this permutation is wrong Time complexity O n 3 log n or less maybe 
You are given two positive integers and You can perform the following operation with write it in its binary form without leading zeros add or to the right of it reverse the binary form and turn it into a decimal number which is assigned as the new value of For example can be turned into via one operation the binary form of is if you add reverse it and remove leading zeros you will get which is the binary form of can be turned into via one operation the binary form of is if you add reverse it and remove leading zeros you will get which is the binary form of can be turned into via one operation the binary form of is if you add reverse it and remove leading zeros you will get which is the binary form of can be turned into via two operations first you turn into and then into Your task is to find out whether can be turned into after a certain number of operations possibly zero ,There are two main approaches to this problem Let s analyze how the binary representation of changes after the operation If there are no zeroes at the end of it appending just reverses the binary representation if there are any trailing zeroes we remove them and reverse the binary representation If we append we just reverse the binary representation and add at the beginning No matter which action we choose on the first step the resulting binary representation will have at its beginning and at its end so no bits can be removed from it no zero from the resulting binary representation can become leading It means that every number we can obtain from will have the following form several ones maybe none then then several ones again maybe none where is one of the following four strings the binary representation of after appending in the first operation the binary representation of after appending in the first operation one of the aforementioned representations but reversed We can check that meets one of these four templates but since we only considered the case when we apply at least one operation we also have to verify if Run something like implicit BFS or DFS to generate all possible values you can obtain pruning when the length of the binary representation we get becomes too large say greater than Why does this work fast As we have shown in our first approach the numbers we can get from have a very specific form and if we limit their lengths to we will consider only about different numbers Note that if you try this approach you have to store the obtained numbers in some associative data structure I use a set of strings in my solution 
The robot is located on a checkered rectangular board of size rows columns The rows in the board are numbered from to from top to bottom and the columns from to from left to right The robot is able to move from the current cell to one of the four cells adjacent by side Each cell has one of the symbols or written on it indicating the direction in which the robot will move when it gets in that cell left right down or up respectively The robot can start its movement in any cell He then moves to the adjacent square in the direction indicated on the current square in one move If the robot moves beyond the edge of the board it falls and breaks If the robot appears in the cell it already visited before it breaks it stops and doesn t move anymore Robot can choose any cell as the starting cell Its goal is to make the maximum number of steps before it breaks or stops Determine from which square the robot should start its movement in order to execute as many commands as possible A command is considered successfully completed if the robot has moved from the square on which that command was written it does not matter whether to another square or beyond the edge of the board ,Let s start moving from an arbitrary cell of the table for example from Movement from each cell is specified by the direction given in that cell so you can run a loop with a stopping condition exit from the board border or get to the already visited cell Create a separate array how many commands the robot will execute starting the movement from the cell we will also use it to check whether the cell has already been visited or not not visited if is not yet positive Finishing the movement from let s consider two cases Either we have gone beyond the boundary of the array then we can say for sure that for the th cell from the end of the sequence the answer is Or we came to the already visited cell let it be the th from the end in our path Then at the end of the path there is a cycle of length starting the movement at any cell of this cycle the robot will walk exactly steps until it arrives at the already visited cell Thus for distance will be equal to and for all others it will be as in the first case Let us run the same algorithm from the next cell which we have not yet considered There will be three cases of robot stopping the execution of the commands the first two repeat those already considered above and the third case is that the robot will come to the cell already visited on some of the previous iterations of our algorithm In this case we know that starting from the robot will make exactly steps so for the th cell from the end on the current path will hold The first two cases are handled completely in the same way as described above Each of the cases is eventually reduced to another iteration over the cells visited in the current path Let s visit all the cells in reverse and mark all values of Such algorithm is enough to repeat until each cell is processed after which for each cell of the table its will be known and we ll only have to choose the maximal value of among all 
There is a rectangular grid of size Each cell of the grid is colored black or white The color of the cell is You are also given a map of directions for each cell there is a direction which is one of the four characters and If is then there is a transition from the cell to the cell if is then there is a transition from the cell to the cell if is then there is a transition from the cell to the cell if is then there is a transition from the cell to the cell It is guaranteed that the top row doesn t contain characters the bottom row doesn t contain characters the leftmost column doesn t contain characters and the rightmost column doesn t contain characters You want to place some robots in this field at most one robot in a cell The following conditions should be satisfied Firstly each robot every time i e it cannot skip the move Secondly you have to place robots in such a way that before which two different robots occupy the same cell it also means that you cannot place two robots in the same cell I e if the grid is one row two columns colors does not matter there then you can place two robots in cells and but if the grid is then you cannot place robots in cells and because during the first second both robots will occupy the cell The robots make an infinite number of moves Your task is to place the maximum number of robots to satisfy all the conditions described above and among all such ways you have to choose one where the number of cells occupied by robots is the maximum possible You have to answer independent test cases ,First of all I want to say about solution You can extract cycles in the graph do some dynamic programming on trees use some hard formulas and so on but it is a way harder to implement than the other solution that only has an additional log so I ll describe the one which is easier to understand and much easier to implement Firstly consider the problem from the other side What is this grid It is a functional graph such a directed graph that each its vertex has exactly one outgoing edge This graph seems like a set of cycles and ordered trees going into these cycles How can it help us Let s notice that if two robots meet after some move then they ll go together infinitely from this moment It means that if we try to make at least moves from each possible cell we will obtain some equivalence classes it means that if endpoints of two cells coincide after moves then you cannot place robots in both cells at once So if we could calculate such endpoints then we can take for each possible endpoint the robot starting from the black cell if such exists and otherwise the robot starting from the white cell if such exists How can we calculate such endpoints Let s number all cells from to where the number of the cell is Let the next cell after is i e if you make a move from you go to Also let s create the two dimensional array where means the number of the cell in which you will be if you start in the cell number and make moves What is the upper bound of It is exactly Well we need to calculate this matrix somehow It is obvious that if the number of the cell is and the number of the next cell is then Then let s iterate over all degrees from to and for each vertex set The logic behind this expresion is very simple if we want to jump times from and we have all values for calculated then let s just jump times from and times from the obtained vertex This technique is called binary lifting Now we can jump from every cell times in time just iterate over all degrees from to and if has the th bit on just jump from the current vertex times set The rest of solution is described above Time complexity 
Polycarp found the string and the permutation Their lengths turned out to be the same and equal to A permutation of elements is an array of length in which every integer from to occurs exactly once For example and are permutations but and are not In one operation he can multiply by so he replaces with string in which for any from to it is true that For example with and after operation the string will turn to Polycarp wondered after how many operations the string would become equal to its initial value for the first time Since it may take too long he asks for your help in this matter It can be proved that the required number of operations always exists It can be very large so use a 64 bit integer type ,To begin with let s understand why the string will return to its original form In fact the graph that the permutation sets consists of simple cycles and it turns out that after a certain number of operations each character will return to its place Consider each cycle as a string that is cyclically shifted every turn It may seem that the answer is the smallest common multiple of the cycle lengths but to become equal to the initial string it is not necessary to go through the entire cycle The constraints allow us to calculate the length of the minimum suitable shift in where is the length of the cycle so just iterate over the desired shift Note that after operations the cycle will return to its original form and this will happen again after operations The answer will be of all since each cycle individually comes to its original form after the number of operations is a multiple of its 
There are shovels in the nearby shop The th shovel costs bourles Misha has to buy shovels Each shovel can be bought Misha can buy shovels by several purchases During one purchase he can choose any subset of remaining non bought shovels and buy this subset There are also special offers in the shop The th of them is given as a pair and it means that if Misha buys shovels then of them are for free i e he will not pay for most cheapest shovels during the current purchase Misha can use any offer any possibly zero number of times but he cannot use offer during but he can buy shovels without using any offers Your task is to calculate the minimum cost of buying shovels if Misha buys them optimally ,First of all since we are going to buy exactly shovels we may discard most expensive shovels from the input and set and solve the problem which requires us to buy all the shovels Also let s add an offer which allows us to buy shovel and get cheapest of them for free to simulate that we can buy shovels without using offers Now we claim that if we sort all the shovels by their costs it s optimal to divide the array of costs into some consecutive subarrays and buy each subarray using some offer Why should the sets of shovels for all purchases be consecutive subarrays Suppose it s not so let s pick two purchases such that they are mixed in the array of costs i e there exists at least one shovel bought in the first purchase such that there exists a shovel cheaper than it and a shovel more expensive than it both bought in the second purchase If shovel is for free then we may swap shovels and otherwise we may swap shovels and and the answer won t become worse So we can do it until all purchases correspond to subsegments in the array of costs Then it s easy to see that we can make purchases in such a way that we always buy some amount of cheapest shovels And now the problem can be solved by knapsack like dynamic programming let be the minimum cost to buy exactly cheapest shovels is and for each offer we can update by the value of where is the sum of costs of all shovels in the sorted order from shovel on position to shovel on position inclusive these sums can be calculated in using partial sums method 
You are given strings all of them have the same length The strings consist of lowercase English letters Find any string of length such that each of the given strings differs from in at most one position Formally for each given string there is no more than one position such that Note that the desired string may be equal to one of the given strings or it may differ from all the given strings For example if you have the strings and then the answer to the problem might be the string which differs from the first only by the last character and from the second only by the first ,Consider all strings that differ from the first one in no more than one position this is either the first string or the first string with one character changed We will go through all such strings and see if they can be the answer To do this go through all the strings and calculate the number of positions where they differ 
You are given two strings and consisting of lowercase Latin letters The length of is i e this string consists only of two characters In one move you can choose character of and replace it with lowercase Latin letter More formally you choose some and replace the character at the position with some character from to You want to do replacements in such a way that the number of occurrences of in as a Recall that a subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements ,I m almost sure this problem can be solved faster and with greater constraints but this version is fine for the last problem Consider both strings indexed and let s do the dynamic programming It means the maximum number of occurrences of if we considered first characters of did moves and the number of characters is The answer to the problem is Initially all states are and is What about transitions There are essentially three types of them don t change the current character change the current character to and change the current character to Let s create three additional variables to make our life easier if that were true is if and otherwise is if and otherwise and is if and otherwise Now let s make and describe our transitions Don t change the th character The expression is just ternary if statement if is true return otherwise return So the number of characters increases if equals and the answer increases if the th character equals because we added all occurrences that end in the th character Change the th character to possible only when The number of characters always increases and the answer increases if equals by the same reason as in the previous transition Change the th character to possible only when The number of characters increases only if and the answer always increases Note that we always increase the number of moves in the second and the third transitions even when equals or because this case is handled in the first transition so we don t care Time complexity There are also some greedy approaches which work in with pretty small constant and can be optimized even further 
Polycarp found segments on the street A segment with the index is described by two integers and coordinates of the beginning and end of the segment respectively Polycarp realized that he didn t need all the segments so he wanted to delete some of them Polycarp believes that a set of segments is good if there is a segment from the set such that it intersects every segment from the set the intersection must be a For example a set of segments is good since the segment intersects each segment from the set Set of segments is not good Polycarp wonders what is the minimum number of segments he has to delete so that the remaining segments form a good set ,As we know from the problem statement Polycarp believes that a set of k segments is good if there is a segment l i r i 1 leq i leq k from the set such that it intersects every segment from the set the intersection must be a Let s iterate over this segment which intersects all the others and construct a good set of the remaining segments maximum in terms of inclusion It is easy to understand that this set will include all segments that intersect with ours We must delete all other segments Two segments l 1 r 1 and l 2 r 2 intersect if max l 1 l 2 le min r 1 r 2 Then if the segment that we iterate over has coordinates L R then we must remove all such segments l r for which r L or R l is satisfied that is the segment ends earlier than ours begins or vice versa Note that these two conditions cannot be fulfilled simultaneously since l le r and if both conditions are satisfied then r L le R l This means that we can count the number of segments suitable for these conditions independently Each of these conditions is easy to handle Let s create two arrays all the left boundaries of the segments and all the right boundaries of the segments Let s sort both arrays Now we can count the required quantities using the binary search or prefix sums but in this case we need to use the coordinate compression technique Taking at least the number of deleted segments among all the options we will get the answer to the problem 
You are given an unweighted tree with vertices Recall that a tree is a connected undirected graph without cycles Your task is to choose vertices on this tree such that the number of edges which belong to one of the simple paths between and and or and is the maximum possible See the notes section for a better understanding The simple path is the path that visits each vertex at most once ,There is some obvious dynamic programming solution that someone can describe in the comments but I will describe another one that in my opinion much easier to implement Firstly let s find some diameter of the tree Let and be the endpoints of this diameter and first two vertices of the answer You can prove yourself why it is always good to take the diameter and why any diameter can be taken in the answer Then there are two cases the length of the diameter is or the length of the diameter is less than In the first case you can take any other vertex as the third vertex of the answer it will not affect the answer anyway Otherwise we can run multi source bfs from all vertices of the diameter and take the farthest vertex as the third vertex of the answer It is always true because we can take any diameter and the farthest vertex will increase the answer as much as possible Time complexity 
Timofey came to a famous summer school and found a tree on vertices A tree is a connected undirected graph without cycles Every vertex of this tree except is colored The vertex is colored Timofey wants to color all the vertices of this tree in To do this he performs operations During the th operation he selects the vertex which is currently and paints it Let s call the of tree the minimum distance between all pairs of different vertices in it The distance between the vertices and is the number of edges on the path from to After each operation Timofey wants to know the of the current tree ,Let s store for each vertex the minimum distance from it to the nearest one let s call it We will also store the global answer which for obvious reasons does not increase we will call it Let s now color the vertex let s set and run a depth first search from it This DFS will visit the vertices with Let us consider the vertex and its neighbour If we can relax through let s do it and start from Otherwise has a closer neighbour let s try to update the answer through it Also do not forget to update the answer via from all vertices that we visited The correctness of the algorithm is obvious let s evaluate its time complexity It is easy to notice that after the first operations We enter only the vertices from which firstly does not exceed and secondly was relaxed by the parent that is decreased by at least So we allowed ourselves a complete tree bypassing for the first operations and then amortized performed no more than operations The final asymptotics will be 
One important contest will take place on the most famous programming platform Topforces very soon The authors have a pool of problems and should choose of them into this contest The prettiness of the th problem is The authors have to compose the most pretty contest in other words the cumulative prettinesses of chosen problems should be But there is one important thing in the contest preparation because of some superstitions of authors the prettinesses of problems cannot divide each other In other words if the prettinesses of chosen problems are then should be divisible by neither nor should be divisible by neither nor and should be divisible by neither nor If the prettinesses of chosen problems are and then neither should be divisible by nor should be divisible by Any contest composed from one problem is considered good Your task is to find out the maximum possible total prettiness of the contest composed of problems from the given pool You have to answer independent queries ,I know about some solutions that are trying to iterate over almost all possible triples but I have a better and more interesting one Possibly it was already mentioned in comments but I need to explain it Let s solve the problem greedily Let s sort the initial array The first number we would like to choose is the maximum element Then we need to pop out some maximum elements that are divisors of the maximum Then there are two cases the array becomes empty or we have some maximum number that does not divide the chosen number Let s take it and repeat the same procedure again but now we have to find the number that does not divide neither the first taken number nor the second taken number So we have at most three numbers after this procedure Let s update the answer with their sum This solution is almost correct Almost What have we forgotten Let s imagine that the maximum element is divisible by and and there are three following numbers in the array maximum divided by by and by Then their sum is greater than the maximum and may be greater than the answer we have because So if these conditions are satisfied let s update the answer with the sum of these three numbers It can be shown that this is the only possible triple that can break our solution The triple does not match because the maximum divided by divides the maximum divided by The triple is bad for the same reason And the triple has sum less than the maximum element 
You are given a tree consisting exactly of vertices Tree is a connected undirected graph with edges Each vertex of this tree has a value assigned to it Let be the distance between the vertices and The distance between the vertices is the number of edges on the simple path between them Let s define the cost of the tree as the following value firstly let s fix some vertex of the tree Let it be Then the cost of the tree is Your task is to calculate the of the tree if you can choose arbitrarily ,Firstly let s calculate the answer let it be for some fixed vertex Let this vertex be the vertex Just run simple and calculate the result using the formula from the problem statement Also let s calculate the sum of values let the sum in the subtree of the vertex be in each subtree of the given tree if its root is the vertex It can be easily done with simple dynamic programming And now the magic part let s apply the technique which is called at least we called it so Let s maintain the correct values in subtrees at each step of our algorithm How will values and the answer change if we will go through the edge The following sequence of changes will change all values correctly Firstly it can be seen that will decrease by because the distance to each vertex in this subtree will decrease by one then will decrease by because we change the root of the tree we need this step to maintain the correct values then will increase by because the distance to each vertex in this subtree will increase by one and then will increase by because we change the root of the tree we need this step to maintain the correct values So we can recalculate all the values we need if we go through the edge So now we can write another one to try to update the answer for each vertex as a root as the chosen vertex 
You are given two bracket sequences not necessarily regular and consisting only of characters and You want to construct the shortest bracket sequence that contains both given bracket sequences as not necessarily contiguous Recall what is the regular bracket sequence is the regular bracket sequence if is the regular bracket sequence then is a regular bracket sequence if and regular bracket sequences then concatenation of and is a regular bracket sequence Recall that the subsequence of the string is such string that can be obtained from by removing some possibly zero amount of characters For example and are subsequences of but and are not ,Firstly notice that the length of the answer cannot exceed copies of Now we can do some kind of simple dynamic programming Let be the minimum possible length of the prefix of the regular bracket sequence if we are processed first characters of the first sequence first characters of the second sequence and the current balance is Each dimension of this dp should have a size nearby The base of this dp is all other values Transitions are very easy if we want to place the opening bracket then we increase if the th character of exists and equals the same with the second sequence and the balance increases by one and the length of the answer increases by one If we want to place the closing bracket then we increase if the th character of exists and equals the same with the second sequence and the balance decreases by one and the length of the answer increases by one Don t forget to maintain parents in this dp to restore the actual answer The last problem that can be unresolved is how to write this dp The easiest way is bfs because every single transition increases our answer by one Then we can restore answer from the state You can write it recursively but I don t sure this will look good And you also can write it just with nested loops if you are careful enough Time complexity If you know the faster solution please share it 
Authors have come up with the string consisting of lowercase Latin letters You are given two permutations of its indices not necessary equal and both of length Recall that the permutation is the array of length which contains each integer from to exactly once For all from to the following properties hold and It means that if you will write down all characters of in order of permutation indices the resulting string will be sorted in the non decreasing order Your task is to restore such string of length consisting of which suits the given permutations If there are multiple answers you can print any of them ,Because if we write down all characters of in order of both permutations and this string will be sorted it is obvious that these two strings are equal Let s try the maximum possible number of distinct characters and then replace extra characters with How to find the maximum number of distinct characters Let s iterate over all values of and in order from left to right If we staying at the position now let s add to the set the value and to the set the value And when these sets become equal the first time let s say that the block of positions such that values are in the set right now have the same letter and then clear both sets We can see that this segment of positions is the minimum by inclusion set that can contain equal letters We don t need to compare sets naively and clear them naively you can see implementation details in author s solution If the number of such segments is less than then the answer is otherwise the answer is and we can fill the string with letters in order of these segments if the segment is then all characters of with indices has the same letter the first segment has the letter the second one has the letter and so on all segments after th has the letter Time complexity 
You are given two binary square matrices and of size A matrix is called binary if each of its elements is equal to or You can do the following operations on the matrix number of times 0 or more vertical You choose the number and for all do the following is the operation exclusive or horizontal You choose the number and for all do the following Note that the elements of the matrix change after each operation For example if and the matrix is Then the following sequence of operations shows an example of transformations vertical horizontal vertical Check if there is a sequence of operations such that the matrix becomes equal to the matrix ,It is clear that the order of operations does not affect the final result also it makes no sense to apply the same operation more than once by the property of the operation Let s construct a sequence of operations that will reduce the matrix to the matrix if the answer exists Let s try iterate over will we use the operation horizontal Now by the each element of the first line we can understand whether it is necessary to apply the operation vertical if Let s apply all necessary operations vertical It remains clear whether it is necessary to apply the operation horizontal for Let s look at each element of the first column by it you can understand whether it is necessary to apply the operation horizontal if 
Vitaly enrolled in the course Advanced Useless Algorithms The course consists of tasks Vitaly calculated that he has hours to do the task from the day he enrolled in the course That is the deadline before the th task is hours The array is sorted in ascending order in other words the job numbers correspond to the order in which the assignments are turned in Vitaly does everything conscientiously so he wants to complete task by percent Initially his completion rate for each task is percent Vitaly has training options each option can be used once The th option is characterized by three integers and If Vitaly uses the th option then after hours from the current moment he will increase the progress of the task by percent For example let Vitaly have of tasks to complete Let the array have the form Suppose Vitaly has of options Then if Vitaly prepares in the following way he will be able to complete everything in time Vitaly chooses the th option Then in hour he will complete the st task at percent He still has hours left before the deadline for the st task Vitaly chooses the rd option Then in hours he will complete the nd task in its entirety He has another hour left before the deadline for the st task and hours left before the deadline for the rd task Vitaly chooses the st option Then after hour he will complete the st task for percent which means that he will complete the st task just in time for the deadline Vitaly chooses the th option He will complete the rd task for hours and after another hour Vitaly will complete the rd task in its entirety Thus Vitaly has managed to complete the course completely and on time using the options Help Vitaly print the options for Vitaly to complete the tasks in the correct order Please note each option can be used once If there are several possible answers it is allowed to output any of them ,Note that it is always advantageous for us to complete the task that has an earlier deadline first Only then will we proceed to the next task Then we can solve each problem independently for each exam Then it remains to score percent on the task on the available options This is a typical knapsack problem with an answer recovery 
Vlad and Nastya live in a city consisting of houses and road From each house you can get to the other by moving only along the roads That is the city is a tree Vlad lives in a house with index and Nastya lives in a house with index Vlad decided to visit Nastya However he remembered that he had postponed for later things that he has to do before coming to Nastya To do the th thing he needs to come to the th house things can be done in any order In minute he can walk from one house to another if they are connected by a road Vlad does not really like walking so he is interested what is the minimum number of minutes he has to spend on the road to do all things and then come to Nastya Houses he can visit in any order He can visit any house multiple times if he wants ,To begin with we will hang the tree by the vertex In fact we want to go from the root to the top of going off this path to do things and coming back At one vertex of the path it is advantageous to get off it in all the necessary directions and follow it further So we will go once for each edge leading to and times for each edge leading to some of the cases but not leading to Let s match each vertex with an edge to its ancestor If the edge of a vertex leads to then is in the subtree of this vertex similarly with vertices with cases It is necessary for each vertex to determine whether there is a vertex in its subtree and whether there is a vertex from the array this can be done using a depth first search then we will calculate the answer according to the rules described above 
You work as a system administrator in a dormitory which has rooms one after another along a straight hallway Rooms are numbered from to You have to connect all rooms to the Internet You can connect each room to the Internet directly the cost of such connection for the th room is coins Some rooms also have a spot for a router The cost of placing a router in the th room is also coins You cannot place a router in a room which does not have a spot for it When you place a router in the room you connect all rooms with the numbers from to inclusive to the Internet where is the range of router The value of is the same for all routers Calculate the minimum total cost of connecting all rooms to the Internet You can assume that the number of rooms which have a spot for a router is not greater than the number of routers you have ,Firstly I know that this problem has very pretty linear solution and its author can describe it if he wants I ll describe my own solution without any data structures but Let be the total cost to connect all rooms from to to the Internet indexed Initially all other values are Let s iterate over all from to and make some transitions After all the answer will be The first transition is the easier update with just connect the current room directly To do other transitions let s carry two sets and and one array of vectors of length Set carries all values Initially it carries Set carries the minimum cost to cover some suffix of rooms that also covers the room Array of vectors helps us to carry the set efficiently First of all if then let s remove from Then let s remove all values of from Then if is not empty let s update with the minimum value of Then if then let be the minimum value of plus Update with and insert into Also let s add into if And after we make all we need with the current add the value to the set Time complexity It can be optimized to solution with some advanced data structures as a queue with minimums 
There is a rectangular grid of size Each cell has a number written on it the number on the cell is Your task is to calculate the number of paths from the upper left cell to the bottom right cell meeting the following constraints You can move to the right or to the bottom only Formally from the cell you may move to the cell or to the cell The target cell can t be outside of the grid The of all the numbers on the path from the cell to the cell must be equal to operation is the bitwise exclusive OR it is represented as in Java or C and in Pascal Find the number of such paths in the given grid ,This is a typical problem on the technique The number of moves we will made equals So if would be small enough 25 is the upper bound I think then we can just run recursive backtracking in or in to iterate over all binary masks of lengths containing exactly ones and check each path described by such mask in this mask is the move to the bottom and is the move to the right if its is But it is too slow So let s split this mask of bits into two parts the left part will consist of bits and the right part will consist of bits Note that each left mask and each right mask too uniquely describes the endpoint of the path and the path itself Let s carry associative arrays where for the endpoint and will denote the number of paths which end in the cell having Let s run recursive backtracking which will iterate over paths starting from the cell and move to the right or to the bottom and maintain of the path If we made moves and we are currently in the cell with right now set and return from the function Otherwise try to move to the bottom or to the right changing as needed Let s run another recursive backtracking which will iterate over paths starting from the cell and move to the left or to the top and maintain of the path except the last cell The same if we made moves and we are currently in the cell with right now let s add to the answer obvious that way we complement our from the right part of the path with the suitable from the left part of the path Otherwise try to move to the left or to the top changing as needed So this is the technique at least the way I code it Overall complexity is 
Maksim walks on a Cartesian plane Initially he stands at the point and in one move he can go to any of four adjacent points left right up down For example if Maksim is currently at the point he can go to any of the following points in one move There are also key points at this plane The th point is It is guaranteed that and and there is no key point Let the first level points be such points that the second level points be such points that and so on Maksim wants to visit all the key points But he shouldn t visit points of level if he does not visit all the points of level He starts visiting the points from the minimum level of point from the given set The distance between two points and is where is the absolute value of Maksim wants to visit all the key points in such a way that the total distance he walks will be minimum possible Your task is to find this distance ,The main idea is that we don t need more than border points on each level So if we consider than the point is less than point when or and then let s distribute all the points by their levels using or something like it sort points on each level by the comparator above and remain the first one and the last one on each level Also let s add the fictive level with the point It is always true to remain at most points and can be easily proved but this fact is very intuitive I think Now let s do dynamic programming on the points means that now we are at the level and stay in the first point if or in the last point if and we are already visit all the points on the level The value of this dynamic programming is the minimum possible total distance to reach this state Initially other values are equal to Let s calculate this dynamic programming in order of increasing levels Let be the first key point at the level and be the last key point at the level Now if we are at the level and the previous level is these transitions are sufficient to calculate states of dynamic programming on the current level There means the distance between points and Let last level we have be After calculating this dynamic programming the answer is 
You are given segments on a coordinate axis The th segment has borders All points for which holds belong to the th segment Your task is to choose the by size the number of segments subset of the given set of segments such that each pair of segments in this subset either non intersecting or one of them lies inside the other one Two segments and are non intersecting if they have For example segments and and are non intersecting while segments and and are intersecting The segment lies inside the segment if and For example segments and lie inside the segment while and are not You have to answer independent test cases ,Firstly let s compress the given borders of segments just renumerate them in such a way that the maximum value is the minimum possible and the relative order of integers doesn t change Pretty standard approach Now let s do recursive dynamic programming This state stores the answer for the segment not necessarily input segment How about transitions Firstly if there is a segment covering the whole segment why don t just take it It doesn t change anything for us The first transition is just skip the current left border and try to take the additional answer from the state The second transition is the following let s iterate over all possible segments starting at we can store all right borders of such segments in some array Let the current segment be If just skip it if then we can t take this segment into the answer because it s out of and if then we can t take it because we considered it already Then we can take two additional answers from and from Don t forger about some corner cases like when or and something like that You can get the answer if you run the calculation from the whole segment What is the time complexity of this solution We obviously have states And the number of transitions is also pretty easy to calculate Let s fix some right border For this right border we consider segments in total Summing up we get transitions So the time complexity is P S I am sorry about pretty tight ML yeah I saw Geothermal got some memory issues because of using map I really wanted to make it 512MB but just forgot to do that 
You are given a string consisting only of first lowercase Latin letters Recall that the substring of the string is the string For example the substrings of are but not and You can perform the following operation choose some substring and it i e the string becomes Your goal is to maximize the length of the maximum substring of consisting of i e unique characters The string consists of characters if no character in this string appears more than once For example strings and consist of distinct characters but strings do not consist of distinct characters ,First of all I wanted to offer you one little challenge I found a solution that I can t break and I don t sure if it can be broken and I will be so happy if anyone will give me countertest which will break it You can see its code below Let s notice that we can reduce our problem to the following find two substrings of the given string that letters in them do not intersect and the total length of these substrings is the maximum possible Why can we make such a reduction It is so because our answer consists of at most two non intersecting parts one fixed substring and at most one substring that we appended to the first one We can always append any other substring to the first one by one reverse operation just look at some examples to understand it Let s iterate over all possible substrings of length at most AL where AL is the size of the alphabet which contain distinct letters We can do it in O n AL Let the current substring containing distinct letters be s i j Let s create the bitmask corresponding to this substring the bit pos is 1 if the pos th letter of the alphabet is presented in the substring and 0 otherwise letters are Store all these masks somewhere Notice that our current problem can be reduced to the following we have the set of masks and we need to find a pair of masks that they do not intersect and their total number of ones in them is the maximum possible This reduction is less obvious than the previous one but you also can understand it considering some examples So how to solve this problem We can do it with easy bitmasks dynamic programming Let dp mask be the maximum number of ones in some mask that is presented in the given string and it is the submask of mask How to calculate this dynamic programming First of all all values dp mask for all masks presented in the string are equal to the number of ones in corresponding masks Let s iterate over all masks from 0 to 2 AL 1 Let the current mask be mask Then let s try to update the answer for this mask with the answer for one of its submasks It is obvious that because of dynamic programming we need to remove at most one bit from our mask to cover all possible submasks that can update our answer So let s iterate over all bits in mask let the current bit be pos If this bit is zero then just skip it Otherwise update dp mask max dp mask dp mask hat 2 pos where hat is the operation After calculating this dynamic programming we can finally calculate the answer Let s iterate over all masks presented in the string let the current mask be mask We can update the answer with the number of ones in mask plus dp mask hat 2 AL 1 mask hat 2 AL 1 is the completion of mask Total complexity O n AL AL 2 AL 
You are given a matrix of size consisting of integers You can choose elements in Your task is to choose these elements in such a way that their sum is and this sum is the In other words you can choose no more than a half rounded down of elements in each row you have to find the maximum sum of these elements divisible by Note that you can choose zero elements and the sum of such set is ,This is pretty standard dynamic programming problem Let be the maximum possible sum we can obtain if we are at the element right now we took elements in the row and our current remainder is Initially all states are except Transitions are standard because this is a knapsack problem we either take the element if or don t take it If the element is not the last element of the row then transitions look like that we don t take the current element we take the current element this transition is only possible if The transitions from the last element of the row are almost the same but the next element is and the new value of is always zero The answer is 
 Polycarp is a very famous freelancer His current rating is units Some very rich customers asked him to complete some projects for their companies To complete the th project Polycarp needs to have at least units of rating after he completes this project his rating will change by his rating will increase or decrease by can be positive or negative Polycarp s rating should not fall below zero because then people won t trust such a low rated freelancer Is it possible to complete all the projects Formally write a program to check if such an order of the projects exists that Polycarp has enough rating before starting each project and he has non negative rating after completing each project In other words you have to check that there exists such an order of projects in which Polycarp will complete them so he has enough rating before starting each project and has non negative rating after completing each project ,Firstly let s divide all projects into two sets all projects giving us non negative rating changes let this set be and all projects giving up negative rating changes let this set be Firstly let s take all projects from the set How do we do that Let s sort them by in non decreasing order because each project we take cannot make our rating less and we need to consider them in order of their requirements If we can take the current project set and go further otherwise print and terminate the program Okay what do we do with the projects that has negative Firstly let s set This means the tighter requirement of this project obviously Then let s sort all projects in order of in non increasing order and go from left to right and take all of them If we cannot take at least one project the answer is Otherwise the answer is 
 Ivan plays a computer game that contains some microtransactions to make characters look cooler Since Ivan wants his character to be really cool he wants to use some of these microtransactions and he won t start playing until he gets all of them Each day during the Ivan earns exactly one burle There are types of microtransactions in the game Each microtransaction costs burles usually and burle if it is on sale Ivan has to order exactly microtransactions of the th type he orders microtransactions during the Ivan can order possibly zero number of microtransactions of types during any day of course If the microtransaction he wants to order is on sale then he can buy it for burle and otherwise he can buy it for burles There are also special offers in the game shop The th offer means that microtransactions of the th type are on sale during the th day Ivan wants to order all microtransactions as soon as possible Your task is to calculate the minimum day when he can buy all microtransactions he want and actually start playing ,Let s iterate over all possible answers Obviously this value is always in the range The first day when Ivan can order all microtransactions he wants will be the answer How to check if the current day is enough to order everything Ivan wants If we had several sale days for some type of microtransaction of course we can use only such days that are not greater than the fixed last day let s use the last one it is always not worse than some of the previous days Then let s iterate over all days from to and do the following firstly let s increase our balance by one burle Then let s try to order all microtransactions for which the current day is the last sale day and pay one burle per copy If we are out of money at some moment then just say that we should order all microtransactions that remain in this sale day during the last day for two burles per copy It is true because it does not matter which types will remain because this day is the last sale day for all of these types So after all we had some remaining microtransactions that we cannot buy during sales and the current balance And the current day is good if the number of such microtransactions multiplied by two is not greater than the remaining balance 
You are given an integer Find the minimum integer such that and the number is A number is called if its decimal representation having no leading zeroes contains no more than different digits E g if the numbers and are whereas the numbers and are not ,Suppose the number contains digits The desired number isn t greater than the number consisting of digits This number is beautiful whereas any beautiful number is at the same time beautiful so contains at most digits At the same time so contains at least digits Therefore the desired number contains exactly digits Suppose There are exactly beautiful numbers containing exactly digits To get the answer fast it s possible to consider all these numbers Suppose If is already beautiful let s output it Otherwise let s initialize the answer by the value as if Let s iterate two digits and such that Let s search for the answer by considering the strings consisting only of digits and Let s iterate a prefix of starting from the empty one so that the prefix will be the prefix of This prefix must contain only the digits and Consider the leftmost digit that doesn t belong to the prefix Let s try to increase it If the digit is less than a possible answer is a number such that it has the considered prefix and all other digits are equal to Let s update the answer by this number i e if the found number is less than the best previously found answer let s set the answer to the found number If the considered digit is at least and is less than let s update the answer by the number such that it has the considered prefix the digit follows the prefix and all other digits are equal to 
Vova likes pictures with kittens The news feed in the social network he uses can be represented as an array of consecutive pictures with kittens of course Vova likes all these pictures but some are more beautiful than the others the th picture has beauty Vova wants to repost exactly pictures in such a way that each segment of the news feed of at least consecutive pictures has at least one picture reposted by Vova the sum of beauty values of reposted pictures is maximum possible For example if then Vova has to repost all the pictures in the news feed If then Vova can skip some pictures but between every pair of consecutive pictures Vova has to repost at least one of them Your task is to calculate the maximum possible sum of values of reposted pictures if Vova follows conditions described above or say that there is no way to satisfy all conditions ,Let s solve the problem using dynamic programming Let be the maximum total beauty of pictures if Vova is at the th picture now the number of remaining reposts is and Vova reposted the th picture Initially and all other values of are Let s learn to do some transitions to calculate this dynamic programming What is the way to do it Let s iterate over the position of the previously reposted picture and try to update using previously calculated values Obviously this position can be from to So let s iterate over the position let it be and if we need one more repost to repost the th picture is not then try to update pictures are indexed So where can we find the answer The answer is If this value is then the answer is Overall complexity is 
We will call a non empty string if it contains the same number of plus and minus signs For example strings and are balanced and strings and are not balanced We will call a string if the string can be made balanced by several possibly zero uses of the following operation replace two minus signs with one plus sign In particular every balanced string is promising However the converse is not true not every promising string is balanced For example the string is promising because you can replace two adjacent minuses with plus and get a balanced string or get another balanced string How many non empty substrings of the given string are promising Each non empty promising substring must be counted in the answer as many times as it occurs in string Recall that a substring is a sequence of consecutive characters of the string For example for string its substring are the string is a substring of itself and some others But the following strings are not its substring ,Note the fact that if the number of minus signs is greater than the number of plus signs by at least then there is sure to be a pair of standing next to minus signs according to the Dirichlet principle When we apply the operation of replacing two adjacent minus signs with a plus sign the balance the difference of plus signs and minus signs increases by Then we need to find the number of subsections such that the balance on them is a multiple of and non positive then we can apply the operations until the balance is The balance value on the segment equals the balance value on the right boundary minus the balance value on the left boundary i e we can find by prefix sums 
You are given an undirected unweighted connected graph consisting of vertices and edges It is guaranteed that there are no self loops or multiple edges in the given graph Your task is to find spanning tree of this graph such that the maximum degree over all vertices is maximum possible Recall that the degree of a vertex is the number of edges incident to it ,We can take vertex with the maximum degree and all its neighbours To implement it just run from vertex with the maximum degree See the authors solution for better understanding 
You are given an undirected tree of vertices Some vertices are colored blue some are colored red and some are uncolored It is guaranteed that the tree contains at least one red vertex and at least one blue vertex You choose an edge and remove it from the tree Tree falls apart into two connected components Let s call an edge if neither of the resulting components contain vertices of both red and blue colors How many edges are there in the given tree ,Let s root the tree by some vertex The edge where is the parent of is now nice if and only if the subtree of contains either all red vertices of the tree and no blue vertices or all blue vertices of the tree and no red vertices That s because removing that edge splits the tree into the subtree of and the component of every other vertex Thus the task is to calculate the number of red and blue vertices in each subtree with dfs and check a couple of conditions Overall complexity 
 Polycarp is a very famous freelancer His current rating is units Some very rich customers asked him to complete some projects for their companies To complete the th project Polycarp needs to have at least units of rating after he completes this project his rating will change by his rating will increase or decrease by can be positive or negative Polycarp s rating should not fall below zero because then people won t trust such a low rated freelancer Polycarp can choose the order in which he completes projects Furthermore he can even skip some projects altogether To gain more experience and money of course Polycarp wants to choose the subset of projects and the order in which he will complete them so he has enough rating before starting each project and has non negative rating after completing each project Your task is to calculate the maximum possible size of such subset of projects ,To view the main idea of the problem read the editorial of easy version The only difference is that for non negative we don t need to print if we cannot take the project we just need to skip it because we cannot take it at all And for negative we need to write the knapsack dynamic programming to take the maximum possible number of projects we need to consider them in order of their sorting Dynamic programming is pretty easy means that we consider projects and our current rating is and the value of dp is the maximum number of negative projects we can take If the current project is the th negative project in order of sorting we can do two transitions and if then we can make the transition And then we just need to find the maximum value among all values of dp and add the number of positive projects we take to find the answer 
You are given an array of integers You can perform the following operations on array elements choose any index and move the element to the of the array choose any index and move the element to the of the array For example if then the following sequence of operations can be performed after performing the operation of the first type to the second element the array will become after performing the operation of the second type to the second element the array will become You can perform operations of any type any number of times in any order Find the minimum total number of operations of the first and second type that will make the array sorted in non decreasing order In other words what is the minimum number of operations must be performed so the array satisfies the inequalities ,Let s replace each number with the number of unique numbers less than For example the array will be replaced by Note that the values of the numbers themselves were not important to us only the order between them was important Let s sort such an array Let s see what maximum length of the segment from the array is already sorted it forms a subsequence This segment can be left in place and all other numbers can be moved either to the beginning or to the end That is the task came down to finding the maximum sorted subsequence in the array This problem can be solved with the help of simple dynamic programming Let be the maximum length of a subsequence ending in position To calculate it we will find the closest past position which also has the value and the position with value lower numbers cannot be used since must stand between them Any of these positions can be extended so we take the maximum out of them and add 1 It is necessary to separately consider the first numbers in the subsequence and the last since the first should include their suffix and the last should have their prefix 
 Ivan plays a computer game that contains some microtransactions to make characters look cooler Since Ivan wants his character to be really cool he wants to use some of these microtransactions and he won t start playing until he gets all of them Each day during the Ivan earns exactly one burle There are types of microtransactions in the game Each microtransaction costs burles usually and burle if it is on sale Ivan has to order exactly microtransactions of the th type he orders microtransactions during the Ivan can order possibly zero number of microtransactions of types during any day of course If the microtransaction he wants to order is on sale then he can buy it for burle and otherwise he can buy it for burles There are also special offers in the game shop The th offer means that microtransactions of the th type are on sale during the th day Ivan wants to order all microtransactions as soon as possible Your task is to calculate the minimum day when he can buy all microtransactions he want and actually start playing ,The main idea of this problem is the same as in the easy version The only thing we should replace is the search method Replacing linear search with binary search leads to reducing time complexity from to And it is obvious that we can apply binary search here because if we can order all microtransactions during some day then we can order all of them during day even using the answer for days and doing nothing during day 
You are given an integer Find the minimum integer such that and the number is A number is called if its decimal representation having no leading zeroes contains no more than different digits E g if the numbers and are whereas the numbers and are not ,Suppose the number contains digits and its decimal representation is The desired number isn t greater than the number consisting of digits This number is beautiful whereas any beautiful number is at the same time beautiful so contains at most digits At the same time so contains at least digits Therefore the desired number contains exactly digits Since we search for the minimum we need to minimize first of all the first digit only then the second digit etc Therefore we need to find a prefix of the decimal representation of such that is a prefix of the decimal representation of Let s do it greedily Let s find the maximum prefix of such that contains no more than distinct numbers Suppose the prefix has the length If then is already beautiful let s output it Otherwise let s increase the prefix like a number by e g if and then we increase by the resulting prefix is All other digits let s set to zeroes e g if and then will be turned into The answer for the old is the answer for the new To get the answer for the new let s start the described procedure once again preparing the new Let s find the maximum prefix of such that contains no more than distinct numbers It s possible to do using a in which for each digit the key the number of its occurrences in the prefix is stored For an empty prefix the is empty If we increase the prefix length by we need to check that contains no more than keys and add a new key with the value or increase the value of an existing key If the length of the found prefix is equal to the length of the whole decimal representation the given number is already beautiful so the answer is Otherwise the found prefix may not be a prefix of the desired number Let s change the digits of the decimal representation of to turn it into the desired number Let s start the following procedure suppose we consider a prefix with the length equal to First let s find out is it possible to increase the first element out of the prefix i e We need to do it because if we consider the length then the prefix with the length cannot be unchanged so the element must be changed whereas it cannot be decreased because in this case we will get the number which is less than If we can increase the element so that the prefix with the length has at most distinct digits the only thing that is remained to do is to fill the remaining digits somehow greedily and output the result If we cannot increase the element let s decrease the length of the considered prefix by updating the let s decrease the value corresponding to the key by then if it s equal to we remove the key from the Consider how and under what conditions we can change and the following digits If it s impossible Suppose the considered prefix contains less than distinct digits the number of the keys in the is less than In this case we can replace the digit with the value so the prefix with the length will not contain more than distinct elements because the prefix with the length doesn t contain more than distinct elements If the prefix with the length still contains less than distinct numbers let s replace the remaining digits etc with Otherwise we can replace them with the minimum digit that occurs in the prefix with the length it may be Suppose the considered prefix contains exactly distinct digits So let s find the minimum digit that occurs in the prefix with the length and is greater than If such digit exists let s replace with it and all following digits with the minimum digit that occurs in the prefix with the length Otherwise the element cannot be increased The converted by the procedure is the answer 
Vova likes pictures with kittens The news feed in the social network he uses can be represented as an array of consecutive pictures with kittens of course Vova likes all these pictures but some are more beautiful than the others the th picture has beauty Vova wants to repost exactly pictures in such a way that each segment of the news feed of at least consecutive pictures has at least one picture reposted by Vova the sum of beauty values of reposted pictures is maximum possible For example if then Vova has to repost all the pictures in the news feed If then Vova can skip some pictures but between every pair of consecutive pictures Vova has to repost at least one of them Your task is to calculate the maximum possible sum of values of reposted pictures if Vova follows conditions described above or say that there is no way to satisfy all conditions ,Let s use dynamic programming described in the previous tutorial to solve this problem too But its complexity is so we have to improve some part of the solution Let s see how we do transitions in this dp for What can we do to optimize it is the constant and we have to take the maximum value among You will say segment tree I say no Not a segment tree Not a sparse table Not a cartesian tree or some other logarithmic data structures If you want to spend a lot of time to fit such solution in time and memory limits okay it is your choice I prefer the queue with supporting the maximum on it The last part of this tutorial will be a small guide about how to write and use the queue with supporting the maximum on it The first part of understanding this data structure is the stack with the maximum How do we support the stack with the maximum on it That s pretty easy let s maintain the stack of pairs when the first value of pair is the value in the stack and the second one is the maximum on the stack if this element will be the topmost Then when we push some value in it the first element of pair will be and the second one will be if is our stack and is the topmost element When we pop the element we don t need any special hacks to do it Just pop it And the maximum on the stack is always Okay the second part of understanding this data structure is the queue on two stacks Let s maintain two stacks and and try to implement the queue using it We will push elements only to and pop elements only from Then how to maintain the queue using such stacks The push is pretty easy just push it in The main problem is pop If is not empty then we have to pop it from But what do we do if is empty No problems let s just transfer elements of to pop from push to in order from top to bottom And don t forget to pop the element after this transfer Okay if we will join these two data structures we can see that we obtain exactly what we want Just two stacks with maximums That s pretty easy to understand and implement it The last part of the initial solution is pretty easy just apply this data structure in fact data structures to do transitions in our dynamic programming The implementation of this structure can be found in the authors solution Total complexity of the solution is 
We will call a non empty string if it contains the same number of plus and minus signs For example strings and are balanced and strings and are not balanced We will call a string if the string can be made balanced by several possibly zero uses of the following operation replace two minus signs with one plus sign In particular every balanced string is promising However the converse is not true not every promising string is balanced For example the string is promising because you can replace two adjacent minuses with plus and get a balanced string or get another balanced string How many non empty substrings of the given string are promising Each non empty promising substring must be counted in the answer as many times as it occurs in string Recall that a substring is a sequence of consecutive characters of the string For example for string its substring are the string is a substring of itself and some others But the following strings are not its substring ,Now we need to quickly find for a given balance value on the prefix the number of matching left boundaries The boundary is suitable if the balance on the boundary is comparable modulo to the current balance and the current balance is less than the balance on the boundary since we need the balance on the segment to be non positive That is we need to be able to find a number of numbers for each value of the balance that is not less than ours This can be done either by data structure or notice that the balance takes only different values then you can find the number of numbers not less on the prefix for 
You are given an array of integers A is a sequence of contiguous consecutive elements Thus a block is defined by a pair of indices Find a set of blocks such that They do not intersect i e they are disjoint Formally for each pair of blocks and where either or For each block the sum of its elements is the same Formally The number of the blocks in the set is maximum Formally there does not exist a set of blocks satisfying the above two requirements with Write a program to find such a set of blocks ,Let s the same sum of blocks in the answer Obviously can be represented as a sum of some adjacent elements of i e for some and Iterate over all possible blocks in and for each sum store all the blocks You can use map int vector pair int int to store blocks grouped by a sum You can do it with the following code map int vector pair int int segs for int r 0 r n r int sum 0 for int l r l 0 l sum a l segs sum push back l r Note that blocks are sorted by the right end in each group After it you can independently try each group there are of them and find the maximal disjoint set of blocks of a group You can do it greedily each time taking into the answer segment with the smallest right end Since in each group they are ordered by the right end you can find the required maximal disjoint block set with one pass Let s assume is the current group of blocks they are ordered by the right end then the following code constructs the maximal disjoint set int cur 0 int r 1 vector pair int int now for auto seg pp if seg first r cur now push back seg r seg second Choose the maximum among maximal disjoint sets for the groups 
You are given an undirected unweighted connected graph consisting of vertices and edges It is guaranteed that there are no self loops or multiple edges in the given graph Your task is to find spanning tree of this graph such that the is equal to or say that there are no such spanning trees Recall that the degree of a vertex is the number of edges incident to it ,Firstly let s remove the vertex from the graph Then let s calculate the number of connected components Let it be The answer is if and only if or is greater than the number of edges incident to the first vertex Otherwise let s construct the answer Firstly let s add into the new graph spanning trees of components in the initial graph without vertex Then let s add into the new graph edges from vertex one edge to each component Then let s add into the new graph any remaining edges from vertex The last thing we need is to construct a spanning tree of a new graph such that all edges incident to the vertex are in this spanning tree and other edges doesn t matter How to do it Let s run from the vertex in a new graph 
You are given an undirected tree of vertices Some vertices are colored one of the colors some are uncolored It is guaranteed that the tree contains at least one vertex of each of the colors There might be no uncolored vertices You choose a subset of and remove it from the tree Tree falls apart into connected components Let s call this subset of edges if none of the resulting components contain vertices of different colors How many subsets of edges are there in the given tree Two subsets are considered different if there is some edge that is present in one subset and absent in the other The answer may be large so print it modulo ,Okay this solution is really complicated and I would like to hear nicer approaches from you in comments if you have any However I still feel like it s ok to have this problem in a contest specifically as a harder version of F1 Let s start with the following thing Root the tree by some vertex For each color take all vertices of this color and paint their lowest common ancestor the same color as them The purpose of that will come clear later Why can we do this The case with lca some vertex of that color is trivial Now take a look at the edges from lca to its subtrees At least two of them contain a vertex of that color You can t cut the edges to these subtrees because this will make vertices of the same color belong to different components Thus lca will always be in the same component as these vertices If lca is already painted the other color then the answer is 0 That s because lca once again make vertices of the same color belong to different components Now everything will be calculated in a single dfs Let return one of the following values if there is no colored vertex in the subtree of if there exists some color such that vertex has vertices of color in its subtree and vertex has ancestors of color not necesserily direct parent otherwise I claim that if there are multiple suitable colors for some vertex then the answer is 0 Let s take a look at any two of them and call them colors and For both colors take a path from arbitrary vertex of that color in subtree to arbitrary vertex of that color that is ancestor of You can t cut any edge on these paths because that will divide the vertices of the same color Now either path for color contains vertex of color or path for color contains vertex of color That vertex is the upper end of the corresponding path That means that component of one color includes the vertex of the other color which is impossible Moreover that s the last specific check for the answer being 0 The step with lca helped us to move to the ancestor instead of any vertex in the upper subtree of I truly believe that you can avoid lca in this solution however that will make both implementation and proof harder Now let s do the number of ways to cut some edges in the subtree of so that 0 the component with vertex has no colored vertices in it 1 has some colored vertices Generally the color itself for 1 doesn t matter If for some child of returned color then it must be color in that component otherwise the color doesn t matter For all vertices of each color presented in the subtree of are contained within the subtree of The transitions will be of form do we cut the edge from to or not for all children of That is the most tedious part so I m sorry if I mess up something the way I did with my author solution DHere from now I ll ignore the children that returned if I say all children I will mean all non zero returning children as they add nothing to the answer If there are no children then the vertices with will have and the other vertices will have Basically there are two main cases I would recommend to follow the code in attachment while reading this tbh and all children dfs returned Then for each edge to the child you can either cut it if there are colored vertices take or don t cut it if it has no colored vertices take So For to have some color you ll need to push that color from exactly one of the children You can t choose two subtrees because they are guaranteed to have different colors in them otherwise they wouldn t return So To calculate that fast enough you ll need to precalculate prefix and suffix products of or but some children returned the same value Then you are required to make the part of component with vertices of color That means that for that case For children who returned you don t cut their edge take For the other children you can either cut it if there are colored vertices take or don t cut it if it has no colored vertices take Thus The answer will be stored in after that Overall complexity but I m sure this can be rewritten in such a manner that it becomes 
You are given four positive integers Find any such rectangular matrix of size that satisfies all of the following conditions each row of the matrix contains exactly ones each column of the matrix contains exactly ones all other elements are zeros If the desired matrix does not exist indicate this For example for there exists a matrix satisfying the conditions above ,Let s see how the desired matrix looks like Since each row should have exactly ones and each column should have exactly ones the number of ones in all rows should be equal to the number of ones in all columns Thus the desired matrix exists iff or Let s show how to construct the desired matrix if it exists Let s find any number such that where is the remainder of dividing by In the first row of the desired matrix we put the ones at the positions and in the th row we put the ones as in the row but cyclically shifted by to the right 
A known chef has prepared dishes the th dish consists of grams of fish and grams of meat The banquet organizers estimate the of dishes as follows The is equal to the absolute value of the difference between the total mass of fish and the total mass of meat Technically the equals to The smaller the the better In order to improve the a taster was invited He will eat grams of food from each dish For each dish the taster determines separately how much fish and how much meat he will eat The only condition is that he should eat exactly grams of each dish in total Determine how much of what type of food the taster should eat from each dish so that the value of the is as minimal as possible If there are several correct answers you may choose any of them ,Let s find how much meat and fish a taster can eat at most Note that a taster can eat no more than of fish from the th dish since he can t eat more than or more than there is at all Similarly he can eat no more than of meat Let s sum the obtained values over all and denote the resulting sums by and the maximum total amount of fish and meat that can be eaten Let s denote by the value that is the without module If the taster eats as much fish as possible he will eat of fish and of meat and change the by Similarly if he eats the maximum amount of meat the will change by Note that the taster can achieve any between and of the same oddity as both of these numbers To do this just take the way of eating the maximum fish and substitute eating a gram of fish for a gram of meat several times Thus the final can be found as over all between and with same oddity To do this just check the boundaries of the resulting segment if they have the same sign then it s the boundary with the smallest absolute value otherwise we can take one of the numbers present in said set depending on the parity of All that remains is to find how much of what type to eat from each dish Having obtained the answer in the previous paragraph the final balance we can reconstruct how much fish and how much meat the taster has to eat to achieve it The expected amount of fish to be eaten can be found as Note that the taster must eat of fish from the th dish since if meat then at least of fish is guaranteed to be eaten Let s break down into the sum of how much total fish will have to be eaten anyway and the remaining value Let s go through all the dishes and collect the first summand as just the sum of over all and the second summand with greedy algorithm each time giving the taster as much fish beyond what he must eat anyway until the sum of such additions reaches And knowing for each dish how much fish will be eaten from it the amount of meat eaten can be calculated by subtracting the fish eaten from 
There are candies in a candy box The type of the th candy is You have to prepare a gift using some of these candies with the following restriction the numbers of candies of each type presented in a gift should be all distinct i e for example a gift having two candies of type and two candies of type is bad It is also possible that of some types will be taken to a gift You really like some of the candies and don t want to include them into the gift but you want to eat them yourself instead For each candy a number is given which is equal to if you really want to keep th candy for yourself or if you don t mind including it into your gift It is possible that two candies of the same type have different values of You want your gift to be as large as possible but you don t want to include too many of the candies you want to eat into the gift So you want to calculate the maximum possible number of candies that can be included into a gift and among all ways to choose maximum number of candies you want to maximize the number of candies having in your gift You have to answer independent queries ,First of all to maximize the number of candies in the gift we can use the following greedy algorithm let s iterate on the number of candies of some type we take from to backwards For fixed let s try to find any suitable type of candies A type is suitable if there are at least candies of this type in the box If there exists at least one such type that wasn t used previously let s pick any such type and take exactly candies of this type and decrease It does not matter which type we pick if we only want to maximize the number of candies we take Okay let s now modify this solution to maximize the number of candies having We initially could pick any type that has at least candies but now we should choose a type depending on the number of candies with in this type For example if we have two types having and candies with respectively and we want to pick candies from one type and candies from another type and and it s better to pick candies of the first type and candies of the second type In this case we have candies with in the other case it s And if and then So when we want to pick a type of candies such that we will take exactly candies of this type it s optimal to choose a type that wasn t used yet contains at least candies and has maximum possible number of candies with This best type can be maintained with a multiset or a set of pairs 
A sequence of round and square brackets is given You can change the sequence by performing the following operations change the direction of a bracket from opening to closing and vice versa without changing the form of the bracket i e you can change to and to you can change to and to The operation costs burles change any bracket to bracket having the same direction i e you can change to but from to similarly you can change to but from to The operation costs burle The operations can be performed in any order any number of times You are given a string of the length and queries of the type where For every substring find the minimum cost to pay to make it a correct bracket sequence It is guaranteed that the substring has an even length The queries must be processed independently i e the changes made in the string for the answer to a question don t affect the queries In other words for every query the substring is given from the initially given string A correct bracket sequence is a sequence that can be built according the following rules an empty sequence is a correct bracket sequence if is a correct bracket sequence the sequences and are correct bracket sequences if and are correct bracket sequences the sequence the concatenation of the sequences is a correct bracket sequence E g the sequences and are correct bracket sequences whereas and are not ,Consider a substring Let s call square brackets located in odd positions in the substring brackets and square brackets located in even positions brackets Let be the number of odd brackets be the number of even brackets be the number of all square brackets Let s prove that the string can be turned into a correct bracket sequence for burles if and only if Let s prove the necessary condition Suppose the initial substring has been turned into a correct bracket sequence Since we have paid burles there s no bracket which form has been changed Therefore for the new sequence is the same as for the initial sequence the similar situation happens with Let s say that two square brackets form a pair if the left one is an opening bracket and the right one is a closing bracket and the substring between them is a correct bracket sequence A pair can be formed only by one odd bracket and one even bracket because between them is placed an even number of brackets since it s a correct bracket sequence so the difference between their indices is odd In a correct bracket sequence each square bracket has a pairwise bracket Therefore a correct bracket sequence contains pairs of brackets so Let s prove the sufficient condition Suppose the initial substring contains equal numbers of odd and even brackets Let s prove by induction that the substring may be turned into a correct bracket sequence for burles Suppose So the initial substring contains only round brackets Let s make the first brackets opening and the other brackets closing The resulting sequence is a correct bracket sequence whereas we haven t changed the form of any bracket so the cost is equal to A correct bracket sequence has two important properties after deleting its substring being a correct bracket sequence the resulting string is a correct bracket sequence after inserting at any place any correct bracket sequence the resulting string is a correct bracket sequence These properties can be applied to an incorrect bracket sequence too after deleting a substring being a correct bracket subsequence from an incorrect bracket sequence or inserting a correct bracket sequence into an incorrect one the resulting sequence is an incorrect bracket sequence Consider a substring such that Suppose we have proved before that each substring having decreased by can be turned into a correct bracket sequence for burles Let s find two square brackets such that one of them is odd and another one is even and there are no square brackets between them There s an even number of round brackets between them that can be turned into a correct bracket sequence for burles Let s make the left found bracket opening and the right one closing Then the substring starting at the left found bracket and ending at the right found bracket is a correct bracket sequence Let s remove it from The resulting string contains odd brackets and even brackets so by the assumption of induction it can be turned into a correct bracket sequence for burles Let s do it and then insert the removed string into its place Since we insert a correct bracket sequence into a correct bracket sequence the resulting string is a correct bracket sequence Actually the operations of inserting and removing are not allowed they have been used for clarity the string can be turned into a correct bracket sequence without these operations as follows let s turn the substring we have removed into a correct bracket sequence as it was described above then change the other brackets of the string the same way as it was done with the string that was the result after removing The resulting string is a correct bracket sequence Therefore the illegal operations of inserting and removing are not necessary all other operations cost burles so the substring can be turned into a correct bracket sequence for burles Therefore to turn a substring into a correct bracket sequence we need to get a sequence such that Suppose initiallly Let s pay burles to replace odd brackets with round brackets If let s replace even brackets with round brackets Anyway we must pay burles We cannot pay less than this value because for a correct bracket sequence But there s no need to pay more than this value because if we turn the initial substring into a sequence with we can turn it into a correct bracket sequence for free Therfore the answer for a given question is Since we must answer the queries fast let s use a concept of prefix sums If the given string contains brackets let s create arrays and with the length will contain the number of odd brackets on the prefix of the string with the length the same value for even brackets Let s initialize and then iterate from to Let s initialize and If the th bracket is round then the current values are correct Otherwise let s find out what bracket is it If is odd the bracket is odd so we must increase by If is even the bracket is even so we must increase by To get the answer for a current and let s calculate and is a number of odd brackets that belong to the prefix with the length but not to the prefix with the length so Similarly The remaining thing is to output 
You are given a table of size i e two rows and columns consisting of integers from to In one move you can choose some and swap values and in it Each column can be chosen Your task is to find the number of moves required to obtain permutations of size in both first and second rows of the table or determine if it is impossible to do that You have to answer independent test cases Recall that the permutation of size is such an array of size that contains from to exactly once the order of elements doesn t matter ,Firstly we can determine that the answer is if some number has not two occurrences Otherwise the answer exists and we actually don t need to prove it because we can check it later Let s find for each number i from 1 to n indices of columns in which it appears c 1 i and c 2 i Consider some number i If c 1 i c 2 i then let s just skip it we can t change anything by swapping values in this column Otherwise let r 1 i be the number of row of the number i in the column c 1 i and r 2 i is the number of row of the number i in the column c 2 i If r 1 i r 2 i then it s obvious that at exactly one of these two columns should be swapped The same if r 1 i ne r 2 i then it s obvious that we either swap both of them or don t swap both of them Let s build a graph consisting of n vertices when the vertex v determines the state of the v th column If r 1 i r 2 i then let s add edge of color 1 between vertices c 1 i and c 2 i Otherwise let s add the edge of color 0 between these vertices So we have the graph consisting of several connected components and some strange edges Let s color it If the edge v to has the color 1 then the color of the vertex to should be different from the color of the vertex v The same if the edge v to has the color 0 then the color of the vertex to should be the same as the color of the vertex v This makes sense because edges with color 1 mean that exactly one of the columns connected by this edge should be swapped and vice versa So after we colored the graph we can ensure that conditions for each edge are satisfied If it isn t so the answer is but this case can t actually appear Otherwise we need to decide for each component independently what is the color 0 and the color 1 means for it The color 0 can mean that the column having this color isn t swapped and the color 1 means that the column having this color is swapped in this case and vice versa We can choose greedily the minimum number of swaps for each component and print the answer Time complexity O n 
There are of independent carriages on the rails The carriages are numbered from left to right from to The carriages are not connected to each other The carriages move to the left so that the carriage with number moves ahead of all of them The th carriage has its own engine which can accelerate the carriage to km h but the carriage cannot go faster than the carriage in front of it See example for explanation All carriages start moving to the left at the same time and they naturally form We will call consecutive moving carriages having the same speed For example we have carriages and array Then the final speeds of the carriages will be Respectively of the train will be formed There are also messages saying that some engine has been corrupted message means that the speed of the th carriage has decreased by that is there has been a change in the maximum speed of the carriage Messages arrive sequentially the processing of the next message takes into account the changes from all previous messages After each message determine the number of formed trains ,In the set we will keep the indices that start the trains That is if the array the real speeds of the carriages then we will store in the network such values that As well as the value of Thus the size of the set is the answer to the problem Consider now the operation to reduce the speed of the carriage find such maximal index in the set if the value then we should add the value to the set since it will start a new train Then we should remove all subsequent indexes from the set such that Thus for all operations we will add no more than elements to the array and remove in total no more than elements from the set We obtain the asymptotic 
Given an undirected connected graph with vertices and edges The graph contains no loops edges from a vertex to itself and multiple edges i e no more than one edge between each pair of vertices The vertices of the graph are numbered from to Find the number of paths from a vertex to whose length differs from the shortest path from to by no more than It is necessary to consider all suitable paths even if they pass through the same vertex or edge more than once i e they are not simple For example let and and let the graph look like the figure above Then the length of the shortest path from to is Consider all paths whose length is at most The length of the path is Path length is Path length is Path length is There is a total of of matching paths ,Note that in any shortest path we cannot return to the previous vertex Since if the current vertex the previous The current distance the shortest distance to vertex the shortest distance to vertex Then if we return to the vertex the shortest distance from it to is If we add to the current distance we get Thus we get a path at least longer than the shortest one Thus our answer consists of only simple paths If the answer consists only of simple paths then we will simply add vertices to the queue when traversing bfs twice on the first visit and on the next visit when the distance to the vertex is equal to the shortest And we will also count the number of ways to get to that vertex Then we can output the answer as soon as we get to the vertex the second time for processing After that we can terminate the loop The asymptotic will be since we only need bfs 
You are given two non empty strings and consisting of Latin letters In one move you can choose an occurrence of the string in the string and replace it with dots Your task is to remove all occurrences of the string in the string in the minimum number of moves and also calculate how many sequences of moves of the minimum length exist Two sequences of moves are considered different if the sets of indices at which the removed occurrences of the string in begin differ For example the sets and are considered different the sets and too but sets and not For example let the string and the string We can remove all occurrences of the string in moves by cutting out the occurrences of the string at the th and th positions In this case the string is an example of the form It is also possible to cut occurrences of the string at the th and th positions There are two different sequences of minimum length moves Since the answer can be large output it modulo ,First find all occurrences of in as substrings This can be done using the prefix function To find the minimum number of times we need to cut substrings consider all indexes of occurrences Having considered the index of the occurrence we cut out the rightmost occurrence that intersects with it After that we find the leftmost occurrence that does not intersect with the cut one If it doesn t we end the loop The number of optimal sequences of moves will be calculated using dynamic programming For each occurrence we can count how many ways we can cut out all occurrences of in the suffix starting with this occurrence in the minimum number of moves Considering the occurrence we find the leftmost occurrence that does not intersect with it and then iterate over the occurrences with which we can remove it 
Monocarp is playing chess on one popular website He has opponents he can play with The th opponent has rating equal to Monocarp s initial rating is Monocarp wants to raise his rating to the value When Monocarp is playing against one of the opponents he will win if his rating is bigger or equal to the opponent s rating If Monocarp wins his rating is increased by otherwise it is decreased by The rating of his opponent does not change Monocarp wants to gain rating playing as few games as possible But he can t just grind it playing against weak opponents The website has a rule that you should play against all opponents as evenly as possible Speaking formally if Monocarp wants to play against an opponent there should be no other opponent such that Monocarp has played more games against than against Calculate the minimum possible number of games Monocarp needs to gain rating or say it s impossible Note that ratings of Monocarp s opponents change while Monocarp s rating does change ,After parsing the statement you can understand that Monocarp plays cyclically in one cycle he chooses some order of opponents and play with them in that order Then repeats again and again until he gains desired rating at some moment So firstly let s prove that in one cycle it s optimal to play against opponents in Suppose you play with opponents in some order and there is a position where if you swap and you won t lose anything and may even gain extra wins It means that the total gain after playing one cycle in increasing order in greater or equal than playing in any other order In other words we can sort array and play against them cyclically in that order Monocarp s list of games will look like several full cycles and some prefix The problem is that there can be many cycles and we need to skip them in a fast way How one cycle looks Monocarp starts with some wins first games and then loses all other games games where The maximum rating he gains is and the resulting rating after all games is We can already find several conditions of leaving a cycle if then Monocarp gets what he wants and stops otherwise if or he will never gain the desired rating since in the next cycle the number of wins since his starting rating Otherwise if and he will start one more cycle with rating and will gain the desired rating eventually So how to find the number of games he will win for a starting rating Let s calculate two values for a given sorted skill array for each let s calculate the minimum rating Monocarp need to win opponent and all opponent before and the rating he ll get after winning the th opponent We can calculate these values in one iteration we ll use indexation then for each if then and otherwise and Now knowing values it s easy to find the number of wins for a starting rating is equal to minimum such that don t forget indexation Or the first position in array with value strictly greater than We can search it with standard function since array is sorted Okay we found the number of wins for the current Let s just calculate how many cycles Monocarp will make with exactly wins There are only two conditions that should be met in order to break this cycle either Monocarp reaches rating it can be written as inequality or the number of wins increases starting rating becomes greater or equal than i e From the first inequality we get minimum and from the second one As a result we can claim that Monocarp will repeat the current cycle exactly times and either finish in the next turn or the number of wins will change So we can skip these equal cycles we can increase answer by and current rating by Since we skip equal cycles then at each step we either finish with success or or the number of wins increases Since is bounded by we will make no more than skips and total complexity is because of initial sorting and calls of 
Polycarp has of red and of blue candies Using them he wants to make gift sets Each gift set contains either red candies and blue candies or blue candies and red candies Any candy can belong to at most one gift set Help Polycarp to find the largest number of gift sets he can create For example if and then Polycarp can make three gift sets In the first set there will be red candies and blue candies In the second set there will be blue candies and red candies In the third set will be blue candies and red candies Note that in this example there is one red candy that Polycarp does not use in any gift set ,In this problem we can use a binary search for the answer If we can make sets then we can make sets So we need to come up with the following test whether we can make sets knowing the parameters Let otherwise we will swap them If the answer is Otherwise let s say we want to make sets of the first kind Then we get a system of inequalities Let s express from here We need to check whether these four equations have an intersection in integers If there is then the division into gifts exists 
You are given a binary matrix of size A binary matrix is a matrix where each element is either or You may perform some possibly zero operations with this matrix During each operation you can inverse the row of this matrix or a column of this matrix Formally inverting a row is changing all values in this row to the opposite to to Inverting a column is changing all values in this column to the opposite Your task is to sort the initial matrix by some sequence of such operations The matrix is considered if the array is sorted ,The first observation if we have an answer where the first row is inverted we can inverse all rows and columns then the matrix will remain the same and the first row is not inverted in the new answer So we can suppose that the first row is never inverted Note that this will be true only for slow solution The second observation if we consider a sorted matrix its first row either consists only of s or has at least one and then all other rows consist only of s This observation can be extended to the following one user wrote a comment about it and I pinned the link to it above which can improve time complexity of the solution a lot in the sorted matrix either the first row consists only of s or the last row consists only of s the corner case is n 1 but for n 1 we can obtain both answers So what should we do with these observations I will explain a slow solution a faster solution can be obtained by mirroring one of cases of this one Let s iterate over the number of s in the first row Let it be cnt Then the first cnt elements of the first string should be s and all others should be s We can do it by inverting the columns with elements among first cnt elements of the first row and columns with elements among remaining elements So it s case handling time The first case when cnt m is pretty easy We have to check if all rows from 2 to n that they consist only of s or only of s and if some row consists of s then we should invert it If it is true then we found the answer Otherwise the first row consists only of s So we have to find the transitional row the row with some s on the prefix and s on the suffix or vice versa If the number of such rows among all rows from 2 to n is greater than 1 then this configuration is bad If the number of such rows is 1 then let idx be the index of this row Then we should inverse all rows above it consisting only of s and all rows consisting only of s below it And we have to check if the current row is really transitional We know that its sum is neither 0 nor m so there is at least one and at least in it If the first element is then let s inverse it Then we just should check if this row is sorted and if it is then we found the answer And the last case is if there are no transitional rows in the matrix Then we should invert all rows from 2 to n consisting only of s or only of s it does not matter So we have a solution with time complexity O n 3 Each number of s in the first row is processed in O n 2 and there are O n such numbers But we can see that if we apply the last case when the number of is m to the first row and then do the same but with the last row consisting of m we can get a solution in O n 2 
Kirill lives on a connected undirected graph of vertices and edges at vertex One fine evening he gathered friends the th friend lives at the vertex So all friends are now in the vertex the th friend must get to his home to the vertex The evening is about to end and it is time to leave It turned out that of his friends have no cars and they would have to walk if no one gives them a ride One friend with a car can give a ride to number of friends without cars but only if he can give them a ride by driving along one of the paths to his house For example in the graph below a friend from vertex can give a ride to friends from the following sets of vertices but can t give a ride to friend from vertex or a set Kirill wants as few friends as possible to have to walk Help him find the possible number ,To begin with let s learn how to find possible sets of friends for the vertex whom he can give a ride in the form of masks Let s use a breadth first search every time we find the shortest path to the vertex with the previous vertex we will add the masks of the vertex to the masks of the vertex updating them with friends living in Now according to the resulting sets you need to get the best combination of them We will find it using the knapsack problem we will use masks as weights and the total weight will be the bitwise of the selected set 
You are given lengths of segments that need to be placed on an infinite axis with coordinates The first segment is placed on the axis so that one of its endpoints lies at the point with coordinate Let s call this endpoint the of the first segment and let s call its as that endpoint that is not the start The start of each following segment must coincide with the end of the previous one Thus if the length of the next segment is and the end of the previous one has the coordinate the segment can be placed either on the coordinates and then the coordinate of its end is or on the coordinates in which case its end coordinate is The total of the axis by these segments is defined as their overall union which is basically the set of points covered by at least one of the segments It s easy to show that the coverage will also be a segment on the axis Determine the minimal possible length of the coverage that can be obtained by placing all the segments on the axis without changing their order ,One possible solution involves the method of dynamic programming As a state of DP we will use the number of already placed segments and the distance from the end of the last segment to the current left boundary of the coverage and in the DP we will store the minimal possible distance from the end of the last segment to the current right boundary of the coverage We can prove that the answer never exceeds where is the maximal length of the segments To do this let us define a region of length specifically the segment If the end of the last segment has a coordinate we put the next segment to the left otherwise we put it to the right With this algorithm none of the end endpoints of the segments will go beyond the marked boundaries because to do so the segment must be placed from the coordinate of one sign beyond the boundary of the opposite sign and thus must have a length greater than which contradicts how we defined Using this fact we will consider the DP for and as the minimum distance between the end of the th segment and the right boundary of the axis coverage of the first segments when the distance to the left boundary of the coverage equals to The end of the th segment here is the beginning of the first one that is the point The base of DP is since when no segments are placed the coverage boundaries and the current point are all coincident Next we consider the forward dynamic programming relaxation for every there are two cases to consider the case of the next segment being placed to the left and the case of it being placed to the right value below refers to the distance to the right boundary of the coverage and is an alias for If a segment of length is placed to the left side then the new distance to the left boundary will be equal to and distance to the right boundary will always be which gives us the relaxation formula If a segment of length is placed to the right side then the new distance to the right boundary will be equal to and distance to the left boundary will always be which gives us the relaxation formula The values in array can be calculated in ascending order by Then the answer for the problem can be found as the minimum sum of and in the last row of that is The time complexity is 
You are given an array consisting of integers Your problem is to find such pair of indices that is minimum possible is the least common multiple of and minimum positive number such that both and are divisors of this number ,I ve heard about some very easy solutions with time complexity where is the maximum value of but I will describe my solution with time complexity where is the maximum number of divisors of A very good upper bound approximation of the number of divisors of is so my solution works in Firstly let s talk about the idea The main idea is the following for each number from to we want to find two minimum numbers in the array which are divisible by this number Then we can find the answer among all such divisors that have at least two multiples in the array Let s write a function which will try to add the number to all its divisors The easiest way to do it is iterate over all divisors in time and add it somehow But it is too slow Let s improve it somehow How can we skip numbers that aren t divisors of Let s build an Eratosthenes sieve I highly recommended one with time complexity because the sieve with time complexity is about twice slower on such constraints which will maintain the minimum divisor for each number from to the linear sieve builds this array automatically in its implementation Then we can factorize the number in and iterate over all its divisors using simple recursive function And the last thing I should notice this solution can give TLE and require some constant optimizations I recommended to use pair of integers or arrays of size two for each divisor and to add numbers using a few statements 
Recently Vlad has been carried away by spanning trees so his friends without hesitation gave him a connected weighted undirected graph of vertices and edges for his birthday Vlad defined the of a spanning tree as the bitwise OR of all its weights and now he is interested in what is the minimum possible that can be achieved by choosing a certain spanning tree A spanning tree is a connected subgraph of a given graph that does not contain cycles In other words you want to keep edges so that the graph remains connected and the bitwise OR weights of the edges are as small as possible You have to find the minimum bitwise OR itself ,We need to minimize the result of the bitwise operation so for convenience we represent the answer as a mask Firstly let s assume that this mask is composed entirely of ones Let s go from the most significant bit to the least significant one and try to reduce the answer To understand whether it is possible to remove the th bit remove it and check if the graph in which all the weights are submasks of the current answer is connected for this you can use depth first search or a disjoint sets union If the graph is connected then the bit can obviously be thrown out and if not it cannot and must be returned 
There are cities in Berland The city numbered is the capital Some pairs of cities are connected by a road of length 1 Before the trip Polycarp for each city found out the value of the shortest distance from the capital the st city to the th city Polycarp begins his journey in the city with number and being in the th city chooses one of the following actions Travel from the th city to the th city if there is a road from the th city to the th and Travel from the th city to the th city if there is a road from the th city to the th and Stop traveling Since the government of Berland does not want all people to come to the capital so Polycarp can take the second action from the list in other words he can perform the second action or time during his journey Polycarp on the other hand wants to be as close to the capital as possible For example if and the cities are connected as in the picture above then Polycarp could have made the following travels not all possible options Polycarp wants for each starting city to find out how close he can get to the capital More formally he wants to find the minimal value of that Polycarp can get from the city to the city according to the rules described above ,Find the distances to all vertices and construct a new graph that has only edges that goes from a vertex with a smaller distance to a vertex with a larger distance Such a graph cannot contain cycles Next you need to run a dynamic programming similar to finding bridges in an undirected graph First we write the minimum distance from each vertex to the capital using no more than one edge This distance is either equal to the distance from the capital to the vertex itself or the distance to the vertex connected to us by one of the remote edges We can t go through more than one remote edge The real answer for a vertex is the minimum of such values in all vertices reachable from in the new graph Since the new graph is acyclic we can calculate the answer using dynamic programming and a depth first search started from the capital 
Polycarp was dismantling his attic and found an old floppy drive on it A round disc was inserted into the drive with integers written on it Polycarp wrote the numbers from the disk into the array It turned out that the drive works according to the following algorithm the drive takes one positive number as input and puts a pointer to the first element of the array after that the drive starts rotating the disk every second moving the pointer to the next element counting the sum of all the elements that have been under the pointer Since the disk is round in the array the last element is again followed by the first one as soon as the sum is at least the drive will shut down Polycarp wants to learn more about the operation of the drive but he has absolutely no free time So he asked you questions To answer the th of them you need to find how many seconds the drive will work if you give it as input Please note that in some cases the drive can work infinitely For example if and then the answers to the questions are as follows the answer to the first query is because the drive initially points to the first item and the initial sum is the answer to the second query is the drive will spin the disk completely twice and the amount becomes the answer to the third query is the amount is ,Let s denote for the sum of all the elements of the array and for the array of its prefix sums If the drive runs for seconds the sum is This formula immediately shows that if and then the disk will run indefinitely Otherwise the answer exists The disk cannot make less than full spins otherwise the required amount simply will not be achived The disk can t make more spins either because when it reaches the position of the maximum prefix sum will already be achived So we know how to determine the number of full spins of the disk Let s make these spins Now we have a new problem given find the first position in the array such that This problem can be solved using binary search If is not sorted into the array that is there is such that then can simply be thrown out of the array the answer will never be reached on it 
You are given a rooted tree It contains vertices which are numbered from to The root is the vertex Each edge has two positive integer values Thus two positive integers and are given for each edge Output numbers where is defined as follows Consider the path from the root vertex to Let the sum of the costs of along this path be Then is equal to the length of the maximum prefix of this path such that the sum of along this prefix does not exceed Consider an example In this case since the path to has an amount of equal to only the prefix of this path of length has a smaller or equal amount of since the path to has an amount of equal to the prefix of length of this path has a sum of equal to the number is since the path to has an amount of equal to the prefix of length of this path has an amount of equal to this is the longest suitable prefix since the prefix of length already has an amount of equal to which is more than since the path to has an amount of equal to the prefix of length of this path has a sum of equal to this is the longest suitable prefix since the prefix of length already has an amount of equal to what is more than since the path up to has an amount of equal to the prefix of length of this path has an amount of equal to since the path to has an amount of equal to the prefix of length of this path has an amount of equal to this is the longest suitable prefix since the prefix of length already has an amount of equal to which is more than since the path up to has an amount of equal to the prefix of length of this path has an amount of equal to since the path to has an amount of equal to the prefix of length of this path has a sum of equal to ,Note that all are positive which means that the amount on the prefix only increases This allows us to use binary search to find the answer for the vertex It remains only to learn how to quickly find the sum of on the path prefix Let s run a depth first search and store the prefix sums of the current path in stack going to the vertex add the sum to the end of the path and delete it when exiting 
You are given a weighted tree consisting of vertices Recall that a tree is a connected graph without cycles Vertices and are connected by an edge with weight You are given queries The th query is given as an integer In this query you need to calculate the number of pairs of vertices such that the maximum weight of an edge on a simple path between and doesn t exceed ,Let s carry the value that means the answer for the current set of edges Initially it is Let s sort all edges by their weight and all queries by their weight also both in non decreasing order Let s merge components of the tree using disjoint set union We need to carry sizes of components also it is easy if we use Then let s iterate over all queries in order of non decreasing their weights If the current query has weight then let s merge all components connected by edges with weight When we merge two components with sizes and the answer changes like that The value equals to It is so because we subtract all old paths corresponding to these components and add all new paths in the obtained component So the answer for the current query will be after all required merges Time complexity 
Petya studies at university The current academic year finishes with special days Petya needs to pass exams in those special days The special days in this problem are numbered from to There are three values about each exam the day when questions for the th exam will be published the day of the th exam number of days Petya needs to prepare for the th exam For the th exam Petya should prepare in days between and inclusive There are three types of activities for Petya in each day to spend a day doing nothing taking a rest to spend a day passing exactly one exam or to spend a day preparing for exactly one exam So he can t pass prepare for multiple exams in a day He can t mix his activities in a day If he is preparing for the th exam in day then It is allowed to have breaks in a preparation to an exam and to alternate preparations for different exams in consecutive days So preparation for an exam is not required to be done in consecutive days Find the schedule for Petya to prepare for all exams and pass them or report that it is impossible ,If in the current day there is no exam we should prepare for an exam for which questions already given for which we prepare less than needed and which will be before other remaining exams For this we will use array where equals to the number of days which we already prepared for exam Initially array consists of zeroes Let s iterate through the days Suppose exam is in the current day If we did not have time to prepare for it and we should print In the other case in this day we will pass the exam In the other case let iterate through all exams and choose exam for which we need still to prepare i e for which already given the questions and which will be before other remaining exams If there is no such exam we should relax in this day else in this day we should prepare for exam Also we should increase by one 
Treeland consists of cities and roads Each road is bidirectional and connects two distinct cities From any city you can get to any other city by roads Yes you are right the country s topology is an undirected tree There are some private road companies in Treeland The government decided to sell roads to the companies Each road will belong to one company and a company can own multiple roads The government is afraid to look unfair They think that people in a city can consider them unfair if there is one company which owns two or more roads entering the city The government wants to make such privatization that the number of such cities doesn t exceed and the number of companies taking part in the privatization is minimal Choose the number of companies such that it is possible to assign each road to one company in such a way that the number of cities that have two or more roads of one company is at most In other words if for a city all the roads belong to the different companies then the city is Your task is to find the minimal that there is such assignment to companies from to that the number of cities which are not doesn t exceed ,Formally the problem is to paint tree edges in minimal number of colors in such a way the the number of improper vertices doesn t exceed A vertex is improper if it has at least two incident edges of the same color It is easy to show that colors is always enough to paint a tree in such a way that all the vertices are proper where is the maximum vertex degree Actually it is always the truth do any bipartite graph Indeed if number of colors is less than the maximum degree such vertices will have at least two edges of the same color Dirichlet s principle If equals the maximum degree you can use just depth first search tree traversal to paint edges in different colors In this problem you can have up to improper vertices so just choose such minimal that number of vertices of degree greater than is at most In an alternative solution you can use a binary search to find such but it makes the implementation harder and the solution becomes slower by factor After it paint edges with colors each time choosing the next color skip color if it equals with the color of the traversal incoming edge 
You are a mayor of Berlyatov There are districts and two way roads between them The th road connects districts and The cost of travelling along this road is There is some path between each pair of districts so the city is connected There are delivery routes in Berlyatov The th route is going from the district to the district There is one courier on each route and the courier will always choose the minimum by total cost path from the district to the district to deliver products The route can go from the district to itself some couriers routes can coincide You can make at most one road to have cost zero i e you choose at most one road and change its cost with Let be the cheapest cost of travel between districts and Your task is to find the minimum total courier routes cost you can achieve if you optimally select the some road and change its cost with In other words you have to find the minimum possible value of after applying the operation described above optimally ,If we would naively solve the problem we would just try to replace each edge s cost with zero and run Dijkstra algorithm times to get the cheapest paths But this is too slow Let s try to replace each edge s cost with zero anyway but use some precalculations to improve the speed of the solution Let s firstly run Dijkstra times to calculate all cheapest pairwise paths Then let s fix which edge we remove There are three cases for the path this edge was not on the cheapest path before removing and is not on the cheapest path after removing Then the cost of this path is The second case is when this edge was not on the cheapest path before removing but it is on the cheapest path after removing Then the cost of this path is So we are just going from to using the cheapest path then going through the zero edge and then going from to using the cheapest path also or vice versa from to and from to And the third case is when this edge was already on the cheapest path between and but this case is essentially the same as the second one So if we fix the edge then the answer for this edge is Taking the minimum over all edges we will get the answer The precalculating part works in and the second part works in 
You are given a directed acyclic graph consisting of vertices and edges The vertices are numbered from to There are no multiple edges and self loops Let be the number of incoming edges indegree and be the number of outgoing edges outdegree of vertex You are asked to remove some edges from the graph Let the new degrees be and You are only allowed to remove the edges if the following conditions hold for every vertex or or Let s call a set of vertices if for each pair of vertices and such that and there exists a path either from to or from to over the non removed edges What is the maximum possible size of a set after you remove some edges from the graph and both indegrees and outdegrees of all vertices either decrease or remain equal to ,Let s solve the problem in reverse Imagine we have already removed some edges so that the conditions hold When is some set of vertices considered Since the graph is acyclic we can topologically sort the vertices in the set The vertices are reachable from each other so there exists a path from the th vertex in the set to the st vertex Thus there exists a path that goes through all chosen vertices However we can make this conclusion even stronger In the optimal answer not just the path goes from the th vertex to the st one but a single edge That can be shown by contradiction Let there be some vertices and that are adjacent in the chosen set There exists a path between them but not a single edge We want to show that this set is not optimal and can be made larger The vertices on that path don t belong to the set If they did they would be between and in the set because of the topological order We can add them to the set Every vertex that can reach can reach them too and every vertex that can be reached from can be reached from them Thus it will still be a set Now every vertex from to has an edge between them and the size of the set is larger Thus we showed that the maximum set in the answer is always some path in the graph So the task is to choose some path then remove some edges so that this path still exists and the conditions hold Note that if the conditions hold for some set of remaining edges then we can remove any edge from it and the conditions will still be met Thus we can only leave this path Let s look closer into the conditions What they actually tell is the following If a vertex has incoming edges then remove at least one of them The same for the outgoing edges Since we are looking for a path it s enough to leave one outgoing edge for all vertices except the last one and leave one incoming edge for all vertices except the first one In order to achieve that every vertex except the last one should have at least two outgoing edges and every vertex except the first one should have at least two incoming edges We can see that this condition is not only necessary but sufficient as well Just remove the outgoing edges which don t go to the next vertex and the incoming edges which don t go from the previous vertex Now we can wrap this up into the dynamic programming Initialize the answer with since you can always remove all edges and get a set with one vertex Then let be the longest path such that it starts in vertex all vertices in it have at least two incoming edges and all vertices except maybe the final one have at least two outgoing edges Initialize the for the vertices that can be the final in the path have at least two incoming edges with Then update for all that can be internal vertices have at least two outgoing and two incoming edges with for all outgoing edges Finally update the answer from the vertices that can be the first one in the path For each vertex that has at least two outgoing edges take the value of for all outgoing edges Overall complexity 
A sequence of numbers is called if it contains all numbers from to exactly once For example the sequences and are permutations but and are not For a permutation of even length you can make an array of length such that for For example if then As a result we made For a given array find the permutation such that you can make the given array from it If then the lexicographically minimal permutation from which it can be made is since A permutation is lexicographically smaller than a permutation if and only if there exists such that and ,First let s check the array for correctness that is that it has no repeating elements Then let s look at the following ideas each number must be paired with another permutation element with by the definition of array Then since we want a lexicographically minimal permutation it is always more advantageous to put element before for the permutation to be lexicographically minimal the smallest possible numbers must be placed at the beginning Consequently the largest numbers must be placed at the end Let s proceed as follows Let s select the set of numbers that are not included in the array For an element find the maximum number of the set such that and put that number in front of the element moving from the end of the array to its beginning each element will be matched with such an element If at some point can not be matched array is not composed correctly and the answer to the query Otherwise print and the resulting permutation 
Polycarp has a rectangular field of cells the size of the field does not exceed cells in each cell of which there can be candy There are rows and columns in the field Let s denote a cell with coordinates vertically and horizontally by Then the top left cell will be denoted as and the bottom right cell will be denoted as If there is candy in the cell then the cell is marked with the symbol otherwise with the symbol Polycarp made a Robot that can collect candy The Robot can move from either to or to If the Robot is in a cell that contains candy it takes it While there is at least one candy on the field the following procedure is executed Polycarp puts the Robot in an arbitrary cell on the of the field He himself chooses in which cell to place the Robot It is allowed to put the Robot in the same cell multiple times The Robot moves across the field and collects candies He controls the Robot When the Robot leaves the field Polycarp takes it If there are still candies left Polycarp repeats the procedure Find the number of times Polycarp needs to put the Robot on the topmost row of the field in order to collect all the candies It is guaranteed that Polycarp can always collect all the candies ,Note first that we can solve the two subtasks independently if we consider the coloring as on a chessboard since at any move of the robot the parity of does not change Now replace the moves with moves respectively This can be done because we simply shifted the rows by some value with the Robot walking on the same cells it walked on in the original board Let s look at the even numbered gray cells Then we ll go through the columns from left to right keeping the minimum by size set of cells the Robot should be in Then the transition to the next column will be as follows Go through the cells from bottom to top which contain the candy For each cell find the closest cell of our set find the Robot that is above the current cell Then we change the square from the set to the current square If there is no robot for the square in the array then we need to increase the answer by and add the robot to our current square you can think of it as adding the robot to the very top square in the column and getting all the candies that were above In the picture the red circles indicate the cells where we will put the robot as needed The pink cells mean that this cell is contained in the set The final asymptotic depends on the implementation you can use a set as data structure or you can use a vector with two pointers and respectively 
Let us denote by the sum of all divisors of the number i e For example For a given number find the minimum such that ,Note that n le d n le 10 7 10 7 is the maximum value of c in the problem so it is enough for every n 1 10 7 to calculate the value of d n To calculate the value of d n you can use the sieve of Eratosthenes and get the solution for mathcal O 10 7 log 10 7 Also you can use the linear sieve of Eratosthenes to find the minimum divisor for each n 1 10 7 and use the multiplicativity of the function d n d a cdot b d a cdot d b if gcd a b 1 
Nastya baked pancakes and spread them on dishes The dishes are in a row and numbered from left to right She put pancakes on the dish with the index Seeing the dishes Vlad decided to bring order to the stacks and move some pancakes In one move he can shift one pancake from any dish to the closest one that is select the dish and do one of the following if put the pancake on a dish with the previous index after this move and if put the pancake on a dish with the following index after this move and Vlad wants to make the array after moving as few pancakes as possible Help him find the minimum number of moves needed for this The array is called non increasing if for all from to ,For convenience we will calculate the prefix sums on the array we will also enter the array containing the indexes of all pancakes and calculate the prefix sums on it Let s use dynamic programming Let s define as the required number of operations to correctly lay out the th prefix with the final and Then you can go to from the previous number must be greater and the sum is fixed To it will be necessary to add a certain number of actions necessary to get let s call it all the terrible prefix sums are needed to count it Since depends only on and we only need to choose the minimum the choice can be optimized by suffix minima As a result the solution works for that s how many states need to be processed 
Polycarp found on the street an array of elements Polycarp invented his criterion for the beauty of an array He calls an array beautiful if at least one of the following conditions must be met is divisible by or is divisible by For example if and then the array is not beautiful for and none of the conditions above is met and then the array is beautiful and then the array is not beautiful for and none of the conditions above is met Ugly arrays upset Polycarp so he wants to remove some elements from the array so that it becomes beautiful Help Polycarp determine the smallest number of elements to remove to make the array beautiful ,Let s calculate for each number how many times it occurs in the array Let s denote this number as Let s use the dynamic programming method Let be equal to the maximum number of numbers not greater than such that for each pair of them one of the conditions above is satisfied More formally if then there exists numbers from the array such that for all one of the conditions above is satisfied Then to calculate you can use the following formula Note that to calculate you need to go through the list of divisors of For this we use the sieve of Eratosthenes 
Kid was gifted a tree of vertices with the root in the vertex Since he really like objects Kid wants to find out if this tree is Formally a tree is if there exists an order of children such that The subtree of the leftmost child of the root is a mirror image of the subtree of the rightmost child the subtree of the second left child of the root is a mirror image of the subtree of the second right child of the root if the number of children of the root is odd then the subtree of the middle child should be ,Note that if one subtree is a mirror image of another then they are isomorphic that is equal without taking into account the vertex numbers To check the subtrees for isomorphism we use Now we just have to learn how to check trees for symmetry To do this let s calculate how many children of each type our vertex has let s denote the hash of its subtree by the vertex type In order for the vertex subtree to be symmetric each child must have a pair of the same type except perhaps one which must also be symmetric We can calculate the symmetry of the subtrees while counting their hash to simplify this task 
Dima overslept the alarm clock which was supposed to raise him to school Dima wonders if he will have time to come to the first lesson To do this he needs to know the it will take him to get from home to school The city where Dima lives is a rectangular field of size Each cell on this field is denoted by one number The number means that the passage through the cell is prohibited The number means that the cell is free and Dima can walk though it The number means that the cell contains a portal with a cost of A cell with a portal is also considered free From any portal Dima can go to any other portal while the time of moving from the portal to the portal corresponds to the sum of their costs In addition to moving between portals Dima can also move between unoccupied cells adjacent to one side in time In particular he can enter a cell with a portal and not use it Initially Dima is in the upper left cell and the school is in the lower right cell ,There is no point in using two transitions between portals because if you want to go from portal A to portal B and then from portal C to portal D then you can immediately go from portal A to portal D for less Then there are two possible paths First do not use portals Here it is enough to find the shortest path between two points The second use a single transition Let s choose a portal from which we should teleport Obviously this is a portal with a minimum distance to it and the cost of the transition Similarly the portal in which we should teleport is selected 
You are given an undirected connected graph some vertices of which contain tokens and or bonuses Consider a game involving one player you You can move tokens according to the following rules At the beginning of the game you can make exactly one turn move any token to any adjacent vertex If the movement of the token ended on the bonus then you are allowed to make another turn with any token You can use different bonuses in any order The same bonus can be used an unlimited number of times Bonuses do not move during the game There can be several tokens in one vertex at the same time but initially there is no more than one token in each vertex The vertex with number is the finish vertex and your task is to determine whether it is possible to hit it with any token by making turns with the tiles according to the rules described above If a token is initially located at the vertex of then the game is considered already won For example for a given graph you can reach the finish line with a chip from the th vertex by making the following sequence of turns Move from the th vertex to the th Move from the th vertex to the th Move from the th vertex to the th Move from the th vertex to the th Move from the th vertex to the nd Move from the th vertex to the th Move from the nd vertex to the st vertex which is the finish ,Let s calculate the shortest paths to the finish along the vertices containing bonuses We will try to reach the finish line with the chip that is closest to it and mark it If there is none we lose Other chips will give her extra moves Find all connected components from vertices containing bonuses Then for each component we find all the tokens that are not selected located at the vertex of this component and at the vertices adjacent to at least one vertex of this component Consider the size of the connectivity component If it is equal to then the chip located in the neighboring vertex gives an additional move Otherwise the chip located at the top of the component or at the neighboring vertex as well as the selected chip will be able to move indefinitely in turn which gives us a victory Otherwise you need to count the number of extra moves and compare it with the shortest distance to the finish line 
Monocarp plays a computer game yet again This game has a unique trading mechanics To trade with a character Monocarp has to choose one of the items he possesses and trade it for some item the other character possesses Each item has an integer price If Monocarp s chosen item has price then he can trade it for any item with price not greater than Monocarp initially has items the price of the th item he has is The character Monocarp is trading with has items the price of the th item they have is Monocarp can trade with this character as many times as he wants possibly even zero times each time exchanging one of his items with one of the other character s items according to the aforementioned constraints Note that if Monocarp gets some item during an exchange he can trade it for another item since now the item belongs to him and vice versa if Monocarp trades one of his items for another item he can get his item back by trading something for it You have to answer queries Each query consists of one integer which is the value of and asks you to calculate the maximum possible total cost of items Monocarp can have after some sequence of trades assuming that he can trade an item of cost for an item of cost not greater than during each trade Note that the queries are independent the trades do not actually occur Monocarp only wants to calculate the maximum total cost he can get ,Suppose we have fixed the value of so we can trade an item with price for an item with price if We can see that it s never optimal to trade an item with higher price for an item with lower price and we could just simulate the trading process as follows try to find an item owned by Polycarp and a more expensive item owned by the other character which can be traded repeat until we cannot find any suitable pair Unfortunately it is too slow Instead let s try to analyze for a given value of how to verify that an item of price can be traded for an item of price maybe not right away but with intermediate trades You can build a graph of vertices representing items where two vertices representing items with prices and are connected by an edge if and only if Then the edges of the graph represent possible trades and the paths in the graph represent sequences of trades So one item can be traded for another item possibly with intermediate trades if the vertices representing the items belong to the same component For a fixed value of we can build this graph find all of its components calculate the number of Monocarp s items in each component and add this number of most expensive vertices from the component to the answer There are two problems though The first one is that the graph may have up to edges But if we sort all items according to their prices we are only interested in edges between vertices which represent adjacent items in sorted order so the size of the graph is decreased to Another problem is that there are multiple queries for different values of To handle it we can sort the values of in ascending order and go in sorted order while maintaining the graph for the current value of A data structure like DSU or a method like small to large merging can be helpful to update the components as they merge The last trick to quickly recalculate the number of items Monocarp has in a component and the sum of most expensive several items you can build two prefix sum arrays one over the array storing the costs of the items and another one over the array which stores values or depending on who owns the respective item the items should still be considered in sorted order Since each component is a segment of costs of items prefix sums allow us to calculate the required values in By the way knowing that each component is a segment we can get rid of the graph and the structure that stores it altogether and just maintain a set of segments of items representing the components 
Two integer sequences existed initially one of them was increasing and another one decreasing Strictly increasing sequence is a sequence of integers And strictly decreasing sequence is a sequence of integers Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing Elements of increasing sequence were inserted between elements of the decreasing one and possibly before its first element and after its last element For example sequences and can produce the following resulting sequences The following sequence cannot be the result of these insertions because the order of elements in the increasing sequence was changed Let the obtained sequence be This sequence is given in the input Your task is to find two suitable initial sequences One of them should be increasing and another one decreasing If there is a contradiction in the input and it is impossible to split the given sequence into one increasing sequence and one decreasing sequence print ,I know about greedy solutions and other approaches but I ll describe my solution This is dynamic programming I ll consider all positions indexed Let be the minimal element in the decreasing sequence if the last element th was in the increasing sequence and be the maximum element in the increasing sequence if the last element th was in the decreasing sequence Initially all are and all are except two values and What about transitions Let s consider four cases The previous element was in the increasing sequence and we want to add the current element to the increasing sequence We can do if the previous element was in the increasing sequence and we want to add the current element to the decreasing sequence We can do if the previous element was in the decreasing sequence and we want to add the current element to the decreasing sequence We can do if the previous element was in the decreasing sequence and we want to add the current element to the increasing sequence We can do if The logic behind these transitions is kinda hard but understandable If and then the answer is Otherwise we can restore any possible answer using parents in the dynamic programming 
Polycarp is very fond of playing the game Minesweeper Recently he found a similar game and there are such rules There are mines on the field for each the coordinates of its location are known Each mine has a lifetime in seconds after which it will explode After the explosion the mine also detonates all mines vertically and horizontally at a distance of two perpendicular lines As a result we get an explosion on the field in the form of a plus symbol Thus one explosion can cause new explosions and so on Also Polycarp can detonate anyone mine every second starting from zero seconds After that a chain reaction of explosions also takes place Mines explode and also detonate other mines according to the rules described above Polycarp wants to set a new record and asks you to help him calculate in what minimum number of seconds all mines can be detonated ,Our first task is to separate mines into components We will store in the hashmap at the coordinate all the coordinates where there is a mine Let s do the same with the hashmap Thus going through the available arrays in and we connect adjacent elements into one component if also with As a result we have components where if you detonate one mine in the s component then all the mines belonging to this component will also explode Further we find a mine with a minimum timer in each component Finding the minimum for each component we store it conditionally in the array Now we know at what minimum time some component will explode if it is left unaffected To answer it remains to find in the sorted array such a minimum index that is min And the general asymptotic behavior is 
Polycarp grew a tree from vertices We remind you that a tree of vertices is an undirected connected graph of vertices and edges that does not contain cycles He calls a set of vertices if there is such a path in the tree that passes through each vertex of this set without passing through any edge twice The path can visit other vertices not from this set In other words a set of vertices is called if there is a simple path that passes through all the vertices of this set and possibly some other For example for a tree below sets are and are not Polycarp asks you to answer queries Each query is a set of vertices For each query you need to determine whether the corresponding set of vertices is ,If the answer is then we can choose a subset of the tree vertices forming a simple path and containing all the vertices of our set Let s choose the minimum possible path its ends vertices from the set The constraints allow us to answer the query in hang the tree by one of the ends and check if it is true that there is only one selected vertex that does not have any selected ones in the subtree if there is one such vertex then it is the second end To make it easier to search for one of the ends we will hang the tree by any vertex before the queries calculate their depths and take the deepest of the set 
 Vlad found a row of tiles and the integer The tiles are indexed from left to right and the th tile has the color After a little thought he decided what to do with it You can start from any tile and jump to any number of tiles forming the path Let s call the path of length if can be divided into blocks of length exactly that is is divisible by Your task is to find the number of paths of length Since this number may be too large print it modulo ,Let s use the dynamic programming Let be the number of paths on the prefix of blocks of the same color To make transitions in such dynamics for the position we will iterate over the position in which the block started Denote as the number of the same elements as and between them then such a transition creates combinations This solution works in complexity 
Polycarp grew a tree from vertices We remind you that a tree of vertices is an undirected connected graph of vertices and edges that does not contain cycles He calls a set of vertices if there is such a path in the tree that passes through each vertex of this set without passing through any edge twice The path can visit other vertices not from this set In other words a set of vertices is called if there is a simple path that passes through all the vertices of this set and possibly some other For example for a tree below sets are and are not Polycarp asks you to answer queries Each query is a set of vertices For each query you need to determine whether the corresponding set of vertices is ,Recall that the path in the rooted tree ascends from one end to the least common ancestor of the ends and descends to the other end possibly by 0 Then our set is divided into two simple ways To check this you only need to count We will first calculate the depths as for solving an easy version of the problem We will go along the vertices according to the non growth of the depths if of the deepest vertex and the current one is equal to the current one then it is the ancestor of the deepest one we will mark it Next we will find the deepest unmarked vertex and do the same if there is no such vertex then the whole path goes down and the answer is If there are unmarked vertices then there are vertices outside of those two ascents and the answer is Now we need to check that the two ascents do not intersect or intersect only at the of ends for this we just make sure that is not deeper than the shallowest vertex of the set 
 Vlad found a row of tiles and the integer The tiles are indexed from left to right and the th tile has the color After a little thought he decided what to do with it You can start from any tile and jump to any number of tiles forming the path Let s call the path of length if can be divided into blocks of length exactly that is is divisible by Your task is to find the number of paths of length Since this number may be too large print it modulo ,To solve the hard version let s modify the simple version solution Note that the parameter can be discarded since we only need paths of maximum length on each prefix Now as we denote a pair of the number of maximum paths and the number of blocks in them For the position we will find the position closest to the left from which we can start a block and so we will find out what is the maximum for We will update until the maximum of the position being sorted is suitable for us 
The chef has cooked dishes yet again the th dish consists of grams of fish and grams of meat Banquet organizers consider two dishes and equal if and at the same time The banquet organizers estimate the of dishes as follows The of a set of dishes is equal to the number of different dishes in it The is the In order to reduce the a taster was invited He will eat grams of food from each dish For each dish the taster determines separately how much fish and how much meat he will eat The only condition is that he will eat exactly grams of the th dish in total Determine how much of what type of food the taster should eat from each dish so that the value of is the minimum possible If there are several correct answers you may output any of them ,Note that dishes can become equal if and only if they have equal values of that is how much fish and meat remain in them in total after tasting Let s calculate this value for each dish and group all the dishes with equal calculated values The minimum amount of fish that can remain in the th dish is in case where the maximum possible mass of fish is eaten Similarly the maximum amount of fish that can remain is in case where the maximum possible mass of meat is eaten Consider one of the groups in which there are all the dishes with equal values We sill assign each dish a corresponding segment on the coordinate line between and This segment specifies all possible values of the remaining mass of fish in the dish any value on it is achievable by replacing eating some mass of fish with the same mass of meat And since is common the same amount of remaining fish will imply the same amount of remaining meat thus equality Let us solve the problem for each group independently Within a group the problem is reduced to choosing as few points as possible that cover all the segments described in the last paragraph that is that there should be a point inside each segment Each selected point will correspond to the resulting dish and it being inside a segment will mean that such a resulting dish can be obtained from the corresponding starting one Such a problem is solved as follows we choose a segment with the minimal right end because it must contain at least one chosen point we ll greedily choose it equal to its right end there s no point in choosing a point to the left from it since it will not cover more segments than the right end of the segment in question we ll mark all segments containing this point as covered and repeat the algorithm for the next unprocessed segment with the minimal right end For this algorithm it is sufficient to sort the segments by their right ends within each group and iterate through the segments greedily selecting points in the manner described above The set of points obtained at the end will be the answer and its size and the information about the point selected within each segment should be printed in the output If for a dish a point is chosen inside its corresponding segment then there should be exactly of fish left in it that is you should output the numbers and in the answer 
Consider all binary strings of length A binary string is a string that consists of the characters and only For example is a binary string and is not Obviously there are exactly such strings in total The string is lexicographically smaller than the string both have the same length if in the first position from the left in which they differ we have This is exactly the way strings are compared in dictionaries and in most modern programming languages when comparing them in a standard way For example the string is lexicographically smaller than the string because the first two characters are the same and the third character in the first string is less than that in the second We remove from this set binary strings each of length Thus the set will have strings Sort all strings of the resulting set in lexicographical ascending order as in the dictionary We number all the strings after sorting from to Print the string whose index is such an element is called where is the rounding of the number down to the nearest integer For example if and then after removing the strings and sorting the result will take the form Thus the desired median is ,If we did not delete the strings then the median would be equal to the binary notation of After deleting strings the median cannot change numerically by more than Let s start with the median and each time decrease it by one if there are fewer not deleted smaller numbers than not deleted large numbers Similarly you need to increase the median by one otherwise The algorithm stops when the result is the median of the current set All these steps will run at most times 
You are given a permutation of elements A permutation of elements is an array of length containing each integer from to exactly once For example and are permutations but and are not permutations You should perform queries There are two types of queries swap and print the number that will become if we assign times ,Let s compute an array of integers answers to all possible second type queries with Now if we have to perform any second type query we can split it into at most queries with and at most queries with Let s also compute an array of integers reverse permutation If then To perform any first type query we should recompute and We can swap and in the array and and in the array No more than elements will be changed in the array These are elements with indexes elements and elements We can recompute and then assign and times Similarly for Time complexity 
 A subsequence is a string that can be derived from another string by deleting some or no symbols without changing the order of the remaining symbols Characters to be deleted are not required to go successively there can be any gaps between them For example for the string the following strings are subsequences and empty string But the following strings are not subsequences and You are given a string consisting of lowercase Latin letters In one move you can take subsequence of the given string and add it to the set The set can t contain duplicates This move costs where is the length of the added subsequence i e the price equals to the number of the deleted characters Your task is to find out the minimum possible total cost to obtain a set of size or report that it is impossible to do so ,Firstly let s calculate the following auxiliary matrix means the maximum position that is less than or equal to and the character in order from to and so on It can be calculated naively or with some easy dynamic programming initially all are and then for each from to all values are equal to except which is After calculating this matrix we can solve the problem by the following dynamic programming let be the number of subsequences of length that ends exactly in the position Initially all values are zeros except for each from to How do we perform transitionss Let s iterate over all lengths from to then let s iterate over all positions from to in a nested loop and for the current state we can calculate it as If then we don t need to add this state of the dynamic programming to the current state Don t forget to take the minimum with after each transition This transition means that we take all subsequences that end with each possible character of the alphabet and try to add the current character to each of them You can understand that there are no overlapping subsequences in this dynamic programming After that let s iterate over all possible lengths from to and calculate the number of subsequences of the current length It equals to The same if then we don t need to add this state of the dynamic programming to Don t forget to take the minimum with If then let s add to the answer and break the cycle Otherwise let s add to the answer and decrease by If after all iterations is greater than zero then let s try to add the empty string to the answer we didn t take it into account earlier Increase the answer by and decrease by one If after this is still greater than zero then the answer is otherwise the answer is the calculated sum Time complexity 
Given a lowercase Latin character letter check if it appears in the string ,You need to implement what is written in the statement You can either use an if statement for each of the characters or you can iterate through the string check if the current character equals 
Codeforces separates its users into divisions by their rating For Division 1 For Division 2 For Division 3 For Division 4 Given a print in which division the belongs ,For this problem you just need to implement what it asks you To be able to implement it you need to know about the if statement 
A ticket is a string consisting of six digits A ticket is considered lucky if the sum of the first three digits is equal to the sum of the last three digits Given a ticket output if it is lucky or not Note that a ticket can have leading zeroes ,We need to check if the sum of the first three digits is equal to the sum of the last three digits This is doable by scanning the input as a string then comparing the sum of the first three characters with the sum of the last three characters using the if statement and the addition operation 
You are given four integers Timur and three other people are running a marathon The value is the distance that Timur has run and correspond to the distances the other three participants ran Output the number of participants in front of Timur ,We can re word the problem to count the number of numbers from that are larger than A possible way to do this is by keeping a variable that gets incremented every time we checked using the if statement whether a number is larger than The complexity is 
Given three integers and find the medium number between all of them The medium number is the number that is neither the minimum nor the maximum of the given three numbers For example the median of is since the minimum is and the maximum is ,Here are two ways to implement what s given in the problem Take input as an array a 1 a 2 a 3 and sort it Output the middle element Write two if statements The first if a b text and a c text or a b text and a c output a Else if b a text and b c text or b a text and b c output b Else output c 
You are given three integers and such that of these two equations is true Output if the first equation is true and otherwise ,You need to implement what is given in the statement for example you can use an if statement to output if and otherwise 
Timur likes his name As a spelling of his name he allows any permutation of the letters of the name For example the following strings are valid spellings of his name Note that the correct spelling must have uppercased and lowercased other letters Today he wrote string of length consisting only of uppercase or lowercase Latin letters He asks you to check if is the correct spelling of his name ,Here are two solutions Iterate through the string character by character If then otherwise if or then or If the statement is false for any the answer is Otherwise it is Replace all with since they are the same anyway Then just check if the two strings are equal In either case the complexity is per testcase 
You are given three integers and Determine if one of them is the sum of the other two ,You only need to write an if statement and check if any of these are true 
There is a string of length consisting of uppercase and lowercase English letters Check if it is equal to without quotes where each letter can be in any case For example are all allowable ,You should implement what is written in the statement Here are three ways to do it Check that the first character is or check that the second character is or and check the third character is or Make an array storing all acceptable strings there are only and loop and see if any of the strings match the input Use some built in function like in C to make the string all lowercase and check if is equal to The complexity is per test case 
Sho has an array consisting of integers An operation consists of choosing two distinct indices and and removing and from the array For example for the array Sho can choose to remove indices and After this operation the array becomes Note that after any operation the length of the array is reduced by two After he made some operations Sho has an array that has only elements In addition he made operations such that the resulting array is the possible More formally the array after Sho has made his operations respects these criteria No pairs such that and exist The length of is maximized Output the length of the final array ,Note that the size of the array doesn t change parity since it always decreases by Let s count the number of distinct elements call it If is the same parity as the length of the array then we can make sure all of these distinct elements stay in the array by removing two elements at a time Otherwise isn t the same parity as Then is the same parity as and we can make sure distinct elements stay in the array by removing two elements at a time So the answer is if and have the same parity and otherwise For example has So and have the same parity and we can get all distinct numbers by removing Time complexity or depending on the implementation 
In order to write a string Atilla needs to first learn all letters that are contained in the string Atilla needs to write a message which can be represented as a string He asks you what is the minimum alphabet size required so that one can write this message The alphabet of size contains Latin letters For example an alphabet of size contains the characters and ,To solve the problem we need to find the character with the highest alphabetical order in our string since Atilla will need at least that alphabet size and won t need more To do this iterate through the string and find the character with the highest alphabetical order Output the maximum alphabetical order found The solution can be done in 
Vasya has a grid with rows and columns He colours each cell red green or blue Vasya is colourblind and can t distinguish green from blue Determine if Vasya will consider the two rows of the grid to be coloured the same ,Here are two solutions Iterate through the string character by character If then otherwise if or then or If the statement is false for any the answer is Otherwise it is Replace all with since they are the same anyway Then just check if the two strings are equal In either case the complexity is per testcase 
There are boxes with different quantities of candies in each of them The th box has candies inside You also have friends that you want to give the candies to so you decided to give each friend a box of candies But you don t want any friends to get upset so you decided to eat some possibly none candies from each box so that all boxes have the same quantity of candies in them Note that you may eat a different number of candies from different boxes and you cannot add candies to any of the boxes What s the minimum total number of candies you have to eat to satisfy the requirements ,Because we can only eat candies from boxes The only way to make all boxes have the same quantity of candies in them would be to make all candies contain a number of candies equal to the minimum quantity of candies a box initially has So we should find this minimum number let s denote it as and then for each box there should be eaten candies So the answer would be the sum of over all s 
Alperen is standing at the point He is given a string of length and performs moves The th move is as follows if then move one unit left if then move one unit right if then move one unit up if then move one unit down There is a candy at that is one unit above and one unit to the right of Alperen s starting point You need to determine if Alperen ever passes the candy ,We can keep track of our current point as we iterate over the string if then decrement set if then increment set if then increment set if then decrement set Initially set If is ever true then we should output otherwise we output The time complexity is 
Mihai and Bianca are playing with bags of candies They have a row of bags of candies The th bag has candies The bags are given to the players in the order from the first bag to the th bag If a bag has an even number of candies Mihai grabs the bag Otherwise Bianca grabs the bag Once a bag is grabbed the number of candies in it gets added to the total number of candies of the player that took it Mihai wants to show off so he wants to reorder the array so that at any moment except at the start when they both have no candies Mihai will have candies than Bianca Help Mihai find out if such a reordering exists ,Let be the total number of candies with all bags with an even number of candies and the total of all bags with an odd number of candies If then the answer is because at the end Mihai who takes only even numbers of candies will have less candies than Bianca Otherwise if the answer is The construction is to simply put all even bags first and then all odd bags since all even bags come before all odd bags and at any point in time Mihai will have more candies than Bianca The time complexity is 
In an ICPC contest balloons are distributed as follows Whenever a team solves a problem that team gets a balloon The first team to solve a problem gets an additional balloon A contest has 26 problems labelled You are given the order of solved problems in the contest denoted as a string where the th character indicates that the problem has been solved by some team No team will solve the same problem twice Determine the total number of balloons that the teams received Note that some problems may be solved by none of the teams ,Let s keep an array of booleans denoting whether or not some team has solved the th problem already Now we can iterate through the string from left to right and keep a running total If is true the th problem has already been solved increase by otherwise increase by and set to true The time complexity is Bonus the answer is always Can you see why 
You are given an array of positive integers Determine if by rearranging the elements you can make the array strictly increasing In other words determine if it is possible to rearrange the elements such that holds ,If there are two elements with the same value then the answer is because neither of these values is less than the other Otherwise the answer is since we can just sort the array The time complexity is or depending on the implementation 
You are given two positive integers and Represent the number as the sum of positive integers of the same parity have the same remainder when divided by In other words find such that all and either all are even or all are odd at the same time If such a representation does not exist then report it ,Consider two cases when we choose all odd numbers and all even numbers In both cases let s try to maximize the maximum So if we choose odd numbers let s try to take ones and the remainder But we need to sure that is greater than zero and odd And in case of even numbers let s try to take twos and the remainder We also need to check that the remainder is greater than zero and even If none of these cases is true print 
Given an array of elements print any value that appears at least three times or print if there is no such value ,Approach 1 Sort the array using an efficient sorting algorithm For every element check if the next two in the array are equal to it If you find such an element output it Time complexity is Approach 2 Notice that elements have an upper bound of you can use an auxiliary array to store the count of each value Go through each value and see if its count is bigger than or equal to Time complexity is 
There are participants in a competition participant having a strength of Every participant wonders how much of an advantage they have over the other best participant In other words each participant wants to know the difference between and where is the strongest participant in the competition not counting a difference can be negative So they ask you for your help For each output the difference between and the maximum strength of any participant other than participant ,Make a copy of the array s call it t Sort t in non decreasing order so that t 1 is the maximum strength and t 2 the second maximum strength Then for everyone but the best person they should compare with the best person who has strength t 1 So for all i such that s i neq t 1 we should output s i t 1 Otherwise output s i t 2 the second highest strength which is the next best person 
Luca has a cypher made up of a sequence of wheels each with a digit written on it On the th wheel he made moves Each move is one of two types move denoted by it increases the th digit by After applying the up move on it becomes move denoted by it decreases the th digit by After applying the down move on it becomes Luca knows the final sequence of wheels and the moves for each wheel Help him find the original sequence and crack the cypher ,We will perform each move in reverse from the final sequence of the cypher move it increases the th digit by After applying the up move on it becomes move denoted by it decreases the th digit by After applying the down move on it becomes Now we just need to implement the two types of moves The time complexity is per test case 
You are given a string consisting of lowercase Latin characters In an operation you can take a character and replace occurrences of this character with or replace occurrences of this character with Is it possible to perform some number of moves so that the resulting string is an alternating binary string For example consider the string You can perform the following moves Replace with Now the string is Replace with Now the string is Replace with Now the string is This is an alternating binary string An is a string of s and s such that no two adjacent bits are equal For example are alternating binary strings but are not ,Let s solve a harder problem given a string and a binary string can we make into using the find and replace operations We can simply iterate through each character of and see the bit it has turned to in that is for each Keep track of each change and see if there is some letter that needs to be turned into both and If there is some letter it is impossible since each operation requires changing all occurrences of a letter into the same bit Otherwise it is possible and we can directly change each letter into the bit it needs to be See the implementation for a better understanding Now for this problem since there are only two alternating binary strings of length and we can simply check both Actually we only have to check one do you see why The time complexity is 
You are given two positive integers and Print the th positive integer that is not divisible by For example if and then all numbers that are not divisible by are The th number among them is ,Suppose the answer is just th positive integer which we should shift right by some number Each multiplier of shifts our answer by The number of such multipliers is where is divided by rounded down So the final answer is th positive integer with the required number of skipped integers multipliers of You can also use a binary search to solve this problem 
You are given words of length consisting of lowercase Latin alphabet letters The th word is denoted In one move you can choose and change the letter at that position to the previous or next letter in alphabetical order For example you can change to or to can only be changed to can only be changed to The between two words is the number of moves required to make them equal For example the between and is Find the minimum of and such that In other words find the minimum over all possible pairs of the words ,Firstly given any pair of strings of length we should be able to tell the difference between them It s enough to find the sum of absolute differences between each character from the same position Now we should go through all possible pairs and pick the minimum value over all of them using the function we use to calculate the difference 
Given an array of positive integers you can do operations of two types on it Add to element with an index In other words change the array as follows Add to element with an index In other words change the array as follows Determine if after any number of operations it is possible to make the final array contain only even numbers or only odd numbers In other words determine if you can make all elements of the array have the same parity after any number of operations Note that you can do operations of both types any number of times even none Operations of different types can be performed a different number of times ,Note is that after doing two operations of the same type they are cancelled out in terms of parity since we would change the parity of all elements once then change it back again So we know that we will do each operation exactly or time It is possible to check all possible cases just by simulating or we can notice that all elements on all indices of the same parity have the same parity and if they do we can always find an answer by doing just a single type of operation a single time in case the array doesn t already contain all elements of the same parity The time complexity is 
Timur initially had a binary string possibly of length He performed the following operation several possibly zero times Add to one end of the string and to the other end of the string For example starting from the string you can obtain either or You are given Timur s final string What is the length of the possible string he could have started with A binary string is a string possibly the empty string whose characters are either or ,Let s perform the process in reverse we will remove the first and last character of the string if these two characters are different We should do this as long as possible since we need to find the shortest initial string So the algorithm is straightfoward keep track of the left and right characters and if they are different remove both Otherwise output the length of the current string or output if the string became empty There are a few ways to implement this For example you can keep two pointers one at the beginning of the string and one at the end say and and check if If it s true then we increment and decrement Otherwise we output We stop when Alternatively you can use deque to simulate the operations directly The time complexity is 
On an grid some horizontal rows have been painted red and some vertical columns have been painted blue in some order The stripes are drawn sequentially one after the other When the stripe is drawn it repaints all the cells through which it passes Determine which color was used last ,Note that if a stripe is painted last then the entire stripe appears in the final picture because no other stripe is covering it Since rows are only painted red and columns are only painted blue we can just check if any row contains 8 s If there is such a row then red was painted last otherwise blue was painted last 
Mihai has an chessboard whose rows are numbered from to from top to bottom and whose columns are numbered from to from left to right Mihai has placed exactly one bishop on the chessboard In other words the row and column of the bishop are between and inclusive The bishop attacks in all directions diagonally and there is no limit to the distance which the bishop can attack Note that the cell on which the bishop is placed is also considered attacked Mihai has marked all squares the bishop attacks but forgot where the bishop was Help Mihai find the position of the bishop ,There are many ways to solve the problem One way is to look for the following pattern There can only be one such pattern if there is one bishop and it s not on the edge of the board We can iterate through all cells and see if we can match this pattern and if we can we output the centre cell You can also look at the positions of the two diagonals and intersect them but it requires more implementation Time complexity per testcase 
Three guys play a game first each person writes down distinct words of length Then they total up the number of points as follows if a word was written by one person that person gets 3 points if a word was written by two people each of the two gets 1 point if a word was written by all nobody gets any points In the end how many points does each player have ,You need to implement what is written in the statement To quickly check if a word is written by another guy you should store some or Python dictionary and increment every time you see a new string in the input Then you should iterate through each guy find the number of times their word appears and update their score The complexity is per testcase 
There are candies in a row they are numbered from left to right from to The size of the th candy is Alice and Bob play an interesting and tasty game they eat candy Alice will eat candy and Bob The game ends if all the candies are eaten The process consists of moves During a move the player eats one or more sweets from her his side Alice eats from the left Bob from the right Alice makes the first move During the first move she will eat candy its size is Then each successive move the players alternate that is Bob makes the second move then Alice then again Bob and so on On each move a player counts the total size of candies eaten during the current move Once this number becomes strictly greater than the total size of candies eaten by the other player on their previous move the current player stops eating and the move ends In other words on a move a player eats the smallest possible number of candies such that the sum of the sizes of candies eaten on this move is than the sum of the sizes of candies that the other player ate on the move If there are not enough candies to make a move this way then the player eats up all the remaining candies and the game ends For example if and then move 1 Alice eats one candy of size and the sequence of candies becomes move 2 Alice ate on the previous move which means Bob must eat or more Bob eats one candy of size and the sequence of candies becomes move 3 Bob ate on the previous move which means Alice must eat or more Alice eats three candies with the total size of and the sequence of candies becomes move 4 Alice ate on the previous move which means Bob must eat or more Bob eats two candies with the total size of and the sequence of candies becomes move 5 Bob ate on the previous move which means Alice must eat or more Alice eats two candies with the total size of and the sequence of candies becomes move 6 the last Alice ate on the previous move which means Bob must eat or more It is impossible so Bob eats the two remaining candies and the game ends Print the number of moves in the game and two numbers the total size of all sweets eaten by Alice during the game the total size of all sweets eaten by Bob during the game ,This is just an implementation problem and it can be solved in time but we didn t ask for such solutions so you could solve it in or maybe even in I ll describe solution anyway Firstly we need to maintain several variables initially the number of moves passed the position of the leftmost remaining candy initially the position of the rightmost remaining candy initially the sum of candies eaten by Alice initially the sum of candied eaten by Bob initially the sum of candies eaten by Alice during her last move initially and the sum of candies eaten by Bob during his last move initially So let s just simulate the following process while if the number of moves is even then now is Alice s move and we need to maintain the sum of candies Alice eats during this move How to calculate it While and let s eat the leftmost candy so variables will change like this After all let s add to replace with assign and increase by If the number of moves is odd then the process is the same but from the Bob s side I ll also add a simply implemented solution written by Gassa below 
You are given an array of integers This array is called a if there exists subarray such that or or Here are three examples The first image shows the array it because only subarray with indices satisfies the condition The second image shows the array it because only subarray with indices satisfies the codition The third image shows the array it because two subarrays and that satisfy the condition You are asked whether the given array is a valley or not ,One possible solution is to represent a range of equal element as a single element with that value Construct this array and loop through it and check how many element satisfy the conditions or and or If exactly one index satisfies these conditions print YES and othewise NO Complexity 
A row of cells is given all initially white Using a stamp you can stamp any two neighboring cells such that one becomes red and the other becomes blue A stamp can be rotated i e it can be used in both ways as and as During use the stamp must completely fit on the given cells it cannot be partially outside the cells The stamp can be applied multiple times to the same cell Each usage of the stamp recolors both cells that are under the stamp For example one possible sequence of stamps to make the picture could be Here and represent a white red or blue cell respectively and the cells that the stamp is used on are marked with an underline Given a final picture is it possible to make it using the stamp zero or more times ,First note that parts of the picture separated by are independent That is any stamps used on one part doesn t have any impact on the other since a character means no stamp has been placed on that cell So let s split the string by s for example with method in Python and consider the resulting strings containing only and Call one of these parts In the final stamp we place on we must have placed so it should have both the characters and Therefore if the string has only or only the answer is Otherwise the answer is Let s show it As we have just shown we must have next to for the string to be possible Consider the way to make The final stamp can be For the rest of the cells we can make them one by one as below so now we have made the prefix of the string before the final stamp Similarly Now we have made the prefix and the suffix by stamping one character at a time actually we stamp two characters but then cover it up with another stamp Finally we can put the final stamp to make the whole string This method easily generalizes to any string We can find the final stamp and then make the prefix and suffix one by one The solution runs in 
Given an array of positive integers Find the maximum value of such that and are coprime or if no such exist For example consider the array The maximum value of that can be obtained is since and are coprime Two integers and are coprime if the only positive integer that is a divisor of both of them is that is their greatest common divisor is ,Note that the array has at most distinct elements since For each value store the largest index it is in Then we can brute force all pairs of values and find the coprime pair with largest sum of indices The time complexity is per testcase 
Let s denote the function for a string as the number of distinct characters that the string contains For example and Given a string split it into two non empty strings and such that is the maximum possible In other words find the maximum possible value of such that the concatenation of string and string is equal to string ,Let s check all splitting points for all We denote a splitting point as the last index of the first string we take and all the remaining characters will go to the second string We need to keep a dynamic count of the number of distinct characters in both strings the first string and the second string We can do this using two frequency arrays and adding one to the distinct count of either string or when the frequency of a character is greater than zero 
You are given strings of length at most For each string determine if there exist two strings and such that That is is the concatenation of and Note that be equal to Recall that the concatenation of strings and is where and are the lengths of strings and respectively For example concatenation of and is ,Use some data structure that allows you to answer queries of the form does the string appear in the array For example in C you can use a while in Python you can use a dictionary Afterwards for each string brute force all strings and such that There are at most such strings because has length at most Then check if both and appear in the array using your data structure The time complexity is per test case where is the maximum length of an input string 
There are people in a horizontal line each looking either to the left or the right Each person counts the number of people in the direction they are looking The of the line is the sum of each person s count For example in the arrangement where stands for a person looking left and stands for a person looking right the counts for each person are and the value is You are given the initial arrangement of people in the line For each from to determine the maximum value of the line if you can change the direction of people ,For each person let s calculate how much the value will change if they turn around For example in the line if the th person turns around then the value of the line will change by respectively For instance if the second person turns around they see people before and person after so the value of the line changes by if they turn around Now note that if a person turns around it doesn t affect anyone else s value So the solution is a greedy one let s sort the array of values in increasing order Afterwards we should go from the left to the right and see if the value will increase if this person turns around if it does we should add it to the current total and continue The time complexity of this solution is per testcase 
You have an array Answer queries of the following form If we change all elements in the range of the array to will the sum of the entire array be odd Note that queries are and do not affect future queries ,Note that for each question the resulting array is So the sum of the elements of the new array after each question is We can compute and in time by precomputing the sum of all prefixes and suffixes or alternatively by using the prefix sums technique So we can find the sum each time in per question and just check if it s odd or not The time complexity is 
Victor has a 24 hour clock that shows the time in the format He looks at the clock every minutes and the clock is currently showing time How many palindromes will Victor see in total after looking at the clock every minutes the first time being at time For example if the clock starts out as and Victor looks at the clock every minutes i e every hours then he will see the times and the times will continue to repeat Here the time is the only palindrome he will ever see so the answer is A palindrome is a string that reads the same backward as forward For example the times are palindromes but are not ,Note that Victor looks at the clock forever but there are only at most different times the clock can show because there are different minutes in a day So we only have to check the first times Victor sees and count the palindromes you can check a few more just to be safe but they will repeat anyways Now we just have to implementing adding minutes to a clock There are several ways to do this One of the slower ways might be writing functions converting a number of minutes into a time for a clock or you can just compute all palindrome times in terms of minutes and that way you don t have to convert from clock time to number of minutes The complexity is per test case since you only have to check a constant number of times 
Timur s grandfather gifted him a chessboard to practice his chess skills This chessboard is a grid with rows and columns with each cell having a integer written on it Timur s challenge is to place a bishop on the board such that the sum of all cells attacked by the bishop is The bishop attacks in all directions diagonally and there is no limit to the distance which the bishop can attack Note that the cell on which the bishop is placed is also considered attacked Help him find the maximal sum he can get ,The solution is to check the sum over all diagonals for each cell For a cell we can iterate over all elements in all its diagonals This will be in total elements The complexity will be solutions involving precomputation are also possible but aren t needed 
Given strings each of length consisting of lowercase Latin alphabet letters output the number of pairs of indices such that and the th string and the th string differ in exactly one position In other words count the number of pairs such that the th string and the th string have one position such that The answer may not fit into 32 bit integer type so you should use 64 bit integers like in C to avoid integer overflow ,One solution is to go through all given strings generate all strings that differ in exactly one position and count the number of times these strings occur in the array A possible way to count them is by using either the map dictionary data structure or even simpler a frequency array Depending on the implementation you may need to divide the answer by because of overcounting pairs The solution runs in or depending on the implementation 
Slavic has an array of length consisting only of zeroes and ones In one operation he removes either the first or the last element of the array What is the minimum number of operations Slavic has to perform such that the total sum of the array is equal to after performing all the operations In case the sum can t be obtained after any amount of operations you should output ,Note that the remaining array is a subarray of the original array There are many ways to approach the problem Here is one solution which the main solution uses Compute prefix sums on the array so we can find out the value of quickly Let s iterate through the left endpoint from to Afterwards we can binary search on the smallest value of such that since this sum is strictly increasing The time complexity is 
You are given a binary array of length You are allowed to perform one operation on it In an operation you can choose any element and flip it turn a into a or vice versa What is the maximum number of inversions the array can have after performing operation A binary array is an array that contains only zeroes and ones The number of inversions in an array is the number of pairs of indices such that and ,Let s find out how to count the number of binary inversions without flips This is the number of 1 s that appear before a 0 To do this iterate through the array and keep a running total k of the number of 1 s seen so far When we see a 0 increase the total inversion count by k since this 0 makes k inversions one for each of the 1 s before it Now let s see how to maximize the inversions Consider the flip 0 to 1 We claim that it is best to always flip the earliest 0 in the array It s never optimal to flip a later 0 since we have strictly fewer 0 s after it to form inversions Similarly we should flip the latest 1 in the array Now recalculate the answer for these two choices for flipping and pick the maximum The complexity is mathcal O n 
You have rectangles the th rectangle has height and width You are asked queries of the form For each query output the total area of rectangles you own that a rectangle of height and width while also a rectangle of height and width In other words print for such that and Also note that you rotate rectangles Please note that the answer for some test cases won t fit into 32 bit integer type so you should use at least 64 bit integer type in your programming language like for C ,Consider the 2D array with for all Increase by if there is an rectangle in the input Now for each query we need to find the sum of all in a rectangle with lower left corner at and upper right corner at This is the standard problem that can be solved with 2D prefix sums The time complexity is per testcase 
Timur has candies The th candy has a quantity of sugar equal to So by eating the th candy Timur consumes a quantity of sugar equal to Timur will ask you queries regarding his candies For the th query you have to answer what is the number of candies he needs to eat in order to reach a quantity of sugar or print if it s not possible to obtain such a quantity In other words you should print the minimum possible such that after eating candies Timur consumes a quantity of sugar of at least or say that no possible exists Note that he can t eat the same candy twice and queries are independent of each other Timur can use the same candy in different queries ,Let s solve the problem with just one query Greedily we should pick the candies with the most sugar first since there is no benefit to picking a candy with less sugar So the solution is as follows sort the candies in descending order and then find the prefix whose sum is This is per query which is too slow for us To speed it up notice that we just need to find a prefix sum at least So if we compute the prefix sums of the reverse sorted array we need to find the first element that is at least Since all elements of are positive the array of prefix sums is increasing Therefore you can binary search the first element This solves the problem in per query Total time complexity 
You are given a square grid with rows and columns Each cell contains either or In an operation you can select a cell of the grid and flip it from or Find the minimum number of operations you need to obtain a square that remains the same when rotated and The picture below shows an example of all rotations of a grid ,Let s rotate the grid by and and mark all cells that map to each other under these rotations For example for and grids mirror grid must have the following patterns the same letters denoting equal values In general we can rotate the grid by and and see which cells need to have equal values by seeing the positions which each cell maps to Now to solve the problem we consider each equal value each of the letters in the above figures independently and consider the minimum number of moves to make them all or all The answer is the total across all values See the implementation for better understanding The time complexity is per testcase 
Given an array consisting of elements find the maximum possible sum the array can have after performing the following operation Choose elements and flip both of their signs In other words choose an index such that and assign and ,We can notice that by performing any number of operations the parity of the count of negative numbers won t ever change Thus if the number of negative numbers is initially even we can make it equal to by performing some operations So for an even count of negative numbers the answer is the sum of the absolute values of all numbers since we can make all of them positive And if the count of negative numbers is odd we must have one negative number at the end We will choose the one smallest by absolute value and keep the rest positive for simplicity we consider as a negative number 
Timur has a stairway with steps The th step is meters higher than its predecessor The first step is meters higher than the ground and the ground starts at meters Timur has questions each denoted by an integer For each question you have to print the maximum possible height Timur can achieve by climbing the steps if his legs are of length Timur can only climb the th step if his legs are of length at least In other words for each step climbed Note that you should answer each question independently ,Let s compute the prefix sums of the array let Rephrasing the problem for each question containing an integer we need to find the largest such that are all at most and then output In other words Let s make the prefix maximums of the array let Then we need to find the largest such that which is doable using binary search since the array is non decreasing Once we find the index we simply need to output The time complexity is per testcase 
The array is given Its element is called special if there exists a pair of indices and such that In other words an element is called special if it can be represented as the sum of of an array no matter if they are special or not Print the number of special elements of the given array For example if and then the answer is is a special element since is a special element since is a special element since is a special element since is a special element since Please note that some of the elements of the array may be equal if several elements are equal and special then all of them should be counted in the answer ,The intended solution for this problem uses time and memory Firstly let s calculate for each from to where is the number of occurrences of in This part can be done in Then let s iterate over all segments of of length at least maintaining the sum of the current segment We can notice that we don t need sums greater than because all elements do not exceed So if the current sum does not exceed then add to the answer and set to prevent counting the same elements several times This part can be done in 
Given an array of positive integers with length determine if there exist three indices such that ends in the digit ,Since we only care about the last digit of the sum we can ignore all numbers other than the last digits of the elements of For example we can consider to be the same as Now note that if a number appears more than times in the array we can ignore all copies that occur more than times since our sum only involves three numbers For example we can consider to be the same as Using these observations note that there are only digits and each digit can occur at most times So we can always reduce the array to one of length Since is very small we can brute force all triples which runs quickly enough Time complexity 
For some binary string i e each character is either or all pairs of consecutive adjacent characters were written In other words all substrings of length were written For each pair substring of length the number of ones in it was calculated You are given three numbers the number of such pairs of consecutive characters substrings where the number of ones equals the number of such pairs of consecutive characters substrings where the number of ones equals the number of such pairs of consecutive characters substrings where the number of ones equals For example for the string the following substrings would be written Thus Your task is to restore suitable binary string from the given values It is guaranteed that at least one of the numbers is greater than Also it is guaranteed that a solution exists ,Consider case separately and print the sting of zeros or ones correspondingly Now our string has at least one pair or Let s form the pattern of length So all substrings with the sum are satisfied Now let s insert zeros before the first zero in this way we satisfy the substrings with the sum And then just insert ones before the first one in this way we satisfy the substrings with the sum 
You are given a room that can be represented by a grid There is a ball at position the intersection of row and column and it starts going diagonally in one of the four directions The ball is going down and right denoted by it means that after a step the ball s location goes from to The ball is going down and left denoted by it means that after a step the ball s location goes from to The ball is going up and right denoted by it means that after a step the ball s location goes from to The ball is going up and left denoted by it means that after a step the ball s location goes from to After each step the ball maintains its direction unless it hits a wall that is the direction takes it out of the room s bounds in the next step In this case the ball s direction gets flipped along the axis of the wall if the ball hits a corner both directions get flipped Any instance of this is called a The ball never stops moving In the above example the ball starts at and goes until it reaches the bottom wall then it bounces and continues in the direction After reaching the left wall the ball bounces and continues to go in the direction When the ball reaches the upper wall it bounces and continues in the direction After reaching the bottom right corner it bounces and continues in direction and so on Your task is to find how many bounces the ball will go through until it reaches cell in the room or report that it never reaches cell by printing Note that the ball first goes in a cell and only after that bounces if it needs to ,We can see that there are at most states the ball can be in because there are cells and states of direction We can simulate the bouncing process keeping count of the bounces until we arrive at the finish cell when we can output the answer or we arrive at a previously visited state and end up in a loop then we can output 1 Bonus Can you prove there are at most states for any given starting position 
There are candies put from left to right on a table The candies are numbered from left to right The th candy has weight Alice and Bob eat candies Alice can eat any number of candies from the left she can t skip candies she eats them in a row Bob can eat any number of candies from the right he can t skip candies he eats them in a row Of course if Alice ate a candy Bob can t eat it and vice versa They want to be fair Their goal is to eat the same total weight of candies What is the most number of candies they can eat in total ,We can solve the problem with a two pointers technique Let be the left pointer initially at and be the right pointer initially at Let s store Alice and Bob s current totals as and Let s iterate from the left to the right For each we should do the following Increase by Alice eats the th candy Move leftwards until Bob s total is at least Alice s total and update every time we move If the two pointers have crossed then both Alice and Bob took the same candy which is not possible So we should exit and output the current answer Otherwise if after this step we should update the current answer to be the value that is equal to Alice and Bob Both and move at most times in total so the solution runs in 
An L shape is a figure on gridded paper that looks like the first four pictures below An L shape contains exactly three shaded cells denoted by which can be rotated in any way You are given a rectangular grid Determine if it contains L shapes only where L shapes can t touch an edge or corner More formally Each shaded cell in the grid is part of exactly one L shape and no two L shapes are adjacent by edge or corner For example the last two grids in the picture above satisfy the condition because the two L shapes touch by corner and edge respectively ,The problem is mainly a tricky implementation problem Let s denote the of an L shape as the square in the middle the one that is side adjacent to two other squares Every elbow is part of exactly one L shape and every L shape has exactly one elbow Iterate through the grid and count the number of side adjacent neighbors they have If there is a cell with more than 2 or if there is a cell with exactly two neighbors on opposite sides then the answer is Otherwise if there are exactly 2 neighbors this cell is an elbow Mark all three cells of this L shape with a unique number say mark the first one you find with the second with and so on If you ever remark a cell that already has a number then two elbows are adjacent and you can output After all elbows are marked check if all shaded cells have a number If some don t then they are not part of an L shape so you can output Finally we should check that L shapes don t share edge or corner Just check for each number if it is only diagonally adjacent to other numbers equal to it or unshaded cells If it is diagonally adjacent to other unequal numbers then the answer is because two L shapes share an edge or corner then Otherwise the answer is There are many other solutions all of which are various ways to check the conditions The complexity is per testcase 
Given an array of length and an integer you are tasked to find any two numbers and such that For each appears in at least times i e or more array elements are equal to The value is maximized If no numbers satisfy the conditions output For example if and then for the first condition fails because does not appear at least times for the first condition holds because occurs at least times in and occurs at least times in for the first condition holds because occurs at least times in A pair of and for which the first condition holds and is maximal is ,Let s call a value if it appears at least times For example if and then good values are So we need to find the longest subarray of this array in which all values are consecutive For example the subarray is the answer because all values are good and the length of the array is longest There are many ways to do this For example we can see when the difference between two elements is more than and then break the array into parts based on that For instance You can also iterate from left to right and keep track of the size of the current array Time complexity 
There are quests If you complete the th quest you will gain coins You can only complete at most one quest per day However once you complete a quest you cannot do the same quest again for days For example if and you do quest on day then you cannot do it on day or but you can do it again on day You are given two integers and Find the maximum value of such that you can gain at least coins over days If no such exists output If can be arbitrarily large output ,Let s fix k and find the maximum number of coins we can get Here we can do a greedy solution at every step we should always take the most rewarding quest Intuitively it makes sense since doing more rewarding quests earlier allows us to do them again later If no quests are available we do nothing To implement this sort the quests in decreasing order and 0 index them On day i we should do quest i bmod k provided that this value is less than n This is because after every k days we cycle back to the first quest Thus we solved the problem for a fixed k in mathcal O d with mathcal O n log n precomputation to sort the array Now to solve the problem we can binary search on the answer since if some k works then all smaller k work The minimum value of k is 0 and the maximum value is n for larger k we won t be able to do the same quest multiple times anyways so it s useless to consider them If we find that k always goes towards the smaller end of our binary search and k 0 still fails we output If we find that k always goes towards the larger end of our binary search and k n still fails we output Otherwise just output k The overall time complexity is mathcal O n log n d log n It is not hard to improve the solution to mathcal O n log n Originally I proposed the problem this way but we ended up removing this part of the problem because the implementation of this solution was tricky enough 
Given an array you need to handle a total of updates and queries of two types for each index with update the value of to the sum of the digits of output ,Let denote the sum of the digits of The key observation is the following after the operation is applied to index thrice it won t change after any further operations The proof is provided at the bottom of the editorial So we only need to update if it s been updated at most times so far otherwise we can ignore it This allows us to do the following solution store the current active indices that is indices that have been updated times in a sorted list for example in C Then search for the smallest active index at least since the list is sorted we can do it in Afterwards update that index replace with remove it if it s no longer active and binary search for the next largest active index in the sorted list until we pass just output Although it looks like we take time for each update we actually only ever update each element of the array at most times so we will do no more than binary searches Therefore the time complexity is amortized To show this note that initially The maximum possible value of the sum of the digits of is achieved when So Now considering the numbers from to the one with maximum sum of digits is with Hence Finally considering the numbers from to the one with maximum sum of digits is so That is after three operations becomes a single digit Any further operations and it won t change any more 
Alperen has two strings and which are both initially equal to He will perform operations of two types on the given strings Append the string exactly times at the end of string In other words Append the string exactly times at the end of string In other words After each operation determine if it is possible to the characters of and such that is lexicographically smaller than Note that the strings change after performing each operation and go back to their initial states Simply speaking the lexicographical order is the order in which words are listed in a dictionary A formal definition is as follows string is lexicographically smaller than string if there exists a position such that and for all If no such exists then is lexicographically smaller than if the length of is less than the length of For example and where we write if is lexicographically smaller than ,First of all let s think about how we should rearrange the two strings in such a way that if that is ever possible It s always optimal to arrange s characters increasingly in lexicographic order and s characters decreasingly Since initially both and contain a character the first time receives any other letter than the answer will always be because that character will always be lexicographically larger than s first character which should be In the other case we know that doesn t have any other characters than so we can compare the string with multiple characters and we know that will be smaller if and only if it s only formed of s and has a smaller size than 
You are given an array Count the number of pairs of indices such that ,Call a pair if it satisfies the condition Let s split the inequality into three parts Note that if for any then it can t be an element of a good pair because it fails the first and third conditions So we can throw out all elements of the array satisfying For the remaining elements the first and third inequalities are already satisfied so we only have to count the number of pairs with Let s iterate through the array from the left to the right and make a list storing all that appear before Then for each count the number of less than by binary searching on the number of elements in the list less than Afterwards add to the end of the list Since we iterate from left to right the list will always remain sorted we insert the indices of elements which are increasing from left to right so the binary search will always work The time complexity is 
Given an array of length and an integer find the number of indices such that the subarray with length with length has the following property If you multiply the first element by the second element by and the st element by then this subarray is sorted in strictly increasing order More formally count the number of indices such that ,Note that is the same as since we can divide by This means that we only need to check whether for each pair of adjacent elements Let s consider as an example Note that and so if you multiply the first element by the second by and the third by the array is sorted So let s make a new array where if and otherwise Then we know that the whole chain of inequalities holds true if all values in a subarray of length in have all their values equal to For example if Say Then works since is sorted We can write this as and This is equivalent to since and since So the problem is equivalent to counting the number of subarrays of length in whose elements are all equal to There are many ways to do this For example you can compute prefix sums and then find the sum of all subarrays of length and count the number whose sum is The model solution uses a sliding window and updates the number of ones in the current subarray as we move from left to right Time complexity is 
Given an integer find any array of nonnegative integers less than such that the bitwise XOR of the elements on odd indices equals the bitwise XOR of the elements on even indices ,There are a lot of solutions to this problem Here I will describe one of them First we observe that having the XOR of even indexed numbers and odd indexed numbers equal is equivalent to having the XOR of all the elements equal to 0 Let s note with the XOR of all odd indexed numbers and the xor of all even indexed numbers Notice that the XOR of all the array equals if and only if a b So how do we generate such an array with XOR of all elements Our first instinct might be to arbitrarily generate the first numbers then set the last element as the XOR of the first ensuring that the total XOR is However we might have problems with the condition that all elements must be distinct Let s arbitrarily set the first so that they don t have the highest bit set and then the th number can be just The last number can be the XOR of the first XOR the th number you will be sure that the last number has not occurred in the first elements because they don t have the highest bit set while the last number must have the highest bit set But how do we know that the th number and the th number will not be equal This occurs only if the total XOR of the first numbers equals To fix this we can just choose a different arbitrary number in one of the spots For example my solution checks if the XOR of the numbers is If it is not great We can use the simple solution without any changes However if the XOR is I use the numbers in their place These two sequences have different XORs so it ensures that one of them always works 
There is a grid with rows and columns and three types of cells An empty cell denoted with A stone denoted with An obstacle denoted with the lowercase Latin letter All stones fall down until they meet the floor the bottom row an obstacle or other stone which is already immovable In other words all the stones just fall down as long as they can fall Simulate the process What does the resulting grid look like ,Note that the columns don t affect each other so we can solve for each column by itself For each column go from the bottom to the top and keep track of the row of the last obstacle seen call it Note that initially since we treat the floor as the th row of obstacles Whenever we see a new obstacle we should update Now if we ever see a stone we should move it to row since it will be one row above the last obstacle seen it will fall on top of it Afterwards we should also decrease by because if any future stones fall on top of it they will land on the row above this stone This solution works in We also accepted slower solutions that run in that simulate each stone falling 
There are chests The th chest contains coins You need to open all chests There are two types of keys you can use to open a chest a good key which costs coins to use a bad key which does not cost any coins but will halve all the coins in each unopened chest The halving operation to the nearest integer for each chest halved In other words using a bad key to open chest will do any key both good and bad breaks after a usage that is it is a one time use You need to use in total keys one for each chest Initially you have no coins and no keys If you want to use a good key then you need to buy it During the process you are allowed to go into debt for example if you have coin you are allowed to buy a good key worth coins and your balance will become coins Find the maximum number of coins you can have after opening all chests in order from chest to chest ,We will prove it is always optimal to use good keys for a prefix then only use bad keys Consider we have used a bad key then a good key by doing this we obtain coins If we switch and use a good key first the a bad key then we obtain this number is clearly bigger so we will never encounter a bad key before a good key in an optimal solution thus we will use a prefix of good keys then move on to using bad keys For every possible prefix of good keys we will calculate the coins we get at the end We do this by maintaining a variable with the prefix sum where we use the good keys and then calculate what we will get from the chests where we use bad keys Notice that because we halve all the chests when we use a bad key we only need to verify the next chests all chests after it will go to coins Final complexity 
You are given an array consisting of nonnegative integers Let s define the prefix OR array as the array where represents the bitwise OR operation In other words the array is formed by computing the of every prefix of You are asked to rearrange the elements of the array in such a way that its prefix OR array is lexicographically maximum An array is lexicographically greater than an array if in the first position where and differ ,Note that in this context denotes We can make the observation that only the first elements matter since after placing them optimally we can be sure all bits that could be set in the prefix OR would have already been set So we can brute force the optimal choice times we choose to add an element if it provides the largest new prefix OR value among all unused elements and then just add the rest of the unused elements 
You are given a weighted tree with vertices Recall that a tree is a connected graph without any cycles A weighted tree is a tree in which each edge has a certain weight The tree is undirected it doesn t have a root Since trees bore you you decided to challenge yourself and play a game on the given tree In a move you can travel from a node to one of its neighbors another node it has a direct edge with You start with a variable which is initially equal to When you pass through edge changes its value to where is the weight of the th edge Your task is to go from vertex to vertex but you are allowed to enter node if and only if after traveling to it the value of will become In other words you can travel to node only by using an edge such that Once you enter node the game ends and you win Additionally you can teleport at any point in time to any vertex except vertex You can teleport from any vertex even from Answer with if you can reach vertex from and otherwise Note that represents the bitwise XOR operation ,Let s ignore the teleporting and decide how to find the answer Note that we don t need to ever go over an edge more than once since going over an edge twice cancels out since for all In other words the only possible value of equals the of the edges on the unique path from to We can find it through a BFS from continuing to keep track of s as we move to each adjacent node and ing it by the weight of the corresponding edge as we travel across it Now let s include the teleport It means that we travel from then teleport to and go from for some nodes and Also we cannot pass on the path from Again note that the value of is fixed on each of the paths from and since there is a unique path between them Let be the of the first path and be the of the second Then we need So we need to find if there are two nodes such that the s from and to those nodes are the same To do this we can do our BFS from before but instead run one BFS from and another from and check if any two values are the same Make sure not to include nodes past while we look for on our BFS from The time complexity is 
A permutation of length is an array which contains every integer from to inclusive and moreover each number appears exactly once For example is a permutation of length For a given number find a permutation in which absolute difference that is the absolute value of difference of any two neighboring adjacent elements is between and inclusive Formally find such permutation that for each Print any such permutation for the given integer or determine that it does not exist ,If then there is no answer You can do some handwork to be sure Otherwise the answer exists and there is one simple way to construct it firstly let s put all odd integers into the answer in decreasing order then put and all other even numbers in increasing order To test that it always works you can run some kind of checker locally you can check all tests very fast in less than one second this may be very helpful sometimes 
You are given a rooted tree consisting of vertices numbered from to The root is vertex There is also a string denoting the color of each vertex if then vertex is black and if then vertex is white A subtree of the tree is called balanced if the number of white vertices equals the number of black vertices Count the number of balanced subtrees A is a connected undirected graph without cycles A is a tree with a selected vertex which is called the In this problem all trees have root The tree is specified by an array of parents containing numbers is the parent of the vertex with the number for all The parent of a vertex is a vertex that is the next vertex on a simple path from to the root The of a vertex is the set of all vertices that pass through on a simple path to the root For example in the picture below is in the subtree of because the simple path passes through Note that a vertex is included in its subtree and the subtree of the root is the entire tree The picture shows the tree for and The subtree at the vertex is balanced ,Let s run a dynamic programming from the leaves to the root For each vertex store the values of the number of balanced subtrees as well as the number of white and black vertices in it Then from a vertex we can count the total number of white vertices in its subtree as well as the black vertices in its subtree and update our total if they are equal Remember to include the color of the vertex itself in these counts The answer is the answer at the root Therefore the problem is solved in time 
Initially array contains just the number You can perform several operations in order to change the array In an operation you can select some subsequence of and add into an element equal to the sum of all elements of the subsequence You are given a final array Check if can be obtained from the initial array by performing some number possibly 0 of operations on the initial array A sequence is a subsequence of a sequence if can be obtained from by the deletion of several possibly zero but not all elements In other words select distinct indices and insert anywhere into a new element with the value equal to ,Firstly let s note that it doesn t matter in what order we add the elements to the array since if we can add an element in any position if it s possible to get the said elements of the array then we can obtain them in any order Now let s note that it s always optimal to obtain the needed elements in sorted order since we only use smaller values in order to obtain the current one so we will consider the array as sorted If the first element of the array isn t then we immediately know such an array doesn t exist Otherwise we can use dynamic programming for finding out if the remaining elements are obtainable Let s denote a boolean array which tells us whether sum is obtainable Initially since the first element is guaranteed to be We will go in increasing order of and if we calculated an element to be obtainable in the past we update all obtainable values with the new value We do this in by going through all sums and updating is true if it already was true or if was true and we add to that sum the new value The total time complexity of this solution is 
Consider the points on the number line There is a teleporter located on each of the points At point you can do the following Move left one unit it costs coin Move right one unit it costs coin Use a teleporter at point if it exists it costs coins As a result you teleport to point Once you use a teleporter you use it again You have coins and you start at point What s the most number of teleporters you can use ,It s easy to see that it s optimal to only move right or to use a portal once we are at it We can notice that when we teleport back the problem is independent of the previous choices We still are at point and have some portals left Thus we can just find out the individual cost of each portal sort portals by individual costs and take them from smallest to largest by cost as long as we can The cost of portal is since we pay to use it and need moves to get to it 
Initially array contains just the number You can perform several operations in order to change the array In an operation you can select some subsequence of and add into an element equal to the sum of all elements of the subsequence You are given a final array Check if can be obtained from the initial array by performing some number possibly 0 of operations on the initial array A sequence is a subsequence of a sequence if can be obtained from by the deletion of several possibly zero but not all elements In other words select distinct indices and insert anywhere into a new element with the value equal to ,Let s prove that for an array that was created by using a number of operations with a sum of elements we can add into any number Suppose that it is true that in the array with some length we introduce a number Then after introducing we can create using the initial elements of the array any number and using the element and some subset of the initial elements we can create any number and because we proved that for the new array of length we can still create any number between and Since it is true for the initial array we can use induction and this fact to prove it is true for all arrays So we just need to verify if our array satisfies this condition We should sort the array and check for each if 
Consider the points on the number line There is a teleporter located on each of the points At point you can do the following Move left one unit it costs coin Move right one unit it costs coin Use a teleporter at point if it exists it costs coins As a result you can choose whether to teleport to point or point Once you use a teleporter you use it again You have coins and you start at point What s the most number of teleporters you can use ,Please also refer to the tutorial for the easy version If we are not at the first taken portal the problem is still independent for each portal but this time the cost of a portal is since we can come to a portal either from point or point So we again sort the portals by their costs But this time we need to make sure that the first taken portal is taken from point so we will iterate over all portals and check the maximum amount of portals we can take if we use it as the first one We can check this using prefix sums over the minimum cost array and binary searching checking if the amount of considered portals taken doesn t exceed the number of coins we initially have we also have to deal with the case when the portal we are considering is included both times as the initial portal and in the minimum cost prefix 
Marian is at a casino The game at the casino works like this Before each round the player selects a number between and After that a dice with faces is rolled so that a random number between and appears If the player guesses the number correctly their total money is doubled else their total money is halved Marian predicted the future and knows all the numbers that the dice will show in the next rounds He will pick three integers and He will play rounds rounds between and inclusive In each of these rounds he will guess the same number At the start before the round he has dollar Marian asks you to determine the integers and such that he makes the most money at the end Note that during halving and multiplying there is no rounding and there are no precision errors So for example during a game Marian could have money equal to etc any value of where is an integer of any sign ,There are several solutions Here is one If we fix the value of then let s make a new array as follows if and otherwise Then the total amount of money earned will just be so we only need to maximize In other words we need to find the maximum sum of a subarray This is a standard problem that can be solved using segment tree Note that we need to iterate over all values of of which there are possibilities So we have to update elements of the segment tree times and query once for each which means overall the solution runs in 
Let denote the bitwise AND operation and denote the bitwise OR operation You are given an array of length and a non negative integer You can perform operations on the array of the following type Select an index and replace with where is any integer between and In other words in an operation you can choose an index and set the th bit of to Output the maximum possible value of after performing operations ,The optimal strategy is to greedily take the highest bit we have enough operations to set in every array element To do this we maintain a count for each bit with the number of elements that have it set already The cost to set the th bit will be We go from the highest bit to the lowest If we have enough operations left we set the bit subtract its cost from the operations and move to the next lower bit If we don t have enough operations we move on to the next lower bit and don t modify the operations We stop once we processed bit The time complexity is 
 and the sum of over all test cases does not exceed A is a row of equal segments numbered to in order There are two terminals one above the other You are given an array of length For all there should be a straight wire from some point on segment of the top terminal to some point on segment of the bottom terminal You can t select the endpoints of a segment For example the following pictures show two possible wirings if and A occurs when two wires share a point in common In the picture above crossings are circled in red What is the number of crossings there can be if you place the wires optimally ,Let s look at two wires from and If there can never be any intersection If there has to be an intersection If it is possible that there is an intersection or not depending on how we arrange the wires on the bottom terminal In the last case if there are multiple wires that go to the same segment we can make all pairs of them cross by arranging the points in which they hit this segment from right to left For example if then we can make all pairs of segments cross as shown Since we want to maximize the number of intersections we just need to count the number of pairs such that You can brute force all pairs in 
 and the sum of over all test cases does not exceed A is a row of equal segments numbered to in order There are two terminals one above the other You are given an array of length For all there should be a straight wire from some point on segment of the top terminal to some point on segment of the bottom terminal You can t select the endpoints of a segment For example the following pictures show two possible wirings if and A occurs when two wires share a point in common In the picture above crossings are circled in red What is the number of crossings there can be if you place the wires optimally ,Read the solution of the easy version We want to count the number of pairs such that and This is a standard problem and we can do this we can use a segment tree or BIT for example Insert the from to and then for each count the number of using a BIT It is also related to the problem of counting inversions so you can solve it using a modification of merge sort Either way the solution is 
You are standing at the point on a coordinate line Your goal is to reach the point In one minute you can move by or by to the left or to the right i e if your current coordinate is it can become or Note that the new coordinate can become negative Your task is to find the number of minutes required to get from the point to the point You have to answer independent test cases ,If the answer is we can t get so we can move by to the right and by to the left If or the answer is obviously Otherwise the answer is always We can t get the answer less than this value because we need at least moves to get to the point greater than or equal to and we can always get this answer by the recurrence 
You are playing a variation of game Initially you have a multiset of integers Every integer in this multiset is a power of two You may perform any number possibly zero operations with this multiset During each operation you choose two integers from remove them from and insert the number equal to their sum into For example if and you choose integers and then the multiset becomes You win if the number belongs to your multiset For example if you can win as follows choose and your multiset turns into Then choose and your multiset turns into and you win You have to determine if you can win this game You have to answer independent queries ,It s obvious that we don t need elements that are larger than If the sum of the remaining elements is greater than or equal to 2048 then the answer is and otherwise It s true because for getting a integer that wasn t in the multiset initially we first need to get integer 
You are given a string of length consisting of characters and or Let be the number of occurrences of string in as a Analogically is the number of occurrences of in as a In one step you can choose any index and replace with character or What is the minimum number of steps you need to make to achieve The number of occurrences of string in as substring is the number of indices such that substring is equal to For example since there are two indices where and where ,Let s look at the first and the last characters of Note that if where then is always equal to It can be proved for example by induction if consists of equal characters then if has a structure like or then Otherwise there is at least one character in the middle that equal to and So we can split string in and Both these string has by induction so our string also has As a result if then the answer is and we print the string untouched Otherwise we replace either or and get the desired string It also can be proved that if then 
You are given a string consisting of characters is even For each from to is one of or A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and and and are not You want to find a string that consists of characters such that is a regular bracket sequence if for some and then In other words you want to replace all occurrences of with the same type of bracket then all occurrences of with the same type of bracket and all occurrences of with the same type of bracket Your task is to determine if such a string exists ,There are two key observations First a regular bracket sequence always starts with an opening bracket and ends with a closing one Thus the first letter of corresponds to an opening bracket and the last letter corresponds to a closing bracket If they are the same then the answer is Second a regular bracket sequence has exactly opening and closing brackets Thus we can check if the counts of the remaining letter and the first letter of the string or the remaining letter and the last letter of the string make it in total If neither of them do then the answer is If both do then that means that there are occurrences of the remaining letter so it doesn t matter what bracket it is assigned to Finally after the assignment is complete check if the resulting string is a regular bracket sequence For that you have to check if on any prefix the number of opening brackets is greater or equal to the number of closing brackets And also if the total number of opening and closing brackets is the same Overall complexity per testcase 
Polycarp has spent the entire day preparing problems for you Now he has to sleep for at least minutes to feel refreshed So he has just fallen asleep and his first alarm goes off in minutes Every time Polycarp wakes up he decides if he wants to sleep for some more time or not If he s slept for less than minutes in total then he sets his alarm to go off in minutes after it is reset and spends minutes to fall asleep again Otherwise he gets out of his bed and proceeds with the day If the alarm goes off while Polycarp is falling asleep then he resets his alarm to go off in another minutes and tries to fall asleep for minutes again You just want to find out when will Polycarp get out of his bed or report that it will never happen ,Let s handle some cases Firstly if then Polycarp wakes up rested enough immediately so is the answer Otherwise what does Polycarp do He sets alarm to go off in minutes and falls asleep in minutes Thus he spends minutes sleeping Notice that if is non positive then Polycarp always resets his alarm without sleeping So for that case the answer is Finally if Polycarp resets his alarm times then he ends up with minutes of sleep in total and ends up spending minutes of time We know that should be greater or equal to and should be the smallest possible Thus the smallest possible integer is equal to And the answer is Overall complexity per testcase 
 heroes fight against each other in the Arena Initially the th hero has level Each minute a fight between two different heroes occurs These heroes can be chosen arbitrarily When two heroes of equal levels fight nobody wins the fight When two heroes of different levels fight the one with the higher level wins and his level increases by The winner of the tournament is the first hero that wins in at least fights A is a hero such that there exists a sequence of fights that this hero becomes the winner of the tournament Calculate the number of among heroes ,If for some hero no other hero is weaker than then the th hero cannot win any fights and is not a possible winner Otherwise the hero is a possible winner he may fight the weakest hero times and be declared the winner So the solution to the problem is calculating the number of minimum elements in the array since all other elements denote possible winners of the tournament 
You are given two arrays of length and You can perform the following operation any number of times Choose integer index Swap and What is the minimum possible sum in other words you can achieve after performing several possibly zero operations ,Let s look at our arrays and Note that for any position such that we can always fix it by swapping positions from to In that case contribution from all won t change contribution of pair will decrease and contribution from all won t change again since we swapped all of them It means that we already can use the following algorithm while exists such that just swap all from to This solution works for per test that should be enough But we can optimize our approach by realizing that we can instead of searching each time just go from to and fix pairs one by one if then swap with next if then swap with and so on In such way solution works in 
You are given an array which is sorted in non decreasing order Find three indices such that and it is to construct a non degenerate triangle a triangle with nonzero area having sides equal to and for example it is possible to construct a non degenerate triangle with sides and but impossible with sides and If it is impossible to find such triple report it ,The triangle with side is degenerate if So we have to maximize the length of the longest side and minimize the total length of other sides Thus if then we answer if otherwise the answer is 
You are given a string consisting of letters each letter is either or The letters in the string are numbered from to is a continuous substring of letters from index to of the string inclusive A string is called balanced if the number of letters in it is equal to the number of letters For example strings and are balanced and strings and are not Find any non empty balanced substring of string Print its and If there is no such substring then print ,Any non empty balanced string contains at least one letter and at least one letter That implies that there s an adjacent to a somewhere in that string Both strings and are balanced Thus any balanced string contains a balanced substring of length So the solution is to check all pairs of adjacent letters If there exists a pair of different ones print it Overall complexity per testcase 
The game of Berland poker is played with a deck of cards of which are jokers players play this game is divisible by At the beginning of the game each player takes cards from the deck so each card is taken by exactly one player The player who has the maximum number of jokers is the winner and he gets the number of points equal to where is the number of jokers in the winner s hand and is the maximum number of jokers among all other players If there are two or more players with maximum number of jokers all of them are winners and they get points Here are some examples If one player gets jokers and plain card and another player gets jokers and plain cards then the first player is the winner and gets points Two players get plain cards and the other two players get jokers so both of them are winners and get points If the first player gets jokers the second player gets joker and plain cards and the third player gets jokers and plain card then the first player is the winner and he gets point Since there are no jokers everyone gets jokers everyone is a winner and everyone gets points Given and calculate the maximum number of points a player can get for winning the game ,There are many different ways to solve this problem The easiest one in my opinion is to iterate on the number of jokers the winner has let it be and the number of jokers the runner up has let it be Then the following conditions should be met the winner doesn t have less jokers than the runner up the number of jokers in the winner s hand does not exceed the number of cards in his hand the number of jokers for these two players does not exceed the total number of jokers it is possible to redistribute remaining jokers among other players so that they have at most jokers Iterating on and then checking these constraints gives us a solution It is possible to get a constant time solution using some greedy assumptions and math the first player should get as many jokers as possible while the remaining jokers should be evenly distributed among other players 
You are given array Find the subsegment with maximum arithmetic mean in floating point numbers i e without any rounding If there are many such subsegments find the one ,There is a property of arithmetic mean and the equality holds when Obviously we can always gain maximum arithmetic mean equal to by taking single maximum element from Considering the property above we need to take only maximum elements in our subsegment that s why we need to find the longest subsegment consisting only of maximum elements 
Polycarp has just invented a new binary protocol for data transmission He is encoding positive integer decimal number to binary string using following algorithm Each digit is represented with number of characters equal to the value of that digit for it is zero ones Digits are written one by one in order corresponding to number and separated by single character Though Polycarp learnt how to encode the numbers he has no idea how to decode them back Help him calculate the decoded number ,Let s decode the number digit by digit starting from the leftmost When you meet in the string increase the value of the current digit For print current digit and proceed to the next one Don t forget to print the last digit when the string is over Overall complexity 
Recently Luba bought a very interesting book She knows that it will take seconds to read the book Luba wants to finish reading as fast as she can But she has some work to do in each of next days The number of seconds that Luba has to spend working during th day is If some free time remains she can spend it on reading Help Luba to determine the minimum number of day when she finishes reading ,Let s read the book greedily On th day Luba will read for seconds Subtract value for each day from until becomes less or equal to zero That will be the day Luba finishes the book Overall complexity 
Recently Polycarp noticed that some of the buttons of his keyboard are malfunctioning For simplicity we assume that Polycarp s keyboard contains buttons one for each letter of the Latin alphabet Each button is either working fine or malfunctioning To check which buttons need replacement Polycarp pressed some buttons in sequence and a string appeared on the screen When Polycarp presses a button with character one of the following events happened if the button was working correctly a character appeared at the end of the string Polycarp was typing if the button was malfunctioning characters appeared at the end of the string For example suppose the buttons corresponding to characters and are working correctly and the button corresponding to is malfunctioning If Polycarp presses the buttons in the order then the string he is typing changes as follows You are given a string which appeared on the screen after Polycarp pressed some buttons Help Polycarp to determine which buttons are working correctly for sure that is this string could not appear on the screen if any of these buttons was malfunctioning You may assume that the buttons don t start malfunctioning when Polycarp types the string each button either works correctly throughout the whole process or malfunctions throughout the whole process ,If a key malfunctions each sequence of presses of this key gives a string with even number of characters So if there is a substring consisting of odd number of equal characters such that it cannot be extended to the left or to the right without adding other characters then it could not be produced by presses of button if was malfunctioning The only thing that s left is to find all maximal by inclusion substrings consisting of the same character 
Buses run between the cities and the first one is at 05 00 AM and the last one departs not later than at 11 59 PM A bus from the city departs every minutes and arrives to the city in a minutes and a bus from the city departs every minutes and arrives to the city in a minutes The driver Simion wants to make his job diverse so he counts the buses going towards him Simion doesn t count the buses he meet at the start and finish You know the time when Simion departed from the city to the city Calculate the number of buses Simion will meet to be sure in his counting ,Consider the time interval when Simion will be on the road strictly between cities Let s iterate over the oncoming buses Let be the time interval when the oncoming bus will be strictly between two cities If the intersection of that intervals is not empty than Simion will count that bus 
You are playing a very popular game called Cubecraft Initially you have one stick and want to craft torches One torch can be crafted using Hopefully you ve met a very handsome wandering trader who has two trade offers exchange stick for sticks you lose stick and gain sticks exchange sticks for coal you lose sticks and gain coal During one trade you can use of these two trade offers You can use each trade offer any number of times you want to in any order Your task is to find the minimum number of trades you need to craft at least torches The answer always exists under the given constraints You have to answer independent test cases ,You need additional sticks to get torches sticks for units of coal and also sticks required to craft torches and you get sticks per one trade To buy this number of sticks you need trades And also you need additional trades to turn some sticks into coals And the final answer is 
Alex Bob and Carl will soon participate in a team chess tournament Since they are all in the same team they have decided to practise really hard before the tournament But it s a bit difficult for them because chess is a game for two players not three So they play with each other according to following rules Alex and Bob play the first game and Carl is spectating When the game ends the one who lost the game becomes the spectator in the next game and the one who was spectating plays against the winner Alex Bob and Carl play in such a way that there are no draws Today they have played games and for each of these games they remember who was the winner They decided to make up a log of games describing who won each game But now they doubt if the information in the log is correct and they want to know if the situation described in the log they made up was possible that is no game is won by someone who is spectating if Alex Bob and Carl play according to the rules Help them to check it ,This task is about pure implementation Maintain the number of current spectator and check if he doesn t win With knowledge of current winner and current spectator you can easily get the third player by formula just the sum of all numbers without the known ones Overall complexity 
You are given a chessboard of size It is guaranteed that The chessboard is painted like this Some cells of the board are occupied by the chess pieces Each cell contains no more than one chess piece It is known that the total number of pieces equals to In one step you can move one of the pieces one cell to the left or to the right You cannot move pieces beyond the borders of the board You also cannot move pieces to the cells that are already occupied Your task is to place all the pieces in the cells of the same color all the pieces must occupy only the black cells or only the white cells after all the moves are made ,Firstly let s sort our array pay the attention that there are elements in this array not Then for 0 indexed array answer will be equal to where is an absolute value of difference between and 
Berland annual chess tournament is coming Organizers have gathered chess players who should be divided into two teams with people each The first team is sponsored by BerOil and the second team is sponsored by BerMobile Obviously organizers should guarantee the win for the team of BerOil Thus organizers should divide all players into two teams with people each in such a way that the first team always wins Every chess player has its rating It is known that chess player with the greater rating always wins the player with the lower rating If their ratings are equal then any of the players can win After teams assignment there will come a drawing to form pairs of opponents in each pair there is a player from the first team and a player from the second team Every chess player should be in exactly one pair Every pair plays once The drawing is totally random Is it possible to divide all players into two teams with people each so that the player from the first team in every pair wins of the results of the drawing ,Let s sort the input array in non decreasing order Now we should take the first players to the first team and the last players to the second team That will guarantee that every member of the first team has greater or equal rating than every member of the second team Now the only thing left is to check if all ratings in the first teams differ from all the ratings in the second team if some are equal then in sorted order 
Luba has to do chores today th chore takes units of time to complete It is guaranteed that for every the condition is met so the sequence is sorted Also Luba can work really hard on some chores She can choose not more than any chores and do each of them in units of time instead of Luba is very responsible so she has to do all chores and now she wants to know the minimum time she needs to do everything Luba cannot do two chores simultaneously ,Since it is better to do exactly chores in time And since we need to minimize total time we need to spend it s better to speed up the longest chores So the answer is 
You are given an array of elements you must make it a co prime array in as few moves as possible In each move you can insert any positive integral number you want not greater than in any place in the array An array is co prime if any two adjacent numbers of it are co prime In the number theory two integers and are said to be co prime if the only positive integer that divides both of them is ,Note that we should insert some number between any adjacent not co prime elements On other hand we always can insert the number 
Codehorses has just hosted the second Codehorses Cup This year the same as the previous one organizers are giving T shirts for the winners The valid sizes of T shirts are either or from to followed by or For example sizes are valid and are not There are winners to the cup for both the previous year and the current year Ksenia has a list with the T shirt sizes printed for the last year cup and is yet to send the new list to the printing office Organizers want to distribute the prizes as soon as possible so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter Ksenia can t remove or add letters in any of the words What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one That means two lists are considered equal if and only if the number of occurrences of any string is the same in both lists ,At first let s remove all coinciding entries of both lists The most convinient way is to use map hashmap but it s not the only option Now divide entries into categories by their length You can notice that it takes exactly one second to remove an entry in each category to make it equal to an entry of the opposing list Thus the answer is Overall complexity or 
In Berland there are two types of coins having denominations of and burles Your task is to determine whether it is possible to represent burles in coins i e whether there exist non negative integers and such that ,Note that 2 coins with denomination k can be replaced with k coins with denomination 2 So if the answer exists then there is also such a set of coins where there is no more than one coin with denomination k Therefore it is enough to iterate through the number of coins with denomination k from 0 to 1 and check that the remaining number is non negative and even i e it can be represented as some number of coins with denomination 2 
There is a bag containing colored balls There are different colors of balls numbered from to There are balls of color in the bag The total amount of balls in the bag is odd e g is odd In one move you can choose two balls and take them out of the bag At some point all the remaining balls in the bag will have the same color That s when you can t make moves anymore Find any possible color of the remaining balls ,Let s prove that the color with the maximum value of is one of the possible answers Let the color have the maximum value of if there are several such colors choose any of them Let s keep taking the balls of two different colors out of the bag without touching the balls of color for as long as possible After such operations two cases exist In one case only balls of color are left then everything is fine In other case there are balls of color and some color let be the remaining number of balls of this color Since initially was one of the maximums However the number of remaining balls is odd which means and Therefore we can keep taking the balls of colors and until only balls of color are left 
Berland Football Cup starts really soon Commentators from all over the world come to the event Organizers have already built commentary boxes regional delegations will come to the Cup Every delegation should get the of the commentary boxes If any box is left unoccupied then the delegations will be upset If is not divisible by it is impossible to distribute the boxes to the delegations at the moment Organizers can build a new commentary box paying burles and demolish a commentary box paying burles They can both build and demolish boxes arbitrary number of times each time paying a corresponding fee It is allowed to demolish all the existing boxes What is the minimal amount of burles organizers should pay to satisfy all the delegations i e to make the number of the boxes be divisible by ,Notice that you need to check just two numbers the closest one less or equal to and the closest one greater than Distances to them are and respectively Now you should multiply the first result by the second result by and compare the products Overall complexity 
You are given two very long integers leading zeroes are allowed You should check what number or is greater or determine that they are equal The input size is very large so don t use the reading of symbols one by one Instead of that use the reading of a whole line or token As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in Don t use the function in instead of it use the function ,Note that solutions in Java with BigInteger class or input function in Python2 will fail in this problem The reason is the next standard objects stores numbers not in decimal system and need a lot of time to convert numbers from decimal system Actually they are working in where is the legth of the number To solve this problem you should simply read the numbers to strings and add leading zeroes to the shorter one until the numbers will be of the same length After that you should simply compare them alphabetically 
Monocarp is playing a computer game Now he wants to complete the first level of this game A level is a rectangular grid of rows and columns Monocarp controls a character which starts in cell at the intersection of the st row and the st column Monocarp s character can move from one cell to another in one step if the cells are adjacent by side and or corner Formally it is possible to move from cell to cell in one step if and Obviously it is prohibited to go outside the grid There are traps in some cells If Monocarp s character finds himself in such a cell he dies and the game ends To complete a level Monocarp s character should reach cell at the intersection of row and column Help Monocarp determine if it is possible to complete the level ,At first glance it seems like a graph problem And indeed this problem can be solved by explicitly building a graph considering cells as the vertices and checking that there is a safe path from start to finish via DFS BFS DSU any other graph algorithm or data structure you know But there s a much simpler solution Since there are only two rows in a matrix it s possible to move from any cell in the column to any cell in column if they are both safe of course It means that as long as there is at least one safe cell in each column it is possible to reach any column of the matrix and the cell as well It s easy to see that if this condition is not met there exists a column with two unsafe cells and this also means that this column and columns to the right of it are unreachable So the problem is reduced to checking if there is a column without any unsafe cells To implement this you can read both rows of the matrix as strings let these strings be and and check that there is a position such that both and are equal to 
There are three sticks with integer lengths and You are asked to break exactly one of them into two pieces in such a way that both pieces have positive strictly greater than length the total length of the pieces is equal to the original length of the stick it s possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides A square is also considered a rectangle Determine if it s possible to do that ,First the condition about being able to construct a rectangle is the same as having two pairs of sticks of equal length Let s fix the stick that we are going to break into two parts Now there are two cases The remaining two sticks can be the same In that case you can break the chosen stick into equal parts to make the second equal pair of sticks Note however that the stick should have an even length because otherwise the length of the resulting parts won t be integer The remaining two sticks can be different In that case the chosen stick should have the length equal to their total length because the only way to make two pairs of equal sticks is to produce the same two sticks as the remaining ones Overall complexity per testcase 
There s a chessboard of size rooks are placed on it in such a way that no two rooks occupy the same cell no two rooks attack each other A rook attacks all cells that are in its row or column Is it possible to move rook you can choose which one to move into a different cell so that no two rooks still attack each other A rook can move into any cell in its row or column if no other rook stands on its path ,First note that is always less than or equal to If there were at least rooks on the board at least two of them would share a row or a column by pigeonhole principle If then there is always at least one free row and at least one free column You can move any rook into that row or column Otherwise all rows and columns are taken so any move will make two rooks share a row or a column which is prohibited Thus if then it s Otherwise it s Overall complexity per testcase Alternatively you could check every rook and every possible move Overall complexity per testcase 
You play your favourite game yet another time You chose the character you didn t play before It has points of strength and points of intelligence Also at start the character has free experience points you can invest either in strength or in intelligence by investing one point you can either raise strength by or raise intelligence by Since you d like to make some fun you want to create a jock character so it has more strength than intelligence points resulting strength is than the resulting intelligence Calculate the number of different character builds you can create for the purpose of replayability if you must Two character builds are different if their strength and or intellect are different ,Let and be number of free points that we invest in the strength and intelligence respectively It s obvious that since we must spend all free points From the other side we must make Now we can expess and put it in the inequality Since must be non negative we can get We can use or write the correct ceiling function that works with negative numerator or use one hack and magic and get with usual integer division Let s denote this value as Since all integer values from are good for us so the number of pairs is equal to P S Let me explain how to prove that is equal to P P S Interesting fact the formula above works for all positive and thats why it works in our case even though can be negative 
Hideo Kojima has just quit his job at Konami Now he is going to find a new place to work Despite being such a well known person he still needs a CV to apply for a job During all his career Hideo has produced games Some of them were successful some were not Hideo wants to remove several of them possibly zero from his CV to make a better impression on employers As a result there should be no unsuccessful game which comes right after successful one in his CV More formally you are given an array of zeros and ones Zero corresponds to an unsuccessful game one to a successful one Games are given in order they were produced and Hideo can t swap these values He should remove some elements from this array in such a way that no zero comes right after one Besides that Hideo still wants to mention as much games in his CV as possible Help this genius of a man determine the maximum number of games he can leave in his CV ,The statement literally asks for the longest subsequence which looks like Let s find out how many zeroes will be in this sequence and then take all ones which come after the last zero On each step take the next zero from the beginning of the sequence and count ones after it Update answer with the maximum value You can precalc number of ones on suffix with partial sums but it was not necessary in this task Overall complexity naively or with partial sums 
You are given a non degenerate triangle a non degenerate triangle is a triangle with positive area The vertices of the triangle have coordinates and You want to draw a straight line to cut the triangle into Furthermore the line you draw should be Can you draw the line to meet all the constraints Here are some suitable ways to draw the line However these ways to draw the line are not suitable the first line cuts the triangle into a triangle and a quadrangle the second line doesn t cut the triangle at all the third line is neither horizontal nor vertical ,The line we draw must go through a triangle s vertex otherwise two sides of the triangle are split and one of the resulting parts becomes a quadrilateral So we need to check if it is possible to make a horizontal or vertical cut through a vertex A horizontal cut is possible if all y coordinates are different we can draw it through a vertex with the median y coordinate a vertical cut is possible if all x coordinates are different we can draw it through a vertex with the median x coordinate So all we need to check is the following pair of conditions all x i are different all y i are different 
Adilbek was assigned to a special project For Adilbek it means that he has days to run a special program and provide its results But there is a problem the program needs to run for days to calculate the results Fortunately Adilbek can optimize the program If he spends is a non negative integer days optimizing the program he will make the program run in days is the ceiling function The program cannot be run and optimized simultaneously so the total number of days he will spend is equal to Will Adilbek be able to provide the generated results in no more than days ,At first let s note that if is integer and and are non negative then So instead of looking at we can consider It s easier since the function is more common function and it can be proven that it s concave upward It means that this function has a unique minimum and moreover we can calculate it has minimum value in and Since the ceiling function is monotonically increasing so we can assume that for all So we can just iterate from to and check the unequation The total complexity is equal to There is a simple optimization because of the monotone ceiling we can prove that we need to check only and 
You received a notebook which is called This notebook has infinite number of pages A rule is written on the last page huh of this notebook It says You have to write names in this notebook during consecutive days During the th day you have to write exactly names You got scared of course you got scared who wouldn t get scared if he just receive a notebook which is named with a some strange rule written in it Of course you decided to follow this rule When you calmed down you came up with a strategy how you will write names in the notebook You have calculated that each page of the notebook can contain exactly names You will start writing names from the first page You will write names on the current page as long as the limit on the number of names on this page is not exceeded When the current page is over you turn the page Note that you turn the page when it ends it doesn t matter if it is the last day or not If after some day the current page still can hold at least one name during the next day you will continue writing the names from the current page Now you are interested in the following question how many times will you turn the page during each day You are interested in the number of pages you will turn each day from to ,In this problem all we need is to maintain the variable which will represent the number of names written on the current page Initially this number equals zero The answer for the th day equals This value represents the number of full pages we will write during the th day After the answering we need to set where operation is taking modulo 
Ivan recently bought a detective book The book is so interesting that each page of this book introduces some sort of a mystery which will be explained later The th page contains some mystery that will be explained on page Ivan wants to read the whole book Each day he reads the first page he didn t read earlier and continues to read the following pages one by one until all the mysteries he read about are explained and clear to him Ivan stops if there does not exist any page such that Ivan already has read it but hasn t read page After that he closes the book and continues to read it on the following day from the next page How many days will it take to read the whole book ,Solution is just some implementation simulate algorithm given in the legend maintaining maximum over all on prefix and breaking when the maximum becomes smaller than index of the next page 
Mikhail walks on a 2D plane He can go either up or right You are given a sequence of Mikhail s moves He thinks that this sequence is too long and he wants to make it as short as possible In the given sequence moving up is described by character and moving right is described by character Mikhail can replace any pair of consecutive moves or with a diagonal move described as character After that he can go on and do some other replacements until there is no pair of consecutive moves or left Your problem is to print the minimum possible length of the sequence of moves after the replacements ,Let s iterate over all characters of the string from left to right excluding last character Suppose is a position of the current element of the string If increase answer by and increase by else just increase by 
Mishka got a six faced dice It has integer numbers from to written on its faces all numbers on faces are different so this is an usual dice Mishka wants to get exactly points by rolling his dice The number of points is just a sum of numbers written at the topmost face of the dice for all the rolls Mishka makes Mishka doesn t really care about the number of rolls so he just wants to know number of rolls he can make to be able to get exactly points for them Your task is to print this number It is that at least one answer exists Mishka is also very curious about different number of points to score so you have to answer queries ,It is enough to print for each query where is divided by rounded down 
You are given a sequence consisting of digits from to You have to divide it into segments segment is a consecutive sequence of elements in other words you have to place separators between some digits of the sequence in such a way that and if the resulting division will be represented as an integer numbers sequence then each next element of this sequence will be than the previous one More formally if the resulting division of the sequence is where is the number of element in a division then for each from to the condition using comparing it means that the integer representations of strings are compared should be satisfied For example if then you can divide it into parts and it will be suitable division But if you will divide it into parts then it will be bad division because If then you can divide it into parts but not into parts Your task is to find suitable division for each of the independent queries ,Since we just want to make two numbers such that the first number is smaller than the second our best bet is to use only the first digit for the first number and the rest of the digits for the second number Note that since the numbers can have up to 300 digits we shouldn t actually evaluate the second number Instead since the digits only include 1 through 9 we can handle that case by checking the number of digits Code 49002957 
There are students who have taken part in an olympiad Now it s time to award the students Some of them will receive diplomas some wiil get certificates and others won t receive anything Students with diplomas and certificates are called But there are some rules of counting the number of diplomas and certificates The number of certificates must be times greater than the number of diplomas The number of must i e not be greater than half of It s possible that there are no You have to identify the maximum possible number of according to these rules Also for this case you have to calculate the number of students with diplomas the number of students with certificates and the number of students who are not ,Let be the number of students with diplomas and students with certificates is always So the total number of winners is It should not exceed so the maximum value for will be hit in where is Overall complexity 
You have a large electronic screen which can display up to decimal digits The digits are displayed in the same way as on different electronic alarm clocks each place for a digit consists of segments which can be turned on and off to compose different digits The following picture describes how you can display all decimal digits As you can see different digits may require different number of segments to be turned on For example if you want to display you have to turn on segments of the screen and if you want to display all segments of some place to display a digit should be turned on You want to display a really large integer on the screen Unfortunately the screen is bugged no more than segments can be turned on simultaneously So now you wonder what is the greatest integer that can be displayed by turning on no more than segments Your program should be able to process different test cases ,First of all we don t need to use any digits other than and If we use any other digit it consists of or more segments so it can be replaced by two s and the number will become greater For the same reason we don t need to use more than one if we have two we can replace them with three s Obviously it is always optimal to place before So our number is either a sequence of s or a and a sequence of s We should use only if is odd because if is even it will decrease the number of digits in the result 
Let s denote the Manhattan distance between two points with coordinates and with coordinates as For example the distance between two points with coordinates and is You are given two points and The point has coordinates the point has coordinates Your goal is to find a point such that both coordinates of are non negative integers without any rounding without any rounding Find any point that meets these constraints or report that no such point exists ,There is a solution in but in fact a solution that checks all points with coordinate from to and coordinate from to is fast enough There s no need to check any other points since implies that point is on one of the shortest paths between and 
You are given an integer You have to change the minimum number of digits in it in such a way that the resulting number and If there are multiple ways to do it print any of them If the given number is already divisible by leave it unchanged ,A lot of different solutions can be written in this problem The model solution relies on the fact that every th integer is divisible by and it means that there is always a way to change the last digit of or leave it unchanged so that the result is divisible by So if is already divisible by we just print it otherwise we change its last digit using some formulas or iteration on its value from to 
You are given a string consisting of lowercase Latin letters A substring of string is a continuous segment of letters from For example is a substring of and is not The length of the substring is the number of letters in it Let s call some string of length if and only if there is no letter to appear strictly more than times For example strings and are and strings and are not Your task is to find substring of string or report that there is none Note that it is not required to maximize or minimize the length of the resulting substring ,Notice that the string of two distinct letter is already diverse That implies that the answer is if and only if all the letters in the string are the same Otherwise you can check all pairs of adjacent letters in Overall complexity 
Let s denote a step ladder as the following structure exactly wooden planks of which two planks of length the base of the ladder planks of length the steps of the ladder Note that neither the base planks nor the steps planks are required to be equal For example ladders and are correct step ladders and ladder is a correct step ladder On the first picture the lengths of planks are for the base and for the step On the second picture lengths are for the base and for the step On the third picture lengths are for the base and for the steps You have planks The length of the th planks is You don t have a saw so you can t cut the planks you have Though you have a hammer and nails so you can assemble the improvised ladder from the planks The question is what is the maximum number such that you can choose some subset of the given planks and assemble a step ladder using them ,Since all planks have length at least 1 so we can take any n 2 planks as steps So all we need is to maximize the length of base planks We can take the first and second maximum as base then the answer is minimum among second maximum 1 and n 2 
You have a board represented as a grid with cells The first cells on the first row and first cells on the second row are colored in white All other cells are colored in black You have white dominoes tiles both cells are colored in white and black dominoes tiles both cells are colored in black You can place a white domino on the board if both board s cells are white and not occupied by any other domino In the same way you can place a black domino if both cells are black and not occupied by any other domino Can you place all dominoes on the board if you can place dominoes both horizontally and vertically ,We can prove that if we have white cells on the board then we can place any white dominoes as long as The proof is the following if let s place one domino at position otherwise let s place domino at position Then we can solve the placement of dominoes in cells in the first row and cells of the second row recursively or analogically and At the end either all dominoes are placed or and If or then since then or we successfully placed all dominoes If and then we possibly need to place one domino more and we can place it vertically We can prove that we can place any dominoes as long as in the same manner As a result all we need to check is that and 
There are two rival donut shops The first shop sells donuts at retail each donut costs dollars The second shop sells donuts only in bulk box of donuts costs dollars So if you want to buy donuts from this shop then you have to buy the smallest number of boxes such that the total number of donuts in them is greater or equal to You want to determine two values how many donuts can you buy so that they are strictly cheaper in the first shop than in the second shop how many donuts can you buy so that they are strictly cheaper in the second shop than in the first shop If any of these values doesn t exist then that value should be equal to If there are multiple possible answers then print any of them ,At first notice that if there exists a value for the second shop then the value divisible by also exists For any you can round it up to the nearest multiple of That won t change the price for the second shop and only increase the price for the first shop You can also guess that if there exists a value for the first shop then the value with modulo also exists exactly donut on top of some number of full boxes Following the same logic the second shop needs an entire new box and the first shop needs only an extra donut So let s take a look at the smallest values of two kinds this value is valid for the second shop if one box is cheaper than donuts in the first shop Otherwise no matter how many boxes will you take they will never be cheaper than the corresponding number of donuts this value is valid for the first shop if one donut is cheaper than one box in the second shop Apply the same idea otherwise no value for the first shop is valid Overall complexity per testcase 
The knight is standing in front of a long and narrow hallway A princess is waiting at the end of it In a hallway there are three doors a red door a green door and a blue door The doors are placed one after another however possibly in a different order To proceed to the next door the knight must first open the door before Each door can be only opened with a key of the corresponding color So three keys a red key a green key and a blue key are also placed somewhere in the hallway To open the door the knight should first pick up the key of its color The knight has a map of the hallway It can be transcribed as a string consisting of six characters denoting red green and blue doors respectively denoting red green and blue keys respectively Each of these six characters appears in the string exactly once The knight is standing at the beginning of the hallway on the left on the map Given a map of the hallway determine if the knight can open all doors and meet the princess at the end of the hallway ,The necessary and sufficient condition is the following for each color the key should appear before the door Necessary is easy to show if there is a key after a door this door can t be opened Sufficient can be shown the following way If there are no closed doors left the knight has reached the princess Otherwise consider the first door the knight encounters He has a key for this door so he opens it We remove both the key and the door from the string and proceed to the case with one less door Overall complexity 
You are playing a new computer game in which you have to fight monsters In a dungeon you are trying to clear you met three monsters the first of them has health points the second has health points and the third has To kill the monsters you can use a cannon that when fired deals damage to the selected monster Every th i e shots with numbers etc cannon shot is and deals damage to monsters not just one of them If some monster s current amount of health points is it can t be targeted by a regular shot and does not receive damage from an shot You want to pass the dungeon beautifully i e kill all the monsters with the same shot i e after some shot the health points of each of the monsters should become equal to Each shot must hit a monster i e each shot deals damage to at least one monster ,Note that for every shots we deal a total of units of damage Since we want to kill all the monsters with a shot which index is divisible by let s denote the number of shots as In this case a total of units of damage must be dealt hence if the result of the division is not an integer then there is no answer Since each monster will receive at least units of damage with shots the health of each monster must be at least If the two conditions described above are met then the remaining shots can always be distributed in the desired way 
You had positive integers arranged For each pair of neighboring numbers and and and and and you wrote down are the numbers in the pair equal or not Unfortunately you ve lost a piece of paper with the array Moreover you are afraid that even information about equality of neighboring elements may be inconsistent So you are wondering is there any array which is consistent with information you have about equality or non equality of corresponding pairs ,Let s look at a group of it s easy to see that each such a group is equal to the same number Now let s look at how these groups are distributed on the circle If there are no then all are just equal to each other It s okay If there is exactly one then from one side all of them are still in one group so they should be equal but from the other side one pair should have different values It s contradiction If there are more than one then all numbers are divided in several groups with different values It s okay As a result array exists as long as the number of isn t 
You are given a string consisting of lowercase Latin letters Every letter appears in it no more than twice Your task is to rearrange the letters in the string in such a way that for each pair of letters that appear exactly twice the distance between the letters in the pair is the same You are not allowed to add or remove letters It can be shown that the answer always exists If there are multiple answers print any of them ,Let s consider a very special case of equal distances What if all distances were equal to It implies that if some letter appears exactly twice both occurrences are placed right next to each other That construction can be achieved if you sort the string for example first right down all letters a then all letters b and so on If a letter appears multiple times all its occurrences will be next to each other just as we wanted Overall complexity or per testcase 
You are given a string Each character is either or You want all s in the string to form a contiguous subsegment For example if the string is or then all s form a contiguous subsegment and if the string is or then this condition is not met You may erase some possibly none s from the string What is the minimum number of s that you have to erase ,Let s find the first and the last position of characters denote them as and respectively Since the can t delete characters all characters between and will remain So we have to delete all characters between and 
You are given string Let s call any largest sequence of consecutive symbols without symbols comma and semicolon For example there are four in string A word can be empty for example the string contains three empty words separated by You should find all in the given string that are nonnegative INTEGER numbers without leading zeroes and build by them new string String should contain all that are numbers separating them by the order of numbers should remain the same as in the string By all other you should build string in the same way the order of numbers should remain the same as in the string Here strings are INTEGER numbers but and are not For example for the string the string would be equal to and string would be equal to ,This is a technical problem You should do exactly what is written in problem statement 
Let s call a positive integer if it has only one non zero digit For example are extremely round integers are not You are given an integer You have to calculate the number of extremely round integers such that ,There are many ways to solve this problem The most naive one iterating through all numbers from to in each test case and checking if they are extremely round fails since it is but you can optimize it by noticing that extremely round numbers are rare So for example we can iterate through all numbers from to once remember which ones are extremely round store them into an array and while answering the test case only check the numbers from the array we have created There is also a solution in per test case with a formula try to invent it yourself 
Four players participate in the playoff tournament The tournament is held according to the following scheme the first player will play with the second and the third player with the fourth then the winners of the pairs will play in the finals of the tournament It is known that in a match between two players the one whose skill is greater will win The skill of the th player is equal to and all skill levels are pairwise different i e there are no two identical values in the array The tournament is called if the two players with the highest skills meet in the finals Determine whether the given tournament is ,It is easier to determine the case when the players with the maximum skills will not meet in the finals It means that they met in the semifinals and in the other semifinals both players are weaker It s easy to check this case with the following formula or 
According to rules of the Berland fashion a jacket should be fastened by but not necessarily it should be the last one Also if the jacket has only one button it should be fastened so the jacket will not swinging open You are given a jacket with buttons Determine if it is fastened in a right way ,In this problem you should simply check the conditions from the problem statement 
You are given a range of positive integers from to Find such a pair of integers that and divides If there are multiple answers print any of them You are also asked to answer independent queries ,Print and Firstly the smallest value of you can have is and if any greater value fits then fits as well Secondly the absolute difference between and increases when you increase thus lessening the possibility of both numbers fitting into the range Overall complexity 
Let s call an array consisting of positive greater than integers if the following condition is held for every from to either or at least one of the numbers and exists in the array as well For example the array is beautiful for the number exists in the array for the number exists in the array for the condition holds the array is beautiful for the condition holds for every other number the number exists in the array the array is not beautiful for neither nor exists in the array and the array is not beautiful for neither nor exists in the array and the array is beautiful for the number exists in the array for the condition holds for the number exists in the array You are given a positive integer Find the minimum possible size of a beautiful array with the sum of elements equal to ,The maximum sum we can construct with elements is so we need at least elements to construct the sum equal to Let s show how to express with exactly elements Let By taking we achieve a sum of using elements is not less than and not greater than since and Thus we can just add to our array and the sum becomes exactly So the solution is to find the minimum such that 
You are given an integer and an integer In one step you can do one of the following moves decrease by divide by if is divisible by For example if and you can do the following steps You are asked to calculate the minimum number of steps to reach from ,It s always optimal to divide by whenever it s possible since dividing by equivalent to decreasing by The only problem is that it s too slow to just subtract from each time since in the worst case we can make operations Consider case and But if we d look closer then we can just replace times of subtract with one subtraction of And to make is divisible by we should make subtractions 
You are given a set of integer points on a Cartesian plane Points are numbered from to inclusive Let be the th point The coordinate of the point equals The coordinate of the point equals zero initially Thus initially The given points are vertices of a plot of a piecewise function The th piece of the function is the segment In one move you can increase the coordinate of any point with odd coordinate i e such points are by Note that the corresponding segments also change For example the following plot shows a function for i e number of points is in which we increased the coordinate of the point three times and coordinate of the point one time Let the area of the plot be the area below this plot and above the coordinate axis OX For example the area of the plot on the picture above is 4 the light blue area on the picture above is the area of the plot drawn on it Let the height of the plot be the maximum coordinate among all initial points in the plot i e points The height of the plot on the picture above is 3 Your problem is to say which minimum possible height can have the plot consisting of vertices and having an area equal to Note that it is unnecessary to minimize the number of moves It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding ,It is easy to see that the area of the plot is the sum of areas of all triangles in this plot Each move increases area by one We cannot obtain the answer less than but we always can obtain such an answer 
The th grade student Gabriel noticed a caterpillar on a tree when walking around in a forest after the classes The caterpillar was on the height cm from the ground On the height cm on the same tree hung an apple and the caterpillar was crawling to the apple Gabriel is interested when the caterpillar gets the apple He noted that the caterpillar goes up by cm per hour by day and slips down by cm per hour by night In how many days Gabriel should return to the forest to see the caterpillar get the apple You can consider that the day starts at am and finishes at pm Gabriel s classes finish at pm You can consider that Gabriel noticed the caterpillar just after the classes at pm Note that the forest is magic so the caterpillar can slip down under the ground and then lift to the apple ,Let s consider three cases in this case the caterpillar will get the apple on the same day so the answer is The first condition is false and in this case the caterpillar will never get the apple because it can t do that on the first day and after each night it will be lower than one day before If the first two conditions are false easy to see that the answer equals to 
Maxim wants to buy some games at the local game shop There are games in the shop the th game costs Maxim has a wallet which can be represented as an array of integers His wallet contains bills the th bill has value Games in the shop are ordered from left to right Maxim tries to buy game in that order When Maxim stands at the position in the shop he takes the first bill from his wallet if his wallet is empty then he proceeds to the next position immediately and tries to buy the th game using this bill After Maxim tried to buy the th game he leaves the shop Maxim buys the th game if and only if the value of the first bill which he takes from his wallet is greater or equal to the cost of the th game If he successfully buys the th game the first bill from his wallet disappears and the next bill becomes first Otherwise Maxim leaves the first bill in his wallet and proceeds to the next game For example for array and array the following process takes place Maxim buys the first game using the first bill its value is the bill disappears after that the second bill with value becomes the first one in Maxim s wallet then Maxim doesn t buy the second game because the same with the third game then he buys the fourth game using the bill of value the third bill becomes the first one in Maxim s wallet and buys the fifth game using the bill of value Your task is to get the number of games Maxim will buy ,Let s keep the variable which will represent the number of games Maxim buy Initially Assume that arrays and are 0 indexed Then let s iterate over all and if and make So will be the answer after this cycle 
Alice and Bob play a game Alice has cards the th of them has the integer written on it Bob has cards the th of them has the integer written on it On the first turn of the game chooses one of his her cards and puts it on the table plays it On the second turn chooses one of his her cards and plays it On the third turn chooses one of his her cards and plays it and so on the players take turns and each player has to choose one of his her cards with greater integer than the card played by the other player on the last turn If some player cannot make a turn he she loses For example if Alice has cards with numbers and Bob has cards with numbers the game may go as follows Alice can choose any of her cards She chooses the card with integer and plays it Bob can choose any of his cards with number greater than He chooses a card with integer and plays it Alice can choose any of her cards with number greater than She chooses the card with integer and plays it Bob can choose any of his cards with number greater than He chooses a card with integer and plays it Alice can choose any of her cards with number greater than but she has no such cards so she loses Both Alice and Bob play You have to answer two questions who wins if Alice is the first player who wins if Bob is the first player ,Let the maximum card among all cards be If only one player has a card of value of then he she can win by playing it on the first turn or on the second turn the opponent won t be able to respond with any of their cards Otherwise if both players have a card with value the player who plays this card earlier wins the game So in this case the winner is the player who makes the first turn 
Monocarp is playing a computer game He s going to kill monsters the th of them has health Monocarp s character has two spells either of which he can cast an arbitrary number of times possibly zero and in an arbitrary order choose exactly two alive monsters and decrease their health by choose a single monster and kill it When a monster s health becomes it dies What s the minimum number of spell casts Monocarp should perform in order to kill all monsters ,The first spell looks pretty weak compared to the second spell Feels like you almost always replace one with another Let s show that you can totally avoid casting the spell of the first type twice or more on one monster Let the two first spell casts be and for some monsters and You can replace them by a cast of the second spell on and a cast of the first spell on That would deal even more damage to and the same amount to and The number of casts doesn t change Thus it only makes sense to use the first spell on monsters with health Calculate the number of them kill the full pairs of them with the first spell and use the second spell on the remaining monsters Overall complexity per testcase 
Luba thinks about watering her garden The garden can be represented as a segment of length Luba has got buckets the th bucket allows her to water some continuous subsegment of garden of length each hour Luba has to choose of the buckets in order to water the garden as fast as possible as mentioned above each hour she will water some continuous subsegment of length if she chooses the th bucket Help her to determine the minimum number of hours she has to spend watering the garden It is guaranteed that Luba can always choose a bucket so it is possible water the garden See the examples for better understanding ,In this problem we just need to find maximum divisor of that belongs to array Let s call it Then we need to print 
You have a garland consisting of colored light bulbs the color of the th light bulb is Initially all the light bulbs are turned off Your task is to turn all the light bulbs on You can perform the following operation any number of times select a light bulb and switch its state turn it on if it was off and turn it off if it was on The only restriction on the above operation is that you can apply the operation to a light bulb only if the previous operation was applied to a light bulb of a different color the first operation can be applied to any light bulb Calculate the minimum number of operations to turn all the light bulbs on or report that this is impossible ,Note that there are only a few configuration classes and Let s discuss each of them If all bulbs are of the same color then it is impossible to turn all the bulbs on because after you switch one light bulb it is impossible to turn the others on If there is a color with bulbs then it is impossible to turn all the bulbs on in operations which means there is a bulb that turns on turns off and then turns on again i e the answer is at least operations And there is a sequence of exactly operations such an example was shown in the problem notes For configurations like and it is enough to turn on the color bulbs not in a row i e in order for the first case and for the second one So the answer for such configurations is If all the bulbs are of different colors then nothing prevents you from turning them all on in operations 
Grandma Laura came to the market to sell some apples During the day she sold all the apples she had But grandma is old so she forgot how many apples she had brought to the market She precisely remembers she had buyers and each of them bought exactly half of the apples she had at the moment of the purchase and also she gave a half of an apple to some of them as a gift if the number of apples at the moment of purchase was odd until she sold all the apples she had So each buyer took some integral positive number of apples but maybe he didn t pay for a half of an apple if the number of apples at the moment of the purchase was odd For each buyer grandma remembers if she gave a half of an apple as a gift or not The cost of an apple is the number is even Print the total money grandma should have at the end of the day to check if some buyers cheated her ,Consider the process from the end The last buyer will always buy a half of an apple and get a half for free so the last string always is halfplus After that each buyer increases the number of apples twice and also maybe by one So we simply have the binary presentation of the number of apples from the end To calculate the answer we should simply restore that value from the end and also calculate the total money grandma should have 
There is a field of size Each cell of this field can either contain grass or be empty The value is if the cell contains grass or otherwise In one move you can choose and and cut all the grass in this row and this column In other words you choose the row and the column then you cut the grass in all cells and all cells for all from to After you cut the grass from a cell it becomes empty i e its value is replaced by Your task is to find the minimum number of moves required to cut the grass in all non empty cells of the field i e make all zeros You have to answer independent test cases ,If there is no grass on the field the answer is If the whole field is filled with grass the answer is because there always will be one cell that we can t clear with one move Otherwise the answer is This is because if the cell is empty we can just choose other row than and other column than and clear three other cells in one move 
Several days ago you bought a new house and now you are planning to start a renovation Since winters in your region can be very cold you need to decide how to heat rooms in your house Your house has rooms In the th room you can install at most heating radiators Each radiator can have several sections but the cost of the radiator with sections is equal to burles Since rooms can have different sizes you calculated that you need at least sections in total in the th room For each room calculate the minimum cost to install at most radiators with total number of sections not less than ,Let s denote the number of sections in the th radiator as Let s prove that in the optimal answer Proof by contradiction suppose we have and in the answer let s move from to and check The answer is not optimal contradiction Finally there is the only way to take with And it s to take elements with value and elements with 
Ivan s classes at the university have just finished and now he wants to go to the local CFK cafe and eat some fried chicken CFK sells chicken chunks in small and large portions A small portion contains chunks a large one chunks Ivan wants to eat exactly chunks Now he wonders whether he can buy exactly this amount of chicken Formally Ivan wants to know if he can choose two non negative integers and in such a way that small portions and large ones contain exactly chunks Help Ivan to answer this question for several values of ,There are lots of different approaches to this problem For example you could just iterate on the values of and from to and check if 
You have an image file of size consisting of pixels Each pixel can have one of different colors denoted by lowercase Latin letters You want to recolor some of the pixels of the image In one move you can choose pixels and paint them into some other color What is the minimum number of moves you have to make in order to fulfill your goal ,There are some solutions based on case analysis but in my opinion the most elegant one is the following Let s pick a color with the maximum possible number of pixels and repaint all other pixels into it We will try to pick all pixels of some other color and repaint them in one operation and we can ignore the constraint that we can repaint no more than pixels since we will never need to repaint or pixels in one operation So the number of operations is just the number of colors other than the one we chosen or just where is the number of different colors in the image To calculate this we can use a set or an array of size where we mark which colors are present 
There is a chess board of size The rows are numbered from to the columns are numbered from to Let s call a cell if a knight placed in that cell can t move to any other cell on the board Recall that a chess knight moves two cells in one direction and one cell in a perpendicular direction Find any cell on the board If there are no such cells print any cell on the board ,Let s consider some cases If at least one of or are then all cells are isolated A knight can t move one in a perpendicular direction If at least one of or are at least then the knight always has at least one move No matter where you place it it can move two cells along the greater of the dimensions and move one in a perpendicular direction because it s at least Three cases are left and For all of these cases the middle cell is isolated That cell is Since it doesn t matter which cell you print in the first two cases you can always print Overall complexity per testcase Alternatively you can check every possible cell Iterate over a cell and check all eight possible knight moves from it If none are inside the board the cell is isolated Overall complexity per testcase 
Consider the infinite sequence of integers The sequence is built in the following way at first the number is written out then the numbers from to then the numbers from to then the numbers from to and so on Note that the sequence contains numbers not digits For example number first appears in the sequence in position the elements are numerated from one Find the number on the th position of the sequence ,Let s decrease by one Now let s determine the block with the th number To do that let s at first subtract from then subtract then subtract and so on until we got negative The number of subtractions will be the number of the block and the position in the block will be the last nonnegative number we will get 
The math faculty of Berland State University has suffered the sudden drop in the math skills of enrolling students This year the highest grade on the entrance math test was 8 Out of 100 Thus the decision was made to make the test easier Future students will be asked just a single question They are given a sequence of integer numbers each number is from to and for each valid The th number represents a type of the th figure circle isosceles triangle with the length of height equal to the length of base square The figures of the given sequence are placed somewhere on a Cartesian plane in such a way that th figure is inscribed into the th one each triangle base is parallel to OX the triangle is oriented in such a way that the vertex opposite to its base is at the top each square sides are parallel to the axes for each from to figure has the maximum possible length of side for triangle and square and maximum radius for circle The task is to calculate the number of points not necessarily with integer coordinates where figures touch The trick is however that the number is sometimes infinite But that won t make the task difficult for you will it So can you pass the math test and enroll into Berland State University ,Firstly let s find out when the answer is infinite Obviously any point of intersection is produced by at least a pair of consecutive figures Take a look at every possible pair and you ll see that only square inscribed in triangle and vice verse produce infinite number of points in intersection The other cases are finite From now we assume that initial sequence has no 2 and 3 next to each other Basically it s all triangles and squares separated by circles If the task was to count all pairs of intersecting figures the solution will be the following Square next to circle gives 4 points triangle next to circle gives 3 points Unfortunately the task asked for distinct points Notice that there is a single subsegment which can produce coinciding points square circle triangle So you have to find each triplet 3 1 2 and subtract their count from the sum Overall complexity 
There s a chip in the point of the coordinate plane In one operation you can move the chip from some point to some point if the Euclidean distance between these two points is an i e is integer Your task is to determine the minimum number of operations required to move the chip from the point to the point ,Note that the answer does not exceed because the chip can be moved as follows Obviously in this case both operation are valid It remains to check the cases when the answer is or The answer is only if the destination point is and the answer is if is integer 
Johny likes numbers and very much Now Johny wants to find the smallest integer greater than so it is divisible by the number ,We should find minimal so Easy to see that To learn more about floor ceil functions I reccomend the book of authors Graham Knuth Patashnik Concrete Mathematics There is a chapter there about that functions and their properties 
You are given two integers and You should create an array of such that the sum is divisible by and maximum element in is minimum possible What is the minimum possible maximum element in ,Let s denote as the sum of array From one side since should be divisible by then we can say From other side since all are positive then It s quite obvious that the smaller the smaller maximum so we need to find the smallest that Then Now we now that and we need to represent it as with maximum minimized It s easy to prove by contradiction that maximum Moreover we can always construct such array that its sum is equal to and the maximum element is equal to As a result the answer is where 
Given a positive integer find integers not necessary distinct such that all these integers are strictly greater than and their product is equal to ,There are many approaches to this problem You can for example factorize store all multipliers in a list and while size of this list is greater than take any two elements of this list and replace them with their product If the initial size of this list is less than then answer is 
The only king stands on the standard chess board You are given his position in format where is the column from a to h and is the row from 1 to 8 Find the number of moves permitted for the king Check the king s moves here https en wikipedia org wiki King chess ,Easy to see that there are only three cases in this problem If the king is in the corner of the board the answer is If the king is on the border of the board but not in a corner then the answer is Otherwise the answer is 
Let be the minimum positive integer that is divisible by both and For example You are given two integers and Find two integers and such that and ,Suppose we have chosen and as the answer and is not a divisor of Since belongs to we could have chosen and instead So if the answer exists there also exists an answer where is a divisor of If then there is no pair such that and Otherwise and is the answer 
Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online Now players from all over the world can try his level All levels in this game have two stats to them the number of plays and the number of clears So when a player attempts the level the number of plays increases by If he manages to finish the level successfully then the number of clears increases by as well so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears Polycarp is very excited about his level so he keeps peeking at the stats to know how hard his level turns out to be So he peeked at the stats times and wrote down pairs of integers where is the number of plays at the th moment of time and is the number of clears at the same moment of time i e the order of given pairs is exactly the same as Polycarp has written down Between two consecutive moments of time Polycarp peeked at the stats many players but possibly zero could attempt the level Finally Polycarp wonders if he hasn t messed up any records and all the pairs are correct If there could exist such a sequence of plays and clears respectively that the stats were exactly as Polycarp has written down then he considers his records correct Help him to check the correctness of his records For your convenience you have to answer multiple independent test cases ,Let s use the fact that initially the level has plays and clears Call the differences before the previous stats and the current ones and The stats are given in chronological order so neither the number of plays nor the number of clears should decrease i e and Finally should be greater or equal to It s easy to show that if players pass the level successfully and players just try the level then such deltas are achieved So in implementation it s enough to check these three conditions between the consecutive pieces of data including the initial Overall complexity 
You are given an array Some element of this array is a iff it is strictly less than both of its neighbours that is and Also the element can be called iff it is strictly greater than its neighbours that is and Since and have only one neighbour each they are neither local minima nor local maxima An element is called a iff it is either local maximum or local minimum Your task is to calculate the number of local extrema in the given array ,Iterate over indices from to and check if at least one of given local extremum conditions holds Overall complexity 
Monocarp wrote down two numbers on a whiteboard Both numbers follow a specific format a positive integer with zeros appended to its end Now Monocarp asks you to compare these two numbers Can you help him ,First let s say that appending the number with zeros is the same as multiplying it by The given numbers are so large that they can t fit into any reasonable integer type Even if you use a language with unlimited length integers python for example or store the numbers in strings you should still face the time limit issue So let s learn to shrink the numbers a bit Note that the result of the comparison of two numbers doesn t change if you divide both numbers by the same positive number So we can keep dividing both numbers by until one of them is not divisible anymore Let s also ignore the trailing zeros in and and leave them as is If the first number is appended with zeros and the second numbers is appended with zeros we can subtract from both values effectively dividing both numbers by This way one of the numbers becomes short enough to fit into an integer type because it has and is only up to The other number might still be large enough However if it s really large we can instantly say that it s larger than another one Say if its is at least This number it at least and the other number is at most Otherwise we can calculate this number as well and compare the values normally Overall complexity per testcase 
Apart from having lots of holidays throughout the year residents of Berland also have whole years Year is considered if it has no more than non zero digit in its number So years 100 40000 5 are and 12 3001 and 12345 are not You are given current year in Berland Your task is to find how long will residents of Berland wait till the next year ,Notice that the next lucky year always looks like first digit of the current 1 10 number of digits of the current 1 It holds also for numbers starting with 9 it will be 10 10 number of digits 1 The answer is the difference between the next lucky year and current year 
An array is called if it contains element which is equal to the If the array is not ugly it is For example the array is ugly the element is equal to the array is ugly the element the second one is equal to the array is beautiful so there is no element which is equal to the sum of all elements before it You are given an array such that You have to the elements of in such a way that the resulting array is beautiful Note that you are not allowed to insert new elements or erase existing ones you can only change the order of elements of You are allowed to keep the array unchanged if it is beautiful ,If we put the maximum in the array on the first position then for every element starting from the third one the sum of elements before it will be greater than it since that sum is greater than the maximum value in the array So the only element that can make our array ugly is the second element We need to make sure that it is not equal to the first element Let s put the maximum element on the first position the minimum element on the second position and then fill the rest of the array arbitrarily The only case when it fails is when the maximum element is equal to the minimum element and it s easy to see that if the maximum is equal to the minimum then the first element of the array will be equal to the second element no matter what and the array cannot become beautiful So the solution is to check if the maximum is different from the minimum and if it is so put them on the first two positions and the order of remaining elements does not matter Note that the given array is sorted so the minimum is the first element the maximum is the last element 
You got a job as a marketer in a pet shop and your current task is to boost sales of cat food One of the strategies is to sell cans of food in packs with discounts Suppose you decided to sell packs with cans in a pack with a discount and some customer wants to buy cans of cat food Then he follows a greedy strategy he buys packs with a discount then he wants to buy the remaining cans one by one But customers are greedy in general so if the customer wants to buy cans one by one and it happens that he decides to buy the whole pack of cans instead of buying cans It makes you as a marketer happy since the customer bought more than he wanted initially You know that each of the customers that come to your shop can buy any number of cans from to inclusive Can you choose such size of pack that each customer buys more cans than they wanted initially ,Note that if then exists such that and obviously a customer who wants to buy cans won t buy more than he wants That s why and we can rephrase our task as finding such that The longer the segment is the better and the maximum we can take is As a result we need to check that 
You are given matrix with rows and columns filled with zeroes You should put ones in it in such a way that the resulting matrix is symmetrical with respect to the main diagonal the diagonal that goes from the top left to the bottom right corner and is lexicographically maximal One matrix is lexicographically greater than the other if the first different number in the first different row from the top in the first matrix is greater than the corresponding number in the second one If there exists no such matrix then output ,Let s construct matrix from top to bottom from left to right At current step we consider position Look at contents of cells and If number of zeroes in them doesn t exceed then let s fill those cells with ones and decrease by this number If isn t equal to in the end of algorithm then there is no answer Overall complexity 
You are given a string consisting of lowercase Latin letters You have to remove i e zero or one character of this string in such a way that the string you obtain will be lexicographically smallest among all strings that can be obtained using this operation String is than string if and or there exists a number such that and and For example is smaller than is smaller than is smaller than ,By the definition of lexicographical comparing we can see that if we can remove one character we always have to do it Besides we have to remove the character from the leftmost position such that and or from the position if there is no such 
String can be called if it consists of characters and and there are no redundant leading zeroes Here are some examples You are given a string You can perform two different operations on this string swap any pair of adjacent characters for example replace with for example Let be such a number that is its binary representation string is less than some other string iff Your task is to find the minimum string that you can obtain from the given one using the operations described above You can use these operations any number of times in any order or even use no operations at all ,If then the answer is equal to Otherwise answer will be equal to where is the count of the zeroes in the given string i e the answer is the binary string of length in which the first character is one and the other characters are zeroes 
An array is if both of the following two conditions meet there are and elements in the array equal to its minimum there are and elements in the array equal to its maximum For example the array has elements equal to its minimum st rd and th and elements equal to its maximum th and th Another example the array has elements equal to its minimum and elements equal to its maximum Your task is to calculate the possible number of elements in a array ,Firstly since we are interested in minimum possible size of the array we don t need any elements other than minimums and maximums So the array has at most distinct elements Now there are many possible solutions The simplest one is to iterate on the number of minimums let this be and maximums let this be If the number of minimums is equal to the number of maximums then the array should have all elements as both its minimums and maximums so its length should be otherwise it should be We can iterate on all possible pairs and find the best result over all of them A solution in is possible if you see that you only have to consider and as the number of minimums maximums or check if the segments and intersect in 
You are given an array of integer numbers Find the distance between two closest nearest minimums in it It is guaranteed that in the array a minimum occurs at least two times ,This task can be done by one array traversal Maintain current minimum value position of the last occurrence of current minumum distance between two occurrences of Now for each if then do For do In the end will be the global minimum of array and will keep the closest its occurrences Overall complexity 
There are cities situated along the main road of Berland Cities are represented by their coordinates integer numbers All coordinates are pairwise distinct It is possible to get from one city to another only by bus But all buses and roads are very old so the Minister of Transport decided to build a new bus route The Minister doesn t want to spend large amounts of money he wants to choose two cities in such a way that the distance between them is minimal possible The distance between two cities is equal to the absolute value of the difference between their coordinates It is possible that there are multiple pairs of cities with minimal possible distance so the Minister wants to know the quantity of such pairs Your task is to write a program that will calculate the minimal possible distance between two pairs of cities and the quantity of pairs which have this distance ,At first let s notice that if there exists such triple and that then and Thus we can sort all numbers and check only adjacent ones There are exactly of such pairs The only thing left is to find minimal distance of all pairs and count pairs with that distance Overall complexity 
Polycarp is sad New Year is coming in few days but there is still no snow in his city To bring himself New Year mood he decided to decorate his house with some garlands The local store introduced a new service this year called Build your own garland So you can buy some red green and blue lamps provide them and the store workers will solder a single garland of them The resulting garland will have all the lamps you provided put in a line Moreover no pair of lamps of the same color will be adjacent to each other in this garland For example if you provide red green and blue lamps the resulting garland can look like this being the red green and blue color respectively Note that it s ok to have lamps of the same color on the ends of the garland However if you provide say red green and blue lamps then the store workers won t be able to build any garland of them Any garland consisting of these lamps will have at least one pair of lamps of the same color adjacent to each other Note that the store workers should use all the lamps you provided So Polycarp has bought some sets of lamps and now he wants to know if the store workers can build a garland from each of them ,Let r le g le b if it is not the case do some swaps If b r g 1 then at least two blue lamps will be adjacent so there is no solution Otherwise the answer can be easily constucted Place all blue lamps in a row Then place red lamps one between the first and the second blue lamp one between the second and the third and so on Then place all green lamps one between the b 1 th blue lamp and the b th one between the blue lamps with numbers b 2 and b 1 and so on Since r g ge b 1 there is at least one non blue lamp between each pair of blue lamps If g b we didn t place all green lamps we can place the remaining one before all other lamps the same with r b So if we swap l g and b in such a way that r le g le b we only have to check that b le r g 1 
Recently a new building with a new layout was constructed in Monocarp s hometown According to this new layout the building consists of three types of apartments three room five room and seven room apartments It s also known that each room of each apartment has exactly one window In other words a three room apartment has three windows a five room five windows and a seven room seven windows Monocarp went around the building and counted windows Now he is wondering how many apartments of each type the building may have Unfortunately Monocarp only recently has learned to count so he is asking you to help him to calculate the possible quantities of three room five room and seven room apartments in the building that has windows If there are multiple answers you can print any of them Here are some examples if Monocarp has counted windows there could have been three room apartments five room apartments and seven room apartments since if Monocarp has counted windows there could have been three room apartments five room apartments and seven room apartments since if Monocarp has counted windows he should have mistaken since no building with the aforementioned layout can have windows ,There are many possible solutions to this problem The simplest one is to notice that using several flats of size and one flat of some size possibly also possibly not we can get any equal to or The only numbers that don t belong to these lists are and and it s easy to see that there is no answer for that numbers So the solution is to try all possible sizes of one flat and if the remaining number of windows is non negative and divisible by then take the required number of three room flats 
You are given a string consisting of lowercase Latin letters is even For each position in string you are required to change the letter on this position either to the previous letter in alphabetic order or to the next one letters and have only one of these options Letter in every position must be changed For example letter should be changed either to or to letter should be changed to and letter should be changed to That way string for example can be changed to String is called a palindrome if it reads the same from left to right and from right to left For example strings and are palindromes and strings and are not Your goal is to check if it s possible to make string a palindrome by applying the aforementioned changes to every position Print if string can be transformed to a palindrome and otherwise Each testcase contains several strings for each of them you are required to solve the problem separately ,If some string can t be transformed to palindrom then it has some pair of positions with different letters on them as no such pair affects any other pair Thus you need to check each pair for from to and verify that the distance between the corresponding letters is either or Overall complexity 
You are walking through a parkway near your house The parkway has benches in a row numbered from to from left to right The distance between the bench and is meters Initially you have units of energy To walk meter of distance you spend unit of your energy You can t walk if you have no energy Also you can restore your energy by and this is the only way to restore the energy When you are sitting you can restore any integer amount of energy you want if you sit longer you restore more energy Note that the amount of your energy Your task is to find the amount of energy you have to by sitting on benches to reach the bench from the bench and end your walk You have to answer independent test cases ,If you have at least units of energy then the answer is because you can just walk to the end Otherwise the answer is because you can just sit on the first bench and then just go Time complexity 
Monocarp has forgotten the password to his mobile phone The password consists of digits from to note that it can start with the digit Monocarp remembers that his password had exactly two different digits and each of these digits appeared exactly two times in the password Monocarp also remembers some digits which were definitely not used in the password You have to calculate the number of different sequences of digits that could be the password for Monocarp s mobile phone i e these sequences should meet all constraints on Monocarp s password ,There are two possible solutions for the problem The first solution is basically brute force Each password can be obtained from an integer from to If the number is from to then it s already a password of length Otherwise you have to prepend it with enough zeros so that it becomes length Then you have to check if the password is valid First check if it consists of exactly two different digits make a set of all its characters set char in case of C for example and check its size Then check if the first digit of the password appears exactly twice It would mean that the other digits appears exactly twice as well Finally check if neither of the found digits are forbidden The second solution is based on combinatorics First choose the two digits that will appear in the password Since digits are prohibited the remaining are allowed Second choose the positions that will be taken by the first one The answer is the product of these two values 
PizzaForces is Petya s favorite pizzeria PizzaForces makes and sells pizzas of three sizes small pizzas consist of slices medium ones consist of slices and large pizzas consist of slices each Baking them takes and minutes respectively Petya s birthday is today and of his friends will come so he decided to make an order from his favorite pizzeria Petya wants to order so much pizza that each of his friends gets at least one slice of pizza The cooking time of the order is the total baking time of all the pizzas in the order Your task is to determine the minimum number of minutes that is needed to make pizzas containing at least slices in total For example if friends come to Petya s birthday he has to order pizzas containing at least slices in total He can order two small pizzas containing exactly slices and the time to bake them is minutes if friends come to Petya s birthday he has to order pizzas containing at least slices in total He can order a small pizza and a large pizza containing slices and the time to bake them is minutes if friends come to Petya s birthday he has to order pizzas containing at least slices in total He can order small pizzas medium pizzas and large pizzas in total they contain slices and the total time to bake them is minutes if only one friend comes to Petya s birthday he can order a small pizza and the time to bake it is minutes ,Note that the speed of cooking 1 slice of pizza is the same for all sizes 1 slice of pizza for 2 5 minutes If n is odd then we will increase it by 1 since the pizza is cooked only with an even number of pieces Now the value of n is always even If n 6 then for such n the answer is equal to the answer for n 6 so we can say that n max n 6 While n ge 12 we can order a small pizza Eventually the value of n will be equal to 6 8 or 10 This means that for any n there will be a set of pizzas with exactly n slices Then the answer is n 2 5 in the solution it is better to use the formula n 2 5 
Consider a playoff tournament where athletes compete The athletes are numbered from to The tournament is held in stages In each stage the athletes are split into pairs in such a way that each athlete belongs exactly to one pair In each pair the athletes compete against each other and exactly one of them wins The winner of each pair advances to the next stage the athlete who was defeated gets eliminated from the tournament The pairs are formed as follows in the first stage athlete competes against athlete competes against competes against and so on in the second stage the winner of the match competes against the winner of the match the winner of the match competes against the winner of the match and so on the next stages are held according to the same rules When athletes and compete the winner is decided as follows if is odd the athlete with the lower index wins i e if then wins otherwise wins if is even the athlete with the higher index wins The following picture describes the way the tournament with goes Your task is the following one given the integer determine the index of the athlete who wins the tournament ,During the first stage every player with an even index competes against a player with an odd index so in each match during the first stage the player whose index is smaller wins The pairs are formed in such a way that in each pair the player with an odd index has smaller index so all players with even indices get eliminated and all players with odd indices advance to the next stage All of the remaining matches are between players with odd indices so the winner of each match is the player with the larger index So the overall winner of the tournament is the player with the greatest odd index which is Note in some languages for example C standard power functions work with floating point numbers instead of integers so they will produce the answer as a floating point number which may lead to wrong formatting of the output and or calculation errors You might have to implement your own power function that works with integers or compute using a loop 
You have an initially empty cauldron and you want to brew a potion in it The potion consists of two ingredients magic essence and water The potion you want to brew should contain exactly magic essence and water In one step you can pour either one liter of magic essence or one liter of water into the cauldron What is the minimum number of steps to brew a potion You don t care about the total volume of the potion only about the ratio between magic essence and water in it A small reminder if you pour liters of essence and liters of water into the cauldron then it contains without rounding magic essence and water ,Since you need liters of essence to be exactly of potion then we can write an equality or and for some integer Since we need to minimize and then we should maximize but both and should be divisible by In other words taking as Greatest Common Divisor of and is optimal As a result 
You are given two integers and it is guaranteed that You may choose any integer and subtract it any number of times from Is it possible to make equal to Recall that a number is a positive integer that has exactly two positive divisors and this integer itself The sequence of prime numbers starts with Your program should solve independent test cases ,Let s denote the difference between and as Then if has a prime divisor we can subtract from times The only positive integer that doesn t have any prime divisors is So the answer is if and only if 
Let number be such number that adding some leading zeros possible none to it produces a palindromic string String is called a palindrome if it reads the same from left to right and from right to left For example numbers and are they can be transformed to strings and respectively which are palindromes You are given some integer number Check if it s a number ,You can check if the given is by removing all the trailing zeros and checking if resulting string is a palindrome 
You have red and blue beans You d like to distribute them among several maybe one packets in such a way that each packet has at least one red bean or the number of red beans has at least one blue bean or the number of blue beans the number of red and blue beans should differ in no more than or Can you distribute all beans ,Without loss of generality let s say otherwise we can swap them Note that you can t use more than packets at least one red bean in each packet so can t exceed at most blue beans in each packet So if then asnwer is Otherwise we can form exactly packets 
A bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters and into this sequence For example sequences and are regular while and are not Let s call a regular bracket sequence RBS You are given a sequence of characters and or in this sequence You have to replace every character with either or different characters can be replaced with different brackets Determine if it is possible to obtain an RBS after these replacements ,There are two solutions to this problem casework and greedy The greedy solution goes as follows the number of opening brackets in an RBS should be exactly and if there is a closing bracket before an opening bracket it s optimal to swap them if possible So we should replace the first question marks with opening brackets other question marks with closing brackets and if the answer exists this method will find it All that s left is to check that the resulting sequence is an RBS The casework solution goes as follows first of all each RBS should have an even length so if is odd there is no answer Furthermore an RBS always begins with an opening bracket and always ends with a closing bracket so if the first character is a closing bracket or the last character is an opening bracket there is no answer Since there is at most one opening bracket and at most one closing bracket in the original sequence these three constraints are enough if the opening bracket is before the closing bracket then they balance out and all other characters can be replaced in such a way that they form an RBS of length If the opening bracket is after the closing bracket then the first and the last characters are question marks since the first character is not a closing bracket and the last one is not an opening bracket We should replace the first character with an opening bracket the last character with a closing bracket so we get four characters two opening and two closing brackets which balance themselves out All other question marks can be replaced in such a way that they form an RBS of length So all we have to check is that is even the first character is not a closing bracket and the last character is not an opening bracket 
A string is called if it does not contain any characters other than and A bracket sequence is called if it it is possible to obtain correct arithmetic expression by inserting characters and into this sequence For example and are regular bracket sequences and are bracket sequences but not regular ones and and are not bracket sequences at all You have a number of strings each string is a bracket sequence of length So overall you have strings strings strings and strings You want to write all these strings in some order one after another after that you will get a long bracket sequence of length You wonder is it possible to choose some order of the strings you have such that you will get a regular bracket sequence ,For bracket sequence to be regular it should have equal number of opening and closing brackets So if then it s impossible to construct any regular bracket sequence is completely irrelevant to us since inserting or removing a substring doesn t change the status of the string we get Almost the same applies to but we should have at least one substring before it So if but there is no solution In all other cases it is possible to order all strings as follows all strings then all strings then all strings then all strings 
A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and and and are not You are given an integer Your goal is to construct and print different regular bracket sequences of length ,There are many ways to solve this problem The model solution does the following thing start with the sequence merge the first characters into one sequence to get merge the first characters into one sequence to get and so on 
You have a list of numbers from to written from left to right on the blackboard You perform an algorithm consisting of several steps steps are indexed On the th step you wipe the th number considering only numbers You wipe not one digit When there are less than numbers remaining you stop your algorithm Now you wonder what is the value of the th remaining number after the algorithm is stopped ,After some simulation of the given algorithm in your head on paper or on a computer we can realize that exactly all odd numbers are erased So all even numbers remain and the answer is 
You have an array All are positive integers In one step you can choose three distinct indices and and assign the sum of and to i e make Can you make all lower or equal to using the operation above any number of times possibly zero ,Let s note that since all are positive any It means that we can t make the first and second minimums lower than they already are suppose the first and second minimums are and if we choose any other element to replace we can t make it less than and if we choose to replace or we will only make them bigger As a result it means that we can choose for each element either not to change it or make it equal to So to be able to make all elements we need just check that either or maximum We can do it for example by sorting our array in increasing order and checking that either or 
You are given a string consisting of lowercase Latin letters Let s define a substring as a contiguous subsegment of a string For example is a substring of it starts in position and ends in position but or aren t substrings of this string So the substring of the string from position to position is You have to choose one of the substrings of the given string and reverse it i e make to obtain a string that is lexicographically Note that it to obtain the minimum possible string If it is impossible to reverse some substring of the given string to obtain a string that is less print Otherwise print and suitable substring String is lexicographically less than string if either is a prefix of and or there exists such that and for any Here denotes the length of the string The lexicographic comparison of strings is implemented by operator in modern programming languages ,If the answer is then we always can reverse a substring of length So we need to check only pairs of adjacent characters in If there is no such pair of characters for all from to then the answer is Why is it so Consider the substring we have to reverse It is obvious that otherwise it is pointless to reverse this substring Then consider two cases then by transitivity and then we can go to a smaller substring otherwise and it means that we can take the substring 
You are an upcoming movie director and you have just released your first movie You have also launched a simple review site with two buttons to press upvote and downvote However the site is not so simple on the inside There are two servers each with its separate counts for the upvotes and the downvotes reviewers enter the site one by one Each reviewer is one of the following types type a reviewer has watched the movie and they like it they press the upvote button type a reviewer has watched the movie and they dislike it they press the downvote button type a reviewer hasn t watched the movie they look at the current number of upvotes and downvotes of the movie on the server they are in and decide what button to press If there are more downvotes than upvotes then a reviewer downvotes the movie Otherwise they upvote the movie Each reviewer votes on the movie exactly once Since you have two servers you can actually manipulate the votes so that your movie gets as many upvotes as possible When a reviewer enters a site you know their type and you can send them either to the first server or to the second one What is the maximum total number of upvotes you can gather over both servers if you decide which server to send each reviewer to ,Notice that the answer depends only on the number of the reviewers of the third type who upvote the movie Optimally we would want every single reviewer of the third type to upvote We can achieve it with the following construction send all reviewers of the first type to the first server all reviewers of the second type to the second server and all reviewers of the third type to the first server Since there are no downvotes on the first server all reviewers of the third type will upvote Thus the answer is the total number of reviewers of the first and the third type Overall complexity per testcase 
You are given two integers and You can perform two types of operations Pay dollars and increase or decrease any of these integers by For example if and there are four possible outcomes after this operation Pay dollars and increase or decrease both integers by For example if and there are two possible outcomes after this operation Your goal is to make both given integers equal zero simultaneously i e There are no other requirements In particular it is possible to move from to Calculate the minimum amount of dollars you have to spend on it ,Let s presume that x ge y Then there are two cases in the problem If a a le b then we have to x y times perform the first operation So the answer is x y cdot a If a a b then we have to y times perform the second operation and pass the remaining distance by performing the first operation So the answer is y cdot b x y cdot a 
There is an infinite 2 dimensional grid The robot stands in cell and wants to reach cell Here is a list of possible commands the robot can execute move north from cell to move east from cell to move south from cell to move west from cell to stay in cell The robot wants to reach cell in as few commands as possible However he can t execute the same command two or more times in a row What is the minimum number of commands required to reach from ,Obviously you can always obtain the optimal answer without using west or south moves So the shortest path consists of east moves and north moves Let s estimate the lower bound of the answer Take a look at these constructions and let question mark be any command different from the used one That s the tightest you can put east or north moves in So the answer is at least For you can put them just as in the construction and fill the rest of question marks with a stay in place move case works differently though You can do it only in moves by taking alternating moves Overall complexity per testcase 
Polycarp plays a well known computer game we won t mention its name In this game he can craft tools of two types shovels and swords To craft a shovel Polycarp spends two sticks and one diamond to craft a sword Polycarp spends two diamonds and one stick Each tool can be sold for exactly one emerald How many emeralds can Polycarp earn if he has sticks and diamonds ,There are three constraints on the number of emeralds the number of emeralds can t be greater than the number of emeralds can t be greater than the number of emeralds can t be greater than So the answer is 
Polycarp has built his own web service Being a modern web service it includes login feature And that always implies password security problems Polycarp decided to store the hash of the password generated by the following algorithm take the password consisting of lowercase Latin letters and shuffle the letters randomly in it to obtain can still be equal to generate two random strings consisting of lowercase Latin letters and any of these strings can be empty the resulting hash where addition is string concatenation For example let the password Then can be equal to Random strings and Then Note that no letters could be deleted or added to to obtain only the order could be changed Now Polycarp asks you to help him to implement the password check module Given the password and the hash check that can be the hash for the password Your program should answer independent test cases ,The general idea of the solution is to check that string contains some substring which is a permutation of The constraints were so low you could do it with any algorithm even per test case could pass The most straightforward way was to iterate over the substring of sort it and check if it s equal to sorted That s Next you could notice than only substrings of length matter and shave another off the complexity to get After that you might remember that the size of the alphabet is pretty low And one string is a permutation of another one if the amounts of letters a letters b and so on in them are equal So you can precalculate array where is equal to the amount of the th letter of the alphabet in Calculating this array for substrings will be each so that makes it Then notice how easy it is to recalculate the letter counts going from some substring to Just subtract from the amount of the th letter and add to the amount of the th letter Comparing two array every time will still lead to though The final optimization is to maintain the boolean array such that means that is equal to the current value of of the substring You are updating just two values of on each step thus only two values of might change You want all the values to be so keep the number of values in that array and say if that number is equal to That finally makes the solution per test case 
Your favorite shop sells Kinder Surprise chocolate eggs You know that exactly stickers and exactly toys are placed in eggs in total Each Kinder Surprise can be one of three types it can contain a single sticker and it can contain a single toy and it can contain both a single sticker a single toy But you which type a particular Kinder Surprise has All eggs look identical and indistinguishable from each other What is the minimum number of Kinder Surprise Eggs you have to buy to be sure that whichever types they are you ll obtain at least one sticker and at least one toy Note that you do not open the eggs in the purchasing process that is you just buy some number of eggs It s guaranteed that the answer always exists ,Note that there are exactly eggs with only a sticker and analogically exactly with only a toy So we need to buy more than eggs or exactly 
Let s define a function is a positive integer as follows write all digits of the decimal representation of backwards then get rid of the leading zeroes For example Let s define another function is a positive integer as well Your task is the following for the given positive integer calculate the number of different values of among all numbers such that ,Let s analyze which values can the function have It can be proven that the value of is equal to where is the number of zero digits at the end of the number because is the same number as except for the fact that it doesn t have any trailing zeroes Okay now let s analyze when we reach the new value of is the first value of such that is the first value of such that is the first value of such that and so on We have to calculate the maximum number that has the form and is not greater than and the answer is exactly It can be done with a mathematical solution but the most simple way to do it is read as a string instead and calculate its length 
You are given a string You have to determine whether it is possible to build the string out of strings and or by concatenating them You can use the strings and or any number of times and in any order For example can be built as can be built as can be built as cannot be built from and or ,Every character in strings and has at least one character adjacent to it that is the same So if there is an isolated character in our string a character that has no neighbors equal to it we cannot build it It s easy to see that in the other case we can build the string we can split it into blocks of consecutive equal characters and since there are no isolated characters each block will have at least characters so it can be formed from strings of length and or consisting of equal characters So the problem is reduced to checking if each character has a neighbor equal to it 
A binary string is a string where each character is either or Two binary strings and of equal length are if they have the same character in some position there exists an integer such that For example and are they have the same character in position and are and are and are not You are given an integer and a binary string consisting of characters Let s denote as the contiguous substring of starting with th character and ending with th character in other words You have to construct a binary string of length which is to ,We just need to make sure our string of characters matches each of the substrings in at least one spot The easiest way to do this is to take every other character from Code 90908018 Another fun solution we can generate random strings and check them until we find one that matches everything This works because the probability of failing to match any particular substring is so as gets bigger the probability of failing gets extremely low Code 90999219 
You are given two integers and Your task is to find if can be represented as a sum of not divisible by integers or not You have to answer independent test cases ,First of all notice that the sum of the first odd integers is If then the answer obviously And if then the answer is also is modulo operation Otherwise the answer is always and it seems like this where It is obviously greater than because and it is obviously odd because the parity of and is the same 
A telephone number is a sequence of exactly digits where the first digit is For example the sequence is a telephone number but the sequences and are not You are given a string of length consisting of digits In one operation you can delete any character from string For example it is possible to obtain strings or from string You need to determine whether there is such a sequence of operations possibly empty after which the string becomes a telephone number ,To solve this problem we just need to find the first occurrence of the digit let s denote it as Now if then answer is otherwise 
A tennis tournament with participants is running The participants are playing by an olympic system so the winners move on and the losers drop out The tournament takes place in the following way below is the number of the participants of the current round let be the maximal power of the number such that participants compete in the current round and a half of them passes to the next round the other participants pass to the next round directly when only one participant remains the tournament finishes Each match requires bottles of water for each participant and one bottle for the judge Besides towels are given to each participant for the whole tournament Find the number of bottles and towels needed for the tournament Note that it s a tennis tournament so in each match two participants compete one of them will win and the other will lose ,Here you can simply model the process Or you can note that after each match some player drops out In total players will drop out So the first answer is Obviously the second answer is 
You are given a following process There is a platform with columns squares are appearing one after another in some columns on this platform If there are no squares in the column a square will occupy the bottom row Otherwise a square will appear at the top of the highest square of this column When all of the columns have at least one square in them the bottom row is being removed You will receive point for this and all the squares left will fall down one row You task is to calculate the amount of points you will receive ,The answer will be equal to where is the number of squares that will appear in the th column 
You are given a text of single space separated words consisting of small and capital Latin letters of the word is number of capital letters in the word of the text is maximum of all words in the text Calculate the of the given text ,Maintain the amount of capital letters taken by going from left to right make it zero when you meet space Overall complexity 
Pasha is participating in a contest on one well known website This time he wants to win the contest and will do anything to get to the first place This contest consists of problems and Pasha solves th problem in time units his solutions are always correct At any moment of time he can be thinking about a solution to only one of the problems that is he cannot be solving two problems at the same time The time Pasha spends to send his solutions is negligible Unfortunately there are too many participants and the website is not always working Pasha received the information that the website will be working only during time periods th period is represented by its starting moment and ending moment Of course Pasha can send his solution only when the website is working In other words Pasha can send his solution at some moment iff there exists a period such that Pasha wants to know his best possible result We need to tell him the minimal moment of time by which he is able to have if he acts optimally or say that it s impossible no matter how Pasha solves the problems ,Notice that we can keep solved tasks and then submit all at once So the solution goes down to this you should find the first moment of time that the site works at that moment and Also it s convinient that the intervals are already sorted in increasing order Let s sum up all elements of array and write it to some variable The answer is obtained this way if the sum lies in the current interval then the answer is the sum Otherwise there are two cases If there exists some interval that then the answer is In other case the answer is 1 
You are given the string of length and the numbers Split the string to pieces of length and For example the string for can be split to the two strings and or to the two strings and Note it is allowed to split the string to the strings only of length or to the strings only of length see the second sample test ,Let s fix the number a of strings of length p and the number b of strings of length q If a p b q n we can build the answer by splitting the string s to a parts of the length p and b parts of the length q in order from left to right If we can t find any good pair a b then the answer doesn t exist Of course this problem can be solved in linear time but the constraints are small so you don t need linear solution Complexity O n2 
There are two types of burgers in your restaurant hamburgers and chicken burgers To assemble a hamburger you need two buns and a beef patty To assemble a chicken burger you need two buns and a chicken cutlet You have buns beef patties and chicken cutlets in your restaurant You can sell one hamburger for dollars and one chicken burger for dollars Calculate the maximum profit you can achieve You have to answer independent queries ,In this task you just can iterate over the numbers of hamburgers and chicken burgers you want to assemble check that you have enough ingredients and update the answer If you want to sell hamburgers and chicken burgers then you need beef patties chicken cutlets and buns 
There are three doors in front of you numbered from to from left to right Each door has a lock on it which can only be opened with a key with the same number on it as the number on the door There are three keys one for each door Two of them are hidden behind the doors so that there is no more than one key behind each door So two doors have one key behind them one door doesn t have a key behind it To obtain a key hidden behind a door you should first unlock that door The remaining key is in your hands Can you open all the doors ,Note that we never have a choice in what door should we open First we open the door with the same number as the key in our hand Then the door with the same number as the key behind the first opened door Finally the door with the same number as the key behind the second opened door If any of the first and second opened doors didn t have a key behind it then it s impossible Otherwise we open every door Let be the keys behind the corresponding doors Then we should check if is not zero and is not zero Overall complexity per testcase 
You are given a permutation Recall that sequence of integers is called a if it contains all integers from to exactly once Find three indices and such that and Or say that there are no such indices ,A solution in iterate on check that there exists an element lower than to the left of it and check that there exists an element lower than to the right of it Can be optimized to with prefix suffix minima A solution in note that if there is some answer we can find an index such that and if there is no such triple the array descends to some point and ascends after that so there is no answer So we only have to check consecutive triples 
Captain Bill the Hummingbird and his crew recieved an interesting challenge offer Some stranger gave them a map potion of teleportation and said that only this potion might help them to reach the treasure Bottle with potion has two values and written on it These values define four moves which can be performed using the potion Map shows that the position of Captain Bill the Hummingbird is and the position of the treasure is You task is to tell Captain Bill the Hummingbird whether he should accept this challenge or decline If it is possible for Captain to reach the treasure using the potion then output otherwise without quotes ,Firstly let s approach this problem as if the steps were and Then the answer is if and It s easy to see that if the answer to this problem is then the answer to the original one is also Let s return to the original problem and take a look at some sequence of steps It ends in some point Define as and as The parity of is the same as the parity of It is like this because every type of move changes parity of both and So the answer is if and Overall complexity 
You are given two integers and Consider a regular polygon of vertices Recall that a regular polygon is a polygon that is equiangular all angles are equal in measure and equilateral all sides have the same length Examples of convex regular polygons Your task is to say if it is possible to build another regular polygon with vertices such that its center coincides with the center of the initial polygon and each of its vertices is some vertex of the initial polygon You have to answer independent test cases ,The answer is if and only if is divisible by because if you number all vertices of the initial polygon from to clockwise then you need to take every vertex divisible by and this number obviously should be integer and there is no other way to construct the other polygon 
You are the gym teacher in the school There are students in the row And there are two rivalling students among them The first one is in position the second in position Positions are numbered from to from left to right Since they are rivals you want to maximize the distance between them If students are in positions and respectively then distance between them is You can do the following operation at most times choose two students and swap them Calculate the maximum distance between two rivalling students after at most swaps ,To solve the problem you need to understand two facts The answer can t be greater than If current distance between rivaling student if less then we always can increment this distance by one swap In means that answer is equal to 
There are two towers consisting of blocks of two colors red and blue Both towers are represented by strings of characters and or denoting the order of blocks in them where corresponds to a blue block and corresponds to a red block You can perform the following operation any number of times choose a tower with and move its block to the of the other tower The pair of towers is if no pair of touching blocks has the same color i e no red block stands on top of another red block and no blue block stands on top of another blue block You have to check if it is possible to perform any number of operations possibly zero to make the pair of towers beautiful ,Note that it does not make sense to move several blocks first from the left tower to the right and then from the right to the left since this is similar to canceling the last actions Using the fact described above and small restrictions on the input data one of the possible solutions is the following choose which tower will be the one where we take blocks from try both options iterate over the number of operations and then check that both towers are beautiful after that number of operations There is a faster solution move all the blocks to the left tower and then check that there is no more than one pair of adjacent blocks of the same color If there are no such pairs then we can divide the tower into two in an arbitrary way and if there is exactly one pair then we need to make a cut exactly between two blocks of the same color Otherwise there will always be a pair of adjacent blocks of the same color in one of the towers 
The FB string is formed as follows Initially it is empty We go through all positive integers starting from in ascending order and do the following for each integer if the current integer is divisible by append to the end of the FB string if the current integer is divisible by append to the end of the FB string Note that if an integer is divisible by both and we append and then not in the opposite order The first characters of the FB string are the first comes from the integer the next character comes from the next comes from the integer and so on It s easy to see that this string is infinitely long Let be the th character of FB string so is is is is and so on You are given a string consisting of characters and or You have to determine whether it is a substring contiguous subsequence of the FB string In other words determine if it is possible to choose two integers and so that the string is exactly For example is a substring of the FB string if we pick and the string is exactly is a substring of the FB string if we pick and the string is exactly is not a substring of the FB string ,It s easy to see that the FB string repeats every characters after processing every numbers we will get the same remainders modulo and as numbers ago and when we process consecutive numbers we get characters So This means that if we want to find a substring no longer than characters in the FB string we don t need to consider more than first characters of the FB string the substring of length starting with the th character ends with the th character and we don t need to consider substrings starting on positions greater than So the solution is to generate at least first characters of the FB string and then check if the substring occurs in the generated string using a standard function like 
Sean is trying to save a large file to a USB flash drive He has USB flash drives with capacities equal to megabytes The file size is equal to megabytes Find the minimum number of USB flash drives needed to write Sean s file if he can split the file between drives ,Let s sort the array in nonincreasing order Now the answer is some of the first flash drives Let s iterate over array from left to right until the moment when we will have the sum at least m The number of elements we took is the answer to the problem Complexity O nlogn 
Vasya is reading a e book The file of the book consists of pages numbered from to The screen is currently displaying the contents of page and Vasya wants to read the page There are two buttons on the book which allow Vasya to scroll pages forwards or backwards but he cannot scroll outside the book For example if the book consists of pages and then from the first page Vasya can scroll to the first or to the fourth page by pressing one of the buttons from the second page to the first or to the fifth from the sixth page to the third or to the ninth from the eighth to the fifth or to the tenth Help Vasya to calculate the minimum number of times he needs to press a button to move to page ,It is easy to understand that the optimal answer is achieved in one of three cases Vasya is trying to visit page without visiting pages and Vasya first goes to the page and then to the page Vasya first goes to the page and then to the page In the first case Vasya can go directly to the page from the page if is divided by In the second case Vasya can get to page through page if is divided by The required number of actions will be equal to Similarly in the third case Vasya can go to the page through the page if is divided by The required number of actions will be equal to If none of the three options described above is appropriate then there is no answer 
There is a special offer in Vasya s favourite supermarket if the customer buys chocolate bars he or she may take additional bars for free This special offer can be used any number of times Vasya currently has roubles and he wants to get as many chocolate bars for free Each chocolate bar costs roubles Help Vasya to calculate the maximum possible number of chocolate bars he can get ,Number of chocolate bars Vasya can buy without offer is Number of bundles with bars Then number of additional bars In result total number of bars is 
Vasya came up with a password to register for a string The password in should be a string consisting of lowercase and uppercase Latin letters and digits But since takes care of the security of its users user passwords must contain at least one digit at least one uppercase Latin letter and at least one lowercase Latin letter For example the passwords and are valid and the passwords and are not A substring of string is a string is the length of the substring Note that the empty string is also considered a substring of it has the length Vasya s password however may come too weak for the security settings of He likes his password so he wants to replace some its substring with another string of the same length in order to satisfy the above conditions This operation should be performed once and ,There are just a few general cases in the task to consider If the password is already valid nothing has to be changed just print Try to change exactly one character iterate over all positions in and all three options for character any digit any lowercase or uppercase Latin letter After the replacement the string is checked for the validity and printed if it turned out to be valid We weren t able to replace a substring of length 0 or 1 then the answer is at least 2 We can obtain it in a following manner replace the first two characters to if the third character is an uppercase Latin letter to if the third character is a lowercase Latin letter and to if the third character is a digit 
It is winter now and Max decided it s about time he watered the garden The garden can be represented as consecutive garden beds numbered from to beds contain water taps th tap is located in the bed which if turned on start delivering water to neighbouring beds If the tap on the bed is turned on then after one second has passed the bed will be watered after two seconds have passed the beds from the segment will be watered if they exist after seconds have passed the beds from the segment will be watered if they exist The garden from test White colour denotes a garden bed without a tap red colour a garden bed with a tap The garden from test after seconds have passed after turning on the tap White colour denotes an unwatered garden bed blue colour a watered bed Max wants to and now he wonders what is the minimum number of seconds that have to pass after he turns on some taps until the whole garden is watered Help him to find the answer ,The answer is the maximal value among the following values to cover all water beds within some segment to cover water beds before the first tap to cover all water beds after the last tap 
You are given two binary strings and which are binary representations of some two integers let s denote these integers as and You can choose any integer calculate the expression and write the binary representation of in let s denote it as For example let and you ve chosen and since so and For given and you need to choose such that is read notes if you don t know what does lexicographically means It s guaranteed that with given constraints exists and is finite ,Multiplying by power of is shift left binary operation you probably should know it Reverse and for the simplicity and look at leftmost in let s denote its position as If you move it to in then you make the lexicographically bigger than the reverse of So you should move it to in too You can choose any with position Let be the minimum position of in such that You must move to otherwise the in still be present in and it will be not optimal So the solution is next reverse and find find print 
Alica and Bob are playing a game Initially they have a binary string consisting of only characters and Alice and Bob make alternating moves Alice makes the first move Bob makes the second move Alice makes the third one and so on During each move the current player must choose two characters of string and delete them For example if then the following moves are possible delete and delete and delete and delete and If a player can t make any move they lose Both players play optimally You have to determine if Alice can win ,If there is at least one character and at least one character then current player can always make a move After the move the number of character decreases by one and the number of character decreases by one too So the number of moves is always where is the number of characters in string and is the number of characters in string So if is odd then Alice wins otherwise Bob wins 
You are given two integers and You can perform a sequence of operations during the first operation you choose one of these numbers and increase it by during the second operation you choose one of these numbers and increase it by and so on You choose the number of these operations yourself For example if and you can perform the following sequence of three operations add to then and add to then and add to then and Calculate the minimum number of operations required to make and equal ,Assume that Let s denote the minimum number of operations required to make and equal as There are two restrictions on At first because if then will be greater than after applying all operations Secondly integers and must have the same parity because if they have different parity then and will have different parity after applying all operations It turns out that we always can make integers and equal after applying operations It s true because we have to add to and the rest to And we can get any integer from to as a sum of subset of set 
You are given a sequence consisting of pairwise distinct positive integers Find different pairs of integers and such that and appear in doesn t appear in Note that some or can belong to multiple pairs denotes the floor function the largest integer less than or equal to denotes the remainder from dividing by If there are multiple solutions print any of them It can be shown that at least one solution always exists ,There is one important observation Thus you can obtain at least pair by choosing as the minimum number in the sequence and as anything else for any positive Overall complexity per testcase 
An is a string yes in the real world accordions are musical instruments but let s forget about it for a while which can be represented as a concatenation of an opening bracket ASCII code a colon ASCII code some possibly zero vertical line characters ASCII code another colon and a closing bracket ASCII code The length of the accordion is the number of characters in it For example and are accordions having length and are not accordions You are given a string You want to transform it into an accordion by removing some possibly zero characters from it Note that you may not insert new characters or reorder existing ones Is it possible to obtain an accordion by removing characters from and if so what is the maximum possible length of the result ,No cases No any special thoughts Just greedy The solution consists of six steps Remove the prefix of the string until the position of leftmost character If there is no such character print Remove the prefix of the string until the position of leftmost character If there is no such character print Reverse the string Remove the prefix of the string until the position of leftmost character If there is no such character print Remove the prefix of the string until the position of leftmost character If there is no such character print Print the number of characters in the remaining string plus four 
Alice and Bob are playing a game The game involves splitting up game pieces into two teams There are pieces and the th piece has a strength The way to split up game pieces is split into several steps First Alice will split the pieces into two different groups and This can be seen as writing the assignment of teams of a piece in an character string where each character is or Bob will then choose an arbitrary prefix or suffix of the string and flip each character in that suffix i e change to and to He can do this step at most once Alice will get all the pieces marked and Bob will get all the pieces marked The strength of a player is then the sum of strengths of the pieces in the group Given Alice s initial split into two teams help Bob determine an optimal strategy Return the maximum strength he can achieve ,Let s calculate the prefix sums for all numbers and store it in array and for numbers with letter B and store it in array Now we can find the sum of all numbers in any segment in time and the sum of numbers with letter B Let s iterate over prefix or suffix to flip and calculate the sum in that case by formulas for prefixes and for suffixes 
You are beta testing the new secret Terraria update This update will add quests to the game Simply the world map can be represented as an array of length where the th column of the world has height There are quests you have to test The th of them is represented by two integers and In this quest you have to go from the column to the column At the start of the quest you are appearing at the column In one move you can go from the column to the column or to the column In this version you have Spectre Boots which allow you to fly Since it is a beta version they are bugged so they only allow you to fly when you are going up and have infinite fly duration When you are moving from the column with the height to the column with the height then you get some amount of fall damage If the height is greater than the height you get fall damage otherwise you fly up and get damage For each of the given quests determine the minimum amount of fall damage you can get during this quest ,So the first idea that is coming into mind is prefix sums Let s define two values and The value means the amount of fall damage when we are going to the right from the column to the column and means the amount of fall damage when we are going to the left from the column to the column Then let s build prefix sums on these two arrays Now let be the sum of all on a prefix i e and be the sum of all on a prefix Then if in a query the answer is otherwise if the answer is Time complexity 
Let s call a permutation of length if the condition holds for all Recall that the permutation is the array of length which contains each integer from to exactly once Your task is for a given number print anti Fibonacci permutations of length ,Let s consider one of the possible solutions Let s put the first element in the th permutation equal to and sort all the other elements in descending order Thus we get permutations of the form In such a construction for all and hence 
For an array of integers of size we construct another array as follows for Your task is to restore the array from a given array or to report that there are multiple possible arrays ,Note that or Since there is no upper bound for the values of the case where for all always exists It remains to check if there are other ways To do this it is enough to check whether there is such a position that the change to doesn t result in a negative value of The reason for is that for no matter the plus or minus we choose the array doesn t change If you could change at least one sign to minus that would be another answer 
You are given an array consisting of integers Let s call a pair of indices if and where is the greatest common divisor of and Find the maximum number of index pairs if you can reorder the array in an arbitrary way ,If the value of is even then at least regardless of the value of Therefore we can put all the even values before the odd ones it does not matter in what order Now it remains to arrange the odd values In fact their order is not important because for odd and This means that each pair will be considered exactly time regardless of the order of the odd elements 
You are given an array consisting of integers Initially you are standing at index and have a score equal to You can perform two kinds of moves move right go from your current index to and add to your score This move can only be performed if move left go from your current index to and add to your score This move can only be performed if You want to perform moves Also there should be no more than moves to the left among them What is the maximum score you can achieve ,Notice that your final position is determined by the number of moves to the left you make Let there be exactly moves to the left that leaves us with moves to the right However let s interpret this the other way You have pairs of moves right left to insert somewhere inside the sequence of moves to the right Easy to see that all the positions from to will always be visited And the extra pairs can also increase the score by visiting some positions for some from to Notice that it s always optimal to choose exactly the same for all the pairs right left And that should be such that is maximum possible You can implement this idea in a straightforward manner iterate over and calculate the sum of values from to and the maximum value of over from to That will lead to a solution per testcase You can optimize it to with prefix sums or with some clever order to iterate over It s also possible to iterate over the final position and restore the number of left moves required to achieve it Overall complexity or per testcase 
You are given two strings and consisting of lowercase Latin letters A template is string consisting of lowercase Latin letters and asterisks character A template is called if the number of asterisks in it is less than or equal to the number of letters in it A string is said to be matching a template if you can replace each asterisk in with a string of lowercase Latin letters possibly an empty string so that it becomes equal to Find an template such that both and match it or report that such a template doesn t exist If there are multiple answers print any of them ,What s the reason behind authors specifically asking for templates that have less or equal asterisks than letters Well without that the problem would be kind of trivial A template is matched by every string so it would always work Hmm let s try to make something similar to that template then We basically have to find some part of that occurs in both strings that we can use letters on to get some freedom to use asterisks There are some easy cases If the first letters of both strings are the same then the template can be that letter followed by an asterisk There s a symmetrical case for the last letter By studying the examples you can also notice the final case a common substring of both strings of length at least two surrounded by two asterisks Moreover since we only use two asterisks we can find a substring of length exactly two which always exists if a longer common substring exists Turns out that s it If a template exists one of these three kinds also exists This is not that hard to show If the first two kinds don t work then you have to use asterisks on both sides of the template In order for the template with asterisks on both sides to work there have to be adjacent letters in it at least once otherwise it s like and there are more asterisks than letters And since at least one such substring exists we can just remove everything other than this substring and the asterisks on the sides Overall complexity per testcase 
It s been almost a week since Polycarp couldn t get rid of insomnia And as you may already know one week in Berland lasts days When Polycarp went to a doctor with his problem the doctor asked him about his sleeping schedule more specifically the average amount of hours of sleep per week Luckily Polycarp kept records of sleep times for the last days So now he has a sequence where is the sleep time on the th day The number of records is so large that Polycarp is unable to calculate the average value by himself Thus he is asking you to help him with the calculations To get the average Polycarp is going to consider consecutive days as a week So there will be weeks to take into consideration For example if and then the result is You should write a program which will calculate average sleep times of Polycarp over all weeks ,To get the sum for th week you need to take sum of th week subtract first element of th week from it and add up last element of th week All common elements will remain Thus by moving right week by week calculate sum of all weeks and divide it by Overall complexity 
You are given a string consisting only of characters and A substring of is a string and its length equals to A substring is called if the number of zeroes equals to the number of ones in this substring You have to determine the length of the longest substring of ,Let be the number of zeroes and the number of ones on prefix of length also let The interesting property of is that the substring is balanced iff That leads to a solution for each value of maintain the minimum where this is obtained let it be called and for each index in the string update answer with 
You have barrels lined up in a row numbered from left to right from one Initially the th barrel contains liters of water You can pour water from one barrel to another In one act of pouring you can choose two different barrels and the th barrel shouldn t be empty and pour any possible amount of water from barrel to barrel possibly all water You may assume that barrels have infinite capacity so you can pour any amount of water in each of them Calculate the maximum possible difference between the maximum and the minimum amount of water in the barrels if you can pour water times Some examples if you have four barrels each containing liters of water and you may pour liters from the second barrel into the fourth so the amounts of water in the barrels are and the difference between the maximum and the minimum is if all barrels are empty you can t make any operation so the difference between the maximum and the minimum amount is still ,A greedy strategy always works take largest barrels choose one barrel among them and pour all water from those barrels to the chosen barrel That way we make the minimum amount equal to it s quite obvious that we can t do anything better here and the maximum amount as large as possible so the difference between them will be as large as possible 
Recently Luba learned about a special kind of numbers that she calls numbers The number is called iff its binary representation consists of consecutive ones and then consecutive zeroes Some examples of beautiful numbers More formally the number is beautiful iff there exists some positive integer such that the number is equal to Luba has got an integer number and she wants to find its greatest beautiful divisor Help her to find it ,Let s notice that there are only beautiful numbers less than Generate them all and select the greatest one which is also divisor of Overall complexity 
Berland crossword is a puzzle that is solved on a square grid with rows and columns Initially all the cells are white To solve the puzzle one has to color some cells on the border of the grid black in such a way that exactly cells in the top row are black exactly cells in the rightmost column are black exactly cells in the bottom row are black exactly cells in the leftmost column are black Note that you can color zero cells black and leave every cell white Your task is to check if there exists a solution to the given puzzle ,Consider some corner of the picture If it s colored black then it contributes to counts to both of the adjacent sides Otherwise it contributes to none All the remaining cells can contribute only to the side they are on There are of such cells on each side So let s try all options of coloring the corners After fixing the colors of the corners we can calculate the number of cells that have to be colored on each side That is calculated by taking the initial requirement and subtracting the adjacent colored corners from it If any of the numbers is below or above then that corner coloring doesn t work Otherwise you can always color the cells in some way Overall complexity per testcase 
Berland Music is a music streaming service built specifically to support Berland local artist Its developers are currently working on a song recommendation module So imagine Monocarp got recommended songs numbered from to The th song had its predicted rating equal to where and every integer from to appears exactly once In other words is a permutation After listening to each of them Monocarp pressed either a like or a dislike button Let his vote sequence be represented with a string such that means that he disliked the th song and means that he liked it Now the service has to re evaluate the song ratings in such a way that the new ratings still form a permutation each integer from to appears exactly once every song that Monocarp liked should have a greater rating than every song that Monocarp disliked formally for all such that and should hold Among all valid permutations find the one that has the smallest value of where is an absolute value of Print the permutation If there are multiple answers you can print any of them ,Since we know that every disliked song should have lower rating than every liked song we actually know which new ratings should belong to disliked songs and which should belong to the liked ones The disliked songs take ratings from to the number of zeros in The liked songs take ratings from the number of zeros in plus to Thus we have two independent tasks to solve Let the disliked songs have ratings Their new ratings should be We can show that if we sort the array then will be the lowest possible The general way to prove it is to show that if the order has any inversions we can always fix the leftmost of them swap two adjacent values and the cost doesn t increase So the solution can be to sort triples and restore from the order of in these Overall complexity per testcase 
Let s define the value of the permutation of integers a permutation is an array where each element from to occurs exactly once as follows initially an integer variable is equal to if then add to set otherwise assign to if then add to set otherwise assign to if then add to set otherwise assign to the value of the permutation is at the end of this process For example for the value of changes as follows so the value of the permutation is You are given an integer Find a permutation of size with the maximum possible value among all permutations of size If there are several such permutations you can print any of them ,Let be the value of the variable after steps Note that should be less than for to be not equal to It means that does not exceed It turns out that for there is always a permutation such that is equal to The only thing left is to find out how to build such a permutation There are many suitable permutations let s consider one of the possible options For an even a suitable permutation is You can see that in such a permutation changes as follows For an odd there is a similar permutation where changes as follows 
A palindrome is a string which reads the same backward as forward formally for all Here denotes the length of a string For example the strings and are palindromes You have binary strings each consists of zeroes and or ones You can swap any pair of characters any number of times possibly zero Characters can be either from the same string or from different strings there are no restrictions Formally in one move you choose four integer numbers such that and and where and are string indices and and are positions in strings and respectively swap exchange the characters and What is the maximum number of strings you can make palindromic simultaneously ,Let s make several observations At first note that the lengths of the strings doesn t change At second note that if the string has even length then being palindromic is the same as having even number of zeroes and even number of ones But if the string has odd length then it always is palindromic So the question is how to fix bad strings with even length but with odd number of zeroes and ones If we have at least one string with odd length then you can trade between bad string and odd string either zero to one or one to zero fixing the bad string Otherwise you can fix two bad strings swapping appropriate characters In result we can either make all strings palindromic or all strings except one in case of absence of odd strings and having odd number of bad strings 
Let s say string has period if for all from to means length of string and is the minimum positive integer with this property Some examples of a period for the period is for the period is for the period is for the period is You are given string consisting only of s and s and you need to find such string that String consists only of s and s The length of doesn t exceed String is a subsequence of string String has smallest possible period among all strings that meet conditions 1 3 Let us recall that is a subsequence of if can be derived from by deleting zero or more elements any without changing the order of the remaining elements For example is a subsequence of ,Let s see how strings with periods k 1 and k 2 look There are two types of strings with a period equal to 1 and And there are two types of strings with a period equal to 2 and It s easy to see if t consists only of s s then the string itself is an answer since it has period equal to 1 Otherwise it s also quite obvious that any string t is a subsequence of of 2 t length 
You are given a string consisting only of characters or Let be the length of You are asked to choose some integer and find a sequence of length such that for all from to The characters at positions are removed the remaining characters are concatenated without changing the order So in other words the positions in the sequence should not be adjacent Let the resulting string be is called sorted if for all from to Does there exist such a sequence that the resulting string is sorted ,There are several different ways to solve this problem In my opinion the two easiest solutions are notice that in the sorted string there is a prefix of zeroes and a suffix of ones It means that we can iterate on the prefix from which we remove all ones and remove all zeroes from the suffix we obtain If we try to remove two adjacent characters then we cannot use this prefix if there is a substring before the substring in our string then from both of the substrings at least one character remains so if the first occurrence of is earlier than the last occurrence of there is no answer Otherwise the answer always exists 
There are block towers numbered from to The th tower consists of blocks In one move you can move one block from tower to tower but only if That move increases by and decreases by You can perform as many moves as you would like possibly zero What s the largest amount of blocks you can have on the tower after the moves ,Notice that it never makes sense to move blocks between the towers such that neither of them is tower 1 as that can only decrease the heights Moreover it never makes sense to move blocks away from the tower 1 Thus all operations will be moving blocks from some towers to tower 1 At the start which towers can move at least one block to tower 1 Well only such i that a i a 1 What happens after you move a block Tower 1 becomes higher some tower becomes lower Thus the set of towers that can share a block can t become larger Let s order the towers by the number of blocks in them At the start the towers that can share a block are at the end on some suffix in this order After one move is made the towers get reordered and the suffix can only shrink Ok but if that suffix shrinks what s the first tower that will become too low The leftmost one that was available before So regardless of what the move is the first tower that might become unavailable is the leftmost available tower Thus let s attempt using it until it s not too late The algorithm then is the following Find the lowest tower that can move the block to tower 1 move a block repeat When there are no more towers higher than tower 1 the process stops However the constraints don t allow us to do exactly that We ll have to make at most 10 9 moves per testcase Ok let s move the blocks in bulk every time Since the lowest available tower will remain the lowest until you can t use it anymore make all the moves from it at the same time If the current number of blocks in tower 1 is x and the current number of blocks in that tower is y lceil frac y x 2 rceil blocks can be moved You can also avoid maintaining the available towers by just iterating over the towers in the increasing order of their height Overall complexity O n log n per testcase 
You are given an array Array is good if for each pair of indexes the condition holds Can you shuffle this array so that it becomes good To shuffle an array means to reorder its elements arbitrarily leaving the initial order is also an option For example if then shuffled arrays and are good but shuffled arrays and aren t It s guaranteed that it s always possible to shuffle an array to meet this condition ,Let s sort array in non ascending order In this case for each pair of indexes the condition holds 
Luba is surfing the Internet She currently has opened tabs in her browser indexed from to from left to right The mouse cursor is currently located at the th tab Luba needs to use the tabs with indices from to inclusive for her studies and she wants to close all the tabs that don t belong to this segment as fast as possible Each second Luba can either try moving the cursor to the left or to the right if the cursor is currently at the tab then she can move it to the tab or to the tab or try closing all the tabs to the left or to the right of the cursor if the cursor is currently at the tab she can close all the tabs with indices from segment or from segment In the aforementioned expressions and denote the minimum and maximum index of an unclosed tab respectively For example if there were tabs initially and tabs and are closed then What is the minimum number of seconds Luba has to spend in order to leave opened ,If and then the answer is If and or and then answer is or respectively And in the other case when and the answer is 
Ivan has a robot which is situated on an infinite grid Initially the robot is standing in the starting cell The robot can process commands There are four types of commands it can perform move from the cell to move from to move from to move from to Ivan entered a sequence of commands and the robot processed it After this sequence the robot ended up in the starting cell but Ivan doubts that the sequence is such that after performing it correctly the robot ends up in the same cell He thinks that some commands were ignored by robot To acknowledge whether the robot is severely bugged he needs to calculate the maximum possible number of commands that were performed correctly Help Ivan to do the calculations ,Consider the final cell after original path It has some distance to and to That means the path included at least and in corresponding directions Let s remove just these minimal numbers of moves Finally the answer will be where are distances from the final cell of the original path to Overall complexity 
Monocarp has just learned a new card trick and can t wait to present it to you He shows you the entire deck of cards You see that the values of cards from the topmost to the bottommost are integers and all values are different Then he asks you to shuffle the deck times With the th shuffle you should take topmost cards and move them under the remaining cards without changing the order And then using some magic Monocarp tells you the topmost card of the deck However you are not really buying that magic You tell him that you know the topmost card yourself Can you surprise Monocarp and tell him the topmost card before he shows it ,The easiest way to solve to problem is probably to see the resemblense of a shuffle operation to an std rotate function So you can obtain the final deck by applying cyclic shifts of the deck by then and so on Since the shifts are cyclic it doesn t matter if you shift by or by or by for any non negative The result will be the same Thus you can calculate the sum of rotations you apply and subtract until it becomes less than That is taking it modulo Finally after rotating a sequence by some the th element of it indexed becomes the first one Thus you just want to print the th element of Overall complexity per testcase 
Suppose you are living with two cats A and B There are napping spots where both cats usually sleep Your cats like to sleep and also like all these spots so they change napping spot each hour cyclically Cat A changes its napping place in order In other words at the first hour it s on the spot and then goes in decreasing order cyclically Cat B changes its napping place in order In other words at the first hour it s on the spot and then goes in increasing order cyclically The cat B is much younger so they have a strict hierarchy A and B don t lie together In other words if both cats d like to go in spot then the A takes this place and B moves to the next place in its order if then to but if then to Cat B follows his order so Calculate where cat B will be at hour ,If is even then each hour A and B are on the spots with different parity so they will never meet Otherwise let s look closely what happens At the start A in and B in But since we can form a cycle from spots then it means that and in reality are neighbors After that A and B starting from neighboring positions just go in opposite directions and meet each other in the opposite spot after exactly steps After meeting B jumps over A making extra step and the situation become practically the same A and B are neighbors and move in the opposite direction In other words each steps B makes one extra step so the answer if both and spots are indexed is 
You are given a function written in some basic language The function accepts an integer value which is immediately written into some variable is an integer variable and can be assigned values from to The function contains three types of commands for for loop end every command between for and corresponding end is executed times add adds to After the execution of these commands value of is returned Every for is matched with end thus the function is guaranteed to be valid for can be immediately followed by end add command can be outside of any for loops Notice that add commands might overflow the value of It means that the value of becomes greater than after some add command Now you run and wonder if the resulting value of is correct or some overflow made it incorrect If overflow happened then output OVERFLOW otherwise print the resulting value of ,One can notice or actually derive using some maths that the answer is the sum of products of nested for loops iterations for every add command Let s learn to simulate that in linear complexity Maintain the stack of multipliers on for push the top of stack multiplied by to the stack on end pop the last value on add add the top of the stack to the answer The problem however is the values are really large Notice that once you add the value greater or equal to to the answer it immediately becomes OVERFLOW Thus let s push not the real multiplier to the stack but min multiplier That way the maximum value you can achieve is about which fits into the 64 bit integer Overall complexity 
A chess tournament will be held soon where chess players will take part Every participant will play one game against every other participant Each game ends in either a win for one player and a loss for another player or a draw for both players Each of the players has their own expectations about the tournament they can be one of two types a player wants not to lose any game i e finish the tournament with a player wants to win at least one game You have to determine if there exists an outcome for all the matches such that all the players meet their expectations If there are several possible outcomes print any of them If there are none report that it s impossible ,Since the chess players of the first type should not lose a single game each game between two chess players of the first type should end in a draw so that none of them gets defeated And a game between a chess player of the first type and the second type should end either with a victory of the first or a draw Therefore for convenience we will say that all games with a chess player of the first type end in a draw Now there are only games between chess players of the second type left If there are only or such players then there is no answer Otherwise we can choose the following method the th chess player of the second type wins against the th chess player of the second type and the last one wins against the first all remaining games are drawn 
You are given four integer values and Check if there exists a string that contains letters letters letters no other letters exactly pairs of adjacent equal letters exactly such positions that the th letter is equal to the th one ,Let s start with a simple assumption For some fixed values the values of that the answers exist for make up a range So there s the smallest possible number of adjacent equal pairs one can construct and the largest one everything in between exists as well The largest number is simple put all A s then all B s then all C s So this value is The smallest number is trickier Let s instead investigate when it s equal to WLOG assume Imagine the following construction There are letters C which separate blocks of letters A and B There are if you consider the ones to the sides of all letters C but we want the smallest value so we shouldn t consider them such blocks thus it s possible that each block contains no more than one letter A and no more than one letter B So letters A and B will never produce adjacent pairs If there are empty blocks then there are adjacent letters C So the condition to still have no empty blocks is to have at least letters A and B in total If then any extra letter C can only be put adjacent to another letter C thus producing an extra pair at least one extra pair but since we are examining the lower bound we can always do exactly one That means that the lower bound is Now for the proof of the fact that every value in between is also achievable Since we have a construction for let s try modifying it Let s reduce the test to the following way While decrease the count of the letter that appears the most by and decrease by Now build the string for with the reduced values After that put the letters back placing them next to the last occurrence of the same letter there is at least one occurrence of each letter the proof is trivial That increases by and the count of this letter by Thus we ll return to the initial test Overall complexity per testcase 
You are given points with integer coordinates on a coordinate axis The coordinate of the th point is All points coordinates are distinct and given in strictly increasing order For each point you can do the following operation take this point and move it by to the left or to the right i e you can change its coordinate to or to In other words for each point you choose separately its new coordinate For the th point it can be either or Your task is to determine if you can move some points as described above in such a way that the new set of points forms a of integers i e for some integer the coordinates of points should be equal to Note that the resulting points should have coordinates You have to answer independent test cases ,We can see that the answer is if and only if there are no more than two gaps of length between the given points If there is no gap the answer is obviously If there is only one gap of length we can just move the left or the right part of the set to this gap When there are two gaps we can move the part before the first gap to the right and the part after the second gap to the left Of course if there is a gap of length at least or multiple gaps with the total length we can t move the points from the left and the right part to satisfy the middle gap Time complexity 
 children are standing in a circle and playing the counting out game Children are numbered clockwise from to In the beginning the first child is considered the leader The game is played in steps In the th step the leader counts out people in clockwise order starting from the next person The last one to be pointed at by the leader is eliminated and the next player after him becomes the new leader For example if there are children with numbers currently in the circle the leader is child and then counting out rhyme ends on child who is eliminated Child becomes the leader You have to write a program which prints the number of the child to be eliminated on every step ,The task was just about implementing algorithm described in statement This is one of many possible ways of doing this Firstly you should notice that doing iterations in th step is equal to doing iterations based numbering That is less than Now fill array of length with ones and create pointer to current leader Then on th step move pointer to the right from cell proceed to till you encounter ones When finished write to this cell and move pointer to next cell which contains Overall complexity 
The robot is placed in the top left corner of a grid consisting of rows and columns in a cell In one step it can move into a cell adjacent by a side to the current one The robot can t move outside the grid The cell contains a deadly laser If the robot comes into some cell that has distance less than or equal to to the laser it gets evaporated The distance between two cells and is Print the smallest number of steps that the robot can take to reach the cell without getting evaporated or moving outside the grid If it s not possible to reach the cell print The laser is neither in the starting cell nor in the ending cell The starting cell always has distance greater than to the laser ,First let s determine if it s possible to reach the end at all If the laser s field doesn t span until any wall then it s surely possible just stick to the wall yourself If it touches at most one wall it s still possible If it s the bottom wall or the left wall then take the path close to the top and the right wall Vice versa if it s the top wall or the right wall then take the path close to the bottom and the left wall What if both of these paths are locked That means that the laser touches at least two walls at the same time the top one and the left one or the bottom one and the right one Turns out it s completely impossible to reach the end in either of these two cases Just draw a picture and see for yourself Thus we can always take at least one of the path sticking to the walls The distance from the start to the end is and both of these paths are exactly this long So the answer is always either or To check if the laser touches a wall with its field you can either use a formula or check every cell adjacent to a wall Overall complexity or per testcase 
You are playing a computer game To pass the current level you have to kill a big horde of monsters In this horde there are monsters standing in the row numbered from to The th monster has health and a special Death s Blessing spell of strength attached to it You are going to kill all of them It takes exactly seconds to kill a monster with health When the th monster dies it casts its spell that increases the health of its by the neighbors of the th monster in the row are the monsters on places and The first and the last monsters have only one neighbor each After each monster is killed the row shrinks so its former neighbors become adjacent to each other so if one of them dies the other one is affected by its spell For example imagine a situation with monsters with health and spells One of the ways to get rid of the monsters is shown below As a result we can kill all monsters in seconds Note that it s only an example and may not be the fastest way to get rid of the monsters What is the minimum time required to kill all monsters in the row ,Note that whichever order you choose the total time will always contain all initial health in other words any answer will contain as its part So the lower the sum of you will add to the answer the better Look at some monster If you kill it while it has both left and right neighbor it will add to the answer If it is the first or the last in the row it will add just And if it is the last monster it will add There can be only one last monster so any other will add at least to the answer And for any chosen last monster you can find the order that gives exactly for all other monsters For example you can firstly kill monsters then and finally moster In other words if the last monster is the th one the total answer will be equal to Since we need to minimize answer we can choose monster with maximum So the answer is 
Mikhail walks on a Cartesian plane He starts at the point and in one move he can go to any of eight adjacent points For example if Mikhail is currently at the point he can go to any of the following points in one move If Mikhail goes from the point to the point in one move and and then such a move is called a Mikhail has For the th query Mikhail s target is to go to the point from the point in moves Among all possible movements he want to choose one with the maximum number of Your task is to find the maximum number of or find that it is impossible to go from the point to the point in moves Note that Mikhail visit any point any number of times even the destination point ,There are several cases in this problem If then let s swap them Let be the modulo operator Firstly if then let s decrease and by one Otherwise if let s decrease by one and by two Now if then the answer is otherwise the answer is You can get more clear description of these cases if you will draw some cases on the paper 
Today at the lesson of mathematics Petya learns about the digital root The digital root of a non negative integer is the single digit value obtained by an iterative process of summing digits on each iteration using the result from the previous iteration to compute a digit sum The process continues until a single digit number is reached Let s denote the digital root of as Then As a homework Petya got tasks of the form find th positive number whose digital root is Petya has already solved all the problems but he doesn t know if it s right Your task is to solve all tasks from Petya s homework ,The key observation is that the digital root of an integer is the single digit number such that You can prove this by noticing that for all Once we observe this finding the th number is very simple see the code 48993705 
Jack decides to invite Emma out for a dinner Jack is a modest student he doesn t want to go to an expensive restaurant Emma is a girl with high taste she prefers elite places Munhattan consists of streets and avenues There is exactly one restaurant on the intersection of each street and avenue The streets are numbered with integers from to and the avenues are numbered with integers from to The cost of dinner in the restaurant at the intersection of the th street and the th avenue is Jack and Emma decide to choose the restaurant in the following way Firstly Emma chooses the street to dinner and then Jack chooses the avenue Emma and Jack makes their choice optimally Emma wants to maximize the cost of the dinner Jack wants to minimize it Emma takes into account that Jack wants to minimize the cost of the dinner Find the cost of the dinner for the couple in love ,Firstly you should find the minimum value in each row and after that you should find the maximum value over that minimums It s corresponding to the strategy of Jack and Emma 
You came to a local shop and want to buy some chocolate bars There are bars in the shop th of them costs coins and you want to buy all of them You have different coupons that allow you to buy chocolate bars th coupon allows you to buy chocolate bars while you have to pay only for the most expensive ones so the cheapest bar of those bars is for free You can use only one coupon if you use coupon you have to choose bars and buy them using the coupon and buy all the remaining bars without any discounts To decide which coupon to choose you want to know what will be the minimum total amount of money you have to pay if you use one of the coupons optimally ,When using th coupon the bar we get for free should have at least bars not cheaper than it So if we consider sorted in non decreasing order then we cannot get discount greater than On the other hand we can always get such a discount if we pick most expensive bars to buy using the th coupon 
You are given the array of integer numbers For each element find the distance to the nearest zero to the element which equals to zero There is at least one zero element in the given array ,Let s divide the solution into two parts firstly check the closest zero to the left and then the closest zero to the right After that we can take minimum of these numbers Initialize distance with infinity Iterate over array from left to right If value in current position is then set distance to otherwise increase distance by On each step write value of distance to the answer array Do the same thing but going from right to left This will find closest zero to the right Now you should write minimum of current value of distance and value that s already in answer array Finally you should retrieve the answer from distances Overall complexity 
You are given an integer number The following algorithm is applied to it if then end algorithm find the smallest divisor of subtract from and go to step Determine the number of subtrations the algorithm will make ,Notice that once the number becomes even it never stops being even as subtracting doesn t change parity Thus the task is to find the smallest divisor subtract it and print Overall complexity 
There are emotes in very popular digital collectible card game the game is pretty famous so we won t say its name The th emote increases the opponent s happiness by units we all know that emotes in this game are used to make opponents happy You have time to use some emotes only times You are allowed to use any emotion once more than once or not use it at all The only restriction is that you otherwise the opponent will think that you re trolling him You have to make your opponent as happy as possible Find the maximum possible opponent s happiness ,It is obvious that we always can use only two emotes with maximum Let their values be and We have to solve the problem by some formula The best way to use emotes use the emote with the value times then use the emotion with the value then again use the emote with value times and so on So the has length and we can use the emote with the value the remaining number of times So the answer is where is the first maximum of is the second maximum of is divided by rounded down and is modulo 
You are given an array such that Let be the sum of all elements of the array Let s call an array of integers if for each from to for every pair of adjacent integers from the array either divides or divides or both Your task is to find any beautiful array It can be shown that at least one beautiful array always exists ,It is enough to consider two possible arrays and It is not difficult to notice that in these arrays the condition is met that among two neighboring elements one divides the other It remains to show that at least one of these two arrays satisfies the condition Let s consider the sum of elements at odd positions and the sum of elements at even positions Since at least one of the values of and does not exceed because otherwise their sum will be strictly greater than Without losing generality assume that Note that for the second variant of the array the condition holds so 
Alice and Bob play 5 in a row game They have a playing field of size In turns they put either crosses or noughts one at a time Alice puts crosses and Bob puts noughts In current match they have made some turns and now it s Alice s turn She wonders if she can put cross in such empty cell that she wins immediately Alice wins if some crosses in the field form line of length This line can be horizontal vertical and diagonal ,This one is a pure implementation task Just check every possible line of length If the current one contains crosses and empty cell then the answer is 
The flag of Berland is such rectangular field that satisfies following conditions Flag consists of three colors which correspond to letters and Flag consists of three equal in width and height stripes parralel to each other and to sides of the flag Each stripe has Each color should be used in You are given a field consisting of characters and Output without quotes if this field corresponds to correct flag of Berland Otherwise print without quotes ,There are lots of ways to check correctness For example you can keep boolean array with already used colors check stripes naively and mark the color used if the stripe has single color If all the colors are used in the end then the answer is Overall complexity 
A telephone number is a sequence of digits such that its first digit is Vasya and Petya are playing a game Initially they have a string of length is odd consisting of digits Vasya makes the first move then players alternate turns In one move the player choose a character and erase it from the current string For example if the current string after the player s move it may be or The game ends when the length of string becomes If the resulting string is a telephone number Vasya wins otherwise Petya wins You have to determine if Vasya has a winning strategy that is if Vasya can win the game no matter which characters Petya chooses during his moves ,Let s understand how players should act Vasya needs to delete the first digit that is not equal to because the first digit of telephone number should be and the first digit not equal to is preventing it Petya needs to delete the first digit equal to for the same reasons So all that we need to do is delete first digits not equal to if they exist and first digits equal to again if they exist It s enough to stop when there is either no s left or no non s because the latter moves won t change the result of the game anyway Finally if first digit of resulting string is then Vasya wins otherwise Petya Overall complexity 
You are given three integers and Find two positive integers and such that the decimal representation of without leading zeroes consists of digits the decimal representation of without leading zeroes consists of digits the decimal representation of without leading zeroes consists of digits denotes the greatest common divisor GCD of integers and Output and If there are multiple answers output any of them ,The easiest way to force some gcd to be of some fixed length is to use the divisibility rules for or if the number produced by the last digits is divisible by then is also divisible by same goes for and One of the possible constructions is the following let and Since and are pairwise prime gcd is Overall complexity per testcase 
Suppose you have an integer In one operation you can either set or set You are given integers What is the minimum number of operations you need to make each equal to ,Note that so you can make any value equal to by multiplying it by two times since So the answer for each value is at most Now let s note that there is always an optimal answer that consists of at first add one times then multiply by two times and is the minimum answer In other words let s just iterate over all and and check that The answer is minimum among them To prove that it s optimal to add at first and only then to multiply note that it s not optimal to add more than once after muptiplying can be replaced by So there is at most one between two but it s not optimal to make even one since we need to make divisible by and break divisibility There are many other approaches to this task except this one for example since you can write bfs to find the shortest paths from to all 
You have a string of length consisting of only characters and You may do some operations with this string for each operation you have to choose some character that still remains in the string If you choose a character the character that comes right after it is deleted if the character you chose was the last one nothing happens If you choose a character the character that comes right before it is deleted if the character you chose was the first one nothing happens For example if we choose character in string the string will become to And if we choose character in string the string will become to The string is good if there is a sequence of operations such that after performing it only one character will remain in the string For example the strings are good you may remove any number of characters from the given string possibly none possibly up to but not the whole string You need to calculate the minimum number of characters to be deleted from string so that it becomes good ,A string is good when either its first character is or the last is Strings of type are not good as their first and last characters will never change and they will eventually come to the form So the answer is the minimum number of characters from the beginning of the string which must be removed so that the first symbol becomes or minimum number of characters from the end of the string which must be removed so that the last symbol becomes 
Once Max found an electronic calculator from his grandfather Dovlet s chest He noticed that the numbers were written with seven segment indicators https en wikipedia org wiki Seven segment display Max starts to type all the values from to After typing each number Max resets the calculator Find the total number of segments printed on the calculator For example if and then at first the calculator will print segments then segments and at last it will print segments So the total number of printed segments is ,Let s simply iterate over all the values from to and add to the answer the number of segments of the current value To count the number of segments we should iterate over all the digits of the number and add to the answer the number of segments of the current digit These values can be calculated by the image from the problem statement and stored in some array in code 
 students attended the first meeting of the Berland SU programming course is even All students will be divided into two groups Each group will be attending exactly one lesson each week during one of the five working days Monday Tuesday Wednesday Thursday and Friday and the days chosen for the groups must be different Furthermore both groups should contain the same number of students Each student has filled a survey in which they told which days of the week are convenient for them to attend a lesson and which are not Your task is to determine if it is possible to choose two different week days to schedule the lessons for the group the first group will attend the lesson on the first chosen day the second group will attend the lesson on the second chosen day and divide the students into two groups so the groups have equal sizes and for each student the chosen lesson day for their group is convenient ,Since there are only five days we can iterate over the two of them that will be the answer Now we have fixed a pair of days and and want to check if it can be the answer All students can be divided into four groups marked neither of days and marked only day marked only day and marked both days Obviously if the first group is non empty days and can t be the answer Let s call the number of students who only marked day and the number of students who only marked day If either of or exceed then days and can t be the answer as well Otherwise we can always choose students from the ones who marked both days and send them to day The rest of the students can go to day 
HDD hard drives group data by sectors All files are split to fragments and each of them are written in some sector of hard drive Note the fragments can be written in sectors in arbitrary order One of the problems of HDD hard drives is the following the magnetic head should move from one sector to another to read some file Find the time need to read file split to fragments The th sector contains the th fragment of the file Note different sectors contains the different fragments At the start the magnetic head is in the position that contains the first fragment The file are reading in the following manner at first the first fragment is read then the magnetic head moves to the sector that contains the second fragment then the second fragment is read and so on until the th fragment is read The fragments are read in the order from the first to the th It takes time units to move the magnetic head from the sector to the sector Reading a fragment takes no time ,You are given the permutation f Let s build another permutation p in the following way pfi i So the permutation p defines the number of sector by the number of fragment The permutation p is called inverse permutation to f and denoted f 1 Now the answer to problem is Complexity O n 
You are given one dimensional segments each segment is denoted by two integers its endpoints Let s define the function as the number of segments covering point a segment covers the point if where is the left endpoint and is the right endpoint of the segment An integer point is called if it belongs to more segments than any other integer point i e is true for any other integer point You are given an integer Your task is to determine whether it is possible to remove some possibly zero segments so that the given point becomes ,First of all let s delete all segments that do not cover the point because they increase the value of the function at points other than If there are no segments left then the answer is Otherwise all segments cover the point And it remains to check whether the point is the only point which is covered by all segments Note that it does not make sense to delete any of the remaining segments because if there are several points with maximum value of then deleting segments can only increase their number To check the number of points with the maximum value of you can iterate over from to and calculate because of the small number of segments in the problem A faster way is to check the size of the intersection of all segments The left boundary of the intersection is and the right boundary is if then the point is ideal otherwise it is not 
You are given string of length consisting of s and s You build an infinite string as a concatenation of an infinite number of strings or For example if then Calculate the number of prefixes of with equal to The balance of some string is equal to where is the number of occurrences of in and is the number of occurrences of in The number of such prefixes can be infinite if it is so you must say that A prefix is a string consisting of several first letters of a given string without any reorders An empty prefix is also a valid prefix For example the string abcd has 5 prefixes empty string a ab abc and abcd ,Let s denote a prefix of length as We can note that each where and is a concatenation Then balance of prefix of length is equal to Now there two cases is equal to or not If then if exist such that then for each and answer is Otherwise for each such there will no more than one possible since there are zero or one solution to the equation The solution exists if and only if and So just precalc and for each check the equation 
You have a statistic of price changes for one product represented as an array of positive integers where is the initial price of the product and is how the price was increased during the th month Using these price changes you are asked to calculate the inflation coefficients for each month as the ratio of current price increase to the price at the start of this month Your boss said you clearly that the inflation coefficients must not exceed so you decided to some values in such a way that all remain integers and the inflation coefficients for each month don t exceed You know that the bigger changes the more obvious cheating That s why you need to minimize the total sum of changes What s the minimum total sum of changes you need to make all inflation coefficients not more than ,Suppose we decided to increase some by How does it affect all inflation coefficients Let s the th inflation coefficient be We now that If then doesn t change If then it s denominator increases by and decreases If then it s numerator increases and increases as well But if we increase instead of then all decreased will decrease as well and also will decrease Finally if we increase then all decrease and there is no that increases so it s always optimal to increase only Now we need to calculate what is minimum we should add to There are two ways we can either binary search this value knowing that is always enough Then we just need to check that all that is equivalent to checking that Or we can note that each and we need to make or that or Since we should fulfill all conditions then we should take as maximum over all fractions Since is just a prefix sum we can check condition for each in It total the time complexity is either or per test case 
A one dimensional Japanese crossword can be represented as a binary string of length An encoding of this crossword is an array of size where is the number of segments formed completely of s and is the length of th segment No two segments touch or intersect For example If and the crossword is then its encoding is an array If and the crossword is then its encoding is an array If and the crossword is then its encoding is an array If and the crossword is then its encoding is an empty array Mishka wants to create a new one dimensional Japanese crossword He has already picked the length and the encoding for this crossword And now he needs to check if there is crossword such that its length and encoding are equal to the length and encoding he picked Help him to check it ,The only answer is when no segment can be moved one cell either to the left or to the right So there should be exactly one cell between two consecutive segments and the first and the last segments should touch the borders Thus total count of cells needed is Overall complexity 
You are standing on the axis at point and you want to move to an integer point You can make several jumps Suppose you re currently at point may be negative and jump for the th time You can either jump to the point or jump to the point What is the minimum number of jumps you need to reach the point ,At first let s jump with while is still greater than the current position Now we finished in some position Note that otherwise we wouldn t make the last step If then we are lucky to finish right in point Otherwise let s look at what happens if we replace one with Basically we ll finish in And since then We know that so if then we can choose the corresponding and replace with and get straight to the point But if then we need one extra operation To calculate fast we can note we need at least since and then we can increase while 
Vadim is really keen on travelling Recently he heard about kayaking activity near his town and became very excited about it so he joined a party of kayakers Now the party is ready to start its journey but firstly they have to choose kayaks There are people in the group including Vadim and they have exactly tandem kayaks each of which obviously can carry two people and single kayaks th person s weight is and weight is an important matter in kayaking if the difference between the weights of two people that sit in the same tandem kayak is too large then it can crash And of course people want to distribute their seats in kayaks in order to minimize the chances that kayaks will crash Formally the instability of a single kayak is always and the instability of a tandem kayak is the absolute difference between weights of the people that are in this kayak Instability of the whole journey is the total instability of all kayaks Help the party to determine minimum possible total instability ,Firstly let s learn how to split persons in pairs as if there are no single kayaks Let there be people with weights and Obviously the lowest instability you can achieve is Swapping any two elements will only make the result greater This greedy strategy can be used to distribute all the seats Now you need to check every pair of persons to seat in single kayaks and calculate total instability for the rest The answer will be the minimun instabily over all pairs Overall complexity 
Ivan plays an old action game called Heretic He s stuck on one of the final levels of this game so he needs some help with killing the monsters The main part of the level is a large corridor so large and narrow that it can be represented as an infinite coordinate line The corridor is divided into two parts let s assume that the point is where these parts meet The right part of the corridor is filled with monsters for each monster its initial coordinate is given and since all monsters are in the right part every is positive The left part of the corridor is filled with crusher traps If some monster enters the left part of the corridor or the origin so its current coordinate becomes to it gets instantly killed by a trap The main weapon Ivan uses to kill the monsters is the Phoenix Rod It can launch a missile that explodes upon impact obliterating every monster caught in the explosion and throwing all other monsters away from the epicenter Formally suppose that Ivan launches a missile so that it explodes in the point Then every monster is either killed by explosion or pushed away Let some monster s current coordinate be then if then the monster is killed if then the monster is pushed units to the left so its current coordinate becomes if then the monster is pushed units to the right so its current coordinate becomes Ivan is going to kill the monsters as follows choose some integer point and launch a missile into that point then wait until it explodes and all the monsters which are pushed to the left part of the corridor are killed by crusher traps then if at least one monster is still alive choose another integer point probably the one that was already used and launch a missile there and so on What is the minimum number of missiles Ivan has to launch in order to kill all of the monsters You may assume that every time Ivan fires the Phoenix Rod he chooses the impact point optimally You have to answer independent queries ,Notice the following fact it s never optimal to fire a missile at such a position that there are monsters to the right of it That suggests the next solution sort the positions leave only the unique ones and process to shoot at the rightmost alive monster until every monster is dead Position of some monster after shots are made is the original position minus because the monster could only be pushed to the left Overall complexity 
You are given a chess board with rows and columns Initially all cells of the board are empty and you have to put a white or a black knight into each cell of the board A knight is a chess piece that can attack a piece in cell from the cell if one of the following conditions is met and or and Here are some examples of which cells knight can attack In each of the following pictures if the knight is currently in the blue cell it can attack all red cells and only them A is a pair of knights of colors such that these knights attack each other You have to put a knight a white one or a black one into each cell in such a way that the number of duels is maximum possible ,Let s denote a cell as if is even otherwise the cell is It s easy to see that if a knight is occupying a black cell then all cells attacked by it are white and vice versa Using this fact we can construct a solution where every pair of knights that attack each other have different colors put black knights into black cells and white knights into white cells so every pair of knights that can possibly form a duel actually form it 
You might have heard about the next game in Lara Croft series coming out this year You also might have watched its trailer Though you definitely missed the main idea about its plot so let me lift the veil of secrecy Lara is going to explore yet another dangerous dungeon Game designers decided to use good old 2D environment The dungeon can be represented as a rectangle matrix of rows and columns Cell is the cell in the th row in the th column Lara can move between the neighbouring by side cells in all four directions Moreover she has even chosen the path for herself to avoid all the traps She enters the dungeon in cell that is top left corner of the matrix Then she goes down all the way to cell the bottom left corner Then she starts moving in the snake fashion all the way to the right one cell up then to the left to the cell in nd column one cell up She moves until she runs out of non visited cells and given are such that she always end up in cell Lara has already moved to a neighbouring cell times Can you determine her current position ,Naive solution would be just simulate the tranversal and break when steps are made Obviously this won t fit into time limit Then we can decompose the path to some parts which can be calculated separately Walk from the top left to the bottom left corner Walk from second column to th on even rows Walk from th column to second on odd rows If then it s the first part Otherwise you can use the fact that rows are of the same length will tell you the row and will get you the number of steps Lara have made along this row Overall complexity 
Your friend Mishka and you attend a calculus lecture Lecture lasts minutes Lecturer tells theorems during the th minute Mishka is really interested in calculus though it is so hard to stay awake for all the time of lecture You are given an array of Mishka s behavior If Mishka is asleep during the th minute of the lecture then will be equal to otherwise it will be equal to When Mishka is awake he writes down all the theorems he is being told during the th minute Otherwise he writes nothing You know some secret technique to keep Mishka awake for minutes straight However you can use it You can start using it at the beginning of any minute between and If you use it on some minute then Mishka will be awake during minutes such that and will write down all the theorems lecturer tells You task is to calculate the maximum number of theorems Mishka will be able to write down if you use your technique to wake him up ,Let s iterate over all from to and if is equal to then add to the some variable and replace with Then answer will be equal to where can be easily calculated with prefix sums for each 
You are given a string consisting only of lowercase Latin letters You can rearrange all letters of this string as you wish Your task is to obtain a string by rearranging the letters of the given string or report that it is impossible to do it Let s call a string if it is not a palindrome Palindrome is a string which is read from left to right the same as from right to left For example strings and are palindromes and strings are not You have to answer queries ,The only case when the answer is is when all letters of the string are equal Why is it so Because if we have at least two different letters we can place the first one at the first position of the string and the second one at the last position of the string Then it is clearly that the obtained string is We can implement this solution by the following way sort and if the first letter equals to the last one then the answer is otherwise the answer is 
The letters shop showcase is a string consisting of lowercase Latin letters As the name tells letters are sold in the shop Letters are sold one by one from the leftmost to the rightmost Any customer can only buy some prefix of letters from the string There are friends the th of them is named Each of them is planning to estimate the following value how many letters the length of the shortest prefix would s he need to buy if s he wanted to construct her his name of bought letters The name can be constructed if each letter is presented in the equal or greater amount For example for and letters have to be bought For example for and letters have to be bought For example for and letters have to be bought For example for and letters have to be bought For example for and all letters have to be bought It is guaranteed that every friend can construct her his name using the letters from the string Note that the values for friends are independent friends are only estimating them but not actually buying the letters ,Let s construct the answer letter by letter How to get enough letters a for the name Surely the taken letters will be the first a the second a up to th a in string where is the amount of letters a in the name It s never profitable to skip the letter you need Do the same for all letters presented in the name The answer will the maximum position of these last taken letters How to obtain the th letter fast Well just precalculate the list of positions for each letter and take the needed one from it Overall complexity 
Recently you bought a brand new smart lamp with programming features At first you set up a schedule to the lamp Every day it will turn power on at moment and turn power off at moment Moreover the lamp allows you to set a program of switching its state states are lights on and lights off Unfortunately some program is already installed into the lamp The lamp allows only programs Good program can be represented as a non empty array where All must be integers Of course preinstalled program is a good program The lamp follows program in next manner at moment turns power and light on Then at moment the lamp flips its state to opposite if it was lit it turns off and vice versa The state of the lamp flips instantly for example if you turn the light off at moment and then do nothing the total time when the lamp is lit will be Finally at moment the lamp is turning its power off regardless of its state Since you are not among those people who read instructions and you don t understand the language it s written in you realize after some testing the only possible way to alter the preinstalled program You can element into the program so it still should be a program after alteration Insertion can be done between any pair of consecutive elements of or even at the begining or at the end of Find such a way to alter the program that the total time when the lamp is lit is maximum possible Maybe you should leave program untouched If the lamp is lit from till moment then its lit for units of time Segments of time when the lamp is lit are summed up ,At first let s insert and in array so all possible positions for inserting will always belong to At second let be value to insert and It can be proven that it s always optimal to move to or to So for each we need to check only and To check it fast enough we need to know total time of lamp is lit for each prefix and precalculate for each total time of lamp is lit if starting from light is on lights is off Result complexity is 
A robot is placed in a cell of an infinite grid This robot has adjustable length legs Initially its legs have length Let the robot currently be in the cell and have legs of length In one move it can perform one of the following three actions jump into the cell jump into the cell increase the length of the legs by i e set it to What s the smallest number of moves robot has to make to reach a cell ,Let s fix the number of leg length increases we do Let the final length be k Notice that for all i from 1 to k there is some time when the length is exactly i Thus we can perform jumps of form x y rightarrow x i y or x y rightarrow x y i What s the jumping strategy then Obviously we can solve the problem independently for a and b Consider a We would love to just make jumps of length k as that s the maximum possible length Unfortunately that only works when a is divisible by k Otherwise we are left with some remainder which is smaller than k But we have already figured out how to jump to any value from 1 to k So that only adds another jump You can say that the total number of jumps is lceil frac a k rceil Same for b Finally for a fixed k the answer is lceil frac a k rceil lceil frac b k rceil k 1 The constraints tell us that we are not allowed to iterate over all k from 1 to max a b It feels like huge k will never be optimal but let s try to base our intuition on something Try to limit the options by studying the formula Let s simplify Assume a b and also get rid of the ceil Not like that changes the formula a lot Now it becomes 2 frac a k k 1 We can see that when we increase k 2 frac a k becomes smaller and k 1 becomes larger However we care more about how fast they become smaller and larger You can just guess or write down the derivative explicitly and figure out that the first term shrinks faster than the second term grows until around sqrt a cdot c for some constant c apparently c sqrt 2 Thus their sum decreases until then then increases Thus you can search for the best k around sqrt a or sqrt b or sqrt max a b It doesn t really matter since for implementation you can basically try all k until around 10 5 which is safely enough 
Luba has a ticket consisting of digits In one move she can choose digit in any position and replace it with arbitrary digit She wants to know the minimum number of digits she needs to replace in order to make the ticket lucky The ticket is considered lucky if the sum of first three digits equals to the sum of last three digits ,Let s iterate over all 6 digit numbers Now we will calculate number of positions in which digit of current ticket differs from digit of input ticket and call it Then answer will be minimal value over all lucky tickets 
Recently Petya walked in the forest and found a magic stick Since Petya really likes numbers the first thing he learned was spells for changing numbers So far he knows only two spells that can be applied to a integer If the chosen number is even then the spell will turn it into If the chosen number is greater than one then the spell will turn it into Note that if the number is even and greater than one then Petya can choose which spell to apply Petya now has only one number He wants to know if his favorite number can be obtained from using the spells he knows The spells can be used any number of times in any order It is not required to use spells Petya can leave as it is , cannot be transformed into any other number can be transformed into or and can be transformed only into It means that if then only is reachable and if or then should be less than Otherwise we can make as large as we want so if any is reachable 
After returning from the army Makes received a gift an array consisting of positive integer numbers He hadn t been solving problems for a long time so he became interested to answer a particular question how many triples of indices such that is minimum possible are there in the array Help him with it ,Minimal product is obtained by multiplying three smallest elements of the array Let s iterate over the middle element of these three and calc sum of all options Firstly let s precalc two arrays of pairs and is minimum and number of its occurrences on the prefix of array up to index inclusive is minimum and number of its occurrences on the suffix of array up to index inclusive It can be done with two traversals over the array Let s also store set of three elements which give minimal product of the array Consider every index from to inclusive 0 indexed If set is equal to the stored set of three minimums then add to the answer number of ways to choose pair that is Overall complexity 
Polycarp takes part in a math show He is given tasks each consists of subtasks numbered through It takes him minutes to solve the th subtask of any task Thus time required to solve a subtask depends only on its index but not on the task itself Polycarp can solve subtasks in any order By solving subtask of arbitrary problem he earns one point Thus the number of points for task is equal to the number of solved subtasks in it Moreover if Polycarp solves the task solves all of its subtasks he recieves one extra point Thus total number of points he recieves for the complete solution of the task is Polycarp has minutes of time What is the maximum number of points he can earn ,Constraints tell us that we can avoid making any weird assumptions for any greedy solutions You can easily count the answer for some fixed amount of tasks completed Just sort all left subtasks but the longest to solve in each uncompleted task and take the easiest till the time is over Now you can iterate from to tasks completed and take maximum over all options Overall complexity 
For a square matrix of integers of size let s define its as follows for each pair of side adjacent elements and write out the number and then find the number of different numbers among them For example for the matrix the numbers we consider are and there are different numbers among them and which means that its beauty is equal to You are given an integer You have to find a matrix of size where each integer from to occurs exactly once such that its is the maximum possible among all such matrices ,The first step is to notice that beauty doesn t exceed because the minimum difference between two elements is at least and the maximum difference does not exceed the difference between the maximum element and the minimum element At first finding a matrix with maximum beauty seems to be a quite difficult task So let s try to find an array of elements of maximum beauty In this case it is not difficult to come up with an array of the form In such an array there are all possible differences from to So we found an array with the maximum possible beauty It remains to find a way to convert the array to the matrix i e to find such a sequence of matrix cells that each two adjacent cells in it are side adjacent One of the ways is the following traverse the first row of the matrix from left to right go down to the second row traverse it from right to left go down to the third row traverse it from left to right and so on Thus we constructed a matrix with the maximum possible beauty 
You are given a string of length consisting only of the characters and You perform the following operation until the string becomes empty choose some substring of characters erase it from the string and glue the remaining two parts together any of them can be empty in the same order For example if you erase the substring from the string you will get the string When you delete a substring of length you get points Your task is to calculate the maximum number of points that you can score in total if you have to make the given string empty ,Let be the length of the substring deleted at the th step Then the number of points will be equal to or The sum of all is equal to because in the end we deleted the entire string so the final formula has the form Obviously for you should delete the characters one by one so that Now and you have to delete the string in the minimum number of operations Let the string consist of blocks of zeros and ones then is the minimum number of operations for which the entire string can be deleted As long as the number of blocks is more than we will delete the second block the number of blocks will decrease by after each such operation the block that we delete will disappear and the first and third blocks will merge into one 
You have a Petri dish with bacteria and you are preparing to dive into the harsh micro world But unfortunately you don t have any microscope nearby so you can t watch them You know that you have bacteria in the Petri dish and size of the th bacteria is Also you know intergalactic positive integer constant The th bacteria can swallow the th bacteria if and only if and The th bacteria disappear but the th bacteria doesn t change its size The bacteria can perform multiple swallows On each swallow operation any bacteria can swallow any bacteria if and The swallow operations go one after another For example the sequence of bacteria sizes and The one of possible sequences of swallows is In total there are bacteria remained in the Petri dish Since you don t have a microscope you can only guess what the minimal possible number of bacteria can remain in your Petri dish when you finally will find any microscope ,It can be proved that the optimal answer equals to a number of bacteria which can t be eaten by any other bacteria So for each bacteria you need to check existence of any bacteria satisfying condition There plenty of ways to check this condition One of them is to sort array and for each find minimal with or with two pointers technique Or you can use the fact that and build solution around it Result complexity is 
Many years ago Berland was a small country where only people lived Each person had some savings the th one had burles The government considered a person as wealthy if he had at least burles To increase the number of wealthy people Berland decided to carry out several reforms Each reform looked like that the government chooses some subset of people maybe all of them the government takes all savings from the chosen people and redistributes the savings among the chosen people equally For example consider the savings as list if the government chose the st and the rd persons then it at first will take all burles and after that will return burles to the chosen people As a result the savings will become A lot of data was lost from that time so we don t know how many reforms were implemented and to whom All we can do is ask you to calculate the maximum possible number of wealthy people after several maybe zero reforms ,In fact to carry out only one reform is always enough And it s easy to prove if you make only one reform it s always optimal to take the maximum such that the average of maximums in the array is at least i e sum greater or equal to So the solution is next sort array and find the suffix with maximum length such that the sum on the suffix is at least To prove the fact about one reform we can prove another fact after each reform the sum of maximums doesn t increase for each We ll prove it in two steps The first step Let s look at some reform and form an array from the chosen elements in in descending order After the reform we ll get array where all Let s just skip the proof and say it s obvious enough that for any The second step Let fix and divide array on two parts maximums as and other elements as And let s make the same division of the array after performing the reform on and So we need to prove that Suppose elements were chosen in the reform of them were in and now in If then we can think like maximum elements from elements in were replaced by the average and other were replaced by elements from Since and any element from is greater or equal to any element from then we proved that when If then let s look at and The has chosen elements and has so and we can prove that practically in the same way as before Obviously if and then Q E D The last step is easy let s prove that the only reform is enough The answer after several reforms is clearly equal to maximums which are at least But it means that the sum of maximums is at least therefore the sum of maximums in the initial array is at least So we can make them all at least by only one reform 
You are given a ternary string it is a string which consists only of characters and You can swap any two adjacent consecutive characters and i e replace with or vice versa or any two adjacent consecutive characters and i e replace with or vice versa For example for string we can perform the following moves Note than you cannot swap and vice versa You cannot perform any other operations with the given string excluding described above You task is to obtain the minimum possible lexicographically string by using these swaps arbitrary number of times String is lexicographically less than string if strings and have the same length if there exists some position where is the length of the string such that for every holds and ,Let s notice that described swaps allows us to place any character to any position of the string relative order of and obviously cannot be changed Let s remove all characters from the string and keep their count in some variable Now more profitable move is to place all the 1 characters right before the first character of and if there is no character in then place they after the end of the string 
You are given a decimal representation of an integer without leading zeros You have to perform the following reduction on it take two neighboring digits in and replace them with their sum without leading zeros if the sum is it s represented as a single For example if the possible reductions are choose the first and the second digits and replace them with the result is choose the second and the third digits and replace them with the result is also choose the third and the fourth digits and replace them with the result is still choose the fourth and the fifth digits and replace them with the result is What s the largest number that can be obtained ,Let s think how a reduction changes the length of There are two cases If two adjacent letters sum up to or greater then the length doesn t change Otherwise the length decreases by one Obviously if there exists a reduction that doesn t change the length then it s better to use it Which among such reduction should you choose Well notice that such a reduction always makes the number strictly smaller easy to see with some case analysis Thus the logical conclusion is to leave the longest possible prefix of untouched So the rightmost such reduction will change the number as little as possible If all reductions decrease the length then a similar argument can be applied The sum will be a single digit but a digit that is greater than or equal to the left one of the adjacent pair If it was just greater it s easy to see that the leftmost such reduction will make the number the largest possible The equal case adds more case analysis on top of the proof but the conclusion remains the same the leftmost reduction is the best one As an implementation note since all the reductions are of the same type the leftmost reduction always includes the first and the second digits Overall complexity per testcase 
You are given a string consisting only of characters 0 and 1 You have to choose a contiguous substring of and remove all occurrences of the character which is a strict minority in it from the substring That is if the amount of 0 s in the substring is strictly smaller than the amount of 1 s remove all occurrences of 0 from the substring If the amount of 1 s is strictly smaller than the amount of 0 s remove all occurrences of 1 If the amounts are the same do nothing You have to apply the operation What is the maximum amount of characters that can be removed ,Let s try to estimate the maximum possible answer Best case you will be able to remove either all zeros or all ones from the entire string Whichever has the least occurrences can be the answer If the amounts of zeros and ones in the string are different this bound is actually easy to reach just choose the substring that is the entire string If the amounts are the same the bound is impossible to reach Choosing the entire string will do nothing and asking a smaller substring will decrease the answer The smallest we can decrease the answer by is If you choose the substring that is the string without the last character you will decrease one of the amounts by one That will make the amounts different and the bound will be reached Overall complexity per testcase 
Your company was appointed to lay new asphalt on the highway of length You know that every day you can either repair one unit of the highway lay new asphalt over one unit of the highway or skip repairing Skipping the repair is necessary because of the climate The climate in your region is periodical there are days when the weather is good and if you lay new asphalt these days it becomes high quality pavement after that the weather during the next days is bad and if you lay new asphalt these days it becomes low quality pavement again good days bad days and so on You can be sure that you start repairing at the start of a good season in other words days are good You don t really care about the quality of the highway you just want to make sure that will have high quality pavement For example if the then at least units of the highway should have high quality if then at least units should have high quality What is the minimum number of days is needed to finish the repair of ,There are two conditions that should be met according to the statement On the one hand we should repair the whole highway so we must spend at least days to do it On the other hand at least half of it should have high quality pavement or at least units should be laid at good days How to calculate the minimum number of days name it as for the second condition to meet Note that the first days can be represented as several maybe zero blocks of days where exactly days in each block are good and some remaining days The because will not be minimum otherwise There are plenty of ways to calculate One of them is the following Firstly let s calculate the number of cycles we need Now if we just add it since it s exactly the or But if we added to last block and should subtract it or The answer is 
You are given an array consisting of integers Each position of the array is either locked or unlocked You can take the values on the unlocked positions rearrange them in any order and place them back into the unlocked positions You are not allowed to remove any values add the new ones or rearrange the values on the locked positions You are allowed to leave the values in the same order as they were For example let the underlined positions are locked You can obtain the following arrays and some others Let be a sequence of prefix sums of the array after the rearrangement So Let be the maximum such that If there are no such that then Your goal is to rearrange the values in such a way that is minimum possible Output the array after the rearrangement such that the value for it is minimum possible If there are multiple answers then print any of them ,Let s collect the prefix sums of the initial array How do they change if you swap two values in the array Let s swap values on positions and Prefix sums from to aren t changed Prefix sums from to are increased by note that if then these sums become smaller Finally prefix sums from to aren t changed as well Thus swapping two values will only increase some prefix sums but never decrease any of them That helps us see that the array such that all values on the unlocked positions are sorted in a non increasing order is the most optimal one Overall complexity per testcase 
Max wants to buy a new skateboard He has calculated the amount of money that is needed to buy a new skateboard He left a calculator on the floor and went to ask some money from his parents Meanwhile his little brother Yusuf came and started to press the keys randomly Unfortunately Max has forgotten the number which he had calculated The only thing he knows is that the number is divisible by You are given a string consisting of digits the number on the display of the calculator after Yusuf randomly pressed the keys Your task is to find the number of substrings which are divisible by A substring can start with a zero A substring of a string is a nonempty sequence of consecutive characters For example if string is then we have four substrings that are divisible by and For the string the answer is three As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,The key observation is that the number is divisible by if and only if its last two digits forms a number divisible by So to calculate the answer at first we should count the substrings of length one Now let s consider pairs of consecutive digits If they forms a two digit number that is divisible by we should increase the answer by the index of the right one 
You might have remembered Theatre square from the problem 1A Now it s finally getting repaved The square still has a rectangular shape of meters However the picture is about to get more complicated now Let be the th square in the th row of the pavement You are given the picture of the squares if then the th square in the th row should be if then the th square in the th row should be The black squares are paved already You have to pave the white squares There are two options for pavement tiles tiles each tile costs burles and covers exactly square tiles each tile costs burles and covers exactly adjacent squares of the What is the smallest total price of the tiles needed to cover all the white squares ,Notice that rows can be solved completely separately of each other Each tile takes either one or two squares but it s always in the same row So let s take a look at a single row There are sequences of dot characters separated by some asterisks Once again each of these sequences can be solved independently of the others Thus we have these empty strips of empty squares which when solved can be summed up into the whole answer There are two cases depending on if a is cheaper than two tiles If it is then we want to use of many tiles as possible So given we can place tiles and cover the rest squares with tiles If it isn t cheaper then we want to cover everything with tiles and never use ones So all should be The easier way to implement this might be the following Let s update the price of the tile with the minimum of and This way the first algorithm will produce exactly the same result of the second one in the case when a tile isn t cheaper than two ones Overall complexity per testcase 
You want to type the string consisting of lowercase Latin letters using your favorite text editor Notepad Notepad supports two kinds of operations append any letter of the string copy a substring of an already typed string and paste this substring of the string Can you type string in than operations ,Why does the problem ask us only to check if we can do less than operations instead of just asking the minimum amount That must be making the problem easier so let s focus our attention on that What if it was instead of Well then the problem would be trivial You can type the word letter by letter and be done in operations So we only have to save one operation In order to save at least one operation we have to use the copy operation and copy more than one character in that Let s take a closer look at any of the copy operations we do Basically it has to be a substring that has at least two non intersection occurrences in the string Thus if the string has any substring that has length at least two that appears at least twice in the string we can copy it and the answer will be That s still not enough to solve the problem we d have to check all substrings which is Let s think further Imagine we found a substring that works Let it have length Notice how you can remove its last character obtaining a substring of length and it will still occure in the same set of positions possibly even more occurrences will be found Remove characters until the substring has length Thus if any appropriate substring exists an appropriate substring of length also exists Finally we can check if there exists a substring of length that appears at least twice in the string so that the occurrences are at least apart That can be done with a set hashset or a map hashmap Some implementations might require careful handling of the substrings of kind and similar Overall complexity or per testcase 
You are given a chessboard of size It is filled with numbers from to in the following way the first numbers from to are written in the cells with even sum of coordinates from left to right from top to bottom The rest numbers from to are written in the cells with odd sum of coordinates from left to right from top to bottom The operation means division by rounded up For example the left board on the following picture is the chessboard which is given for and the right board is the chessboard which is given for You are given queries The th query is described as a pair The answer to the th query is the number written in the cell is the row is the column Rows and columns are numbered from to ,Let s see the following fact if we will decrease from all numbers written in cells with an odd sum of coordinates and write out the numbers obtained on the board from left to right from top to bottom the sequence will looks like for even for odd there is only one number at the end of the sequence but in general it does not matter Let s try to find out the answer for some query Let 1 indexed There is the position of our cell in order of the written sequence The first approximation of the answer is But now we are remember that we decreased from all numbers written in cells with an odd sum of coordinates So if is even then the answer is otherwise the answer is Note that you should be careful with integer overflow in C Java or similar languages 64 bit datatype is quite enough Time complexity 
You are given two integers and You may perform any number of operations on them possibly zero During each operation you should choose any positive integer and set or Note that you may choose different values of in different operations Is it possible to make and equal to simultaneously Your program should answer independent test cases ,Let s assume Then the answer is if two following conditions holds because after each operation the value does not change 
You are given sequence of integer numbers of length Your task is to find such subsequence that its sum is odd and maximum among all such subsequences It s guaranteed that given sequence contains subsequence with odd sum Subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements You should write a program which finds sum of the best subsequence ,The answer to this problem can be constructed this way Sum up all positive numbers Find maximum of negative odd numbers Find minimum of positive odd numbers If sum was even then subtract Overall complexity 
You are given points on a line with their coordinates Find the point so the sum of distances to the given points is minimal ,The function of the total distance is monotonic between any pair of adjacent points from the input so the answer is always in some of the given points We can use that observation to solve the problem by calculating the total distance for each point from the input and finding the optimal point The other solution uses the observation that the answer is always is the middle point by index in the sorted list of the given points The last fact is also can be easily proven 
A permutation of length is a sequence of integers from to such that each integer appears in it exactly once Let the fixedness of a permutation be the number of fixed points in it the number of positions such that where is the th element of the permutation You are asked to build a sequence of permutations starting from the identity permutation permutation Let s call it a permutation chain Thus is the th permutation of length For every from onwards the permutation should be obtained from the permutation by swapping any two elements in it not necessarily neighboring The fixedness of the permutation should be strictly lower than the fixedness of the permutation Consider some chains for that is a valid chain of length From to the elements on positions and get swapped the fixedness decrease from to that is not a valid chain The first permutation should always be for that is not a valid chain From to the elements on positions and get swapped but the fixedness increase from to that is a valid chain of length From to the elements on positions and get swapped the fixedness decrease from to From to the elements on positions and get swapped the fixedness decrease from to Find the longest permutation chain If there are multiple longest answers print any of them ,Ideally we would want the fixedness values to be That would make a chain of length However it s impossible to have fixedness of after one swap The first swap always makes a permutation with fixedness Okay how about then That turns out to always be achievable For example swap elements and then elements and then and and so on Overall complexity per testcase 
 children are standing in a circle and playing a game Children s numbers in clockwise order form a permutation of length It is an integer sequence such that each integer from to appears exactly once in it The game consists of steps On each step the current leader with index counts out people in clockwise order starting from the next person The last one to be pointed at by the leader becomes the new leader You are given numbers indices of leaders in the beginning of each step Child with number is the first leader in the game Write a program which will restore a possible permutation If there are multiple solutions then print any of them If there is no solution then print ,Let s show by construction that there can be no ambiguity in values of of the children who were leaders at least once except for probably the last leader If then on this step the value of taken was exactly Otherwise went over and in circle ended up to the left or in the same position So for this case should be Obviously counting cannot go over two or more times as this will result in We only need to check if all the numbers are unique and fill the unvisited children with remaining values to form the permutation Overall complexity 
You are given a permutation consisting of numbers a permutation is an array in which each element from to occurs exactly once You can perform the following operation choose some subarray contiguous subsegment of and rearrange the elements in it in any way you want But this operation cannot be applied to the whole array For example if and we want to apply the operation to the subarray the subarray containing all elements from the nd to the th then after the operation the array can become or for example Your task is to calculate the minimum number of operations described above to sort the permutation in ascending order ,To solve the problem it is enough to consider several cases if the array is already sorted the answer is if or then you can sort the array in one operation by selecting the subarray or if and you can perform the sequence of operations and and sort the array on each of them you can t do it faster since you can t move both to position and to position in only operations otherwise the array can be sorted in operations 
You are given an integer You have to construct a permutation of size A is an array where each integer from to where is the size of permutation occurs exactly once For example is a permutation of size is a permutation of size is not a permutation the integer is absent is not a permutation the integer appears twice A of a permutation is a contiguous subsequence of that permutation For example the permutation has subsegments and The of the permutation is the number of its subsegments which are also permutations For example the value of is since the subsegments and are permutations You have to construct a permutation of size with among all permutations of size ,The subsegment as well as the whole permutation will always be a permutation so the value is at least Let s try to find a way to generate a permutation of elements with value equal to Every permutation must contain the number Let s try to construct the answer in such a way that if a subsegment contains the number then it also contains the number if it is so it can only be a permutation if it contains all numbers If we begin our permutation with the numbers and we will reach our goal the only subsegment which does not contain but contains is and the only subsegment which contains and also a permutation is the whole permutation itself So any permutation that begins with can be the answer 
Recall that a permutation of length is an array where each element from to occurs exactly once For a fixed positive integer let s define the cost of the permutation of length as the number of indices such that For example if and then the cost of such a permutation is because and Your task is the following one for a given value find the permutation of length and the value with maximum possible cost over all ways to choose the permutation and If there are multiple answers then print any of them ,Let s notice that for a fixed value of the answer the cost of permutation does not exceed because only numbers from to can have a pair It turns out that it is always possible to construct a permutation with the cost of exactly It is enough to consider the number chains of the form where It is not difficult to understand that each number is included in exactly one such chain Therefore if we append the chains one after another then in such a permutation the answer will be equal to because all numbers will have a pair except the last element in the chain The number of chains is equal to which means the cost of the permutation is equal to By choosing the permutation will have the maximum possible cost 
There are pillars aligned in a row and numbered from to Initially each pillar contains exactly one disk The th pillar contains a disk having radius You can move these disks from one pillar to another You can take a disk from pillar and place it on top of pillar if all these conditions are met there is no other pillar between pillars and Formally it means that pillar contains one disk either pillar contains no disks or the topmost disk on pillar has radius strictly greater than the radius of the disk you move When you place a disk on a pillar that already has some disks on it you put the new disk on top of previously placed disks so the new disk will be used to check the third condition if you try to place another disk on the same pillar You may take any disk and place it on other pillar any number of times provided that every time you do it all three aforementioned conditions are met Now you wonder is it possible to place all disks on the same pillar simultaneously ,Suppose we have a disk that is smaller than both of its neighbours Then it s impossible to collect all the disks on the same pillar eventually we will put this disk on the same pillar with one of its neighbours and then we can t put the other neighbouring disk on the same pillar since it is greater than the middle disk Okay and what if there is no disk that is strictly smaller than both of its neighbours Let k be the index of the largest disk a k 1 a k that implies a k 2 a k 1 and so on a k 1 a k a k 2 a k 1 and so on It means that the array a is sorted in ascending until the index k and after that it is sorted in descending order If this condition is met then we can collect all the disks on the pillar k one by one starting with the disk having radius n 1 and ending with the disk having radius 1 So the only thing that we need to check is the following condition array a is sorted in ascending order until a k n and then it is sorted in descending order 
You are given a two dimensional plane and you need to place chips on it You can place a chip only at a point with integer coordinates The cost of placing a chip at the point is equal to where is the absolute value of The cost of placing chips is equal to the among the costs of each chip You need to place chips on the plane in such a way that the Euclidean distance between each pair of chips is than and the cost is the minimum possible ,Suppose the answer is What s the maximum number of chips we can place Firstly the allowed points to place chips are such that We can group them by coordinate for there is only one for possible are for possible are in segment and so on For possible are in The negative s are the same Let s calculate the maximum number of chips we can place at each row for it s for there are three s but since we can t place chips at the neighboring s we can place at most chips for we have places but can place only chips for we have places but can occupy only points In total for we can place at most chips Analogically for we can place at most chips In total we can place at most chips with cost at most Note that can actually be reached since the distance between chips on the different rows is greater than So to solve our task it s enough to find minimum such that that can be done with Binary Search Or we can calculate Note that can lose precision since is cast to before taking the square root for example transforms to when converted to So you should either cast to that consists of bits in some C compilers or check value as a possible answer 
The King of Berland Polycarp LXXXIV has daughters To establish his power to the neighbouring kingdoms he wants to marry his daughters to the princes of these kingdoms As a lucky coincidence there are other kingdoms as well So Polycarp LXXXIV has enumerated his daughters from to and the kingdoms from to For each daughter he has compiled a list of kingdoms princes of which she wanted to marry Polycarp LXXXIV is very busy so he finds a couple for his daughters greedily one after another For the first daughter he takes and marries the daughter to their prince For the second daughter he takes If there are no free princes in the list then the daughter marries nobody and Polycarp LXXXIV proceeds to the next daughter The process ends after the th daughter For example let there be daughters and kingdoms the lists daughters have are respectively In that case daughter marries the prince of kingdom daughter marries the prince of kingdom daughter marries the prince of kingdom leaving daughter nobody to marry to Actually before starting the marriage process Polycarp LXXXIV has the time to convince one of his daughters that some prince is also worth marrying to Effectively that means that he can add exactly one kingdom to exactly one of his daughter s list Polycarp LXXXIV wants to increase the number of married couples Unfortunately what he doesn t have the time for is determining what entry to add If there is no way to increase the total number of married couples then output that the marriages are already optimal Otherwise find such an entry that the total number of married couples increases if Polycarp LXXXIV adds it If there are multiple ways to add an entry so that the total number of married couples increases then print any of them For your and our convenience you are asked to answer independent test cases ,Simulate the process without adding the new entry For this you can just maintain an array th value of which is true if the th prince is married and false otherwise Now observe that there are two possible outcomes Every daughter is married the answer is optimal There is a daughter who isn t married That means that there is a free prince as well Marry them to each other because doing that won t affect any other marriages and add a new one to the answer Overall complexity 
The store sells items the price of the th item is The store s management is going to hold a promotion if a customer purchases at least items cheapest of them are free The management has not yet decided on the exact values of and Therefore they ask you to process queries for the given values of and determine the maximum total value of items received for free if a customer makes Note that all queries are independent they don t affect the store s stock ,First of all there is an answer with exactly items bought Suppose items worth were purchased Then by removing from this set the sum of the cheapest items in the set will change by which means the answer will not decrease The second fact that is necessary to solve the problem of the most expensive items should be chosen Otherwise one can remove the minimum price item from the set and add an item with a higher price it can always be found which means the answer will not decrease Using these two facts it is enough to sort the array and use prefix sums 
Recently your friend discovered one special operation on an integer array Choose two indices and Set After playing with this operation for a while he came to the next conclusion For every array of integers where you can find a pair of indices such that the total sum of will after performing the operation This statement sounds fishy to you so you want to find a counterexample for a given integer Can you find such counterexample and prove him wrong In other words find an array consisting of integers such that for all pairs of indices performing the operation won t decrease the total sum it will increase or not change the sum ,Suppose the initial sum of is equal to If we perform the operation the new sum will be equal to We want the sum not to decrease or If we will get If we ll get analogically In other words array you need if sorted will have and so on And one of the variants and obviously an optimal one is just As a result since we just need to check if then we found an answer otherwise there is no counterexample 
You are given two arrays of integers and For each element of the second array you should find the number of elements in array that are less than or equal to the value ,Let s sort all numbers in a Now let s iterate over elements of b and for element bj find the index of lowest number that is greater than bj We can do that using binary search That index will be the answer for value bj Complexity O nlogn 
Monocarp had a sequence consisting of integers He painted the elements into two colors red and blue elements were painted red all other elements were painted blue After painting the elements he has written two sequences and The sequence consisted of all red elements of similarly the sequence consisted of all blue elements of Unfortunately the original sequence was lost and Monocarp only has the sequences and He wants to restore the original sequence In case there are multiple ways to restore it he wants to choose a way to restore that maximizes the value of Help Monocarp to calculate the maximum possible value of ,Denote as the sum of first elements of and as the sum of first elements of These values can be calculated in with prefix sums The first solution is to use dynamic programming Let be the maximum value of if we placed the first elements of and the first elements of Transitions can be performed in we either place an element from then we go to and update it with or place an element from then we go to and update it with The answer is stored in and this solution works in The second solution observe that the sum of several first elements of is the sum of several first elements of and several first elements of So each prefix sum of and the answer itself is not greater than It s easy to show how to obtain exactly this answer let be the value of such that is maximized and be the value of such that is maximized Let s place the first elements of then the first elements of so the current sum is exactly and place all of the remaining elements in any possible order So the answer is This solution works in 
You are given a set of all integers from to inclusive and is always odd You want to split these numbers into exactly pairs in such a way that for each pair the greatest common divisor of and is equal to Each number should appear in exactly one of the pairs Print the resulting pairs or output that no solution exists If there are multiple solutions print any of them ,Numbers with the difference of are always relatively prime That s the only thing I should mention for this editorial Overall complexity 
You are given a string of even length String is binary in other words consists only of s and s String has exactly zeroes and ones is even In one operation you can reverse any substring of A substring of a string is a contiguous subsequence of that string What is the minimum number of operations you need to make string A string is alternating if for all There are two types of alternating strings in general or ,We need to make our string alternating i e When we reverse substring we change no more than two pairs and Moreover one pair should be a consecutive pair and other So we can find lower bound to our answer as maximum between number of pairs of and number of pairs of And we can always reach this lower bound by pairing with or with left right border of Another way to count the answer is next suppose we want to make string then let s transform to For example if we will get We claim that after this transformation we will have equal number of and so the answer is the number of consecutive pairs of the same character divided by two The answer is the minimum between answers for and 
There is a field divided into rows and columns Some cells are empty denoted as other cells contain robots denoted as You can send a command to at the same time The command can be of one of the four types move up move right move down move left When you send a command attempt to take one step in the direction you picked If a robot tries to move outside the field it explodes otherwise moves to an adjacent cell in the chosen direction You can send as many commands as you want possibly zero in any order Your goal is to make at least one robot reach the upper left corner of the field Can you do this without forcing any of the robots to explode ,Let s assume that the rows are numbered from to from top to bottom and columns are numbered from to from left to right If there is no robot in the cell initially we have to perform several moves up and or left If the first row with at least one robot is the th row then we can make at most steps up and we should do at least steps up since otherwise there will me no robot in the upper row Similarly if the first column with at least one robot is the th column then we can make at most steps to the left and we should do at least steps to the left since otherwise there will me no robot in the leftmost column Now there are two possible solutions both starting with finding and we afterwards either simulate moves up and moves to the left and check that everything is fine or just check that there is a robot in the cell since only this robot can end up in 
You are playing one RPG from the 2010s You are planning to raise your smithing skill so you need as many resources as possible So how to get resources By stealing of course You decided to rob a town s blacksmith and you take a follower with you You can carry at most units and your follower at most units In the blacksmith shop you found swords and war axes Each sword weights units and each war axe units You don t care what to take since each of them will melt into one steel ingot What is the maximum number of weapons both swords and war axes you and your follower can carry out from the shop ,First iterate on the number of swords we will personally take Then we should greedily take as many war axes as we can until we run out of money At this point our follower needs to take as many items as possible They can do this by greedily taking whichever of swords or war axes are cheaper until they run out followed by taking the more expensive of the two Code 90918673 
Let s call a string if it is symmetric about the middle of the string For example the string is but the string is not The string is not because the second half of it is not a mirror reflection of the first half You are given a string Check if the string is ,In this problem you should simply find the symmetric letters by picture and also observe that the pairs and is the symmteric reflections 
Consider rows of the seats in a bus rows of the seats on the left and rows of the seats on the right Each row can be filled by two people So the total capacity of the bus is Consider that people occupy the seats in the bus The passengers entering the bus are numbered from to in the order of their entering the bus The pattern of the seat occupation is as below st row left window seat st row right window seat nd row left window seat nd row right window seat th row left window seat th row right window seat After occupying all the window seats for the non window seats are occupied st row left non window seat st row right non window seat th row left non window seat th row right non window seat All the passengers go to a single final destination In the final destination the passengers get off in the given order st row left non window seat st row left window seat st row right non window seat st row right window seat th row left non window seat th row left window seat th row right non window seat th row right window seat You are given the values and Output numbers from to the order in which the passengers will get off the bus ,In this problem you should simply do what was written in the problem statement There are no tricks 
You are given two strings and both consisting only of lowercase Latin letters The substring is the string which is obtained by taking characters without changing the order Each of the occurrences of string in a string is a position such that is the length of string You are asked queries for the th query you are required to calculate the number of occurrences of string in a substring ,Let s take a look at a naive approach for each query you iterate over positions and check if Okay this is obviously Now we notice that there are only positions for to start from we can calculate if there is an occurrence of starting in this position beforehand in Thus we transition to solution Finally we calculate a partial sum array over this occurrence check array and answer each query in Overall complexity 
Ayush is a cashier at the shopping center Recently his department has started a service which allows users to shop online The store contains items customers have already used the above service Each user paid for items Let denote the th item in the th person s order Due to the space limitations all the items are arranged in one single row When Ayush receives the th order he will find one by one all the items in the row Let denote the position of the item in the row at the moment of its collection Then Ayush takes time equal to for the th customer When Ayush accesses the th element he keeps a new stock in the front of the row and takes away the th element Thus the values are updating Your task is to calculate the total time it takes for Ayush to process all the orders You can assume that the market has endless stock ,In this problem you should simply do what was written in the problem statement There are no tricks 
You are given an array consisting of integers Initially all other elements are equal to You have to perform operations During the th operation you choose two indices and such that and swap and Calculate the number of indices such that it is possible to choose the operations so that in the end ,Let s consider how the set of possible indices where the can be changes Initially only one index is correct After performing an operation such that or this set does not change But after performing an operation such that we should insert the elements into this set if they are not present Now consider how the set changes If segments and do not share any indices there are no changes but if they do the set turns into So the set of reachable indices is always a segment of numbers and to process an operation we should check whether the segment from operation intersects with the segment of indices we have and if it is true unite them 
A permutation of length is an array which contains every integer from to inclusive exactly once For example is a permutation of length You are given three integers and where is an even number Print any permutation of length that the minimum among equals and the maximum among equals Print if no such permutation exists ,There are many different constructions that give the correct answer if it exists In my opinion one of the most elegant is the following one should always be present in the left half and should be present in the right half but the exact order of elements in each half doesn t matter So it will never be wrong to put in the first position and in the second position As for the remaining elements we want elements of the left half to be as big as possible since they shouldn t be less than and elements of the right half as small as possible since they shouldn t be greater than Let s put the elements excluding and on positions respectively so the elements in the left half are as big as possible and the elements in the right half are as small as possible After constructing a permutation according to these rules we should check if it meets the constraints and print it if it does 
You are given two matrices and Each matrix contains exactly rows and columns Each element of is either or each element of is initially You may perform some operations with matrix During each operation you choose any submatrix of having size and replace every element in the chosen submatrix with In other words you choose two integers and such that and and then set and to Your goal is to make matrix equal to matrix Two matrices and are equal if and only if every element of matrix is equal to the corresponding element of matrix Is it possible to make these matrices equal If it is you have to come up with a sequence of operations that makes equal to Note that you don t have to minimize the number of operations ,It is quite obvious that we can t choose any submatrix that contains at least one zero in The contrary is also true if a submatrix of consists of only ones then there s no reason not to choose it suppose there is an answer that does not choose it then choosing this submatrix won t affect it So we may perform an operation on every submatrix of such that the corresponding submatrix in is filled with s and check if our answer is correct 
Eve is a beginner stand up comedian Her first show gathered a grand total of two spectators Alice and Bob Eve prepared jokes to tell grouped by their type type 1 both Alice and Bob like them type 2 Alice likes them but Bob doesn t type 3 Bob likes them but Alice doesn t type 4 neither Alice nor Bob likes them Initially both spectators have their mood equal to When a spectator hears a joke he she likes his her mood increases by When a spectator hears a joke he she doesn t like his her mood decreases by If the mood of a spectator becomes negative strictly below zero he she leaves When someone leaves Eve gets sad and ends the show If no one leaves and Eve is out of jokes she also ends the show Thus Eve wants to arrange her jokes in such a way that the show lasts as long as possible Help her to calculate the maximum number of jokes she can tell before the show ends ,First let Eve tell the jokes of the first type they will never do any harm At the same time let her tell the jokes of the fourth time at the very end they will not do any good Types two and three are kind of opposites of each other If you tell jokes of each of them one after another then the moods of both spectators don t change Let s use that to our advantage Tell the jokes of these types in pairs until one of them runs out There s a little corner case here though If there were no jokes of the first type then you can t use a single pair because of the spectators leaves after one joke Finally try to tell the remaining jokes of the same type before the fourth type So the construction looks like with and possibly swapped with each other Let s recover the answer from that construction After the first type both moods are After the alternating jokes the moods are still the same After that one of the spectators will have his her mood only decreasing until the end Once it reaches the show ends Thus Eve can tell jokes if Otherwise it s always Overall complexity 
Let s define a multiplication operation between a string and a positive integer is the string that is a result of writing copies of one after another For example A string is divisible by another string if there exists an integer such that For example is divisible by but is not divisible by or LCM of two strings and defined as is the shortest non empty string that is divisible by both and You are given two strings and Find or report that it does not exist It can be shown that if exists it is unique ,We should notice that if some string is a multiple of string then is a multiple of This fact leads us to the conclusion that should be a common multiple of and Since we want to minimize the length of the string then its length is So we have to check that copies of the string equal to copies of the string If such strings are equal print them otherwise there is no solution 
You are given a string consisting of lowercase Latin letters You have to type this string using your keyboard Initially you have an empty string Until you type the whole string you may perform the following operation add a character to the end of the string Besides you may perform one additional operation copy the string and append it to itself For example if you have to type string you can type it in operations if you type all the characters one by one However you can type it in operations if you type the string first and then copy it and type the last character If you have to type string the best option is to type characters one by one then copy the string and then type the remaining character Print the minimum number of operations you need to type the given string ,Let s consider as a substring of string from position to position is not included Let s iterate over all lenghts of the copied prefix from to 0 inclusive and then if then answer will be and iterating over smaller lenghts is not necessary 
Alice and Bob play a game They have a binary string a string such that each character in it is either or Alice moves first then Bob then Alice again and so on During their move the player can choose any number not less than one of in and delete them For example if the string is there are possible moves deleted characters are bold After the characters are removed the characters to the left and to the right of the removed block become adjacent I e the following sequence of moves is valid The game ends when the string becomes empty and the score of each player is Each player wants to maximize their score Calculate the resulting score of Alice ,The following greedy strategy works during each turn delete the largest possible substring consisting of characters So we have to find all blocks of characters sort them according to their length and model which blocks are taken by Alice and which by Bob Why does the greedy strategy work It s never optimal to delete some part of the block of ones because we either have to spend an additional turn to delete the remaining part or allow our opponent to take it which is never good Why don t we need to delete zeroes If we delete a whole block of zeroes our opponent can take the newly formed block of s during their turn and it is obviously worse than taking a part of that block And deleting some part of a block of zeroes doesn t do anything our opponent will never delete the remaining part because it s suboptimal 
You are given a string of length consisting only of lowercase Latin letters A substring of a string is a contiguous subsequence of that string So string is substring of string but string is not Your task is to calculate the number of ways to remove one substring from this string in such a way that remaining characters are the number of distinct characters either zero or one It is guaranteed that there is different characters in Note that you remove the whole string and it is correct Also note that you should Since the answer can be rather large not very large though print it modulo ,Firstly let s calculate the length of the prefix of equal letters let it be and the length of the suffix of equal letters let it be It can be done with two cycles with breaks It is obvious that this prefix and suffix wouldn t overlap Then let s consider two cases the first one is when and the second one is when In the first case we can only remain either prefix or suffix of consisting only of equal letters Then the answer is because we can remain from to letters on the prefix from to on the suffix or empty string In the second case we can remain from to letters on the prefix and from to letters on the suffix But now because we can combine these ways so the answer is And the bonus this case is not belong to the given problem if all letters in the string are equal then then answer is because we can choose any substring of of length at least and any substring of length 
You are given switches and lamps The th switch turns on some subset of the lamps This information is given as the matrix consisting of rows and columns where if the th switch turns on the th lamp and if the th switch is not connected to the th lamp Initially all lamps are turned off Switches change state only from off to on It means that if you press two or more switches connected to the same lamp then the lamp will be turned on after any of this switches is pressed and will remain its state even if any switch connected to this lamp is pressed afterwards It is guaranteed that if you push all switches then Your think that you have too many switches and you would like to ignore one of them Your task is to say if there exists such a switch that if you will ignore not use it but press all the other switches then all the lamps will be turned on ,Let s maintain an array of size where will be equal to the number of switches that are connected to the th lamp Then answer will be if and only if there exists some switch such that for each lamp that is connected to this switch Otherwise the answer will be 
Recently students from city S moved to city P to attend a programming camp They moved there by train In the evening all students in the train decided that they want to drink some tea Of course no two people can use the same teapot simultaneously so the students had to form a queue to get their tea th student comes to the end of the queue at the beginning of th second If there are multiple students coming to the queue in the same moment then the student with greater index comes after the student with lesser index Students in the queue behave as follows if there is nobody in the queue before the student then he uses the teapot for exactly one second and leaves the queue with his tea otherwise the student waits for the people before him to get their tea If at the beginning of th second student still cannot get his tea there is someone before him in the queue then he leaves the queue without getting any tea For each student determine the second he will use the teapot and get his tea if he actually gets it ,Let s store the last moment when somebody gets a tea in the variable Then if for the th student then he will not get a tea Otherwise he will get it during second And if he gets a tea then will be replaced with the answer for this student 
You are given a string such that each its character is either or You have to choose the shortest contiguous substring of such that it contains each of these three characters at least once A contiguous substring of string is a string that can be obtained from by removing some possibly zero characters from the beginning of and some possibly zero characters from the end of ,There are multiple solutions involving advanced methods such as binary search or two pointers but I ll try to describe a simpler one The main idea of my solution is that the answer should look like one character of type a block of characters of type and one character of type If we find all blocks of consecutive equal characters in our string each candidate for the answer can be obtained by expanding a block to the left and to the right by exactly one character So the total length of all candidates is and we can check them all Why does the answer look like If the first character of the substring appears somewhere else in it it can be deleted The same applies for the last character So the first and the last characters should be different and should not appear anywhere else within the string Since there are only three types of characters the answer always looks like 
Emily s birthday is next week and Jack has decided to buy a present for her He knows she loves books so he goes to the local bookshop where there are books on sale from one of genres In the bookshop Jack decides to buy Based on the genre of books on sale in the shop find the number of options available to Jack for choosing two books of different genres for Emily Options are considered different if they differ in at least one book The books are given by indices of their genres The genres are numbered from to ,Let s denote cnti the number of books of i th genre The answer to problem is equals to In first sum we are calculating the number of good pairs while in second we are subtracting the number of bad pairs from the number of all pairs Complexity O n m2 or O n m 
There is a grid You are standing at cell and your goal is to finish at cell You can move to the neighboring cells to the right or down In other words suppose you are standing at cell You can move right to the cell it costs burles move down to the cell it costs burles Can you reach cell spending burles ,Note that whichever path you choose the total cost will be the same If you know that the cost is the same then it s not hard to calculate it It s equal to So the task is to check is equal to or not The constant cost may be proved by induction on for cost is For a fixed there are only two last steps you can make either from with cost the total cost is or from with cost the total cost is So whichever path you choose the total cost is the same 
 year in Berland is such a year that its number can be represented as where and are non negative integer numbers For example if and then the years and are and year isn t as there is no such representation for it Such interval of years that there are no years in it is called You should write a program which will find maximum length of which starts no earlier than the year and ends no later than the year If all years in the interval are then the answer is ,Notice that for has no more than powers which give numbers no greater than So let s store all possible sums of all powers of and Now the answer to the query can be obtained in linear time by checking difference between neighbouring unlucky years in sorted order Don t forget that you should handle multiplying of such big numbers very carefully For example instead of writingwhile num 1e18 num num xorwhile num x 1e18 num num xyou should writewhile num 1e18 x num num xto avoid getting overflow errors of 64 bit type Integer division will work fine in that case because will never exceed if doesn t exceed Overall complexity 
Vova is again playing some computer game now an RPG In the game Vova s character received a quest to slay the fearsome monster called Modcrab After two hours of playing the game Vova has tracked the monster and analyzed its tactics The Modcrab has health points and an attack power of Knowing that Vova has decided to buy a lot of strong healing potions and to prepare for battle Vova s character has health points and an attack power of Also he has a large supply of healing potions each of which increases his current amount of health points by when Vova drinks a potion All potions are identical to each other It is guaranteed that The battle consists of multiple phases In the beginning of each phase Vova can either attack the monster thus reducing its health by or drink a healing potion it increases Vova s health by Then the Modcrab attacks Vova reducing his health by The battle ends when Vova s or Modcrab s health drops to or lower It is possible that the battle ends in a middle of a phase after Vova s attack Of course Vova wants to win the fight But also he wants to do it as fast as possible So he wants to make up a strategy that will allow him to win the fight after the minimum possible number of phases Help Vova to make up a strategy You may assume that Vova never runs out of healing potions and that he can always win ,A simple greedy solution works simulate the process until the Modcrab is dead and make Vova drink a potion if his current health is less than and monster s current health is greater than because in this case Vova can t finish the Modcrab in one strike but the Modcrab can win if Vova doesn t heal In any other situation Vova must attack Since all parameters are up to the number of phases won t exceed 
The girl Taylor has a beautiful calendar for the year In the calendar all days are given with their days of week Monday Tuesday Wednesday Thursday Friday Saturday and Sunday The calendar is so beautiful that she wants to know what is the next year after when the calendar will be exactly the same Help Taylor to find that year Note that leap years has days The year is leap if it is divisible by or it is divisible by but not by https en wikipedia org wiki Leap year ,Two calendars are same if and only if they have the same number of days and starts with the same day of a week So we should simply iterate over years and maintain the day of a week of January 1st for example Easy to see that the day of a week increases by one each year except of the leap years when it increases by two 
You are given the current time in hour format Find and print the time after minutes Note that you should find only the time after minutes see the examples to clarify the problem statement You can read more about hour format here https en wikipedia org wiki 24 hour clock ,In this problem we can simply increase times the current time by one minute after each increasing we should check the hours and the minutes for overflow Another solution is to use the next formulas as the answer 
You are asked to watch your nephew who likes to play with toy blocks in a strange way He has boxes and the th box has blocks His game consists of two steps he chooses an arbitrary box he tries to move blocks from the th box to other boxes If he can make the same number of blocks in each of other boxes then he will be happy otherwise will be sad Note that your nephew can only move the blocks from the chosen box to the other boxes he cannot move blocks from the other boxes You don t want to make your nephew sad so you decided to put several extra blocks into some boxes in such a way that no matter which box he chooses he won t be sad What is the minimum number of extra blocks you need to put ,Since nephew emptying the box he s chosen and wants to make all other box equal then it means that at least the of all array should be divisible by and the number of blocks in each other box should be at least ceiling function On the other side since nephew chooses not you then he can choose a box which is a maximum and since he makes empty the only box then the final number in each other block should be at least In total the resulting number of blocks in each of other boxes should be at least and we need to add at least elements to the initial array We can always reach this lower bound if we will put each block in the box with the current minimum number of blocks 
A rectangle with its opposite corners in and and sides parallel to the axes is drawn on a plane You are given a list of lattice points such that each point lies on a side of a rectangle but not in its corner Also there are at least two points on every side of a rectangle Your task is to choose three points in such a way that exactly two of them belong to the same side of a rectangle the area of a triangle formed by them is maximum possible Print the doubled area of this triangle It can be shown that the doubled area of any triangle formed by lattice points is always an integer ,The area of a triangle is equal to its base multiplied by its height divided by Let the two points that have to be on the same side of a rectangle form its base To maximize it let s choose such two points that are the most apart from each other the first and the last in the list Then the height will be determined by the distance from that side to the remaining point Since there are points on all sides the points on the opposite side are the furthest Thus the height is always one of or depending on whether we picked the horizontal or the vertical side So we have to check four options to pick the side and choose the best answer among them 
It s New Year s Eve soon so Ivan decided it s high time he started setting the table Ivan has bought two cakes and cut them into pieces the first cake has been cut into pieces and the second one into pieces Ivan knows that there will be people at the celebration including himself so Ivan has set plates for the cakes Now he is thinking about how to distribute the cakes between the plates Ivan wants to do it in such a way that all following conditions are met Each piece of each cake is put on some plate Each plate contains at least one piece of cake No plate contains pieces of both cakes To make his guests happy Ivan wants to distribute the cakes in such a way that the minimum number of pieces on the plate is maximized Formally Ivan wants to know the maximum possible number such that he can distribute the cakes according to the aforementioned conditions and each plate will contain at least pieces of cake Help Ivan to calculate this number ,Let s fix number of plates to have pieces of the first cake plates left for the other cake Obviously the most optimal way to distribute pieces to plates will lead to the minimum of pieces on a plate Now try every possible and take maximum of Overall complexity 
You have an axis aligned rectangle room with width and height so the lower left corner is in point and the upper right corner is in There is a rectangular table standing in this room The sides of the table are parallel to the walls the lower left corner is in and the upper right corner in You want to place another rectangular table in this room with width and height with the width of the table parallel to the width of the room The problem is that sometimes there is not enough space to place the second table without intersecting with the first one there are no problems with tables touching though You any of the tables but you can move the first table inside the room What is the minimum distance you should move the first table to free enough space for the second one ,Firstly let s notice the next property if two axis aligned rectangles don t intersect then we can draw a vertical or horizontal line between them In other words either max x 1 x 2 le min x 3 x 4 or max x 3 x 4 le min x 1 x 2 if x 1 and x 2 are coordinates of the one rectangle and x 3 and x 4 of the other one analogically for y coordinates Now suppose you want to move the first table by dx dy Note that if in result they will be divided by vertical line then we can set dy 0 they still will be divided but the total distance will decrease Analogically if divided by horizontal line we can set dx 0 In other words it s always optimal to move the table either horizontally or vertically Let s look at the case of horizontal move at first we need to check that both tables can fit in the room or their total width w x 2 x 1 le W If yes then we calculate the movement distance dx as follows if we move the table right then there should be at least w to the left of it or w le x 1 dx Leftrightarrow dx ge w x 1 Since we want to minimize dx then we take dx max 0 w x 1 If we want to move the table left then there should be at least w to the right or x 2 dx le W w Leftrightarrow dx ge x 2 W w minimizing dx means taking dx max 0 x 2 W w So the result is min max 0 w x 1 max 0 x 2 W w The vertical case can be handled in the same manner if h y 2 y 1 le H then the result is min max 0 h y 1 max 0 y 2 H h The answer is the minimum among all possible variants or 1 if both cases are impossible 
You are given a string consisting of lowercase Latin letters A pair of letters in a string is considered ugly if these letters are also in a alphabet For example string contains ugly pairs at positions and Letters and aren t considered neighbouring in a alphabet Can you rearrange the letters of a given string so that there are no ugly pairs You can choose any order of the letters of the given string but you can t add any new letters or remove the existing ones You can also leave the order the same If there are multiple answers print any of them You also have to answer separate queries ,To be honest the solution to this problem is easier to code than to prove Let s follow the next strategy Write down all the letters of the string which have odd positions in alphabet and even positions in alphabet Sort both of these lists in non decreasing order The answer is either concatenation of the lists odd even or even odd or Now for the proof part Let s establish that we don t care about equal letters and leave just a single copy of each letter of the string Let s check some cases There is just a single letter That s trivial There are two letters of the same parity There is no incorrect arrangement for this There are two letters of different parity If they differ by one then no answer exists Otherwise any arrangement works There are three letters and they are consecutive in alphabet No answer exists There are other types of three letters Then the one of the different parity can put on the side e g and As the difference between at least one of these letters and that one isn t 1 that arrangement will be ok Finally there are at least 4 letters It means that the difference between either the smallest odd and the largest even or between the smallest even and the largest odd isn t 1 The only thing you need to do is to implement the check function the most straightforward way possible and check both arrangements Overall complexity 
Recently you found a bot to play Rock paper scissors with Unfortunately the bot uses quite a simple algorithm to play he has a string of length where each letter is either or While initializing the bot is choosing a starting index and then it can play any number of rounds In the first round he chooses Rock Scissors or Paper based on the value of if is equal to the bot chooses Rock if is equal to the bot chooses Scissors if is equal to the bot chooses Paper In the second round the bot s choice is based on the value of In the third round on and so on After the bot returns to and continues his game You plan to play rounds and you ve already figured out the string but still don t know what is the starting index But since the bot s tactic is so boring you ve decided to find choices to each round to maximize the average number of wins In other words let s suggest your choices are and if the bot starts from index then you ll win in rounds Find such that is maximum possible ,Let s look at the contribution of each choice to the total number of wins we can look at total instead of average since average is equal to total divided by For example let s look at the first choice in we compare with in with in with and so on In the result we compare with all once So to maximize the total sum we need to choose that beats the maximum number of or in other words let s find the most frequent character in and choose that beats it Okay we found the optimal But if we look at the contribution of any other we can note that we compare any with all once So we can choose all equal to which is equal to the choice that beats the most frequent choice in 
Berland State University has received a new update for the operating system Initially it is installed only on the st computer Update files should be copied to all computers The computers are not connected to the internet so the only way to transfer update files from one computer to another is to copy them using a patch cable a cable connecting two computers directly Only one patch cable can be connected to a computer at a time Thus from any computer where the update files are installed they can be copied to some other computer in exactly one hour Your task is to find the minimum number of hours required to copy the update files to all computers if there are only patch cables in Berland State University ,Let be the current number of computers with the update already installed initially it is Then in hour we can increase by From here we can see that the value of will double for the first few hours and then when it becomes greater than it will begin to increase by exactly The process when the number of computers doubles can be modeled using a loop because the number of doublings does not exceed And after that we have to increase the answer by to take the number of additions of into account Note that computing should be done without using fractional data types to calculate in integers you should divide by using integer division this will work provided that both and are non negative and If you use real numbers this may cause precision issues 
Vasya has got books numbered from to arranged in a stack The topmost book has number the next one and so on The book at the bottom of the stack has number Vasya wants to move all the books to his backpack in steps During th step he wants to move the book number into his backpack If the book with number is in the stack he takes this book and all the books the book and puts them into the backpack otherwise he does nothing and begins the next step For example if books are arranged in the order book is the topmost and Vasya moves the books in the order then during the first step he will move two books and during the second step he will do nothing since book is already in the backpack and during the third step one book the book number Help Vasya Tell him the number of books he will put into his backpack during each step ,Let s maintain the pointer to the topmost non deleted book and whether each book whether is removed from the stack or not Initially all books are in a stack and is 0 if we store the array 0 indexed We will process the array in the order If the current book is removed from the stack then the answer for it is zero Otherwise we will increment the pointer until the equality is satisfied while marking all the intermediate books in the array After that the answer for the book will be the number of marked books in the array including itself Since the pointer shifts times at total we get a solution with an complexity 
Vasya has got an undirected graph consisting of vertices and edges This graph doesn t contain any self loops or multiple edges Self loop is an edge connecting a vertex to itself Multiple edges are a pair of edges such that they connect the same pair of vertices Since the graph is undirected the pair of edges and is considered to be multiple edges Isolated vertex of the graph is a vertex such that there is no edge connecting this vertex to any other vertex Vasya wants to know the minimum and maximum possible number of isolated vertices in an undirected graph consisting of vertices and edges ,Vasya can decrease number of isolated vertices up to using one edge and pairing them So minimum number of isolated vertices is To calculate maximum number of isolated vertices let s keep number of non isolated vertices knowing that each pair connected by edge i e size of clique Let we have size of clique and edges remained unassigned at current step If then answer is Otherwise we need to increase clique with one vertex Maximum number of edges we can add to connect this vertex is So subtract it from and increase by one Repeat this step while greater than zero Answer is One corner case is next if then answer is not 
New Year is coming Vasya has prepared a New Year s verse and wants to recite it in front of Santa Claus Vasya s verse contains parts It takes seconds to recite the th part Vasya can t change the order of parts in the verse firstly he recites the part which takes seconds secondly the part which takes seconds and so on After reciting the verse Vasya will get the number of presents equal to the number of parts he fully recited Vasya can skip at most one part of the verse while reciting it if he skips more than one part then Santa will definitely notice it Santa will listen to Vasya s verse for no more than seconds For example if and Vasya skips the first part of verse then he gets two presents Note that it is possible to recite the whole verse if there is enough time Determine which part Vasya needs to skip to obtain the maximum possible number of gifts If Vasya shouldn t skip anything print If there are multiple answers print any of them You have to process test cases ,If sum limits i 1 n a i le s then answer is Otherwise let s find we minimum index x such that sum limits i 1 x a i s It s useless to skip a part i x because Vasya just has not time to recite previous part it s change nothing So he has to skip a part i le x And among such parts it s beneficial to skip part with maximum value of a i 
Vova has won trophies in different competitions Each trophy is either golden or silver The trophies are arranged in a row The of the arrangement is the length of the longest subsegment consisting of golden trophies Vova wants to swap two trophies not necessarily adjacent ones to make the arrangement as beautiful as possible that means to maximize the length of the longest such subsegment Help Vova Tell him the maximum possible beauty of the arrangement if he is allowed to do at most one swap ,Let be the maximal segment of gold cups that begins in the cup Let be the maximum segment of gold cups that ends in the cup Also let the total number of gold cups be Note that it makes no sense to change the cups of the same color Then let s consider the silver cup which will change with the gold cup let its number be Then if then we will update the answer with the value and otherwise with the value This will not work if all the cups are golden In this case the answer is 
You have two variables and Consider the following sequence of actions performed with these variables If or end the process Otherwise go to step If then set the value of to and repeat step Otherwise go to step If then set the value of to and repeat step Otherwise end the process Initially the values of and are positive integers and so the process will be finite You have to determine the values of and after the process ends ,The answer can be calculated very easy by Euclid algorithm which is described in the problem statement but all subtractions will be replaced by taking by modulo 
You are given four integers and You should build a sequence where and for each you can choose either or Your goal is to build such a sequence that for all and is maximum possible ,Strategy is quite easy we go from to and if we take this variant we set otherwise we set Note that all are in range so there won t be any overflow underflow It s also not hard to prove that this strategy maximizes the sum By contradiction suppose the optimal answer has some index where but Let s find first position where and swap operations between and As a result all from were increased while remained the same i e there is no violation of the rules and the total sum increased contradiction 
You are given a picture consisting of rows and columns Rows are numbered from to from the top to the bottom columns are numbered from to from the left to the right Each cell is painted either black or white You think that this picture is not interesting enough You consider a picture to be interesting if there is at least one in it A cross is represented by a pair of numbers and where and such that in row and in column are painted black For examples each of these pictures contain crosses The fourth picture contains 4 crosses at and Following images don t contain crosses You have a brush and a can of black paint so you can make this picture interesting Each minute you may choose a white cell and paint it black What is the minimum number of minutes you have to spend so the resulting picture contains at least one cross You are also asked to answer multiple independent queries ,Let s consider each cell as a center of a cross and take the fastest one to paint Calculating each time naively will take overall which is too slow Notice how the answer for some cell can be represented as if is white else where is the number of white cells in row and is the same for column The first two terms can be precalculated beforehand Overall complexity per query 
Suppose you have a special counter This counter can store some value as a decimal number at first the counter has value The counter performs the following algorithm it prints its lowest digit and after that adds either or to its value So all sequences this counter generates are starting from For example a counter can act as follows it prints and adds to its value so the current value is and the output is it prints and adds to its value so the current value is and the output is it prints and adds to its value so the current value is and the output is it prints and adds to its value so the current value is and the output is it prints and adds to its value so the current value is and the output is This is only one of the possible outputs for example the same counter could generate as the output if we chose to add during each step You wrote down a printed sequence from one of such counters But the sequence was corrupted and several elements from the sequence could be erased Now you d like to recover data you ve lost but you don t even know the type of the counter you used You have a decimal string the remaining data of the sequence For all calculate the minimum number of digits you have to insert in the string to make it a possible output of the counter Note that you can t change the order of digits in string or erase any of them only insertions are allowed ,All you need to know to solve this task is the minimal number of steps to move from any digit to any digit for fixed and let s denote it as Shortest path BFS Floyd Of course you can use it but you can think a little harder and save nerves and time Since order of choosing operations and doesn t matter for transferring from to so only number of s and s are matter Let s denote them as and Since adding any fixed value times are meaningless so Now you can for each for each for each iterate over all possible and Digit you d move to is equal to Just relax value of by Now you can for each and calculate the answer by iterating over string by summing number of inserted values is less by one than number of steps But it will work only in C since the language is fast and basic operations are executed in less than 0 5 second But the model solution is written in Kotlin How is it The string can be long but there are only different neighbouring digits so you can just one time precalculate the number of such that and And calculate the answer not by iterating over but by multiplying by The result complexity is where But will pass on fast languages like C P S There are no real problem with I O both Python and Kotlin read one string up to in less than 0 5 seconds 
A student of school found a kind of sorting called sort The array with elements are sorted if two conditions hold for all even for all odd For example the arrays and are sorted while the array isn t sorted Can you make the array sorted ,Easy to see that we can sort any array Let be the number of even positions in We can assign to those positions maximal elements and distribute other elements to odd positions Obviously the resulting array is sorted 
You are fighting with Zmei Gorynich a ferocious monster from Slavic myths a huge dragon like reptile with multiple heads Initially Zmei Gorynich has heads You can deal types of blows If you deal a blow of the th type you decrease the number of Gorynich s heads by there is the current number of heads But if after this blow Zmei Gorynich has at least one head he grows new heads If then Gorynich is defeated For example if then the number of heads changes to you cut heads off but then Zmei grows new ones but if then number of heads changes to and Zmei Gorynich is considered defeated Calculate the minimum number of blows to defeat Zmei Gorynich You have to answer independent queries ,Lets divide all dealing blows into two parts the last blow and others blows The last hit should be with maximum value of The others blows should be with the maximum value of So lets denote as and as Then if the we can beat Zmei Gorynich with one blow Otherwise if then we cannot defeat Zmei Gorynich Otherwise if and the answer is 
Ilya is working for the company that constructs robots Ilya writes programs for entertainment robots and his current project is Bob a new generation game robot Ilya s boss wants to know his progress so far Especially he is interested if Bob is better at playing different games than the previous model Alice So now Ilya wants to compare his robots performance in a simple game called 1 2 3 This game is similar to the Rock Paper Scissors game both robots secretly choose a number from the set and say it at the same moment If both robots choose the same number then it s a draw and noone gets any points But if chosen numbers are different then one of the robots gets a point beats beats and beats Both robots programs make them choose their numbers in such a way that their choice in th game depends only on the numbers chosen by them in th game Ilya knows that the robots will play games Alice will choose number in the first game and Bob will choose in the first game He also knows both robots programs and can tell what each robot will choose depending on their choices in previous game Ilya doesn t want to wait until robots play all games so he asks you to predict the number of points they will have after the final game ,Notice that there are only possible patterns in this game You can used in a following way Simulate games till one of the patterns get repeated Games between this pair of occurences will get you the same total outcome no matter when they are played Let the distance between the games with the same pattern is and index of these games are and zero indexed Total score of some interval is Then the answer will be 
You are playing a game similar to Sokoban on an infinite number line The game is discrete so you only consider integer positions on the line You start on a position There are boxes the th box is on a position All positions of the boxes are distinct There are also special positions the th position is All the special positions are also distinct In one move you can go one position to the left or to the right If there is a box in the direction of your move then you push the box to the next position in that direction If the next position is taken by another box then that box is also pushed to the next position and so on You are allowed to perform any number of moves possibly zero Your goal is to place as many boxes on special positions as possible Note that some boxes can be initially placed on special positions ,Since you can only push boxes you can t bring boxes from negative positions to positive ones and vice versa Thus negative boxes special positions and positive boxes special positions are two separate tasks You can solve them independently with the same algorithm and add up the answers So we will only consider the positive boxes special positions case Notice that it never makes sense to move left Thus the only thing that determines the answer is the maximum position to the right you reach For a naive algorithm we could iterate over that position push all boxes that we have encountered on our way ahead of us and calculate the number of boxes that are on special positions That works in where is maximum coordinate To improve that solution we can notice that the positions that are the most optimal are actually the ones such that the first box is pushed to some special position Consider the case the first box isn t on a special position and there is a special position somewhere to the right of it There are two types of boxes the ones that are in the pile you would push if you move right and the remaining suffix What happens if you move one step to the right The number of boxes from the suffix on special positions doesn t change The number of boxes from the pile on special positions doesn t decrease This number changes depending on if there is a special position immediately to the right of the pile and underneath the first box Since we considered the case where there is no special position underneath the first box the number can t decrease So we managed to improve the solution to Still slow Let s now learn to maintain the answer while moving the boxes Precalculate the number of boxes from the th to the last one that are already on special positions That can be done with two pointers Now iterate over the special position under the first box in the increasing order Maintain the size of the pile and the number of special positions under the pile The first value is just the index of the first box not in a pile The second value is easier to obtain if you keep the index of the first special position after the pile or if there are none Also achievable with two pointers The answer is the number of special positions under the pile plus the suffix answer for the boxes after the pile Take the maximum of all options The constraints are pretty free so you could replace two pointers with binary searches if you wanted to Overall complexity per testcase 
Suppose you are performing the following algorithm There is an array filled with zeroes at start The following operation is applied to the array several times at th step indexed you can either choose position and increase by or not choose any position and skip this step You can choose how the algorithm would behave on each step and when to stop it The question is can you make array equal to the given array for each after some step ,This is the solution that doesn t involve masks Let s reverse the process and try to get all zeroes from the array since all we can start from maximum The key idea since then there should be no more than one position such that and we should decrease it by Now we can decrease by and repeat the same process If at any step there are at least two or as result we won t get array filled with then there is no way to build the array 
Ivan is going to sleep now and wants to set his alarm clock There will be many necessary events tomorrow the th of them will start during the th minute Ivan doesn t want to skip any of the events so he has to set his alarm clock in such a way that it rings during minutes so he will be awake during each of these minutes Ivan can choose two properties for the alarm clock the first minute it will ring let s denote it as and the interval between two consecutive signals let s denote it by After the clock is set it will ring during minutes and so on Ivan can choose minute as the first one but he cannot choose any arbitrary value of He has to pick it among the given values his phone does not support any other options for this setting So Ivan has to choose the first minute when the alarm clock should start ringing and the interval between two consecutive signals in such a way that it will ring during all given minutes and it does not matter if his alarm clock will ring in any other minutes Your task is to tell the first minute and the index such that if Ivan sets his alarm clock with properties and it will ring during all given minutes or say that it is impossible to choose such values of the given properties If there are multiple answers you can print any ,It is obvious that we can always take as But we don t know which value of we can take Let be for all from to The value of should be divisor of value of The maximum possible divisor of each is greatest common divisor And then it is obvious that the value of should be the divisor of So we have to find divisor of among all values If there is no such value then the answer is Time complexity 
Alice got an array of length as a birthday present once again This is the third year in a row And what is more disappointing it is overwhelmengly boring filled entirely with zeros Bob decided to apply some changes to the array to cheer up Alice Bob has chosen changes of the following form For some integer numbers and he chooses an arbitrary position and for every adds to the value of the th cell is the distance between positions and i e where is an absolute value of For example if Alice currently has an array and Bob chooses position for and then the array will become Note that Bob can t choose position outside of the array that is smaller than or greater than Alice will be the happiest when the elements of the array are as big as possible Bob claimed that the arithmetic mean value of the elements will work fine as a metric What is the maximum arithmetic mean value Bob can achieve ,Judging by constraints you can guess that the greedy approach is the right one Firstly let s transition from maximizing the arithmetic mean to the sum it s the same thing generally Secondly notice that each is being added to each element regardless of the chosen position Finally take a look at a function total sum obtained by applying change with to position and notice that it is non strictly convex Its maximum or minimum values can always be found in one of these positions method of rounding doesn t matter and Thus the solution will look like this for positive you apply the change to position and for non positive to position The impact of the change can be calculated with the formula of the sum of arithmetic progression Also you should either do all of your calculations in long double 10 byte type or maintain sum in long long you can estimate it with so it fits and divide it by in the end then double will work Overall complexity 
You are given a array for each index condition holds and an integer You are asked to divide this array into non empty consecutive subarrays Every element in the array should be included in exactly one subarray Let be equal to the maximum in the th subarray and be equal to the minimum in the th subarray The cost of division is equal to For example if and we divide it into subarrays in the following way then the cost of division is equal to Calculate the minimum cost you can obtain by dividing the array into non empty consecutive subarrays ,Let s carefully look at the coefficients with which the elements of the array will be included in the answer If pair of adjacent elements a i and a i 1 belong to different subarrays then element a i will be included in the answer with coefficient 1 and element a i 1 with coefficient 1 So they add value a i a i 1 to the answer If element belongs to subarray with length 1 then it will be included in the sum with coefficient 0 because it will be included with coefficient 1 and 1 simultaneously Elements at positions 1 and n will be included with coefficients 1 and 1 respectively So initially our answer is a n a 1 All we have to do is consider n 1 values a 1 a 2 a 2 a 3 dots a n 1 a n and add up the k 1 minimal ones to the answer 
You are given two strings and both of length Each character in both string is or In one move you can perform one of the following actions choose an occurrence of in and replace it with choose an occurrence of in and replace it with You are allowed to perform an arbitrary amount of moves possibly zero Can you change string to make it equal to string ,First check that the counts of all letters are the same in both strings Then consider the following restatement of the moves The letters in the string are stationary Letters and however move around the string The move of the first type moves a letter to the right The move of the second type moves a letter to the left Notice that letters and can never swap with each other Thus if you remove all letters from both strings the remaining strings should be the same Again since letters and can never swap with each other you can deduce where each of these letters should end up after the swaps The first letter a in should be on the position of the first letter in and so on After that we recall that s can only move to the right and s can only move to the left Thus we check that the th occurrence of in is to the left or equal to the th occurrences of in and vice versa for s Finally we can see that this is a sufficient condition Easy to show by construction you can just fix the positions one after another left to right Overall complexity per testcase 
You are given an integer and a string that consists only of characters a a lowercase Latin letter and an asterisk Each asterisk should be replaced with several from to inclusive lowercase Latin letters b Different asterisk can be replaced with different counts of letter b The result of the replacement is called a Two strings and are different if they either have different lengths or there exists such a position that A string is lexicographically smaller than a string if and only if one of the following holds is a prefix of but in the first position where and differ the string has a letter that appears earlier in the alphabet than the corresponding letter in Now consider all different BA strings and find the th lexicographically smallest of them ,Find all segments of asterisks in the string Let there be of them and the number of asterisks in them be That tells us that the th segment of asterisks can be replaced with at most letters b Notice that we can compare two strings lexicographically using just the number of letters b that replace each of segments of asterisks Let that sequence for some string be and that sequence for some string be Then if and only if That is there exists such position that The proof is trivial So we can actually look at the sequence as some kind of number in a mixed base The lowest digit can be of one of values from to The second lowest one of And so on Then comparison of two strings is the same as comparison of these two mixed base numbers Thus the task is to convert number to this mixed base Turns out it s not that hard In base for example the lowest digit can be determined as the remainder of the number of dividing by Here it will be the remainder of dividing by After that divide and floor the number and proceed to the next digit After steps are done the digits of that mixed base number tell exactly how many letters b should replace each segment of asterisks Overall complexity per testcase to recover the string to print it 
In Berland different types of banknotes are used Banknotes of the th type have denomination burles burles are the currency used in Berland the denomination of banknotes of the first type is exactly Let s denote as the minimum number of banknotes required to represent exactly burles For example if the denominations of banknotes used in Berland are and then banknotes with denomination of burle and banknotes with denomination of burles can be used to represent exactly burles and there s no way to do it with fewer banknotes For a given integer find the minimum positive number of burles that cannot be represented with or fewer banknotes that is ,First of all let s find out how to calculate This can be done greedily let s iterate from the higher denominations to the lower ones the number of banknotes of th type is equal to the value of here changes to reflect that we have already taken some banknotes that is we subtract from each time which is the same as taking modulo We can see that after we process the th type of banknotes the condition holds which means that the number of banknotes of th type does not exceed except in the case of Now we can find the minimum number such that Let be the number of banknotes that still remains to take initially equal to because we want to be at least Let s iterate from the lower denominations to the highest ones the number of banknotes of th type we take should be equal to the minimum of how many we need to take and how many we are allowed to take so as not to break the minimality of the function 
Limak is a little polar bear He likes strings strings of length consisting of lowercase English letters only The distance between two letters is defined as the difference between their positions in the alphabet For example and Also the distance between two nice strings is defined as the sum of distances of corresponding letters For example and Limak gives you a nice string and an integer He challenges you to find any nice string that Find any satisfying the given conditions or print if it s impossible to do so As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,There is no solution if the given required distance is too big Let s think what is the maximum possible distance for the given string Or the more useful thing how to construct a string to maximize the distance We can treat each letter separately and replace it with the most distant letter For example we should replace c with z and we should replace y with a To be more precise for first 13 letters of the alphabet the most distant letter is z and for other letters it is a 
Polycarp is an organizer of a Berland ICPC regional event There are universities in Berland numbered from to Polycarp knows all competitive programmers in the region There are students the th student is enrolled at a university and has a programming skill Polycarp has to decide on the rules now In particular the number of members in the team Polycarp knows that if he chooses the size of the team to be some integer each university will send their strongest with the highest programming skill students in the first team the next strongest students in the second team and so on If there are fewer than students left then the team can t be formed Note that there might be universities that send zero teams The strength of the region is the total skill of the members of all present teams If there are no teams present then the strength is Help Polycarp to find the strength of the region for each choice of from to ,There are two important observations to make The first one is that you can calculate the answers for each university independently of each other and sum them up to obtain the true answer The second one is that if there are students in an university then that university can only contribute to answers for from to So if we learn to calculate the contribution of the th university for some fixed in then we will be able to iterate over all possible for each university and get the solution in where is the number of students in the th university To achieve it you have to gather the sum of the maximum number of students that can form full teams of size That must be the highest number less than or equal to that is divisible by so Sort the students of each university precalculate partial sums and now you are free to add the prefix sum of that number of students to the answer for Overall complexity per testcase 
Karlsson has recently discovered a huge stock of berry jam jars in the basement of the house More specifically there were jars of strawberry and blueberry jam All the jars are arranged in a row The stairs to the basement are exactly in the middle of that row So when Karlsson enters the basement he sees exactly jars to his left and jars to his right For example the basement might look like this Being the starightforward man he is he immediately starts eating the jam In one minute he chooses to empty either the first non empty jar to his left or the first non empty jar to his right Finally Karlsson decided that at the end the amount of full strawberry and blueberry jam jars should become the same For example this might be the result Jars are numbered from to from left to right so Karlsson initially stands between jars and What is the minimum number of jars Karlsson is required to empty so that an equal number of full strawberry and blueberry jam jars is left Your program should answer independent test cases ,Let s transit from counting strawberry and blueberry jam jars separately to their difference Let be equal to Then eating one strawberry jar decreases by and eating one blueberry jar increases by The goal is to make equal to Let there be some initial difference Let s eat first jars from the left and first jars from the right Difference of the jars on the left is on the right it s So the goal becomes to find such and that Rewrite that as Now for each unique value of save the smallest to reach that value in a map Finally iterate over the and find the minimum answer Overall complexity 
The construction of subway in Bertown is almost finished The President of Berland will visit this city soon to look at the new subway himself There are stations in the subway It was built according to the For each station there exists exactly one train that goes from this station Its destination station is possibly For each station there exists exactly one station such that The President will consider the of subway after visiting it The is the number of ordered pairs such that person can start at station and after taking some subway trains possibly zero arrive at station The mayor of Bertown thinks that if the subway is not enough then the President might consider installing a new mayor and of course the current mayor doesn t want it to happen Before President visits the city mayor has enough time to rebuild some paths of subway thus changing the values of for Of course breaking the is really bad so the subway must be built according to the even after changes The mayor wants to do these changes in such a way that the of the subway is maximized Help him to calculate the maximum possible he can get ,Let s notice that one swap can affect at most two cycles of this permutation Moreover you can join two cycles into one with the length equal to the sums of lengths of initial ones The function we are going to maximize is where and are the lengths of the cycles we are joining together Now its easily seen that the maximum is achived when joining two cycles with the greatest product of lengths Finally they are the two longest cycles in permutation Overall complexity 
Consider the following process You have a binary string a string where each character is either or of length and an integer You build a new binary string consisting of characters The th character of is chosen as follows if the character exists and is equal to then is formally if and then if the character exists and is equal to then is formally if and then if both of the aforementioned conditions are false then is You are given the integer and the resulting string Reconstruct the original string ,Note that means either or whereas means both and We can greedily solve this by starting out our string with all 1 s then marking and as 0 whenever we are forced to because Then we can simply check whether all of the conditions are valid to confirm Code 90915688 
You are given a string consisting of characters and or You have to remove several possibly zero characters from the beginning of the string and then several possibly zero characters from the end of the string The cost of the removal is the of the following two values the number of characters left in the string the number of characters removed from the string What is the cost of removal you can achieve ,There are many different approaches to this problem dynamic programming binary search greedy two pointers anything you want The model solution uses an approach based on binary search so I ll describe it First of all why does binary search work Let s say that the number of s is If the cost of deletion is then we have deleted at most characters and have left at most characters Let s increase the number of characters we delete from the prefix of the string until the number of deleted s becomes if it s always possible So if we consider the segment of values the fact that we can get cost implies that we can get cost so we can use binary search on segment to find the minimum achievable cost Now how to check if we can obtain the cost of deletion equal to One possible way to do this is to form an array where is the position of the th character in the string and find the minimum value of in this array the string that should remain has to contain at least characters and the minimum value of is the minimum possible length of such string Then we can find the number of s in this string and check if it is greater than or not 
Mishka has got empty boxes For every th box is a cube with side length Mishka can put a box into another box if the following conditions are met th box is not put into another box th box doesn t contain any other boxes box is smaller than box Mishka can put boxes into each other an arbitrary number of times He wants to minimize the number of boxes A box is called iff it is not put into some another box Help Mishka to determine the minimum possible number of boxes ,You can always show that the answer is equal to the amount of boxes of the size appearing the most in array Result can be easily obtained by constructive algorithm take these most appearing boxes put smaller boxes in decreasing order of their size into free ones there always be space and put resulting boxes into the larger ones in increasing order Overall complexity 
You are given a bracket sequence consisting of characters and or You perform several operations with it During one operation you choose the prefix of this string some amount of first characters of the string that is and remove it from the string The prefix is considered if one of the following two conditions is satisfied this prefix is a regular bracket sequence this prefix is a palindrome of length A bracket sequence is called regular if it is possible to obtain a correct arithmetic expression by inserting characters and into this sequence For example sequences and are regular while and are not The bracket sequence is called palindrome if it reads the same back and forth For example the bracket sequences and are palindromes while bracket sequences and are not palindromes You stop performing the operations when it s not possible to find a prefix Your task is to find the number of operations you will perform on the given string and the number of remaining characters in the string You have to answer independent test cases ,Consider the first character of the string If it is then we can remove the first two characters of the string and continue because the prefix of length will be either a palindrome or a regular bracket sequence If the first character of the string is then this is a bad case Of course the regular bracket sequence can t start with so this prefix should be a palindrome And what is the shortest palindrome we can get with the first character It is the closing bracket then some possibly zero amount of opening brackets and another one closing bracket We can see that we can t find a palindrome shorter than this one because we have to find a pair for the first character So if the first character of the string is then we just remove anything until the next character inclusive To not remove any characters explicitly we can just use pointers instead And the last thing is to carefully handle cases when we can t do any operations 
A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters 1 and between the original characters of the sequence For example bracket sequences are regular the resulting expressions are 1 1 1 1 1 and and are not You are given bracket sequences Calculate the number of pairs such that the bracket sequence is a regular bracket sequence Operation means concatenation i e If and are regular bracket sequences and then both pairs and must be counted in the answer Also if is a regular bracket sequence the pair must be counted in the answer ,Let be the mirror reflection of the string For example Let string be good if it does not have a prefix which have more closing brackets than opening ones For example are good and are not The balance of the string is the difference between number of opening and closing brackets in For example 1 0 Let be the number of good strings with a balance The answer to the problem is 
You are playing a new famous fighting game Kortal Mombat XII You have to perform a brutality on your opponent s character You are playing the game on the new generation console so your gamepad have buttons Each button has a single lowercase Latin letter from to written on it All the letters on buttons are pairwise distinct You are given a sequence of hits the th hit deals units of damage to the opponent s character To perform the th hit you have to press the button on your gamepad Hits are numbered from to You know that if you press some button times then it ll break You cherish your gamepad and don t want to break any of its buttons To perform a brutality you have to land some of the hits of the given sequence The total damage dealt is the sum of over all for the hits which weren t skipped Your task is to skip some hits to deal the possible total damage to the opponent s character and not break your gamepad buttons ,Since we are only allowed to push the same button times in a row let s do a two pointer sweep to find all segments of consisting of just one button Within each segment we ll sort and take the highest values See the code for details on the two pointer sweep 48994498 
You want to build a fence that will consist of equal sections All sections have a width equal to and height equal to You will place all sections in one line side by side Unfortunately the ground beneath the fence is not flat For simplicity you can think that the ground level under the th section is equal to You should follow several rules to build the fence the consecutive sections should have a common side of length at least the first and the last sections should stand on the corresponding ground levels the sections between may be either on the ground level or higher but not higher than from the ground level the height should be an integer Is it possible to build a fence that meets all rules ,Let s set sections from left to right Note that for the th section all valid heights heights for which it s possible to choose heights for all sections meeting all rules and finishing with the height of equal to form a segment It s not hard to prove by induction For the first section the valid segment is The step of induction if the valid segment for is then valid s for is the segment since for each you can find at least one in which don t break the first rule If for any the correct segment is empty or if we can t fulfill the third rule then there is no answer otherwise at least one answer is always exist As a result to solve the problem you should just maintain the segment of valid using the formula above while iterating Complexity is 
You have a robot that can move along a number line At time moment it stands at point You give commands to the robot at time seconds you command the robot to go to point Whenever the robot receives a command it starts moving towards the point with the speed of unit per second and he stops when he reaches that point However while the robot is moving it all the other commands that you give him For example suppose you give three commands to the robot at time move to point at time move to point and at time move to point Then the robot stands at until time then starts moving towards ignores the second command reaches at time and immediately starts moving to to execute the third command At time it reaches and stops there You call the command successful if there is a time moment in the range i e after you give this command and before you give another one both bounds inclusive we consider when the robot is at point Count the number of successful commands Note that it is possible that an ignored command is successful ,The main idea in the problem is not how to solve it but how to code it neatly I ve come up with the following way Let s store three variables where is the robot now what direction does it move or and how much time is left until it stops moving The processing of the commands looks becomes pretty easy If there is no time left to move then the command is executed and we tell the robot the direction and the time left for the current command Then there are two cases either the robot stops before the next command or after it However they can be processed simultaneously Let be the minimum of the time left before the robot stops moving and the time before the next command We sure know that before the next command the robot will visit exactly the segment of positions between the current position and the current position plus direction multiplied by If the destination for the current command is in this segment then that command is successful After the command is processed subtract from the time left and increase the position by direction multiplied by Overall complexity per testcase 
Consider a game with cards is even Each card has a number written on it between and All numbers on the cards are different We say that a card with number is stronger than a card with number if Two players Alex and Boris play this game In the beginning each of them receives exactly cards so each card belongs to exactly one player Then they take turns Alex goes first then Boris then Alex again and so on On a player s turn he must play of his cards Then if the opponent doesn t have any cards than the card played the opponent loses and the game ends Otherwise the opponent has to play a stronger card exactly one card as well These two cards are removed from the game and the turn ends If there are no cards left the game ends in a draw otherwise it s the opponent s turn Consider all possible ways to distribute the cards between two players so that each of them receives exactly half of the cards You have to calculate three numbers the number of ways to distribute the cards so that Alex wins the number of ways to distribute the cards so that Boris wins the number of ways to distribute the cards so that the game ends in a draw You may assume that both players play optimally i e if a player can win no matter how his opponent plays he wins Two ways to distribute the cards are different if there is at least one card such that in one of these ways it is given to Alex and in the other way it is given to Boris For example suppose Alex receives the cards and Boris receives the cards Then the game may go as follows if Alex plays the card then Boris has to respond with the card Then Alex s turn ends and Boris turn starts Boris has only one card left which is he plays it and Alex responds with the card So the game ends in a draw if Alex plays the card then Boris has to respond with the card Then Alex s turn ends and Boris turn starts Boris has only one card left which is he plays it and Alex responds with the card So the game ends in a draw So in this case the game ends in a draw ,The example tests suggest that there is only one possible distribution with a draw Let s find out why it is so We will use a process similar to induction recursion to distribute the cards between the two players so that the game ends in a draw suppose Alex receives the card Then he wins since he can play it immediately So for the game to result in a draw Boris must receive the card suppose Boris receives the card Then he wins since he also has the card he can use it to answer any first move of Alex and then win the game by playing So for the game to result in a draw Alex must receive the card suppose Boris receives the card Then he wins since he also has the card if Alex plays the card Boris responds with and then plays if Alex plays some other card Boris responds with and the plays So for the game to result in a draw Alex must receive the card and so on In fact if Alex receives the card and Boris receives the card Alex must play the card or something equivalent to it on the first move and Boris must respond with the card so we can consider the game without these two cards with the roles swapped So if we consider the distribution of cards as a string with characters and where denotes the card belonging to Alex and denotes the card belonging to Boris and the th character of the string represents the card the only possible distribution for the draw is But there s more to this string representation of the distribution of cards the first character that is different from this pattern denotes the winner if the first different character is in the draw distribution and in the distribution we consider the winner is Boris otherwise the winner is Alex This may lead us to the following ways to count the number of possible distributions which win lose for Alex we can use dynamic programming of the form where is the number of characters we used is the number of characters we used and is or depending on whether our string coincides with the draw string differs from it in a way that Alex wins or differs from it in a way that Boris wins the actual value of must be the number of ways to reach this state of dynamic programming The answer then is stored in the states of the form or we can use combinatorics let s iterate on the length of the prefix that is common in the draw string and in the string representing the distribution of cards and then count the number of ways to distribute the remaining characters with a binomial coefficient To calculate the binomial coefficients we can use one of the following methods Pascal s triangle precalculating factorials and modular inverses to then or calculating factorials with big integers in Java or Python 
You are a usual chat user on the most famous streaming platform Of course there are some moments when you just want to chill and spam something More precisely you want to spam the emote triangle of size It consists of messages The first message consists of one emote the second one of two emotes the th one of emotes the th one of emotes and the last one of one emote For example the emote triangle for consists of messages Of course most of the channels have auto moderation Auto moderator of the current chat will ban you right after you spam at least emotes in succession you can assume you are the only user in the chat Now you are interested how many messages will you write before getting banned Or maybe you will not get banned at all i e will write all messages and complete your emote triangle successfully Note that if you get banned as a result of writing a message this message is also counted You have to answer independent test cases ,This is a pretty obvious binary search problem If we get banned after messages we also get banned after and so on messages and vice versa if we don t get banned after messages we also don t get banned after and so on messages For simplicity let s split the problem into two parts when we check if we re getting banned after messages let s handle cases and separately Recall that the sum of the arithmetic progression consisting of integers is Let it be The first case is pretty simple the number of emotes we send with messages when is which is So we only need to check if The second case is a bit harder but still can be done using arithmetic progression formulas Firstly we send all messages for the number of such messages is Then we need to add messages This number equals to i e we send all messages from to and subtract messages from to from this amount The final condition is Time complexity per test case 
Chef Monocarp has just put dishes into an oven He knows that the th dish has its optimal cooking time equal to minutes At any minute Monocarp can put dish out of the oven If the th dish is put out at some minute then its unpleasant value is the absolute difference between and Once the dish is out of the oven it can t go back in Monocarp should put all the dishes out of the oven What is the minimum total unpleasant value Monocarp can obtain ,There are a lot of solutions for the problem Let s start with the easiest one Sort the dishes in the non decreasing order of their optimal time I claim that there is an optimal answer such that the times for each dish go in the increasing order That s not too hard to prove something along the lines of if there are two dishes and such that and then is always greater than So we can use dynamic programming to solve the task Let be the minimum total unpleasant value if dishes are processed and the current minute is For the transitions you can either put out the current dish at the current minute or wait one more minute Notice that you ll never need more time than minutes the actual constraint is even smaller just consider the case with all dishes times equal to So that dp works in The other possible solution is matching Let s build the following graph The left partition is vertices corresponding to dishes The right partition is vertices corresponding to minutes as we saw in previous solution is always enough Now add the edges between all dishes and all minutes with the cost of their absolute different Finally find the minimum cost maximum matching That can be done with MCMF or Hungarian algorithm Both should pass pretty easily There s also a solution in involving the slope trick 
Magnus decided to play a classic chess game Though what he saw in his locker shocked him His favourite chessboard got broken into pieces each of size by is And what s even worse some squares were of wrong color th square of the th row of th piece of the board has color being black and being white Now Magnus wants to change color of some squares in such a way that he recolors minimum number of squares and obtained pieces form a valid chessboard Every square has its color different to each of the neightbouring by side squares in a valid board Its size should be by You are allowed to move pieces but ,Since is odd exactly pieces of the board will have upper left corner colored black and exactly white Let s check every option to choose two pieces of the board so their upper left corners will be painted white when we assemble the board calculate the number of board cells that have to be recolored and find the minimum of this value among all possible choices 
You are playing another computer game and now you have to slay monsters These monsters are standing in a circle numbered clockwise from to Initially the th monster has health You may shoot the monsters to kill them Each shot requires exactly one bullet and decreases the health of the targeted monster by deals damage to it Furthermore when the health of some monster becomes or less than it dies and explodes dealing damage to the next monster monster if or monster if If the next monster is already dead then nothing happens If the explosion kills the next monster it explodes too damaging the monster after it and possibly triggering another explosion and so on You have to calculate the minimum number of bullets you have to fire to kill all monsters in the circle ,We cannot utilize the explosion of the last monster we kill So the naive approach is to iterate on the monster we kill the last break the circle between this monster and the next one and then shoot the first monster in the broken circle until it s dead then the second one and so on Let s calculate the number of bullets we will fire this way If the circle is broken after the monster then the first monster gets bullets the second one and so on all monsters except the first one get exactly bullets So we should choose an index such that is minimum possible since this is the number of bullets we have to spend additionally since we cannot utilize the explosion of the th monster After breaking the circle between the monsters and you may use a formula to calculate the required number of bullets or just model the shooting 
Let s call some positive integer if its decimal representation contains no more than non zero digits For example numbers are and numbers are not You are given a segment Count the number of integers such that Each testcase contains several segments for each of them you are required to solve the problem separately ,There are quite a few approaches to the problem I ll describe the two of them which I actually implemented First approach combinatoric one Problems of the form count the number of beautiful numbers from to usually require counting the numbers on and or not inclusively and and subtracting one from another Let s try this thing here counting not inclusively Let s fix some prefix of the upper border number We want to calculate the amount of numbers having the same prefix but being smaller in the next digit If we count it for all prefixes including the empty one we will get the answer And that is pretty easy Let the prefix include non zero digits the length of the suffix be and the digit after the chosen prefix is If is zero then there the result is obviously zero Otherwise we can either put or any of the non zero digits Then the formula is We choose positions from the suffix to put non zero digits in them any digit from to and fill the rest with zeros Overall complexity Second approach precalc one This is a bit easier to implement Actually there are just about 700000 valid numbers you can generate them all put them into the array in sorted order and binary search for the given queries Overall complexity 
Alice and Bob are playing a game on a matrix consisting of rows and columns The cell in the th row in the th column contains coins in it Initially both Alice and Bob are standing in a cell They are going to perform a sequence of moves to reach a cell The possible moves are Move right from some cell to Move down from some cell to First Alice makes until she reaches She collects the coins in all cells she visit including the starting cell When Alice finishes Bob starts his journey He also performs the moves to reach and collects the coins in all cells that he visited The score of the game is the total number of coins Bob collects Alice wants to minimize the score Bob wants to maximize the score What will the score of the game be if both players play optimally ,First observe that each of the players has only m options for their path which column to go down in Let s consider a Bob s response to a strategy chosen by Alice The easiest way to approach that is to look at the picture of the Alice s path The path clearly separates the field into two independent pieces suffix of the first row and the prefix of the second row Bob can t grab the coins from both of them at once However he can grab either of them fully So the optimal path for him will be one of these two options You can precalculate some prefix sums and become able to get the Bob s score given the Alice s path Alice has m possibly paths so you can iterate over them and choose the minimum answer However prefix sums are not required since you can quickly recalculate both needed sums while iterating over the Alice s column to go down in Overall complexity O m per testcase 
You are given an integer You have to calculate the number of binary consisting of characters and or strings meeting the following constraints For every pair of integers such that an integer is given It imposes the following constraint on the string if all characters in should be the same if there should be at least two different characters in if there are no additional constraints on the string Count the number of binary strings of length meeting the aforementioned constraints Since the answer can be large print it modulo ,Suppose we build the string from left to right and when we place the i th character we ensure that all substrings are valid What do we need to know in order to calculate the number of different characters in the string ending with the i th character Suppose the character s i is Let s try going to the left of it The string from i to i will have the same characters but if there is at least one character before the i th position the string s 1 s 2 s 3 dots s i will have two different characters What about the strings in the middle The string s j s j 1 dots s i will contain different characters if and only if there is at least one in j i since s i is so we are actually interested in the position of the last character before i The same logic applies if the character s i is we are only interested in the position of the last before i and it is enough to check if all substrings ending with the i th character are violated What if when we choose the i th character we violate some substring that doesn t end in the i th position Well you could also check that or you could just ignore it Actually it doesn t matter if this happens because it means that the substring that is violated ends in some position k i and we will check it when placing the k th character So the solution can be formulated with the following dynamic programming let dp i j be the number of ways to choose the first i characters of the string so that the last character different from s i was s j or j 0 if there was no such character and all the constraints on the substrings ending no later than position i are satisfied The transitions are simple you either place the same character as the last one going from dp i j to dp i 1 j or a different character going from dp i j to dp i 1 i and when you place a character you check all the constraints on the substrings ending with the i th position Note that the state dp 1 0 is actually represented by two strings and This solution works in O n 3 although O n 4 or O n 2 implementations are also possible 
You are given segments on a coordinate line each endpoint of every segment has integer coordinates Some segments can degenerate to points Segments can intersect with each other be nested in each other or even coincide Your task is the following for every calculate the number of points with integer coordinates such that the number of segments that cover these points equals A segment with endpoints and covers point if and only if ,This problem with small coordinates can be solved using partial sums and some easy counting Let s carry an array where will be equal to the number of segments that cover the point with coordinate How to calculate in For each segment let s add to and to Now build on this array prefix sums and notice that equals the number of segments that cover the point with coordinate Then will be equal to All the answers can be calculated in in total So the total complexity of this solution is But in our problem it is too slow to build an entire array So what should we do It is obvious that if any coordinate is not equals some or some then So we do not need carry all the positions explicitly Let s carry all and in some logarithmic data structure or let s use the coordinate compression method The coordinate compression method allows us to transform the set of big sparse objects to the set of small compressed objects maintaining the relative order In our problems let s make the following things push all and in vector sort this vector keep only unique values and then use the position of elements in vector instead of original value any position can be found in by binary search or standard methods as in C So the first part of the solution works in Answer can be calculated using almost the same approach as in solution to this problem with small coordinates But now we know that between two adjacent elements and there is exactly points with answer equals to So if we will iterate over all pairs of the adjacent elements and and add to the we will calculate all the answers in So the total complexity of the solution is 
There are programmers that you want to split into several non empty teams The skill of the th programmer is You want to assemble the maximum number of teams from them There is a restriction for each team the number of programmers in the team multiplied by the minimum skill among all programmers in the team must be at least Each programmer should belong to at most one team Some programmers may be left without a team Calculate the maximum number of teams that you can assemble ,At first notice that if only programmers are taken then the same or even better answer can be achieved if strongest programmers are taken Now let s sort the programmers in a non increasing order and choose some assignment into the teams For each team only the rightmost taken programmer of that team matters the sorted sequence implies that the rightmost is the weakest Take a look at the team with the strongest weakest member If the number of programmers in it is less than the position of the weakest member then you can safely rearrange the programmers before him in such a way that none of parameters of later teams change and the weakest member in the first one only becomes stronger After that you can get rid of the first team as it takes exactly the prefix of all the programmers and proceed to fix the later teams Thus we can see that there is an optimal solution such that each team is a segment and all the teams together take some prefix of the programmers So we can finally run a greedy solution that takes programmers from left to right and increases the answer if the conditions for the latest team hold Overall complexity 
Monocarp has got an array consisting of integers Let s denote as the mathematic mean of these elements note that it s possible that is not an integer The mathematic mean of an array of elements is the sum of elements divided by the number of these elements i e sum divided by Monocarp wants to delete exactly two elements from so that the mathematic mean of the remaining elements is still equal to Your task is to calculate the number of pairs of positions such that if the elements on these positions are deleted the mathematic mean of remaining elements is equal to that is it is equal to the mathematic mean of elements of the original array ,First of all instead of the mathematic mean let s consider the sum of elements If the mathematic mean is then the sum of elements of the array is Let s denote the sum of elements in the original array as Note is always an integer If we remove two elements from the array the resulting sum of elements should become So the sum of the elements we remove should be exactly If is not an integer the answer is to check that you can simply compare with Otherwise we have to find the number of pairs such that and This is a well known problem To solve it you can calculate the number of occurrences of each element and store it in some associative data structure for example in C Let be the number of occurrences of element Then you should iterate on the element you want to remove and check how many elements match it that is how many elements give exactly if you add to them The number of these elements is just Let s sum up all these values for every element in the array Unfortunately this sum is not the answer yet We need to take care of two things if for some index then matches itself so you have to subtract the number of such elements from the answer every pair of elements is counted twice the first time when we consider the first element of the pair and the second time when we consider the second element of the pair So don t forget to divide the answer by 
Let s define for a positive integer as the length of the base 10 representation of without leading zeros I like to call it a digital logarithm Similar to a digital root if you are familiar with that You are given two arrays and each containing positive integers In one operation you do the following pick some integer from to assign either to or to Two arrays are considered similar to each other if you can rearrange the elements in both of them so that they are equal e g for all from to What s the smallest number of operations required to make and similar to each other ,First why can you always make the arrays similar Applying a digital logarithm to any number will eventually make it equal to Thus you can at least make all numbers into s in both arrays Then notice the most improtant thing applying the digital logarithm to a number greater than always makes this number smaller Thus if a number appears in only one of the arrays you will have to do one of the followings two things decrease some greater number to make it equal to this one decrease this number What if there is no greater number at all This is the case for the largest number in both arrays altogether If it appears in only one of the arrays you must always decrease If it appears in both though why decrease it further Worst case you will decrease it in one array then you ll have to decrease it in the other array as well This is never more optimal than just matching one occurrence in both arrays to each other and removing them from the arrays So the proposed solution is the following Consider the largest element in each array If they are equal remove both If not apply digital logarithm to the larger of them Continue until the arrays are empty What s the estimated complexity of this algorithm Each number in the first array will be considered at most the number of times you can decrease it with a digital logarithm operation plus one That is at most a number greater than always becomes a single digit and a single digit always becomes Same goes for the second array So the complexity is basically linear To implement it efficiently you will have to use some data structure that provides three operations peek at the maximum remove the maximum insert a new element The perfect one is a heap priority queue in C Overall complexity per testcase 
A positive integer number is written on a blackboard It consists of not more than digits You have to transform it into a number by erasing some of the digits and you want to erase as few digits as possible The number is called beautiful if it consists of at least one digit doesn t have leading zeroes and is a multiple of For example are beautiful numbers and are not Write a program which for the given will find a beautiful number such that can be transformed into this number by erasing as few digits as possible You can erase an arbitraty set of digits For example they don t have to go one after another in the number If it s impossible to obtain a beautiful number print If there are multiple answers print any of them ,Let s declare a function which takes number as a string and erases minimal number of digits in substring from nd to last character to obtain beautiful number Note that if the answer for given string exists then this function will erase no more than digits If the number is divisible by then sum of its digits is also divisible by So here are the only options for the function Sum of digits is already equal to modulo Thus you don t have to erase any digits There exists such a digit that equals sum modulo Then you just have to erase this digit All of the digits are neither divisible by nor equal to sum modulo So two of such digits will sum up to number which equals sum modulo Let positions of non zero numbers be Then you can easily see that its enough to check only three function outputs on substrings We imply that all digits to the left of the taken non zero digit are erased As we can erase no more than digits these options will cover all the cases If there exists no answer for any of substrings than you need to check if the number contains it will be answer in that case If there is no then answer is Otherwise the answer is the function output of maximal length Overall complexity 
There are segments for You should divide all segments into two groups in such way that there is no pair of segments from different groups which have at least one common point or say that it s impossible to do it Each segment should belong to exactly one group To optimize testing process you will be given multitest ,Let s prove that division possible if and only if union of all segments has two and more segments If the union have at least two segments then we can choose one of them and put all segments it contains in one group and other segments to another group On the other hand if we can divide all segments in two groups in such way that there are no pair from different group which intersects then union of segments from the first group doesn t intersect union of segments from another and union of unions consists of several non intersecting components How can it help If union of segments consits of several segments then exists such that for any segment either or and both parts are non empty Moreover equals to one of It leads us straight to one of possible solutions sort all segments by in increasing order and for each we should check that suffix minimum If we ve found such then all prefix goes to one group and suffix to another 
Turbulent times are coming so you decided to buy sugar in advance There are shops around that sell sugar the th shop sells one pack of sugar for coins but only each day So in order to buy several packs you need to visit several shops Another problem is that prices are increasing each day during the first day the cost is during the second day cost is during the third day and so on for each shop On the contrary your everyday budget is only coins In other words each day you go and buy as many packs as possible with total cost not exceeding Note that if you don t spend some amount of coins during a day you can t use these coins during the next days Eventually the cost for each pack will exceed and you won t be able to buy even a single pack So how many packs will you be able to buy till that moment in total ,Firstly note that if we want to buy as many packs as possible then it s optimal to buy the cheapest packs In other words if we sort all packs we ll always buy a prefix of array Next note that each day we buy some number of packs so instead of iterating through the days we can iterate through the number of packs and for each calculate the number of days we ll buy exactly packs Since the prices increasing and at day the price is then exists last day such that as days we could buy packs and at days we can t And we can find as maximum possible integer solution to inequation or We can calculate all using prefix sums in linear time As a result we buy packs in days in total packs in days in total packs in days in total and so on The resulting complexity is because of sort 
Let s call an array by value in the next situation At first array should have at least elements Now let s calculate number of occurrences of each number in and define it as Then is dominated by if and only if for any other number For example arrays and are dominated by and respectevitely but arrays and are not Small remark since any array can be dominated only by one number we can not specify this number and just say that array is either dominated or not You are given array Calculate its shortest dominated subarray or say that there are no such subarrays The subarray of is a contiguous part of the array i e the array for some ,At first let s prove that the shortest dominated subarray has pattern like with and dominated by value Otherwise we can decrease its length by erasing an element from one of its ends which isn t equal to and it d still be dominated Now we should go over all pairs of the same numbers and check its subarrays Or not Let s look closely at the pattern if and all are pairwise distinct then the pattern is dominated subarray itself Otherwise we can find in our pattern other shorter pattern and either the found pattern is dominated or it has the pattern inside it and so on What does it mean It means that the answer is just the shortest pattern we can find And all we need to find is the shortest subarray with the same first and last elements or just distance between two consecutive occurrences of each number We can do it by iterating over current position and keeping track of the last occurrence of each number in some array Then the current distance is The total complexity is 
You are given two arrays and both consisting of integers In one move you can choose two indices and and swap with and with You have to perform the swap in both arrays You are allowed to perform at most moves possibly zero Can you make both arrays sorted in a non decreasing order at the end If you can print any sequence of moves that makes both arrays sorted ,Imagine that all elements of are distinct This way sorting in increasing order will fix the order of If turns out sorted in a non decreasing order then the answer exists Otherwise it doesn t To obtain the sequence of swaps you can sort with any comparison based sorting algorithm you want even bubble sort will not exceed the allowed number of swaps What changes if has repeated elements Distinct elements are still ordered among themselves but now there are also blocks of equal elements For each block look into the corresponding values in Obviously these have to be sorted in a non decreasing order Rearrange them as they should be In fact this is exactly the same as sorting the sequence of pairs with a default comparator first by then by Since we fixed the wanted order we can proceed with the same steps we made in a distinct case Overall complexity or per testcase 
At first there was a legend related to the name of the problem but now it s just a formal statement You are given points on the axis Now you are asked to find such an integer point on axis that is minimal possible The function can be described in the following way form a list of distances where distance between and sort list in non descending order take as a result If there are multiple optimal answers you can print any of them ,First observation closest points to any point form a contiguous subsegment so Second observation for any contiguous subsegment all points this subsegment closest to also form a contiguous segment And because of the nature of value of is minimal in borders and So all we need is to check all and But what is a value of It s such point that but So it s just in the middle of segment Note that and so it s enough to check only s In result all we need is to find minimal possible value and resulting 
You are given a positive decimal number Your task is to convert it to the Let where then in general case the looks like If equals to zero the part should be skipped If is an integer it should be written without decimal point Also there should not be extra zeroes in and ,This is an implementation problem You should do exactly what is written in the problem statement On my mind the simplest way is to find the position of the first not zero digit and the position of the dot The difference between that positions is the value of if the value is positive you should also decrease it by one 
There is a classroom with two rows of computers There are computers in each row and each computer has its own grade Computers in the first row has grades and in the second row Initially all pairs of computers in each row are connected by wire pairs for all so two rows form two independent computer networks Your task is to combine them in one common network by connecting one or more pairs of computers from rows Connecting the th computer from the first row and the th computer from the second row costs You can connect one computer to several other computers but you need to provide at least a basic fault tolerance you need to connect computers in such a way that the network stays connected despite one of its computer failing In other words if one computer is broken no matter which one the network won t split in two or more parts That is the minimum total cost to make a fault tolerant network ,There is a criterion when the given network becomes fault tolerant the network becomes fault tolerant if and only if each of corner computers let s name them and is connected to the other row From the one side if WLOG is not connected to other row then if is broken loses connection to the other network since is connected only with From the other side suppose WLOG is broken then the row is falling in at most two parts and But since both and are connected to row and is still connected then the resulting network is still connected Now the question is how to connect all corner computers Because sometimes it s optimal not to connect corners directly One of the approaches is described below Let s look at Essentially there are three ways to connect it to row to or where is with minimum possible The same applies to So let s just iterate over all these variants For each of these variants if we didn t cover then we should also add one more connection between and if we didn t cover then we should also add one more connection between and As a result we choose the best variant 
You are given a permutation of length Also you are given foe pairs Your task is to count the number of different intervals that do not contain any foe pairs So you shouldn t count intervals that contain at least one foe pair in it the positions and order of the values from the foe pair are not important Consider some example and foe pairs are The interval is incorrect because it contains a foe pair The interval is also incorrect because it contains two foe pairs and But the interval is correct because it doesn t contain any foe pair ,Let s precompute for each value its position in permutation It s easy to do in linear time Consider some foe pair we may assume Let s store for each value the leftmost position such that is a foe pair Denote that value as Now let s iterate over the array from right to left and maintain the position of the maximal correct interval with the left end in the current position To maintain the value we should simply take the minimum with the value And finally we should increment the answer by the value 
You are given an array of integer numbers Let be the sum of all numbers on positions from to non inclusive th element is counted th element is not counted For indices and holds Indices in array are numbered from For example if then and for each from to Choose the indices of three delimiters and divide the array in such a way that the value of is maximal Note that some of the expressions can correspond to empty segments if for some segment ,Imagine the same task but without the first term in sum As the sum of the array is fixed the best second segment should be the one with the greatest sum This can be solved in with partial sums When recalcing the best segment to end at position you should take minimal prefix sum from to inclusive from the whole sum you want to subtract the lowest number Now let s just iterate over all possible ends of the first segment and solve the task above on the array without this segment Oveall complexity 
You are given three strings and consisting of lowercase Latin letters You may perform any number possibly zero operations on these strings During each operation you choose any character from erase it from and insert it into string you may insert this character anywhere you want in the beginning of in the end or between any two consecutive characters For example if is and is then the following outcomes are possible the character we erase from and insert into is highlighted Your goal is to perform several maybe zero operations so that becomes equal to Please determine whether it is possible Note that you have to answer independent queries ,If the answer exists then each element of string matches with some element of string Thereby string must be a subsequence of string Let equal to the number of occurrences of the letter in the string Then for any letter condition must be hold So the answer to the query is if following conditions hold string is subsequence of string for any Latin latter 
Petya has a rectangular Board of size Initially chips are placed on the board th chip is located in the cell at the intersection of th row and th column In one action Petya can move to the left right down or up by cell If the chip was in the cell then after the operation left its coordinates will be right its coordinates will be down its coordinates will be up its coordinates will be If the chip is located by the wall of the board and the action chosen by Petya moves it towards the wall then the chip remains in its current position For each chip Petya chose the position which it should visit Note that it s not necessary for a chip to end up in this position Since Petya does not have a lot of free time he is ready to do no more than actions You have to find out what actions Petya should do so that each chip visits the position that Petya selected for it at least once Or determine that it is not possible to do this in actions ,Note that is a fairly large number of operations Therefore we can first collect all the chips in one cell and then go around the entire board Let s calculate the required number of operations First let s collect all the chips in the cell To do this let s do operations so that all the chips are in the first row then do operations After such operations wherever the chip is initially located it will end up in the cell After that we need to go around the entire board Let s do it in such a way that the rows with odd numbers are be bypassed from left to right and the even ones from right to left We also need operations to move from one row to the next one In total we got operations which is completely suitable for us 
You are responsible for installing a gas pipeline along a road Let s consider the road for simplicity as a segment on axis The road can have several crossroads but for simplicity we ll denote each crossroad as an interval with integer So we can represent the road as a binary string consisting of characters where character means that current interval doesn t contain a crossroad and means that there is a crossroad Usually we can install the pipeline along the road on height of unit with supporting pillars in each integer point so if we are responsible for road we must install pillars But on crossroads we should lift the pipeline up to the height so the pipeline won t obstruct the way for cars We can do so inserting several zig zag like lines Each zig zag can be represented as a segment with integer consisting of three parts units of horizontal pipe unit of vertical pipe of horizontal Note that if pipeline is currently on height the pillars that support it should also have length equal to units Each unit of gas pipeline costs us bourles and each unit of pillar bourles So it s not always optimal to make the whole pipeline on the height Find the shape of the pipeline with minimum possible cost and calculate that cost Note that you start and finish the pipeline on height and also it s guaranteed that the first and last characters of the input string are equal to ,This task was designed as a simple dynamic programming problem but it also can be solved greedily The dp solution is following when we have already built some prefix of the pipeline all we need to know is the length of the prefix the height of the pipeline s endpoint or So we can calculate the following dynamic programming is the minimal answer for prefix of length with pipeline at height Transitions are quite straightforward if then we can either leave the pipeline on the same level or change it If then we have to stay on the height Look at the source code for the formal transitions The answer is The greedy solution is based on the following fact let s look at some subsegment consisting of s It s always optimal either to leave this subsegment on height or raise it to height We can calculate the amount we have to pay in both cases and choose the optimal one 
Let s call of some string as string Analogically let s call of string as string Let s say string is if its left cyclic shift is equal to its right cyclic shift You are given string which consists of digits What is the minimum number of characters you need to erase from to make it good ,Let s analyze when the string is good Suppose it is The cyclic shifts of this string are and We get the following constraints for a good string If the string has odd length then all characters should be equal to each other otherwise all characters on odd positions should be equal and all characters on even positions should be equal Now since there are only different types of characters we can brute force all possible combinations of the first and the second character of the string we want to obtain there are only of them and for each combination greedily construct the longest possible subsequence of beginning with those characters in 
You are given an array consisting of integers from to A subarray is good if the sum of elements of this subarray is equal to the length of this subarray For example if then there are good subarrays and Calculate the number of good subarrays of the array ,We use zero indexing in this solution We also use half closed interval so subarray is Let s precalculate the array where so if sum of first elements of Then subarray is good if so Thus we have to group all prefix by value for from to And if the have prefix with same value of then we have to add to the answer 
Sir Monocarp Hamilton is planning to paint his wall The wall can be represented as a grid consisting of rows and columns Initially the wall is completely white Monocarp wants to paint a black picture on the wall In particular he wants cell the th cell in the th row to be colored black if and to be left white if Additionally he wants each column to have at least one black cell so for each the following constraint is satisfied or both of them will be equal to In order for the picture to turn out smooth Monocarp wants to place down a paint brush in some cell and move it along the path so that for each and share a common side all black cells appear in the path white cells don t appear in the path Determine if Monocarp can paint the wall ,Why is there a constraint of each column having at least one black cell Does the problem change a lot if there were white columns Well if such a column was inbetween some black cells then the answer would be If it was on the side of the grid you could remove it and proceed to solve without it So that doesn t really change the problem other than removing some casework Let s try to fix a start Find a column that has only one black cell in it If there are no such columns the answer is immediately Otherwise the path will always go through it in known directions to the left and to the right if both of them exist Let s solve the problem separately for the left part of the path and for the right one find a path that starts to the left of it and covers everything to the left and the same for the right part Consider the right part If the next column also has one black cell then we can determine where to go uniquely If this cell is on the opposite row then the answer is Otherwise go there and proceed further Let it have two black cells now Find the entire two black row rectangle of maximum size that starts there If there s nothing after it you can easily traverse it any way you like Otherwise you have to traverse it in such a way that you end up in its last column then go to the right from there Turns out there s only one way to achieve that Go up down to another row go right up down to another row right and so on Now you just have to check if you end up in the correct row Thus you can simulate the path to the left and to the right and check if you never get stuck Overall comlexity per testcase 
You are given an array with elements Each element of is either or Let s denote the length of the longest subsegment of consecutive elements in consisting of only numbers one as You can change no more than zeroes to ones to maximize ,Let s call the segment good if it contains no more than zeroes Note if segment is good than the segment is also good So we can use the method of two pointers the first pointer is and the second is Let s iterate over from the left to the right and move while we can to do that we should simply maintain the number of zeroes in the current segment 
You are given an array consisting of integers You are also given an integer value Let be the maximum sum of a contiguous subarray of after applying the following operation add to the elements on exactly positions An empty subarray should also be considered it has sum Note that the subarray doesn t have to include all of the increased elements Calculate the maximum value of for all from to independently ,Consider the naive solution Iterate over Then iterate over the segment that will have the maximum sum Let its length be Since is non negative it s always optimal to increase the elements inside the segment So if then the sum of the segment increases by Otherwise only the elements inside the segment will affect the sum thus it will increase by That can be written as Notice that we only care about two parameters for each segment Its length and its sum Moreover if there are several segments with the same length we only care about the one with the greatest sum Thus the idea of the solution is the following For each length find the segment of this length with the greatest sum Then calculate in by iterating over the length of the segment Overall complexity per testcase 
You are a rebel leader and you are planning to start a revolution in your country But the evil Government found out about your plans and set your punishment in the form of correctional labor You must paint a fence which consists of planks in two colors in the following way suppose planks are numbered from left to right from if the index of the plank is divisible by such planks have indices and so on then you must paint it red if the index of the plank is divisible by such planks have indices and so on then you must paint it blue if the index is divisible both by and to paint the plank otherwise you don t need to paint the plank at all and it is forbidden to spent paint on it Furthermore the Government added one additional restriction to make your punishment worse Let s list all planks of the fence in ascending order if there are consecutive planks with the same color in this list then the Government will state that you failed the labor and execute you immediately If you don t paint the fence according to the four aforementioned conditions you will also be executed The question is will you be able to accomplish the labor the time is not important or the execution is unavoidable and you need to escape at all costs ,At first suppose that if not swap them Let s look at the case where We can be sure that there will be a situation where the th plank is painted in blue and plank is painted in red It s true because it s equivalent to the solution of equation And all we need to check that interval contains less than red planks Or in formulas The situation with is almost the same if we look only at positions which are divisible by in other words we can just divide on and on and check the same condition 
Little Joty has got a task to do She has a line of tiles indexed from to She has to paint them in a strange pattern An unpainted tile should be painted Red if it s index is divisible by and an unpainted tile should be painted Blue if it s index is divisible by So the tile with the number divisible by and can be either painted Red or Blue After her painting is done she will get chocolates for each tile that is painted Red and chocolates for each tile that is painted Blue Note that she can paint tiles in any order she wants Given the required information find the maximum number of chocolates Joty can get ,Easy to see that we can paint with both colours only tiles with the numbers multiple of Obviously that tiles should be painted with more expensive colour So the answer equals to 
 people gathered to hold a jury meeting of the upcoming competition the th member of the jury came up with tasks which they want to share with each other First the jury decides on the order which they will follow while describing the tasks Let that be a permutation of numbers from to an array of size where each integer from to occurs exactly once Then the discussion goes as follows If a jury member has some tasks left to tell then they tell one task to others Otherwise they are skipped If a jury member has some tasks left to tell then they tell one task to others Otherwise they are skipped If a jury member has some tasks left to tell then they tell one task to others Otherwise they are skipped If there are still members with tasks left then the process repeats from the start Otherwise the discussion ends A permutation is nice if none of the jury members tell two or more of their own tasks in a row Count the number of nice permutations The answer may be really large so print it modulo ,Note that if there are at least two members with the maximum value of then any permutation is nice Now let s consider the case when there is only one maximum Let s find out when the permutation is nice Let be the index of the jury member with the maximum number of tasks Then during the th discussion round they will be the only one who will tell their task because the other members of the jury have already told all their tasks So during the th discussion round there should be a jury member who tells a task after the th jury member Let be the number of elements in the array equal to Then if at least one of these jury members goes after the jury member in the permutation then the permutation is nice Using this we will count the number of bad permutations Let s fix the elements in the permutation that are not equal to or there are of them then the number of ways is It remains to place elements so that the maximum is in the last position among them there are such ways The total number of bad permutations is So the answer is 
You are given a string consisting of lowercase Latin letters Character is called dominant iff each substring of with length at least contains this character You have to find minimum such that there exists at least one dominant character ,At first notice that the final answer is minimum over answers for each character The answer for one character can be obtained like this Write down lengths of segments between two consecutive occurrences of this character from the first occurrence to the start of the string and from the last to the end of the string Take maximum of these values Answer will be this maximum 1 Overall complexity 
Monocarp is playing a computer game In this game his character fights different monsters A fight between a character and a monster goes as follows Suppose the character initially has health and attack the monster initially has health and attack The fight consists of several steps the character attacks the monster decreasing the monster s health by the monster attacks the character decreasing the character s health by the character attacks the monster decreasing the monster s health by the monster attacks the character decreasing the character s health by and so on until the end of the fight The fight ends when someone s health becomes non positive i e or less If the monster s health becomes non positive the character wins otherwise the monster wins Monocarp s character currently has health equal to and attack equal to He wants to slay a monster with health equal to and attack equal to Before the fight Monocarp can spend up to coins to upgrade his character s weapon and or armor each upgrade costs exactly one coin each weapon upgrade increases the character s attack by and each armor upgrade increases the character s health by Can Monocarp s character slay the monster if Monocarp spends coins on upgrades optimally ,First of all let s understand how to solve the problem without upgrades To do this it is enough to compare two numbers and the number of attacks that the character needs to kill the monster and the number of attacks that the monster needs to kill the character respectively So if the first number is not greater than the second number then the character wins Note that the number of coins is not very large which means we can iterate over the number of coins that we will spend on weapon upgrades and the remaining coins will be spent on armor upgrades After that we can use the formula described above to check whether the character will win The complexity of the solution is 
You have wooden staves The th stave has length You have to assemble barrels consisting of staves each you can use any staves to construct a barrel Each stave must belong to exactly one barrel Let volume of barrel be equal to the length of the stave in it You want to assemble exactly barrels with the maximal total sum of volumes But you have to make them so a difference between volumes of any pair of the resulting barrels must not exceed i e for any and Print maximal total sum of volumes of barrels or if it s impossible to satisfy the condition above ,At first sort all in non decreasing order Let be first position that if Then each barrel should have at least one stave from segment So if answer is Otherwise for each from to let s take no more than smallest staves from this segment in the th barrel but in such way that there are at least staves left for next barrels 
In the school computer room there are servers which are responsible for processing several computing tasks You know the number of scheduled tasks for each server there are tasks assigned to the th server In order to balance the load for each server you want to reassign some tasks to make the difference between the most loaded server and the least loaded server as small as possible In other words you want to minimize expression where is the most loaded server and is the least loaded one In one second you can reassign a single task Thus in one second you can choose any pair of servers and move a single task from one server to another Write a program to find the minimum number of seconds needed to balance the load of servers ,Denote s the sum of elements in array If s is divisible by n then the balanced array consists of n elements In this case the difference between maximal and minimal elements is 0 Easy to see that in any other case the answer is greater than 0 On the other hand the array consists of numbers and numbers is balanced with the difference equals to 1 Let s denote this balanced array b To get array b let s sort array a in nonincreasing order and match element ai to element bi Now we should increase some elements and decrease others In one operation we can increase some element and decrease another so the answer is Complexity O nlogn 
You have chains the th chain consists of vertices Vertices in each chain are numbered independently from to along the chain In other words the th chain is the undirected graph with vertices and edges connecting the th and the th vertices for each Now you decided to unite chains in one graph in the following way the first chain is skipped the st vertex of the th chain is connected by an edge with the th vertex of the th chain the last th vertex of the th chain is connected by an edge with the th vertex of the th chain Calculate the length of the longest simple cycle in the resulting graph A is a chain where the first and last vertices are connected as well If you travel along the simple cycle each vertex of this cycle will be visited exactly once ,Suppose we ve built the graph and chosen any simple cycle Due to the nature of the graph any simple cycle right part is part of one of the chains So let s for each chain calculate the longest simple path with its right part on this chain and denote it as Obviously Now let s look at chain If we go along the cycle in both ways we will step to vertices and of the previous chain If then we closed cycle and it s the only possible cycle so Otherwise we can either go from and and meet each other closing the cycle with part of the th chain between th and th vertices this part has edges and our cycle will have length But if we decide to go in different ways then we will meet the first and the last vertices of the th chain After that we ll go to the th and the th vertices of th chain and will make almost the same choice But instead of recurrently solving the same problem we can note that in fact we took a cycle that ends at the th chain erased the part between vertices and and merged it with our th chain part so the length of this merged cycle will be equal to Since we maximize we just choose what part or is longer and take it As a result we can iterate from left to right calculate all and print the maximum among them 
Find an matrix with different numbers from to so the sum in each row column and both main diagonals are odd ,The solution can be got from the second sample testcase Easy to see that if we place all odd numbers in the center in form of rhombus we will get a magic square 
You a captain of a ship Initially you are standing in a point obviously all positions in the sea can be described by cartesian plane and you want to travel to a point You know the weather forecast the string of length consisting only of letters and The letter corresponds to a direction of wind Moreover the forecast is periodic e g the first day wind blows to the side the second day the th day and th day again and so on Ship coordinates change the following way if wind blows the direction then the ship moves from to if wind blows the direction then the ship moves from to if wind blows the direction then the ship moves from to if wind blows the direction then the ship moves from to The ship can also either go one of the four directions or stay in place each day If it goes then it s exactly 1 unit of distance Transpositions of the ship and the wind add up If the ship stays in place then only the direction of wind counts For example if wind blows the direction and the ship moves the direction then from point it will move to the point and if it goes the direction then it will move to the point You task is to determine the minimal number of days required for the ship to reach the point ,Note that if we can reach the destination in days so we can reach it in days since we can stay in the destination point by moving to the opposite to the wind direction So we can binary search the answer To check the possibility to reach the destination point in days we should at first look at the position the wind moves ship to Now we can calculate where we can go since each day we can move in one of four directions or not move at all we can reach any point with Manhattan distance So we need to check that To calculate we can note that there were full cycles and extra days So it can be calculated with time using prefix sums Finally about borders of binary search to reach the destination point we need to move closer at least by one it terms of Manhattan distance from the full cycle of the wind So if answer exists then it doesn t exceed 
There is a toy building consisting of towers Each tower consists of several cubes standing on each other The th tower consists of cubes so it has height Let s define operation on some height as following for each tower if its height is greater than then remove some top cubes to make tower s height equal to Cost of one slice equals to the total number of removed cubes from all towers Let s name slice as one if its cost is lower or equal to Calculate the minimum number of good slices you have to do to make all towers have the same height Of course it is always possible to make it so ,Let s iterate over height of slice in decreasing order All we need to know is a number of towers with height more than name it and sum of its heights Current slice on height is good if Let s greedily decrease value while slice on is good keeping correct values and When we found minimal good slice we can perform it increasing answer by one and changing tower heights just by setting new value to equal to Finish algorithm when becomes equal to minimal height of towers and make final slice 
A string is called palindrome if it reads the same from left to right and from right to left For example and are palindroms but strings and are not You are given string consisting of lowercase Latin letters At once you can choose any position in the string and change letter in that position to any other lowercase letter So after each changing the length of the string doesn t change At first you can change some letters in Then you can permute the order of letters as you want Permutation doesn t count as changes You should obtain palindrome with the minimal number of changes If there are several ways to do that you should get the lexicographically alphabetically smallest palindrome So firstly you should minimize the number of changes and then minimize the palindrome lexicographically ,Let s denote cntc the number of occurences of symbol c Let s consider odd values cntc Palindrome can not contain more than one symbol c with odd cntc Let s denote symbols with odd cntc as a1 a2 ak in alphabetical order Let s replace any one of symbols ak with symbol a1 ak 1 with a2 and so on until the middle of a Now we have no more than one odd symbol If we have some let s place it in the middle of the answer First half of answer will contain occurences of symbol c in alphabetical order The second half will contain the same symbols in reverse order For example for string s aabcd at first we will replace d by Unable to parse markup type CF TEX abcba Compexity O n 
Suppose you have two points and Let s denote the Manhattan distance between them as Let s say that three points form a triple if Let s say that an array is if it is impossible to choose three indices such that the points and form a bad triple You are given an array Calculate the number of subarrays of A subarray of the array is the array for some Note that according to the definition subarrays of length and are ,Let s figure out criteria for the bad triple It s not hard to prove that the triple is bad iff point lies inside the bounding box of points and In other words if and Now looking at points and we can see that the bad situation may arise only if so we can check only ordered triples Looking closely at inequality we can note that there are two situations where forms a bad triple when either or In other words subarray is bad if and only if it contains either non decreasing subsequence of length or non increasing subsequence of length The final observation is that any sequence of length at least contains either non decreasing or non increasing subsequence of length It s not hard to prove it either brute forcing all possible variants of relative orders on paper or searching remembering the theorem that says it As a result you need to check only subarrays of length at most whichever the way you want The complexity is 
You are given a set of points on the number line Two points and can be matched with each other if the following conditions hold neither nor is matched with any other point What is the maximum number of pairs of points you can match with each other ,Let s denote the points that have greater coordinates in their matched pairs as points and the points that have smaller coordinates as points Suppose we have an point that has smaller coordinate than some point Then we can swap them and the answer won t become worse Also if some point has smaller coordinate than some point that doesn t belong to any pair or some point has greater coordinate than some point that doesn t belong to any pair we can swap them too So if the answer is we choose leftmost points as points and rightmost ones as points For a fixed value of it s easy to see that we should match the leftmost point with the leftmost point the second point with the second point and so on in order to maximize the minimum distance in a pair This fact allows us to check whether it is possible to construct at least pairs and we can use binary search to compute the answer to the problem 
There is a matrix of size filled with integers For every Obviously every integer from occurs exactly once in this matrix You have traversed some path in this matrix Your path can be described as a sequence of visited cells denoting that you started in the cell containing the number then moved to the cell with the number and so on From the cell located in th line and th column we denote this cell as you can move into one of the following cells only if only if only if only if Notice that making a move requires you to go to an adjacent cell It is not allowed to stay in the same cell You don t know and exactly but you have to find any possible values for these numbers such that you could start in the cell containing the integer then move to the cell containing in one step then move to the cell containing also in one step and so on Can you choose and so that they don t contradict with your sequence of moves ,You can notice that moves of kind and are changing value to and Thus you can determine by checking adjacent nodes in the path The answer is if there are one or zero distinct values of differences not counting difference of You can also set to arbitrary big value it doesn t really matter until you can fit all values will work just fine Finally knowing and simulate the process and check that all moves are valid Overall complexity 
You are given positive integer number You should create such sequence of positive numbers that their sum is equal to and greatest common divisor is maximal Greatest common divisor of sequence is maximum of such numbers that every element of sequence is divisible by them If there is no possible sequence then output ,Notice that GCD of the resulting sequence is always a divisor of Now let s iterate over all divisors up to Current divisor is One of the ways to retrieve resulting sequence is to take their sum is The last number is You should check if is the sum of arithmetic progression its equal to Don t forget that you should consider and if you check divisors up to Take maximum of possible divisors or output if there were no such divisors Overall complexity 
A set of positive integers is called beautiful if for every two integers and from this set either divides or divides or both You are given two integers and Consider all beautiful sets consisting of integers not less than and not greater than You have to print two numbers the maximum possible size of a beautiful set where all elements are from to the number of beautiful sets consisting of integers from to with the maximum possible size Since the second number can be very large print it modulo ,Every beautiful set can be represented as a sequence of its elements in sorted order Let these elements for some set be also let When the set is beautiful every is an integer greater than It s easy to see that if and belong to the whole set belongs to Since in order to maximize we need to choose and as small as possible So why don t we choose and every This will allow us to calculate the maximum possible size of a beautiful set let be this maximum possible size Okay what about counting those sets The claims and that every are no longer true by default However there are some constraints on Firstly every If we had some value of we could replace it with two values of and the size of the set would increase Secondly there is at most one If there are two values we could replace them with three and the size of the set would increase as well So the sequence contains at most one value and the rest of the values are We will divide the sets we want to count into two categories the ones with all and the ones with one value To count the sets in the first category we simply need to count the number of different minimum values in those sets Those minimum values have to be such that multiplying them by wouldn t make them greater than so these are all integers from the segment For every such integer there exists exactly one set of the first category To count the sets in the second category we do a similar thing The minimum value in the set should be from the segment but for every integer from this segment there are different sets of the second category since there are ways to choose which is equal to 
Try guessing the statement from this picture You are given a non negative integer You have to find two non negative real numbers and such that and ,To solve this problem we need to use some math and solve the equation on the paper If then and transforms to or Then where So if then or if there is no answer Since values are small calculating answer in was enough all we need to do is just output answer with sufficient number of digits after the decimal point 
You are given a permutation of length a permutation of length is an array of length in which each integer from to occurs exactly once You can perform the following operation any number of times possibly zero choose two different elements and and erase them from the permutation insert the minimum of and into the permutation in such a way that it becomes the first element insert the maximum of and into the permutation in such a way that it becomes the last element For example if and we want to apply the operation to the elements and then after the first step of the operation the permutation becomes and after we insert the elements it becomes Your task is to calculate the minimum number of operations described above to sort the permutation in ascending order i e transform so that ,If the array is already sorted then the answer is Otherwise there is a last operation after which the permutation takes the form Which means that the elements and are selected as the last operation because they are at the first and last positions after the operation Now we know that the last operation is and it doesn t matter where exactly these numbers are in the permutation i e we can assume that the answer has increased by and consider only the numbers 1 Similarly for the remaining permutation there are two options either it is sorted and then the answer is or there is a last operation and the numbers and are used in it And so on until the remaining permutation is sorted or empty It remains to find out how to quickly check whether the numbers in the segment are sorted they go in the correct order in the initial permutation Note that this segment corresponds to values of elements not to positions in the permutation If this segment is sorted for some then the answer does not exceed There are several ways to check let s consider one of them Note that if the segment is sorted for some value then it will be sorted for large values as well So we can start with the maximum value of which is equal to and decrease it until the segment remains sorted Now for each we need only two checks that and where is the position of the element in the permutation Thus we got the solution in linear time Another way is to run binary search on since if the numbers in appear in the permutation in sorted order the same holds for This approach yields a solution in 
You are given an array which is sorted in non descending order You decided to perform the following steps to create array Create an array consisting of arbitrary integers Set for each Sort the array in non descending order You are given the resulting array For each index calculate what is the minimum and maximum possible value of you can choose in order to get the given array Note that the minimum maximum s are of each other i e they can be obtained from different possible arrays ,For the start let s note that for each Otherwise there is no way to get from Firstly let s calculate for each Since all then is always greater or equal than you get it from So the minimum would come from lowest that still Since is sorted we can find such with in Let s prove that we can build such that transforms to we found earlier Let s just make for for and It s easy to see that all are non negative so such is valid Now let s calculate Suppose we transform to for some It s not hard to prove that the proving array may be constructed in the similar way for for and In order to build such array you need for each In other words if there is some position such that and you can t choose such that It means that we can iterate in descending order and just keep track of leftmost with Then is equal to or if there are no such The resulting complexity is because of the first part But it can be optimized to if we use two pointers instead of 
Petya recieved a gift of a string with length up to characters for his birthday He took two more empty strings and and decided to play a game This game has two possible moves Extract the character of and append with this character Extract the character of and append with this character Petya wants to get strings and empty and string lexicographically minimal You should write a program that will help Petya win the game ,On every step you should maintain minimal alphabetic letter in current string this can be done by keeping array of 26 cells with number of times each letter appear in string nd updating it on every step Let s call string a stack and use its terms Now you extract letters from one by one Put the letter to the top of the stack Pop letters from the top of stack and push them to answer while they are less or equal than any letter left in string After string becomes empty push all the letters from stack to answer The answer will be lexicographically minimal It is obvious if we consider the case when current top of stack is strictly greater than any character from the remaining string or there is a character in that is strictly less than current top If current top is equal to some character then appending answer with the letter from top won t make answer worse Overall complexity where is the length of the alpabet in our case 
You are given a huge integer consisting of digits is between and inclusive It may contain leading zeros You can swap two digits on adjacent neighboring positions if the swapping digits are of different parity that is they have different remainders when divided by For example if you can get the following integers in a single operation if you swap the first and the second digits if you swap the second and the third digits if you swap the fifth and the sixth digits if you swap the sixth and the seventh digits if you swap the seventh and the eighth digits Note that you can t swap digits on positions and because the positions are not adjacent Also you can t swap digits on positions and because the digits have the same parity You can perform any number possibly zero of such operations Find the minimum integer you can obtain ,Let s consider two sequences of digits and there is the first even digit in is the second even digit and so on and is the first odd digit in is the second odd digit and so on Since you can t swap digits of same parity the sequence of even digits of never changed Sequence of odd digits of also never changed So the first digit in the answer will be equal to or to And since we have to minimize the answer we have to chose the as the first digit in answer and them delete it from the corresponding sequence in this way sequence turn into or sequence turn into Second third and followings digits need to choose in the same way 
Let s say you are standing on the plane at point and you want to reach point You can move only in two directions to the i e horizontally and in the direction that increase your coordinate or i e vertically and in the direction that increase your coordinate In other words your path will have the following structure initially you choose to go to the right or up then you go some distance in the chosen direction distances can be chosen independently after that you change your direction from right to up or from up to right and repeat the process You don t like to change your direction too much so you will make no more than direction changes As a result your path will be a polygonal chain from to consisting of line segments where each segment has positive integer length and vertical and horizontal segments alternate Not all paths are equal You have integers where is the cost of the th segment Using these costs we can define the as the sum of lengths of the segments of this path multiplied by their cost i e if the path consists of segments then the cost of the path is equal to segments are numbered from to in the order they are in the path Find the path of the minimum cost and print its cost ,Suppose we decided to make exactly turns or in other words our path will consist of exactly segments Since we should finish at point and vertical and horizontal segments alternates then it means that and From the other side we should minimize But it means that we can minimize and independently How to minimize if we know that and It s easy to prove that it s optimal to assign all except minimum and assign to this minimum the remaining part In other words to calculate the optimal path consisting of segments we need to know the sum of on odd and even positions among and also minimum among odd and even positions Then we can drive out the answer as a quite easy formula Finally we should iterate over all from to and find the minimum answer among all variants It s easy to recalculate sums and minimums when we make transition form to Complexity is 
A big football championship will occur soon teams will compete in it and each pair of teams will play exactly one game against each other There are two possible outcomes of a game the game may result in a tie then both teams get point one team might win in a game then the winning team gets points and the losing team gets points The score of a team is the number of points it gained during all games that it played You are interested in a hypothetical situation when all teams get the same score at the end of the championship A simple example of that situation is when all games result in ties but you want to minimize the number of ties as well Your task is to describe a situation choose the result of each game so that all teams get the same score and the number of ties is the minimum possible ,If is odd then we can solve the problem without any ties each team should win exactly matches and lose the same number of matches Finding which matches each team wins and which matches each team loses can be done with some graph algorithms like Eulerian cycles or circulations or with a simple construction place all teams in a circle in any order and let the th team win against the next teams after it in the circle and lose to all other teams Unfortunately if is even we need to use some ties since the total sum of scores over all teams is exactly when there are no ties and this number is not divisible by when is even Each tie reduces the total sum by and the minimum number of ties to make divisible by is since So if we find an answer with exactly ties it is optimal And it s easy to find one once again place all teams in a circle in any order make the th team win against next teams in the circle lose against previous teams in the circle and tie with the opposite team in the circle 
You have sticks of the given lengths Your task is to choose exactly four of them in such a way that they can form a rectangle No sticks can be cut to pieces each side of the rectangle must be formed by a single stick No stick can be chosen multiple times It is guaranteed that it is always possible to choose such sticks Let be the area of the rectangle and be the perimeter of the rectangle The chosen rectangle should have the value minimal possible The value is taken without any rounding If there are multiple answers print any of them Each testcase contains several lists of sticks for each of them you are required to solve the problem separately ,Let s work with the formula a bit Let then the formula becomes Considering thus is strictly increasing and has its minimum at So the solution will be to sort the list extract the pairs of sticks of equal length and check only neighbouring pairs in sorted order for the answer Overall complexity 
Mishka is trying really hard to avoid being kicked out of the university In particular he was doing absolutely nothing for the whole semester miraculously passed some exams so that just one is left There were classes of that subject during the semester and on th class professor mentioned some non negative integer to the students It turned out the exam was to tell the whole sequence back to the professor Sounds easy enough for those who attended every class doesn t it Obviously Mishka didn t attend any classes However professor left some clues on the values of to help out students like Mishka was sorted in non decreasing order was even the following sequence consisting of elements was formed and given out to students Professor also mentioned that any sequence which produces sequence with the presented technique will be acceptable Help Mishka to pass that last exam Restore any sorted sequence of non negative integers which produces sequence with the presented technique It is guaranteed that there exists at least one correct sequence which produces the given sequence ,Let s present the following greedy approach The numbers will be restored in pairs and so on Thus we can have some limits on the values of the current pair satisfying the criteria about sort Initially and they are updated with Let be minimal possible in the answer Take and That way was chosen in such a way that both and are within the restrictions and is also minimal possible If was any greater than we would move both limit up and limit down leaving less freedom for later choices Overall complexity Funnily enough I coded some naive solution just to test main correct and with restriction of on numbers it passed all tests in 300 ms at max After I saw that I guessed why it worked in but it looked fun nonetheless 
There are two infinite sources of water hot water of temperature cold water of temperature You perform the following procedure of alternating moves take cup of the water and pour it into an infinitely deep barrel take cup of the water and pour it into an infinitely deep barrel take cup of the water and so on The barrel is initially empty You have to pour into the barrel The water temperature in the barrel is an average of the temperatures of the poured cups You want to achieve a temperature as close as possible to So if the temperature in the barrel is then the of and should be as small as possible How many cups should you pour into the barrel so that the temperature in it is as close as possible to If there are multiple answers with the minimum absolute difference then print the smallest of them ,Alice wants to choose such a segment that is maximum possible There is a well known problem where you have to find a segment with maximum That problem is solved with Kadane algorithm Let s learn how to reduce our problem to that one Notice that the values in the array are unusually small Let s iterate over the maximum value on segment Let be the current value If we make all such that equal to then it will never be optimal to take them in a segment Find the maximum sum subarray in that modified array and update the answer with its Notice that you can ignore the fact if there is a value exactly equal to on the maximum sum segment If there isn t then you ll update the answer with a smaller value than the actual one Let the actual maximum on the maximum sum segment be some You can see that for any value between and the maximum sum segment will always be that chosen one Thus when you reach you ll update the answer with the correct value Overall complexity 
Monocarp is playing a computer game once again He is a wizard apprentice who only knows a single spell Luckily this spell can damage the monsters The level he s currently on contains monsters The th of them appears seconds after the start of the level and has health points As an additional constraint for all All are different Monocarp can cast the spell at moments which are positive integer amounts of second after the start of the level The damage of the spell is calculated as follows If he didn t cast the spell at the previous second the damage is Otherwise let the damage at the previous second be Then he can choose the damage to be either or A spell uses mana casting a spell with damage uses mana Mana doesn t regenerate To kill the th monster Monocarp has to cast a spell with damage at least at the exact moment the monster appears which is Note that Monocarp can cast the spell even when there is no monster at the current second The mana amount required to cast the spells is the sum of mana usages for all cast spells Calculate the least amount of mana required for Monocarp to kill all monsters It can be shown that it s always possible to kill all monsters under the constraints of the problem ,Consider the problem with There is a single monster with some health that appears at some second In order to kill it we have to wind up our spell until it has damage So we have to use it from second to second Look at it as a segment on a timeline Actually to avoid handling zero length segments let s instead say that a segment covers the time from non inclusive to inclusive producing a half interval This way the total mana cost will be where is the length of the half interval Now There are two time segments If they don t intersect segments and don t intersect since they are half intervals then it s always better to wind up the spell for the monsters separately instead of saving the damage However if they intersect then we don t have the choice other than to save the damage from the earlier one to the later one Otherwise there won t be enough time to wind up the spell What that means in a mathematic sense The answer is the union of two half intervals If they don t intersect they are left as is Otherwise they become one half interval that covers them both Now add the third monster into the construction The same argument applies While there exists a pair of intersecting half intervals keep uniting them The union of all half intervals can be found in but the constraints allowed slower approaches as well 
You and your friend are playing the game Mortal Kombat XI You are trying to pass a challenge tower There are bosses in this tower numbered from to The type of the th boss is If the th boss is easy then its type is otherwise this boss is hard and its type is During one session either you or your friend can kill bosses neither you nor your friend can skip the session so the minimum number of bosses killed during one session is at least one After your friend session your session begins then again your friend session begins your session begins and so on Your friend needs to get good because he can t actually kill hard bosses To kill them he uses skip points One skip point can be used to kill one hard boss Your task is to find the number of skip points your friend needs to use so you and your friend kill all bosses in the given order For example suppose Then the best course of action is the following your friend kills two first bosses using one skip point for the first boss you kill the third and the fourth bosses your friend kills the fifth boss you kill the sixth and the seventh bosses your friend kills the last boss using one skip point so the tower is completed using two skip points You have to answer independent test cases ,If then our friend always needs one skip point because he always has to kill the first boss Let s just remove this boss from our consideration and increase the answer if needed What about other skip points Firstly let s understand that we can always do our moves in such a way that the first hard boss will always be killed by us except the first one So if it s our friend turn now and there is only one easy boss before the hard our friend just kills this easy boss If there are two easy bosses he kills both If there are three friend kills the first we kill the second and he kills the third And so on So we can always assume that each segment of hard bosses starts with our move We can kill each such segment greedily we kill two bosses and our friend kills one If there are less than three bosses in the segment we just kill remaining and proceed So if the length of the current segment of hard bosses is then we need skip points Summing up these values over all segments we get the answer and don t forget that the first boss should be handled separately Segments of ones can be extracted using two pointers There are also dynamic programming solution but I found this one more clever 
Makes solves problems on Decoforces and lots of other different online judges Each problem is denoted by its difficulty a positive integer number Difficulties are measured the same across all the judges the problem with difficulty on Decoforces is as hard as the problem with difficulty on any other judge Makes has chosen problems to solve on Decoforces with difficulties He can solve these problems in arbitrary order Though he can solve problem with difficulty only if he had already solved some problem with difficulty no matter on what online judge was it With given conditions it s easy to see that Makes sometimes can t solve all the chosen problems no matter what order he chooses So he wants to solve some problems on other judges to finish solving problems from his list Makes can solve problems on any judge at any time it isn t necessary to do problems from the chosen list one right after another Makes doesn t have too much free time so he asked you to calculate the minimum number of problems he should solve on other judges in order to solve all the chosen problems from Decoforces ,Obviously sorting the tasks by difficulty will always produce the most optimal order of solving In that case ability to solve some task will mean ability to solve any task from to Now let s maintain the upper limit of difficulty of problem Makes is able to solve Right after solving some problem it will be Initially it s just Transition from to will then look like this If the upper limit it greater or equal to then we solve this problem and update the upper limit Otherwise we will need some problems from other judges As our goal is to maximize the upper limit the most optimal task to solve is the hardest possible So you should solve task with the difficulty of upper limit and update the limit itself Keep doing it until upper limit becomes grater or equal to You will require no more then tasks from the other judges By algorithm it s easy to see that by solving task with difficulty we update upper limit with the value This function produces such a estimate Overall complexity 
A multi subject competition is coming The competition has different subjects participants can choose from That s why Alex the coach should form a competition delegation among his students He has candidates For the th person he knows subject the candidate specializes in and a skill level in his specialization this level can be negative The rules of the competition require each delegation to choose some subset of subjects they will participate in The only restriction is that the participating in each of the subjects should be the Alex decided that each candidate would participate only in the subject he specializes in Now Alex wonders whom he has to choose to maximize the total sum of skill levels of all delegates or just skip the competition this year if every valid non empty delegation has negative sum Of course Alex doesn t have any spare money so each delegate he chooses must participate in the competition ,At first it s optimal to take candidates with maximal levels for a fixed subject At second if we fix number of participants in each subject for some delegation then it s always optimal to choose all subjects with positive sum of levels It leads us to a following solution Let s divide all candidates by it s and sort each group in non increasing order In result we can just iterate over all prefix sums for each group and update global answer of current length with current sum if it has a positive value 
You are given a sequence of one dimensional segments numbered through Your task is to find two distinct indices and such that segment lies within segment Segment lies within segment iff and Print indices and If there are multiple answers print any of them If no answer exists print ,Let s sort segments firstly by their left border in increasing order and in case of equal by their right border in decreasing order If there is any valid pair then the inner segment will always go after the outer one Now you can go from left to right keep the maximum right border of processed segments and compare it to the current segment Overall complexity 
In some social network there are users communicating with each other in groups of friends Let s analyze the process of distributing some news between users Initially some user receives the news from some source Then he or she sends the news to his or her friends two users are friends if there is at least one group such that both of them belong to this group Friends continue sending the news to their friends and so on The process ends when there is no pair of friends such that one of them knows the news and another one doesn t know For each user you have to determine what is the number of users that will know the news if initially only user starts distributing it ,The first intention after reading the problem is to reformulate it in graph theory terms Let people be vertices edge between two vertices and exists if and have some group in common Basically if person starts distributing the news everyone in his connectivity component recieves it Thus the task is to calculate the number of vertices of each vertex component As of now the graph can have up to edges consider the case where everyone is in the same group Let s reduce the number of edges without changing connectivity components For each group you know for sure that people in it are in the same component Let s connect not just every pair of vertices in it but every pair of neighbouring ones in each group It s easy to see that they are still in the same component This graph will have edges which is a much smaller number You can use dfs or dsu to find the components and their sizes Overall complexity 
You have a sequence with elements Let s call as inversion in a pair of indices such that Suppose you have some permutation of size and you build a sequence of size in the following manner Your goal is to find such permutation that the total number of inversions in doesn t exceed the total number of inversions in and is Small reminder the sequence of integers is called a permutation if it contains all integers from to exactly once Another small reminder a sequence is than another sequence if either is a prefix of or for the first such that holds in the first position that these sequences are different has smaller number than ,At first let s look at sequence Let s prove that the number of inversions in is the same regardless of what are the only condition is that should be distinct Let s group all elements by their value there will be or elements in each group Then we can take any two groups with values and and calculate the number of inversions between elements in these groups It s easy to note that construction will always be like or and regardless of or in both cases there will be exactly two inversions between groups equal to and to or one inversion in the second case So the total number of inversion will be equal to Now we can split sequences and into two parts Let then the first part is elements from segment and the second is from Note that the second parts both in and are exactly the sequence described above The total number of inversions is equal to the sum of inversions in the first part in the second part and the inversions with elements from both parts Note that in the first and the third components are equal to and the second component is constant so in we must also have inversions in the first part and inversion between parts It means that must start from But since the number of inversions in the second part is constant we can set the remaining elements the way we want And since we want to build lexicographically maximum we should make the second part as In the end optimal is The permutation to make such is equal to 
You are given array with integers and queries The th query is given with three integers For the th query find any position so that ,This problem can be solved differently For example you can use some data structures or sqrt decomposition technique But it is not required We expected the following simple solution from the participants Let s preprocess the following values the position of the first element to the left from the th element such that Now to answer to the query we should check if then we have the answer Otherwise we should check the position 
Alice and Bob are playing a game They have an array of positive integers of size Before starting the game Alice chooses an integer The game lasts for stages the stages are numbered from to During the th stage Alice must remove an element from the array that is less than or equal to After that if the array is not empty Bob must add to an arbitrary element of the array Note that both Alice s move and Bob s move are two parts of the same stage of the game If Alice can t delete an element during some stage she loses If the th stage ends and Alice hasn t lost yet she wins Your task is to determine the maximum value of such that Alice can win if both players play optimally Bob plays against Alice so he tries to make her lose the game if it s possible ,Note that if Bob has increased some element then Alice can t remove it on the next stages Obviously it is more profitable for Bob to prohibit the smallest element of the array Using this fact we can iterate over the value of and then simulate the game process To simulate the game we can maintain the set of elements that Alice can remove On the th stage Alice removes the maximum element such that if there are no such elements then Alice lost Bob always removes the minimum element of the set Thus the complexity of the solution is for each test case There is another possible solution we can notice that if Alice wins Bob will prohibit the elements on positions of the sorted array So Alice has to delete the next elements So if the segment of the sorted array can be deleted by Alice during the game phases she wins with this value of 
Numbers each integer from to once are written on a board In one operation you can erase any two numbers and from the board and write one integer instead You should perform the given operation times and make the resulting number that will be left on the board as small as possible For example if the following course of action is optimal choose and so the new number is and the whiteboard contains choose and so the new number is and the whiteboard contains choose and so the new number is and the whiteboard contains It s easy to see that after operations there will be left only one number Your goal is to minimize it ,It s easy to see that we can t get the result less than because if we merge two positive numbers and at least one of them is or greater the new number is always greater than So we can t get rid of all numbers greater than To always achieve we can use a greedy algorithm always merge two maximum numbers During the first step we merge and get then we merge and get then we merge and get and it s easy to see that the last operation is merging and so the result is 
You are given two strings and consisting of lowercase Latin letters Also you have a string which is initially empty You want string to be equal to string You can perform the following operation to achieve this append any subsequence of at the end of string A subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements For example if you may turn into following strings in one operation if we choose subsequence if we choose subsequence if we choose subsequence Note that after this operation string doesn t change Calculate the minimum number of such operations to turn string into string ,The answer is when in string there is a character that is not in string Otherwise let s precalculate the following array minimum index from to such that if there is no such index then Now we can solve this problem by simple greed Presume that now and last taken symbol in is Then there are two options if then if then and is equal to initially 
You have a long fence which consists of sections Unfortunately it is not painted so you decided to hire painters to paint it th painter will paint all sections such that Unfortunately you are on a tight budget so you may hire only painters Obviously only painters you hire will do their work You want to maximize the number of painted sections if you choose painters optimally A section is considered painted if at least one painter paints it ,Let be the number of painters that are painting the th section Let s fix the first painter denote his index as we won t take and decrease the numbers of array in the range which he paints Then we may new array such that is equal to if and only if and otherwise This array corresponds to segments that are painted by only one painter After that we build prefix sum array on array This should be done in Now for each remaining painter we can count the number of sections that are painted only by him For painter it will be equal to Let s denote it as Finally find an painter with the minimum value of denote it as The answer if we choose painter as one of two that won t be hired will be equal to where is the number of elements greater than in the array after removing the painter And of course we should do the same for all painters 
You are given a matrix with rows numbered from to and columns numbered from to A number is written in the cell belonging to the th row and the th column each number is either or A chip is initially in the cell and it will be moved to the cell During each move it either moves to the next cell in the current row or in the current column if the current cell is then after the move it can be either or The chip cannot leave the matrix Consider each path of the chip from to A path is called if the number in the first cell is equal to the number in the last cell the number in the second cell is equal to the number in the second to last cell and so on Your goal is to change the values in the minimum number of cells so that path is ,Let s group the cells by their distance from the starting point the group consists of a single cell the group consists of the cells and and so on In total there are groups Let s analyze the groups and There are two cases if or then we are looking at the starting cell and the ending cell and their contents should be equal otherwise suppose two cells and belong to the same group We can easily prove that the contents of these two cells should be equal for example by analyzing two paths that go through cell and coincide after this cell but one goes to from and another from and using induction we can prove that the contents of all cells in a group should be equal And since the paths should be palindromic the contents of the group should be equal to the contents of the group So in each pair of groups we should calculate the number of s and s and choose which of them to change Note that if is even the central group has no pair so it should not be modified 
There are pearls in a row Let s enumerate them with integers from to from the left to the right The pearl number has the type Let s call a sequence of consecutive pearls a Let s call a segment if it contains two pearls of the same type Split the row of the pearls to the maximal number of good segments Note that each pearl should appear in exactly one segment of the partition As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,Let s solve the problem greedily Let s make the first segment by adding elements until the segment will be good After that let s make the second segment in the same way and so on If we couldn t make any good segment then the answer is Otherwise let s add all uncovered elements at the end to the last segment Easy to prove that our construction is optimal consider the first two segments of the optimal answer obviously we can extend the second segment until the first segment will be equal to the first segment in our construction 
Polycarp wants to assemble his own keyboard Layouts with multiple rows are too complicated for him his keyboard will consist of only one row where all lowercase Latin letters will be arranged in some order Polycarp uses the same password on all websites where he is registered it is bad but he doesn t care He wants to assemble a keyboard that will allow to type this password very easily He doesn t like to move his fingers while typing the password so for each pair of adjacent characters in they should be adjacent on the keyboard For example if the password is then the layout is perfect since characters and are adjacent on the keyboard and and are adjacent on the keyboard It is guaranteed that there are no two adjacent equal characters in so for example the password cannot be two characters are adjacent Can you help Polycarp with choosing the perfect layout of the keyboard if it is possible ,The problem can be solved using a greedy algorithm We will maintain the current layout of the keyboard with letters that have already been encountered in the string and the current position on the layout If the next letter of the string is already on the layout it must be adjacent to the current one otherwise there is no answer If there was no such letter yet we can add it to the adjacent free position if both of them is occupied then there is no answer At the end you have to add letters that were not in the string 
You may have already known that a standard ICPC team consists of exactly three members The perfect team however has more restrictions A student can have some specialization coder or mathematician So the team is considered perfect if it includes at least one coder at least one mathematician and it consists of exactly three members You are a coach at a very large university and you know that of your students are coders are mathematicians and have no specialization What is the maximum number of full perfect teams you can distribute them into Note that some students can be left without a team and each student can be a part of no more than one team You are also asked to answer independent queries ,Notice that if then you can equalize them to the min and re qualify the rest into students without specialization That won t change the answer Now analyze the possible team formations 1 of each kind 2 coders and 1 mathematician or 1 coder and 2 mathematicians Each of these squads have 1 coder and 1 mathematician so you can only choose the type of the third member The students without specialization can only be used in the first kind of teams so let s use them first After that you might have been left with a nonzero count of coders and mathematicians These are equal however so can be added to the answer This solves each query in You can also run a binary search and solve each query in 
You are given two positive integer numbers and Permute change order of the digits of to construct maximal number not exceeding No number in input and or output can start with the digit It is allowed to leave as it is ,Let s construct the answer digit by digit starting from the leftmost Obviously we are asked to build lexicographically maximal answer so in this order we should choose the greatest digit on each step Precalc number of digits in number Iterate over all possible digits starting from the greatest For each digit check if it s possible to put it in this position For this you construct minimal suffix greedily put the lowest digit and compare the resulting number with number If it became less or equal then proceed to the next digit Overall complexity where is digits from to 
Alice and Bob play ping pong with simplified rules During the game the player serving the ball commences a play The server strikes the ball then the receiver makes a return by hitting the ball back Thereafter the server and receiver must alternately make a return until one of them doesn t make a return The one who doesn t make a return loses this play The winner of the play commences the next play Alice starts the first play Alice has stamina and Bob has To hit the ball while serving or returning each player spends stamina so if they don t have any stamina they can t return the ball and lose the play or can t serve the ball in this case the other player serves the ball instead If both players run out of stamina the game is over Sometimes it s strategically optimal not to return the ball lose the current play but save the stamina On the contrary when the server commences a play they have to hit the ball if they have some stamina left Both Alice and Bob play optimally and want to firstly maximize their number of wins and secondly minimize the number of wins of their opponent Calculate the resulting number of Alice s and Bob s wins ,Let s find an answer for a little different version of the game Let s say that is the final score if the first player has stamina and the second has stamina The first player can either hit the ball or How to calculate Obviously and Otherwise the first player can either hit the ball then the player spent stamina and now it s to the second player to decide hit or lose So basically we moved to the state and the answer in this case is where or lose the play then the player doesn t spend any stamina but the opponent serve the ball He serves the ball spend stamina and return to the state where the first player decides hit or lose Formally the answer in this case is Looking at and one of transitions we can guess that and prove it by induction is either or but and and is better than so The final step is to note that since Alice starts the first play and serve ball the answer is 
You have a playlist consisting of songs The th song is characterized by two numbers and its length and beauty respectively The pleasure of listening to set of songs is equal to the total length of the songs in the set multiplied by the minimum beauty among them For example the pleasure of listening to a set of songs having lengths and beauty values is equal to You need to choose songs from your playlist so the pleasure of listening to the set of these songs them is maximum possible ,If we fix a song with minimum beauty in the answer then we need to take the remaining songs or less among those having beauty greater than or equal to the beauty of the fixed song and the longer they are the better So we will iterate on the songs in the order of decreasing their beauty and for the current song we will maintain longest songs having greater or similar beauty This can be done using some standard containers in or in 
You are given a string consisting only of characters and You perform some process with this string This process can be described by the following pseudocode Note that the denotes infinity and the characters of the string are numbered from to You have to calculate the value of the after the process ends ,Let s replace all with and all with After that let s create a preffix sum array Also lets create array such that is equal minimum index such that if there is no such index Let s consider the first iteration of loop If then process ends and Otherwise the condition fulfilled then the value of will be equal to So the value of is equal to after first iteration Now let s consider the second iteration of loop If then process ends and Otherwise the condition fulfilled then the value of will be equal to So the value of is equal to after second iteration In this way we can calculate the value of after the process ends 
Monocarp is playing yet another computer game In this game his character has to kill a dragon The battle with the dragon lasts seconds during which Monocarp attacks the dragon with a poisoned dagger The th attack is performed at the beginning of the th second from the battle start The dagger itself does not deal damage but it applies a poison effect on the dragon which deals damage during each of the next seconds starting with the same second when the dragon was stabbed by the dagger However if the dragon has already been poisoned then the dagger updates the poison effect i e cancels the current poison effect and applies a new one For example suppose and Monocarp stabs the dragon during the seconds and Then the poison effect is applied at the start of the nd second and deals damage during the nd and rd seconds then at the beginning of the th second the poison effect is reapplied so it deals exactly damage during the seconds and then during the th second the poison effect is applied again and it deals damage during the seconds and In total the dragon receives damage Monocarp knows that the dragon has hit points and if he deals at least damage to the dragon during the battle he slays the dragon Monocarp has not decided on the strength of the poison he will use during the battle so he wants to find the minimum possible value of the number of seconds the poison effect lasts that is enough to deal at least damage to the dragon ,Let s find out the total damage for a fixed value of Since the effect of the poison from the th attack deals damage seconds for and seconds for then the total damage is We can see that the higher the value of the greater the total sum So we can do a binary search on and find the minimum value when the sum is greater than or equal to 
You are given an angle The Jury asks You to find such gon regular polygon with vertices that it has three vertices and they can be non consecutive with or report that there is no such gon If there are several answers print the one It is guarantied that if answer exists then it doesn t exceed ,At first let prove that all possible angles in the regular gon equal to where To prove it we can build circumscribed circle around gon Then the circle will be divided on equal arcs with lengths Any possible angle in the gon is a inscribed angle in the circle and equal to half of central angle Any central angle in turn equals to sum of some consecitive arcs In result any angle equal to The maximal possible angle is reached from three consecutive vertices and equal by properties of regular polygons to So we need to find minimal integer such that where is integer and Its equivalent to find minimal integer solution of Let then we can divide both parts on In result Since then must divide Analogically must divide Then solution is next and We are finding the minimal solution so is almost always except cases where here we must take since we have restricition on The picture for the futher visibility 
Ivan likes to learn different things about numbers but he is especially interested in numbers Ivan thinks that a positive integer number is if the difference between and the sum of its digits in decimal representation is not less than To prove that these numbers may have different special properties he wants to know how rare or not rare they are in fact he needs to calculate the quantity of numbers that are not greater than Ivan tried to do the calculations himself but soon realized that it s too difficult for him So he asked you to help him in calculations ,Let s prove that if is then is too Since the sum of digits of let s call it is not greater than then and if then So if is then is This observation allows us to use binary search to find the minimum number let s call it And if then all numbers in the segment are and not greater than so the quantity of these numbers is the answer to the problem 
A bracket sequence is a string containing only characters and A regular bracket sequence or shortly an RBS is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and bracket sequences and are not There was an RBS Some brackets have been replaced with question marks Is it true that there is a way to replace question marks with brackets so that the resulting sequence is an RBS ,There are many different approaches to this problem but I think the model solution has the most elegant one First of all let s construct an RBS from the given string it always exists so it is always possible By calculating the number of opening brackets closing brackets and questions in the given string we can compute the number of question marks that should be replaced with opening brackets it is easy since exactly half of the characters in each RBS are opening brackets Then let s form the RBS greedily replace the first several question marks with opening brackets and all remaining ones with closed brackets Okay then what about finding a second RBS Recall that a bracket sequence is an RBS when for each of its positions the number of closing brackets before it is not greater than the number of opening brackets before it and these two values should be equal at the end of the sequence but it is less important now Consider the segment between the last question mark replaced with an opening bracket and the first question mark replaced by the closing bracket If we try to change the order of characters corresponding to question marks the balance on this segment will decrease at least by since at least one opening bracket to the left of it will become a closing bracket Is there a way to affect only this segment and change the balance on it only by Yes just swap the endpoints of this segment i e the last opening bracket that was a question mark and the first closing bracket that was also a question mark If it yields an RBS then the answer is Otherwise the answer is since any other permutation of characters that were replacing question marks will also decrease the balance on this segment by at least 
You are given string consists of opening and closing brackets of four kinds There are two types of brackets opening and closing You can replace any bracket by another of the same type For example you can replace by the bracket but you can t replace it by or The following definition of a regular bracket sequence is well known so you can be familiar with it Let s define a regular bracket sequence RBS Empty string is RBS Let and be a RBS then the strings are also RBS For example the string is RBS but the strings and are not Determine the least number of replaces to make the string RBS ,If we forget about bracket kinds the string s should be RBS otherwise the answer doesn t exist If the answer exists each opening bracket matches to exactly one closing bracket and vice verse Easy to see that if two matching brackets have the same kind we don t need to replace them In other case we can change the kind of the closing bracket to the kind of the opening So we can build some answer Obviously the answer is minimal because the problems for some pair of matching pairs are independent and can be solved separately The only technical problem is to find the matching pairs To do that we should store the stack of opening brackets Let s iterate from left to right in s and if the bracket is opening we would simply add it to the stack Now if the bracket is closing there are three cases 1 the stack is empty 2 at the top of the stack is the opening bracket with the same kind as the current closing 3 the kind of the opening bracket differs from the kind of the closing bracket In the first case answer doesn t exist in the second case we should simply remove the opening bracket from the stack and in the third case we should remove the opening bracket from the stack and increase the answer by one Complexity O n 
There are robots driving along an OX axis There are also two walls one is at coordinate and one is at coordinate The th robot starts at an integer coordinate and moves either left towards the or right with the speed of unit per second No two robots start at the same coordinate Whenever a robot reaches a wall it turns around instantly and continues his ride in the opposite direction with the same speed Whenever several robots meet at the same coordinate they collide and explode into dust Once a robot has exploded it doesn t collide with any other robot Note that if several robots meet at a non integer coordinate nothing happens For each robot find out if it ever explodes and print the time of explosion if it happens and otherwise ,Notice that the robots that start at even coordinates can never collide with the robots that start at odd coordinates You can see that if a robot starts at an even coordinate it ll be at an even coordinate on an even second and at an odd coordinate on an odd second Thus we ll solve the even and the odd cases separately Sort the robots by their starting coordinate Apparently that step was an inconvenience for some of you There is a common trick that can help you to implement that Create a separate array of integer indices and sort them with a comparator that looks up the value by indices provided to tell the order This gives you the order of elements and doesn t require you to modify the original data in any way Consider the task without reflections of the wall Take a look at the first robot If it goes to the left then nothing ever happens to it Otherwise remember that it goes to the right Look at the next one If it goes to the left then it can collide with the first one if that went to the right Otherwise remember that it also goes to the right Now for the third one If this one goes to the left who does it collide with Obviously the rightmost alive robot that goes to the right So the idea is to keep a stack of the alive robots If a robot goes to the left then check if the stack is empty If it isn t then the top of the stack robot is the one who will collide with it Pop it from the stack since it explodes If a robot goes to the right simply push it to the stack The time of the collision is just the distance between the robots divided by If there are robots left in the stack after every robot is processed then they all go to the right together so they never collide What changes when the reflections are introduced Almost nothing actually Well now if the stack is empty and a robot goes to the left then it behaves as a one going to the right You can reflect the part of the way from its start to the wall Just say that instead of starting at some going to the left it starts at going to the right Since there s no one alive to the left of him initially that will change nothing That should be used for computing the collision time However the final robots in the stack also act differently First the top of the stack robots reflects off the wall and collides with the second on the stack one Then the third and the fourth and so on So you can pop them in pairs until or are left The coordinate reflection trick can be used here as well Imagine that the top of the stack starts at and goes to the left instead of starting in going to the right For the same reason it changes nothing Overall complexity 
There is a grid consisting of rows and columns The rows are numbered from to from top to bottom The columns are numbered from to from left to right The robot starts in a cell In one second it can perform either of two actions move into a cell adjacent by a side up right down or left remain in the same cell The robot is not allowed to move outside the grid Initially all cells except for the cell are locked Each cell contains a value the moment that this cell gets unlocked The robot can only move into a cell if at least seconds have passed before the move The robot should visit all cells cell is considered entered at the start It can finish in any cell What is the fastest the robot can achieve that ,Let s first consider the possible paths across the grid that visit all cells You can immediately think of two of them The first one is go right to the wall turn into the other row and return Let s call it a hook The second one is go down go right go up go right and so on Let s call it a snake Turns out these two are basically the two extremes of all paths You can start with a snake and turn into a hook when you wish You can see that once you move right twice in a row you can only continue with a hook And as long as you didn t move right twice you are just doing a snake Let s fix some path across the grid What will its minimum time be Calculate it iteratively If you want to enter the next cell and it s still locked wait until it isn t So there are some seconds of waiting possibly zero before each cell However why not instead do the following Let s calculate the sum of waiting time required and wait for that amount of seconds before starting to move All cells will be visited at the same time as before or even later Thus they will surely be unlocked if they were in the original plan So the goal is to calculate the minimum amount of time required to wait in the start then add the movement time to it Once again the path is fixed Let the th cell of the path be If you start after waiting for seconds then you reach the th cell at time is indexed Thus the th cell should have If all cells satisfy this condition then the path can be done after waiting for seconds at the start Let s rewrite it into So the condition tells us that should be greater or equal than this value for all cells In other words should be greater or equal than the maximum of the values over all cells Study the formula Imagine we have some path with a known length and want to append a cell to it That s pretty simple Just update the maximum with the value with the corresponding cell and increase the length What if we wanted to prepend a cell to it Turns out it s not that hard as well Every cell in the path gets its value increased by From the formula you can see that this actually decreases the value of each cell by So the maximum decreases by as well The only thing left is to update the maximum with the value of the new first cell Well and increase the length again Finally let s learn how to choose the best path We can iterate over the length of the snake part The hook part is determined uniquely It s easy to maintain the maximum on the snake Just append the new cell to the path How to glue up the hook part to that Well actually realize that the formula allows us to glue up two paths into one Let path have length and maximum and path have length and maximum To make path start after path we just decrease its maximum by The resulting path has length and maximum Let s look closer into what the hooks look like They start in some column traverse all the way right then left up to the same column If the snake part took both cells in its last column then that s it Otherwise the hook has to take the final cell in the last column column If we manage to precalculate something for hooks that start in some column and end in column then we will be able to use that Appending the final cell is not a hard task since we know its index in the path Let be the waiting time required for a hook that starts in cell and ends in a cell as if the path started with the hook cell is the first one can be calculated from Prepend it with a cell and append it with a cell The only thing left is to find the best answer I found the most convenient to start with a snake of length only cell and progress it two steps at the time update the answer progress the snake to the other cell of the current column update the answer progress the snake into the next column Overall complexity per testcase 
Vova promised himself that he would never play computer games But recently Firestorm a well known game developing company published their newest game World of Farcraft and it became really popular Of course Vova started playing it Now he tries to solve a quest The task is to come to a settlement named Overcity and spread a rumor in it Vova knows that there are characters in Overcity Some characters are friends to each other and they share information they got Also Vova knows that he can bribe each character so he or she starts spreading the rumor th character wants gold in exchange for spreading the rumor When a character hears the rumor he tells it to all his friends and they start spreading the rumor to their friends for free and so on The quest is finished when all characters know the rumor What is the minimum amount of gold Vova needs to spend in order to finish the quest Take a look at the notes if you think you haven t understood the problem completely ,In this problem you are given an undirected graph with weighted vertices And the problem is to calculate the sum of minimum values in every connected component To do this we just need to run or several times 
Monocarp has been collecting rare magazines for quite a while and now he has decided to sell them He distributed the magazines between boxes arranged in a row The th box contains magazines Some of the boxes are covered with lids others are not Suddenly it started to rain and now Monocarp has to save as many magazines from the rain as possible To do this he can move the lids between boxes as follows if the th box was covered with a lid initially he can either move the lid from the th box to the box if it exists or keep the lid on the th box You may assume that Monocarp can move the lids instantly at the same moment and no lid can be moved more than once If a box will be covered with a lid after Monocarp moves the lids the magazines in it will be safe from the rain otherwise they will soak You have to calculate the maximum number of magazines Monocarp can save from the rain ,Let s process the boxes from left to right Consider the first box If it has a lid then you can just add the number of magazines in it to the answer and forget about this box To be exact proceed to solve the problem with the first box removed If it doesn t have a lid then look at the next box If it doesn t have a lid too then this box can never be covered Remove it and proceed further If the next box has a lid then look at the next one Again if it doesn t have a lid then these two first boxes are solved independently of everything else You can cover exactly one of them Choose the bigger one and remove them both To propagate the argument let s derive a pattern First there s a box without a lid Then some number of boxes with lids in a row Then a box without a lid again Among the first box and the box with lids you can choose exactly one to not be covered However that can be any one of them The best box to be left uncovered is the one with the smallest number of magazines in it Thus the solution is the following As long as the first box has a lid keep removing the first box and adding it to the answer Then as long as there are boxes left take the first box and the largest number of consecutive boxes with lids after it that number might be zero On that segment find the minimum value and the sum Add the sum minus the minimum to the answer remove the entire segment The removals can be done explicitly with a queue or just a reversed vector or implicitly with maintaining a pointer to the first non removed box Overall complexity 
There are workers and tasks The workers are numbered from to Each task has a value the index of worker who is proficient in this task Every task should have a worker assigned to it If a worker is proficient in the task they complete it in hour Otherwise it takes them hours The workers work in parallel independently of each other Each worker can only work on one task at once Assign the workers to all tasks in such a way that the tasks are completed as early as possible The work starts at time What s the minimum time all tasks can be completed by ,The statement should instantly scream binary search at you Clearly if you can assign the workers in such a way that the tasks are completed by time you can complete them all by or more as well How to check if the tasks can be completed by some time What that means is that all workers have hours to work on some tasks If all tasks took hours to complete then each of them could complete of them Thus together they would be able to complete tasks How to incorporate the hour tasks into that Well we can redistribute the tasks in such a way that each worker first completes the tasks they are proficient in then some other tasks if they have more time So the general idea is the following Let each worker complete hour tasks where is the number of tasks the th worker is proficient in Then remember how many hour tasks they can complete which is Finally remember how many tasks that they are proficient in they didn t have time to complete which is If the sum of the number of incomplete tasks doesn t exceed the sum of the number of tasks they have time to complete then everything can be completed in time Worst case it can take up to hours to complete everything if you assign all tasks to a single worker and they are not proficient in any of them Overall complexity per testcase 
Suppose you have boxes The th box contains infinitely many balls of color Sometimes you need to get a ball with some specific color but you re too lazy to do it yourself You have bought two robots to retrieve the balls for you Now you have to program them In order to program the robots you have to construct two lists and where the list represents the boxes assigned to the first robot and the list represents the boxes assigned to the second robot When you request a ball with color the robots work as follows Each robot looks through the boxes that were assigned to that robot in the order they appear in the list The first robot spends seconds analyzing the contents of a box the second robot spends As soon as one of the robots finds the box with balls of color and analyzes its contents the search ends The search time is the number of seconds from the beginning of the search until one of the robots finishes analyzing the contents of the th box If a robot analyzes the contents of all boxes assigned to it it stops searching For example suppose If you request a ball with color the following happens initially the first robot starts analyzing the box and the second robot starts analyzing the box at the end of the nd second the first robot finishes analyzing the box It is not the box you need so the robot continues with the box at the end of the rd second the second robot finishes analyzing the box It is not the box you need so the robot continues with the box at the end of the th second the first robot finishes analyzing the box It is not the box you need so the robot continues with the box at the end of the th second the first robot finishes analyzing the box It is not the box you need so the robot continues with the box At the same time the second robot finishes analyzing the box It is not the box you need and the second robot has analyzed all the boxes in its list so that robot stops searching at the end of the th second the first robot finishes analyzing the box It is the box you need so the search ends so the search time is seconds You know that you are going to request a ball of color times a ball of color times and so on You want to construct the lists and for the robots in such a way that the total search time over all requests is the minimum possible ,If the ball of color x is present in the first list on position i then it takes i cdot t 1 seconds to find it The same for the second list if color x is on position j it takes j cdot t 2 seconds to find it So for each position we have a coefficient which will be multiplied by the number of times it is requested and the total search time is the sum of these products for all positions There is a classical problem of the form you are given two arrays a i and b i both of length m consisting of non negative integers permute the elements of a in such a way that sum limits i 1 m a i cdot b i is the minimum possible To solve this problem you have to pair the maximum element of a with the minimum element of b the second maximum of a with the second minimum element of b and so on We can reduce our problem to this one For each of 2n positions in the lists there is a coefficient you have to assign the boxes from 1 to n to the positions so that the sum of r i multiplied by the coefficients for the positions is the minimum possible This looks similar but there are 2n positions and only n boxes To resolve this issue we can try a lot of different approaches I believe the easiest one is the following initially both lists are empty and when want to add an element to one of these two lists we choose the list such that the coefficient for the new position which is s i cdot 1 cnt i where cnt i is the number of elements we already added to the i th list is smaller If for both lists adding a new element has the same coefficient it doesn t matter which one we choose This greedy approach works because every time we add an element to the list next time we ll add another one into the same list the coefficient for that element will be greater So the problem can be solved in O n log n first we sort the boxes by the number of times they are requested in non ascending order and then we put them into the two lists greedily every time choosing the list such that the coefficient for the next element is smaller 
You are given an integer array and integer In one step you can either choose some index and decrease by one make or choose two indices and and set equal to make What is the minimum number of steps you need to make the sum of array You are allowed to make values of array negative ,First we can prove that the optimal way to perform operations is first decrease the minimum value several maybe zero times then take several maybe zero maximums and make them equal to the minimum value The proof consists of several steps Prove that first we make decreases only then sets if some is done after some then if there were no modification of then you can just move earlier Otherwise there were and you can replace with We demonstrated how to move decrease operations before set operations Prove that it s optimal to decrease only one element instead of decreasing by and by where we can decrease by and replace all with It s optimal to decrease the minimum element it follows from proof of previous step If we make set operations it s optimal to set minimum value to maximum elements should be obvious To use the strategy we ll firstly sort array in non decreasing order In this case we ll decrease by and perform set to elements The question is how to minimize value of Note that since setting the same position multiple times has no sense Let s iterate over all possible values of and determine the minimum needed The resulting array will consists of Let s say that and all can be precomputed beforehand Then the sum of array will become and we need or since we need minimum possible Using the formula above we can for each calculate minimum required But to be accurate value may be negative and usually in programming languages integer division for negative returns instead of There is an alternative solution note that if then Note that if then resulting value of is in and there are at most possible value for So you can iterate over all possible and for each calculate minimum required either with binary search or two pointers 
 loves simple strings A string is called simple if every pair of adjacent characters are distinct For example are simple whereas are not simple is given a string He wants to change a minimum number of characters so that the string becomes simple Help him with this task ,There are two ways to solve this problem greedy approach and dynamic programming The first apprroach Considerr some segment of consecutive equal characters Let be the length of that segment Easy to see that we should change at least characters in the segment to remove all the pairs of equal consecutive letters On the other hand we can simply change the second the fourth etc symbols to letter that is not equal to the letters before and after the segment 
Recently Petya learned about a new game Slay the Dragon As the name suggests the player will have to fight with dragons To defeat a dragon you have to kill it and defend your castle To do this the player has a squad of heroes the strength of the th hero is equal to According to the rules of the game exactly one hero should go kill the dragon all the others will defend the castle If the dragon s defense is equal to then you have to send a hero with a strength of at least to kill it If the dragon s attack power is then the total strength of the heroes defending the castle should be at least The player can increase the strength of any hero by for one gold coin This operation can be done any number of times There are dragons in the game the th of them has defense equal to and attack power equal to Petya was wondering what is the minimum number of coins he needs to spend to defeat the th dragon Note that the task is solved improvements are not saved ,It is enough to consider two cases whether we will increase the strength of the hero who will kill the dragon or not If you do not increase the hero s strength then you have to choose such that Obviously among such you have to choose with the minimum value because the strength of defending heroes is equal to It remains to increase the total strength of the remaining heroes to So the required number of coins is equal to If you increase the hero s strength then you have to choose the maximum value of which is less than In this case the required number of coins is to increase the strength of the hero who will kill the dragon plus to increase the strength of the defending heroes To find the heroes with strength as close to as possible you can use binary search don t forget to sort the heroes beforehand 
Yet another round on DecoForces is coming Grandpa Maks wanted to participate in it but someone has stolen his precious sofa And how can one perform well with such a major loss Fortunately the thief had left a note for Grandpa Maks This note got Maks to the sofa storehouse Still he had no idea which sofa belongs to him as they all looked the same The storehouse is represented as matrix Every sofa takes two neighbouring by some side cells No cell is covered by more than one sofa There can be empty cells Sofa is standing to the left of sofa if there exist two such cells and that is covered by and is covered by Sofa is standing to the top of sofa if there exist two such cells and that is covered by and is covered by Right and bottom conditions are declared the same way Also some sofa can be both to the top of another sofa and to the bottom of it The same is for left and right conditions The note also stated that there are sofas to the left of Grandpa Maks s sofa to the right to the top and to the bottom Grandpa Maks asks you to help him to identify his sofa It is guaranteed that there is no more than one sofa of given conditions Output the number of Grandpa Maks s sofa If there is no such sofa that all the conditions are met for it then output ,Coordinates don t exceed so it s possible to use sweep line method to solve the problem Let s calculate value separately for each side I will show the algorithm for left side and all the others will be done similarly Let be the number of sofas which has smaller of their coordinates less than or equal to To count that let s firstly increment by one for all sofas and then proceed from left to right and do Now will represent number of sofas to the left of the current one but the sofa itself can also be counted You need to decrement the result by one if The same is for top value but with coordinates insted of For the right and bottom values you should calculate and Then take and The only thing left is to compare values of each sofa with given ones and find the suitable sofa Overall complexity 
Santa has to send presents to the kids He has a large stack of presents numbered from to the topmost present has number the next present is and so on the bottom present has number All numbers are distinct Santa has a list of presents he has to send He will send them To send a present Santa has to find it in the stack by removing all presents above it taking this present and returning all removed presents on top of the stack So if there are presents above the present Santa wants to send it takes him seconds to do it Fortunately Santa can speed the whole process up when he returns the presents to the stack he may reorder them as he wishes only those which were above the present he wanted to take the presents below cannot be affected in any way What is the minimum time required to send all of the presents provided that Santa knows the whole list of presents he has to send and reorders the presents optimally Santa cannot change the order of presents or interact with the stack of presents in any other way Your program has to answer different test cases ,At first let s precalculate array pos such that pos a i i Now presume that we have to calculate answer for b i Then there are two cases let s denote lst max limits 1 le j i pos b j initially lst 1 if pos b i lst then we have to spend 1 2 cdot pos b i i 1 seconds on it second on the gift b i pos b i i 1 seconds on removing gifts above and pos b i i 1 seconds on pushing these gifts if pos b i lst then we can reorder gifts by previous actions such that gift b i be on the top of stack So we spend only second on it 
You are playing a game where your character should overcome different obstacles The current problem is to come down from a cliff The cliff has height and there is a moving platform on each height from to Each platform is either hidden inside the cliff or moved out At first there are moved out platforms on heights The platform on height is moved out and the character is initially standing there If you character is standing on some moved out platform on height then he can pull a special lever which switches the state of In other words the platform you are currently standing on will hide in the cliff and the platform one unit below will change it state it will hide if it was moved out or move out if it was hidden In the second case you will safely land on it Your character is quite fragile so it can safely fall from the height no more than In other words falling from the platform to platform is okay but falling from to or lower is certain death Sometimes it s not possible to come down from the cliff but you can always buy for donate currency several magic crystals Each magic crystal can be used to change the state of any single platform except platform on height which is unaffected by the crystals After being used the crystal disappears What is the minimum number of magic crystal you need to buy to safely land on the ground level ,You are given the input data in compressed format let s decompress it in binary string where the th character is if the th platform is hidden and otherwise For example the third query is Let s look how our string changes if we had then after pulling the lever it becomes and if we had then we d get The underlined index is the platform we are currently on So it looks like we are standing on and move it to the left until it clashes with the next one So we can determine that we should look only at subsegments on s Now we can note that the good string should have all subsegments of ones with even length except two cases the subsegment that starts from should have odd length and subsegment which ends in can have any length Now we can say that the answer is equal to number of subsegments which doesn t match the pattern of the good string since we can fix each subsegment with one crystal And we can prove that it s optimal since the only way to fix two subsegments with one crystal is to merge them but it does not help Finally we can understand that we have no need in decompressing the input and can determine subsegments of ones straightforwardly 
Ivan is playing a strange game He has a matrix with rows and columns Each element of the matrix is equal to either or Rows and columns are indexed Ivan can replace any number of ones in this matrix with zeroes After that his score in the game will be calculated as follows Initially Ivan s score is In each column Ivan will find the topmost that is if the current column is then he will find minimum such that If there are no s in the column this column is skipped Ivan will look at the next elements in this column starting from the element he found and count the number of s among these elements This number will be added to his score Of course Ivan wants to maximize his score in this strange game Also he doesn t want to change many elements so he will replace the minimum possible number of ones with zeroes Help him to determine the maximum possible score he can get and the minimum possible number of replacements required to achieve that score ,Let s notice that this task can be solved independently for each column total result will be the sum of results for columns The ones you should remove will always be the top ones in column It makes no profit to erase some one while there are still ones on top of it score won t become higher Go from the top of the column to the bottom and recalculate the score after removing every one Take the first position of the maximal score and update global answer with it Overall complexity can be achieved with partial sums 
You are given a string consisting of small english letters In one move you can replace any character of this string to the next character in alphabetical order will be replaced with will be replaced with etc You cannot replace letter with any other letter Your target is to make some number of moves not necessary minimal to get string english alphabet as a subsequence Subsequence of the string is the string that is obtained by deleting characters at some positions You need to print the string that will be obtained from the given string and will be contain english alphabet as a subsequence or say that it is impossible ,The problem can be solved by the next greedy algorithm At first we need to store the last character of the alphabet we haven t obtained for example in variable initially it will be equal to Then we will just iterate over all characters of the string from left to right and if the current character of the string is not greater than we just replace it to and increase by 1 If in any moment will be greater than we got the answer And if after iterating over the string will be not greater than the answer is 1 
For an array let s denote its as the array For example the array has non empty subarrays You are given two integers and Construct an array consisting of integers such that all elements of are from to has exactly subarrays with positive sums the rest subarrays of have negative sums ,There are many ways to solve this problem I will describe the following recursive solution if let s compose an array where every segment ending with the th element is positive and every other segment is negative This array can be where is the th element of the array note that when doesn t belong to the array so it consists of only negative numbers but if solve the same problem with and recursively get an array of length with positive subarrays and append to it to make all segments ending with the last element positive 
You have an array consisting of integers Each integer from to appears exactly once in this array For some indices it is possible to swap th element with th for other indices it is not possible You may perform any number of swapping operations any order There is no limit on the number of times you swap th element with th if the position is not forbidden Can you make this array sorted in ascending order performing some sequence of swapping operations ,Take a look at some pair such that and initial It means that all the swaps from to should be allowed Then it s easy to notice that it s enough to check only and as any other pair can be deducted from this You can precalc for each and prefix sums over the string of allowed swaps to check it in no time Overall complexity 
Polycarp invited all his friends to the tea party to celebrate the holiday He has cups one for each of his friends with volumes His teapot stores milliliters of tea Polycarp wants to pour tea in cups in such a way that Every cup will contain tea for at least half of its volume Every cup will contain integer number of milliliters of tea All the tea from the teapot will be poured into cups All friends will be Friend with cup won t be if there exists such cup that cup contains less tea than cup but For each cup output how many milliliters of tea should be poured in it If it s impossible to pour all the tea and satisfy all conditions then output ,At first let s pour minimal amount of tea in each cup that is If it requires more tea than available then it s Now let s sort cups in non increasing order by volume and start filling up them until we run out of tea in the teapot It s easy to see that everyone will be satisfied that way If sequence of is non increasing then sequence of is also non increasing So we can t make someone unsatisfied by filling the cup with maximal possible volume And finally get the right order of cups back and print the answer Overall complexity 
A tea manufacturer decided to conduct a massive tea tasting sorts of tea will be tasted by tasters Both the sorts of tea and the tasters are numbered from to The manufacturer prepared milliliters of the th sort of tea The th taster can drink milliliters of tea at once The tasting will be conducted in steps During the first step the th taster tastes the th sort of tea The th taster drinks tea how much is available of the th sort and how much the th taster can drink also decreases by this amount Then all tasters move to the previous sort of tea Thus during the second step the th taster tastes the st sort of tea The th taster drinks tea The st person ends the tasting During the third step the th taster tastes the nd sort of tea The nd taster ends the tasting This goes on until everyone ends the tasting Take a look at the tasting process for In the left row there are the current amounts of each sort of tea In the right column there are current amounts of tea each taster has drunk in total The arrow tells which taster each tea goes to on the current step The number on the arrow is the amount minimum of how much is available of the sort of tea and how much the taster can drink For each taster print how many milliliters of tea he she will drink in total ,Consider how each sort of tea affects the tasters The th sort makes testers for some drink to their limit and the th taster drink the remaining tea Sometimes there is no such th taster but we ll explore the general case Let s add the remaining tea straight to the th taster answer And for each taster from to we ll add into the value denoting how many times they drank at their limit If we have these calculated we can obtain the answer by adding and In order to find we can use prefix sums Build over the sequence Now you want to find the largest such that Rewrite it as You can do this with a binary search In particular with an upper bound call The amount of the remaining tea can also be calculated from prefix sums To add on a range you can use a technique called delta encoding Add to Subtract from After everything is added propagate this values via a prefix sum This way if both and happened non strictly to the left or strictly to the right of it doesn t affect at all the segment either closes before or opens after Otherwise it adds exactly to Overall complexity per testcase 
You are given a rectangular field of cells Each cell is either empty or impassable contains an obstacle Empty cells are marked with impassable cells are marked with Let s call two empty cells if they share a side Let s call a any non extendible set of cells such that any two of them are connected by the path of adjacent cells It is a typical well known definition of a connected component For each impassable cell imagine that it is an empty cell all other cells remain unchanged and find the size the number of cells of the connected component which contains You should do it for each impassable cell independently The answer should be printed as a matrix with rows and columns The th symbol of the th row should be if the cell is empty at the start Otherwise the th symbol of the th row should contain the only digit the answer modulo The matrix should be printed without any spaces To make your output faster it is recommended to build the output as an array of strings having length and print it as a sequence of lines It will be much faster than writing character by character As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,Let s enumerate all the connected components store their sizes and for each empty cell store the number of it s component It can be done with a single dfs Now the answer for some impassable cell is equal to one plus the sizes of all different adjacent connected components Adjacent means the components of cells adjacent to the current impassable cell in general case each unpassable cell has four adjacent cells 
You are given a binary string recall that a string is binary if each character is either or Let be the decimal representation of integer written in binary form possibly with leading zeroes For example and The substring is good if For example string has good substrings and Your task is to calculate the number of good substrings of string You have to answer independent queries ,At first lets precalc the array The value of if equal the maximum position in range such that After that lets iterate over the right boundary of substring and high bit position denote it as and respectively Note that if then So we iterate over such pair that and Lets look at value If then we have to increase the length of substring without increasing the value of So we need to check if there exists a position such that and This position exists if the condition is met is equal to 1 
You re given a list of strings You d like to concatenate them together in some order such that the resulting string would be lexicographically smallest Given the list of strings output the lexicographically smallest concatenation ,Let s sort all the strings by comparator and concatenate them Let s prove that it s the optimal answer Let that operator be transitive so if Consider an optimal answer with two strings in reverse order by that operator Because of the transitivity of operator we can assume that pair of strings are neighbouring But then we can swap them and get the better answer Let s prove the transitivity of operator Consider the strings as the base numbers Then the relation equivalent to The last is simply the relation between real numbers So we proved the transitivity of the relation 
Alice got tired of playing the tag game by the usual rules so she offered Bob a little modification to it Now the game should be played on an undirected rooted tree of vertices Vertex is the root of the tree Alice starts at vertex and Bob starts at vertex The moves are made in turns Bob goes first In one move one can either stay at the current vertex or travel to the neighbouring one The game ends when Alice goes to the same vertex where Bob is standing Alice wants to minimize the total number of moves and Bob wants to maximize it You should write a program which will determine how many moves will the game last ,If you check some games then you will notice that the most optimal strategy for Bob is always like this Climb up for some steps possibly zero Go to the lowest vertex from it Stay in this vertex till the end Thus let s precalc the depth the distance from the root of the lowest vertex of each subtree using dfs distance from Alice s starting node and from Bob s starting node to the vertex again dfs bfs Now iterate over all vertices and check if Bob can reach this vertex earlier than Alice If he can then update the answer with the lowest vertex that can be reached from this one The answer is doubled depth of the obtained lowest reachable vertex That is the time which will take Alice to get there Overall complexity 
Mishka is decorating the Christmas tree He has got three garlands and all of them will be put on the tree After that Mishka will switch these garlands on When a garland is switched on it periodically changes its state sometimes it is lit sometimes not Formally if th garland is switched on during th second then it is lit only during seconds and so on Mishka wants to switch on the garlands in such a way that during each second after switching the garlands on there would be at least one lit garland Formally Mishka wants to choose three integers and not necessarily distinct so that he will switch on the first garland during th second the second one during th second and the third one during th second respectively and during each second starting from at least one garland will be lit Help Mishka by telling him if it is possible to do this ,There are pretty few cases to have One of is equal to At least two of are equal to All equal It s easy to notice that having minimum of equal to produce the only case greater numbers will always miss some seconds Let s consider minimum of let it cover all odd seconds Now you should cover all even seconds and and are the only possible solutions Overall complexity 
You are given two integers and Calculate the number of pairs of arrays such that the length of both arrays is equal to each element of each array is an integer between and inclusive for any index from to array is sorted in non descending order array is sorted in non ascending order As the result can be very large you should print it modulo ,Let s consider the following sequence It s sequence of length sorted in non descending order where each element of each sequence is an integer between and We can find the number of such sequences by simple combinatorics it s combination with repetitions So the answer is 
You are given a string consisting of brackets of two types and A string is called a regular bracket sequence RBS if it s of one of the following types empty string RBS RBS RBS RBS where plus is a concatenation of two strings In one move you can choose a non empty subsequence of the string not necessarily consecutive that is an RBS remove it from the string and concatenate the remaining parts without changing the order What is the maximum number of moves you can perform ,Notice that it s never optimal to erase a subsequence of length greater than because every RBS of length above contains an RBS of length inside and removing it won t break the regular property of the outside one So the task can be solved for the round and the square brackets independently the answer will be the sum of both Let s solve the version for brackets and In general you just want to remove consecutive substring until there is no more left in the string That can be done by processing the string from left and right and maintaining a stack of current brackets If the top bracket in it is and the current bracket is then you can increment the answer and remove that bracket from the stack Otherwise you push the current bracket to the stack Overall complexity per testcase 
One very important person has a piece of paper in the form of a rectangle Also he has seals Each seal leaves an impression on the paper in the form of a rectangle of the size Each impression must be parallel to the sides of the piece of paper but seal can be rotated by 90 degrees A very important person wants to choose two different seals and put them two impressions Each of the selected seals puts exactly one impression Impressions should not overlap but they can touch sides and the total area occupied by them should be the largest possible What is the largest area that can be occupied by two seals ,If you can place two rectangles in some way without rotations then it s always possible to move one of them to the top left corner and stick the other either to the bottom of the first and push it all the way to the left or to the right of it and push it all the way to the top Now let s try all possible reorderings and rotations for every pair of seals If there is at least one correct reordering then update the answer Overall complexity 
Polycarp is a great fan of television He wrote down all the TV programs he is interested in for today His list contains shows th of them starts at moment and ends at moment Polycarp owns two TVs He can watch two different shows simultaneously with two TVs but he can only watch one show at any given moment on a single TV If one show ends at the same moment some other show starts then you can t watch them on a single TV Polycarp wants to check out all shows Are two TVs enough to do so ,Let s process all the segments on the line from left to right For each segment we should push events and into some array Sort this array of pair in increasing order usual less comparator for pairs Then we iterate over its elements and maintain the current amount of open segments we passed their left border and didn t pass their right border When we meet the event of the first type we increment the value of the second type decrement If in some moment then the answer is Overall complexity 
You are given a string consisting of the characters and Let s call a string if it consists of the characters and and any two adjacent characters are different i e it has the form or Let s call a string if it consists of the characters and and you can replace the characters to or for each character the choice is independent so that the string becomes For example the strings and are beautiful and the strings and are not Calculate the number of beautiful contiguous substrings of the string ,Let s find a simple condition when the string is not beautiful A string is not beautiful if there are two characters or two characters at an odd distance or and at an even distance because in this case the string cannot be made unstable Iterate over the right border of the substring Let be the maximum index such that the substring is not beautiful or if the substring is beautiful Then we have to add to the answer since any substring of a beautiful string is also beautiful Denote as the last occurrence of or at the position of parity Let is the parity of then i e find the nearest character that breaks a beautiful substring at an odd distance or at an even distance The case for is similar If then we can choose what this character will be Obviously we need to choose the option with the smaller value of 
Vasya has an array You don t know this array but he told you facts about this array The th fact is a triple of numbers and and it means if then subbarray is sorted in non decreasing order if then subbarray is not sorted in non decreasing order A subarray is not sorted if there is at least one pair of consecutive elements in this subarray such that the former is greater than the latter For example if then he could give you three facts the subarray is sorted the subarray is not sorted and the subarray is not sorted You don t know the array Find array which satisfies all the given facts ,Let s consider array such that Then subarray is sorted in non decreasing order if and only if all elements are greater or equal to zero So if we have fact then all elements must be greater or equal to zero Let s create the following array if there is such a fact that and otherwise After that we create the following array and for all other indexes This array satisfies all facts such that So all we have to do is check that all remaining facts are satisfied 
Vasya has a multiset consisting of integer numbers Vasya calls some number nice if it appears in the multiset exactly once For example multiset contains nice numbers and Vasya wants to split multiset into two multisets and in such a way that the quantity of nice numbers in multiset would be the same as the quantity of nice numbers in multiset the quantity of numbers to appear exactly once in multiset and the quantity of numbers to appear exactly once in multiset ,Write down all the numbers which appear exactly once let there be of them If is even put the first of them into the first multiset and put the other into the second multiset All the other numbers which appear more than once also go into the first multiset The only nice numbers will be the initial thus the answer is valid If is odd and there is no number to appear more than twice then the answer is as all the numbers to appear exactly twice don t change the difference of the amounts of the nice numbers at all If there is a number to appear more than twice let it be then let s firstly add of the numbers to appear exactly once to the first multiset add others of them to the second multiset Then the first occurrence of goes to the second multiset and all the other numbers go to the first multiset It s easy to notice that multisets will contain equal number of the nice numbers after all the partitioning 
Vasya has got a robot which is situated on an infinite Cartesian plane initially in the cell Robot can perform the following four kinds of operations move from to move from to move from to move from to Vasya also has got a sequence of operations Vasya wants to modify this sequence so after performing it the robot will end up in Vasya wants to change the sequence so the length of changed subsegment is minimum possible This length can be calculated as follows where is the maximum index of a changed operation and is the minimum index of a changed operation For example if Vasya changes to then the operations with indices and are changed so the length of changed subsegment is Another example if Vasya changes to then the length of changed subsegment is Help Vasya Tell him the minimum length of subsegment that he needs to change so that the robot will go from to or tell him that it s impossible ,Denote If then the answer is 1 since the robot will not have the time to reach cell in steps Also if and have different parity then the answer is also 1 as in one move the robot changes the parity of the sum of its coordinates In all other cases the answer exists Let s use binary search to solve this problem Consider all segments of length For a fixed length of the segment let s iterate over the position of the beginning of the segment At the same time we will maintain the cell that the robot will stop at if it execute all commands except commands with indices We denote this position as We also calculate the distances from the cell to the cell the value If there is at least one position of the beginning of the segment for which then we can change the segment of length so that the robot comes to the cell otherwise it can t 
Vasya s house is situated in a forest and there is a mushroom glade near it The glade consists of two rows each of which can be divided into consecutive cells For each cell Vasya knows how fast the mushrooms grow in this cell more formally how many grams of mushrooms grow in this cell each minute Vasya spends exactly one minute to move to some adjacent cell Vasya cannot leave the glade Two cells are considered adjacent if they share a common side When Vasya enters some cell he instantly collects all the mushrooms growing there Vasya begins his journey in the left upper cell Every minute Vasya must move to some adjacent cell he cannot wait for the mushrooms to grow He wants to visit all the cells and maximize the total weight of the collected mushrooms Initially all mushrooms have a weight of Note that Vasya doesn t need to return to the starting cell Help Vasya Calculate the maximum total weight of mushrooms he can collect ,A route visiting each cell exactly once can always be denoted as follows several possibly zero first columns of the glade are visited in a zigzag pattern then Vasya goes to the right until the end of the glade makes one step up or down and goes left until he visits all remaining cells There are such routes To calculate the weight of collected mushrooms quickly we will precompute three arrays for the first row of the glade and will be used to compute the weight of mushrooms collected when Vasya moves to the right until the last column of the glade when Vasya moves to the left from the last column and to handle the growth of mushrooms Also we have to compute the same arrays for the second row of the glade Let s iterate on the number of columns Vasya will pass in a zigzag pattern and maintain the weight of mushrooms he will collect while doing so Then we have to add the weight of the mushrooms Vasya will gather while moving to the right and then while moving to the left The first can be handled by arrays and the second by arrays and 
There are trees in a park numbered from to The initial height of the th tree is You want to water these trees so they all grow to the height The watering process goes as follows You start watering trees at day During the th day you can Choose a tree and water it If the day is odd e g then the height of the tree increases by If the day is even e g then the height of the tree increases by Or skip a day without watering any tree Note that you can t water more than one tree in a day Your task is to determine the number of days required to water the trees so they grow to the same height You have to answer independent test cases ,The first observation we need to solve this problem the required height is either or where is the maximum initial height of some tree We don t need heights greater than because for example if the height is we can remove some moves and get the answer for the height The same thing applies to all heights greater than Why do we even need the height In some cases like the answer for the height is better than the answer for the height in this particular case it is vs Now we have two ways to solve the problem either use some gross formulas or just write a binary search on the answer I won t consider the solution with formulas but we have one so let s assume we use binary search Let the current answer be Then let be the number of operations we can do and be the number of operations we can do We can use operations greedily and then just check if the number of operations is sufficient to grow up the remaining heights Time complexity per test case 
You have a card deck of cards numbered from top to bottom i e the top card has index and bottom card index Each card has its color the th card has color You should process queries The th query is described by integer For each query you should find the highest card in the deck with color i e the card with minimum index print the position of the card you found take the card and place it on top of the deck ,Let s look at one fixed color When we search a card of such color we take the card with minimum index and after we place it on the top of the deck it remains the one with minimum index It means that for each color we take and move the same card one card for each color In other words we need to keep track of only cards where is the number of colors As a result if is the position of a card of color then we can simulate a query in the following way for each color such that we increase by one since the card will move down and then set Complexity is But if we look closely we may note that we don t even need array We can almost manually find the first card of color and move it to the first position either by series of swaps or for example using function present in C and it will work fast Why Let s look at one color For the first time it will cost operations to search the corresponding card and move it to the position But after that at any moment of time the position of the card won t exceed since all cards before are pairwise different due to the nature of queries So all next moves the color costs only time As a result the complexity of such almost naive solution is 
You are given two integers and and queries The th query consists of two numbers and and the answer to it is the number of integers such that and Calculate the answer for each query Recall that is the remainder of the division of by For example ,It s quite easy to see that ab x bmod a bmod b x bmod a bmod b What does it mean The property given in the statement holds for x if and only if it holds for x bmod ab It allows us to answer each testcase in O ab q as follows for each number from 0 to ab 1 we may check the given property before processing the queries and build an array of prefix sums on it to efficiently count the number of integers satisfying the property from the segment 0 y where y ab Then each query l r can be divided into two prefix queries 0 l 1 and 0 r To answer a prefix query 0 p in O 1 we can calculate the number of full segments of length ab inside this prefix that is lfloor frac p ab rfloor and the length of the last segment of numbers that don t belong into a full segment that is p bmod ab To handle full segments we multiply the number of integers satisfying the property on one segment by the number of such segments and to handle the last part of segment we use prefix sums 
You are participating in Yet Another Tournament There are participants you and other opponents numbered from to Each two participants will play against each other exactly once If the opponent plays against the opponent he wins if and only if When the opponent plays against you everything becomes a little bit complicated In order to get a win against opponent you need to prepare for the match for at least minutes otherwise you lose to that opponent You have minutes in total to prepare for matches but you can prepare for only one match at one moment In other words if you want to win against opponents you need to spend minutes for preparation and if this number is greater than you cannot achieve a win against all of these opponents at the same time The final place of each contestant is equal to the number of contestants with strictly more wins For example if contestants have wins each contestant has wins and contestants have win each then the first participants will get the st place the fourth one gets the th place and two last ones get the th place Calculate the minimum possible place lower is better you can achieve if you can t prepare for the matches more than minutes in total ,Suppose at the end you won matches what can be your final place Look at each opponent with indexed Since the th opponent indexed won games against the other opponents even if they win against you they ll gain wins in total and can t affect your place since your place is decided by only opponents who won strictly more matches than you From the other side let s look at each opponent with indexed Even if they lose to you they still have wins you have only so all of them have strictly more wins than you As a result there is only one opponent whose match against you can affect your final place if you won against them your place will be otherwise your place will be Now let s compare your possible places if you win games with places for winning only games wins gives you places or while winning leads you to places or that objectively worse In other words it s always optimal to win as many matches as possible How to win the most number of games It s to choose the easiest opponents Let s sort array and find the maximum prefix with So we found maximum number of games we can win The last is to check can we get place or only If contains among smallest values then we ll take place Otherwise let s try to insert in this set i e let s erase the biggest among them and insert If the sum is still lower or equal to it s success and we get place Otherwise our place is The total complexity is because of sorting 
You have a string a sequence of commands for your toy robot The robot is placed in some cell of a grid He can perform four commands W move one cell up S move one cell down A move one cell left D move one cell right Let be the grid of minimum possible area such that there is a position in the grid where you can place the robot in such a way that it will not fall from the grid while running the sequence of commands For example if then is the grid you can place the robot in the cell the robot performs the command D and moves to the robot performs the command S and moves to the robot performs the command A and moves to the robot performs the command W and moves to the robot performs the command W and moves to the robot performs the command A and moves to the robot performs the command W and moves to You have extra letters one W one A one S one D You d like to insert in any position of sequence to minimize the area of What is the minimum area of you can achieve ,The problem asks us to maintain the bounding box while inserting the character of one of types between every adjacent characters in Of course we can do it but do we really to do it in such way Let s think a little Inserting W or S doesn t affect the width of the bounding box and A or D doesn t affect the height So they are absolutely independent And we can divide our WASD string on WS string and AD string Moreover inserting W or S in WS string and A or D in AD string is almost same thing so we don t even need to write different code for different string How to handle only WS string Let s replace W as and S as and suppose that we started in position Then the position where we go after commands is just prefix sum of first elements Then the length of the bounding box is maximum position minimum position 1 The maximum minimum position is a maximum minimum element in array of prefix sums What the inserted value do It add to suffix of Let s choose for example The can t decrease the maximum but can increase the minimum so we need to place it somewhere before all minimums in or before the first minimum But if we place it before any of maximum elements then we will increase it and prevent decreasing the length of bounding box So we need to place somewhere after all maximums on or after the last maximum And here goes the solution find position of the first minimum in and position of the last maximum If then we can insert and decrease the length of bounding box but since we insert command that move robot we can t achieve bounding box of length What to do with Just multiply by and now we can insert instead of in absolutely same manner What to do with AD string Denote A as and D as and everything is absolutely the same 
You are given a regular polygon with vertices it s convex and has equal sides and equal angles and all its sides have length Let s name it as gon Your task is to find the square of the minimum size such that you can embed gon in the square Embedding gon in the square means that you need to place gon in the square in such way that each point which lies inside or on a border of gon should also lie inside or on a border of the square You can rotate gon and or the square ,It s not hard to come up with a solution if you just imagine how gon looks when is even The solution is to rotate gon in such way that several its sides are parallel to sides of the square And the answer is equal to the distance from center to any side multiplied by two or 
You are given a regular polygon with vertices it s convex and has equal sides and equal angles and all its sides have length Let s name it as gon Your task is to find the square of the minimum size such that you can embed gon in the square Embedding gon in the square means that you need to place gon in the square in such way that each point which lies inside or on a border of gon should also lie inside or on a border of the square You can rotate gon and or the square ,At first lets place gon in such way that the lowest side of gon is horizontal Now we can without loss of generality think that the square has horizontal and vertical sides and we just rotate gon around its center If we rotate the gon at angle then it will move on itself Moreover after rotating at angle we ll get left and right sides vertical and the following rotation is meaningless since it s the same as if we just swap and coordinates So we don t we to rotate more than Also we can see that while rotating the difference between max and min decreasing while the distance between max and min increasing The answer is obviously the maximum among these differences So for example we can just ternary search the optimal answer Or we can note that the behavior of differences is symmetrical just swap and coordinates so the answer is in the middle angle i e we just need to rotate gon at angle Finally observing several right triangles we can come up with quite an easy answer 
You are given a tree an undirected connected acyclic graph consisting of vertices and edges A number is written on each edge each number is either let s call such edges edges or those are edges Let s call an ordered pair of vertices if while traversing the simple path from to we never go through a edge after going through a edge Your task is to calculate the number of pairs in the tree ,Let s divide all valid pairs into three categories the ones containing only edges on the path the ones containing only edges and the ones containing both types of edges To calculate the number of pairs containing only edges we may build a forest on the vertices of the original graph and edges and choose all pairs of vertices belonging to the same connected components of this forest we can find all connected components with DSU or any graph traversal algorithm The same can be done for the pairs containing only edges If a path from to is valid and contains both types of edges then there exists a vertex such that the simple path from to goes only through edges and the simple path from to goes only through edges So let s iterate on this vertex and choose some other vertex from its component in graph as and some other vertex from its component in graph as and add the number of ways to choose them to the answer 
Alice and Bob play a game There is a paper strip which is divided into cells numbered from left to right starting from There is a chip placed in the th cell the last one Players take turns Alice is first Each player during his or her turn has to move the chip or cells to the left so if the chip is currently in the cell the player can move it into cell or The chip should not leave the borders of the paper strip it is impossible for example to move it cells to the left if the current cell has number The player who can t make a move loses the game Who wins if both participants play optimally Alice and Bob would like to play several games so you should determine the winner in each game ,Let s determine for each cell whether it s winning or losing position we can do it since the game is symmetric and doesn t depend on a player The th cell is obviously losing the st and nd ones is both winning since we can move to the th cell and put our opponent in the losing position here comes criterion the position is winning if and only if there is a move to the losing position If is large enough then the th rd th th are losing So here comes divisibility by If then this move doesn t change anything since if then so it s not the move to the losing position so doesn t become the winning one Otherwise if then the th positions becomes winning but the th cell is losing all moves are to th th or st cells and all of them are winning The th and th cells are winning and so on In the end we came up with cycle of length where position divisible by except are losing All we need to do is small case work 
You are playing a computer game where you lead a party of soldiers Each soldier is characterised by his agility The level you are trying to get through can be represented as a straight line segment from point where you and your squad is initially located to point where the boss is located The level is filled with traps Each trap is represented by three numbers and is the location of the trap and is the danger level of the trap whenever a soldier with agility lower than steps on a trap that is moves to the point he gets instantly killed Fortunately you can disarm traps if you move to the point you disarm this trap and it no longer poses any danger to your soldiers Traps don t affect you only your soldiers You have seconds to complete the level that is to bring some soldiers from your squad to the boss Before the level starts you choose which soldiers will be coming with you and which soldiers won t be After that you have to bring to the boss To do so you may perform the following actions if your location is you may move to or This action consumes one second if your location is and the location of your squad is you may move to or to with your squad in one second You may not perform this action if it puts some soldier in danger i e the point your squad is moving into contains a non disarmed trap with greater than agility of some soldier from the squad This action consumes one second if your location is and there is a trap with you may disarm this trap This action is done instantly it consumes no time Note that after each action both your coordinate and the coordinate of your squad should be integers You have to choose the maximum number of soldiers such that they all can be brought from the point to the point where the boss waits in no more than seconds ,When we fix a set of soldiers we can determine a set of traps that may affect our squad these are the traps with danger level greater than the lowest agility value So we can use binary search on minimum possible agility of a soldier that we can choose How should we actually bring our soldiers to the boss Each trap that can affect our squad can be actually treated as a segment such that our squad cannot move to until we move to and disarm this trap We should walk through such segments for three times the first time we walk forwards without our squad to disarm the trap the second time we walk backwards to return to our squad and the third time we walk forwards with our squad So the total time we have to spend can be calculated as where is the number of unit segments belonging to at least one trap segment and it can be calculated with event processing algorithms or with segment union Time complexity is or but it is possible to write a solution in without binary search 
The string is good if each letter of this string belongs to at least one palindrome of length than A palindrome is a string that reads the same backward as forward For example the strings are palindromes but the strings are not Here are some examples of good strings letters belong to palindrome and letters belong to palindrome letters belong to palindrome and letter belongs to palindrome all letters belong to palindrome You are given a string of length consisting of letters and You have to calculate the number of good substrings of string ,Instead of counting the number of good substrings let s count the number of bad substrings then number of good substrings is equal to Let s call a character in string is bad if there is no such palindrome that Any character in substring is good It can be proven as follows If or then belong to a palindrome of length If and then belong to a palindrome So only characters and can be bad But at the same time character is bad if there is no character such that and It is true because substring is palindrome index is minimum index such that So there are only patterns of bad strings All that remains is to count the number of substrings of this kind 
You are given a directed graph consisting of vertices and edges each edge is directed so it can be traversed in only one direction You are allowed to remove at most one edge from it Can you make this graph acyclic by removing at most one edge from it A directed graph is called acyclic iff it doesn t contain any cycle a non empty path that starts and ends in the same vertex ,The constraits are set in such a way that naive solution won t pass unmark every edge one by one and check if graph of marked edges doesn t contain cycles with dfs bfs Thus we should somehow limit the number of edges to check Let s take arbitrary cycle in graph Do dfs store the vertex you used to travel to any other vertex and restore edges with this data if cycle is met With this algo length of cycle will not exceed Then do the naive algo but check only edges from this cycle Overall complexity 
A permutation of size is an array such that every integer from to occurs exactly once in this array Let s call a permutation an iff there exist at least indices such that Your task is to count the number of permutations for given numbers and ,Let s iterate on the number of indices such that Obviously How to count the number of permutations with fixed First of all we need to choose the indices that have the property there are ways to do this Secondly we need to construct a permutation for chosen indices such that for every chosen index permutations with this property are called and the number of derangements of fixed size can be calculated using exhaustive search since So the answer is where is the number of derangements of size 
You are given two circles Find the area of their intersection ,If the circles don t intersect than the answer is 0 We can check that case with only integer calculations simply by comparing the square of distance between centers with square of the sum of radiuses If one of the circles is fully in other then the answer is the square of the smaller one We can check this case also with only integer calculations simply by comparing the square of distance between centers with square of the difference of radiuses So now let s consider the general case The answer will be equal to the sum of two circular segments Let s consider the triangle with apexes in centers if circles and in some intersecting point of the circles In that triangle we know all three sides so we can compute the angle of the circular segment So we can compute the square of circular sector And the only thing that we should do now is to subtract the square of triangle with apexes in the center of circle and in the intersecting points of circles We can do that by computing the half of absolute value of cross product So we have the following formulas where d is the distance between centers of the circles And also we should do the same thing with second circle by replacing of indices 1 ftrightarrow2 Complexity O 1 
There are armchairs numbered from to from left to right Some armchairs are occupied by people at most one person per armchair others are not The number of occupied armchairs is not greater than For some reason you would like to tell people to move from their armchairs to some other ones If the th armchair is occupied by someone and the th armchair is not you can tell the person sitting in the th armchair to move to the th armchair The time it takes a person to move from the th armchair to the th one is minutes You may perform this operation any number of times but these operations must be done sequentially i e you cannot tell a person to move until the person you asked to move in the last operation has finished moving to their destination armchair You want to achieve the following situation every seat that was initially occupied must be free What is the minimum time you need to do it ,Let s say that the starting position of people are in sorted order and ending positions of people are also in sorted order It s always optimal to match these starting and ending positions in sorted order the leftmost starting position is matched with the leftmost ending the second starting position is matched with the second ending and so on To prove it suppose that position is matched with position is matched with and If both persons go to the left or to the right it means that either or so nothing changes if we swap the matched positions If instead the person that goes from to goes to the right and the person that goes from to goes to the left the segment belongs to both paths and swapping the matched pairs removes this segment from both paths and decreases the total time So if the order of starting positions is sorted and the order of ending positions is sorted these positions should be matched exactly in those order Using this fact we can implement the following dynamic programming let be the minimum time if we considered first positions and picked of them as the ending ones Transitions are the following we either take the current position as the ending one if it s not a starting one match it with the th starting position and go to or we skip the current position and go to It works in since it has up to states and just up to transitions from each state 
Vasya has an array consisting of positive integer numbers Vasya wants to divide this array into two non empty consecutive parts the prefix and the suffix so that the sum of all elements in the first part equals to the sum of elements in the second part It is not always possible so Vasya will move some element before dividing the array Vasya will erase some element and insert it into an arbitrary position Can Vasya divide the array after choosing the right element to move and its new position ,Suppose we want to move an element from the prefix to the suffix if we need to move an element from the suffix to the prefix we can just reverse the array and do the same thing Suppose the resulting prefix will contain elements Then we need to check that the prefix with elements contains an element such that the sum of this prefix without this element is equal to the half of the sum of the whole array and then we can move this element to the suffix To check all the prefixes we can scan the array from left to right while maintaining the set of elements on the prefix and the sum of these elements 
You are given an array and an integer You are asked to divide this array into non empty consecutive subarrays Every element in the array should be included in exactly one subarray Let be the index of subarray the th element belongs to Subarrays are numbered from left to right and from to Let the cost of division be equal to For example if and we divide it into subbarays in the following way then the cost of division is equal to Calculate the maximum cost you can obtain by dividing the array into non empty consecutive subarrays ,Let s denote as just a suffix sum And let be the position where starts the th subarray obviously and Then we can make an interesting transformation So our task is equivalent to choosing sum of all array and different suffix sums And we want to maximize their total sum That s why we can just greedily take maximum suffix sums along with sum of all array 
You ve got a job in a game studio that developed an online shooter and your first big task is to help to balance weapons The game has weapons the th gun has an integer fire rate and an integer damage per bullet The th gun s total firepower is equal to You have to modify the values of some guns in such a way that the new values will still be integers and the firepower of all guns will become balanced Given an integer the guns are said to be if Since gamers that play your game don t like big changes you need to change the values for the minimum possible number of guns What is the minimum number of guns for which you have to change these values to make the guns balanced Note that the new values must be integers greater than ,Note that the answer n is always possible for example we can set d i frac prod f j f i then p 1 dots p n prod f j and max p i min p i 0 If the answer is less than n then there is at least one gun id we won t change It means that all other guns firepower should be around p id i e p i p id le k So we can look at segment p id k p id k and for each gun i find what values d i we should set to get into this segment After that we can rephrase our task into the next one we should choose segment l l k subset p id k p id k such that each gun occurs in l l k at least once and the number of corresponding d i that are equal to d i is maximum possible It can be solved with two pointers technique Note that there are at most three interesting values d i we should consider v 1 left lfloor frac p id f i right rfloor v 2 v 1 1 and v 3 d i For each value v j such that v j cdot f i in p id k p id k we can add an event i c j in position v j f i where c j is 1 if v j d i or 0 otherwise Now with two pointers technique we can iterate over all subsegments of length k 1 of segment p id k p id k To get the desired answer we should maintain the number of unique i from events that are present in the subsegment and the sum s of c j from that events Since there is only one c j 1 for each gun i then the sum s of c j we have is equal exactly to the number of guns we change Then we take the maximum mx over sums s of all subsegments where all guns occur and the answer for a fixed p id is n mx Let s iterate over all fixed id and take the minimum from all n mx that will be the answer for the initial task Checking answer for a fixed id involves creating 3 n events and two pointers over segment p id k p id k so it takes O n k time and O n k space So the total complexity is O n 2 n k time and O n k space 
You are given an array consisting of integers Beauty of array is the maximum sum of some of this array this subarray may be empty For example the beauty of the array is and the beauty of the array is You may choose of and multiply all values contained in this subarray by You want to maximize the beauty of array after applying at most one such operation ,The first intuitive guess one s probably made is multiplying the segment of maximum sum for positive That thing is correct Unfortunately there is no similar strategy for non positive simple greedy won t work there Thus dynamic programming is our new friend Let s introduce the following state where is the length of the currently processed prefix is the state of maximum sum segment is not reached it ll appear later is open current elements are added to it is passed the segment appeared earlier and is the state of segment multiplied by with the same values This will store the maximum segment sum we can achieve The only base state is the prefix of length is processed and both segments are not open yet The rest of values in are There are two main transitions At any moment we can change the state of each segment to the next one without moving to the next position From state not reached we can go to state opened and from state we can go to state passed Note that this easily covers the case where optimal segment is empty We can also move to the next position updating the value of with correspondance to the current states of segments The answer will be stored in the state where all the array is processed and both segments are closed Overall complexity 
You are given an undirected unweighted graph consisting of vertices and edges You have to write a number on each vertex of the graph Each number should be or The graph becomes beautiful if for each edge the sum of numbers on vertices connected by this edge is odd Calculate the number of possible ways to write numbers and on vertices so the graph becomes beautiful Since this number may be large print it modulo The graph does not have any self loops or multiple edges ,Let s denote a way to distribute numbers as a Let s also call the paintings that meet the constraints paintings and all other paintings are bad We can solve the problem for each connected component of the graph independently and multiply the answers Let s analyze a painting of some connected component If some vertex has an odd number written on it then we should write even numbers on all adjacent vertices and vice versa So in fact we need to check if the component is bipartite and if it is divide it into two parts The number of good paintings is where is the size of the first part and is the size of the second part because we write s into all vertices of one part and s or s into all vertices of another part 
XXI Berland Annual Fair is coming really soon Traditionally fair consists of booths arranged in a circle The booths are numbered through clockwise with being adjacent to The th booths sells some candies for the price of burles per item Each booth has an unlimited supply of candies Polycarp has decided to spend at most burles at the fair However he has some plan in mind for his path across the booths at first he visits booth number if he has enough burles to buy candy from the current booth then he buys it immediately then he proceeds to the next booth in the clockwise order regardless of if he bought a candy or not Polycarp s money is finite thus the process will end once he can no longer buy candy at any booth Calculate the number of candies Polycarp will buy ,Let s code the following process Go one circle across the booths calculate the total cost of sweets bought and the number of sweets bought Now you can decrease you money down to and add to answer It represents that you went maximum number of such circles The later circles will have smaller cost Let s continue this process until becomes smaller than the minimum priced sweet The number of operations made is Let be the amount of money before some operation be the total cost of sweets bought on that operation and is actually smaller than that s how modulo works and smaller than that s also how modulo works And these inequalities imply that That leads to about steps to reach the minimal price Overall complexity 
There are warriors in a row The power of the th warrior is All powers are pairwise distinct You have two types of spells which you may cast Fireball you spend mana and destroy consecutive warriors Berserk you spend mana choose two consecutive warriors and the warrior with greater power destroys the warrior with smaller power For example let the powers of warriors be and If you cast Berserk on warriors with powers and the resulting sequence of powers becomes Then for example if you cast Fireball on consecutive warriors with powers the resulting sequence of powers becomes You want to turn the current sequence of warriors powers into Calculate the minimum amount of mana you need to spend on it ,The first thing we need to do is to find the occurrences of in the sequence these are the monsters that have to remain Since both spells Fireball and Berserk affect consecutive monsters we should treat each subsegment of monsters we have to delete separately Consider a segment with monsters we have to delete such that the last monster before it has power the first monster after the segment has power and the strongest monster on the segment has power If then we have to use Berserk at least times Let s make the strongest monster on segment kill some other monster If then the strongest monster should also be killed by one of the monsters bounding the segment so if and there is no solution Okay now the number of monsters is divisible by If it is more profitable to use Fireball we use the required number of Fireballs to kill all of them Otherwise we have to kill the maximum possible number of monsters with Berserk and finish the remaining ones with Fireball If or then one of the monsters just outside the segment can kill all the monsters inside the segment otherwise the strongest monster should kill adjacent monsters until exactly remain and those monsters are finished with a single Fireball Now we know what we need to consider when processing a single segment all that s left is to sum the minimum required mana over all such segments Since the total length of these segments is at most and we can process each segment in linear time we have a solution with complexity 
A string is called if it does not contain any characters other than and A bracket sequence is called shortly RBS if it is possible to obtain correct arithmetic expression by inserting characters and into this sequence For example and are RBS and and are not We can see that each opening bracket in RBS is paired with some closing bracket and using this fact we can define of the RBS as maximum number of bracket pairs such that the nd pair lies inside the st one the rd one inside the nd one and so on For example nesting depth of is is and is Now you are given RBS of even length You should color each bracket of into one of two colors red or blue Bracket sequence consisting only of red brackets should be RBS and bracket sequence consisting only of blue brackets should be RBS Any of them can be empty You are not allowed to reorder characters in or No brackets can be left uncolored Among all possible variants you should choose one that of s and s nesting depth If there are multiple solutions you can print any of them ,Let be nested depth of RBS There is an interesting fact that From the other side we can always reach equation using some approaches Let s look at prefix of length of string Let be number of opening bracket in the prefix number of closing brackets Then we can define balance of the th prefix of as The author s approach is next Let s define of pair of brackets matched in natural way as where is position of opening bracket of this pair Then we will color in red all pairs with even level and in blue with odd level Proof of It can be shown that and exists such that After any coloring of we can define number of opening closing red blue brackets of th prefix of as and respectively Since and then Finally 
You are given a grid consisting of rows and columns Each cell of this grid should be colored either black or white Two cells are considered neighbours if they have a and share the same color Two cells and belong to the same component if they are neighbours or if there is a neighbour of that belongs to the same component with Let s call some bicoloring if it has exactly components Count the number of bicolorings The number can be big enough so print the answer modulo ,The problem is about counting the number of some combinatoric objects Thus dynamic programming is always the answer Let be the number of bicolorings of the first columns such that components are already created and can t be modified and the colors of the th column are determined by its first bit is the color of the lower cell and its second bit the color of the upper cell Component can be modified if the cell from the th column belongs to it The initial states are for each and for any other state You should iterate over the possible for the next column and recalculate the number of components You can easily show that the current number of components and the last column is actually enough to get the new number of components In my code I have some function to determine the added number of components while transitioning from to These are just the couple of cases to handle carefully Then all the transitions are However the last column won t contain the answer as it is the number of components will be incorrect Let s add some dummy column equal to for each This will add all the real component to the total number So the answer is the sum of over all Overall complexity where is the number of rows 2 for this problem 
You are given a binary string consisting of only characters and or You can perform several operations on this string possibly zero There are two types of operations choose two consecutive elements and swap them In order to perform this operation you pay coins choose any element from the string and remove it In order to perform this operation you pay coins Your task is to calculate the minimum number of coins required to sort the string in non decreasing order i e transform so that where is the length of the string after applying all operations An empty string is also considered sorted in non decreasing order ,Note that the price of operations is much greater than the difference between them Therefore first of all we have to minimize the number of operations and then maximize the number of operations of the first type Swapping two elements if at least one of them will be deleted later is not optimal Therefore first let s delete some elements of the string and then sort the remaining elements using swaps The number of swaps for sorting is equal to the number of inversions i e the number of pairs such that and From here we can notice that if the number of inversions is greater than then there is an element that produces at least inversions So it is more profitable for us to remove it to minimize the number of operations From the above we get that the number of operations of the first type is at most If all operations are only of the second type then we need to find a subsequence of the maximum length of the form To do this we can iterate over the number of zeros that we include in the final string and then add the number of ones from the remaining suffix of the string that goes after the fixed number of zeros If there is an operation of the first type then it is enough to iterate over the pair that creates the inversion to the left of it take all zeros and to the right of it take all ones you can notice that in fact it is enough to iterate over only a pair of neighboring elements of the string 
Ivan has different boxes The first of them contains some balls of different colors Ivan wants to play a strange game He wants to distribute the balls into boxes in such a way that for every th box will contain all balls with color In order to do this Ivan will make some turns Each turn he does the following Ivan chooses any non empty box and takes all balls from this box Then Ivan chooses any empty boxes the box from the first step becomes empty and Ivan is allowed to choose it separates the balls he took on the previous step into non empty groups and puts each group into one of the boxes He should put each group into a separate box He can choose either or The of the turn is the number of balls Ivan takes from the box during the first step of the turn And of the game is the total of turns made by Ivan until he distributes all balls to corresponding boxes Help Ivan to determine the minimum possible of the game ,Let s consider the process backwards we will store the number of balls of each color in a multiset and then merge some of them If is odd then we can always pick three groups of balls with minimal sizes and replace them by one group adding the size of this group to the penalty Repeat until you have only one group If is even then we need to add an auxiliary group of size Then becomes odd so we can use the above algorithm to solve this case Why does it work This algorithm is exactly the same as the algorithm of building a Huffman code with the alphabet of size And it can easily be seen that these problems are similar by separating a group of balls into three groups we add a new character to the codes of the colours present in that group and our goal is to obtain a prefix code 
Let be arbitrary binary tree tree every vertex of which has no more than two children Given tree is rooted so there exists only one vertex which doesn t have a parent it s the root of a tree Every vertex has an integer number written on it Following algorithm is run on every value from the tree Set pointer to the root of a tree Return success if the value in the current vertex is equal to the number you are looking for Go to the left child of the vertex if the value in the current vertex is greater than the number you are looking for Go to the right child of the vertex if the value in the current vertex is less than the number you are looking for Return fail if you try to go to the vertex that doesn t exist Here is the pseudo code of the described algorithm bool find TreeNode t int x if t null return false if t value x return true if x t value return find t left x else return find t right x find root x The described algorithm works correctly if the tree is binary search tree i e for each node the values of left subtree are less than the value in the node the values of right subtree are greater than the value in the node But it can return invalid result if tree is not a binary search tree Since the given tree is not necessarily a binary search tree not all numbers can be found this way Your task is to calculate how many times the search will fail being running on every value from the tree If the tree has multiple vertices with the same values on them then you should run algorithm on every one of them separately ,Let s firstly consider tree with only distinct values in its nodes Then value will be reached if and only if all the jumps to the left children on the path from the root were done from the vertices with values greater than the current one and all the jumps to the right children on the path from the root were done from the vertices with values less than the current one Thus let s run dfs from the root and maintain maximal transition to the left child on current path and minimal transition to the right child on current path If the value of current node is greater than left bound and less than right bound then it will be found Now let s return to the original problem Notice that transitions and comparations won t change Store every found value in set and just calculate how many values of vertices isn t present there Overall complexity 
You have an array where In one step you can choose two indices and and set ceiling function Your goal is to make array consist of ones and two in no more than steps Note that you don t have to minimize the number of steps ,There are many different approaches We will describe a pretty optimal one Let s solve the problem recursively Let s say we need to process segment If we don t need to do anything Otherwise Let s find the minimum such that The chosen is convenient because it allows making equal to in two divisions and it s the minimum number of divisions to get rid of Now we can firstly make all equal to in one step by division on and then make equal to with two divisions on As a result we ve spent operations and can solve our task recursively for In total we will spend and since the segments are like There will be at most segments and operations are enough for 
There is a chip on the coordinate line Initially the chip is located at the point You can perform any number of moves each move increases the coordinate of the chip by some positive integer which is called The length of the first move you make should be divisible by the length of the second move by the third by and so on For example if then the sequence of moves may look like this because is divisible by is divisible by is divisible by is divisible by You are given two positive integers and Your task is to count the number of ways to reach the point starting from for every The number of ways can be very large so print it modulo Two ways are considered different if they differ as sets of visited positions ,Let s calculate dynamic programming the number of ways to achieve in moves From the state you can make a transition to the states where and is divisible by Let s try to estimate the maximum number of moves because it seems that there can t be very many of them For moves the minimum distance by which a chip can be moved is or From here one can see that the maximum number of transitions does not exceed maximum at So it remains to make transitions in dynamic programming faster than from a single state for a fast enough solution Let s use the fact that Let s iterate over the value of and maintain the sum of dynamic programming values with smaller indices for each remainder modulo in a separate array The final complexity of such a solution is It remains to solve the memory problem because with the existing limits it is impossible to save the entire matrix of size However this is easy to solve if you notice that only the previous layer is used for transitions in dp i e it is enough to store to calculate 
You are given three multisets of pairs of colored sticks pairs of red sticks the first pair has length the second pair has length the th pair has length pairs of green sticks the first pair has length the second pair has length the th pair has length pairs of blue sticks the first pair has length the second pair has length the th pair has length You are constructing rectangles from these pairs of sticks with the following process take a pair of sticks of one color take a pair of sticks of another color different from the first one add the area of the resulting rectangle to the total area Thus you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color Each pair of sticks can be used at most once some pairs can be left unused You are not allowed to split a pair into independent sticks What is the maximum area you can achieve ,Let s build some rectangles and take a look at the resulting pairings For example consider only red green rectangles Let the rectangles be Sort them in a non decreasing order of I claim that in the most optimal set are also sorted in a non decreasing order It s easy to prove with some induction Moreover if there are some green or red sticks that are not taken and that are longer than the smallest taken corresponding sticks then it s always optimal to take those instead These facts helps us to conclude that from each set only some suffix of the largest sticks are taken And they also give us the idea of the solution sort the sticks in each set and pick the largest from any of the two sets into a pair until no pairs can be taken However the greedy approach of take from any two of the three sets is incorrect We need to choose these two sets smartly Let store the maximum total area that can be obtained by taking largest red sticks largest green sticks and largest blue sticks Each transition chooses a pair of colors and takes the next pairs in both of them The answer is the maximum value in all the Overall complexity 
You are given a directed graph with vertices and directed edges without self loops or multiple edges Let s denote the coloring of a digraph as following you color each edge in one of colors The coloring is if and only if there no cycle formed by edges of same color Find a good coloring of given digraph with minimum possible ,Let s run dfs on the graph and color all back edges is back edge if there is a path from to by edges from dfs tree in black and all other edges in white It can be proven that any cycle will have at least one white edge and at least black edge Moreover each back edge connected with at least one cycle path from to and back edge So the coloring we got is exactly the answer How to prove that any cycle have at least one edge of both colors Let s look only at edges from dfs trees We can always renumerate vertices in such way that index of parent is bigger than the index of any its child We can process and assign with minimal free number after we processed all its children Now we can note that for any white edge not only tree edge condition holds because of properties of dfs forward edges are obvious cross edge becomes cross because dfs at first processed vertex and after that so And for each back edge it s true that Since any cycle have both and situations profit 
You are given a binary matrix of size Let s denote an compression of the given matrix as a matrix of size such that for every the condition is met Obviously compression is possible only if divides but this condition is not enough For example the following matrix of size does not have any compression For the given matrix find maximum such that an compression of this matrix is possible ,After some tinkering with the given condition we notice that an compression is possible iff divides and the matrix is divisible into matrices such that each matrix is either all 1 or all 0 We can loop over all such and check the condition in time per but this is potentially too slow To speed this up we can precompute rectangle sums for every rectangle containing the upper left corner which enables us to compute the sum of any rectangle in This improves our time complexity to Since really this means our solution is Code 49028814 
Your task is to calculate the number of arrays such that each array contains elements each element is an integer from to for each array there is one pair of equal elements for each array there exists an index such that the array is before the th element and after it formally it means that if and if ,First of all there will be exactly distinct elements in our array Let s choose them there are ways to do that After that there should be exactly one element that appears twice There are elements to choose from but are all of them eligible If we duplicate the maximum element there will be no way to meet the fourth condition So we should multiply the current answer by not And finally some elements will appear earlier than the maximum in our array and some later The duplicated element will appear on both sides but all other elements should appear either to the left or to the right so there are ways to choose their positions Thus the answer is Note that you have to precompute all factorials and use their inverse elements to calculate Note that there is a tricky case when some binpow implementations go into infinite loop trying to compute so you may have to handle it specifically 
Consider an array of length with elements numbered from to It is possible to remove the th element of if where denotes the greatest common divisor After an element is removed the elements to the right are shifted to the left by one position An array with integers such that is a if it is possible to remove all elements of if you remove the th element then the th then the th element For example let is a removal sequence when you remove the st element of the array the condition holds and the array becomes when you remove the st element again the condition holds and the array becomes empty is not a removal sequence when you try to remove the nd element the condition is false An array is if it has removal sequences For example the array is ambiguous it has removal sequences and The array is not ambiguous the only removal sequence it has is You are given two integers and You have to calculate the number of arrays such that the length of is from to and each is an integer from to ,We will calculate the answer by subtracting the number of arrays which have only one removal sequence from the total number of arrays The latter is very simple it s just How do we calculate the number of unambiguous arrays We can always delete the st element of an array so is a removal sequence for each array So we have to calculate the number of arrays which have no other removal sequences How do we check if the array has no removal sequences other than If at any time it s possible to remove some element other than the st from the array it creates another removal sequence since we can always complete that sequence Let s analyze the constraints on each element of the array can be any integer from to should be divisible by otherwise we can remove it on the first step should be divisible by otherwise we can remove it on the first step and by otherwise we can remove it on the second step should be divisible by and but not necessarily by since an element which is divisible by already has a common divisor with And so on using induction we can show that the th element should be divisible by where are all of the primes in Obviously the number of such elements is So we can easily calculate the number of possible elements for each index of the array and that allows us to count all unambiguous arrays 
Recenlty Luba got a credit card and started to use it Let s consider consecutive days Luba uses the card In the of th day a transaction occurs If then bourles are deposited to Luba s account If then bourles are withdrawn And if then the amount of money on Luba s account is checked In the of any of days Luba can go to the bank and deposit any integer amount of burles to her account But there is a limitation the amount of money on the account can never exceed Luba must not exceed this limit and also she wants that the days when the amount of money on her account is non negative It takes a lot of time to go to the bank so Luba wants to know the minimum number of days she needs to deposit some money to her account if it is possible to meet all the requirements Help her ,The following greedy solution works Firstly deposite money only on days with Secondly every time the balance is negative to the day with refill it to maximal possible value such that it won t go over later Days with can only lead to invalid state by going over card limit We can only add money to the balance Adding zero money in those days won t make invalid states if all were valid previously Finally if it s possible to get valid state in every day then it s possible to get it by refilling the same day the check happens For example you can make balance in those days Then you will never have negative balance there Though it s not the most optimal way Let be some value you deposite in some day with to pass all conditions till the next day with I state that function of number of game s moves dependancy on is monotonious Let s check it for some fixed Define minimum balance you will get on any suffix from now as Obviously taking will make it If it goes negative then you will need an extra move to finish the game Thus taking maximal will lead to the lowest score possible And last but not least realization part What will be the maximum possible value to deposite Actually it s such a value that optimal game after this will lead to maximum balance of in some day Thus you want to check what will be the maximum balance if you add zero money and take as Obviously if it s negative then output Naively this still works on per day and lead to overall Notice that by depositing you increase maximums on each suffix for now by So you can calculate it as you will do nothing and add sum of your s to get actual value You store prefix sum of up to in Then take maximum on suffix for every is the maxumum for from to I hope I made it clear enough DOverall comlpexity 
There is a sheet of paper that can be represented with a grid of size rows and columns of cells All cells are colored in white initially operations have been applied to the sheet The th of them can be described as follows choose one of non white colors and color the entire row and the entire column in it The new color is applied to each cell regardless of whether the cell was colored before the operation The sheet after applying all operations is called a coloring Two colorings are different if there exists at least one cell that is colored in different colors How many different colorings are there Print the number modulo ,Let s take a look at a final coloring Each cell has some color There exist cells such that there were no operation in their row and their column They are left white and they don t affect the answer All other cells are colored in one of colors For each cell there is a query that has been the last one to color this cell it covered row column or both of them So all cells that have the same query as the last one will have the same color Since the color for each query is chosen independently the number of colorings will be to the power of the number of queries that have at least one cell belong to them How to determine if a query has at least one cell This is true unless one of these things happen afterwards both its row and its column are recolored all rows are recolored all columns are recolored So the solution is to process the queries backwards Maintain the set of colored rows and colored columns For each query check the conditions If none hold multiply the answer by Overall complexity or per testcase 
You are given a sequence of positive integers Your task is to construct an undirected graph such that there are exactly vertices there are no self loops there are no multiple edges there are no more than edges its is equal to Vertices should be numbered through is an array with length equal to the number of vertices in a graph such that is the number of vertices adjacent to th vertex is a sorted in increasing order sequence of all distinct values from the It is guaranteed that there exists such a graph that all the conditions hold and it contains no more than edges Print the resulting graph ,We prove that the answer always always exists by constructing it Graph for is a single vertex Graph for is a clique of vertices Graph for some is obtained from the graph by adding vertices initially connected to nothing and vertices connected to all previously mentioned ones The vertices connected to nothing got degrees the vertices from the previous step increased their degrees by and finally there appeared vertices of degree The number is vertices is as needed 
You are given an array consisting of integers You perform the sequence of operations on this array during the first operation you either add to and subtract from or add to and subtract from during the second operation you either add to and subtract from or add to and subtract from during the last operation you either add to and subtract from or add to and subtract from So during the th operation you add the value of to one of its neighbors and subtract it from the other neighbor For example if you have the array one of the possible sequences of operations is subtract from and add it to so the array becomes subtract from and add it to so the array becomes subtract from and add it to so the array becomes So the resulting array is An array is if it can be obtained by performing the aforementioned sequence of operations on You have to calculate the number of reachable arrays and print it modulo ,One of the key observations to this problem is that after the first operations the first elements of the array are fixed and cannot be changed afterwards Also after the th operation the elements on positions from to are the same as they were before applying the operations This allows us to write the following dynamic programming the number of different prefixes our array can have if we have performed operations the th element is and the th element is The elements after are the same as in the original array and the elements before won t be changed anymore so we are interested only in these two elements Let s analyze the transitions in this dynamic programming We apply the operation to the elements and If we add to then we subtract it from so we transition into state Otherwise we transition into state The element we leave behind is either or and if these two transitions give us different prefixes But if we need to make only one of these transitions because adding or subtracting actually makes no difference Okay now we ve got a solution with dynamic programming in where is up to and is up to This is too slow But we can notice that the value of actually does not affect our transitions at all we can just discard it so our dynamic programming becomes which easily fits into TL Small implementation note elements can become negative and in order to store dynamic programming with negative states in an array we need to do something about that I don t recommend using maps neither ordered nor unordered you either get an extra log factor or make your solution susceptible to hacking Instead let s say that the value of where can be a negative number will be stored as in the array where is some constant which is greater than the maximum possible for example in this problem That way all array indices will be non negative Solution complexity 
You are walking with your dog and now you are at the promenade The promenade can be represented as an infinite line Initially you are in the point with your dog You decided to give some freedom to your dog so you untied her and let her run for a while Also you watched what your dog is doing so you have some writings about how she ran During the th minute the dog position changed from her previous position by the value it means that the dog ran for meters during the th minute If is positive the dog ran meters to the right otherwise if is negative she ran meters to the left During some minutes you were chatting with your friend so you don t have writings about your dog movement during these minutes These values equal zero You want your dog to return to you after the end of the walk so the destination point of the dog after minutes Now you are wondering what is the maximum possible number of different of the line your dog could visit on her way if you replace every with some integer from to and your dog return to after the walk The dog visits an integer point if she runs through that point or reaches in it at the end of any minute Point is always visited by the dog since she is initially there If the dog cannot return to the point after minutes regardless of the integers you place print ,Consider every cyclic shift of the array Suppose that now the array starts from the position the first element is and the last element is Assume that before the position our dog reached her minimum possible position and now the minimum position will not change So our problem is to fill all zeros in the array in such a way that the maximum prefix sum of is the maximum possible and the total sum of is zero For simplicity consider the array which is the th cyclic shift of i e the first element is the second element is and so on Let s iterate from left to right and maintain the current sum of the array Let this variable be Now when we meet we should replace it with the maximum possible value we can because in such a way we will increase the maximum number of prefix sums Let be the number of zeros in starting from the position This value can be calculated in advance in for every cyclic shift using suffix sums Then the segment of positions we can have at the end is and we want to place the maximum possible value in in such a way that this remaining segment with addition of our current element will cover This maximum value equals If becomes less than then this cyclic shift is invalid and we should skip it Otherwise let s add to and proceed If there are no values then we placed anything correctly Now can just simulate the movements of our dog to find the answer for the current cyclic shift But there are cases when do not contain zeros so these cases should be handled somehow I just checked that after simulation we returned to If we returned to we can update the answer as the difference between the maximum and the minimum positions plus one If there is no valid cyclic shift then the answer is Time complexity 
The Dogeforces company has employees Each employee except for lower level employees has at least subordinates Lower level employees have no subordinates Each employee except for the head of the company has exactly one direct supervisor The head of the company is a direct or indirect supervisor of all employees It is known that in Dogeforces each supervisor receives a salary strictly more than all his subordinates The full structure of the company is a secret but you know the number of lower level employees and for each pair of lower level employees the salary of their common supervisor is known if there are several such supervisors then the supervisor with the minimum salary You have to restore the structure of the company ,We can solve the problem recursively from the root to the leaves Let s maintain a list of leaf indices for the current subtree If the list size is equal to then we can stop our recursion Otherwise we have to find the value of the root of the current subtree and split all leaves between child nodes The root value is the maximum value of among all pairs belonging to a subtree since the current root has at least child nodes there is a pair of leaves for which the current root is the least common ancestor If the value of the least common ancestor of the leaves and is less than the value of the current root then and belong to the same child of the root Using this fact we can split all the leaves between the child nodes and then restore the subtrees for them recursively 
Polycarp has just attempted to pass the driving test He ran over the straight road with the signs of four types speed limit this sign comes with a positive integer number maximal speed of the car after the sign cancel the action of the previous sign of this type overtake is allowed this sign means that after some car meets it it can overtake any other car no speed limit this sign cancels speed limit if any car can move with arbitrary speed after this sign no overtake allowed some car can t overtake any other car after this sign Polycarp goes past the signs consequentially each new sign cancels the action of all the previous signs of it s kind speed limit overtake It is possible that two or more no overtake allowed signs go one after another with zero overtake is allowed signs between them It works with no speed limit and overtake is allowed signs as well In the beginning of the ride overtake is allowed and there is no speed limit You are given the sequence of events in chronological order events which happened to Polycarp during the ride There are events of following types Polycarp changes the speed of his car to specified this event comes with a positive integer number Polycarp s car overtakes the other car Polycarp s car goes past the speed limit sign this sign comes with a positive integer Polycarp s car goes past the overtake is allowed sign Polycarp s car goes past the no speed limit Polycarp s car goes past the no overtake allowed It is guaranteed that the first event in chronological order is the event of type Polycarp changed the speed of his car to specified After the exam Polycarp can justify his rule violations by telling the driving instructor that he just didn t notice some of the signs What is the minimal number of signs Polycarp should say he didn t notice so that he would make no rule violations from his point of view ,Let s notice that you should never say that you didn t notice signs no speed limit and overtake is allowed Also if you drive with speed you don t want to remove signs speed limit with number greater or equal to Thus greedy solution will work Process all the events in chronological order We should maintain stack of signs speed limit and amount of signs no overtake allowed If we meet sign speed limit we push its limit to stack sign no overtake allowed increase no speed limit clear stack overtake is allowed assign to zero After every event we should check if our speed is fine While value of sign on the top of the stack is less than current speed pop it and increase answer If we overtake someone we add to answer and assign to zero Overall complexity 
Vasya is preparing a contest and now he has written a statement for an easy problem The statement is a string of length consisting of lowercase Latin latters Vasya thinks that the statement can be considered hard if it contains a subsequence otherwise the statement is easy For example can be considered hard statements while and are easy statements Vasya doesn t want the statement to be hard He may remove some characters from the statement in order to make it easy But of course some parts of the statement can be crucial to understanding Initially the of the statement is and removing th character increases the by the index of each character is considered as it was in the original statement so for example if you delete character from and then character the index of is still even though you delete it from the string Vasya wants to calculate the minimum of the statement if he removes some characters possibly zero so that the statement is easy Help him to do it Recall that subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements ,Denote string as We will solve this problem with dynamic programming Denote the minimum possible ambiguity if we considered first letters of statement and got prefix having length as a subsequence of the string If th letter of the statement is not equal to then we don t have to change it Otherwise we either change the letter or let it stay as it is and the length of the prefix we found so far increases 
You are given an undirected connected weighted graph consisting of vertices and edges Let s denote the length of the shortest path from vertex to vertex as You have to erase some edges of the graph so that at most edges remain Let s call a vertex if there still exists a path from to with length after erasing the edges Your goal is to erase the edges in such a way that the number of vertices is maximized ,Let s understand how many good vertices we may get if only edges remain This value is not greater than since an edge an add only one good vertex and for we have a good vertex with index This is an upper bound let s try to find a solution getting exactly good vertices or if all vertices of the graph will be good Let s run Dijkstra s algorithm from vertex and stop it as soon as we know the shortest paths to vertices including vertex The answer should contain the edges belonging to the shortest path tree built on these vertices 
One day early in the morning you decided to buy yourself a bag of chips in the nearby store The store has chips of different flavors A bag of the th flavor costs burles The store may run out of some flavors so you ll decide which one to buy after arriving there But there are two major flaws in this plan you have only coins of and burles since it s morning the store will ask you to pay in exact change i e if you choose the th flavor you ll have to pay burles Coins are heavy so you d like to take the least possible number of coins in total That s why you are wondering what is the minimum total number of coins you should take with you so you can buy a bag of chips of any flavor in exact change ,Let s define then it should be obvious that we need at least coins to buy a bag of chips of cost Now it s not hard to prove that coins is always enough to buy a bag of chips of any cost Proof if we ll take coins of value coin and coin if we ll take coins and two coins if we ll take coins one coin and two coins So the question is how to decide is coins enough The solution is to note that there is no need to take more than coins and more than coins so we can just brute force the number of coins we ll take and the number of coins we ll take Then the number of coins and we can check is it possible to pay exactly using at most and coins respectively There exists casework solution as well but it s quite tricky so brute force is preferable The main problem for case work is the case since there are two different ways to take coins either coins and coin or coins and two coins In the first way you can t gather exactly and in the second one you can gather neither nor 
Let s call an integer array if for each Let be the number of pairs such that Let s say that an array is if is for each is the maximum possible among all arrays of size Given and calculate the number of arrays modulo ,Firstly let s learn the structure of good array with maximum Suppose then In other words we can group by and pairs will appear only inside each group It s easy to prove that if the group has size then it s optimal to split it in half one with and other with Then the number of pairs inside the group will be equal to It s also not hard to prove that in this case it s optimal to place all elements inside one group In other words it s optimal to make a half of all elements as and the other half as for some integer Then To achieve maximum the excellent array should also have this structure Let For a fixed if is even then we should choose exactly positions to set as but if is odd we can choose either or positions Let s analyze what happens with different Obviously While both and are in the segment for any In this case we can choose any as so there are exactly ways for even and ways for odd When then for where there is only one choice to set Analogically for where there is only choice to set What remains is elements without restrictions so there are ways to choose for even or ways for odd Note that it s convenient to say that if or so we don t need extra checks Lastly note that we can process all with one formula and there are only of with non zero number of ways to choose so we can iterate over all such straightforwardly The total complexity is because of precomputation of factorials and inverse factorials to calculate 
Little town Nsk consists of junctions connected by bidirectional roads Each road connects two distinct junctions and no two roads connect the same pair of junctions It is possible to get from any junction to any other junction by these roads The distance between two junctions is equal to the minimum possible number of roads on a path between them In order to improve the transportation system the city council asks mayor to build one new road The problem is that the mayor has just bought a wonderful new car and he really enjoys a ride from his home located near junction to work located near junction Thus he wants to build a new road in such a way that the distance between these two junctions won t decrease You are assigned a task to compute the number of pairs of junctions that are not connected by the road such that if the new road between these two junctions is built the distance between and won t decrease ,Let s use bfs to calculate the smallest distances to all vertices from the vertex and from the vertex These will be and for all is the the current smallest distance between and What you need is to iterate over all pairs and check if the edge between them doesn t exist and neither nor is smaller than Overall complexity 
You have a bag of size Also you have boxes The size of th box is where each is an integer non negative power of two You can divide boxes into two parts of equal size Your goal is to fill the bag completely For example if and then you have to divide the box of size into two parts of size and then divide the box of size So you can fill the bag with boxes of size and Calculate the minimum number of divisions required to fill the bag of size ,If then the answer is because the just can divide all boxes to size and then fill the bag Otherwise the answer is If the answer is let s calculate the minimum number of divisions Let s consider all boxes from small to large Presume that now we consider boxes of size Then there are three cases if in binary representation of the th bit is equal to then we don t need boxes of size and we can merge it into boxes of size if in binary representation of the th bit is equal to and we have at most one box of size then we have to put it box in the bag and then merge the remaining boxes of size into boxes of size if in binary representation of the th bit is equal to and we have not boxes of size then we have to divide the large box into box of size let s presume that it s box of size After that we just continue this algorithm with box of size 
You are given permutations each of length Recall that a permutation of length is a sequence of integers from to Let the beauty of a permutation be the largest such that If then the beauty is The product of two permutations is a permutation such that For each from to print the largest beauty of a permutation over all from to possibly ,Let s try to solve for one of the given permutations Let it be some How to make the answer for it at least Well we have to find another permutation such that How about at least Well the same Push to the right side of the equation Now think What does it actually mean for some permutation to be multiplied by It stays the same So the first elements of will be equal to the first elements of Thus you have to find a permumtation such that its inverse has the longest common prefix with This can be done in multiple ways For example you can store all inverses in a trie and traverse it with until you reach a dead end Or simply push all prefixes of each inverse into a set and iterate over Alternatively you can just sort inverses and do lower bound for in this list the permutation with longest common prefix will be either the result or the one before it Overall complexity per testcase 
Monocarp is playing a strategy game In the game he recruits a squad to fight monsters Before each battle Monocarp has coins to spend on his squad Before each battle starts his squad is empty Monocarp chooses and recruits no more units of that type than he can recruit with coins There are types of units Every unit type has three parameters the cost of recruiting one unit of the th type the damage that one unit of the th type deals in a second the amount of health of one unit of the th type Monocarp has to face monsters Every monster has two parameters the damage that the th monster deals in a second the amount of health the th monster has Monocarp has to fight only the th monster during the th battle He wants all his recruited units to stay alive Both Monocarp s squad and the monster attack continuously not once per second and at the same time Thus Monocarp wins the battle if and only if his squad kills the monster strictly faster than the monster kills one of his units The time is compared with no rounding For each monster Monocarp wants to know the minimum amount of coins he has to spend to kill that monster If this amount is greater than then report that it s impossible to kill that monster ,Imagine you are fighting the th monster and you fixed the type of units and their amount What s the win condition Rewrite it as Notice how we only care about for both the units and the monster but not about and on their own Let s call and the power of the squad and the monster You can see that for each cost we can only leave one unit type of that price that has the largest value of Let s call it Now let s learn to determine the maximum power we can obtain for cost exactly We can iterate over the cost of one unit and the count of units in the squad Since should not exceed that will take Propagate to be the maximum power for cost exactly We have the knowledge about cost exactly but we actually want no more than Calculate prefix maximums over that will be the maximum power we can obtain with no more than coins For each monster we just have to find the smallest such that Since the array is monotone we can use binary search Overall complexity 
Nura wants to buy gadgets She has only burles for that She can buy each gadget for dollars or for pounds So each gadget is selling only for some type of currency The type of currency and the cost in that currency are not changing Nura can buy gadgets for days For each day you know the exchange rates of dollar and pound so you know the cost of conversion burles to dollars or to pounds Each day from to Nura can buy some gadgets by current exchange rate Each day she can buy any gadgets she wants but each gadget can be bought no more than once during days Help Nura to find the minimum day index when she will have gadgets Nura always pays with burles which are converted according to the exchange rate of the purchase day Nura can t buy dollars or pounds she always stores only burles Gadgets are numbered with integers from to in order of their appearing in input ,If Nura can buy k gadgets in x days then she can do that in x 1 days So the function of answer is monotonic So we can find the minimal day with binary search Denote lf 0 the left bound of binary search and rg n 1 the right one We will maintain the invariant that in left bound we can t buy k gadgets and in right bound we can do that Denote function f d equals to 1 if we can buy k gadgets in d days and 0 otherwise As usual in binary search we will choose If f d 1 then we should move the right bound rg d and the left bound lf d in other case If binary search found the value lf n 1 then the answer is 1 otherwise the answer is lf Before binary search we can create two arrays of gadgets which are selling for dollars and pounds and sort them Easy to see that we should buy gadgets for dollars on day i d when dollar costs as small as possible and j d when pounds costs as small as possible Let now we want to buy x gadgets for dollars and k x gadgets for pounds Of course we will buy the least cheap of them we already sort the arrays for that Let s iterate over x from 0 to k and maintain the sum of gadgets for dollars s1 and the sum of gadgets for pounds s2 For x 0 we can calculate the sums in O k For other x s we can recalculate the sums in O 1 time from the sums for x 1 by adding gadget for dollars and removing gadget for pounds Complexity O klogn 
You are given a tree consisting of vertices A number is written on each vertex the number on vertex is equal to Let s denote the function as the greatest common divisor of the numbers written on the vertices belonging to the simple path from vertex to vertex including these two vertices Also let s denote as the number of vertices on the simple path between vertices and including the endpoints for every vertex Your task is calculate the maximum value of among such pairs of vertices that ,I know there exists solution and author of the problem promises to tell it to you here he explained it I d love to tell easier to code and about the same time to work solution At first notice that it is only enough to check the paths such that all vertices on it is divisible by some prime Let s for each calculate the path of the maximum length to pass through it That means that one part of this path goes down to one child of it and another part goes down to another child For each vertex we will store the lengths of maximum paths through vertices with values divisible by each prime in That is memory To recalc the answer we will store all values of children nodes sort them and update the answer with two pointers technique Don t forget about the case of Overall complexity 
Given three numbers You need to find an adjacency matrix of such an undirected graph that the number of components in it is equal to and the number of components in its complement is The matrix must be symmetric and all digits on the main diagonal must be zeroes In an undirected graph loops edges from a vertex to itself are not allowed It can be at most one edge between a pair of vertices The adjacency matrix of an undirected graph is a square matrix of size consisting only of 0 and 1 where is the number of vertices of the graph and the th row and the th column correspond to the th vertex of the graph The cell of the adjacency matrix contains if and only if the th and th vertices in the graph are connected by an edge A connected component is a set of vertices such that for every two vertices from this set there exists at least one path in the graph connecting this pair of vertices but adding any other vertex to violates this rule The complement or inverse of a graph is a graph on the same vertices such that two distinct vertices of are adjacent if and only if they are not adjacent in ,Let s prove that if then Let be the original graph and the complement of the graph Let s look at each pair of vertices If and belong to different components of the graph then there is an edge between them in the graph Otherwise and belong to the same component of the graph but since has more than one component there is vertex in other component of and there are edges and in That s why there is a connected path for any pair of vertices and the graph is connected Similarly the case is proved So if then the answer is NO Otherwise Consider the case where if we can swap and and output complement of the constructed graph To have components in the graph it is enough to connect the vertex with the vertex the vertex with the vertex the vertex with the vertex A particular cases are the tests and There is no suitable graph for them 
 You may use in C in Java in Python or in Pascal to flush the output If you use some other programming language consult its documentation You may also refer to the guide on interactive problems https codeforces com blog entry 45307 The jury has chosen a string consisting of characters each character of is a lowercase Latin letter Your task is to guess this string initially you know only its length You may ask queries of two types the query of the first type where is an integer from to In response to this query the jury will tell you the character the query of the second type where and are integers such that In response to this query the jury will tell you the number of different characters among You are allowed to ask no more than queries of the first type and no more than queries of the second type Your task is to restore the string For each test in this problem the string is fixed beforehand and will be the same for every submission ,There are several ways to solve this problem The model solution does it as follows Restore the characters of from left to right The first character is restored by query For each of the next characters let s ask if this character is new by querying and comparing the result with the number of different characters on the segment If it s new ask to obtain the th character there will be at most such queries Otherwise we can find the previous occurrence of the th character with binary search Let be the number of different characters from position to position If we want to find the previous occurrence of the th character we need to find the last index such that Since the value does not decrease when we increase we can find the last such that with binary search Unfortunately the number of queries of type will be too large if we just use binary search over the whole segment To decrease the number of queries we can use the fact that the value of we are interested in is the last occurrence of some character we already met there are at most such values and binary search among them will need only iterations 
You are given an array consisting of elements The of some subsegment of this array is the difference between the maximum and minimum element from this segment The of the array is the sum of of all subsegments of this array For example the of array is because there are different subsegments of this array from index to index is from index to index is from index to index is from index to index is from index to index is from index to index is You have to determine the of the array ,First of all we will calculate the sum of maximum and minimum values on all segments separatedly Then the answer is the difference between the sum of maximum values and minimum values How can we calculate the sum of minimum values for example For each element we will try to find the number of segments where it is the So we will calculate two arrays means that is the maximum index such that and and means that is the minimum index such that and So actually and represent the borders of the largest segment where is the and we need to exclude those borders While knowing these values we can calculate the number of subsegments where is the How can we calculate for example the array We will use a stack where we will store some indices in the array in such a way that if we change all indices to the values in the array they will be in sorted order the maximum element will be at the top of the stack and the minimum at the bottom Let s calculate from the minimum index to the maximum When we calculate we remove all elements such that from the stack since the stack is sorted all these elements will be at the top of the stack and when we encounter the first element such that it is guaranteed that all elements below it don t need to be deleted Then if there s any element on top of the stack it becomes the value of then we push into the stack Since every element will be added and deleted not more than one time the complexity of this algorithm is linear We can apply the same technique to calculate the values of and the sum of maximums 
There is a city that can be represented as a square grid with corner points in and The city has vertical and horizontal streets that goes across the whole city i e the th vertical streets goes from to and the th horizontal street goes from to All streets are bidirectional Borders of the city are streets as well There are persons staying the th person at point so either equal to some or equal to some or both Let s say that a pair of persons form an if the shortest path from one person to another going only by streets is than the Manhattan distance between them Calculate the number of inconvenient pairs of persons pairs and are the same pair Let s recall that Manhattan distance between points and is ,Firstly let s look at some point Let s find closest to it vertical and horizontal lines We will name the closest vertical lines from left and right as and and and as closest horizontal lines So and we can also note that either or Now let s note that if for some other point either or then to reach from we must go reach either or or or so the shortest distance will be strictly greater than the Manhattan distance If neither nor then we can show that it s always possible to find the shortest path equal to the Manhattan distance As a result for each point we should find the number of points such that and or The exception here is when lies on the same line as so we should not count such points We can note that since either or there is no such point that and simultaneously so we can calculate the pairs by and coordinates independently Let s focus on coordinates to calculate for coordinates we can just swap all coordinates Let s sort all points by coordinate To get rid of the case when points and lies on the same vertical street we can group them by coordinate and process by group since we sorted by groups are just segments There are no problems with the case when points lie on the same horizontal street since then and there are no other with If we store for each horizontal line the number of point inside the interval then when we need for point calculate the number of points with and we can just ask for value assigned to because and are consecutive elements in the array So we go through each group two times first collecting answer then updating values in appropriate s Note that we can calculate and with binary search using built in functions The resulting complexity is 
You are given a colored permutation The th element of the permutation has color Let s define an as infinite sequence where all elements have We can also define a multiplication of permutations and as permutation where Moreover we can define a power of permutation as Find the minimum such that has at least one infinite path i e there is a position in such that the sequence starting from is an infinite path It can be proved that the answer always exists ,Let s look at the permutation as at a graph with vertices and edges It s not hard to prove that the graph consists of several cycles self loops are also considered as cycles So the sequence is just a walking on the corresponding cycle Let s consider one cycle In permutation we have But since or so and in general case Now walking with step we can note that the initial cycle split up on cycles of length Looking at the definition of infinite path we can understand that all we need to do is to check that at least one of cycles have all vertices of the same color We can check it in time for the cycle and fixed The final observation is next for and such that the produced cycles will have the same sets of vertices and differ only in the order of walking so we can check only one representative for each i e we can take only such which divide We can handle each cycle of separately So using the approximation that the number of divisors of is we get time complexity 
You are given a sequence of integers You are also given integers You are asked to insert each of the extra integers into the sequence Each integer can be inserted at the beginning of the sequence at the end of the sequence or between any elements of the sequence The score of the resulting sequence is the sum of absolute differences of adjacent elements in it What is the smallest possible score of the resulting sequence ,Observe the cost of inserting a single element Notice that inserting any value between the minimum of the sequence and the maximum of the sequence is free Why is this true The argument is similar to the algorithm of finding some such that for a continous function if you know some such that and such that As a more general idea it s free to insert some value into a segment such that and WLOG assume Let s find the position that is free If then you can insert between and since it s free Otherwise you can choose an arbitrary position will be either between and or between and or both of them Descend into the one that holds to continue the search Since the lenght decreases at some point you will reach the segment of length How does that help Well you can insert somewhere then insert somewhere The rest of insertions will be free Now it s an algorithmic problem First consider all options to insert both and between the same pair of elements Next assume you insert somewhere before Iterate from left to right maintaning the lowest price to insert Try to insert at the current position and into the cheapest position before it Then update the lowest price for inserting After you finish reverse the sequence and solve the problem again that will be the same as inserting before Overall complexity per testcase 
A permutation of size is an array of size such that each integer from to occurs exactly once in this array An inversion in a permutation is a pair of indices such that and For example a permutation contains inversions You are given a permutation of size and queries to it Each query is represented by two indices and denoting that you have to reverse the segment of the permutation For example if and a query is applied then the resulting permutation is After each query you have to determine whether the number of inversions is odd or even ,Permutaion with one swap is called transposition Any permutation can be expressed as the composition product of transpositions Simpler you can get any permutation from any other one of the same length by doing some number of swaps The sign of the permutation is the number of transpositions needed to get it from the identity permutation Luckily not really this is pure math check out all proofs at wiki e g the sign can also tell us the parity of inversion count Now you can start with computing parity of inversion count of the original permutation naively check all pairs of indices Finally you can decompose queries into swaps any method will be ok Like you can swap and then and and so on this is swaps Then parity of inversion count of the resulting permutation will change if you applied odd number of swaps Overall complexity 
Consider a linear function Let s define and for For the given integer values and find the value of modulo ,The problem can be solved using closed formula it s need to calculate the sum of geometric progression The formula can be calculated using binary exponentiation I ll describe more complicated solution but it s more general If we have a set of variables and at each step all variables are recalculating from each other using linear function we can use binary matrix exponentiation There is only one variable in our problem The new variable is calculating using formula Consider the matrix and the vector Let s multiply and Easy to see that we will get the vector So to make iterations we should multiply and times We can do that using binary matrix exponentiation because matrix multiplication is associative As an exercise try to write down the matrix for the Fibonacci numbers and calculate the th Fibonacci number in time The matrix and the vector is under the spoiler 
There are cities numbered from to roads connect these cities the th road connects cities and Each road has a direction The directions are given by a string of characters such that each character is either or If the th character is it means that the th road initially goes from the city to the city otherwise it goes from the city to the city A traveler would like to visit as many cities of this country as possible Initially they will choose some city to start their journey from Each day the traveler go from the city where they currently are to a neighboring city using one of the roads and they can go along a road only if it is directed in the same direction they are going i e if a road is directed from city to the city it is possible to travel from to but not from to After the traveler moves to a neighboring city roads change their directions If the traveler cannot go from their current city to a neighboring city their journey ends it is also possible to end the journey whenever the traveler wants to The goal of the traveler is to visit as many different cities as possible they can visit a city multiple times but only the first visit is counted For each city calculate the maximum number of different cities the traveler can visit during if they start in the city ,There are two key observations to this problem after each pair of moves the directions go back to the original ones after each move we can immediately go back and combining these observations we can derive that if we go from city to some other city we can always go back One of the solutions we can write using these observations is to build an undirected graph on vertices Each vertex represents a pair where is the city we are currently staying in and is the number of moves we made modulo Since each move is to a neighboring city each vertex is unreachable from and vice versa And since we can always go back and each pair of steps doesn t change the directions this graph is actually an undirected one So we can find the connected components of this graph using DFS BFS DSU and for each city print the size of the component the vertex belongs to Another solution is to find the leftmost and the rightmost city reachable from each city For example finding the leftmost reachable city can be done with the following dynamic programming let be the leftmost city reachable from Then if we can t go left from if we can make only one step to the left from and if we can make two steps we can take the answer from the city The same approach can be used to calculate the rightmost reachable city 
Alice and Bob are playing a game Initially they are given a non empty string consisting of lowercase Latin letters The length of the string is even Each player also has a string of their own initially empty Alice starts then they alternate moves In one move a player takes either the first or the last letter of the string removes it from and adds to the beginning it to their own string The game ends when the string becomes empty The winner is the player with a lexicographically smaller string If the players strings are equal then it s a draw A string is lexicographically smaller than a string if there exists such position that for all and What is the result of the game if both players play optimally e g both players try to win if they can t then try to draw ,What do we do when the array loses elements only from the left or from the right and the constraints obviously imply some quadratic solution Well apply dynamic programming of course The classic what is the outcome if only the letters from positions to non inclusive are left is the answer is the base case the draw both strings are empty Let mean that Alice wins be a draw and mean that Bob wins How to recalculate it Let s consider a move of both players at the same time From some state first Alice goes then Bob The new state becomes Alice picked some letter Bob picked some letter What s that pick exactly So they both got a letter prepended it to their own string Then continued the game on a smaller string and prepended even more letters to the string Thus if we want to calculate from we say that we letters and Now it s easy If is not a draw then the new letters change nothing the result is still the same Otherwise the result of the game is the same as the comparison of letters and How to perform both moves at once First we iterate over the Alice s move whether she picks from or from After that we iterate over the Bob s move whether he picks from or from Since we want to be the best outcome for Alice we do the following For any Alice move we choose the worse of the Bob moves the maximum of Among the Alice s moves we choose the better one the minimum one Overall complexity per testcase 
The array with integers is given Let s call the sequence of one or more consecutive elements in Also let s call the segment if it contains no more than different values Find any longest good segment As the input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,This problem is given because on the Codeforces pages we often see questions like What is the method of the two pointers This problem is a typical problem that can be solved using two pointers technique Let s find for each left end the maximal right end that is a good segment Note if is a good segment then is also a good segment So the search of the maximal right end for we can start from the maximal right end for The only thing that we should do is to maintain in the array for each number the number of it s occurrences in the current segment and the number of different numbers in We should move the right end until the segment became bad and then move the left end Each of the ends will be moved exactly times 
You are given array with elements and the number Consider some subsequence of and the value of least common multiple LCM of its elements Denote LCM as Find any longest subsequence of with the value A subsequence of is an array we can get by erasing some elements of It is allowed to erase zero or all elements The LCM of an empty array equals ,Let be the number of occurences of the number in the given array easy to see that we can ignore the numbers greater than Let s iterate over and and increase the value in the position in some array by the value So the value equals the number of numbers in the given array which divide Let s find the minimal with the maximum value Easy to see that the answer to the problem is the numbers which divide Let s calculate the complexity of the solution The number of the pairs we can bound with the value 
Let s name a pair of positive integers if the greatest common divisor of them is equal to Let s define a induced by as a sequence of pairs for some integer The of the chain is the number of pairs it consists of or Let s name such chain if all pairs in the chain are lucky You are given pairs Calculate for each pair the length of the longest lucky chain induced by this pair Note that if is not lucky itself the chain will have the length ,Suppose It means that is also divisible by or is divisible by And backward if then is also divisible by or is divisible by Since is divisible by and is divisible by so In other words we proved that Now knowing the equivalence above we can understand that we are looking for the smallest such that In other words we are searching such that is divisible by some where is some divisor of The problem is that there are a handful of divisors for some But we can note that we can consider only divisors of if and is composite then there is some prime thus It s easy to prove that there are no more than prime divisors of some Now the question is how to find all these prime divisors Note that if you know only one prime divisor for each value from to then you can find all prime divisors for all in The prime divisors are next and so on until The final step is to calculate a prime divisor for each value from to where or We can do it by slight modifications of Sieve of Eratosthenes at the step where you have some prime and want to throw out all values set for each plus set As a result we firstly calculate Sieve in and secondly calculate answer for each pair in Note that the input and output is large so you should you tricks to speed up your input and output 
The main city magazine offers its readers an opportunity to publish their ads The format of the ad should be like this There are space separated non empty words of lowercase and uppercase Latin letters There are hyphen characters in some words their positions set word wrapping points Word can include more than one hyphen It is guaranteed that there are no adjacent spaces and no adjacent hyphens No hyphen is adjacent to space There are no spaces and no hyphens before the first word and after the last word When the word is wrapped the part of the word before hyphen and the hyphen itself stay on current line and the next part of the word is put on the next line You can also put line break between two words in that case the space stays on current line Check notes for better understanding The ad can occupy no more that lines and should have minimal width The width of the ad is the maximal length of string letters spaces and hyphens are counted in it You should write a program that will find minimal width of the ad ,Firstly notice that there is no difference between space and hyphen you can replace them with the same character if you want Let s run binary search on answer Fix width and greedily construct ad wrap word only if you don t option to continue on the same line Then check if number of lines doesn t exceed Overall complexity 
Reziba has many magic gems Each magic gem can be split into normal gems The amount of space each magic and normal gem takes is unit A normal gem cannot be split Reziba wants to choose a set of magic gems and split some of them so the total space occupied by the resulting set of gems is units If a magic gem is chosen and split it takes units of space since it is split into gems if a magic gem is not split it takes unit How many different configurations of the resulting set of gems can Reziba have such that the total amount of space taken is units Print the answer modulo Two configurations are considered different if the number of magic gems Reziba takes to form them differs or the indices of gems Reziba has to split differ ,Let s reformulate the solution to the form of dynamic programming the number of ways to split the gems so that the total amount of space taken is Then there are obvious transitions of either splitting the last gem or not And that can be easily rewritten in such a way that matrix exponentiation becomes the solution Overall complexity 
Consider the decimal presentation of an integer Let s call a number if digit appears in decimal presentation of the number on even positions and nowhere else For example the numbers are but are not On the other hand the number is is is and is Find the number of numbers in the segment that are multiple of Because the answer can be very huge you should only find its value modulo so you should find the remainder after dividing by ,Denote the answer to the problem Note that or what is the same where equals to one if is a magic number otherwise equals to zero Let s solve the problem for the segment Here is described the standard technique for this kind of problems sometimes it is called dynamic programming by digits It can be realized in a two ways The first way is to iterate over the length of the common prefix with number Next digit should be less than corresponding digit in and other digits can be arbitrary Below is the description of the second approach Let be the number of magic prefixes of length with remainder modulo If than the prefix should be less than the corresponding prefix in and if than the prefix should be equal to the prefix of it can not be greater Let s do forward dynamic programming Let s iterate over digit in position We should check that if the position is even than should be equal to otherwise it cannot be equal to Also we should check for should be not greater than corresponding digit in Now let s see what will be the next state Of course By Horner scheme Easy to see that To update the next state we should increase it Of course all calculations should be done modulo 
You have a fence consisting of vertical boards The width of each board is The height of the th board is You think that the fence is if there is no pair of adjacent boards having the same height More formally the fence is great if and only if for all indices from to the condition holds Unfortunately it is possible that now your fence is not great But you can change it You can increase the length of the th board by but you have to pay rubles for it The length of each board can be increased any number of times possibly zero Calculate the minimum number of rubles you have to spend to make the fence great again You have to answer independent queries ,Let s notice that in optimal answer all boards will be increased by no more than two It is true because if it is beneficial to increase the length of some board by three or more denote its length as then increasing to the length or is cheaper and one of these boards is not equal to any of its adjacent boards Noticing this we can write a solution based on dynamic programming Let s is minimum amount of money for making fence great moreover the last board with index we increase by Then value can be calculated as follows 
You have an array of integers of size Initially all elements of the array are equal to You can perform the following operation choose two integers and and then increase the value of by i e make After performing all operations you will receive coins for all such that Your task is to determine the maximum number of coins that you can receive by performing no more than operations ,Let s calculate the minimum number of operations to get the number from To do this it is enough to use BFS or dynamic programming Edges in the graph transitions in dynamic programming have the form for all Now the problem itself can be reduced to a knapsack problem there are items th item weighs and costs you have to find a set of items with the total weight of no more than of the maximum cost This is a standard problem that can be solved in but it is too slow although some participants passed all the tests with such a solution However we can notice that the values of should not grow too fast namely the maximum value of for does not exceed This means that the maximum possible weight is no more than and we can limit to this number i e make 
Monocarp is planning to host a martial arts tournament There will be three divisions based on weight lightweight middleweight and heavyweight The winner of each division will be determined by a single elimination system In particular that implies that the number of participants in each division should be a power of two Additionally each division should have a non zero amount of participants participants have registered for the tournament so far the th of them weighs To split participants into divisions Monocarp is going to establish two integer weight boundaries and All participants who weigh strictly less than will be considered lightweight All participants who weigh greater or equal to will be considered heavyweight The remaining participants will be considered middleweight It s possible that the distribution doesn t make the number of participants in each division a power of two It can also lead to empty divisions To fix the issues Monocarp can invite an arbitrary number of participants to each division Note that Monocarp can t kick out any of the participants who have already registered for the tournament However he wants to invite as little extra participants as possible Help Monocarp to choose and in such a way that the total amount of extra participants required is as small as possible Output that amount ,Sort the weights now choosing and will split the array into three consecutive segments Consider a naive solution to the problem You can iterate over the length of the first segment and the second segment The third segment will include everyone remaining Now you have to check if there exist some and that produce such segment can be equal to the first element of the second segment since only all elements of the first segment are smaller than it Similarly can be equal to the first element of the third segment However if the last element of some segment is equal to the first element of the next segment no or can split the array like that Otherwise you can split an array like that So you can iterate over the lengths check the correctness and choose the best answer Now let s optimize it using the condition about powers of two First iterate over the size of the middle division which is a power of two Then over the length of the first segment which can be not a power of two Check if the first segment is valid So we fixed the length of the first segment and some value which is greater or equal than the length of the second segment That value isn t necessarily equal to the length of the second segment because the produced segment might be invalid So there is a greedy idea that the second segment should be as long as possible under the constraint that it doesn t exceed the fixed value The intuition is the following Consider the longest possible valid segment Now take the last element away from it We will have to invite one more participant to the middle division And that element will also get added to the third segment increasing its length So potentially you can only increase the required number of participants to invite This can be implemented in the following fashion For each position precalculate the closest possible segment border from the left Iterate over the size of the middle division as a power of two Iterate over the length of the first segment Find the closest border to the left of Get the lengths of the second and the third segments Find the closest powers of two to each length and update the answer Overall complexity per testcase 
You are given two arrays and consisting of integers each Let s define a function as follows let s define an array of size where denotes bitwise XOR the value of the function is i e bitwise AND of the entire array Find the maximum value of the function if you can reorder the array in an arbitrary way leaving the initial order is also an option ,We will build the answer greedily from the highest significant bit to the lowest one Let s analyze how to check if the answer can have the highest bit equal to It means that every value in should have its highest bit equal to so for every exactly one of the numbers should have this bit equal to For both of the given arrays we can calculate how many elements have which value of this bit and then the number of elements with in this bit in the array should be equal to the number of elements with in the array and the same for elements with in and elements with in If these values are equal it means that the elements of and can be matched in such a way that in every pair the XOR of them has in this bit If it is so then the highest bit of the answer is otherwise it is Okay then let s proceed to the next bit Should we just do the same to check if this bit can be equal to in the answer Unfortunately that s not enough Let s look at the case We can get the value in the th bit or in the st bit but not in both So for the next bit we need to make sure that not only we can get in the result but we can also do this without transforming some of the s to s in the higher bits If it is impossible it doesn t matter if we can get in the current bit since it will be suboptimal so we have to use an ordering that gets in this bit In general case it means that we have to solve the following subproblem check if we can obtain in several bits of the answer let these bits be to are the bits that we have already checked is the new bit we are trying to check Let be the number that has in every bit and in every other bit The elements should be matched in such a way that If we group all numbers from and from according to the value of or then for every group of elements from there is a corresponding group in such that we can match the elements from the first group with the elements from the second group So if for every such group its size in is equal to the size of the corresponding group in then we can set all bits from to simultaneously Some implementation notes if the number of bits we need to check is big the number of groups can become too large to handle all of them since it is So to store the number of elements in each group we should use some associative data structure like for example in C If you use a map splitting elements into groups will be done in so in total you will get complexity of where is the maximum possible value in the input 
Graph constructive problems are back This time the graph you are asked to build should match the following properties The graph is connected if and only if there exists a path between every pair of vertices The diameter aka longest shortest path of a connected undirected graph is the maximum number of edges in the path between any pair of its vertices The degree of a vertex is the number of edges incident to it Given a sequence of integers construct a graph of vertices such that the graph contains no self loops and no multiple edges the degree of the th vertex doesn t exceed i e the diameter of the graph is maximum possible Output the resulting graph or report that no solution exists ,Let s construct the graph the following manner Take all the vertices with and build a bamboo out of them Surely all but the end ones will have degree the diameter now is the number of vertices minus 1 One can show that building the graph any other way won t make the diameter greater How should we distribute the other vertices Two of them can be used to increase diameter And all the others won t matter they can be paired with any of the vertices with degrees to spare If no loops are added then the diameter won t change the path that was the longest won t become any shorter All those facts imply that the graph should be a tree and the sum of should be at least Overall complexity 
You are given an array consisting of integers You are also given two integers and You have to perform the following operation exactly once add to the elements on positions and subtract from all the others For example if and we have picked the first element then after the operation the array Let be the maximum possible sum of a subarray of The subarray of is a contiguous part of the array i e the array for some An empty subarray should also be considered it has sum Let the array be the array after applying the aforementioned operation Apply the operation in such a way that is the maximum possible and print the maximum possible value of ,There are greedy and dynamic programming solutions We will describe dynamic programming solution The main task is to choose some segment that is the answer to the problem while choosing positions to increase by To do this we can use dynamic programming where is the number of positions that have already been considered from to is the number of elements that have already been increased by from to is the flag showing the current state whether we are before the chosen segment inside the segment or after the segment Transitions in such dynamic programming are quite simple we have a choice either to increase by then the value of the th element is or not to increase then the value of the th element is we can also change the state of the flag note that you can only switch from the current state to the subsequent ones i e for example you cannot switch from the state the segment has already ended to the state inside the segment If the current state of the flag is inside the segment then or depending on the selected transition should be added to the dynamic programming value itself So we got a solution in 
You are given two integer arrays and of length You can reverse subarray continuous subsegment of the array Your task is to reverse such a subarray that the sum is ,The naive approach is to iterate over and reverse the subsegment of the array and calculate the answer But this solution is too slow and works in Instead we can iterate over the center of the reversed segment and its length If the current segment is and we want to go to then the answer for the subsegment will increase by It remains to add the answer for and but without reversion this is easy to do if you pre calculate the prefix sums of the values 
You are given an array consisting of integers Indices of the array start from zero i e the first element is the second one is and so on You can reverse subarray continuous subsegment of this array Recall that the subarray of with borders and is Your task is to reverse such a subarray that the sum of elements on positions of the resulting array is i e the sum of elements for integer should be maximum possible You have to answer independent test cases ,Firstly we can notice that the reverse of of odd length subarray does nothing because it doesn t change parities of indices of affected elements Secondly we can consider the reverse of the subarray of length as reverses of subarrays of length i e it doesn t matter for us how exactly the subarray will be reversed we can only consider changing parities Now there are two ways the first one is smart and the second one is dynamic programming Consider the first way Calculate the initial sum of elements on even positions Then let s create two arrays and There is for all from to and is for all from to Elements of the first array deonte the profit if we reverse the subarray tarting from the even position and elemnts of the second array denote the profit if we reverse the subarray starting from the odd position Now we need to find the subarray with the maximum sum in both arrays this will maximize overall profit and add this value to to get the answer This problem can be solved easily consider the sum of the subarray as the difference of two prefix sums To maximize it consider all right borders and minimize the value Iterate over all positions of the array maintaining the current prefix sum and the minimum prefix sum we meet Update then update and then update the answer with the value And the second way is author s solution and it is dynamic programming This idea can be transformed to solve such problems in which you need to apply some function to some small number of subsegments of course under some constraints on functions State of our dynamic programming is where and denotes the answer on the prefix of length if we didn t start reversing the subarray denotes the answer if we started reversing the subarray but didn t end it and denotes the answer if we ended reversing the subarray Transitions are pretty easy The value is just a ternary if statement If is true then return otherwise return The answer is Time complexity with both approaches is 
Merge sort is a well known sorting algorithm The main function that sorts the elements of array with indices from can be implemented as follows If the segment is already sorted in non descending order that is for any such that then end the function call Let Call Call Merge segments and making the segment sorted in non descending order The merge algorithm doesn t call any other functions The array in this problem is indexed so to sort the whole array you need to call The number of calls of function is very important so Ivan has decided to calculate it while sorting the array For example if then there will be call of which will check that the array is sorted and then end If then the number of calls is first of all you call which then sets and calls and which do not perform any recursive calls because segments and are sorted Ivan has implemented the program that counts the number of calls but now he needs to test it To do this he needs to find an array such that is a permutation of size that is the number of elements in is and every integer number from can be found in this array and the number of calls when sorting the array is exactly Help Ivan to find an array he wants ,First of all if is even then there is no solution since the number of calls is always odd one call in the beginning and each call makes either or recursive calls Then if is odd let s try to start with a sorted permutation and try to unsort it Let s make a function that will do it When we unsort a segment we can either keep it sorted if we already made enough calls or make it non sorted and then call and if we need more calls When we make a segment non sorted it s better to keep its both halves sorted an easy way to handle this is to swap two middle element It s easy to see that the number of calls is equal to the number of calls to sort the resulting permutation so we can use this approach to try getting exactly calls 
Let s call a sequence of integers if for all holds Where is the minimum non negative integer that doesn t belong to the set For example and You are given an array consisting of non negative integers Calculate the number of non empty subsequences of a given array The number of subsequences can be very large so print it modulo Note a subsequence of an array is a sequence meeting the constraints If two different ways to choose the sequence of indices yield the same subsequence the resulting subsequence should be counted twice i e two subsequences are different if their sequences of indices are not the same ,Let s understand what MEX correct sequences look like It turns out there are only two types and For example the sequences and the empty sequence are MEX correct sequences of the first type and and of the second one Let s calculate the dynamic programming the number of MEX correct subsequences of the first type on the prefix of length with equal to and similarly the number of MEX correct subsequences of the second type on the prefix of length with equal to Let s look at the transitions in these dps and show that there are no other MEX correct sequences at the same time Let the current state be and we are trying to add an element equal to if then such an element cannot be added if then the value of will not change and the sequence is still of the first type which means we have a transition to if then the value of will increase by but it will still be of the first type which means we have a transition to if then the value of will not change but the sequence will become of the second type which means we have a transition to if then such an element cannot be added Let the current state be and we are trying to add an element equal to if then such an element cannot be added if then the value of will not change and the sequence is still of the second type which means we have a transition to if then such an element cannot be added because will increase by which means the absolute difference between and is greater than if then the value of will not change and the sequence is still of the second type which means we have a transition to if then such an element cannot be added Thus we considered all possible transitions adding a new element to the already MEX correct sequences and made sure that there are only two types While the solution itself works in time because each element has possible transitions in the dps it uses memory which does not allow us to write that solution as is However note that and similarly for differ in only a few positions in those that the element allowed us to make which means we can store only one dimensional arrays and Thus the final complexity of the solution is 
Let s define the of a string as the number of index pairs and such that and You are given two positive integers and Among all strings with length that contain only the first characters of the Latin alphabet find a string with minimum possible If there are multiple such strings with minimum find any of them ,Consider all possible strings of length on the alphabet of size there are of them Let be the number of occurrences of the th of them in the string The cost of the string by definition is Now let s suppose there are two strings and such that Then if we somehow reduce the number of occurrences of the string by and increase the number of occurrences of the string by the cost will decrease So in the optimal answer all the strings of length should appear the same number of times and if it s impossible the difference in the number of appearances should not be greater than Let s suppose that then our goal is to build a string where each string of length on the alphabet of characters appears exactly once The construction of this string can be modeled using Eulerian cycles build a directed graph with vertices where each vertex represents a character each arc represents a string of length and for every pair of vertices there is an arc from to it s possible that Then by finding the Eulerian cycle in this graph it always exists since the graph is strongly connected and for each vertex its in degree is equal to its out degree we find a string of length such that all its substrings are different so each string of length appears there once as a substring Okay what about the cases and Since the string we build for the case represents a cycle we can make it cyclical and repeat the required number of times then cut last several characters if it s too big For example if then the string for is it s not the only one but we can use it We can expand this string to by repeating the last characters and delete the last character so its length is By the way in this problem you don t have to implement the algorithm that finds Eulerian cycles The graph where we want to find the Eulerian cycle has a very special structure and there are many different constructive ways to find the cycle in it But if you can t use them you always can rely on the straightforward solution that explicitly searches for the Eulerian cycle 
Monocarp had a tree which consisted of vertices and was rooted at vertex He decided to study BFS Breadth first search so he ran BFS on his tree starting from the root BFS can be described by the following pseudocode Monocarp was fascinated by BFS so much that in the end he lost his tree Fortunately he still has a sequence of vertices in which order vertices were visited by the BFS algorithm the array from the pseudocode Monocarp knows that each vertex was visited exactly once since they were put and taken from the queue exactly once Also he knows that all children of each vertex were viewed Monocarp knows that there are many trees in the general case with the same visiting order so he doesn t hope to restore his tree Monocarp is okay with any tree that of a tree is the maximum depth of the tree s vertices and the depth of a vertex is the number of edges in the path from the root to it For example the depth of vertex is since it s the root and the depth of all root s children are Help Monocarp to find any tree with given visiting order and minimum height ,Due to the nature of BFS the visiting order consists of several segments first goes root has depth then all vertices with depth then all vertices with depth and so on Since any vertex of depth is a child of vertex of depth then it s optimal to make the number of vertices with depth as many as possible then make the number of vertices with depth as many as possible and so on Since children of a vertex are viewed in ascending order and form a segment in visiting order then an arbitrary segment of visiting order can be children of the same vertex iff elements in the segments are in ascending order These two observations lead us to a greedy strategy then let s find the maximum that segment is in ascending order they will be the children of and the only vertices of depth Next search the maximum such that segment is in ascending order they will be the children of and so on It s easy to see that this strategy maximizes the number of vertices of each depth level so minimize the height of the tree 
You are given arrays each array consists of exactly integers We denote the th element of the th array as You have to choose two arrays and it is possible that After that you will obtain a new array consisting of integers such that for every Your goal is to choose and so that the value of is maximum possible ,We will use binary search to solve the problem Suppose we want to know if the answer is not less than Each array can be represented by a bit mask where the th bit is if the th element of the array is not less than or if the th element is less than If we want to verify that the answer is not less than we have to choose two arrays such that bitwise OR of their masks is Checking all pairs of arrays is too slow Instead we can treat the arrays represented by the same masks as equal so we will have no more than distinct arrays and we can iterate over pairs Overall the solution works in 
You are given a graph with vertices each pair of vertices in have both directed edges and there are no self loops You should find such a cycle in that visits every directed edge exactly once allowing for revisiting vertices We can write such cycle as a list of vertices a visiting order where each occurs exactly once Find the such cycle It s not hard to prove that the cycle always exists Since the answer can be too large print its segment in other words ,The solution of the problem can be found clearly in constructive way An example for 1 2 1 3 1 4 1 5 2 3 2 4 2 5 3 4 3 5 4 5 1 where brackets mean that we call here some recursive function Since on each level of recursion we have only elements and there levels then the generation of the certificate is quite easy if on the currect level of recursion we can skip the whole part let s just skip it Otherwise let s build this part Anyway the built part of the cycle will have only length so the whole algorithm has complexity The answer is lexicographically minimum by the construction since on each level of recursion there is no way to build lexicographically smaller sequence 
You are given a regular polygon with vertices labeled from to in counter clockwise order The triangulation of a given polygon is a set of triangles such that each vertex of each triangle is a vertex of the initial polygon there is no pair of triangles such that their intersection has non zero area and the total area of all triangles is equal to the area of the given polygon The weight of a triangulation is the sum of weigths of triangles it consists of where the weight of a triagle is denoted as the product of labels of its vertices Calculate the minimum weight among all triangulations of the polygon ,You can use straightforward way and calculate answer with l r dp with But there is a easier claim it s optimal to split gon with diagonals coming from so answer is Proof let s look at the triange which contains edge Let s name it If we can delete this triangle and go to gon Otherwise Let s look at triangle It always exists and Finally if we change pair of triangles to answer will decrease since and that s why Note that triangle changes to and so repeating this step will eventually lead us to situation As a result we can morph any triangulation into one mentioned above and its weight won t increase 
Recently Luba bought a monitor Monitor is a rectangular matrix of size But then she started to notice that some pixels cease to work properly Luba thinks that the monitor will become broken the first moment when it contains a square consisting entirely of broken pixels She knows that pixels are already broken and for each of them she knows the moment when it stopped working Help Luba to determine when the monitor became broken or tell that it s still not broken even after all pixels stopped working ,At first let s sort broken pixels in non descending order by times they appear Obviously if the first broken pixels make monitor broken pixel won t fix it Thus binary search on answer will work Let s search for the first moment in time when the monitor becomes broken The function to check if in some moment monitor is broken looks the following way As we want to check if there is a submatrix of size which consists only of broken pixels let s precalc the array of partial sums is the number of broken pixels on submatrix from to is calculated as if is broken pixel otherwise Sum on submatrix of size then looks like Check all possible and from to and find out if there exists submatrix with sum equal to Overall complexity 
Medicine faculty of Berland State University has just finished their admission campaign As usual about of applicants are girls and majority of them are going to live in the university dormitory for the next hopefully years The dormitory consists of rooms and a single mouse Girls decided to set mouse traps in some rooms to get rid of the horrible monster Setting a trap in room number costs burles Rooms are numbered from to Mouse doesn t sit in place all the time it constantly runs If it is in room in second then it will run to room in second without visiting any other rooms inbetween means that mouse won t leave room It s second in the start If the mouse is in some room with a mouse trap in it then the mouse get caught into this trap That would have been so easy if the girls actually knew where the mouse at Unfortunately that s not the case mouse can be in any room from to at second What it the minimal total amount of burles girls can spend to set the traps in order to guarantee that the mouse will eventually be caught no matter the room it started from ,Mouse jumps on a cycle at some point no matter the starting vertex thus it s always the most profitable to set traps on cycles The structure of the graph implies that there are no intersecting cycles Moreover mouse will visit each vertex of the cycle so it s enough to set exactly one trap on each cycle The only thing left is to find the cheapest vertex of each cycle This can be done by a simple dfs Overall complexity 
Alice and Bob got very bored during a long car trip so they decided to play a game From the window they can see cars of different colors running past them Cars are going one after another The game rules are like this Firstly Alice chooses some color then Bob chooses some color After each car they update the number of cars of their chosen color that have run past them Let s define this numbers after th car and If for every then the winner is Alice If for every then the winner is Bob Otherwise it s a draw Bob knows all the colors of cars that they will encounter and order of their appearance Alice have already chosen her color and Bob now wants to choose such color that he will win the game draw is not a win Help him find this color If there are multiple solutions print any of them If there is no such color then print ,Let s maintain the current availability of colors and the amounts of cars of each color Firstly color is never available When car of some color goes you check if the number of cars of color past before this one isn t smaller than the number of cars of color Only after that increment the amount by one If it was less then set its availability to false If car of color goes then simply increment its amount In the end iterate over all colors and check if it s both available and has higher or equal amount than the amount of cars of color Okay why this works As all the amounts cannot decrease color will become not available at some moment when car of color goes And this will be encountered either when the new car of color goes or in the end of the sequence Amount of cars of color doesn t update between this periods And if there was point when there became more cars of color than of color then this inequality will hold until the next moment we will check Overall complexity 
So you decided to hold a contest on Codeforces You prepared the problems statements solutions checkers validators tests Suddenly your coordinator asks you to change all your tests to multiple testcases in the easiest problem Initially each test in that problem is just an array The maximum size of an array is For simplicity the contents of arrays don t matter You have tests the th test is an array of size Your coordinator asks you to distribute all of your arrays into multiple testcases Each testcase can include multiple arrays However each testcase should include no more than arrays of size no more than arrays of size no more than arrays of size Also So now your goal is to create the new testcases in such a way that each of the initial arrays appears in testcase for each testcase the given conditions hold the number of testcases is minimum possible Print the minimum possible number of testcases you can achieve and the sizes of arrays included in each testcase ,Let s estimate the smallest possible achievable answer Let the number of the arrays of size greater than or equal to i be g i The answer is maximum lceil frac g i c i rceil over all i from 1 to k You can prove that you can t fit g i arrays in less than lceil frac g i c i rceil testcases with the pigeonhole principle Let that be called ans Ok let s now construct the solution for that estimate Sort arrays in the increasing or decreasing order and assign the i th array 0 indexed in that order to the i mod ans testcase It s easy to see that for any i the number of arrays of size greater than or equal to i is always restricted by lceil frac g i c i rceil Overall complexity O n log n k or O n k if you care enough to do counting sort 
You are given a multiset consisting of integers You have to process queries of two types add integer into the multiset find the th order statistics in the multiset and remove it th order statistics in the multiset is the th element in the sorted list of all elements of the multiset For example if the multiset contains elements and then you have to find the rd element in which is If you try to delete an element which occurs multiple times in the multiset only one occurence is removed After processing all queries print number belonging to the multiset or say that it is empty ,First solution write some data structure that would simulate the operations as they are given for example a segment tree or a Fenwick tree Probably will require optimization since the limits are strict Second solution notice that we have to find only one number belonging to the multiset For example let s find the minimum element We can do it with binary search as follows let s write a function that for a given element tells the number of elements not greater than in the resulting multiset To implement it use the fact that all elements are indistinguishable and all elements are indistinguishable too so the multiset can be maintained with just two counters Okay how does this function help The minimum in the resulting multiset is the minimum such that this function returns non zero for it and since the function is monotonous we can find the answer with binary search 
You are given distinct points on a plane The coordinates of the th point are For each point find the nearest in terms of Manhattan distance point with that is not among the given points If there are multiple such points you can choose any of them The Manhattan distance between two points and is ,Firstly we can find answers for all points that are adjacent to at least one point not from the set The distance for such points is obviously and this is the smallest possible answer we can get On the next iteration we can set answers for all points that are adjacent to points with found answers because they don t have neighbors not from the set the distance for them is at least It doesn t matter which point we will take so if the point is adjacent to some point that have the answer we can set the answer for the point as the answer for the point We can repeat this process until we find answers for all points In terms of the code this can be done by breadth first search BFS In other words we set answers for the points that have the distance and then push these answers to all adjacent points from the set in order of the increasing distance until we find all the answers Time complexity 
You are given segments on a line There are no ends of some segments that coincide For each segment find the number of segments it contains ,This problem is a standard two dimensional problem that can be solved with one dimensional data structure In the same way a lot of other problems can be solved for example the of finding the maximal weighted chain of points so that both coordinates of each point are greater than the coordinates of the predecessing point Rewrite the problem formally for each we should count the number of indices so that the following conditions are hold and Let s sort all segments by the left ends from right to left and maintain some data structure Fenwick tree will be the best choice with the right ends of the processed segments To calculate the answer for the current segment we should simple take the prefix sum for the right end of the current segment So the condition is hold by sorting and iterating over the segments from the right to the left the first dimension of the problem The condition is hold by taking the prefix sum in data structure the second dimension 
You are given points on a plane All the points are distinct and no three of them lie on the same line Find the number of parallelograms with the vertices at the given points ,It s known that the diagonals of a parallelogram split each other in the middle Let s iterate over the pairs of points and consider the middle of the segment Let s calculate the value for each middle is the number of segments with the middle Easy to see that the answer is 
You are given a sequence of pairs of integers This sequence is called bad if it is sorted in non descending order by first elements or if it is sorted in non descending order by second elements Otherwise the sequence is good There are examples of good and bad sequences is bad because the sequence of first elements is sorted is bad because the sequence of second elements is sorted is bad because both sequences the sequence of first elements and the sequence of second elements are sorted is good because neither the sequence of first elements nor the sequence of second elements is sorted Calculate the number of permutations of size such that after applying this permutation to the sequence it turns into a good sequence A permutation of size is a sequence consisting of distinct integers from to If you apply permutation to the sequence you get the sequence For example if and then turns into ,Let s suppose that all permutation are good We counted the permutations giving the sequences where the first elements are sorted we denote the number of such permutations as and the permutations giving the sequences where the second elements are sorted we denote the number of such permutations as Then the answer is right No because we subtracted the number of sequences where first and second elements are sorted simultaneously we denote this number as twice So the answer is How can we calculate the value of It s easy to understand that the elements having equal can be arranged in any order So where is the number of elements equal to among can be calculated the same way How can we calculate the value of First of all there is a case where it is impossible to arrange the elements of the sequence so that the first elements and the second elements are sorted To check that we may sort the given sequence comparing two elements by and if are equal by If the sequence of second elements in the resulting sequence is not sorted then Otherwise equal elements of the given sequence can be arranged in any order So where are the elements that appear in the given sequence of pairs at least once 
You have array that contains all integers from to twice You can arbitrary permute any numbers in Let number be in positions in the permuted array Let s define the value the distance between the positions of the number Permute the numbers in array to minimize the value of the sum ,Let s build the answer with the sum equal to zero Let be even Let s place odd numbers in the first half of the array the number in the positions and the number in the positions and and so on Similarly let s place even numbers in the second half the number in the position and the number in the positions and and so on We can place the number in the leftover positions We can build the answer for odd in a similar way Easy to see that our construction will give zero sum 
You are given points on Cartesian plane Every point is a lattice point i e both of its coordinates are integers and all points are distinct You may draw two straight lines not necessarily distinct Is it possible to do this in such a way that every point lies on at least one of these lines ,If the number of points is less than then the answer is obviously Else let s fix first points Check if there is a solution if st and nd points lie on the same line Just erase all points which lie on this line and check the remaining points if they belong to one line If we didn t find the answer let s check points and in the same way If its failed again then line which contains point can t contain points and so points and must lie on one line If we didn t succeed again then there is no way to do it so the answer is Checking that points and belong to the same line can be done by calculating 2d version of cross product It equals to if vectors and are collinear 
You have integers You have to redistribute these elements into pairs After that you choose pairs and take minimum elements from them and from the other pairs you take maximum elements Your goal is to obtain the set of numbers as the result of taking elements from the pairs What is the number of different s such that it s possible to obtain the set if for each you can choose how to distribute numbers into pairs and from which pairs choose minimum elements ,Let s prove that in the set minimum elements will be from pairs where we ll take minimums and analogically maximums will be from pairs where we ll take maximums By contradiction let s look at two pairs and where we will take maximum from and minimum from and if we swap elements and and get pair the result won t change but now minimum from pair will be less than maximum from So we can always make pairs in such a way that the chosen minimum from any pair will be less than the chosen maximum from any other pair Let s make set as all elements which are not in In the same way we can prove that minimums of are from pairs where we took maximums and maximums are from pairs where we took minimums Let s say and are sorted Now we ve proven that for a fixed we should pair with and with It s not hard to prove that it s optimal to pair and in the same way For a fixed we can just check that constructed pairs are valid But what happens if we move from to If for all was valid then for all pairs will be valid as well And on contrary if at least one pair wasn t valid then for the pair won t be valid as well Due to monotony we can find the maximum valid just checking only pairs and in the same way we can find maximum minimum such that all pairs are valid That s why all valid s form a segment and we need to find its borders We can find a maximum maximum with either binary search or with two pointers and print the length of the segment Time complexity is either or 
 is a complete binary tree consisting of vertices It means that exactly one vertex is a root and each vertex is either a leaf and doesn t have children or an inner node and has exactly two children All leaves of a complete binary tree have the same depth distance from the root So is a number such that is a power of In the picture you can see a complete binary tree with Vertices are numbered from to in a special recursive way we recursively assign numbers to all vertices from the left subtree if current vertex is not a leaf then assign a number to the current vertex and then recursively assign numbers to all vertices from the right subtree if it exists In the picture vertices are numbered exactly using this algorithm It is clear that for each size of a complete binary tree exists exactly one way to give numbers to all vertices This way of numbering is called You have to write a program that for given answers queries to the tree Each query consists of an integer number and a string where is the number of vertex and represents the path starting from this vertex String doesn t contain any characters other than and which mean traverse to the left child to the right child and to the parent respectively Characters from have to be processed from left to right considering that is the vertex where the path starts If it s impossible to process a character for example to go to the left child of a leaf then you have to skip it The answer is the number of vertex where the path represented by ends For example if and then the answer is ,In this editorial represents the number of vertex we are currently in Let be the maximum integer number such that is divisible by or the number of zeroes at the end of the binary representation of It is easy to prove that if then is a leaf if then both children of are leaves and so on Even more the difference between and any of his children is exactly So to traverse to the left child we have to subtract from if is not a leaf and to traverse to the right child we add to How can we process traversions up Let be the number of the parent node has exactly zeroes at the end of its binary representation so to traverse from to we need to either add or subtract from And to traverse from to we also have to either subtract or add to One of these operations will lead us to the number divisible by and not divisible by and we need to choose this operation Time complexity is 
Monocarp had a permutation of integers a permutation is an array where each element from to occurs exactly once Then Monocarp calculated an array of integers of size where For example if the permutation is then the array is equal to Unfortunately the Monocarp has lost his permutation so he wants to restore it Your task is to find a permutation that corresponds to the given array If there are multiple possible permutations then print any of them The tests are constructed in such a way that least one suitable permutation exists ,We have for each we can rewrite this as follows or From here we can see that for each there is a segment of values that can be assigned to So we have to match each number from to with one of these segments To solve this problem we can iterate from to Let the current number be then it can be paired with a segment without a pair such that and the right bound is minimum among all such segments because it will be the first to end among these segments To do this it is enough to maintain a set with open segments that have not yet been assigned a pair and choose from it a segment with the minimum right bound Before running this method you can sort the segments by their left border so they can be easily added to this set when we go from to we will need to insert all segments that begin with that s why it s convenient to have them sorted by their left border beforehand 
 teams participate in a playoff tournament The tournament consists of games They are held as follows first of all the teams are split into pairs team plays against team team plays against team exactly in this order and so on so games are played in that phase When a team loses a game it is eliminated and each game results in elimination of one team there are no ties After that only teams remain If only one team remains it is declared the champion otherwise games are played in the first one of them the winner of the game vs plays against the winner of the game vs then the winner of the game vs plays against the winner of the game vs and so on This process repeats until only one team remains For example this picture describes the chronological order of games with Let the string consisting of characters describe the results of the games in chronological order as follows if is then the team with lower index wins the th game if is then the team with greater index wins the th game if is then the result of the th game is unknown any team could win this game Let be the number of of the tournament described by the string A team is a of the tournament if it is possible to replace every with either or in such a way that team is the champion You are given the initial state of the string You have to process queries of the following form replace with character and print as the result of the query ,Denote as the number of teams that can be winners in the th game The answer to the problem is If the th game is played between the winners of games and then if if if So we can calculate all values of for the initial string Note that the result of no more than other games depends on the result of any game So if we change it will change no more than values of and we can recalculate all of them For convenience you can renumerate the games so that the playoff looks like a segment tree i e the final has the number the semifinals have numbers and etc 
 teams participate in a playoff tournament The tournament consists of games They are held as follows in the first phase of the tournament the teams are split into pairs team plays against team team plays against team and so on so games are played in that phase When a team loses a game it is eliminated and each game results in elimination of one team there are no ties After that only teams remain If only one team remains it is declared the champion otherwise the second phase begins where games are played in the first one of them the winner of the game vs plays against the winner of the game vs then the winner of the game vs plays against the winner of the game vs and so on This process repeats until only one team remains The skill level of the th team is where is a permutation of integers a permutation is an array where each element from to occurs exactly once You are given a string which consists of characters These characters denote the results of games in each phase of the tournament as follows if is equal to then during the th phase the phase with games in each match the team with the lower skill level wins if is equal to then during the th phase the phase with games in each match the team with the higher skill level wins Let s say that an integer is if it is possible to find a permutation such that the team with skill wins the tournament Find all winning integers ,Firstly let s prove that the order of characters in s is interchangeable Suppose we have a tournament of four teams with skills a b c and d such that a b c d and this tournament has the form 01 or 10 It s easy to see that a and d cannot be winners since a will be eliminated in the round with type 1 and d will be eliminated in the round with type 0 However it s easy to show that both with s 10 and with s 01 b and c can be winners Using this argument to matches that go during phases i and i 1 a group of two matches during phase i and a match during phase i 1 between the winners of those matches can be considered a tournament with n 2 we can show that swapping s i and s i 1 does not affect the possible winners of the tournament So suppose all phases of type 1 happen before phases of type 0 there are x phases of type 1 and y phases of type 0 x y n 2 x y 2 y teams will be eliminated in the first part phases of type 1 and the team with the lowest skill that wasn t eliminated in the first half will win the second half It s easy to see that the teams with skills 1 2 x 1 cannot pass through the first part of the tournament since to pass the first part a team has to be the strongest in its subtree of size 2 x Furthermore since the minimum of 2 y teams passing through the first half wins the winner should have skill not greater than 2 x y 2 y 1 the winner should have lower skill than at least 2 y 1 teams so teams with skills higher than 2 x y 2 y 1 cannot win Okay now all possible winners belong to the segment 2 x 2 n 2 y 1 Let s show that any integer from this segment can be winning Suppose k in 2 x 2 n 2 y 1 let s construct the tournament in such a way that only team with skill k and 2 y 1 teams with the highest skill pass through the first part of the tournament obviously then team k wins There are 2 y independent tournaments of size 2 x in the first part let s assign teams with skills from 1 to 2 x 1 and also the team k to one of those tournaments for all other 2 y 1 tournaments let s assign the teams in such a way that exactly one team from the 2 y 1 highest ones competes in each of them It s easy to see that the team k will win its tournament and every team from the 2 y 1 highest ones will win its tournament as well so the second half will contain only teams with skills k and 2 n 2 y 2 2 n and obviously k will be the winner of this tournament So the answer to the problem is the segment of integers 2 x 2 n 2 y 1 
You are given an integer You have to find a sequence consisting of digits such that it has exactly subsequences equal to For example sequence has subsequences equal to you can remove the second and fifth characters you can remove the third and fifth characters you can remove the fourth and fifth characters you can remove the second and sixth characters you can remove the third and sixth characters you can remove the fourth and sixth characters You have to answer independent queries ,Let s consider the following string If digit occurs times in it then string have subsequences Let s increase the number of digits in this string while condition holds is the number of digits in this string The length of this string will not exceed because The value will not exceed as well All we have to do is increase the number of subsequences in the current string by So if we add digits after the first two digits we increase the number of subsequences by The string will look like this where sequence consists of exactly digits and sequence consists of exactly digits 
You are given a string consisting of characters Each character of is either or A substring of is a contiguous subsequence of its characters You have to choose two substrings of possibly intersecting possibly the same possibly non intersecting just any two substrings After choosing them you calculate the value of the chosen pair of substrings as follows let be the first substring be the second chosen substring and be the integer such that is its binary representation for example if is the value is the of and Calculate the maximum possible value you can get and print it ,The first observation we need is that we can choose two prefixes of as the substrings used in forming the results This can be proved easily suppose we chose a substring which does not contain the leftmost character of if we expand it to the left the answer won t become worse So it is optimal to choose two prefixes of as the substrings Furthermore one of these prefixes must be itself if the leftmost index of is the length of the answer won t exceed but the only way to have a in the th bit of the answer is to choose a prefix of where the th character from the right is and there is only one such prefix of which is itself So now we can solve the problem in try to combine all prefixes of with itself and choose the one that yields the best answer To speed this up we need to somehow cut down on the number of prefixes of we check Let s look at the first block of s in The next character after this block is since we take as one of the substring in order to get instead of in the corresponding position of the answer we need to choose a prefix which has in that position This represents one of the s from the first block of s since only one of them can shift to that position So we need to check only the prefixes such that by using them we shift some character from the first block to the position of the first after this block Since the tests are random the expected length of the first block of s is furthermore even the probabiliy that its length is or bigger is about so the expected number of prefixes we need to check is also Thus the expected runtime of our solution is 
Professor GukiZ has two arrays of integers and Professor wants to make the sum of the elements in the array as close as possible to the sum of the elements in the array So he wants to minimize the value In one operation professor can swap some element from the array and some element from the array For example if the array is and the array is professor can swap the element from the array and the element from the array and get the new array and the new array Professor doesn t want to make more than two swaps Find the minimal value and some sequence of no more than two swaps that will lead to the such value Professor makes swaps one by one each new swap he makes with the new arrays and ,We can process the cases of zero or one swap in time Consider the case with two swaps Note we can assume that two swaps will lead to move two elements from to and vice versa in other case it is similar to the case with one swap Let s iterate over all the pairs of the values in and store them in some data structure in C we can user map Now let s iterate over all the pairs and find in out data structure the value closest to the value and update the answer by the value Required sum we can find using binary search by data structure map in C has lower bound function 
You are given a program that consists of instructions Initially a single variable is assigned to Afterwards the instructions are of two types increase by decrease by You are given queries of the following format query how many distinct values is assigned to if all the instructions between the th one and the th one inclusive are ignored and the rest are executed without changing the order ,The value of always changes by thus the set of values of is always some contiguous segment The length of such segment can be determined by just its minimum and maximum values So we have to solve two separate tasks for each query find the minimum and the maximum value gets assigned to I ll describe only the minimum one This task however can as well be split into two parts minimum value on a prefix before and on a suffix after The prefix is easy it doesn t get changed by a query so it can be precalculated beforehand Minimum value on a prefix of length is minimum of a minimum value on a prefix of length and the current value The suffix minimum is not that trivial First in order to precalculate the minimum value on a suffix of length we have to learn to prepend an instruction to the suffix of length Consider the graph of values of over time What happens to it if the initial value of is not but for example It just gets shifted by upwards That move is actually the same as prepending a instruction So the minimum value for a suffix of length is a minimum of a minimum value for a suffix of length increased by the current instruction and the start of the graph So now we have a minimum value on a suffix after However it can t be taken into the answer as it is because it considers the graph for the suffix to be starting from And that s not the case The graph for the suffix starts from the value the prefix ends on So we can shift the answer for the suffix by the value of after the prefix The overall minimum value is just the minimum on a prefix and on a suffix then Overall complexity per testcase 
You are given two arrays an array consisting of zeros and an array consisting of integers You can apply the following operation to the array an arbitrary number of times choose some subsegment of of length and add the arithmetic progression to this subsegment i e add to the first element of the subsegment to the second element and so on The chosen subsegment should be inside the borders of the array i e if the left border of the chosen subsegment is then the condition should be satisfied Note that the progression added is always but not the or anything else i e the leftmost element of the subsegment always increases by the second element always increases by and so on Your task is to find the possible number of operations required to satisfy the condition for each from to Note that the condition should be satisfied for all elements at once ,Let s solve the problem greedily But not from the beginning because if we solve it from the beginning we can t be sure what option is more optimal for the next elements e g for the second element it is not clear if we need to add to it starting our segment from the first position or add to it starting our segment from the second position So let s solve the problem from right to left then anything becomes clearer Actually let s operate with the array and decrease its elements instead of using some other array Let s carry some variables and the array of length along with the answer The variable means the value we need to subtract from the current element from currently existing progressions is the number of currently existing progressions and means the number of progressions that will end at the position i e will not add anything from the position and further to the left When we consider the element firstly let s fix decrease it by Then let s fix decrease it by Then let s decrease by and if it becomes less than or equal to zero just proceed Otherwise the number by which we can decrease the th element with one progression equals to zero indexed Then the number of progressions we need to satisfy this element is Let s add this number to the answer increase by increase by and if then we need to end these progressions somewhere so let s add to Time complexity 
A Pythagorean triple is a triple of integer numbers such that it is possible to form a right triangle with the lengths of the first cathetus the second cathetus and the hypotenuse equal to and respectively An example of the Pythagorean triple is Vasya studies the properties of right triangles and he uses a formula that determines if some triple of integers is Pythagorean Unfortunately he has forgotten the exact formula he remembers only that the formula was some equation with squares So he came up with the following formula Obviously this is not the right formula to check if a triple of numbers is Pythagorean But to Vasya s surprise it actually worked on the triple so according to Vasya s formula it is a Pythagorean triple When Vasya found the right formula and understood that his formula is wrong he wondered how many are there triples of integers with such that they are Pythagorean both according to his formula and the real definition He asked you to count these triples ,We have to find the number of triples such that equations and are satisfied Let s subtract one equation from another and get that So we know that and after substituting we get that We can see that there is only one correct value of and for every odd value of greater than So we can iterate over the value of and check that the corresponding value of doesn t exceed This solution works in because but you can also solve it in 
There are towns located on a coordinate line numbered from to The th town is located at the point You build a radio tower in each of the towns with probability these events are independent After that you want to set the signal power on each tower to some integer from to signal powers are not necessarily the same but also not necessarily different The signal from a tower located in a town with signal power reaches every city such that After building the towers you want to choose signal powers in such a way that towns and don t get any signal from the radio towers towns get signal from one radio tower each For example if and you have built the towers in towns and you may set the signal power of the tower in town to and the signal power of the towers in towns and to That way towns and don t get the signal from any tower towns and get the signal from the tower in town town gets the signal from the tower in town and town gets the signal from the tower in town Calculate the probability that after building the towers you will have a way to set signal powers to meet all constraints ,The crucial observation is that when the positions of towers are fixed the way to set their signal powers is unique if it exists That s because the first tower should have its signal power exactly equal to the required to cover all towns before it the second tower should have signal power exactly equal to the required to cover all towns before it that weren t covered by the first one and so on So let s count the number of ways to cover all towns and then divide it by Covering all towns can be expressed as splitting into the sum of several positive odd integers It can be calculated with dynamic programming with prefix sums but we can also prove that the number of ways to split is exactly the th integer in the Fibonacci sequence as follows this proof uses mathematical induction for it s quite obvious for and let s iterate on the length of the last segment We have to sum and so on until we get for and let s iterate on the length of the last segment and add to result since we can cover everything with a single segment So this is and so on So the answer to the problem is The last thing we have to consider is that we have to print a fraction modulo Since is a prime using Fermat little theorem we can calculate as Exponentiation must be done with some fast algorithm for example binary exponentiation Note it s common in problems requiring to calculate something modulo some prime number to have problems with overflow in intermediate calculations or some other issues when we forget to take the result of some expression modulo I recommend using either special addition multiplication exponentiation functions that always take the result modulo an example how to write and use them can be viewed in the model solution or a special modular integer data structure with overloaded operators that you have to implement by yourself 
You are given a matrix consisting of rows and columns The th cell of the th row contains an integer First you have to color each row of the matrix either red or blue in such a way that and Then you have to choose an integer and cut the colored matrix in such a way that the first columns become a separate matrix the matrix and the last columns become a separate matrix the matrix The coloring and the cut are called if two properties hold every red cell in the left matrix contains an integer greater than every blue cell in the left matrix every blue cell in the right matrix contains an integer greater than every red cell in the right matrix Find any perfect coloring and cut or report that there are none ,Imagine you fixed some cut and then colored one row red Which rows can now be colored red or blue so that the condition on the left matrix is satisfied If the row has at least one number greater or equal than the numbers in the red row then the row must be red Otherwise it can be either red or blue However imagine a weaker condition Let s look only at the first cell in each row Sort the rows by the first cell in them Similarly if a row is colored red all the rows that are further in the sorted order should also be red because they already have a greater or equal number in them It implies that after you sort the rows the only possible colorings are color some prefix of the rows in blue and the remaining suffix in red So there are possible colorings and possible cuts If we learn to check if they are perfect in we can get the solution in Turns out the condition all numbers in the submatrix should be greater than all numbers in the other submatrix is the same as the minimum in the first submatrix should be greater than the maximum in the second submatrix Thus you can first precalculate prefix and suffix minimums and maximums and check a coloring and a cut in Overall complexity per testcase 
Let s call an undirected graph if and only if for each edge the greatest common divisor of and is If there is no edge between some pair of vertices and then the value of doesn t matter The vertices are numbered from to Construct a graph with vertices and edges such that it is connected and it contains neither self loops nor multiple edges If there exists no valid graph with the given number of vertices and edges then output If there are multiple answers then print any of them ,Even though is up to straightforward solution will work You iterate for from to in the outer loop from to in the inner loop and check each time When edges are found you break from both loops Here is why this work fast enough The total number of pairs with is where is Euler s totient function We also want to substract a single pair And this sum grows so fast that after about iteratons will be greater than for any The only thing left is to check that is big enough to build a connected graph and small enough to fit all possible edges for given the formula above Overall complexity 
You are given two integer numbers and You may perform several operations with the integer Each operation you perform is the following one choose any digit that occurs in the decimal representation of at least once and replace by You want to make the length of decimal representation of without leading zeroes equal to What is the minimum number of operations required to do that ,One of the possible approaches to this problem is to try multiplying only by the largest digit in it Unfortunately this doesn t work quite well since it gives WA on one of the examples That example is too big to consider but a smaller version of it can prove that this is an incorrect solution let If we multiply by we get and there s no way to obtain a number with digits using the next action But if we multiply by we get which can then be multiplied by to obtain a digit number So considering only the largest digit is not enough This implies that we somehow need to consider the options that are not optimal locally but optimal globally i e choose a lower digit right now to obtain a higher digit in the future Let s try to estimate the number of possible integers that can be obtained using these operations to see if we can consider all possible options The key observation is that each integer we obtain will have the form since only one digit primes can be added to the factorization Since we consider only numbers less than is not greater than is not greater than is not greater than and is not greater than and the number of reachable integers is about million note that this is a very generous bound since not all combinations of yield an integer less than and not all such integers can be reached with the operations This allows us to use BFS or dynamic programming to calculate the answer 
You are given a rooted tree consisting of vertices The vertices are numbered from to the root is the vertex You can perform the following operation times choose an edge of the tree such that is a parent of remove the edge add an edge i e make with its subtree a child of the root of a tree is the maximum depth of its vertices and the depth of a vertex is the number of edges on the path from the root to it For example the depth of vertex is since it s the root and the depth of all its children is What s the smallest height of the tree that can be achieved ,Start with the following Let s look at the input format and consider what the operation actually does to it Since it only changes the parent of some vertex it modifies only one value in it Moreover it just assigns it to Thus the goal is to assign at most values of parents to to minimize the resulting height of the tree In particular that implies that we can freely rearrange the operations since the assignments don t depend on each other One more conclusion Imagine we have already built some answer One by one we moved some subtrees to be children of the root It could happen that we first moved some subtree of a vertex and then applied the operation to an edge inside the subtree of Let s show that it s always possible to rearrange the operations in the answer to avoid that Just apply the operations in order of decreasing the depth of the vertex If we knew what height we want to get we could have been making sure that cut subtree has height at most since it gets increased by when glueing it to the root then pretending that that subtree doesn t exist anymore Moreover it s always required to cut subtrees with height at most If you cut a higher subtree then the answer can t be smaller than since we rearranged the operation to not touch that subtree anymore Well let s fix that height if we wanted that Let s try the solve the opposite problem How many operations will it require to make the tree height at most Obviously the values for this problem are non increasing the greater we allow the height to be the less operations it will require Thus we will be able to apply binary search to it to find the smallest height we can achieve with at most operations Now we want to be choosing the subtrees of height at most repeatedly and cutting them off until the height of the tree becomes at most Let s think greedily If the height of the tree is not at most yet then there exists a vertex with the depth greater than Let s look at the deepest of them That leaf has to be cut in some subtree Otherwise the tree won t become any less higher What subtree is the best for it What options do we have That vertex itself and all its parents up until above It s always optimal to cut the highest of them the st parent since it will remove at least all the vertices of any other cut and some other vertices along with them It s also always possible to remove the st parent since it will always have height exactly The vertex we are looking at is the deepest in the entire tree there are no deeper vertices in the subtree of the st parent Thus the strategy is to keep cutting the st parent of the deepest vertex until the tree becomes at most height Now about the implementation details First we can process the vertices from the deepest upwards in their order in the original tree The operation only removes some vertices but doesn t change the depth of the remaining ones For example you can do a bfs from the root to find the order Now the st parent Let s find it for each vertex before starting the process Run a dfs and maintain the stack of the ascendants When going down the child append it to the stack What exiting pop from the stack Now you can just look at the st element from the top of the stack To be able to do that simulate the stack with a vector C or a list Python Finally we would have to determine if the current vertex in the order is removed or not For that we could maintain a boolean array for the removed vertices Once you apply the operation run the dfs from the removed vertex and mark all the newly removed descendants of it in If you don t go into already marked vertices there will be no more than calls of the dfs The number of cut vertices is the answer for the fixed height Overall complexity per testcase 
There is a grid consisting of rows and columns The rows are numbered from to from bottom to top The columns are numbered from to from left to right The th column has the bottom cells blocked the cells in rows the remaining cells are unblocked A robot is travelling across this grid You can send it commands move up right down or left If a robot attempts to move into a blocked cell or outside the grid it explodes However the robot is broken it executes each received command times So if you tell it to move up for example it will move up times cells You can t send it commands while the robot executes the current one You are asked queries about the robot Each query has a start cell a finish cell and a value Can you send the robot an arbitrary number of commands possibly zero so that it reaches the finish cell from the start cell given that it executes each command times The robot must stop in the finish cell If it visits the finish cell while still executing commands it doesn t count ,What if there were no blocked cells Then the movement is easy From cell we can go to cells or Thus we can visit all cells that have the same remainder modulo over both dimensions The answer would be if and Let s choose the following path from start to finish Let be less or equal to If that isn t the case swap the cells First move up until the row is the same then move to the side until the column is the same What stops us from doing the same on a grid with blocked cells The first part of the part can remain the same we can always move up from the cell Only cells below the start cell can be blocked The second part is trickier If there is a column with too many blocked cells between the start and the finish column then we won t be able to pass through it Let s adjust the path for that Move up as high as possible to the highest cell with the same remainder modulo in this column Then move to the finish column and go down to the finish cell If there still exists a column with too many blocked cells then the answer is No matter what we do we won t be able to go around that column Otherwise the answer is Thus the solution is to check for remainders then find the largest number of blocked cells between the query columns and compare it to the highest row with the same remainder modulo as the start or the finish You can use any RMQ data structure you want Overall complexity with sparse table for RMQ for example 
Let s call the of the number the number of zeros to which it ends You have an array of numbers You need to choose a subset of exactly numbers so that the of the product of the selected numbers will be maximum possible ,Let s use dynamic programming to solve this task Obviously the of the number is determined by minimum of powers of and in the number Let be the maximal power of in the number and be the maximal power of Let be the maximum amount of twos we can collect by checking first numbers taking of them with total power of five equal to It is usually called the knapsack problem There are two types of transitions You can either take current element or skip it The answer will be maximum of for every Also keeping this many states can cause ML the first dimension should be stored in two layers and recalced on the fly Overall complexity 
You are the head of a large enterprise people work at you and is odd i e is not divisible by You have to distribute salaries to your employees Initially you have dollars for it and the th employee should get a salary from to dollars You have to distribute salaries in such a way that the median salary is To find the median of a sequence of odd length you have to sort it and take the element in the middle position after sorting For example the median of the sequence is the median of the sequence is It is guaranteed that you have enough money to pay the minimum salary i e You have to answer test cases ,Let be equal minimum amount of money to obtain the median salary at least We ll solve this problem by binary search by Suppose the have to calculate the minimum amount of money for obtaining median salary at least Let s divide all salaries into three groups In order to the median salary be at least there must be at least salaries greater than or equal to Let s denote the number of such salaries as Note that salaries of the first group can t increment the value of so it s beneficial for us to pay the minimum salary for this group Salaries if second group always increment the value of so it s also beneficial for us to pay the minimum salary The salaries from the third group are more interesting For each salary in this group we can pay and increment or we can pay and don t increase The value of should be increased by So if the size of the third group is less than than we can t obtain the median salary Otherwise we can define how many salaries we can take with value and chose the minimal ones 
You are given two integers and Calculate the number of integers such that and Note is the greatest common divisor of and ,The Euclidean algorithm is based on the next fact if then So if then So we can declare that we are looking at different integers with so all forms a segment So we need to find the number of such that Let s denote then and So or Since so we also can represent and therefore Since then or we need to calaculate the number of such that Since so we can consider and this is the definition of Euler s totient function which is the answer Euler s totient function can be calculated using factorization of Then 
You are going to the beach with the idea to build the greatest sand castle ever in your head The beach is not as three dimensional as you could have imagined it can be decribed as a line of spots to pile up sand pillars Spots are numbered through infinity from left to right Obviously there is not enough sand on the beach so you brought packs of sand with you Let height of the sand pillar on some spot be the number of sand packs you spent on it There is a fence of height equal to the height of pillar with sand packs to the left of the first spot and you should prevent sand from going over it Finally you ended up with the following conditions to building the castle no sand from the leftmost spot should go over the fence For any large difference in heights of two neighboring pillars can lead sand to fall down from the higher one to the lower you really don t want this to happen you want to spend all the sand you brought with you As you have infinite spots to build it is always possible to come up with some valid castle structure Though you want the castle to be as compact as possible Your task is to calculate the minimum number of spots you can occupy so that all the aforementioned conditions hold ,Let s consider the optimal answer to always look like will be the leftmost position of a pillar with maximum height We will heavily use the fact that all integers from to appear in this sequence to the right of If you are able to construct any answer it is easy to rearrange it to this pattern select the leftmost maximum sort in non decreasing order and in non increasing order Sorted sequence will also be valid Let a pyramid of height be such a valid castle that it occupies exactly consecutive spots and Exactly sand packs are required to build it At first let s solve the problem without even touching the fence This won t always give the minimal answer but it ll help us further Given some you can build the pyramid of height and get sand packs left over This can fit in exactly pillars you can place any pillar of height next to some pillar of the same height That way we see that This function is non increasing let s show that for any from to is non positive Now we can show that it is always optimal to push the initial pyramid to the left as far as possible probably removing some pillars on positions less than That way the leftmost pillar will have height The total number of sand packs required to build it is This pattern will also include all the integers from to and will have the minimal width you can achieve Monotonicity of this function can be proven in the similar manner Finally the answer can be calculated using the following algorithm Find the maximum such that where Solve the equation or just do the binary search Output the width of resulting truncated pyramid plus the minimal number of additional pillars it will take to distribute leftover sand packs You should also take into consideration the upper bound on to avoid multiplying huge numbers It s about so bit integer type will be enough for all the calculations Overall complexity or 
Santa Claus has received letters from different kids throughout this year Of course each kid wants to get some presents from Santa in particular the th kid asked Santa to give them one of different items as a present Some items could have been asked by multiple kids Santa is really busy so he wants the New Year Bot to choose the presents for all children Unfortunately the Bot s algorithm of choosing presents is bugged To choose a present for some kid the Bot does the following choose one kid equiprobably among all kids choose some item equiprobably among all items kid wants choose a kid who will receive the present equipropably among all kids this choice is independent of choosing and the resulting triple is called of the Bot If kid listed item as an item they want to receive then the decision Otherwise the Bot s choice is Santa is aware of the bug but he can t estimate if this bug is really severe To do so he wants to know the probability that one decision generated according to the aforementioned algorithm is Can you help him ,First of all how to deal with the fractions modulo 998244353 According to Fermat s little theorem x phi m equiv 1 mod m if x is coprime with m So the inverse element for the denominator y is y phi 998244353 1 y 998244351 taken modulo 998244353 A cool property of fractions taken modulo 998244353 or any other number such that denominator is coprime with it is that if we want to add two fractions together and calculate the result modulo some number we can convert these fractions beforehand and then just add them as integer numbers The same works with subtracting multiplying dividing and exponentiating fractions Okay now for the solution itself We know that there are at most 10 6 possible pairs of x y we can iterate on these pairs calculate the probability that the fixed pair is included in the robot s decision that probability is frac 1 x cdot k x and calculate the probability that x y extends to a valid triple it is equal to frac cnt y z where cnt y is the number of kids who want item y Multiplying these two probabilities we get the probability that x y is chosen produces a valid decision since these events are independent and we sum up these values over all possible pairs x y 
Let s call the string if it does not contain a substring of length at least which is a palindrome Recall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first For example the strings are palindromes but the strings are not Let s define of a string as the minimum number of operations so that the string becomes beautiful if in one operation it is allowed to change any character of the string to one of the first letters of the Latin alphabet in lowercase You are given a string of length each character of the string is one of the first letters of the Latin alphabet in lowercase You have to answer queries calculate the cost of the substring of the string from th to th position inclusive ,Note that in the beautiful string s i neq s i 1 because it is a palindrome of length 2 and s i neq s i 2 because it is a palindrome of length 3 This means s i s i 3 i e a beautiful string has the form up to the permutation of the letters and For each permutation of the letters and we will construct a string t of the form of length n Let s define an array a of length n as follows a i 0 if s i t i i e the character at the i th position does not need to be changed and a i 1 otherwise Let s build an array pr of prefix sums of the array a Now you can process a query of the number of positions that need to be replaced for the current line t in O 1 
You are given two lists of segments and Initially all segments are equal to and all segments are equal to In one step you can choose one segment either from the first or from the second list and extend it by In other words suppose you ve chosen segment then you can transform it either into or into Let s define a total intersection as the sum of lengths of intersections of the corresponding pairs of segments i e Empty intersection has length and length of a segment is equal to What is the minimum number of steps you need to make greater or equal to ,At first note that of segments and can be calculated as If it s negative then segments don t intersect otherwise it s exactly length of intersection Now we have two major cases do segments and already intersect or not If segments intersect then we already have as the total intersection Note that making both segments equal to in each pair are always optimal since in each step we will increase the total intersection by After making all segments equal to we can increase total intersection by only in two steps we need to extend both segments in one pair In result we can find not a hard formula to calculate the minimum number of steps we already have of the total intersection then we can increase it by at most using one step per increase and then to any number using two steps per increase In the case of non intersecting and we should at first invest some number of steps in each pair to make them intersect So let s iterate over the number of segments to invest We should make steps to make segments touch Now segments touch so we can use almost the same formulas for them as in the previous case The total complexity is per test case 
As the name of the task implies you are asked to do some work with segments and trees Recall that a tree is a connected undirected graph such that there is exactly one simple path between every pair of its vertices You are given segments for every It is guaranteed that all segments endpoints are integers and all endpoints are unique there is no pair of segments such that they start in the same point end in the same point or one starts in the same point the other one ends Let s generate a graph with vertices from these segments Vertices and are connected by an edge if and only if segments and intersect and neither of it lies fully inside the other one For example pairs and will induce the edges but pairs and will not Determine if the resulting graph is a tree or not ,The main idea of the solution is to find a linear number of intersections of segments Intersections can be found with sweep line approach We will maintain a set for the endpoints open segments When we add a segment we find all segments which intersect with it that is all segments that end earlier than it Obviously if the number of intersections are greater than then the answer is So as soon as we find intersections we stop our algorithm After that it is necessary to check the connectivity of the resulting graph You can use DFS or DSU to do this 
You are given a sequence consisting of integers and an integer Your task is to make the sequence sorted it is considered sorted if the condition holds To make the sequence sorted you may perform the following operation any number of times you want possibly zero choose an integer such that and and swap the values of and For example if the following sequence of operations is possible choose it is possible since then choose it is possible since then choose it is possible since then Calculate the minimum number of operations you have to perform so that becomes sorted or report that it is impossible ,The main fact that allows us to solve this problem is that the value of always increases after swaps and since the resulting sequence should be sorted the indices of elements we swap with also increase This observation is actually enough for us to implement a dynamic programming solution of the form dp i j is the minimum number of actions we have to perform to reach the following situation the last integer we swapped with was and the current value of is Depending on your implementation it works either in or in But there exists a much simpler to code greedy solution scan the array from left to right until it is sorted and find the first element such that we can apply the operation to it and apply that operation to it Implementing it in or even in is easy but proving it is a bit harder The key fact that is required to prove it is that if we can apply an operation to some position but don t do it and instead apply this operation to some position to the right of that one the elements on these two positions are no longer sorted if we can apply the operation to some position then but if we apply the operation to position instead then after it Since we can t go backward the resulting array cannot be sorted by any means that s why we can t skip elements in this greedy solution 
You are given a binary string i e a string consisting of characters and or of length You can perform the following operation with the string choose a substring a contiguous subsequence of having characters in it and shuffle it reorder the characters in the substring as you wish Calculate the number of different strings which can be obtained from by performing this operation at most once ,We could iterate on the substrings we want to shuffle and try to count the number of ways to reorder their characters but unfortunately there s no easy way to take care of the fact that shuffling different substrings may yield the same result Instead we will iterate on the first and the last character that are changed Let these characters be and First of all let s check that they can belong to the same substring we can shuffle it is the case if the string contains at least characters and the substring from the th character to the th character contains at most characters Then after we ve fixed the first and the last characters that are changed we have to calculate the number of ways to shuffle the characters between them including them so that both of these characters are changed Let s calculate and the number of characters and respectively in the substring Then we need to modify these two values for example if the th character is then since it is the first changed character it should become so we need to put there and decrease by one The same for the th character Let and be the values of and after we take care of the fact that the th and the th character are fixed The remaining characters can be in any order so the number of ways to arrang them is We can add up these values for all pairs such that we can shuffle a substring containing these two characters We won t be counting any string twice because we ensure that is the first changed character and is the last changed character Don t forget to add to the answer the string we didn t count is the original one This solution works in but the problem is solvable in 
A tuple of positive integers is called simple if for all pairs of positive integers is a prime You are given an array with positive integers not necessary distinct You want to find a simple subset of the array with the maximum size A prime number or a prime is a natural number greater than that has no positive divisors other than and itself Let s define a subset of the array as a tuple that can be obtained from by removing some possibly all elements of it ,Consider the subset that is the answer to the problem Let be the arbitrary three elements from and let no more than one of them is equal to By the pigeonhole principle two of three elements from have the same parity So we have two integers with even sum and only one of them is equal to so their sum is also greater than So the subset is not simple In this way consists of only two numbers greater than one with a prime sum or consists of some number of ones and also maybe other value so that is a prime We can simply process the first case in time The second case can be processed in linear time Also we should choose the best answer from that two To check the value of order for primality in time we can use the simple or the linear Eratosthenes sieve 
Berland SU holds yet another training contest for its students today students came each of them brought his laptop However it turned out that everyone has forgot their chargers Let students be numbered from to Laptop of the th student has charge at the beginning of the contest and it uses of charge per minute i e if the laptop has charge at the beginning of some minute it becomes charge at the beginning of the next minute The whole contest lasts for minutes Polycarp the coach of Berland SU decided to buy a charger so that all the students would be able to successfully finish the contest He buys the charger at the same moment the contest starts Polycarp can choose to buy the charger with any non negative zero or positive integer power output The power output is chosen before the purchase it can t be changed afterwards Let the chosen power output be from the minute contest starts to the last minute of the contest he can plug the charger into any of the student s laptops and use it for some number of minutes If the laptop is using charge per minute then it will become per minute while the charger is plugged in Negative power usage rate means that the laptop s charge is increasing The charge of any laptop isn t limited it can become infinitely large The charger can be plugged in no more than one laptop at the same time The student successfully finishes the contest if the charge of his laptop never is below zero at the beginning of some minute from the minute contest starts to the last minute of the contest zero charge is allowed The charge of the laptop of the minute the contest ends doesn t matter Help Polycarp to determine the minimal possible power output the charger should have so that all the students are able to successfully finish the contest Also report if no such charger exists ,The easiest part of the solution is to notice that if the charger of power works then the charger of power also works Thus binary search is applicable to the problem is really small and only one laptop can be charged during some minute It implies that check function can work in something polynomial on by searching for the right laptop to charge during every minute I claim that the greedy algorithm works Find the laptop that gets his charge below zero the first Charge it for one minute as early as possible Repeat until you either don t have time to charge the laptop check returns false or the contest is over check returns true Why greedy works Well check any case where check returns false If some laptop runs out of power then all the minutes up to the current one are used to charge something Moreover you can free no minute of these as by doing greedy we charged all laptops as late as possible Freeing some minute will lead to other laptop dying earlier One way to implement this is the following Keep a heap of events pop its head add to it if the time is greater than the number of charges already made and push it back to heap That will simulate the entire process in Unfortunately this may be too slow on some implementations Let s try the following linear approach Maintain not the heap but such an array that th its cell contains all indices of all the laptops to run out of charge on the beginning of minute Keep an iterator to the first non empty position Pop a single index out of this vector charge it and push it to the new position You ll still make steps and on each step you ll make instant operations That will make it for this simulation I m not really sure how to build the maximal answer case however I can estimate the upper bound of binary search You can set in such a way that it charges every laptop in one minute so that it won t run out of power until the end of the contest Choose the smallest the greatest the greatest and you ll end up with total usage Thus will always be enough Overall complexity or if you are skillful enough to squeeze it D 
You have a string consisting of characters Each character is either or You can perform operations on the string Each operation consists of two steps select an integer from to the length of the string then delete the character the string length gets reduced by the indices of characters to the right of the deleted one also get reduced by if the string is not empty delete the maximum length prefix consisting of the same characters the indices of the remaining characters and the string length get reduced by the length of the deleted prefix Note that both steps are mandatory in each operation and their order cannot be changed For example if you have a string the first operation can be one of the following select we ll get select we ll get select we ll get select we ll get select we ll get select we ll get You finish performing operations when the string becomes empty What is the maximum number of operations you can perform ,Suppose the string consists of characters and each character is different from the adjacent ones so the string looks like or It s easy to see that we can t make more than operations each operation deletes at least two characters except for the case when the string consists of only one character And there is an easy way to perform exactly operations always choose the last character and delete it Okay what about the case when some adjacent characters in the string are equal It s never optimal to delete a character that s different from both adjacent characters since the second part of each operation always deletes the left block of equal characters this action merges two blocks so they will be deleted in one second part of the operation which decreases the total number of operations So we should always delete a character from a block with at least two equal characters From which of the blocks if there are more than one It s easy to see that we should choose a character from the leftmost such block since that block is the earliest to be deleted and if we want to make the same action later we might be unable to do it So the solution is greedy during each action we have to find the leftmost block consisting of at least equal characters and delete a character from it or the last character of the string if there are no such blocks Since the length of the string is up to and the number of operations is up to we should do it efficiently for example by storing the eligible blocks in some data structure 
You are given an array and an array For one operation you can sort in non decreasing order any subarray of the array For example if and you choose subbarray then the array turns into You are asked to determine whether it is possible to obtain the array by applying this operation any number of times possibly zero to the array ,Let s reformulate this problem in next form we can sort only subarray of length 2 swap two consecutive elements and if It is simular tasks because we can sort any array by sorting subbarray of length 2 for example bubble sort does exactly that Now lets look at elements and If then we will solve this task for arrays and Otherwise lets look at minimum position such that if there is no such position then answer to the problem is We can move element to the beginning of array only if all elements greater then In other words any index such that must be greater then And if this condition holds then we just delete element and solve task for arrays and But instead of deleting this element we will change information about minimum index such that This index will be the minimum index such that and For do this we will maintain stacks such that for any element of stack condition holds and moreover all elements in stacks are sorted in ascending order the top element of stack is minimal For example if then For finding minimum element on top of stacks we can use some data structure for example segment tree 
You are given two strings and consisting of small Latin letters string can also contain characters of string is calculated by following metric Any two letters can be swapped positions these operations can be performed arbitrary number of times over any pair of positions Among all resulting strings you choose the one with the largest number of occurrences of string is this number of occurrences You should replace all characters with small Latin letters in such a way that the of string is maximal ,Notice that the order of letters doesn t matter at all depends only on amount of each letter Let be the possibility that string will occur in at least times after replacing all signs and after some swaps If is true then is also true That leads to binary search over the answer Let be the amount of letters in and the amount of letters in is the number of signs is true if If some letter appears in less times than needed then replace some signs with it Answer can be restored greedily by replacing signs with the letters needed Overall complexity where is the size of the alphabet 
You are given a permutation of the numbers and pairs of positions At each step you can choose a pair from the given positions and swap the numbers in that positions What is the lexicographically maximal permutation one can get Let and be two permutations of the numbers is lexicographically smaller than the if a number exists so for and ,Consider a graph with vertices whose edges is the pairs from the input It s possible to swap any two values with the positions in some connected component in that graph So we can sort the values from any component in decreasing order Easy to see that after sorting the values of each component we will get the lexicographically maximal permutation 
Petya sometimes has to water his field To water the field Petya needs a tank with exactly ml of water Petya has got tanks th of them initially containing ml of water The tanks are really large any of them can contain any amount of water no matter how large this amount is Also Petya has got a scoop that can contain up to ml of water initially the scoop is empty This scoop can be used to get some water from some tank and after that pour it all into some tank it is impossible to get water from multiple tanks without pouring it or leave some water in the scoop when pouring it When Petya tries to get some water from a tank he gets water where is the current volume of water in the tank Is it possible to obtain a tank with exactly ml of water using these operations If it is possible print a sequence of operations that allows to do it If there are multiple ways to obtain needed amount of water in some tank print any of them ,Eliminate the obvious corner case when we don t have enough water Now we don t consider it in editorial Let s fix some set of tanks and let be the total amount of water in the set If and have the same remainders modulo then we can transfer all water from to one tank transfer all water from to another tank and then using some number of operations transfer required amount of water from to or from to So we have a solution when we have some set of tanks such that What if we don t have such set In this case it is impossible to solve the problem since we cannot obtain a tank with water such that and obviously we cannot obtain a tank with exactly water To find this set we may use some sort of knapsack dynamic programming 
You are given three positive greater than zero integers and You have to find the number of pairs of positive integers such that equality holds Where is the least common multiple of and and is the greatest common divisor of and ,Let s represent as and as where and By definition so we can represent as Now we can rewrite the equation from the statement as follows Since the left hand side is divisible by the right hand side should also be divisible So we can iterate over as divisors of If the right hand side of is not divisible by then we can skip such let s denote as If has some prime divisor then exactly one of and should be divisible by because and have no common divisors So there are pairs of and for current value of We can precalculate the minimum prime divisor for each number up to the maximum value of that you may need in using Eratosthenes sieve Now we can solve the problem in for each testcase but that s not fast enough To speed up this approach we can precalculate the number of prime divisors for each number up to Let s denote as the minimum prime divisor of and as the number of prime divisors of Then plus if Now to solve the problem we only need to iterate over the divisors of so the time complexity is per testcase 
Ivan is playing yet another roguelike computer game He controls a single hero in the game The hero has equipment slots There is a list of items for the th slot the th of them increases the hero strength by The items for each slot are pairwise distinct and are listed in the increasing order of their strength increase So For each slot Ivan chooses exactly one item Let the chosen item for the th slot be the th item in the corresponding list The sequence of choices is called The strength of a build is the sum of the strength increases of the items in it Some builds are banned from the game There is a list of pairwise distinct banned builds It s guaranteed that there s at least one build that s not banned What is the build with the maximum strength that is not banned from the game If there are multiple builds with maximum strength print any of them ,Consider the bruteforce solution You start with a build that contains the most powerful item for each slot In one move you swap an item in some slot for the one that is the previous one by power If a build is not banned update the answer with its total power banned builds can be stored in a set maybe hashset if you hash carefully enough Notice that if you reach some unbanned build in this bruteforce it never makes sense to go further The answer is already updated with this one and all the lower ones have smaller power If you code that bruteforce in a smart way or just add memorization you won t visit any build twice How many states will you visit though Since you can only proceed if you are standing in a banned build you will check around builds You can code it like that and get accepted However there s another way that s easier to code in my opinion The optimal answer can be one of only two types Either it contains the last item of each slot Or it s some banned build with one item swapped with the previous one It s easy to see from the solution above So you can check the first type then iterate over the banned build and try swapping each slot in it checking if the resulting build is banned or not Overall complexity or 
You are given segments on the coordinate axis and the number The point is if it belongs to at least segments Find the smallest by the number of segments set of segments on the coordinate axis which contains all points and no others ,Let s create two events for each segment li is the time of the segment opening and ri is the time of the segment closing Let s sort all events by time if the times are equal let s sort them with priority to opening events In C it can be done with sorting by standard comparator of vector pair int int events where each element of events is the pair with event time and event type 1 for opening and 1 for closing Let s iterate over events and maintain the balance To do that we should simply decrease the balance by the value of the event type Now if the balance value equals to k and before updating it was k 1 then we are in the left end of some segment from the answer If the balance equals to k 1 and before updating it was k then we are in the right end of the segment from the answer Let s simply add segment left right to the answer So now we have disjoint set of segments contains all satisfied points in order from left to right Obviously it s the answer to the problem Complexity O nlogn 
You stumbled upon a new kind of chess puzzles The chessboard you are given is not necesserily but it still is Each square has some number written on it all the numbers are from to and all the numbers are pairwise distinct The th square in the th row has a number written on it In your chess set you have only three pieces a knight a bishop and a rook At first you put one of them on the square with the number you can choose which one Then you want to reach square possibly passing through some other squares in process then square and so on until you reach square In one step you are allowed to either make a valid move with the current piece or replace it with some other piece A knight can move to a square that is two squares away horizontally and one square vertically or two squares vertically and one square horizontally A bishop moves diagonally A rook moves horizontally or vertically The move should be performed to a different square from the one a piece is currently standing on You want to minimize the number of steps of the whole traversal Among all the paths to have the same number of steps you want to choose the one with the lowest number of piece replacements What is the path you should take to satisfy all conditions ,There are a lot of different solutions for the problem Most of them have the similar structure The first part is to find the shortest distance between the states and where and are the coordinates of the square and is the current piece This can be done with 0 1 bfs Floyd or Dijkstra Just represent the triple as a single integer by transforming it to and do everything on that graph The second part is to write some dp to go from th square with piece to th square with piece The value of this is a pair moves replacements It is easy to see that you can always choose the minimum of two such pairs while updating Overall complexity may vary We believe is achievable However the particular solution I coded works in 
Ivan is a student at Berland State University BSU There are days in Berland week and each of these days Ivan might have some classes at the university There are working hours during each Berland day and each lesson at the university lasts exactly one hour If at some day Ivan s first lesson is during th hour and last lesson is during th hour then he spends hours in the university during this day If there are no lessons during some day then Ivan stays at home and therefore spends hours in the university Ivan doesn t like to spend a lot of time in the university so he has decided to skip some lessons He cannot skip more than lessons during the week After deciding which lessons he should skip and which he should attend every day Ivan will enter the university right before the start of the first lesson he does not skip and leave it after the end of the last lesson he decides to attend If Ivan skips all lessons during some day he doesn t go to the university that day at all Given and Ivan s timetable can you determine the minimum number of hours he has to spend in the university during one week if he cannot skip more than lessons ,The problem can be solved in the following dynamic programming manner Let be the smallest number of hours Ivan can spend in university in the first days while having lessons skipped To calculate it we can store minimal number of hours Ivan is required to spend in the th day so that he attends lessons Then we can iterate over all lengths from to and update with Precalc works in and dp can be processed in 
Monocarp is the coach of the Berland State University programming teams He decided to compose a problemset for a training session for his teams Monocarp has problems that none of his students have seen yet The th problem has a topic an integer from to and a difficulty an integer from to All problems are different that is there are no two tasks that have the same topic and difficulty at the same time Monocarp decided to select exactly problems from problems for the problemset The problems should satisfy of two conditions possibly both the topics of all three selected problems are different the difficulties of all three selected problems are different Your task is to determine the number of ways to select three problems for the problemset ,There are many different ways to solve this problem but in my opinion the easiest one is to count all possible triples and subtract the number of bad triples The first part is easy the number of ways to choose elements out of is just The second part is a bit tricky What does it mean that the conditions in the statements are not fulfilled There is a pair of problems with equal difficulty and there is a pair of problems with the same topic Since all problems in the input are different it means that every bad triple has the following form i e there exists a problem such that it shares the difficulty with one of the other two problems and the topic with the remaining problem of the triple This observation allows us to calculate the number of bad triples as follows we will iterate on the central problem the one that shares the topic with the second problem and the difficulty with the third problem If we pick as the central problem we need to choose the other two Counting ways to choose the other problems is easy if we precalculate the number of problems for each topic difficulty let be the number of problems with topic and be the number of problems with difficulty then if we pick the problem as the central one there are ways to choose a problem that shares the topic with it and ways to choose a problem that has the same difficulty so we have to subtract from the answer for every problem 
Vova decided to clean his room The room can be represented as the coordinate axis There are piles of trash in the room coordinate of the th pile is the integer All piles have coordinates Let s define a as the following process The goal of this process is to collect the piles in different coordinates To achieve this goal Vova can do several possibly zero moves During one move he can choose some and move from to or using his broom Note that he can t choose how many piles he will move Also there are two types of queries remove a pile of trash from the coordinate It is guaranteed that there is a pile in the coordinate at this moment add a pile of trash to the coordinate It is guaranteed that there is no pile in the coordinate at this moment Note that it is possible that there are zero piles of trash in the room at some moment Vova wants to know the number of moves he can spend if he wants to do a before any queries He also wants to know this number of moves after applying each query Queries are applied in the given order Note that the doesn t actually happen and doesn t change the state of piles It is only used to calculate the number of moves For better understanding please read the section below to see an explanation for the first example ,First let s understand that if we choose some subset of points then it does not matter to which point we move it inside the segment because the minimum number of moves will always be the same and it is equal to Okay we need to split all points into two subsets and collect all points of the first subset in some point inside it and the same with the second subset What can we notice If we sort the points it s always optimal to choose these subsets as segments I e if the maximum point of the first subset is the minimum point of the second subset is and we can swap them and decrease answers for both subsets So we need to cover all the points with two segments with the minimum total length What is this length It is is the maximum distance between two consecutive points i e So we can solve the problem in without queries But how to deal with queries Let s maintain the set which contains all points and the multiset set with repetitions that maintains all gaps between two adjacent points So the answer is maximum in the set of points minus minimum in the set of points minus maximum in the multiset of lengths How do we recalculate these sets between queries If some point is removed let s find the maximum point less than let it be and the minimum point greater than let it be in the current set of points Both these points can be found in a logarithmic time Then we need to remove with from the multiset and add to the multiset and of course remove from the set If some point is added then we need to remove from the multiset and add with to the multiset and add to the set So we can process every query in time and the total time complexity is 
You are given an undirected graph consisting of vertices and edges where is divisible by Each edge has a weight which is a positive greater than zero integer The graph has the following structure it is split into triples of vertices the first triple consisting of vertices the second triple consisting of vertices and so on Every pair of vertices from the same triple is connected by an edge There are no edges between vertices from different triples You have to paint the vertices of this graph into two colors red and blue Each vertex should have exactly one color there should be exactly red vertices and blue vertices The coloring is called valid if it meets these constraints The weight of the coloring is the sum of weights of edges connecting two vertices with different colors Let be the maximum possible weight of a valid coloring Calculate the number of valid colorings with weight and print it modulo ,Let s ignore the constraint on the number of red blue vertices for a moment What is the maximum possible weight of a coloring From any triple we can have any two edges connect vertices of different colors So the maximum possible weight of a coloring not necessarily a valid one is the sum of all edge weights except for the minimum weight in each triple Let s show that it is always possible to choose a valid coloring to achieve this weight In each triple we should make sure that the two maximum edges connect vertices with different colors to do this we can color the vertex incident to both of these edges in one color and the two other vertices will be painted in the other color So for each triple of vertices there will be either one red vertex and two blue ones or two red ones and one blue Let s suppose the first triples have one red vertex and two blue vertices each and the other triples have one blue vertex and two red vertices each That way we obtain a valid coloring with maximum possible weight Okay now let s try to find out how do we calculate the number of valid colorings with the maximum possible weight Each triple of vertices will be either red two red vertices one blue or blue the other way around Since exactly half of the vertices should be red then exactly half of the triples should be red so the number of ways to choose a color for all triples is After choosing the color of each triple let s choose how we actually color them The triples are independent so for each triple we can introduce the coefficient which is the number of ways to color it so that its weight is maximized and the triple has some specific type either red or blue doesn t matter since these are symmetric Choosing the vertex which will be different from its neighbors is equivalent to choosing the edge which will not be included in the weight of the coloring this is the edge which is not incident to the chosen vertex So is equal to the number of ways to choose that vertex in the th triple so that the weight is maximized i e the weight of the edge not incident to the chosen vertex should be minimized Thus is just the number of minimum edge weights in the th triple The formula for the final answer is 
You are given two arithmetic progressions and Find the number of integers such that and for some integers ,I wanted to give this problem a lot of time ago I thought it is very standard problem but I underestimated its difficulty Let s write down the equation describing the problem So we have linear Diofant equation with two variables The solution has the form where the last equation can be solved by extended Euclid algorithm and is any integral number The variable should satisfy two conditions and The values and are fixed so we can get the segment of possible values for the values The length of the segment is the answer for the problem 
You are given integers For each find its and such that where is the greatest common divisor of and or say that there is no such pair ,Firstly for the fast factorization of given let s use Sieve of Eratosthenes let s for each value calculate its minimum prime divisor in the same manner as the sieve do Now we can factorize each in time by separating its prime divisors one by one using precalculated array Suppose we have a factorization If then any divisor of is divisible by so do the sum of divisors Obviously the answer is Otherwise we can divide all prime divisors into two non empty groups and and take and Any division is valid proof is below so for example we can take and Let s prove that if and then Let s look at any We can assume that and without loss of generality But it means that then In other words there are no prime divisor of which divides so the Time complexity is for the sieve and finding answers 
Alice is a beginner composer and now she is ready to create another masterpiece And not even the single one but two at the same time Alice has a sheet with notes written on it She wants to take two such non empty non intersecting subsequences that both of them form a and sum of their lengths is maximal Subsequence forms a melody when each two adjacent notes either differs by or are congruent modulo You should write a program which will calculate maximum sum of lengths of such two non empty non intersecting subsequences that both of them form a melody ,Let s solve this problem with dynamic programming Let be the maximum answer if one melody finishes in note number and another melody in note number and are indexed if one of them is then the melody is empty How shall we update First of all we will update from previous values only if If then obviously answer is and if then we take the answer for Secondly to avoid intersections we will update only using values of where and Why Because if we update from some and then it can lead to some intersection we can t guarantee we didn t use in the first melody How can we make fast updates We will count from to Then while counting for some specific we will maintain two arrays the maximum value of encountered so far where the maximum value of encountered so far where So when we need to count it will be the maximum of four values if we add a note which is congruent modulo with the last one if we add a note which is less by than the last note if we add a note which is greater by than the last note if we just start a melody These values can be calculated in 
Vasya has two arrays and of lengths and respectively He can perform the following operation arbitrary number of times possibly zero he takes some consecutive subsegment of the array and replaces it with a single element equal to the sum of all elements on this subsegment For example from the array Vasya can obtain array and from array Vasya can obtain array Two arrays and are considered equal if and only if they have the same length and for each valid Vasya wants to perform some of these operations on array some on array in such a way that arrays and become equal Moreover the lengths of the resulting arrays should be maximal possible Help Vasya to determine the maximum length of the arrays that he can achieve or output that it is impossible to make arrays and equal ,Let s prove that next greedy solution works each step we will find prefixes of minimal length of arrays such that its sums are equal and we will cut them forming next block If we will get valid partition in result so it is an optimal solution otherwise there is no solution Since length of prefix proportional to its sum so prefixes are minimal since its sums are minimal Let s prove this algorithm let optimal solution have alternative partition Since our solution cuts minimal possible prefixes so at some step optimal solution cuts prefix with greater sum and greater length But this prefixes in optimal solutions contain smaller prefixes found by greedy solution so it can be divided on two parts contradiction So we can keep prefixes and increase one which have smaller sum Result complexity is 
Now Vasya is taking an exam in mathematics In order to get a good mark Vasya needs to guess the matrix that the teacher has constructed Vasya knows that the matrix consists of rows and columns For each row he knows the xor bitwise excluding or of the elements in this row The sequence denotes the xor of elements in rows with indices respectively Similarly for each column he knows the xor of the elements in this column The sequence denotes the xor of elements in columns with indices respectively Help Vasya Find a matrix satisfying the given constraints or tell him that there is no suitable matrix ,If then there is no suitable matrix The operation means xor Otherwise we can always construct a suitable matrix by the following method the first element of the first line will be equal to The second element of the first line is the third element is the last one is The first element of the second line will be the first element of the third line is the first element of the last line is The rest of the elements will be zero It is not difficult to verify that the matrix obtained satisfies all the restrictions 
You are given a pair of integers and an integer You can change the pair in two different ways set assign set assign where is the absolute difference between and The pair is called magic if is obtainable either as or as using only the given operations i e the pair is magic if or after some number of operations applied You can apply the operations any number of times even zero Your task is to find out if the pair is magic or not You have to answer independent test cases ,This problem has a GCD based solution Firstly lets try to solve it naively Always suppose that If this is not true let s swap and Firstly if let s do Okay now let s subtract from until again and repeat this algorithm till or If after some step we get or we are done and the answer is If or and we didn t get then the answer is Okay we can see that we always subtract the minimum possible from and trying to maintain this condition It can be proven that this algorithm yields all possible integers that are obtainable by any sequence of the operations from the problem statement either in or in Now we have to speed up this solution somehow Obviously most operations are redundant for us in this particular problem The first thing is that we can skip all operations till becomes greater than The number of such operations is And the second thing is that we can skip all operations till we get in The number of such operations is For simplicity this part can be also written as This doesn t affect the time complexity much but the formula for the final number of operations we can skip will be simpler This number equals in fact we take the minimum between two values written above because we don t want to skip any of these two cases So we can transform the pair to the pair and continue this algorithm There are also simpler approaches using the same idea but in a cooler way Time complexity per test case 
You are given an array of size and queries to it There are queries of two types perform a cyclic shift of the segment to the right That is for every such that new value of becomes equal to old value of and new value of becomes equal to old value of reverse the segment There are important indices in the array For each such that you have to output the number that will have index in the array after all queries are performed ,One can guess from the constraits that complexity of the algorithm should be either or And there is a solution with the second one Let s try to solve the reversed problem answer what position will some number be at after all the queries Check the impact of some query on position Let the query be on some segment If is outside this segment then you can skip it Otherwise reverse will swap and shift will swap and if then it will be instead of This task can be translated to the given one just by reversing the query list Overall complexity Obviously you can also solve it with Cartesian tree online in 
You play a computer game In this game you lead a party of heroes and you have to clear a dungeon with monsters Each monster is characterized by its power Each hero is characterized by his power and endurance The heroes clear the dungeon day by day In the beginning of each day you choose a hero exactly one who is going to enter the dungeon this day When the hero enters the dungeon he is challenged by the first monster which was not defeated during the previous days so if the heroes have already defeated monsters the hero fights with the monster When the hero fights the monster there are two possible outcomes if the monster s power is strictly greater than the hero s power the hero retreats from the dungeon The current day ends otherwise the monster is defeated After defeating a monster the hero either continues fighting with the next monster or leaves the dungeon He leaves the dungeon either if he has already defeated the number of monsters equal to his endurance during this day so the th hero cannot defeat more than monsters during each day or if all monsters are defeated otherwise he fights with the next monster When the hero leaves the dungeon the current day ends Your goal is to defeat the last monster What is the minimum number of days that you need to achieve your goal Each day you have to use exactly one hero it is possible that some heroes don t fight the monsters at all Each hero can be used arbitrary number of times ,At first lets precalc array is equal to maximum hero power whose endurance is greater than or equal to Now let s notice that every day it s profitable for as to kill as many monster as possible Remains to understand how to calculate it Suppose that we already killed monsters If then answer is because we can t kill the th monster Otherwise we can kill at least monsters All we have to do it increase the value until conditions holds After calculating the value we just move to the next day with killed monsters 
The sequence of integers is called a good array if and For example the sequences are good arrays and the sequences are not A sequence of integers is called good if it can be divided into a positive number of good arrays Each good array should be a subsegment of sequence and each element of the sequence should belong to exactly one array For example the sequences are good and the sequences are not For a given sequence of numbers count the number of its that are good sequences and print the number of such subsequences modulo ,The problem is solved by the dynamic programming Let be the answer for the prefix of the array starting at it contains the indices If then Otherwise let s go over the position with which the next good array begins Then we need to select positions among positions which will be elements of the array The number of ways to choose an unordered set of items from of different objects is calculated using the formula Thus the dynamics is as follows The basis of dynamics is the value 
You are given an array and two integers and You can choose some subarray The cost of subarray is equal to where is the least integer greater than or equal to For example if and then the cost of some subarrays are Your task is to find the maximum cost of some subarray possibly empty of array ,At first let s solve this problem when m 1 and k 0 it is the problem of finding subarray with maximum sum For each position from 1 to n we want to know the value of maxl i max limits 1 le j le i 1 sum j i where sum l r sum limits k l k le r a k and sum x 1 x 0 We will calculate it the following way maxl i will be the maximum of two values 0 because we can take segments of length 0 a i maxl i 1 The maximum sum of some subarray is equal to max limits 1 le i le n maxl i So now we can calculate the values of best i max limits 0 le len i len cdot m ge 0 sum i len cdot m 1 i len k the same way best i is the maximum of two values 0 sum i m 1 i k best i m After calculating all values best i we can easily solve this problem At first let s iterate over the elements best i When we fix some element best i lets iterate over the value len 1 2 dots m and update the answer with value best i sum i len i 1 k 
Alice and Bob are playing yet another card game This time the rules are the following There are cards lying in a row in front of them The th card has value First Alice chooses a non empty consecutive segment of cards After that Bob removes a single card from that segment The score of the game is the total value of the remaining cards on the segment In particular if Alice chooses a segment with just one element then the score after Bob removes the only card is Alice wants to make the score as big as possible Bob takes such a card that the score is as small as possible What segment should Alice choose so that the score is maximum possible Output the maximum score ,Alice wants to choose such a segment that is maximum possible There is a well known problem where you have to find a segment with maximum That problem is solved with Kadane algorithm Let s learn how to reduce our problem to that one Notice that the values in the array are unusually small Let s iterate over the maximum value on segment Let be the current value If we make all such that equal to then it will never be optimal to take them in a segment Find the maximum sum subarray in that modified array and update the answer with its Notice that you can ignore the fact if there is a value exactly equal to on the maximum sum segment If there isn t then you ll update the answer with a smaller value than the actual one Let the actual maximum on the maximum sum segment be some You can see that for any value between and the maximum sum segment will always be that chosen one Thus when you reach you ll update the answer with the correct value Overall complexity 
You are given an array Calculate the number of tuples such that and ,We can rethink this as counting the number of equal pairs where To do this we loop over from right to left and make sure we have all pairs where counted in a map Then we simply iterate over and add up the number of occurrences of each in the map For implementation details note that we don t actually want to use a map and make our code slower We can just use an array of size and convert the pair to the number since the are in the range As a bonus even if the were larger than we could just compress them down to and repeat the solution above Code 91019003 
Let s call two strings and both of length if they have the same character in some position i e there exists at least one such that You are given a binary string of length a string of characters and or and an integer Let s denote the string as the substring of starting from the th character and ending with the th character that is Let s call a binary string of length if it is to all substrings of having length exactly that is it is to Your goal is to find the smallest string that is or report that no such string exists String is lexicographically less than string if either is a prefix of and or there exists such that and for any ,Let s denote as the number of substrings of having length exactly so The first and crucial observation is that if then the answer always exists Each of substrings forbids one of the strings from being the answer a string is forbidden if every each character differs from the corresponding character in one of the substrings we can forbid at most strings from being the answer and the number of possible candidates for the answer is This observation leads us to a more strong fact that actually allows us to find a solution we can set the first characters in the answer to all the remaining characters are enough to find the answer There are at most possible combinations of the last characters and this number is not greater than Let s iterate on each substring of of length and check which combination it forbids by inverting the last characters of the substring After that find the minimum unforbidden combination Note that there may be a case when a substring doesn t actually forbid any combination if there are zeroes in the first characters of the substring it is to the answer no matter which combination we choose This can be checked by precalculating the closest position of zero to the left right of each index The whole solution works in per test case the hardest part is inverting the suffix of each substring we are interested in 
You are given a directed graph consisting of vertices Each directed edge or arc labeled with a single character Initially the graph is empty You should process queries with it Each query is one of three types add arc from to with label It s guaranteed that there is no arc in the graph at this moment erase arc from to It s guaranteed that the graph contains arc at this moment find the sequence of vertices such that there exist both routes and and if you write down characters along both routes you ll get the same string You can visit the same vertices any number of times ,At first if there should be both routes and then there are both arcs and i e there should exist at least one pair that both arcs and are present in the graph Now if is odd and we have at least one pair then we can simply create sequence This sequence is a palindrome so obviously both routes generate the same string If is even or we can note that in the sequence there is a middle arc and it should have the same character as arc since it s a middle arc in reverse route i e there should exist at least one pair that both arcs and are present in the graph and have the same label Now if we have at least one such pair then routes and generate the same one letter strings Since each arc is a part of at most one pair we can just maintain two sets with pairs one for pairs with different labels and the other one for pairs with equal labels If is odd we check that at least one of the sets is not empty If is even we check that the second set is not empty 
 New gamemode Huh is that it Slightly disappointed you boot up the game and click on the new gamemode It says There are platforms numbered from to placed one after another There are colors available in the game numbered from to The th platform is colored You start on the platform and want to reach platform In one move you can jump from some platform to platforms or All platforms are initially deactivated including platforms and For each color you can pay coins to activate all platforms of that color You want to activate some platforms so that you could start on an activated platform jump through some activated platforms and reach an activated platform What s the smallest amount of coins you can spend to achieve that ,Imagine we bought some subset of colors How to check if there exists a path from 1 to n Well we could write an easy dp However it s not immediately obvious where to proceed from that You can t really implement buying colors inside the dp because you should somehow know if you bought the current color before and that s not really viable without storing a lot of information Let s find another approach Let s try to deduce when the subset is bad the path doesn t exist Trivial cases c 1 or c n aren t bought Now if there are two consecutive platforms such that their colors aren t bought the path doesn t exist Otherwise if there are no such platforms you can show that the path always exists In particular that implies that among all pairs of consecutive platforms at least one color of the pair have to be bought If the colors of the pair are the same then it s just that this color have to be bought The next step is probably hard to get without prior experience Notice how the condition is similar to a well known graph problem called vertex cover That problem is about finding a set of vertices in an undirected graph such that all graph edges have at least one of their endpoints in the set In particular our problem would be to find a vertex cover of minimum cost That problem is known to be NP hard thus the constraints We can t solve it in polynomial time but we ll attempt to it faster than the naive approach in O 2 m cdot m 2 Let s start with this approach anyway We can iterate over a mask of taken vertices and check if that mask is ok In order to do that we iterate over edges and check if at least vertex is taken for each of them Again having a bit of prior experience one could tell from the constraints that the intended solution involves meet in the middle technique Let s iterate over the mask of taken vertices among vertices from 1 to frac m 2 Then over the mask of taken vertices from frac m 2 1 to m The conditions on edges split them into three groups the edges that are completely in mathit mask 1 the edges that are completely in mathit mask 2 and the edges that have one endpoint in mathit mask 1 and another endpoint in mathit mask 2 First two types are easy to check but how to force the third type to be all good Consider the vertices that are not taken into mathit mask 1 All edges that have them as one of the endpoints will turn out bad if we don t take their other endpoints into mathit mask 2 That gives us a minimal set of constraints for each mathit mask 1 a mask mathit con that includes all vertices from the second half that have edges to at least one of non taken vertex in mathit mask 1 Then mathit mask 2 is good if it has mathit con as its submask Thus we would want to update the answer with the mathit mask 1 of the minimum cost such that its mathit con is a submask of mathit mask 2 Finally let mathit dp mathit mask store the minimum cost of some mathit mask 1 such that its mathit con is a submask of mathit mask Initialize the mathit dp with the exact mathit con for each mathit mask 1 Then push the values of mathit dp up by adding any new non taken bit to each mask When iterating over mathit mask 2 check if it s good for edges of the second kind and update the answer with mathit dp mathit mask 2 Overall complexity O 2 m 2 cdot m 2 
The rules of Sith Tournament are well known to everyone Sith take part in the Tournament The Tournament starts with the random choice of two Sith who will fight in the first battle As one of them loses his place is taken by the next randomly chosen Sith who didn t fight before Does it need to be said that each battle in the Sith Tournament ends with a death of one of opponents The Tournament ends when the only Sith remains alive Jedi Ivan accidentally appeared in the list of the participants in the Sith Tournament However his skills in the Light Side of the Force are so strong so he can influence the choice of participants either who start the Tournament or who take the loser s place after each battle Of course he won t miss his chance to take advantage of it Help him to calculate the probability of his victory ,Let s solve the problem using dynamic programming the maximal probability of Ivans victory if the siths from the already fought and the th sith left alive To calculate that DP we should iterate over the next sith he will fight against the th sith 
Tree is a connected graph without cycles A leaf of a tree is any vertex connected with exactly one other vertex You are given a tree with vertices and a root in the vertex There is an ant in each leaf of the tree In one second some ants can simultaneously go to the parent vertex from the vertex they were in No two ants can be in the same vertex simultaneously except for the root of the tree Find the minimal time required for all ants to be in the root of the tree Note that at start the ants are only in the leaves of the tree ,Easy to see that the answer is equal to the answer over all sons of the root plus one Now let s solve the problem independently for each son of the root Let be the array of the depths of all leaves in the subtree of the vertex Let s sort Statement 1 it s profitable to lift the leaves in order of their appearing in Statement 2 denote the time of appearing the th leaf in the vertex let s consider the leaves and then Statement 3 where is the depth of the th leaf in the subtree of the vertex The last statement gives us the solution for the problem we should simply iterate over from left to right and recalculate the array by formula from the third statement All statements can be easily proved and it s recommended to do by yourself to understand better the idea of the solution 
There are heroes fighting in the arena Initially the th hero has health points The fight in the arena takes place in several rounds At the beginning of each round each alive hero deals damage to all other heroes Hits of all heroes occur simultaneously Heroes whose health is less than at the end of the round are considered killed If exactly hero remains alive after a certain round then he is declared the winner Otherwise there is no winner Your task is to calculate the number of ways to choose the initial health points for each hero where so that there is no winner of the fight The number of ways can be very large so print it modulo Two ways are considered different if at least one hero has a different amount of health For example and are different ,Let s calculate the following dynamic programming the number of ways to choose the initial health if there are heroes still alive and they already received damage Let s iterate over the number of heroes that will survive after the next round Then we have to make a transition to the state where the minimum of the maximum allowed health and plus the damage done in this round It remains to understand with what coefficient we should make this transition in dynamic programming This coefficient is equal to the number of ways to choose which of the living heroes will die in this round multiplied by the number of ways to choose health for these heroes because their health is greater than so that they are still alive at the moment but not more than so that they are guaranteed to die in this round Of course we don t make any transitions from the states where since they represent the fights that have already finished The answer is the sum of all for every 
As you might remember from our previous rounds Vova really likes computer games Now he is playing a strategy game known as Rage of Empires In the game Vova can hire different warriors th warrior has the type Vova wants to create a army hiring some subset of warriors An army is called if for each type of warrior present in the game there are not more than warriors of this type in the army Of course Vova wants his army to be as large as possible To make things more complicated Vova has to consider different plans of creating his army th plan allows him to hire only warriors whose numbers are not less than and not greater than Help Vova to determine the largest size of a army for each plan ,Every time we process a plan let s count only the first warriors of some type When will the warrior on position be counted Of course he has to be present in the plan so But also he has to be among first warriors of his type in this plan Let s denote a function is the position of previous warrior of the same type before warrior that is the greatest such that and If there s no any then if It is easy to prove that the warrior will be among first warriors in some plan iff and So we can make a new array Then we build a segment tree on this array The node of the segment tree will store all values of from the segment corresponding to this node in sorted order Then to get answer to the plan we have to count the number of elements on segment that are less than Complexity is or if you use fractional cascading technique 
 is an array of positive integers all of which are not greater than You have to process queries to this array Each query is represented by two numbers and Several operations are performed in each query each operation changes to There operations are applied until becomes greater than The answer to the query is the number of performed operations ,There are two possible solutions in time First of them answers each query using simple iteration changes to for each query until becomes greater than as stated in the problem But it is too slow Second solution precalculates answers for each and if then else But this uses memory and can be done in time Now we can notice that if then second solution will use only time and memory and if then first solution will do not more than operations on each query So we can combine these two solutions Time complexity 
You are given an array You can perform the following operation any number of times Choose a pair of two neighboring equal elements if there is at least one such pair Replace them by one element with value After each such operation the length of the array will decrease by one and elements are renumerated accordingly What is the minimum possible length of the array you can get ,Let s look at the answer by construction each element in the final answer was the result of replace series of elements on the corresponding segment So all we need to find is the minimal by size partition of the array on segments where each segment can be transformed in one element by series of replaces We can calculate it using standard prefix dynamic programming or is the size of such minimal partition of a prefix of length The transitions are standard let s check all segments and if it can be replaced by one element let s relax Now we need to check for all segments of can it be replaced by one element Let s calculate another using the following fact if there is a way to replace all segment as one element so the segment either has the length or it can be divided into two parts where the prefix can be replaced by one element the suffix also can be replaced by one element and these elements are equal It s exactly the transitions we need to check to calculate The resulting complexity is 
Monocarp is playing a game Assimilation IV In this game he manages a great empire builds cities and conquers new lands Monocarp s empire has cities In order to conquer new lands he plans to build The game is turn based and since Monocarp is still amateur he builds exactly one Monument per turn Monocarp has points on the map he d like to control using the constructed Monuments For each point he knows the distance between it and each city Monuments work in the following way when built in some city a Monument controls all points at distance at most to this city Next turn the Monument controls all points at distance at most the turn after at distance at most and so on Monocarp will build Monuments in turns and his empire will conquer all points that are controlled by at least one Monument Monocarp can t figure out any strategy so during each turn he will choose a city for a Monument randomly among all remaining cities cities without Monuments Monocarp wants to know how many points among of them he will conquer at the end of turn number Help him to calculate the expected number of conquered points ,Let be the indicator function equal to if the th point is controlled by any city and otherwise Then the expected number of controlled points can be written as by linearity of expected value The expected value of the indicator function is equal to the probability of this function equal to In other words for each point we need to calculate the probability of this point being controlled by any city Let s instead calculate the probability of point not being controlled by any city Suppose the distance between point and some city is equal to If we build a Monument in city at step zero indexed then the point will be controlled by city But building the Monument at any step greater or equal than is fine Let s for each turn calculate the number of cities that you can build Monument in starting this turn as Our task is to calculate the number of permutations that are consistent with array At first turn we can choose one of cities at second turn we have choices at third step choices and so on Using this idea it s not hard to calculate the number of good permutations and then the initial probablity The expected value 
Alexey recently held a programming contest for students from Berland students participated in a contest th of them solved problems Now he wants to award some contestants Alexey can award the students with diplomas of three different degrees Each student either will receive one diploma of some degree or won t receive any diplomas at all Let be the number of students that are awarded with diplomas of degree The following conditions must hold For each For any two degrees and Of course there are a lot of ways to distribute the diplomas Let be the degree of diploma th student will receive or if th student won t receive any diplomas Also for any such that let be the maximum number of problems solved by a student that receives a diploma of degree and be the minimum number of problems solved by a student that receives a diploma of degree Alexey wants to distribute the diplomas in such a way that If student solved more problems than student then he has to be awarded not worse than student it s impossible that student receives a diploma and doesn t receive any and also it s impossible that both of them receive a diploma but is maximum possible Among all ways that maximize the previous expression is maximum possible Among all ways that correspond to the two previous conditions is maximum possible where is the maximum number of problems solved by a student that doesn t receive any diploma or if each student is awarded with some diploma Help Alexey to find a way to award the contestants ,Let s consider naive solution make three loops to fix amounts of people to get dimplomas of each degree take the best Obviously sorting the scores will regroup optimal blocks for each degree in such a way that they come in segments of initial array We tried to make these solutions fail but underestimated the abilities of contestants to optimize this kind of stuff and couple of such made it to the end of contest To be honest we just need to get rid of the last loop Let be the difference between and is sorted Then let be the position of the last diploma of second degree and be the amounts of diplomas of the first ans the second degrees Thus the best position to put the separator between the third degree and no diploma is the postion with the maximum number in array over segment This are the borders of possible amount of the dimplomas of the third degree Maximum over segment can be implemented with segment tree sparse table or even naive square matrix with precalc time and memory Overall complexity 
One day ZS the Coder wrote down an array of integers with elements A subarray of the array is a sequence for some integers such that ZS the Coder thinks that a subarray of is beautiful if the bitwise xor of all the elements in the subarray is at least Help ZS the Coder find the number of beautiful subarrays of ,The sign is used for the binary operation for bitwise exclusive or Let be the xor of the first elements on the prefix of Then the interval is beautiful if Let s iterate over from to and consider the values as the binary strings On each iteration we should increase the answer by the value the number of numbers so To do that we can use the trie data structure Let s store in the trie all the values for Besides the structure of the trie we should also store in each vertex the number of leaves in the subtree of that vertex it can be easily done during adding of each binary string To calculate the value let s go down by the trie from the root Let s accumulate the value equals to the xor of the prefix of the value with the already passed in the trie path Let the current bit in be equal to and be the depth of the current vertex in the trie If the number then we can increase by the number of leaves in vertex because all the leaves in the subtree of tha vertex correspond to the values that for sure gives After that we should go down in the subtree Otherwise if then we should simply go down to the subtree and recalculate the value 
You are given a matrix of size Each element of the matrix is either 1 or 0 You have to determine the number of connected components consisting of 1 s Two cells belong to the same component if they have a common border and both elements in these cells are 1 s ,The main idea is to read and process each row of the matrix separately To do this we will use DSU data structure The answer will be equal to the difference between the number of 1 s and the number of operations in DSU When processing the row we will keep the DSU for the previous row When processing a certain index in the row we will try to merge it with the element to the left of it and with the element to the top that s all we have to check here You also have to handle the fact that we cannot store the whole DSU since the number of components can be up to and it s impossible to store all required information for them So each time we process a row we have to renumerate all components in this row to ensure that every time we are operating with indices of components not greater than 
You are given a tree consisting of vertices Some of the vertices at least two are black all the other vertices are white You place a chip on one of the vertices of the tree and then perform the following operations let the current vertex where the chip is located is You choose a black vertex and then move the chip along the first edge on the simple path from to You are not allowed to choose the same black vertex in two operations in a row i e for every two consecutive operations the chosen black vertex should be different You end your operations when the chip moves to the black vertex if it is initially placed in a black vertex you don t perform the operations at all or when the number of performed operations exceeds For every vertex you have to determine if there exists a possibly empty sequence of operations that moves the chip to some black vertex if the chip is initially placed on the vertex ,I think there are some ways to solve this problem with casework but let s try to come up with an intuitive and easy to implement approach It s always possible to move closer to some black vertex no matter in which vertex you are currently and which black vertex was used in the previous operation However sometimes if you try to move along an edge you immediately get forced back Let s analyze when we can move without being forced back We can move along the edge so that our next action is not moving back if either is black there is no next action or if we remove the edge between and the number of black vertices in s component is at least we can use one of them to go from to and another one to continue our path Note that the cases and may be different sometimes it will be possible to move in one direction and impossible to move in the opposite direction Let s treat this possible move as an arc in a directed graph We can find all such arcs if we can answer the queries of the type count black vertices in a subtree of some vertex and this can be done by rooting the tree and calculating this information for each subtree with DFS Now if there is a way from some vertex to some black vertex along these arcs the answer for the vertex is How can we find all such vertices Let s transpose the graph change the direction of each arc to opposite now we need to find all vertices reachable from black ones which is easily done with multisource BFS or DFS The complexity of this solution is 
You are given segments on a number line numbered from to The th segments covers all integer points from to and has a value You are asked to select a subset of these segments possibly all of them Once the subset is selected it s possible to travel between two integer points if there exists a selected segment that covers both of them A subset is good if it s possible to reach point starting from point in arbitrary number of moves The cost of the subset is the difference between the maximum and the minimum values of segments in it Find the minimum cost of a good subset In every test there exists at least one good subset ,Take a look at the condition for a good subset The major implication it makes is that every point even non integer of the segment 1 m should be covered by at least one segment If some point isn t then there is no way to jump across the gap it produces At the same time this condition is enough to have a path since for every half integer point 0 5 1 5 and so on there exists a segment that covers it So you can take that segment to go from 1 to 2 then from 2 to 3 and so on Thus we are asked to select a subset of segments that covers the entire segment 1 m in its union The main prerequisite to the following solution is knowing the way to maintain the union of segments For now I can tell you that there is a data structure that allows you to add a segment remove a segment and query the length of the current union Let s continue with making some observations on the cost function If you fix the minimum and the maximum value you are free to select all segments that have their value in between That allows us to transition from selecting a subset of segment to an interval if you sort the segments by their weight If you fix only minimum then the required maximum should be as small as possible However if some value suffices as a maximum then any value greater than it also suffices since it only adds extra segments to the subset This makes the function on the maximum monotonous So the binary search applicable You could iterate over the minimum and binary search the maximum However it s not too clear how to make a check function You would need to find a union of some interval of segments quickly I don t really know a way to do that so let s try something different Instead let s forget about binary search and try to reach a two pointers solution Let f x be the smallest possible maximum given the fixed minimum is x We want f x 1 to be greater than or equal than f x for two pointers to be applicable That condition indeed holds Imagine if f x 1 is smaller than f x So there exists some optimal subset for x 1 Add all segments with weight x to that subset That brings the minimum to x However it doesn t change the maximum so f x is at least equal to f x 1 what contradicts the assumption Finally the solution comes up to the following Iterate over the minimum value x while maintaining f x When going from x to x 1 keep increasing the value of f until the union of the segments is exactly m Going from x to x 1 and increasing the value of f is actually removing some segments and adding some segments to the data structure The data structure that helps us with that is a segment tree The i th leaf of the tree holds the number of segments that cover the interval i i 1 Add remove segment makes it add subtract on a range The union is full if the there are no intervals that are covered by zero segments Thus let s store the minimum of the subtree in every intermediate node If the minimum on the tree is above zero then the current subset is good Instead of applying two pointers on the values of the segments let s apply them on the sorted segments themselves That makes moving the pointer exactly one update to the segtree Overall complexity O n log n n log m 
Monocarp is playing Minecraft and wants to build a wall of cacti He wants to build it on a field of sand of the size of cells Initially there are cacti in some cells of the field Monocarp can plant new cacti they must also fulfil the aforementioned condition He can t chop down any of the cacti that are already growing on the field he doesn t have an axe and the cacti are too prickly for his hands Monocarp believes that the wall is complete if there is no path from the top row of the field to the bottom row such that each two consecutive cells in the path are adjacent by side no cell belonging to the path contains a cactus Your task is to plant the minimum number of cacti to build a wall or to report that this is impossible ,In order to block any path from the top row to the bottom row you have to build a path from the left side to the right side consisting of Since two consecutive cacti in a path cannot be placed side by side they should be placed diagonally i e should be followed by on the path So we can rephrase the task as a shortest path problem The edge weight is if cactus is already in the cell that corresponds to the end of the edge and otherwise Don t forget that some cells can t contain a cactus thus be part of a path because of the cacti initially placed The shortest path can be found using Dijkstra s or 0 1 BFS algorithm 
Berland year consists of months with days each Months are numbered from to Berland week consists of days The first day of the year is also the first day of the week Note that the last week of the year might be shorter than days A pair such that is ambiguous if day of month is the same day of the week as day of month Count the number of ambiguous pairs ,Let the month the days in them and the days of the week be numbered based Translate the th day of the th month to the index of that day in a year that would be Thus the corresponding day of the week is So we can rewrite the condition for a pair as That s also Continue with So should be divisible by is fixed and some prime divisors of might have appeared in it already If we remove them from then should just be divisible by the resulting number So we can divide by and obtain that Now we should just count the number of pairs such that is divisible by We know that the difference should be from to So we can fix the difference and add the number of pairs for that difference That would be for a difference Finally the answer is Use the formula for the sum of arithmetic progression to solve that in Overall complexity per testcase 
Vova again tries to play some computer card game The rules of deck creation in this game are simple Vova is given an existing deck of cards and a magic number The order of the cards in the deck is fixed Each card has a number written on it number is written on the th card in the deck After receiving the deck and the magic number Vova removes possibly cards from the top of the deck possibly cards from the bottom of the deck and the rest of the deck is his new deck Vova has to leave at least one card in the deck after removing cards So Vova s new deck actually contains cards from the original deck Vova s new deck is considered iff the product of all numbers written on the cards in his new deck is divisible by So Vova received a deck possibly not a one and a number and now he wonders how many ways are there to choose and so the deck he will get after removing cards from the top and cards from the bottom is ,Let s use two pointers Firstly you need to learn to factorize any number in no more than We don t actually need any of their prime divisors except for those that are presented in So let s factorize in After that check for the maximum power of each useful prime will work in for each number Now notice that if some segment has its product divisible by then all segments for will also have products divisible by Now we have to find the smallest for each out there That s where two pointers kick in Let s maintain the current product of the segment in factorized form only useful primes as in normal form its enormous The power of some prime in this form is the sum of powers of this prime in all the numbers in the segment We firstly move the left border of the segment one step to the right and then keep moving the right border to the right until power of at least one prime number in the product is smaller than in It means that it is not divisible by Moving the left border means subtracting all the powers of useful primes of number from the product and moving the right border is adding all the powers of useful primes of The first time we reach such a segment we add to answer consider indexed Overall complexity where is up to 
You are given an undirected graph consisting of vertices and edges The th edge has weight it connects the vertices and Initially each vertex contains a chip Each chip has an integer written on it the integer written on the chip in the th vertex is In one operation you can choose a chip if there are multiple chips in a single vertex you may choose any one of them and move it along one of the edges of the graph The cost of this operation is equal to the weight of the edge The of the graph is the minimum cost of a sequence of such operations that meets the following condition after all operations are performed each vertex contains exactly one chip and the integer on each chip is to the index of the vertex where that chip is located You are given queries of the form change the weight of the th edge the one which connects the vertices and to After each query print the of the graph Note that you don t actually move any chips when you compute the cost the chips are on their initial positions ,Let s try to analyze how many times we traverse each edge in the style of Contribution to the Sum technique For each edge the number of times it is traversed must be even since for every chip that goes from the part of the graph 1 i to the part i 1 n there should be a chip that goes in the opposite direction the number of chips on vertices 1 n should be unchanged For each vertex at least one incident edge should be traversed at least twice otherwise the chip from this vertex cannot be moved to any other vertex We would also like to traverse the edges as rarely as possible Is it possible to find an answer where if we traverse any edge we traverse it only twice It turns out it is possible Let s split the graph into several parts by removing the edges we don t traverse If we don t break the constraint that each vertex has at least one incident edge which is traversed by some chip then each part of the graph will contain at least two vertices And in each part we can make sure that each edge is traversed only twice as follows let the part represent the segment l r of vertices if we move the chip r to the vertex l the chip l to the vertex l 1 the chip l 1 to the vertex l 2 the chip r 1 to the vertex r then every edge in that part will be traversed exactly twice So we have shown that if we pick a subset of edges which we traverse that meets the constraint on each vertex having an incident traversed edge then it is enough to traverse each chosen edge only twice Now the problem becomes the following choose a subset of edges in such a way that every vertex has at least one incident chosen edge minimize the total weight of this subset and print the integer which is double that total weight Since the structure of the graph is specific we can run dynamic programming of the form dp i f the minimum total weight of the subset if we considered the first i edges and f is 0 if we haven t taken the last edge or 1 if we have Obviously this dynamic programming works in O n which is too slow because we have to process queries We will employ a classical technique of storing the dynamic programming in segment tree build a segment tree on n 1 leaves in every vertex of the segment tree we store a 2 times 2 matrix d if the segment represented by the node of the segment tree is l r then the value of d f 1 f 2 is the minimum total weight of the subset of edges between l and r such that among every pair of adjacent edges at least one is chosen f 1 and f 2 represent the status of the first last edge on the segment respectively And when some element changes we need to recalculate only O log n nodes of the segment tree so this solution works in O n log n q log n albeit with a very big constant factor Implementation note don t use dynamic size arrays like in C to store the values in the matrices it might slow your solution very seriously Instead use static size arrays 
You are given two strings and both consist only of lowercase Latin letters Let be the length of string Let s call a sequence a merging sequence if it consists of exactly zeros and exactly ones in some order A merge is produced from a sequence by the following rules if then remove a letter from the beginning of and append it to the end of if then remove a letter from the beginning of and append it to the end of Two merging sequences and are different if there is some position such that Let s call a string if for all from to Let for some be a substring of consecutive letters of starting from position and ending at position inclusive Let be the number of different merging sequences of and that produce merges Note that only non empty substrings of and are considered Calculate Output the answer modulo ,First let s try to calculate the number of merging sequences just for some fixed pair of strings and Imagine we build a merge letter by letter So far letters are in the merge already For the th letter we can pick a letter from either string or string put a or a into the merging sequence respectively What constraints our choice Easy to see that it s only the th letter of the merge So we can come up with the following dynamic programming is the number of merging sequences such that characters from are taken characters from are taken and the last character of the merge is can be either just a letter a dimension of size or an indicator of a string the last character was taken from for string and from string Since we know how many characters are taken from each string we can easily decide the last taken character from that indicator For each transition we can just take a character from either of the strings The sum of over all will be the total number of merging sequences Now for the substrings Recall the following definition of a substring is a substring of if you can remove some characters from the beginning of possibly none or all and some characters from the end of possibly none or all to get the string What if we incorporated that definition into our dynamic programming Let be the number of merging sequences that end exactly before the th character of exactly before the th character of and the last character is still How to remove some characters from the beginning That actually is the same as attempting to start the merge from every state of dp So if we are currently in some state then we can act as if we have just taken the th character of or the th character of as the first character of the merge How to remove some characters from the end Since is the number of merging sequences that end exactly there why not just sum up all the values of dynamic programming into the answer We will count the sequences that end in all possible positions of both strings That is almost the answer to the task The only issue we have is that we forgot the condition that asks us to get a non empty substring from each string Well there are multiple ways to resolve the issue We can remove bad sequences afterwards their count is the number of chaotic substrings of multiplied by all possible empty substrings of there are of them plus the same thing for and These can be counted with two pointers Alternatively we can add an extra dimension or two to the dp to indicate if we have ever taken a character from and from So we get with and being binary flags that tell if a character from and from was ever taken That way we can only push the states with both flags set to true to the answer Overall complexity 
Ivan wants to have a good dinner A good dinner should consist of a first course a second course a drink and a dessert There are different types of first courses Ivan can buy the th of them costs coins different types of second courses the th of them costs coins different types of drinks the th of them costs coins and different types of desserts the th of them costs coins Some dishes don t go well with each other There are pairs of first courses and second courses that don t go well with each other pairs of second courses and drinks and pairs of drinks and desserts that don t go well with each other Ivan wants to buy exactly one first course one second course one drink and one dessert so that they go well with each other and the total cost of the dinner is the minimum possible Help him to find the cheapest dinner option ,The main solution is dynamic programming let for every possible dish be the minimum cost to assemble a prefix of a dinner ending with the dish here can be a dish of any type first course second course drink or dessert Then the answer to the problem is the minimum value among all desserts The number of transitions in this dynamic programming is too big since for example when transitioning from first courses to second courses we need to check options To speed this up we need some sort of data structure built over the values of for all first courses that allows to recalculate for a second course quickly There are two main approaches to this build any version of RMQ over the values of dynamic programming for the first courses Then when we want to calculate the answer for some second course sort all types of first courses which don t go well with it and make several RMQ queries to find the minimum value over all non forbidden first courses store all values of in a data structure that supports adding an element deleting an element and finding the minimum element this DS should allow duplicate elements as well When we want to calculate the answer for some second course remove all values of corresponding to the first courses that don t go well with it from the data structure query the minimum in it and insert the removed elements back The same approach can be used to advance from second courses to drinks and from drinks to desserts you can even use the same code in a for loop with iterations so the resulting solution is actually short and simple 
Igor is a post graduate student of chemistry faculty in Berland State University BerSU He needs to conduct a complicated experiment to write his thesis but laboratory of BerSU doesn t contain all the materials required for this experiment Fortunately chemical laws allow material transformations yes chemistry in Berland differs from ours But the rules of transformation are a bit strange Berland chemists are aware of materials numbered in the order they were discovered Each material can be transformed into some other material or vice versa Formally for each there exist two numbers and that denote a possible transformation kilograms of material can be transformed into kilogram of material and kilogram of material can be transformed into kilogram of material Chemical processing equipment in BerSU allows only such transformation that the amount of resulting material is For each Igor knows that the experiment requires kilograms of material and the laboratory contains kilograms of this material Is it possible to conduct an experiment after transforming some materials or none ,Since then the transformation graph is a tree Let s solve the problem recursively Suppose that material is a leaf in the tree there is no such that Then if we don t have enough material we have to transform some of material into Let s transform the amount required to set current amount of material to if we don t have the required amount of material then this amount will temporarily be negative And if we have more material than we need to conduct the experiment then we will transform it to The same algorithm can be applied to any non root node but we first need to do this for all its children This algorithm is optimal because each time we take the minimum possible amount from the parent After this the root will be the only node such that is not necessarily equal to current amount of material Since we solved the problem for all other materials and did it optimally now the answer is YES iff current amount of material is not less than This must be implemented carefully Since the total amount of materials never increases then if some material s current amount is less than for example then the answer is already NO Also overflows in multiplication must be avoided to do this we can firstly check if the result of multiplication is not too big by multiplying values as real numbers 
As you might remember from the previous round Vova is currently playing a strategic game known as Rage of Empires Vova managed to build a large army but forgot about the main person in the army the commander So he tries to hire a commander and he wants to choose the person who will be respected by warriors Each warrior is represented by his personality an integer number Each commander has two characteristics his personality and leadership both are integer numbers Warrior commander only if is the bitwise excluding OR of and Initially Vova s army is empty There are three different types of events that can happen with the army one warrior with personality joins Vova s army one warrior with personality leaves Vova s army Vova tries to hire a commander with personality and leadership For each event of the third type Vova wants to know how many warriors counting only those who joined the army and haven t left yet the commander he tries to hire ,Let s use binary trie to store all personalities of warriors that is just use the trie data structure on binary representations of all For each subtree of this trie you have to maintain the number of s currently present in this subtree when inserting a value of we increase the sizes of subtrees on the path from the node with to the root by and when removing we decrease the sizes of subtrees on this path by How can it help us with answering the events of third type We will descend the trie When descending we will try to find the number in the structure When we go to some subtree we determine whether we add the quantity of numbers in the subtree we are not going into by checking if the current bit in is equal to if so then for all numbers from this subtree their bitwise xor with the current commander s personality is less than The answer to the event is the sum of sizes of all subtrees we added while descending into the trie 
Consider a hallway which can be represented as the matrix with rows and columns Let s denote the cell on the intersection of the th row and the th column as The distance between the cells and is There is a cleaning robot in the cell Some cells of the hallway are clean other cells are dirty the cell with the robot is clean You want to clean the hallway so you are going to launch the robot to do this After the robot is launched it works as follows While at least one cell is dirty the robot chooses among those which are dirty moves there and cleans it so the cell is no longer dirty After cleaning a cell the robot again finds the closest dirty cell and so on This process repeats until the whole hallway is clean However there is a critical bug in the robot s program If at some moment there are multiple closest to the robot s current position dirty cells the robot malfunctions You want to clean the hallway in such a way that the robot doesn t malfunction you can clean some possibly zero of the dirty cells yourself However you don t want to do too much dirty work yourself while you have this nice smart yet buggy robot to do this Note that you cannot make a clean cell dirty Calculate the maximum possible number of cells you can leave dirty before launching the robot so that it doesn t malfunction ,Why did the author choose the width of the hallway to be only Well in that case you can show that the robot will never move to the left while cleaning That is not true on width already When does the robot break Let the robot currently be in the cell indexed and the next column with a dirty cell be possibly The robot breaks only if both and are dirty That helps us to do a dynamic programming solution Since we can only care about next columns we would want to have some the largest number of dirty cells we can leave to the robot if we processed the first columns of the hallway and are currently standing in the th row of the th column Maybe with some additional states of the current or the next columns We want the dp to maintain the invariant that everything to the left of the th column is cleaned in such a way the robot can reach the cell We can choose when to fix the th column either maintain it being correct prior to entering the state or handling it in the transition to the next one I chose the former option There probably exists a million different dps that work I ll describe the one I did Let be the largest number of dirty cells that we can leave to the robot if we fixed which of the dirty cells in the first columns inclusive are cleaned by hand the robot reaches the cell from the left is true if the cell in the opposite row of the th column is dirty The transitions handle what to do with the dirty cells in the st column and where the robot goes based on that In particular there are the following transitions if is true then we have to clean the cell and the robot will move into otherwise the robot breaks from having two options if is false then let s say that the robot doesn t break immediately but moves into the next column in a unique way it moves horizontally first then possibly vertically we can leave the next column as is and the robot will move into if the cell is clean or if it s dirty if is false then we can clean the cell and the robot will move into Since we maintained the invariant that the th column is valid we can update the answer from all four states in the last column Overall complexity 
You have a multiset containing several integers Initially it contains elements equal to elements equal to elements equal to You may apply two types of operations choose two integers and then remove one occurrence of one occurrence of one occurrence of from the multiset This operation can be applied only if each number from to occurs at least once in the multiset choose two integers and then remove occurrences of from the multiset This operation can be applied only if the multiset contains at least occurrences of What is the minimum number of operations required to delete all elements from the multiset ,Notice that we can reorder the operations in any way we want without affecting the result So let s do all of the first type operations before the second type operations Then it s clear that the number of second type operations we ll need is the number of nonzero elements left over after the first type operations So we just want to choose first type operations to minimize the number of first type operations plus the number of nonzero elements left after we re done Let s say we have an array where is the minimum value if there is a tie you can pick any tied index I only have a messy proof for this at the moment but it turns out we only need to consider two options either take all second type operations or use first type operations on the entire array and then recursively solve and separately This leads to a simple solution 90999997 Note that by using RMQ we can improve this to or even The idea is very similar to the solution to problem G here 
There are boxes with colored balls on the table Colors are numbered from to th box contains balls all of which have color You have to write a program that will divide all balls into sets such that each ball belongs to exactly one of the sets there are no empty sets there is no set containing two or more balls of different colors each set contains only balls of one color there are no two sets such that the difference between their sizes is greater than Print the minimum possible number of sets ,If we want to divide all balls from some box into sets with sizes and and there are balls in this box then either or So the solution will be like that Iterate over the possible sizes of sets from to or to some constant in our solution it s and check if we can divide all balls into sets with sizes and Then iterate over the number of sets calculate the sizes of sets if we want to divide the first box exactly into sets and try to divide balls from all other boxes into sets of these sizes If we want to divide balls from the same box into sets then the sizes will be and but if then we also have to check if sizes can be and If we fix sizes and and we want to check whether we can divide a box with balls into sets with these sizes and to get the minimum possible number of such sets then the best option will be to take sets If then such division is possible If not then it s impossible to divide balls into sets of and balls Time complexity of this solution is 
Monocarp has a tree consisting of vertices He is going to select some vertex and perform the following operations on each vertex from to set equal to the distance from to the number of edges on the shortest path color some color A coloring satisfies two conditions for each pair of vertices of the same color there exists a path from to that only visits vertices of the same color for each pair of vertices of the same color Note that Monocarp can choose any amount of different colors he wants to use For each used color he then counts the number of vertices of this color The of the tree is the minimum of these numbers What can be the maximum cost of the tree ,Let s start by choosing a vertex naively Iterate over all vertices and try each of them Root the tree by and observe what the conditions become for each is just the depth of each vertex Well then the only case when the connected subgraph of vertices of the same color has all values of distinct is when they form a vertical path in the tree So the problem becomes the following Split the tree into some vertical paths in such a way that the shortest path is as long as possible Let s try greedy I guess Start the paths from the leaves and propagate them up Consider some vertex with at least two children All children have some paths leading up to them We d love to continue them all with but we can t do that We can only continue one path and cut the rest Pretty easy to see that the path to continue is the shortest path available It s at least as optimal as any other path Do that from the lowest vertices up and you got yourself a working greedy Also don t forget to stop all paths in root since you can t continue any of them further up Let s make this greedy more formal Every time we update the answer is with a path that is the shortest in every vertex lower than the current one not the shortest in the current one So we want to propagate the shortest child up and update the answer with the remaining children Updating the answer means just taking the minimum of values Thus we can actually ignore all children except the second shortest in each vertex Just don t forget to treat the root properly Now we can actually solve the problem in for a fixed You can just find two minimums in each vertex Well now that we can solve the problem for a single root let s try rerooting to solve for all of them There are solutions in but I found the solution in the neatest The constraints are low enough to allow it For each vertex maintain a multiset of lengths of vertical paths from its children I chose to store nothing in the leaves that only makes the implementation cleaner In order to update the vertex from its child you can take the minimum element in the child s set and add to it If it s empty the child is a leaf return Additionally store a multiset of the second minimums of all vertices that have at least two children In order to update the answer with the current root find the minimum of that multiset and the shortest path from the root To achieve you will probably have to either store prefix and suffix second minimums over children of each vertex or store three shortest paths in it It is kind of messy but it should still perform better Overall complexity or per testcase 
You are given points on the plane the coordinates of the th point are No two points have the same coordinates The distance between points and is defined as For each point you have to choose a color represented by an integer from to For every ordered triple of different points the following constraints should be met if and have the same color then if and have the same color and the color of is different from the color of then and Calculate the number of different ways to choose the colors that meet these constraints ,Let s call a point if its color does not match the color of any other point If a point is not isolated then it has the same color as the points with minimum distance to it and only these points should have this color Let s build a directed graph where the arc means that the point is one of the closest to the point i e If there is a path from the vertex to the vertex it means that if the vertex is not isolated the vertex should have the same color as vertex Suppose the set of vertices reachable from including itself is Finding is easy just run DFS from the vertex Let s analyze two cases there exists a pair of vertices such that and there is no arc from to for every pair of vertices such that and there is an arc Why do we need to analyze these two cases In the first case the vertex be isolated because painting it and some other vertex into the same color means that every vertex from will have this color and it will break the condition in the statement In the second case the vertex may be isolated or it may have the same color as all vertices in and if it is isolated then the whole set should consist of isolated vertices Let s find all such set of vertices that meet the second case Each vertex will belong to at most one of these sets if it doesn t belong to any it must be isolated otherwise either the whole its set consists of isolated vertices or the whole set has the same color So for each set we either use color or colors This allows us to implement a knapsack like dynamic programming let be the number of ways to paint first sets into colors such that the colors are not ordered After running this dynamic programming we can get the answer by simple combinatorics iterate on the number of colors we use in these sets in total multiply the dynamic programming for it by the ordered number of ways to choose these colors from and then by the number of ways to choose the colors for points that must be isolated This dynamic programming can even be implemented a bit easier if we treat every vertex that must be isolated as a set of size and this is the way it s written in the model solution 
A matrix of size such that each cell of it contains either or is considered if the sum in every contiguous submatrix of size is exactly i e every square of size contains exactly two s and exactly two s You are given a matrix of size Initially each cell of this matrix is empty Let s denote the cell on the intersection of the th row and the th column as You have to process the queries of three types clear the cell if there was a number in it write the number in the cell write the number in the cell After each query print the number of ways to fill the empty cells of the matrix so that the resulting matrix is Since the answers can be large print them modulo ,For best understanding we replace the matrix with and with the matrix with black and white cells At first let s consider matrix if there are two adjacent horizontal cell with same color for example cells and are black Then the cells and must have the opposite color white the cells and must have the same color black and so on So two adjacent horizontal cells generate the of width two Reciprocally two adjacent vertical cells generate the of width two And if simultaneously there are and then the answer is because they contradict each other If there are two cells of same color in the same row with even number of cells between them for example and with four cells between them then there is the because there are always two adjacent cells with same color between them The same is correct for Now let s consider how the matrix look if there are the It look like a chess board of size but colors of some verticals are inverted The same is correct if there are the How we can quickly understand that there are two cells of same color in the same row with even number of cells between them For this mentally color the matrix in a checkerboard pattern And then one of this cells has the same color witch cells in chessboard and the other has the opposite color witch cells in chessboard For calculating the answer we have maintain to the following values The color of each colored cell The row and columns containing the cells of same color with even number of cells between them And the number of row and columns containing at least one colored cell for calculating the number of beautiful matrix 
You have a large rectangular board which is divided into cells the board has rows and columns Each cell is either white or black You paint each white cell either red or blue Obviously the number of different ways to paint them is where is the number of white cells After painting the white cells of the board you want to place the maximum number of dominoes on it according to the following rules each domino covers two adjacent cells each cell is covered by at most one domino if a domino is placed horizontally it covers two adjacent cells in one of the rows it should cover only red cells if a domino is placed vertically it covers two adjacent cells in one of the columns it should cover only blue cells Let the of the board be the maximum number of dominoes you can place Calculate the sum of of the board over all possible ways to paint it Since it can be huge print it modulo ,There are different solutions to this problem involving combinatorics and or dynamic programming but in my opinion it s a bit easier to look at the problem from the perspective of probability theory Let s suppose a coloring is already chosen Then it can be covered with dominoes greedily red and blue cells are independent from each other and for example red cells can be analyzed as a set of strips of them of different length Let s say that we cover each strip from left to right so in each strip the first domino covers the cells and the second domino the cells and and so on Let s calculate the value of the coloring that is the expected value of the coloring if it is chosen randomly Let it be then the answer is By linearity of expectation can be calculated as where is the set of all places we can use for a domino and is the probability that there is a domino in place in our domino covering which we construct greedily Each domino covers two adjacent cells so we can iterate on pairs of adjacent cells and for each pair find the probability that this pair is covered Let s suppose that we want to cover the cells and with a domino Then both of these cells should be red the length of the red strip before these cells should be even otherwise the cell will be paired with the cell The only thing we need to know in order to calculate the probability of these two conditions being true is the number of white cells before the cell which can be easily maintained Knowing the number of white cells before we can either use dynamic programming to calculate the required probability or do the math on several easy examples and try to notice the pattern if there are white cells before the current one the probability of that pair being covered with a domino let s call it is both these cells should be red if there is white cell before the current one the probability of that pair being covered with a domino let s call it is the cells and should be red but the cell before them should not be red is either the chosen two cells are red and the cell before them is not red or all four cells are red is and so on So knowing the number of white cells before and we easily calculate the probability of this pair being covered by a domino By summing up the probabilities over all pairs of adjacent white cells don t forget the vertical ones we get the average or expected value of the coloring All that s left is to multiply it by 
You are given an undirected graph consisting of vertices and edges Instead of giving you the edges that exist in the graph we give you unordered pairs such that there is no edge between and and if some pair of vertices is not listed in the input then there is an edge between these vertices You have to find the number of connected components in the graph and the size of each component A connected component is a set of vertices such that for every two vertices from this set there exists at least one path in the graph connecting these vertices but adding any other vertex to violates this rule ,Let be the set of unvisited vertices To store it we will use some data structure that allows us to do the following insert some value into the set delete from the set find the smallest integer from the set such that For example from allows us to do all these operations fastly Also we can use this structure to store the adjacency lists We will use a modified version of depth first search When we are entering a vertex with we erase it from the set of unvisited vertices The trick is that in we will iterate over the set of unvisited vertices using its function And we will make not more than iterations overall because when we skip an unvisited vertex that means there is no edge from this vertex to the vertex we are currently traversing in so there will be no more than skips and each iteration we don t skip decreases the number of unvisited vertices 
You wrote down all integers from to padding them with leading zeroes so their lengths are exactly For example if then you wrote out A block in an integer is a consecutive segment of equal digits that cannot be extended to the left or to the right For example in the integer there are three blocks of length one block of length and two blocks of length For all integers from to count the number of blocks of length among the written down integers Since these integers may be too large print them modulo ,Presume that we want to calculate the number of blocks of length Let s divide this blocks into two types blocks which first element is a first element of integer or blocks which last element is a last element of integer for example blocks and in integer other blocks At first let s calculate the number of blocks of first type We can choose positions of this block at the start of end of the integer Now we can choose digit for this block After that we can chose digits of adjacent block if these blocks contain the same digit then we length of blocks which we want calculate greater than so we have only variations of digit in adjacent block Finally the can chose the remaining digit ways So the total number of block of first type is Now let s calculate the number of blocks of second type We can choose positions of this block all position except the start and end of integer Now we can choose 10 digit for this block After that we can chose digits of adjacent block for block to the left and for block to the right Finally the can chose the remaining digit ways So the total number of block of second type is That s almost all We have one corner case If then we number of blocks is always 
There are segments drawn on a plane the th segment connects two points and Each segment is non degenerate and is either horizontal or vertical formally for every either or but only one of these conditions holds Only segments of different types may intersect no pair of horizontal segments shares any common points and no pair of vertical segments shares any common points We say that four segments having indices and such that and form a rectangle if the following conditions hold segments and are horizontal segments and are vertical segment intersects with segment segment intersects with segment segment intersects with segment segment intersects with segment Please calculate the number of ways to choose four segments so they form a rectangle Note that the conditions and should hold ,Let s iterate over the lower horizontal segment Denote its coordinates as and where We call vertical segment good if followings conditions holds Now let s use the scanline method At first for each good vertical segment we increment the value of element in position in some data structure for example Fenwick Tree Next we will process two types of queries in order of increasing their y coordinate horizontal segments with coordinates upper point of some vertical segment with coordinates And if two events of different types have the same y coordinate then the event of first type must be processed first For event of first type we need to find sum on range in our data structure Let s denote this sum as Then we need to add to the answer because we have vertical segments which intersect with both fixed horizontal segments and we can choose two of them in so many ways For event of second type we just need decrement the value of element in position in our data structure 
You are given two positive integer numbers and An array is called an of iff the following conditions are met There are elements in and all of them are integer numbers You have to count the number of pairwise distinct arrays that are factorizations of Two arrays and are considered different iff there exists at least one index such that Since the answer can be very large print it modulo ,Fill the array with ones Now we should take every prime divisor of and distribute maximum power of this prime to appear in of it into some cells of the array It is pretty well known problem it s equal to Take product of this values for every prime This will be the answer if there were no negative numbers But we should also multiply it by number of ways to select even number of position to put unary minuses like you can fill in position anyhow and the final one will be determined by parity of current count To process many queries you should factorize numbers in by precalcing the smallest prime divisor of every number up to with sieve of Eratosthenes get in by precalcing factorials and inverse factorials and get in binary exponentiation Overall complexity 
You are given segments on a Cartesian plane Each segment s endpoints have integer coordinates Segments can intersect with each other No two segments lie on the same line Count the number of distinct points with which are covered by at least one segment ,I won t tell all the small geometric details just cover some major points The problem asks you the following thing Sum up the total number of points covered by each segment and for each unique point subtract the number of segments covering it minus one Let s reformulate it For each segment add the number of points covered by it and subtract the number of points covered by it and by some already processed segment The first part is easy Segment covers exactly points with integer coordinates The proof left to the reader as an exercise The second part can be done in the following manner Intersect the segment with all segments insert all the points of intersection into set and take its size You can consider only integer points of intersection and use no floating point numbers in your program Overall complexity 
There is a grid consisting of rows and columns Each cell of the grid is either free or blocked One of the free cells contains a lab All the cells beyond the borders of the grid are also blocked A crazy robot has escaped from this lab It is currently in some free cell of the grid You can send one of the following commands to the robot move right move down move left or move up Each command means moving to a neighbouring cell in the corresponding direction However as the robot is crazy it will do anything except following the command Upon receiving a command it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked If there is such a direction then it will move to a neighbouring cell in that direction Otherwise it will do nothing We want to get the robot to the lab to get it fixed For each free cell determine if the robot can be forced to reach the lab starting in this cell That is after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses it will end up in a lab ,One way to think about this problem is in game theory terms Imagine a following game Two players alternate moves The first players chooses a direction The second player chooses a different direction and moves a robot there The game ends when the robot reaches the lab and the first player wins Otherwise it s a draw What s the outcome of the game if both players play optimally as in the first player tries to win the second player tries to draw Does it sound easier Well it sure does if you ever dealt with solving games on arbitrary graphs You can skim through this article if that s unfamiliar to you The state of the game is a pair If a direction is not chosen denote it with it s the first player s move Otherwise it s the second player s move You can even implement it as is Or you can adjust a part of this algorithm for this particular problem Initially all the states are drawing only the state is winning What we basically need is a way to determine if a state is winning or not From game theory we can tell that the state is winning if there s a transition from it to a losing state The state is losing if all the transitions from it lead to winning states So is winning if any of are losing Promote that one step further The state is winning if there exists such a direction that all neighbouring free cells except in this direction are winning states Rephrase it The state is winning if it has at least one winning state neighbour and no more than one non winning state neighbour Let s store the number of non winning neighbouring states for each cell Initially it s the number of neighbouring free cells If some state becomes marked as winning decrease the value for each of its neighbours by If some state s value reaches or after this operation mark it as winning Since what this does is basically a traversal of a grid this can be done with a DFS BFS starting from the lab Overall complexity per testcase 
There are famous Russian nesting dolls named matryoshkas sold in one of the souvenir stores nearby and you d like to buy several of them The store has different matryoshkas Any matryoshka is a figure of volume with an empty space inside of volume of course You don t have much free space inside your bag but fortunately you know that matryoshkas can be nested one inside another Formally let s call a set of matryoshkas if we can rearrange dolls in such a way that the first doll can be nested inside the second one the second doll inside the third one and so on Matryoshka can be nested inside matryoshka if So only the last doll will take space inside your bag Let s call of a nested set of dolls as a total volume of empty space inside this structure Obviously it s equal to where are the indices of the chosen dolls in the order they are nested in each other Finally let s call a nested subset of the given sequence as if there isn t any doll from the sequence that can be added to the nested subset without breaking its nested property You want to buy many matryoshkas so you should choose a nested subset to buy it But you will be disappointed if too much space in your bag will be wasted so you want to choose a big enough subset so that its is minimum possible among all big enough subsets Now you wonder how many different nested subsets meet these conditions they are big enough and there is no big enough subset such that its extra space is less than the extra space of the chosen subset Two subsets are considered different if there exists at least one index such that one of the subsets contains the th doll and another subset doesn t Since the answer can be large print it modulo ,Let s at first sort all matryoshkas by increasing its inner volume in i Then each nested subset will appear as subsequence in its canonical order Now we ll write the DP with d i x y the minimum extra space x and number of such subsequences y among all nested subsets where the i th doll is Why minimal not maximal for example It s just easier transitions and easier proof There are two main cases If there isn t j such that out i le in j then we can t put the i th doll inside any other So d i in i 1 Otherwise we must put the i th doll inside other doll otherwise the subset won t be a big enough If we put the i th doll inside the j th doll then we extra space of such subset is equal to d j first out i in i Since we minimize the extra space then d i first min limits out i le in j d j first out i in i min limits out i le in j d j first out i in i Since we sorted all matryoshkas so there is a position pos such that forall j ge pos out i le in j and d i first min limits j pos n d j first out i in i The d i second is just a sum from all minimums As you can see we can store d i in Segment Tree with minimum number of minimums Why in the second transition we will build only subsets It s because not big enough subsets are not optimal in terms of minimality of extra space The result complexity is O n log n 
For a sequence of integers let s define its as follows Process the sequence from the first element to the last one maintaining the list of its subsequences When you process the element append it to the end of the subsequence in the list such that the bitwise AND of its last element and is greater than If there is no such subsequence in the list create a new subsequence with only one element and append it to the end of the list of subsequences For example let s analyze the decomposition of the sequence processing element the list of subsequences is empty There is no subsequence to append to so we create a new subsequence processing element the list of subsequences is Since the bitwise AND of and is the element is appended to the first subsequence processing element the list of subsequences is Since the bitwise AND of and is the element is appended to the first subsequence processing element the list of subsequences is There is no subsequence to append to so we create a new subsequence processing element the list of subsequences is There is no subsequence to append to so we create a new subsequence processing element the list of subsequences is Since the bitwise AND of and is the element is appended to the first subsequence processing element the list of subsequences is Since the bitwise AND of and is the element is appended to the first subsequence processing element the list of subsequences is The element cannot be appended to any of the first two subsequences but can be appended to the third one The resulting list of subsequences is Let be the number of subsequences the sequence is decomposed into You are given a sequence where each element is an integer from to Let be the sequence You have to calculate ,Let s assume that we don t have any zeroes in our array We ll deal with them later The key observation is that the number of sequences in the decomposition is not more than To prove this we can use the fact that each element will be appended to the first subsequence in the decomposition so if the second third subsequence in the decomposition ends with the number or all such numbers can be appended to that subsequence thus they won t create any new subsequences So if we consider the combination of the last elements in the subsequences of the decomposition there are only such combinations even less in practice Okay now let s try to use the fact that the number of such combinations is small There are many ways to abuse it but in my opinion the most straightforward one and also a bit slow but fast enough to easily pass the time limit is to run the following dynamic programming where is the index of the element we are processing and is the vector representing the combination of last elements of subsequences in the decomposition But it s not clear what do we store in this dynamic programming The model solution stores i e we will consider the number of subsequences added while processing the elements So our dynamic programming automatically sums up the answers for all possible right borders of the segment we decompose Transitions in this dynamic programming is easy we need to see how does the element alter the state of decomposition let it change it to take the value of and if the element forms a new subsequence let s account for it by increasing by because this increase will affect different right endpoints of the segment we decompose And now it s easy to see how to add zeroes to our solution We can just assume they don t change the state of decomposition they simply add a new subsequence which won t take any other elements So in our transitions processing means that but the size of decomposition increases To actually get the answer to the problem we need to consider all possible starting points of the segment so we sum up where is the empty vector for all 
 You may use in C in Java in Python or in Pascal to flush the output If you use some other programming language consult its documentation You may also refer to the guide on interactive problems https codeforces com blog entry 45307 You are given a string consisting of lowercase Latin letters This string was cyphered as follows initially the jury had a string consisting of lowercase Latin letters Then they applied a sequence of no more than possibly zero operations th operation is denoted by two integers and and means swapping two elements of the string with indices and All operations were done in the order they were placed in the sequence For example if is and following operations are performed then after the first operation the current string is and after the second operation the current string is so is You are asked to restore the original string Unfortunately you have no information about the operations used in the algorithm you don t even know if there were any operations in the sequence But you may run the same sequence of operations on any string you want provided that it contains only lowercase Latin letters and its length is and get the resulting string after those operations Can you guess the original string asking the testing system to run the sequence of swaps no more than times ,Since a sequence of swaps denotes some permutation let s try to restore the permutation that was used to transform into and then get by applying inverse permutation If was or less then we could get just by asking one query send a string where no character occurs twice and the resulting positions of characters uniquely determine the permutation Unfortunately may be greater than but we can ask more than one query The main idea is the following for each index we may choose a triple of characters so all triples are distinct There are different triples and that s greater than so each index can be uniquely determined Then after we choose a triple for each index ask three queries as follows in the first query the th character of the string is the first character in the triple representing index in the second query we use the second characters from all triples and in the third query the third characters Let and be the strings we sent and and be the strings we received as answers The permutation maps index to index if and only if and because if some other index is mapped to then at least one of the aforementioned equalities is false since all triples of characters are distinct Using this fact we may recover the permutation 
For a sequence of integers between and inclusive denote as the number of distinct subsequences of including the empty subsequence You are given two positive integers and Let be the set of all sequences of length consisting of numbers from to Compute the sum over all in modulo ,Let s consider some subsequence with the length the empty subsequences we will count separately by adding the valye at the end and count the number of sequences that contains it We should do that accurately to not count the same sequence multiple times Let be the fixed subsequence In the original sequence before the element can be some other elements but none of them can be equal to because we want to count the subsequence exactly one time So we have variants for each of the elements before Similarly between elements and can be other elements and we have choices for each of them And so on After the element can be some elements suppose there are such elements with no additional constraints so we have choices for each of them We fixed the number of elements at the end so we should distribute numbers between numbers before between and ldots between and Easy to see that we have choices to do that it s simply binomial coefficient with allowed repititions The number of sequences equals to So the answer is Easy to transform the last sum to the sum Note the last inner sum can be calculating using the formula for parallel summing So the answer equals to Also we can get the closed formula for the last sum to get logarithmic solution but it is not required in the problem 
You are given a positive integer Let s build the following graph from it each vertex is a divisor of not necessarily prime and itself are also included two vertices and have an undirected edge between them if is divisible by and is a prime the weight of an edge is the number of divisors of that are not divisors of For example here is the graph for Edge has weight because has divisors and has divisors Thus there are divisors of that are not divisors of There is no edge between and because is not divisible by There is no edge between and because is not a prime Let the length of the path between some vertices and in the graph be the total weight of edges on it For example path has length The empty path has length So the shortest path between two vertices and is the path that has the minimal possible length Two paths and are different if there is either a different number of edges in them or there is a position such that and are different edges You are given queries of the following form calculate the between vertices and The answer for each query might be large so print it modulo ,Let s define the semantics of moving along the graph On each step the current number is either multiplied by some prime or divided by it I claim that the all shortest paths from to always go through Moreover the vertex numbers on the path first only decrease until and only increase after it Let s watch what happens to the divisors list on these paths At first all the divisors of that are not divisors of are removed from the list Now we reach gcd and we start adding the divisors of that are missing from the list The length of the path is this total number of changes to the list That shows us that these paths are the shortest by definition If we ever take a turn off that path we either will add some divisor that we will need to remove later or remove some divisor that we will need to add later That makes the length of the path not optimal Now let s learn to calculate the number of paths The parts before gcd and after it will be calculated separately the answer is the product of answers for both parts How many paths are there to gcd Well let s divide by that will give us the primes that should be removed from You can remove them in any order because the length of the path is always the same That is just the number of their permutations with repetitions you might also know that formula as multinomial coefficient The number of paths from to is calculated the same way To find the primes in you can factorize beforehand and only iterate over the primes of Overall complexity 
You are given an multiplication table and a positive integer A multiplication table is a table with rows and columns numbered from to where For each divisor of check does occur in the table at least once and if it does what is the row that contains ,Firstly let s factorize Since we can factorize and separately and then unite divisors For example use can get canonical representations of and to get canonical representation of and then use it to generate all divisors of Let s estimate the number of divisors It s convenient for our purposes to estimate it as More precisely there are at most divisors for search Highly Composite Numbers for more info How to calculate the answer for each divisor There are two ways for each we are searching for the minimum that and Since is fixed the minimum means the maximum So let s find instead In other words for each we need to find the maximum such that divides and We can do it efficiently with on divisors Let be the maximum that is a divisor of and If then obviously Otherwise we know that we are searching Let say that are the prime divisors of the initial number Since is a divisor of and then exists some among the set of prime divisors such that is a divisor of as well So instead of brute search it s enough to take a value In other words if we can calculate Ok now we know value for each divisor Since we found the maximum the last step is to calculate the desired and if we found the answer otherwise it means that is not presented table and The total complexity is per test where is the number of divisors of and is the number of prime divisor of Note that complexity is quite high so you should write it at least a little accurate for example store in an array not map and search position of with There is also a way to get rid of extra factor if you iterate through is a smart way faster easier unproven Let s generate a list of all divisors of as in the increasing order For some divisor we are searching the minimum that is a divisor of and It means that So let s just find the first position such that with and start iterating from onward searching the first that is a divisor of The found would be the minimum we need It looks like in average we will find the correct quite fast or we ll break when 
You are given a string You can build new string from using the following operation choose any subsequence where erase the chosen subsequence from can become empty concatenate chosen subsequence to the right of the string in other words Of course initially the string is empty For example let At first let s choose subsequence we will get and At second let s choose we will get and So we can build from Can you build a given string using the algorithm above ,Let s look at string Since we should get it using no more than two subsequences then where is the first subsequence and is the second one In the general case can be empty Let iterate all possible lengths of so we can check the existence of solution for each pair and If we d fix and we need to check the following is it true that contains and as subsequences and these subsequences don t intersect Initially we can invent the following dp let be if the prefix of of length contains prefixes of and of length and as non intersecting subsequences The transitions are straingforward if we can either skip indexed and update If indexed then we can update and if then we can update But this dp has complexity in general case But we can transform it in the next way instead of the boolean value we will make as a value of dp In other words we will maintain as minimal appropriate prefix But the problem now is to define transitions Let s note the next fact suppose we have and we d like to add next character to which is equal to The idea is next it s always optimal to choose the first occurrence of in It can be proved by contradiction if the first occurrence is free then it s better to take it or if the first occurrence will be occupied by then this will be handled by the other state with The logic for increasing is analogical In result we need to precalculate array with the next occurrence of character in suffix of one time before choosing and and use it each time to acquire complexity The total complexity if for each test case 
Consider a grid of size The rows are numbered top to bottom from to the columns are numbered left to right from to The robot is positioned in a cell It can perform two types of moves move one cell down move one cell right The robot is not allowed to move outside the grid You are given a sequence of moves the initial path of the robot This path doesn t lead the robot outside the grid You are allowed to perform an arbitrary number of modifications to it possibly zero With one modification you can duplicate one move in the sequence That is replace a single occurrence of with or a single occurrence of with Count the number of cells such that there exists at least one sequence of modifications that the robot visits this cell on the modified path and doesn t move outside the grid ,First get rid of the corner cases If the string doesn t contain either of the letters the answer is The general solution to the problem is to consider every single way to modify the path then find the union of them Well every single path is too much let s learn to reduce the number of different sequences of modifications that we have to consider The main observation is that all cells that the robot can visit are enclosed in the space formed by the following two paths the first R is duplicated the maximum number of times then the last D is duplicated the maximum number of times the first D is duplicated the maximum number of times then the last R is duplicated the maximum number of times You can realize that by drawing the visited cells for some large test To show that more formally you can consider the visited cells row by row Let s show that for every two different visited cells in the same row all cells in between them can also be visited In general case we want to show that we can take the prefix of the path to the left one of these cells and duplicate any R on it to reach the right cell The suffixes of the paths will remain the same as in the initial path If there exists an R on the prefix then we are good Otherwise the reason that it doesn t exist is that we duplicated D too many times Reduce that and there will be R immediately after reaching the cell or earlier We should also show that the number of R s on the path to the left cell won t reach the maximum allowed amount until reaching the right cell Use the fact that the number of D s on both prefixes of the paths is the same The other non obvious part is that you can t reach cells outside this space However that can also be shown by analyzing each row independently Finally about the way to calculate the area of this space The main idea is to calculate the total number of cells outside this area and subtract it from Notice that non visited cells form two separate parts the one above the first path and the one to the left of the second path These are pretty similar to each other Moreover you can calculate them with a same function If we replace all D s in the string with R and vice versa then these parts swap places So we can calculate the upper part swap them and calculate it again I think the algorithm is best described with a picture Consider test for example First there are some rows that only have one cell visited Then the first R in the string appears Since we duplicate it the maximum amount of times it produces a long row of visited cells The remaining part of the part becomes the outline of the area Note that the row that marks the end of the string always ends at the last column Thus only at most first rows matter To be exact the amount of rows that matter is equal to the number of letters D in the string For each letter D let s calculate the number of non visited cells in a row it goes down to I found the most convenient way is to go over the string backwards We start from the row corresponding to the number of letters D in the string It has zero non visited cells We can maintain the number of non visited cells in the current row If we encounter an R in the string we add to this number If we encounter a D we add the number to the answer We have to stop after the first R in the string The later well earlier since we are going backwards part corresponds to the prefix of letters D the starting column on the picture Each of these rows have visited cell so non visited So we can easily calculate this part as well Overall complexity per testcase 
You are playing a computer game In this game you have to fight monsters To defend from monsters you need a shield Each shield has two parameters its current durability and its defence rating Each monster has only one parameter its strength When you fight a monster with strength while having a shield with current durability and defence there are three possible outcomes if then you receive damage if and you receive no damage but the current durability of the shield decreases by if and nothing happens The th monster has strength and you will fight each of the monsters exactly once in some random order all orders are equiprobable You have to consider different shields the th shield has initial durability and defence rating For each shield calculate the expected amount of damage you will receive if you take this shield and fight the given monsters in random order ,First of all let s find a solution in We will use the lineriality of expectation the answer for some shield is equal to where is the probability that the monster will deal damage if we use the th shield Let s see how to calculate Consider a monster such that To deal damage he should be preceded by at least other monsters having We can write a complicated formula with binomial coefficients to calculate the probability of this happening and then simplify it but a much easier solution is to consider the order of these strong monsters Suppose there are of them then there are strong monsters that will deal damage Since all orderings are equiprobable the probability that our fixed monster will deal damage is since it is the probability that it will take one of the last places in the order Okay what about weak monsters It turns out that we can use the same approach to deal damage a weak monster should be preceded by at least strong monsters Consider the relative order of strong monsters and that weak monster we are analyzing There are positions where the weak monster will deal damage so the probability of weak monster dealing damage is Okay we got a solution in How to make it faster Whenever we consider a shield all monsters are split into two types strong and weak and we may sort the monsters beforehand so the number of strong monsters and their total strength can be found with binary search Since the probabilities for all strong monsters are the same we can multiply their total strength by the probability that one fixed strong monster will deal damage we already described how to calculate it The same applies for the weak monsters so the total complexity is 
You are playing yet another game where you kill monsters using magic spells There are cells in the row numbered from to Initially the th cell contains the th monster with health You have a basic spell that costs MP and deals damage to the monster you choose You can cast it any number of times Also you have a special scroll with Explosion spell you can use only once You want to finish killing monsters with explosion that s why you firstly cast the basic spell several times possibly zero and then after that you cast one Explosion How does Explosion spell work Firstly you choose the power of the spell if you pour MP into it Explosion will deal damage Secondly you choose some monster which will be targeted by the spell That s what happens next if its health then he stays alive with health decreased by if the th monster dies with an explosion that deals damage to monsters in the neighboring cells and if these cells exist and monsters inside are still alive if the damage dealt by the explosion is enough to kill the monster or i e the current or then that monster also dies creating a secondary explosion of power or that may deals damage to their neighbors and so on until the explosions end Your goal is to kill all the remaining monsters with those chaining explosions that s why you need a basic spell to decrease of some monsters or even kill them beforehand monsters die when their current health becomes less or equal to zero Note that monsters don t move between cells so for example monsters and will never become neighbors What is the minimum total MP you need to kill all monsters in the way you want The total MP is counted as the sum of the number of basic spells you cast and the power of explosion scroll you ve chosen ,Note that each unit of damage dealt by explosions save us from using one more basic spell In other words the more the damage from explosions the better So the answer will be equal to Note that in order to kill all remaining monsters with the last spell the array should have the following structure there is a monster we cast the spell onto it and is strictly increasing in and strictly decreasing in ignoring prefix and suffix of s Let s focus on the left part of array segment since solving the right part is exactly the same Maximizing the total damage is equivalent to maximizing the sum of right before the final spell Note that we can use the straight greedy strategy to kill the chosen monster we should use Explosion spell of power exactly it s not optimal to make it either more or less powerful After that monster will create an explosion of power If we must decrease it to exactly to continue the chain of explosions of maximum total damage If we also decrease it to exactly and so on The general formula is This series will stop either if or or there are no monsters left or we met the monster with The two first cases are easy to check in constant time so let s look at the last case Suppose that monster position is equal to then or That monster is interesting to us because after death it creates an explosion of damage that already doesn t depend on and next calculation is practically the same task what chain of explosion we can have if we start from That idea drives us to dp let be the maximum damage of chaining explosion we can deal if we start from and move to the left For simplicity let s include into that total damage Calculating is next let s find the first such that If there are no such or if that is too far from i e we will set Now we know that on interval the damage dealt is the arithmetic progression for it s for it s for it s In total And if such exists and not too far away we increase by as well The last question is finding for each the closest such that Note that if we define we need just need to find last and that s quite standard task that can be solved with stack Let s iterate over and maintain a stack of previous When we need to find for the current let s just look at the top of the stack if we found we wanted otherwise just pop it and check the new top again and so on until either we find or stack becomes empty that would mean that there are no After processing the th element push on top of the stack Why it works Consider some The element on top of the stack is firstly it s but we are talking about general case If we found what we want Otherwise but it also means that previous elements that was popped on previous iteration was greater than So is bigger than as well and there were no need to even consider them i e popping them out earlier doesn t break anything Since each element is pushed in the stack once and popped out once then the complexity is for all for to or amortized The answer for the chosen position then is where is dp we discussed above is the same dp but on reversed array and because we included into both and Both and are calculated in so the total comlpexity is 
The capital of Berland looks like a rectangle of size of the square blocks of same size Fire It is known that blocks got caught on fire Those blocks are centers of ignition Moreover positions of of these centers are known and one of these stays unknown All positions are distinct The fire goes the following way during the zero minute of fire only these centers of ignition are burning Every next minute the fire goes to all neighbouring blocks to the one which is burning You can consider blocks to burn for so long that this time exceeds the time taken in the problem The neighbouring blocks are those that touch the current block by a side or by a corner Berland Fire Deparment wants to estimate the minimal time it takes the fire to lighten up the whole city Remember that the positions of blocks centers of ignition are known and th can be positioned in any other block Help Berland Fire Department to estimate the minimal time it takes the fire to lighten up the whole city ,We can use binary search to find the answer When binary searching to check whether the whole city will be lightened up after minutes we can use sweep line technique to find the smallest coordinate of the cell that is not lightened by centers of ignition and the smallest coordinate too Suppose that and are these coordinates then we can place the last center of ignition at coordinates Then we can use sweep line again to check whether the city is fully ignited 
You are given four different integer points and on grid In one step you can choose one of the points and move it in one of four directions by one In other words if you have chosen point you can move it to or Your goal to move points in such a way that they will form a square with sides parallel to and axes a square with side is allowed What is the minimum number of steps you need to make such a square ,Let s discuss two approaches to this problem Firstly let s think that we choose not four destination points but four lines on which sides of the square lie It s two vertical lines with coordinates and and two horizontal lines and of course is to note that either both and coincide with some s and coincide with one of or both and coincide with some s and coincide with one Since we know the side of the square from or and one point It s easy to construct other points of the square and find the minimum total distance by iterating all permutations This approach needs around operations and work around one second if written accurately is more clever and faster Let s assign a role for each point which vertex of the final square this will be left bottom left top right bottom or right top There will be such assignments For simplicity let s say that the left bottom vertex is left top is right bottom is and right top is If we rewrite our total distance formulas we can note that instead of summing the distance between points we can sum the distance from lines to the points which should lie on it In other words we can calculate the answer as Let s look at the left side If then the total distance is always and has it s optimal segment of values Analogically also has it s optimal segment of values Since we can choose as any value in its segment and as any value in its segment then the possible distance the side of the square also forms a segment of possible values let s name it as and can be calculated with pretty easy formula On the other hand we can do the same with horizontal sides and compute the segment of optimal side length in the same manner Now if and intersects then we can choose such side length that lies in both and and optimal for both vertical sides and horizontal sides Otherwise without loss of generality and if we choose we need to pay extra fee since we out of it means that the chosen is greater than optimal so we need to choose for example outside And we need to pay for each step outside of this segment In other words the answer for a fixed permutation is 
Monocarp is playing a video game In the game he controls a spaceship and has to destroy an enemy spaceship Monocarp has two lasers installed on his spaceship Both lasers and have two values the power of the laser the reload time of the laser When a laser is fully charged Monocarp can either shoot it or wait for the other laser to charge and shoot both of them at the same time An enemy spaceship has durability and shield capacity When Monocarp shoots an enemy spaceship it receives damage i e gets subtracted from its durability where is the total power of the lasers that Monocarp shoots i e if he only shoots laser and if he shoots both lasers at the same time An enemy spaceship is considered destroyed when its durability becomes or lower Initially both lasers are zero charged What s the lowest amount of time it can take Monocarp to destroy an enemy spaceship ,At any time we have three possible choices wait and shoot the first laser the second laser and both lasers Sometimes it makes sense to wait to both because you can deal more damage than you would do by shooting both lasers separately The first claim greedy won t work Maybe there is a sufficiently smart greedy we weren t able to come up with it The second claim bruteforce won t work The funny thing is that it actually worked on the constraints up to but again we couldn t code any sufficiently fast one for Thus let s try some dynamic programming Since all the times are huge we d want to avoid having them as the states What is small however is the durability of the enemy ship and the number of shots we have to make to destroy it Ideally we d like to have some the smallest time to deal damage to the enemy ship This way would be the answer Sadly it s not immediately clear how to get rid of reload times completely There might be states with different times until the charge with the same damage dealt and we don t know which of those we want to keep Thus let s make the dp state more complicated Let be the smallest time it takes to deal damage if the last shot was from both lasers at the same time This way we know the reload times of both lasers they are full and as moment has both lasers zero charged as if after a shot What are the transitions Well now we have to shoot each laser multiple times then wait until both are charged and shoot both Both lasers can now be considered independent of each other Let the time between the previous double shot and the next one be some value During this time it never made sense to wait until shooting each laser So we waited shot the first laser waited another shot again until we couldn t shoot anymore since the laser wouldn t recharge in time before the double shot Same for the second laser Notice that if both and then you could just decrease by and shoot each laser the same number of times Thus only that are multiples of either or are optimal Thus we can iterate over all possible waiting times Just iterate over and for all from to Having a fixed calculate the number of shots of each laser calculate the damage go into the corresponding dp state It could also happen that the last shot before destroying the ship wasn t a double one However it still follows the same ideas It means that each laser was shooting non stop until the ship was destroyed Thus the destruction time is still a multiple of either of the reload times Overall complexity 
Monocarp and Polycarp are playing a computer game This game features bosses for the playing to kill numbered from to They will fight boss the following way Monocarp makes attempts to kill the boss Polycarp makes attempts to kill the boss Monocarp makes attempts to kill the boss Polycarp makes attempts to kill the boss Monocarp kills the th boss on th attempt Polycarp kills the th boss on th attempt After one of them kills the th boss they move on to the st boss The attempt counters reset for both of them Once one of them kills the th boss the game ends Find all values of from to such that Monocarp kills ,Consider some value of When is it included in the answer When Monocarp spends a lower or an equal amount of blocks of attempts than Polycarp for killing every boss Formally for all from to Let s reverse this condition is not in the answer if there exists such from to that So there exists at least one value between and Let s call it Now it s I set the and signs arbitrarily just so that it shows that such a value exists You can t put both or both because that will accept values or at least values respectively Would be cool if we could multiply everything by and it still worked Is it completely impossible though Take a look at What it says is that there exists a multiple of between and A multiple of is a number that s the last in each block of attempts the block of value that are rounded up the same Turns out this is what we are looking for already Right after the multiple of the new block starts Thus we are wrong we our signs It should be is in the block after so it requires more blocks of attempts So for to not be included in the answer there should exist at least one such that there exists a multiple of in the half interval That is pretty easy to implement For each calculate the number of half intervals that cover I think this is called delta encoding Iterate over all half intervals and make two updates for each one increment by on position and decrement by on position Then make a prefix sum over these updates Now the value in the th position tells you the number of half intervals that cover To check a particular value of iterate over all multiples of and check that none are covered by half intervals It s known that the total number of multiples over all numbers from to is Overall complexity per testcase 
Alice and Bob play a game Initially they have a string consisting of only characters and They take alternating turns and Alice is moving first During each turn the player has to select a contiguous substring consisting only of characters and replaces each of them with Alice must select a substing of length and Bob must select a substring of length It is guaranteed that For example if and then after Alice s move string can turn only into And if it s Bob s turn and the string then after Bob s move the string can turn into or Whoever is unable to make a move loses You have to determine who wins if they both play optimally You have to answer independent queries ,At first let s transform input to a more convenient form We consider only such subsegments that consist of the symbols and which cannot be expanded to the right or left For example for we consider segments of length and Let s divide all such segments into four groups by their length In such a division each segment belongs to exactly one type Suppose that the Bob takes the first turn If there is a segment of second type then Bob wins because he always have a spare turn that Alice cannot make If there is a segment of fourth type then the Bob also wins because he can make the segment of second type by taking turn in this segment of four type If there are no segments of second and four types then victory depends on the parity of the number of segments of the third type But it is true if the Bob takes first turn If Alice takes first turn then she doesn t want after her move there are segments of the second and fourth types So if initially there is a segment of second type then Alice loses because she can t take turns into segment of second type If there are two or more segments of four type then Alice also loses because after her turn at least one such segments remains If there are only one segment of four type then Alice have to take turn into this segment Since the length of this segment doesn t exceed we can iterate over all possible Alice moves After Alice s move segment of fourth type can be divided into no more than two new segments let s denote their types as and If at least one of these segments of second or fourth type then it s bad turn for Alice Otherwise Alice win if remaining number of segment of third type is even note that or also can be the third type And finally if initially there are only segments of first or third type then victory depends on the parity of the number of segments of the third type 
 wants to generate an input file for some programming competition problem His input is a string consisting of letters a He is too lazy to write a generator so he will manually generate the input in a text editor Initially the text editor is empty It takes him seconds to insert or delete a letter a from the text file and seconds to copy the contents of the entire text file and duplicate it wants to find the minimum amount of time needed for him to create the input file of exactly letters a Help him to determine the amount of time needed to generate the input ,This problem has a simple solution described by participants in the comments My solution is a little harder Let s solve it using dynamic programming Let be the smallest amount of time needed to get letters a Let s consider transitions the transition for adding one letter a can be simply done Let s process transitions for multiplying by two and subtraction by one simultaneously let s decrease the number times by one right after getting it Easy to see that such updates never include each other so we can store them in queue by adding the new update at the tail of the queue and taking the best update from the head The solution is hard to describe but it is very simple in the code so please check it to understand the idea 
You are given a rooted tree Each vertex contains tons of gold which costs per one ton Initially the tree consists only a root numbered with tons of gold and price per ton There are queries Each query has one of two types Add vertex where is an index of query as a son to some vertex vertex will have tons of gold with per ton It s guaranteed that For a given vertex consider the simple path from to the root We need to purchase tons of gold from vertices on this path spending the minimum amount of money If there isn t enough gold on the path If we buy tons of gold in some vertex the remaining amount of gold in it decreases by of course we can t buy more gold that vertex has at the moment For each query of the second type calculate the resulting amount of gold we bought and the amount of money we should spend Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query so don t forget to flush output after printing answers You can use functions like in and in or similar after each writing in your program In standard if you don t tweak I O flushes in and in or in makes automatic flush as well ,Note that for each vertex So if we consider a path from some vertex to the closer you are to the cheaper the cost In other words it s always optimal to choose the highest vertex on the path with Suppose we can find such vertex for a given How many times we will repeat this search operation If we need to buy tons and has tons then it s optimal to buy tons in After we buy tons either becomes or becomes Since for each vertex can become equal to zero at most once and since after is zero we stop buying then there will be searches in total The next question is how to find efficiently for a given Consider the path from to some vertex Since we prefer to buy from higher vertices all empty vertices on this path will form some prefix of it possibly empty prefix So we can make some sort of binary search to find the first non empty vertex But instead of binary search we will use binary lifting technique If we know for each which vertex on the path from to on distance from then we can efficiently jump up the path Let s firstly jump at distance if then we jump too high let s not jump But if then we can safely jump or Now we know that we don t need a second jump so we try jump and so on In other words using binary lifting we can find the highest vertex with in steps Also we can calculate array for vertex right after we add vertex to the tree since and The resulting complexity is 
You are given an undirected graph without self loops or multiple edges which consists of vertices and edges Also you are given three integers and Can you label each vertex with one of three numbers or in such way that Each vertex should be labeled by exactly one number or The total number of vertices with label should be equal to The total number of vertices with label should be equal to The total number of vertices with label should be equal to for each edge where is the label of vertex If there are multiple valid labelings print any of them ,Let s rephrase the fifth condition Each edge should connect two vertices with the numbers of different parity either to or to So the graph should actually be bipartite and the first partition should have only the odd numbers or and the second partition should have only the even numbers only Notice how and are completely interchangeable in the sense that if you have exactly vertices which should be assigned odd numbers then you can assign whichever of them to and the rest to you want So you can guess that the first step is to check if the given graph is bipartite If it isn t then the answer doesn t exist It can be done with a single dfs Actually the algorithm for that extracts the exact partitions which comes pretty handy If the graph was a single connected component then the problem would be easy Just check if either the first partition or the second one has size and assigned its vertices color If neither of them are of size then the answer obviously doesn t exist However the issue is that there might be multiple connected components and for each of them you can choose the partition to assign to independently Still each of the connected components should be bipartite for the answer to exist This can be done with a knapsack like dp Let the th connected component have partitions of sizes Then the state can be is true if connected components are processed and it s possible to assign to exactly vertices of these components As for transitions for the th component you can either take the partition with vertices or with vertices Thus if is true then both of and are also true If is false then there is no answer Otherwise you can always restore the answer through the dp The easiest way is probably to store not true false in but three values for false for the case the state is reached by taking the first partition of the th component and for the second partition Also you should store not only the sizes of the partitions but the vertices in each of them as well This way you can recover the answer by backtracking from the final state Overall complexity 
You are given array of length You can choose one segment and integer value positive negative or even zero and change by each i e for each What is the maximum possible number of elements with value that can be obtained after one such operation ,Let be a number of occurrences of number in subsegment The given task is equivalent to choosing and value such that is maximum possible But with some transformations so we need to maximize Key observation is the next if we fix some value then we can shrink each segment between consecutive occurrences of in one element with weight equal to Then we need just to find subsegment with maximal sum the standard task which can be solved in Finally total complexity is 
Leha is planning his journey from Moscow to Saratov He hates trains so he has decided to get from one city to another by car The path from Moscow to Saratov can be represented as a straight line well it s not that straight in reality but in this problem we will consider it to be straight and the distance between Moscow and Saratov is km Let s say that Moscow is situated at the point with coordinate km and Saratov at coordinate km Driving for a long time may be really difficult Formally if Leha has already covered kilometers since he stopped to have a rest he considers the th kilometer as It is guaranteed that for every The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey Fortunately there may be some rest sites between Moscow and Saratov Every integer point from to may contain a rest site When Leha enters a rest site he may have a rest and the next kilometer will have difficulty the kilometer after it difficulty and so on For example if and there is a rest site in coordinate the difficulty of journey will be the first kilometer will have difficulty the second one then Leha will have a rest and the third kilometer will have difficulty the fourth and the last one Another example if and there are rest sites in coordinates and the difficulty of Leha s journey is Leha doesn t know which integer points contain rest sites So he has to consider every possible situation Obviously there are different distributions of rest sites two distributions are different if there exists some point such that it contains a rest site in exactly one of these distributions Leha considers all these distributions to be equiprobable He wants to calculate the expected value of difficulty of his journey Obviously is an integer number You have to calculate it modulo ,Let s consider each kilometer of the journey separatedly and calculate the expected value of its difficulty and then use linearity of expectation to obtain the answer The difficulty of each kilometer depends on the rest site right before it or if there were no rest sites on the distance from Moscow to this kilometer So when considering the difficulty of th kilometer one indexed we may obtain a formula The denominator of the last summand is because it represents the situation where the last rest was in Moscow and its probability is exactly We can actually rewrite this as follows thus calculating all that we need in linear time 
You are given two permutations and both consisting of elements Permutation of elements is such a integer sequence that each value from to appears exactly once in it You are asked to perform two types of queries with them calculate the number of values which appear in both segment of positions in permutation and segment of positions in permutation swap values on positions and in permutation Print the answer for each query of the first type It is guaranteed that there will be at least one query of the first type in the input ,At first time limit was not that tight for the problem We didn t want any sqrt bitset or straight up solution to pass and it s close to none to pass Jury solution works faster than twice the time limit so we decided 6 seconds is alright The task is purely about implementation You renumerate numbers in permutations so that the queries are and then have the structure to make update in point and sum on rectangle Renumeration in my case was making the first permutation into identity one and changing the numbers in second appropriately You can choose the structure you want I ll tell about the one I use when the queries are offline For online the common technique is having BITs each with treap in it ordered set template from pbds is usually enough For offline you can precalculate the values to fall into each BIT beforehand and do BIT on these values inside Preprocess all the update and get queries adding into all the BITs will fall into Then sort them and leave only unique occurrences Overall complexity 
You are given a square board consisting of rows and columns Each tile in it should be colored either white or black Let s call some coloring if each pair of adjacent rows are either the same or different in every position The same condition should be held for the columns as well Let s call some coloring if it is and there is no of the single color consisting of at least tiles Your task is to count the number of colorings of the board of the given size Since the answer can be very large print it modulo ,You can notice that every coloring can be encoded by the two binary strings of length You firstly generate one string to put as a first row and then use the second string to mark if you put the first string as it is or inverting each color That way you can also guess that the area of maximum rectangle of a single color you will get in you coloring is the product of maximum lengths of segments of a single color in both of the strings Let s consider the following dynamic programming solution is the number of binary strings of length such the current last segment of a single color has length and the maximum segment of a single color has length The transitions are color the new tile the same as the previous one color the new tile the opposite from the previous one The starting state is Let s sum the values of this dp to an array the number of binary strings of length such that the maximum segment of a single color in them has length You can also do another dp to calculate this not in but in using some partial sums in it Finally you iterate over the first side of the resulting rectangle the maximum length of segment of a single color in a first binary string and multiply the number of ways to get it by the total number of ways to get the second side of the resulting rectangle so that the area doesn t Overall complexity or 
You have a password which you often type a string of length Every character of this string is one of the first lowercase Latin letters Since you spend a lot of time typing it you want to buy a new keyboard A keyboard is a permutation of the first Latin letters For example if then there are six possible keyboards and Since you type your password with one finger you need to spend time moving your finger from one password character to the next The time to move from character to character is equal to the distance between these characters on keyboard The total time you have to spend typing the password with a keyboard is called the of this keyboard More formaly the slowness of keyboard is equal to where is position of letter in keyboard For example if is and the keyboard is then the total time of typing this password is Before buying a new keyboard you want to know the minimum possible slowness that the keyboard can have ,Let s solve this problem by subset dynamic programming Let s denote as the number of adjacent characters and in such that or Let s be some intermediate result further it will be explained what kind of intermediate result if we already added letters corresponding to subset to the keyboard and we don t care about the order of these letters Now let s consider how to recalculate values of this dynamic programming using some Let s iterate over a new letter on keyboard and we know the position of this letter on the keyboard it s equal to the number of elements in After adding this new letter we want to calculate what it added to the Let consider some letter and calculate how much time will be spent on moving and There are two cases If letter is already on current keyboard then we should add to answer and otherwise where is the position of character on the keyboard But we don t know the position of the letter Let s fix it as follows We will add the contribution of some letter when it will be added to the keyboard So when we added letter we should add the value So the total complexity is 
You have a set of items each having some integer weight not greater than You denote that a subset of items is good if total weight of items in the subset does not exceed You want to calculate the maximum possible weight of a good subset of items Note that you have to consider the empty set and the original set when calculating the answer ,Let s consider the optimal answer Suppose we take items of weight Let be the least common multiple of all weights that is Then we may represent as where Let s do the following trick we will take items of weight and all the remaining items of this weight can be merged into some items of weight Then we can write a brute force solution that picks less than items of each weight transforms the remaining ones into items of weight as much as possible and when we fix the whole subset adds maximum possible number of items of weight to the answer This works in something like operations which is too much How can we speed it up Rewrite it using dynamic programming When we have fixed the number of items we take from first sets the only two things that matter now are the current total weight of taken items and the number of items of weight we can use and it s obvious that the more items of weight we can use the better So let s write the following dynamic programming solution maximum number of items of weight we can have if we processed first types of items and current total weight is Note that the second dimension should have size 
You found a map of a weirdly shaped labyrinth The map is a grid consisting of rows and columns The rows of the grid are numbered from to from bottom to top The columns of the grid are numbered from to from left to right The labyrinth has layers The first layer is the bottom left corner cell The second layer consists of all cells that are in the grid and adjacent to the first layer by a side or a corner The third layer consists of all cells that are in the grid and adjacent to the second layer by a side or a corner And so on The labyrinth with layers for example is shaped as follows The layers are separated from one another with walls However there are doors in these walls Each layer except for layer has exactly two doors to the next layer One door is placed on the top wall of the layer and another door is placed on the right wall of the layer For each layer from to you are given positions of these two doors The doors can be passed in both directions either from layer to layer or from layer to layer If you are standing in some cell you can move to an adjacent by a side cell if a wall doesn t block your move e g you can t move to a cell in another layer if there is no door between the cells Now you have queries of sort what s the minimum number of moves one has to make to go from cell to cell ,WLOG assume all queries ask to move from a lower layer to a higher layer The first thing to notice in the problem is that it is always optimal to never go down a layer You have an optimal path that is going down some layers and then returning to the same layer So it leaves a layer in some its cell and returns to it in some other cell or the same one The best distance it can achieve is the Manhattan distance between these two cells However we can also achieve the Manhattan distance by just going along this layer and the answer will be at least as optimal If the query asks about the cells of the same layer just answer with the Manhattan distance Otherwise we can describe the path as follows go from the first cell to some door on its layer enter the door and go to another door on the next layer so on until the layer of the second cell where you go from a door to the second cell Thus we could potentially write the shortest distance from the start to the th door of the th layer Initialize both doors of the first layer take the best answer from the both doors of the last layer That would be per query which is too slow Let s optimize it with some precalculations In particular we want to know the shortest distance between one door of some layer and one door of another layer We can use the technique similar to binary lifting Calculate the distance between a pair of doors on layers which are apart for all up to Let be the distance from door of layer to door of layer can be initialized straightforwardly Then to calculate we can use the values for and for some intermediate door on layer To obtain the answer use jumps to reach the layer one before the last one Then iterate over the last door Alternatively you could pack this dynamic programming into a segment tree use divide and conquer on queries or do square root decomposition Overall complexity 
 Let s call a positive integer if its decimal representation without leading zeroes contains even number of digits and there exists a permutation of this representation which is palindromic For example is a beautiful number since it contains digits and there exists a palindromic permutation Given a positive integer find the largest beautiful number which is less than ,This is pretty typical problem on greedy construction you are asked to build lexicographically maximal string In the majority of cases it s done like this Imagine you ve built some prefix of length with all numbers equal to the prefix of length of the original string You are also sure there exists some suffix for it that will give proper beautiful number Now you have two options you either put if possible and proceed to the same task of longer prefix or you put the smaller number and fill the entire suffix with the maximum possible beautiful number you can obtain Now you should learn how to check if any valid suffix exists It means at least the smallest possible beautiful number with current prefix is smaller than It s built like this Let be the number of digits which currently have odd number of occurences You put all zeroes but the last digits and then output these odd occurence number digits in increasing order The first part can be checked with partial sums on the number of zeroes on segment in the original string and the second part has its length not greater than and can be checked naively Overall complexity 
You are given a rooted tree with root in vertex Each vertex is coloured in some colour Let s call colour dominating in the subtree of vertex if there are no other colours that appear in the subtree of vertex more times than colour So it s possible that two or more colours will be dominating in the subtree of some vertex The subtree of vertex is the vertex and all other vertices that contains vertex in each path to the root For each vertex find the sum of all dominating colours in the subtree of vertex ,The name of this problem is anagram for Small to large There is a reason for that The author solution for this problem uses the classic technique for computing sets in tree The simple solution is the following let s find for each vertex v the map int int the number of occurences for each colour set pair int int pairs the number of occurences and the colour and the number sum the sum of most frequent colours in subtree of v To find that firstly we should find the same thing for all childs of v and then merge them to one These solution is correct but too slow it works in O n2logn time Let s improve that solution every time when we want to merge two map s a and b let s merge the smaller one to larger simply by iterating over all elements of the smaller one this is the Small to large Let s consider some vertex v every time when vertex v will be moved from one map to another the size of the new map will be at least two times larger So each vertex can be moved not over than logn times Each moving can be done in O logn time If we accumulate that values by all vertices then we get the complexity O nlog2n I saw the solutions that differs from author s but this technique can be used in a lot of other problems 
You are given an array of integers and a set of distinct integers from to In one operation you may choose two integers and can be any integer and assign This operation can be done only if does not belong to the set Calculate the minimum number of operations you should perform so the array is increasing that is or report that it is impossible ,First let s solve the problem without blocked positions Let s look at the array Obviously if strictly increases then does not decrease and vice versa Now we have to find the maximum number of positions in the array that can be left unchanged And you can always choose an integer that will not break the non decreasing array for the rest of positions This problem can be solved in by analogy with the largest increasing subsequence but now you can take equal elements Now you can realize that the segments between two blocked positions do not depend on each other and the initial problem can be solved as the problem described above All that remains is to check that all blocked positions do not break the strict array increment 
Petya is a math teacher of his students has written a test consisting of questions For each student it is known which questions he has answered correctly and which he has not If the student answers the th question correctly he gets points otherwise he gets points Moreover the points for the questions are distributed in such a way that the array is a permutation of numbers from to For the th student Petya knows that he expects to get points for the test Petya wonders how unexpected the results could be Petya believes that the of the results for students is equal to where is the number of points that the th student has got for the test Your task is to help Petya find such a permutation for which the of the results is maximum possible If there are multiple answers print any of them ,Note that there are only two ways to fix the result of the operation of taking an absolute value in the expression or Since the value of is small enough that we can iterate over all options and choose the one for which the sum is maximum For each student let s fix with which sign their total points will contribute to the answer then will contribute with the opposite sign Now for the question we can calculate the coefficient with which will contribute to the answer It remains to choose such a permutation that the sum is the maximum possible From here we can see that if for some and then must holds otherwise we can swap and and the answer will increase This means that we can sort all questions in ascending order by the value in the array and assign the value in the array to the th question in ascending order For some of options the permutations we found may be illegal because it can happen that we consider the case that some evaluates as but in the best permutation we found for that option it evaluates as We can just ignore it because this will never be the case with the option giving the highest possible surprise value if this thing happened for some option to choose the signs of then if we flip the signs for the students such that the conditions on them are not met in the optimal permutation we ll get a combination of signs that yields a higher surprise value 
You are given an array consisting of integers and additionally an integer You have to choose some sequence of indices in such a way that the value of is maximized Chosen sequence can be empty Print the maximum possible value of ,Let s consider the naive solution in or Iterate over all subsets of original set calculate sums and take maximum of them modulo Now we can use meet in the middle technique to optimize it to Preprocess the first elements naively and push sums modulo to some array After this process the second half with following algorithm Take sum of the set and find the greatest total sum of current and some sum in the array As any sum of two numbers less than can go no greater than we can consider just two values the greatest number in array and the greatest number less than in the array This can be found by binary search over sorted array Overall complexity 
You have a set of discs the th disc has radius Initially these discs are split among towers each tower contains at least one disc and the discs in each tower are sorted in descending order of their radii from bottom to top You would like to assemble one tower containing all of those discs To do so you may choose two different towers and each containing at least one disc take several possibly all top discs from the tower and put them on top of the tower in the same order as long as the top disc of tower is bigger than each of the discs you move You may perform this operation any number of times For example if you have two towers containing discs and in order from bottom to top there are only two possible operations move disc from the first tower to the second tower so the towers are and move discs from the first tower to the second tower so the towers are and Let the of some set of towers be the minimum number of operations required to assemble one tower containing all of the discs For example the of the set of towers is you may move the disc to the second tower and then move both discs from the second tower to the first tower You are given queries Each query is denoted by two numbers and and means merge the towers and that is take all discs from these two towers and assemble a new tower containing all of them in descending order of their radii from top to bottom The resulting tower gets index For each calculate the of the set of towers after the first queries are performed ,First of all let s try to find a simple way to evaluate the difficulty of a given set of towers I claim that the difficulty is equal to the number of pairs of discs that belong to different towers during each operation we can merge at most one such pair if we move discs to the tower with disk on top of it only the pair can be affected we can always take the first several discs belonging to the same tower and move them to the tower containing disc thus merging exactly one pair in exactly one operation After that there are two main approaches LCA and small to large merging The model solution uses LCA so I ll describe it For each pair we have to find the first moment these discs belong to the same tower To do so let s build a rooted tree on vertices The vertices to will be the leaves of the tree and will represent the original towers The vertex will represent the tower created during the th query and will have two children the vertices representing the towers we merge during the th query The vertex is the root Now if some vertex is an ancestor of vertex it means that the tower represented by vertex contains all the discs from the tower represented by vertex So to find the first tower containing two discs and we have to find the lowest common ancestor of the vertices representing the towers and The easiest way to do it is to implement something like binary lifting which allows us to solve the problem in 
Monocarp is a tutor of a group of students He communicates with them using a conference in a popular messenger Today was a busy day for Monocarp he was asked to forward a lot of posts and announcements to his group that s why he had to write a very large number of messages in the conference Monocarp knows the students in the group he is tutoring quite well so he understands which message should each student read Monocarp wants the student to read the message Of course no one s going to read all the messages in the conference That s why Monocarp decided to pin some of them Monocarp can pin any number of messages and if he wants anyone to read some message he should pin it otherwise Unfortunately even if a message is pinned some students may skip it anyway For each student Monocarp knows that they will read at most messages Suppose Monocarp pins messages if then the th student will read all the pinned messages but if the th student will choose exactly random pinned messages all possible subsets of pinned messages of size are equiprobable and read only the chosen messages Monocarp wants to maximize the expected number of students that read their respective messages i e the number of such indices that student reads the message Help him to choose how many and which messages should he pin ,First of all let s rewrite the answer using expectation linearity The expected number of students who read their respective messages is equal to where is a random value which is if the th student reads the message and if the th student doesn t do it Let s analyze the expected value of Suppose Monocarp pins the messages There are three cases if then the th student won t read the message so if and then the th student will definitely read the message so if and then If we iterate on the number of messages we pin we can calculate the sum of for each message considering that we pin it sort all of the messages and pick best of them So we have a solution working in The only thing we need to improve this solution sufficiently is the fact that we don t have to consider the case Since every is not greater than the sum of for a message in the case is the same as this sum of in the case but multiplied by the coefficient and we pick best values their sum multiplied by is not greater than the sum of best values The same holds for and greater 
Polycarp is a frequent user of the very popular messenger He s chatting with his friends all the time He has friends numbered from to Recall that a permutation of size is an array of size such that each integer from to occurs exactly once in this array So his recent chat list can be represented with a permutation of size is the most recent friend Polycarp talked to is the second most recent and so on Initially Polycarp s recent chat list looks like in other words it is an identity permutation After that he receives messages the th message comes from the friend And that causes friend to move to the first position in a permutation shifting everyone between the first position and the current position of by Note that if the friend is in the first position already then nothing happens For example let the recent chat list be if he gets messaged by friend then becomes if he gets messaged by friend then doesn t change if he gets messaged by friend then becomes For each friend consider all position he has been at in the beginning and after receiving each message Polycarp wants to know what were the minimum and the maximum positions ,So I have two slightly different approaches to the problem There is a straightforward no brain one and a bit smarter one The minimum place is the same in both solutions For the th friend it s just if he never moves and otherwise Obtaining the maximum place is trickier For the first approach take a look what happens with some friend after he gets moved to the first position Or what s more useful what happens after he gets moved to the first position and before he gets moved again afterwards or the queries end Notice how every other friend is to the right of him initially Thus if anyone sends a message then the position of the friend increases by one However if that friend moves again nothing changes That should remind of a well known problem already You are just required to count the number of distinct values on some segments The constraints allow you to do whatever you want segtree with vectors in nodes Mo persistent segtree I hope ML is not too tight for that Unfortunately for each friend we have missed the part before his first move In that case for each you need to count the number of distinct values greater than as only friends with greater index will matter Luckily you can do it in a single BIT Let th its value be set to zero if the friend hasn t sent messages and one otherwise Let s process messages from left to right If the friend sends a message for the first time then update the BIT with in his index and update his answer with the suffix sum of values greater than his index Finally there are also friends who haven t sent messages at all As we have built the BIT already the only thing left is to iterate over these friends and update the answers for them with a suffix sum Overall complexity The attached solutions are and The second solution requires a small observation to be made Notice that for each friend you can only check his position right before his moves and at the end of the messages That works because the position can decrease only by his move so it s either increases or stays the same between the moves So let s learn to simulate the process quickly The process we are given requires us to move someone to the first position and then shift some friends Let s not shift And let s also reverse the list it s more convenient to append instead of prepending So initially the list is and the message moves a friend to the end of the list Allocate positions in a BIT for example Initially the first positions are taken the rest are free mark them with ones and zeroes respectively For each friend his position in this BIT is known initially they are because we reversed the list On the th message sent count the number of taken positions to the right of set in update and set in And don t forget to update each friend s maximum after all the messages are sent that is the number of taken positions to the right of his final one as well Overall complexity 
You are given a directed acyclic graph with vertices and edges There are no self loops or multiple edges between any pair of vertices Graph can be disconnected You should assign labels to all vertices in such a way that Labels form a valid permutation of length an integer sequence such that each integer from to appears exactly once in it If there exists an edge from vertex to vertex then should be smaller than Permutation should be lexicographically smallest among all suitable Find such sequence of labels to satisfy all the conditions ,This problem is usually called Topological labelling Though it s pretty common problem we decided that it might be educational to some of participants Let s set labels in descending order starting from label to label Look at first step Vertex with label should have out degree equal to zero Among all such vertices we should put the label on the one that has the largest index Ok but why will this produce the lexicographically smallest labelling We can prove this by contradiction Let this vertex be labeled Change it to and renumerate vertices with label to labels Labelling will come lexicographically smaller than it was this leads to contradiction So the algorithm comes as following On step we find vertices with out degree equal to zero select the one with the largest index set its label to and remove this vertex and all edges connected to it from the graph Current minimal out degree can be maintained with set for example Overall complexity 
You are given intervals in form on a number line You are also given queries in form What is the minimal number of intervals you have to take so that every point from to is covered by at least one of them If you can t choose intervals so that every point from to is covered then print for that query ,Let s take a look at a naive approach at first That approach is greedy Let s find such an interval which starts to the left or at and ends as much to the right as possible Set to its right border Continue until either no interval can be found or is reached The proof basically goes like this Let there be some smaller set of intervals which cover the query these can be sorted by left border obviously their left borders are pairwise distinct Compare that set to the greedy one take a look at the first position where best set s interval has his less than the greedy set s You can see that choosing interval greedily will still allow to have the rest of best set intervals making the greedy choice optimal Let s implement it in For each position from to you can precalculate the index of such an interval that it starts to the left or at this position and ends as much to the right as possible To do this sort all intervals by their left border then iterate over positions while maintaining the maximum right border achieved by intervals starting to the left or at the current position The query is now straightforward Now there are two main ways to optimize it You can do it binary lifting style for each interval or position precalculate the index of the interval taken last after taking intervals greedily and use this data to answer queries in You can also do it path compression style Let s process the queries in the increasing order of their right borders Now do greedy algorithm but for each interval you use remember the index of the last reached interval Now the part with answering queries is in total because each interval will be jumped from no more than once Overall complexity 
You are given a weighted undirected connected graph consisting of vertices and edges It is guaranteed that there are no self loops or multiple edges in the given graph Let s define the weight of the path consisting of edges with indices as where weight of the th edge in the graph Your task is to find the minimum weight of the path from the st vertex to the th vertex for each ,Let s consider a problem where you can subtract the weight of any edge not only the maximum one that belong to the current path and similarly add the weight of any edge not only the minimum one that belong to the current path To solve that problem we can build a new graph where the node can be represented as the following triple node from the initial graph flag that some edge has been subtracted flag that some edge has been added Now we can run Dijkstra s algorithm to find the length of the shortest paths in such a graph We can notice that on the shortest path the maximum weight edge was subtracted and the minimum weight edge was added Let s assume that this is not the case and an edge of non maximum weight was subtracted from the path then we can reduce the length of the path by choosing an edge of maximum weight But this is not possible because we considered the shortest path Similarly it is proved that the added edge was of minimal weight Using this fact it is not difficult to notice that by solving the modified problem we have solved the original one 
Connected undirected weighted graph without self loops and multiple edges is given Graph contains vertices and edges For each edge find the minimal possible weight of the spanning tree that contains the edge The weight of the spanning tree is the sum of weights of all edges included in spanning tree ,This problem was prepared by dalex Let s build any MST with any fast algorithm for example with Kruskal s algorithm For all edges in MST the answer is the weight of the MST Let s consider any other edge x y There is exactly one path between x and y in the MST Let s remove mostly heavy edge on this path and add edge x y Resulting tree is the MST contaning edge x y this can be proven by Tarjan criterion Let s fix some root in the MST for example the vertex 1 To find the most heavy edge on the path from x to y we can firstly find the heaviest edge on the path from x to l lca x y and then on the path from y to l where l is the lowest common ancestor of vertices x and y To find l we can use binary lifting method During calculation of l we also can maintain the weight of the heaviest edge Of course this problem also can be solved with difficult data structures for example with Heavy light decomposition method or with Linkcut trees Complexity O mlogn It s very strange but I can t find any articles with Tarjan criterion on English although there are articles on Russian so here it is Some spanning tree is minimal if and only if the weight of any other edge x y not from spanning tree is not less than the weight of the heaviest edge on the path from x to y in spanning tree 
We define as the remainder of division of by operator in C or Java operator in Pascal Let s call an array of positive integers if for every permutation of integers from to and for every non negative integer the following condition is met That is for each non negative integer the value of does not change if we reorder the elements of the array For two given integers and calculate the number of arrays such that ,We claim that the array is stable if and only if all elements are divisible by its minimum The proof of this fact will be at the end of the editorial To calculate the number of stable arrays now we need to iterate on the minimum in the array and choose the remaining elements so that they are multiples of it If the minimum is then the resulting elements should be divisible by There are such numbers between and and we have to choose elements out of since is already chosen The number of ways to do it can be calculated by precomputing factorials modulo since it is a binomial coefficient On the one hand since if all elements in the array are divisible by some element nothing depends on the order of these elements On the other hand suppose there exists an element such that it is not divisible by Let s take and two following reorders of the array and For the first array we get which is non zero and for the second array so the result is zero 
You are given a board of size rows columns Some cells of the board contain chips The chip is represented as and an empty space is represented as It is guaranteed that there is at least one chip on the board In one move you can choose chip and move it to any adjacent by side cell of the board if this cell is inside the board It means that if the chip is in the first row you can move it left right or down but it shouldn t leave the board Same if the chip is in the second row you can move it left right or up If the chip moves to the cell with another chip the chip in the destination cell disappears i e our chip captures it Your task is to calculate the number of moves required to leave one chip on the board You have to answer independent test cases ,Firstly I want to say a few words about the difficulty of this problem Till the last moment we didn t know easy to prove and easy to write solutions so we decided that this is a good problem E But now we realized it is a lot easier than we expected Now let s talk about the solution At the beginning let s remove redundant columns from the beginning and from the end i e columns without chips and change the value correspondingly Now let be if is and otherwise This array needed to make the implementation easier Let s calculate the dynamic programming where is the index of the last processed column and is the number of the row where our chip is standing This seems a bit suspicious why we can calculate such a dynamic programming so let s explain some things about it It can be shown that in the optimal answer there will be some column where the last move happens And if the number of this column is then all chips to the left of will move only to the right and all chips to the right of will move only to the left Actually we can always consider that is the last column Consider paths of two chips that will survive till the last move The first chip is to the left of and will move only to the right and the second one is to the right of and will move only to the left Then we can replicate the path of the second chip in the reverse order using the first chip So the second chip can stay still until the last move In the optimal answer it is always better to have exactly one chip in the current column because moving two chips to the right is always worse than just eat one of them and move the remaining one Initial states of are except the values of the first column For the first column and The answer will be Okay how to make transitions from For all from to let s consider four cases here we need one move to go to the next column and probably one more move to delete the figure in the second row in the column So the transition seems like same as the previous transition because the cost of this transition is always the distance between these cells is we just go firstly to the right and then down to ensure that we eat the figure in the first row So the transition is same as the previous transition Time complexity 
You are given a matrix consisting of rows and columns Each cell of the matrix is either free or taken A free cell is reachable from a free cell if at least one of these conditions hold and share a side there exists a free cell such that is reachable from and is reachable from A connected component is a set of free cells of the matrix such that all cells in it are reachable from one another but adding any other free cell to the set violates this rule You are asked queries about the matrix Each query is the following count the number of connected components of the matrix consisting of columns from to of the matrix inclusive Print the answers to all queries ,Consider the naive approach to the problem Cut off the columns directly and count the connected components There are two main solutions to this problem either DFS or BFS or DSU I personally found the DSU method easier to adjust to the full problem So to count connected components with DSU you should do the following Initialize the structure without edges every free cell is its own connected component Then add edges one by one Each edge connects two cells either vertically or horizontally When an edge connects different components they merge and the number of components decreases by one Thus the number of components on a range of columns is the number of free cells on it minus the number of meaningful edges on it the ones that will merge components if the algorithm is performed only on these columns the spanning forest edges Let s try to adjust this algorithm to the full problem It would be great if we could just calculate the spanning forest of the entire matrix and then print the number of free cells minus the number of its edges on the segment Unfortunately it s not as easy as that For components that lie fully in the segment it works However if a component is split by a border of a segment it can both stay connected or fall apart If we determine its outcome we can fix the answer There are probably a lot of ways to adjust for that but I ll tell you the one I found the neatest to code Let s add the edges into DSU in the following order Go column by column left to right First add all vertical edges in any order then all horizontal edges to the previous column in any order If you start this algorithm at the first column you will be able to answer all queries with Since the algorithm adds columns iteratively the spanning forest it s building is correct after every column So the answer for each query is indeed the number of cells minus the number of edges on the range Let s investigate the difference between starting at the first column and an arbitrary column Look at the column If it contains or free cells or that are adjacent then the cells are always in the same component regardless of what has been before column If there are no free cells nothing to the left matters too This tells us that the spanning forest that the first algorithm has built is correct for any queries that start in this The only non trivial case is when only rows and of the th column contain a free cell Then we can t tell if the algorithm is correct or not because these two cells can be in the same component already or not Let s call this a column Imagine you started processing from the leftmost column of the query left to right to the rightmost column Our previous observations tell us that once we encounter a column that is not a the algorithm onwards will be correct Until then we only have some columns to deal with We can add the part from the first non column onwards to the answer the number of cells minus the number of edges And then handle the prefix with some easy casework if the leftmost column is not then add nothing if all columns in the query are then the answer is if the first non column is then add nothing since the s get merged into the component of this column if the first non column is or then add components since neither row nor row is merged anywhere otherwise add component The number of free cells and edges on a segment can be precalculated with some prefix sums The closest non column can also be precalculated with a linear algorithm Overall complexity 
 A permutation of length is an array of integers such that every integer from to appears in it exactly once An element of permutation is reachable from element if or or and so on The of a permutation is defined as follows firstly we have a permutation all elements of which are and an empty list Then we do the following while there is at least one element in we find the leftmost such element list all elements that are reachable from it mark all of these elements then cyclically shift the list of those elements so that the maximum appears at the first position and add this list of After all elements are marked is the result of this decomposition For example if we want to build a decomposition of we do the following initially bold elements are marked the leftmost unmarked element is and are reachable from it so the list we want to shift is there is no need to shift it since maximum is already the first element the leftmost unmarked element is the list of reachable elements is the maximum is already the first element so there s no need to shift it the leftmost unmarked element is the list of reachable elements is we have to shift it so it becomes all elements are marked so is the result The of a permutation is defined as follows we build the decomposition of this permutation then we sort all lists in decomposition in ascending order of the first elements we don t swap the elements in these lists only the lists themselves then we concatenate the lists into one list which becomes a new permutation For example the of is built as follows the decomposition is after sorting the decomposition it becomes is the result of the transformation We call a permutation if the result of its transformation is the same as the permutation itself For example is a good permutation and is bad since the result of transformation is Your task is the following given and find the th lexicographically good permutation of length ,Let s calculate cycle n the number of permutations of length n which have a maximum at the position 1 and consist of exactly one cycle Each good permutation can be divided into such blocks so we ll need this value later It is easy to notice that cycle n n 2 Let s calculate the following dynamic programming dp i the number of good permutations consisting of elements i n To calculate dp i let s iterate over j the maximum element of the first block it determines the length of this block j i 1 dp i sum j i n dp j 1 cdot cycle j i 1 Now let s use the standard method of lexicographic recovery We will iterate over which element to put next it immediately determines the size of the new block and all the elements in it If the number of permutations starting with such block is at least k then you need to restore this block entirely and reduce the task to the one without this block Otherwise you need to subtract the number of permutations starting on such block from k and proceed to the next option for the block We will also use lexicographic recovery to restore the block You must carefully maintain the current block so that it consists of exactly one cycle To do this you can use DSU or explicitly check for a cycle 
The New Year holidays are over but Resha doesn t want to throw away the New Year tree He invited his best friends Kerim and Gural to help him to redecorate the New Year tree The New Year tree is an undirected tree with vertices and root in the vertex You should process the queries of the two types Change the colours of all vertices in the subtree of the vertex to the colour Find the number of different colours in the subtree of the vertex ,Let s run dfs on the tree and write out the vertices in order of their visisiting by dfs that permutation is called Euler walk Easy to see that subtree of any vertex is a subsegment of that permutation Note that the number of different colours is so we can store the set of colours just as mask of binary bits in bit type long long in C long in Java Let s build the segment tree over the permutation which supports two operations paint subsegment by some colour and find the mask of colours of some segment 
There are points on an infinite plane The th point has coordinates such that and The coordinates are not necessarily integer In one move you perform the following operations choose two points and move point from to either or move point from to either or remove points and Otherwise the move can t be performed and the points stay at their original coordinates and respectively The numeration of points after some points are removed Once the points are removed they can t be chosen in any later moves Note that you have to move both points during the move you can t leave them at their original coordinates What is the maximum number of moves you can perform What are these moves If there are multiple answers you can print any of them ,At first the problem sounds like some sort of matching However it seems like you first want to match each point with either of its moves and then some pairs of points to each other That doesn t sound viable but since the matchings are often connected with graphs the graph idea might come handy Let s first consider a pair of matched points What does it actually mean that there exists a line through their new coordinates and It s the same as the angles of a line through the new coordinates of and and a line through the new coordinates of and are the same Angles are the same means that their tangents are the same and vice versa since we only consider the first quadrant of the plane So we can conclude that or of the first point should be equal to any of these of the second point Now consider the following graph Various values of tangents of the lines are the nodes Each point produces an edge between their and What are the matched pairs of points in this graph It s such a pair of edges that they share at least one endpoint Building a graph is the slowest part of the solution since you have to use some data structure or at least a sort and a binary search is possible with some sort of hashmap but should be perfectly fine as well So we reduced the problem to a more well known one given an arbitrary undirected graph find the maximum number of pairs of edges such that each pair shares at least one endpoint and each edge is included in no more than one pair The upper bound on the answer is the following Let be the number of edges in the th connected component Best case we can make pairs from it Let s come up with an algorithm to achieve this bound Consider a dfs tree of a component It s known that a dfs tree of an undirected graph contains no cross edges So if we direct all the edges of a dfs tree downwards convert all back edges to forward edges each edge will connect some vertex to its descendant Imagine we came up with a dfs such that matches all the edges that have their upper node in the subtree of to each other except one edge in case there is an odd number of them will solve the task exactly then How should that dfs work exactly What if there were no forward edges at all That case is easy since all edges are tree edges We ll try to maintain an invariant that the only unmatched edge is an edge that has as one of its endpoints If is a leaf then there s nothing to match Otherwise we go into some child If it can t match all its edges then match its remaining edge to an edge If it can then remember that we have an edge unmatched so far Go into another child Same match our edge with its edge if it has one unmatched However if turned out to get unmatched and turned out to be unmatched then you can match them to each other This way you will be left with at most one unmatched edge after you process all the children and that edge has its endpoint at Add the forward edges back Did anything change Look at the forward edge that has its upper vertex the lowest We can see that it points to a vertex that has its subtree fully matches So why don t we treat this forward edge the same as an edge to a leaf Forget that has some subtree of its own and just believe that you can t match the edge so far Proceed the same as the easy case Since we mark exactly which edges you pair up with which it s trivial to retrieve the answer Overall complexity 
Let s denote that some array is if it contains a subarray of odd length more than and is odd such that If an array is not bad it is Now you are given an array Some elements are replaced by Calculate the number of good arrays you can obtain by replacing each with some integer from to Since the answer can be large print it modulo ,At first array contains a palindromic subarray of length is equivalent to array contains a palindromic subarray of length So we need to calculate number of arrays without palindromes of length It s equivalent to finding arrays where for all appropriate Note that and have same parity so all odd and all even positions in array are independent and answer is the product of the number of ways to choose numbers for odd positions and the number of ways to choose numbers for even positions In terms of same parity our condition morphs to and we need to calculate all ways to replace s in such way that all pairs of consecutive elements are different To calculate it let s look at sequences of consecutive s They will look like with s where and are positive case where is empty can be considered as case with empty is solved the same way In the end we need to find a way to calculate the number of those sequences There are only two fundamental types of sequences same value from both ends and Exact values of and don t really matter Let s find a way to calculate both values name them and for consecutive s in time Base values Let s try to choose value of in the middle of sequence if then we can split sequence in two sequences of length and and If then just iterate over value of last then and Resulting complexity is 
You are given patterns and strings Each pattern consists of characters that are either lowercase Latin letters or wildcard characters denoted by underscores All patterns are pairwise distinct Each string consists of lowercase Latin letters A string matches a pattern if for each from to either is a wildcard character or You are asked to rearrange the patterns in such a way that the first pattern the th string matches is You are allowed to leave the order of the patterns unchanged Can you perform such a rearrangement If you can then print any valid order ,Let s write down the indices of the pattern that the th string matches If is not among these then the answer is Otherwise all the patterns except should go in the resulting ordering after Consider that as a graph Let s add an edge from to each of the matches If you add the edges for all the strings then the topological ordering of the graph will give you the valid result If the graph has any cycles in it you can t topsort it then there is no answer To find all the patterns we can use the fact that is rather small Consider all the binary masks of length Each mask can correspond to a set of positions in the string that are replaced with wildcards Now if there is a pattern that is exactly equal to the string with the fixed set of positions replaced by wildcards then that pattern is a match To search for an exact match you can either store all patterns in a map beforehand or in a sorted array or build a trie of them The second version is faster by a factor of but both solutions should pass easily Overall complexity or 
Mishka received a gift of multicolored pencils for his birthday Unfortunately he lives in a monochrome world where everything is of the same color and only saturation differs This pack can be represented as a sequence of integer numbers saturation of the color of each pencil Now Mishka wants to put all the mess in the pack in order He has an infinite number of empty boxes to do this He would like to fill some boxes in such a way that Each pencil belongs to one box Each non empty box has at least pencils in it If pencils and belong to the same box then where means absolute value of Note that the opposite is optional there can be pencils and such that and they belong to different boxes Help Mishka to determine if it s possible to distribute all the pencils into boxes Print if there exists such a distribution Otherwise print ,At first you need to sort the sequence Then if there exists some answer there also exists an answer such that every box in it contains some segment of pencils Now it s pretty standard dp approach Let be if it s possible to distribute the first pencils into boxes correctly otherwise initially Now you can come up with straightforward implementation Let s iterate over every and set to if for some and Now we should optimize it a bit Notice that the second and the third conditions actually form some segment of indices You need to check if there is at least one value on this segment This can be maintained with two pointers set BIT segment tree Anything you can code to get update in point and sum max on segment queries Overall complexity 
You are given a permutation an array where each integer from to appears exactly once The weight of the th element of this permutation is At first you separate your permutation into two sets prefix and suffix More formally the first set contains elements the second where After that you may move elements between sets The operation you are allowed to do is to choose some element of the first set and move it to the second set or vice versa move from the second set to the first You have to pay dollars to move the element Your goal is to make it so that each element of the first set is less than each element of the second set Note that if one of the sets is empty this condition is met For example if and then the optimal strategy is separate into two parts and and then move the element into first set it costs And if then the optimal strategy is separate into two parts and and then move the element into first set it costs and element into second set it also costs Calculate the minimum number of dollars you have to spend , All elements in the left set smaller than all elements in the right set means that there is such value that all elements from the first set less than and all elements from the second set are more or equal to So let s make a sweep line on from to while trying to maintain all answers for each prefix Let s maintain for each the total cost to make sets good if we split the permutation on sets and in such way that after transformations all elements in the first set less than It s easy to see that the total cost is equal to sum of weights where and and where and So what will happen if we increase by Let s define the position of as For each we don t need to move to the second set anymore so we should make On the other hand for each we need to move from the second set to the first one now so we should make The answer will be equal to the It means that we should handle two operations add some value on the segment and ask minimum on the segment So we can store all in pretty standart Segment Tree with add on segment and minimum on segment while iterating over So the total complexity is 
This year Alex has finished school and now he is a first year student of Berland State University For him it was a total surprise that even though he studies programming he still has to attend physical education lessons The end of the term is very soon but unfortunately Alex still hasn t attended a single lesson Since Alex doesn t want to get expelled he wants to know the number of working days left until the end of the term so he can attend physical education lessons during these days But in BSU calculating the number of working days is a complicated matter There are days left before the end of the term numbered from to and initially all of them are working days Then the university staff sequentially publishes orders one after another Each order is characterised by three numbers and If then all days from to inclusive become non working days If some of these days are made working days by some previous order then these days still become non working days If then all days from to inclusive become working days If some of these days are made non working days by some previous order then these days still become working days Help Alex to determine the number of working days left after each order ,Let s store current intervals with non working days in set sorted by the right border When new query comes you search for the first interval to have its right border greater or equal than the currect left border and update all intervals to intersect the query either fully delete or insert back its part which doesn t intersect query Finally if then insert the query into current set Updates on the number of working days can be done while deleting segments on the fly Overall complexity 
Calculate the number of ways to place rooks on chessboard so that both following conditions are met each empty cell is under attack exactly pairs of rooks attack each other An empty cell is under attack if there is at least one rook in the same row or at least one rook in the same column Two rooks attack each other if they share the same row or column For example there are only two pairs of rooks that attack each other in the following picture Two ways to place the rooks are considered different if there exists at least one cell which is empty in one of the ways but contains a rook in another way The answer might be large so print it modulo ,If we want to place n rooks on an n times n chessboard so all empty cells are under attack then either each row or each column should contain at least one rook Let s suppose that each row contains at least one rook and multiply the answer by 2 in the end How to ensure that there are exactly k pairs of rooks attacking each other Since each row contains exactly one rook only the rooks in the same column attack each other moreover if there are x rooks in a non empty column they create x 1 pairs So our goal is to distribute n rooks to n k columns so that each column contains at least one rook How to calculate the number of ways to distribute the rooks into c columns One of the options is to choose the columns we use the number of ways to do this is n choose c and then use inclusion exclusion to ensure that we are counting only the ways where each column contains at least one rook The formula we will get is something like sum limits i 0 c 1 i c choose i c i n we want to fix the number of columns that will not contain rooks that is i which are these columns that is c choose i and how many are there ways to distribute the rooks among remaining columns that is c i n Are we done Almost We wanted to multiply the answer by 2 to count the ways where each column contains at least one rook but we should not do it if k 0 because in this case each placement of the rooks has exactly one rook in each row and exactly one rook in each column 
Ivan is a programming teacher During the academic year he plans to give lectures on different topics Each topic should be used in exactly one lecture Ivan wants to choose which topic will he explain during the st nd th lecture formally he wants to choose some permutation of integers from to let s call this permutation is the index of the topic Ivan will explain during the th lecture For each topic except there exists a prerequisite topic for the topic the prerequisite topic is Ivan cannot give a lecture on a topic before giving a lecture on its prerequisite topic There exists at least one valid ordering of topics according to these prerequisite constraints Ordering the topics correctly can help students understand the lectures better Ivan has special pairs of topics such that he knows that the students will understand the th topic better if the lecture on it is conducted the lecture on the th topic Ivan wants to satisfy the constraints on every such pair that is for every there should exist some such that and Now Ivan wants to know if there exists an ordering of topics that satisfies all these constraints and if at least one exists find any of them ,The prerequisites for each lecture form a rooted tree so let s forget about the legend and learn how to find such an order of vertices of a tree that all conditions work Let s introduce some algorithm that produces an ordering of vertices for every possible case If any valid ordering exists it should produce a valid one So we will only have to check if the resulting ordering is fine and output it if it is If there were no special pairs the task would be perfectly solvable with an algorithm of topological sorting Thus let s come up with a way to modify the graph so that topsort could still be a solution We know that the vertices that are in the special pairs should follow each other in the ordering Look at these special pairs as edges as well Let s first imagine they are undirected These edges connect some vertices in the tree into components Each component should be a segment of vertices in a valid answer So how about we compress them into one vertex first each find some answer for a compressed version and decompress them back Let each of these connected components be a vertex in the new graph Two components are connected by an edge if there is a edge in the tree between vertices of the corresponding components Topsort in this graph will tell us the order the components should go However we should also find the order the vertices should go inside each component Let s topsort the graph of all directed special pairs and sort the vertices in that order in every component We can sort the entire graph instead of sorting each component separately because the components are totally independent Finally write down the answer iterate over the compressed vertices of the first new graph in the order of its topsort for each one write down all the actual vertices inside it in the order of the topsort of the second new graph Check if each vertex has its parent earlier than itself in the answer If all the graphs were topologically sortable and that holds then the answer exists and we found it Otherwise the answer doesn t exist Overall complexity O n log n 
 teams participate in a playoff tournament The tournament consists of games They are held as follows first of all the teams are split into pairs team plays against team team plays against team exactly in this order and so on so games are played in that phase When a team loses a game it is eliminated and each game results in elimination of one team there are no ties After that only teams remain If only one team remains it is declared the champion otherwise games are played in the first one of them the winner of the game vs plays against the winner of the game vs then the winner of the game vs plays against the winner of the game vs and so on This process repeats until only one team remains After the tournament ends the teams are assigned places according to the tournament phase when they were eliminated In particular the winner of the tournament gets place the team eliminated in the finals gets place both teams eliminated in the semifinals get place all teams eliminated in the quarterfinals get place all teams eliminated in the 1 8 finals get place and so on For example this picture describes one of the possible ways the tournament can go with and the resulting places of the teams After a tournament which was conducted by the aforementioned rules ended its results were encoded in the following way Let be the place of the th team in the tournament The hash value of the tournament is calculated as where is some given integer Unfortunately due to a system crash almost all tournament related data was lost The only pieces of data that remain are the values of and You are asked to restore the resulting placing of the teams in the tournament if it is possible at all ,There are exactly games in the tournament each game has only two possible outcomes So it s possible to bruteforce all possible ways the tournament could go if is not large In fact this solution is fast enough when so if we somehow can handle the case we will have a working solution To handle let s divide the teams into two groups teams from to and teams from to There will be exactly matches in each group and the winners of these two groups will play in the finals The number of possible ways the games in a group can go is just so let s try to bruteforce all possible results in each group and somehow merge them into the results of the whole tournament The main idea is to rewrite as where and find all possible values for and and choose a pair of values that yields exactly the given value of We will handle two separate cases the winner of the first group wins the whole tournament or the winner of the second group wins the whole tournament Suppose we are handling the first case the second is symmetrical By choosing the results of matches in the first group we determine the places of the teams from the first group the winner of the first group gets place the team eliminated in the last match of the first group gets place and so on It means that by choosing one of the possible results in the first group we can calculate Let s bruteforce these combinations of results in the first group and store them in some data structure that allows to check whether some value of is achievable in the model solution it s a which maps reachable values of to combinations of results that yield these values Then by choosing the results of matches in the second group we can calculate so the remaining part of the solution is to bruteforce all possible results in the second group calculate for them and check that such that can be achieved by choosing the results in the first group Don t forget to also handle the case when the team which wins in the first group loses in the finals it is almost the same but the winner in the first group gets place and the winner in the second group gets place The technique I ve described here instead of bruteforcing all possible variants split the thing we try to bruteforce into two parts bruteforce them separatedly and then try to merge the parts is called and can be used to solve a large variety of problems 
Polycarp has recently got himself a new job He now earns so much that his old wallet can t even store all the money he has Berland bills somehow come in lots of different sizes However all of them are shaped as rectangles possibly squares All wallets are also produced in form of rectangles possibly squares A bill fits into some wallet if either and or and Bills can overlap with each other in a wallet and an infinite amount of bills can fit into a wallet That implies that all the bills Polycarp currently have fit into a wallet if every single one of them fits into it independently of the others Now you are asked to perform the queries of two types Polycarp earns a bill of size Polycarp wants to check if all the bills he has earned to this moment fit into a wallet of size It is guaranteed that there is at least one query of type before the first query of type and that there is at least one query of type in the input data For each query of type print if all the bills he has earned to this moment fit into a wallet of given size Print otherwise ,Let s find the smallest wallet to fit all bills One its side is the maximum side of any bill Now we orient the bills in such a way that their longer side is put against this side of the wallet The second side of the wallet is the maximum of the other sides More formally for set of bills for each the minimum wallet is The minimum wallet fits all sufficient wallets So the solution is maintaining the maximum of all and and checking if and Choose your i o functions wisely Overall complexity 
Adilbek s house is located on a street which can be represented as the OX axis This street is really dark so Adilbek wants to install some post lamps to illuminate it Street has positions to install lamps they correspond to the integer numbers from to on the OX axis However some positions are blocked and no post lamp can be placed there There are post lamps of different types which differ only by their power When placed in position post lamp of power illuminates the segment The power of each post lamp is always a positive integer number The post lamp shop provides an infinite amount of lamps of each type from power to power Though each customer is only allowed to order post lamps of type Post lamps of power cost each What is the minimal total cost of the post lamps of type Adilbek can buy to illuminate the entire segment of the street If some lamps illuminate any other segment of the street Adilbek does not care so for example he may place a lamp of power in position even though its illumination zone doesn t completely belong to segment ,Let s start with learning how to place lamps of fixed power to cover the segment with the minimal number of them The following greedy strategy works find the rightmost non blocked position that is covered by lamps and place lamp there until either everything is covered or rightmost free position is to the left of the last placed lamp Initially you only consider to be covered Function the minimal number of post lamps to cover segment is clearly monotonous thus you want to update states as early as possible Okay now you iterate over all and update the answer with the results multiplied by cost Now why will this work fast You obviously precalculate the rightmost free position for each prefix segment If there are any free positions to the right of last placed lamp then the rightmost of them will always be the rightmost for the entire prefix segment Finally any two consecutive iterations of the algorithm will either move you by positions or return This can be easily proven by contradiction Overall complexity as you do about steps for each and that is a common series sum 
You are given a string consisting of lowercase Latin letters You are asked queries about it given another string consisting of lowercase Latin letters perform the following steps concatenate and calculate the prefix function of the resulting string print the values of the prefix function on positions and denote the lengths of strings and respectively revert the string back to The prefix function of a string is a sequence where is the maximum value of such that and denotes a contiguous substring of a string from a position to a position inclusive In other words it s the longest proper prefix of the string that is equal to its suffix of the same length ,What s the issue with calculating the prefix function on the string and then appending the string with an extra recalculations Calculating prefix function is linear anyway Well it s linear but it s also amortized So while it will make operations for a string in total it can take up to on every particular letter These particular letters can appear in string making the algorithm work in Let s analyze the classic way to calculate the prefix function To append a character to the string and calculate the new value of the prefix function you have to do the following take the longest proper prefix of a string before appending the letter which is also a suffix if the letter right after it is the same as the new one then the new value is length of it plus one if it s empty then the new value is otherwise take its longest proper prefix and return to step Basically from having the value of the prefix function of the string and the new letter you can determine the new value of the prefix function If was always equal to then you would only want to try all options for the next letter after a string That should remind you of a structure known as prefix function automaton Its states are the values of the prefix function and the transitions are appending a letter to a string with a certain value of the prefix function So you can append a letter in if you have an automaton built on the string However you can t just append more letters after one you don t have the automaton built this far You can follow two paths The first one is to jump with a regular way of calculating the prefix function until you reach the state of the automaton which exists The second one is to continue building the automaton onto the string calculating the prefix function along the way Appending a layer to the automaton takes non amortized After you calculated everything you needed pop the states back to the original Overall complexity or 
You are given a rooted tree of vertices Every vertex of this tree has either children or children All leaves of this tree have the same distance from the root and for every non leaf vertex one of its children is the left one and the other child is the right one Formally you are given a The vertices of the tree are numbered in the following order the root has index if a vertex has index then its left child has index and its right child has index Every vertex of the tree has a letter written on it either or Let s define the character on the vertex as Let the of some vertex be defined in the following way if the vertex is a leaf then the of be consisting of only one character otherwise the of is where operator defines concatenation of strings is the of the left child of and is the of the right child of The of the tree is the of its root You have to calculate the number of different strings that can be obtained as the of the given tree if you are allowed to perform the following operation any number of times before constructing the of the tree choose any non leaf vertex and swap its children so the left child becomes the right one and vice versa ,In terms of preorder strings the operation swap two children of some vertex means swap two substrings of equal length in some specific location This operation can be inverted by applying it an additional time so for every positive integer all of the strings of length are split into equivalence classes in such a way that two strings from the same class can be transformed into each other and two strings from different classes cannot For each vertex the set of its possible preorder strings is one of these classes Let s calculate the answer for the problem recursively let be the number of preorder strings for the vertex For a leaf the number of its preorder strings is For a vertex with children and one of the two holds if the equivalence class for vertex is different from the equivalence class for vertex then we have to pick a string from the class of vertex pick a string from the class of vertex and choose the order in which we take them So if the equivalence class for is the same as the equivalence class for then swapping and doesn t do anything so we pick a string from the equivalence class of and then a string from the equivalence class of So The only thing we don t know is how to determine if two vertices represent the same equivalence class The model solution uses hashing for this but there s a much simpler method for each vertex let be the lexicographically smallest string that can be a preorder string of If a vertex has children and then and we can calculate these strings recursively since the total length is each of characters will be present in strings 
Johnny is playing a well known computer game The game are in some country where the player can freely travel pass quests and gain an experience In that country there are islands and bridges between them so you can travel from any island to any other In the middle of some bridges are lying ancient powerful artifacts Johnny is not interested in artifacts but he can get some money by selling some artifact At the start Johnny is in the island and the artifact dealer is in the island possibly they are on the same island Johnny wants to find some artifact come to the dealer and sell it The only difficulty is that bridges are too old and destroying right after passing over them Johnnie s character can t swim fly and teleport so the problem became too difficult Note that Johnny can t pass the half of the bridge collect the artifact and return to the same island Determine if Johnny can find some artifact and sell it ,Edge biconnected component in an undirected graph is a maximal by inclusion set of vertices so that there are two edge disjoint paths between any pair of vertices Consider the graph with biconnected components as vertices Easy to see that it s a tree if it contains some cycle then the whole cycle is a biconnected component All edges are destroying when we passing over them so we can t returnto the same vertex in the tree after leaving it by some edge Consider the biconncted components that contains the vertices and Let s denote them and Statement the answer is YES if and only if on the path in the tree from the vertex to the vertex there are an edge with an artifact or there are a biconnected component that contains some edge with an artifact Easy to see that the statement is true if there are such edge then we can pass over it in the tree on the path from to or we can pass over it in biconnected component The converse also easy to check Here is one of the ways to find edge biconnected components Let s orient all edges to direction that depth first search passed it for the first time Let s find in new directed graph strongly connected components Statement the strongly connected components in the new graph coincide with the biconnected components in old undirected graph Also you can notice that the edges in tree is the bridges of the graph bridges in terms of graph theory So you can simply find the edges in the graph 
You are given an array consisting of integers and an integer It is guaranteed that for every Let s denote a function which erases all values such that from the array and returns the resulting array For example if then Your task is to calculate the number of pairs such that and is sorted in non descending order Note that the empty array is also considered sorted ,Lets find the maximum number such that all values form the non descending order array It can be done the following way Let values form the non descending order array Then values will form the non descending order array if the first occurrence of in array is after the last occurrence of In similar manner we can find the minimum number such that all values form the non descending order array Now let s find out how to get the minimum number such that all values form the non descending order array if we fixed the value We denote this value for some fixed value as Firstly conditions and should hold Secondly there should be no such a pair that conditions and hold Since the condition is satisfied it means that must be greater than where is the last occurrence of in array In this way the answer is 
Monocarp is going to host a party for his friends He prepared dishes and is about to serve them First he has to add some powdered pepper to each of them otherwise the dishes will be pretty tasteless The th dish has two values and its tastiness with red pepper added or black pepper added respectively Monocarp won t add both peppers to any dish won t add any pepper multiple times and won t leave any dish without the pepper added Before adding the pepper Monocarp should first purchase the said pepper in some shop There are shops in his local area The th of them has packages of red pepper sufficient for servings and packages of black pepper sufficient for servings Monocarp goes to exactly one shop purchases multiple possibly zero packages of each pepper in such a way that More formally if he purchases red pepper packages and black pepper packages then and should be non negative and should be equal to For each shop determine the maximum total tastiness of the dishes after Monocarp buys pepper packages only in this shop and adds the pepper to the dishes If it s impossible to purchase the packages in the said way print ,Let s start by learning how to answer a query all red pepper and black pepper options are available Let s iterate over all options to put the peppers and choose the maximum of them First let s use the red pepper for all dishes Now we want to select some of them to use black pepper instead of red pepper Which ones do we choose When we switch from the red pepper to the black pepper the total tastiness changes by for the th dish They are completely independent of each other so we want to choose largest of these values Let be the sequence of values of in a non increasing order Thus black peppers will yield the result of We can answer a query by looking for a maximum in the sequence Now consider an arbitrary query Let be all options for the amount of available black peppers for the query Naively we could iterate over all of them and choose the maximum one However notice an interesting thing about the sequence of the answers By definition it is non strictly convex In particular one idea that can be extracted from this is the following Find the position of an arbitrary maximum in this sequence Then everything to the left of is is non increasing Everything to the right of it is non increasing Thus for a query it s enough to consider only two options the one closest to the maximum from the left and from the right Now we only have to learn how to get these options fast enough For a query we want to solve what s called a diophantine equation An arbitrary solution can be obtained by using extended Euclid algorithm Let it be some Then we would want to check the answer for black peppers The amount of solutions to the equation is either infinite or zero If it s infinite all solutions will be of the form for any integer Remember that not all the solutions will be in a range Finally find the two solutions that are the closest to the maximum check that they are in the range and print the best answer of them Overall complexity 
You have an array of integers initially empty You have to perform queries Each query is of one of two types add the element to the end of the array replace all occurrences of in the array with Find the resulting array after performing all the queries ,Let s solve the problem from the end Let s maintain the array what number will become if we apply to it all the already considered queries of type If the current query is of the first type then we simply add to the resulting array If the current query is of the second type then we have to change the value of Since all occurrences of must be replaced with it is enough to assign Since we process each query in the final complexity is There is also an alternative solution Let s process queries in the direct order Let s store all its positions in an array for each number Then for the first query it is enough to put the index in the corresponding array of positions And for a query of the second type we have to move all the positions of the number into an array of positions of the number The naive implementation is obviously too slow but we can use the small to large method then the complexity of the solution will be 
There is a light source on the plane This source is so small that it can be represented as point The light source is moving from point to the with speed equal to unit per second The trajectory of this light source is a straight segment connecting these two points There is also a fence on axis represented as segments so the actual coordinates of endpoints of each segment are and The point is if segment connecting and the current position of the light source intersects or touches with any segment of the fence You are given points For each point calculate total time of this point being in the shade while the light source is moving from to the ,Let s calculate the answer for a fixed point If you project with respect of each segment of the fence to the line containing light source you can see that the answer is the length of intersection of fence projection with segment of the trajectory light source Key idea is the fact that the length of each fence segment is multiplied by the same coefficient On the other hand fence segments whose projections lie inside form a subsegment in the array of segments so its total length can be obtained with partial sums And at most two fence segment are included in the answer partially their positions can be calculated with lower bound if you project points and on axis So now you can answer the query with time and quite small hidden constant and resulting complexity is 
Each evening Roma plays online poker on his favourite website The rules of poker on this website are a bit strange there are always two players in a hand there are no bets and the winner takes virtual bourle from the loser Last evening Roma started to play poker He decided to spend no more than virtual bourles he will stop immediately if the number of his loses exceeds the number of his wins by Also Roma will leave the game if he wins enough money for the evening i e if the number of wins exceeds the number of loses by Next morning Roma found a piece of paper with a sequence on it representing his results Roma doesn t remember the results exactly and some characters in the sequence are written in a way such that it s impossible to recognize this character so Roma can t recall whether he won bourles or he lost The sequence written by Roma is a string consisting of characters Roma won the corresponding hand Roma lost draw and unknown result Roma wants to restore any sequence by changing all characters to or The sequence is called if all these conditions are met In the end the absolute difference between the number of wins and loses is equal to There is no hand such that the absolute difference before this hand was equal to Help Roma to restore any such sequence ,This problem can be solved using dynamic programming is if Roma could play first games with balance is and for each such that and we update if if if and all three states if If either of and is then we can restore the sequence Time and memory complexity is As an exercise you can think about linear solution 
You are given two integers and Your task is to calculate the sum of numbers from to including and such that each number contains different digits and print this sum modulo For example if then you have to calculate all numbers from to such that each number is formed using only one digit For the answer is ,Let s calculate the answer as the sum of suitable numbers in range minus the sum of suitable numbers in range Now our problem is to calculate the sum of suitable numbers in range The main approach for problem is digit DP Let s calculate two dynamic programmings and means that now we are at the th digit of the number at the digit corresponding to where is the decimal length of a number is a binary mask describing digits we already use and equals if the current prefix of number we trying to obtain is the same as the prefix of number otherwise equals So what means It means the count of numbers in general not numbers but their prefixes in range of length without leading zeroes corresponding to this state So what the point of this DP Its point is helping us to calculate the main DP which means the sum of numbers in general not numbers but their prefixes in range of length without leading zeroes corresponding to this state How do we calculate the answer Firstly let be the length of Let be the function calculating the sum of numbers from to containing at most different digits How to calculate it Let be the sum of numbers from to containing at most different digits and having length exactly Then seems to be pretty easy for each length from to add to the answer And the last step is to add to the answer How to calculate dynamic programmings Initially all states are zeroes excluding which is Firstly let s calculate After calculating it we can calculate in almost the same way Let s iterate over all possible lengths and over all possible masks Let the current state is Then let s iterate over next digit we will place in this number and place it If then otherwise The transition is pretty easy There is the bitwise operation For transitions are almost the same expect the restrictions on digit we place and the state we update If we now at the position with mask and then the current digit of is Then let s iterate over next digit if otherwise The transition is also easy After calculating the previous DP we can calculate All the process is the same as in the previous dynamic programming expect the value we will add in transitions In the previous DP this value was equal in the current DP this value equals to Don t forget to calculate it modulo So after calculating all the values of DPs what is the answer for It is for all masks with at most bits I m pretty sure that there is another way to avoid leading zeroes in calculating these DPs but this one is very straight forward and simple 
After several latest reforms many tourists are planning to visit Berland and Berland people understood that it s an opportunity to earn money and changed their jobs to attract tourists Petya for example left the IT corporation he had been working for and started to sell souvenirs at the market This morning as usual Petya will come to the market Petya has different souvenirs to sell th souvenir is characterised by its weight and cost Petya knows that he might not be able to carry all the souvenirs to the market So Petya wants to choose a subset of souvenirs such that its total weight is not greater than and total cost is maximum possible Help Petya to determine maximum possible total cost ,There are lots of different solutions for this problem We can iterate on the number of elements we will take in this editorial element is a souvenir with weight When fixing the number of elements let it be we want to know the best possible answer for the weight while taking into account only elements and elements To answer these queries we can precalculate the values triples where is the best possible answer for the weight and and is the number of elements and elements we are taking to get this answer Of course and we can update and using value of After precalculating for each possible we can iterate on the number of elements There are also several binary ternary search solutions 
Consider some set of distinct characters and some string consisting of exactly characters where each character is present in You are given an array of integers You are allowed to perform the following move on the string Choose some valid and set Take the first characters of Take the last characters of Substitute the first characters of with the reversed Substitute the last characters of with the reversed For example let s take a look at and Reversed Thus the resulting is The move can be performed arbitrary number of times possibly zero Any can be selected multiple times over these moves Let s call some strings and equal if and only if there exists such a sequence of moves to transmute string to string For the above example strings and are equal Also note that this implies The task is simple Count the number of distinct strings The answer can be huge enough so calculate it modulo ,Let s take a look at any operation You can notice that each letter can only go from position to indexed Then doing some operation twice is the same as doing that operation zero times Now consider some set of operations sorted in increasing order Actually they do the following altogether Replace segment with the reversed segment and vice versa Then replace segment with the reversed segment and vice versa And continue until you reach the first pair Segment might also be included in the answer when the parity is right Moreover every subset of segments is achievable So for each segment you can either swap it or not Let s translate it to math language Let be the number of such pairs of strings and that Why is there such an order You want to consider only unique strings thus you need to pick exactly one of equal strings from each component Let it be the smallest one Then for each segment of the set you have pairs to choose from where is the length of that segment And that part of the formula is However the part covered by zero segments is left There are possible strings up there is actually a number of all pairs of strings of length plus the number of all pairs of equal strings of length divided by Overall complexity 
You are given a connected weighted undirected graph consisting of vertices and edges You are asked queries about it Each query consists of a single integer For each query you select a spanning tree in the graph Let the weights of its edges be The cost of a spanning tree is the sum of absolute differences between the weights and The answer to a query is the lowest cost of a spanning tree The queries are given in a compressed format The first queries are provided explicitly For queries from to Print the xor of answers to all queries ,Consider a naive solution using Kruskal s algorithm for finding MST Given some you arrange the edges in the increasing order of and process them one by one Look closely at the arrangements At the edges are sorted by How does the arrangement change when increases Well some edges swap places Consider a pair of edges with different weights and Edge will go before edge in the arrangement as long as is closer to than So for all up to edge goes before edge And for all from onwards edge goes before edge This tells us that every pair of edge with different weights will swap exactly once So there will be at most swaps Which is at most different arrangements Each of them corresponds to some range of s We can extract the ranges of s for all arrangements and calculate MST at the start of each range We can also find the arrangement that corresponds to some from a query with a binary search However only knowing the weight of the MST at the start of the range is not enough The weights of edges change later in the range and we can t predict how Some edges have their weight increasing some decreasing First let s add more ranges We want each edge to behave the same way on the entire range either increase all the way or decrease all the way If we also add for all into the MST calculation this will hold Second let s store another value for each range the number of edges that have their weight increasing on it With that we can easily recalculate the change in the cost of the spanning tree The TL should be free enough for you to sort the edges for each MST calculation resulting in solution You can also optimize the first part to 
You are given a permutation of integers a permutation is an array where each element from to occurs exactly once Let s call some subsegment of this permutation special if Please calculate the number of special subsegments ,Let s fix the maximum element on segment and iterate on either the elements to the left of it or to the right of it and if the current maximum is and the element we found is check whether the element can form a special subsegment with that is is the maximum value on the segment between and That obviously works in yes Well not exactly If we can precompute the borders of the segment where is the maximum element this can be done with some logarithmic data structure or just by processing the array with a stack forwards and backwards and always choose to iterate on the smaller part of the segment it s Why is it so Every element will be processed no more than times because if we process it in a segment of size the smaller part of it contains no more than elements which we will process later and the smaller part of this segment contains no more than elements and so on Checking whether the element belongs to the segment we are interested in can be done in if we precompute inverse permutation for 
A of length is an array containing each integer from to exactly once For example is a permutation For the permutation the square of permutation is the permutation that for each For example the square of is This problem is about the inverse operation given the permutation you task is to find such permutation that If there are several such find any of them ,Consider some permutation q Let s build by it the oriented graph with edges i qi Easy to see and easy to prove that this graph is the set of disjoint cycles Now let s see what would be with that graph when the permutation will be multiplied by itself all the cycles of odd length would remain so only the order of vertices will change they will be alternated but the cycles of even length will be split to the two cycles of the same length So to get the square root from the permutation we should simply alternate in reverse order all cycles of the odd length and group all the cycles of the same even length to pairs and merge cycles in each pair If it s impossible to group all even cycles to pairs then the answer doesn t exist Complexity O n 
Let s suppose you have an array a stack initially empty and an array also initially empty You may perform the following operations until both and are empty Take the first element of push it into and remove it from if is not empty Take the top element from append it to the end of array and remove it from if is not empty You can perform these operations in arbitrary order If there exists a way to perform the operations such that array is sorted in non descending order in the end then array is called For example is because will be sorted if we perform the following operations Remove from and push it into Remove from and push it into Remove from and append it to the end of Remove from and push it into Remove from and append it to the end of Remove from and append it to the end of After all these operations so is is not You are given first elements of some permutation of size recall that a permutation of size is an array of size where each integer from to occurs exactly once You have to restore the remaining elements of this permutation so it is If there are multiple answers choose the answer such that is lexicographically maximal an array is lexicographically greater than an array iff there exists some integer such that for every and Print the lexicographically maximal permutation you can obtain If there exists no answer then output ,Let s denote as some stack sortable array which contains all integers from to inclusive We can see that if the first element of is then where by we mean concatenation of arrays It s easy to prove this fact if the first element is then we have to store it in the stack until we have processed all elements less than so in no element that is greater than can precede any element less than This way we can represent the prefix we are given For example if and prefix is then we can rewrite the permutation we have to obtain as So the unknown suffix is a contatenation of some stack sortable arrays It s easy to see that if an array is sorted in non increasing order then it is stack sortable So we can replace each block with an array If during rewriting the given prefix we obtain some impossible situation for example when and given prefix is we have and can t be the beginning of then answer is 
You are given a matrix consisting of rows and columns The rows are numbered top to bottom the columns are numbered left to right Each cell of the matrix can be either free or locked Let s call a path in the matrix if it starts and ends in the free cell visits only free cells has one of the two following structures the second cell is to the right from the first one the third cell is to the bottom from the second one the fourth cell is to the right from the third one and so on the second cell is to the bottom from the first one the third cell is to the right from the second one the fourth cell is to the bottom from the third one and so on In particular a path consisting of a single cell is considered to be a staircase Here are some examples of staircases Initially all the cells of the matrix are You have to process queries each of them flips the state of a single cell So if a cell is currently free it makes it locked and if a cell is currently locked it makes it free Print the number of different staircases after each query Two staircases are considered different if there exists such a cell that appears in one path and doesn t appear in the other path ,The solution consist of two main parts calculate the initial number of staircases and recalculate the number of staircases on query The constraints were pretty loose so we ll do the first part in and the second part in per query However it s worth mentioning that faster is possible The first part can surely be done in and can probably be done in The second part can be done in per query It s important to notice is that the only staircase that satisfy the requirements for both types is the staircase that consists of a single cell Thus staircases of both types can be calculated almost separately Let s define base staircases as the staircases that can t be prolonged further in any direction There are of them on the grid If a staircase consists of at least two cells it s a part of exactly one staircase At the same time every segment of a staircase is a valid staircase by itself Thus the main idea of calculating the initial answer is the following Isolate each staircase and determine its length possibly in Add the number of segments of length at least to the answer Add extra one cell staircases afterwards If you draw the staircases on the grid you can easily determine their starting cell The staircases that start by going one cell to the right start from the first row The staircases that start by going one cell to the bottom start from the first column Notice that both types can start from cell The updates can be handled the following way The answer always changes by the number of staircases that pass through cell if you ignore its state If the cell becomes free then these staircases are added to the answer Otherwise they are subtracted from it That can be calculated for two cases as well Go first down then right as far as possible Let it be steps Go first left then up as far as possible Let it be steps Then staircases are added to the answer Then change the order of steps in both directions to calculate the other type of staircases Beware of one cell staircases again To achieve for precalc you can calculate the length of each staircase with a formula To achieve per query you can first enumerate cells in each staircase separately then maintain the set of segments of adjacent free cells in it 
In this problem we will consider undirected graphs consisting of vertices with weighted edges The weight of each edge is an integer from to An undirected graph is considered if the sum of weights of all edges incident to vertex is equal to the weight of MST in the graph MST is the minimum spanning tree a tree consisting of edges of the graph which connects all vertices and has the minimum sum of weights among all such trees the weight of MST is the sum of weights of all edges in it Calculate the number of graphs having exactly vertices and the weights of edges from to Since the answer might be large print it modulo ,Let the weight of the edge between the vertex to the vertex be Suppose there exists a pair of vertices and with indices greater than such that or Then if we choose the spanning tree with all vertices connected to it won t be an MST we can remove either the edge or the edge add the edge instead and the cost of the spanning tree will decrease So we should have for every pair It can be shown that this condition is not only necessary but sufficient as well if for every pair the condition holds the MST can t have the weight less than We can prove this by induction suppose that for simplicity in the spanning tree there should be at least one edge incident to vertex and its weight is at least there should be at least two edges incident to vertices and and their weights are at least there should be at least edges incident to vertices from to and their weights are at least Okay now let s show how to calculate the number of such graphs We can run the following dynamic programming let be the number of graphs where we have already connected vertices to the vertex and the maximum weight we have used is We start with and for each transition from we will iterate on the number of vertices we connect to the vertex with edges with weight let the number of those vertices be choose them with a binomial coefficient and also choose the weights for the edges that connect one of the chosen vertices with one of the vertices already connected to since for each of those edges we know that their weights should be in so we need to multiply the value in transition by where is the number of such edges Implementing this dynamic programming can be done in or both are sufficient 
You are given a string You have to reverse it that is the first letter should become equal to the last letter before the reversal the second letter should become equal to the second to last letter before the reversal and so on For example if your goal is to reverse the string you should get the string To accomplish your goal you can swap the Your task is to calculate the minimum number of swaps you have to perform to reverse the given string ,First of all let s find the resulting position for each character of the string It s easy to see that we don t need to swap equal adjacent characters it changes nothing so the first character in the original string is the first character in the resulting string the second character in the original string is the second character in the resulting string and so on Now let s build a permutation of elements where is the resulting position of the element that was on position in the original string For example for the string this permutation will be In one operation we may swap two elements in this permutation and our goal is to sort it since each character of the string has its own required position and when for every the condition holds each character is on the position it should be The required number of swaps of adjacent elements to sort a permutation is exactly the number of inversions in it since each swap changes the number of inversions by and this number can be calculated using many different techniques for example mergesort tree or Fenwick tree 
You are given a string of length Each character is either one of the first lowercase Latin letters or a question mark You are asked to replace every question mark with one of the first lowercase Latin letters in such a way that the following value is maximized Let be the maximum length substring of string which consists entirely of the th Latin letter A substring of a string is a contiguous subsequence of that string If the th letter doesn t appear in a string then is equal to The value of a string is the minimum value among for all from to What is the maximum value the string can have ,Notice that if there are substrings of length for each letter then there are also substrings of length Thus the function on the answer is monotonous so the binary search is applicable Let s have some answer fixed by binary search We have to place blocks of letters of length somewhere in a string If we fix an order these blocks go into the string then the greedy algorithm for placing them works Put each block after the previous one but as far to the left as possible the correctness can be proven by showing that picking not the furthest to the left position can t be more optimal If there exists such an order that all blocks fit then the answer is greater than or equal to The common transition is to move from iterating over permutations to dynamic programming over submasks Let be the smallest prefix of the string such that all blocks of letters from the mask fit into this prefix The transitions are the same pick a new block and place it as early after that prefix as possible So far the solution works pretty slow since for each of masks we have to find the earliest possible position for a block Let s use some precalculations to perform the transitions in Notice that the transition doesn t depend on a mask only on a length of the previous prefix Thus for every prefix and every letter we can save the closest position for a block Let be the closest position for a prefix of length and the th letter is at least equal to However if the block can be placed at the th position then it should be updated That can happen if the closest occurrence of any letter except is not smaller than Thus we can also maintain the closest occurrence of every letter With some smart iterations we can do the precalculations in The dynamic programming works in then Overall complexity 
Let be the sum of digits of a decimal number Find the smallest non negative integer such that ,There are many ways to solve this problem including precalculating all answers but the model solution is based on the following In most cases It is not true only when the last digit of is and if we know the number of digits at the end of we can easily derive the formula for And since there will be at most one number with last digit equal to in Let s iterate on the last digit of and the number of digits before it Suppose the fixed has no other digits other than the last one and several digits before it Let s calculate Here goes the trick If we prepend with several digits such that the last of them is not and the sum of those digits is then So we can easily derive the value of we need and construct the smallest number with sum of digits equal to don t forget that the last digit should not be 
Let s denote the size of the maximum matching in a graph as You are given a bipartite graph The vertices of the first part are numbered from to the vertices of the second part are numbered from to For a tuple of four integers where and let s define as the graph which consists of all vertices of the given graph that are included in the segment or in the segment and all edges of the given graph such that each of their endpoints belongs to one of these segments In other words to obtain from the original graph you have to remove all vertices such that and and all edges incident to these vertices Calculate the sum of over all tuples of integers having and ,Instead of counting the edges belonging to the maximum matching it is easier to count the vertices So we will calculate the total number of vertices saturated by the maximum matching over all possible tuples and then divide the answer by Furthermore it s easier to calculate the number of unsaturated vertices than the number of saturated vertices so we can subtract it from the total number of vertices in all graphs we consider and obtain the answer Let s analyze how to calculate the total number of unsaturated vertices Each graph is a subgraph of the given graph so it is still bipartite and the degree of each vertex is still not greater than A bipartite graph where the degree of each vertex is at most can be represented as a set of cycles and paths and the maximum matching over each of these cycles paths can be considered independently Each cycle has an even number of vertices since otherwise the graph would not be bipartite so we can saturate all vertices on a cycle with the matching For a path the number of unsaturated vertices depends on its length if the number of vertices in a path is even we can match all vertices on it otherwise one vertex will be unsaturated So the problem reduces to counting paths with odd number of vertices in all possible graphs Every path with an odd number of vertices has a center the vertex which is exactly in the middle of the path Let s iterate on the center of the path and its length and calculate the number of times this path occurs in all graphs we consider Suppose the center of the path is the vertex and the number of vertices in it is Then for this path to exist two conditions must hold every vertex such that the distance from to is not greater than should be present in the graph every vertex such that the distance from to is should be excluded from the graph It means that for each of the two parts of the graph there are several vertices that should be present in the graph and zero or two vertices that should be excluded from the graph It s easy to see that among the vertices we have to include we are only interested in the minimum one and the maximum one all vertices between them will be included as well if these two are included So we need to implement some kind of function that allows us to calculate the number of segments that cover the minimum and the maximum vertex we need and don t cover any of the vertices that we have to exclude this can be easily done in Note that the segments should be considered independently for both parts of the graph Overall for each vertex we have to consider at most different lengths of odd paths with the center in this vertex The minimum maximum indices of vertices in both parts we have to include in the graph can be maintained while we increase the length of the path so the whole solution works in 
Calculate the value of the sum As the result can be very large you should print the value modulo the remainder when divided by The modulo operator stands for the remainder after dividing by For example ,Unfortunately my solution for this problem had overflow bug It was fixed on contest Even so I hope you enjoyed the problem because I think it s very interesting Let s transform the sum Note that the last sum can be accumulated to only value because for all the values will be equal to Note in the last sum either or Let s carefully accumulate both cases The first sum can be simply calculated by iterating over all We will accumulate the second sum independently for all different values Firstly we should determine for which values we will have the value Easy to see that for the values from the interval Also we can note that the sum of the second factors in with fixed first factor can be calculaed in constant time it s simply a sum of arithmetic progression So we have solution with complexity 
Let s define a multiset the following way Write down the sum of all elements of the multiset in its decimal representation For each position of that number check if the multiset includes at least one element such that the digit of the element and the digit of the sum at that position are the same If that holds for every position then the multiset is Otherwise it s For example multiset is and multiset is The red digits mark the elements and the positions for which these elements have the same digit as the sum The sum of the first multiset is every position has the digit required The sum of the second multiset is and the second to last digit doesn t appear in any number thus making the multiset You are given an array consisting of integers You are asked to perform some queries on it The queries can be of two types replace with the value find the subset of the multiset of the numbers with the minimum sum or report that no subset exists Note that the empty multiset is For each query of the second type print the lowest sum of the subset Print if no subset exists ,We are given the definition of the balanced multiset but let s instead fix the criteria to determine if the multiset is unbalanced Take an empty multiset and start adding numbers to it until it becomes unbalanced Empty set to the set of one number is trivial Now for the second number If there is some position such that both numbers have non zero digits in it then the multiset becomes unbalanced let these be non zero digits and then can be neither nor After that let s prove that you can never make an unbalanced multiset balanced again by adding numbers to it Let there be such multisets and such is unbalanced is balanced and Take a look at the lowest position which has non zero digits in several numbers from The sum of these digits should be equal to at least one of them modulo to satisfy the condition of balance That can only mean their sum is greater or equal to thus is make a carry to the next position The sum of digits on the next position plus carry should also be equal to some digit of them thus pushing some other carry value to the next one And so on until the carry makes it to the position greater than any position in any of the numbers But the carry is non zero and there is no number with any non zero digit in this position That makes our assumption incorrect After all it implies that any unbalanced multiset of size greater than two has an unbalanced multiset of size two The problem now got reduced to find a pair of numbers and such that there is at least one position such that both and have non zero digits on it and is minimal possible That can be easily maintained in a segment tree Let a node corresponding to the interval keep the best answer on an interval the sum of such a pair and an array the smallest number on an interval which has a non zero digit at position or if none exists The update is easy Iterate over the digits of a new number and update the values in the array in the corresponding nodes The merge is done the following way push the best answers from children to the parent and then iterate over the positions and try to combine the smallest numbers at each one from the left child and the right child Idea wise this is the same as storing a segtree and calculating the answer by each position separately However these approaches differ by a huge constant factor performance wise The former one accesses the memory in a much more cache friendly way You might want to take that as a general advice on implementing multiple segtrees Overall complexity 
You are given an array of length The elements of the array are numbered from to You have to process queries to this array In the th query you will be given an integer To process the query you should do the following for every do the following if the th element was already swapped with some other element skip it otherwise swap and after that print the maximum sum over all contiguous subsegments of the array including the empty subsegment For example if the array is and the query is processed as follows the st element wasn t swapped yet so we swap it with the rd element the nd element wasn t swapped yet so we swap it with the th element the rd element was swapped already the th element was swapped already the th element wasn t swapped yet so we swap it with the th element the th element wasn t swapped yet so we swap it with the th element So the array becomes The subsegment with the maximum sum is and the answer to the query is Note that the queries actually i e after a query is performed the array does not return to its original state and the next query will be applied to the modified array ,Let s carefully analyze the operation denoted in the query Since the length of the array is always divisible by every element will be swapped with some other element The elements can be split into two groups the ones whose positions increase by and the ones whose positions decrease by Let s find some trait of the elements which will allow us to distinguish the elements of one group from the elements of the other group The first elements will be shifted to the right the next elements will be shifted to the left the next elements will be shifted to the right etc If we look at the binary representations of integers then we can see that the first elements have in the th bit the next elements have in the th bit the next elements have in the th bit and so on So if we consider the positions of elements as indexed then the operation can be described as follows Let the position of the element be If the th bit in is gets increased by otherwise gets decreased by What does it look like Actually it is just where denotes XOR So each query can be represented as swap with for some integer The combination of two queries can also be represented with a single query in fact the state of the array can be denoted as the XOR of all from the previous queries Now let s try to solve the following problem for every calculate the maximum sum of subsegment if every element is swapped with To solve this problem we can use a segment tree First of all we need to understand how to solve the problem of finding the maximum sum on subsegment using a segment tree To do this we should store the following four values in each vertex of the segment tree the sum of elements on the segment denoted by the vertex the maximum sum of elements on the prefix of the segment denoted by the vertex the maximum sum of elements on the suffix of the segment denoted by the vertex the answer on the segment If some vertex of the segment tree has two children these values for it can be easily calculated using the values from the children So we can glue two segments represented by the vertices together creating a new vertex representing the concatenation of these segments Okay but how do we apply XOR to this For every vertex of the segment tree let s create several versions the th version of the vertex represents the segment corresponding to this vertex if we apply swapping query with to it For a vertex representing the segment of length we can use the following relation to get all its versions here we denote as the th version of and and as the children of if then else The function here denotes the glueing together of two vertices we described above Now let s try to analyze how many versions of each vertex we need For the root we will need all versions For its children we need only versions For the children of the children of the root we need only versions and so on so overall the total number of versions is only and each version can be constructed in so the solution works in 
We had a string consisting of lowercase Latin letters We made copies of this string thus obtaining identical strings After that in each of these strings we swapped exactly two characters the characters we swapped could be identical but they had different indices in the string You are given strings and you have to restore any string so that it is possible to obtain these strings by performing aforementioned operations Note that the total length of the strings you are given doesn t exceed 5000 that is ,If we don t have two distinct strings then we just have to swap any pair of characters in any of the given strings and print it Otherwise we have to find two indices and such that Then let s store all positions such that in array If the number of those positions will exceed 4 then the answer will be 1 Otherwise we need to iterate over all positions in array try to swap with any other character of and check that current string can be the answer We also should try the same thing with string It is clear how we can check string to be the answer Let s iterate over all strings and for each string count the number of positions such that Let s call it If for any given string is not equal to 0 or 2 then string can t be the answer Otherwise if for any given string is equal to 0 and all characters in string are distinct then can t be the answer If there is no string that satisfies all aforementioned conditions then the answer will be 1 
We had a really tough time generating tests for problem D In order to prepare strong tests we had to solve the following problem Given an undirected labeled tree consisting of vertices find a set of segments such that both endpoints of each segment are integers from to and each integer from to should appear as an endpoint of exactly one segment all segments are non degenerate for each pair such that and the vertices and are connected with an edge if and only if the segments and intersect but neither segment is fully contained in segment nor segment is fully contained in segment Can you solve this problem too ,For each vertex we will build the following structure for its children the segment for the second child is nested in the segment for the first child the nested for the third child is nested in the segment for the second child and so on and the children of different vertices do not intersect at all Let s solve the problem recursively for each of the children create a set of segments with endpoints from to where is the size of the subtree After that combine them To do this you can use small to large technique and change the coordinates of the segments or use the necessary offset in the function call for the next child After that it remains to cross children s segments with the segment of the vertex itself To do this you can move the right ends of all segments of the children by to the right and add a segment that starts before the first one and ends immediately after the last one 
You wanted to write a text consisting of lowercase Latin letters But instead you have written a text consisting of lowercase Latin letters and now you want to fix it by obtaining the text from the text Initially the cursor of your text editor is at the end of the text after its last character In one move you can do one of the following actions press the left button so the cursor is moved to the left by one position or does nothing if it is pointing at the beginning of the text i e before its first character press the right button so the cursor is moved to the right by one position or does nothing if it is pointing at the end of the text i e after its last character press the home button so the cursor is moved to the beginning of the text before the first character of the text press the end button so the cursor is moved to the end of the text after the last character of the text press the backspace button so the character before the cursor is removed from the text if there is no such character nothing happens Your task is to calculate the minimum number of moves required to obtain the text from the text using the given set of actions or determine it is impossible to obtain the text from the text You have to answer independent test cases ,Of course there is no need to press home more than once and no need to press end at all because suppose we did something on suffix then pressed home did something on prefix and then pressed end and continue doing something on suffix Then we can merge these two sequences of moves on suffix and press home after we did anything we wanted on suffix and the answer will not get worse Now let s iterate over the position at which we will press home in range from to In other words we iterate over the position till which we press only left and backspace to fix the suffix So now we have the string and we want to get some suffix of from this string but we actually don t know which suffix of we want So let s iterate over the length of this suffix in a range from to Now we have the string and the string and we have to check if we can obtain this suffix of from this suffix of This part can be precalculated in greedily we just can store for each suffix of the rightmost position in in which this suffix is obtainable If we can obtain the current suffix then we obviously can say the number of moves to do that it is and actually do not depend on the suffix length because if we meet the character we need we just press left and move to the next character otherwise we press backspace and move to the next character deleting the one we don t need After that we press home and now we have to check if we can obtain from This part can also be precalculated greedily in like the part with rightmost positions for suffixes But the minimum number of moves required to obtain the prefix is tricky Actually if we consider these prefixes from right to left we want to match as many characters from the beginning as possible In other words if we reverse and we want to find their longest common prefix and this will be the number of characters we don t want to touch at all and if it is the longest common prefix it means that the next character is bad and we want to remove it anyway so the length of LCP of these two reversed prefixes is the only thing affecting the number of moves on the prefix This part can be precalculated in with simple dynamic programming using memory or with z function in time and memory we just need to build a z function on a string where is the concatenation of strings and is the reverse operation The required value of the z function for the fixed values and will be in the position And the answer for the prefix will be this is the number of extra characters on the prefix we have to delete plus plus because we have to press home But there is a corner case If the prefix is empty then we don t need to do all of this and the answer for prefix will be Complexity time and memory 
A team of three programmers is going to play a contest The contest consists of problems numbered from to Each problem is printed on a separate sheet of paper The participants have decided to divide the problem statements into three parts the first programmer took some prefix of the statements some number of first paper sheets the third contestant took some suffix of the statements some number of last paper sheets and the second contestant took all remaining problems But something went wrong the statements were printed in the wrong order so the contestants have received the problems in some random order The first contestant has received problems The second one has received problems The third one has received all remaining problems The contestants don t want to play the contest before they redistribute the statements They want to redistribute them so that the first contestant receives some prefix of the problemset the third contestant receives some suffix of the problemset and the second contestant receives all the remaining problems During one move some contestant may give one of their problems to other contestant What is the minimum number of moves required to redistribute the problems ,Suppose we want to divide first problems of the contest between the first contestant and the second contestant the first contestant will get first problems and the second contestant will get problems in the middle and then give all the remaining problems to the third contestant We are going to iterate on from to and for each possible find the best value of Okay Now suppose we fixed and and now we want to calculate the number of problems that should be redistributed Let s denote as the number of problems among first ones given to the th contestant as the number of problems among last ones given to the th contestant and as the number of problems in the middle given to the th contestant Obviously the answer for fixed and is but we don t like this expression because we don t know how to minimize it for fixed We know that for fixed the values of and are constant Using that we may arrive at the fact that minimizing is the same as minimizing for fixed and now we have a way to quickly find best possible for fixed 
Hasan loves playing games and has recently discovered a game called TopScore In this soccer like game there are players doing penalty shoot outs Winner is the one who scores the most They have just finished the game and now are waiting for the result But there s a tiny problem The judges have lost the paper of scores Fortunately they have calculated sum of the scores before they get lost and also for some of the players they have remembered a lower bound on how much they scored However the information about the bounds is private so Hasan only got to know his bound According to the available data he knows that his score is at least and sum of the scores is Thus the final state of the game can be represented in form of sequence of integers player s scores Hasan is player number so Also Two states are considered different if there exists some position such that the value of differs in these states Help Hasan find the probability of him winning It can be shown that it is in the form of where and are non negative integers and Report the value of ,An straightforward dp solution is to calculate number of states at the end of the game in which no one has scored more than goals where is the number of total goals to be scored and is the number players in the game Fix the score of Hasan in the game and by using this dp the rest is easy also described below But as long as the time needed to calculate is this solution won t fit in the constraints With a little help from combinatorics we can calculate the value of mentioned dp function without using recursions Define by inclusion exclusion principle it can be easily seen that the value of equals to the above And the complexity of calculation for is with a preprocess for calculating binomial coefficients This formula is a well known modification of Star and Bars problem but with the upper limit on terms Now we can calculate the answer firstly fix Hasan s score and number of top scorers then use to calculate each state By using modulus arithmetic the answer can be reported in the requested form Overall complexity 
A thief made his way to a shop As usual he has his lucky knapsack with him The knapsack can contain objects There are kinds of products in the shop and an infinite number of products of each kind The cost of one product of kind is The thief is greedy so he will take exactly products it s possible for some kinds to take several products of that kind Find all the possible total costs of products the thief can nick into his knapsack ,Let then it is the standard problem which can be solved by FFT Fast Fourier Transform The solution is the following consider the polynomial which the th coefficient equals to one if and only if there is the number in the given array Let s multiply that polynomial by itself and find for which the coefficient in square not equals to Those values will be in the answer Easy to modificate the solution for the arbitrary We should simply calculate the th degree of the polynomial The complexity will be where is the maximal sum We can improve that solution Instead of calculating the th degree of the polynomial we can calculate the th degree of the DFT of the polynomial The only problem is the large values of the th degrees We can t use FFT with complex numbers because of the precision problems But we can do that with NTT Number theoretic transform But that solution also has a problem It can happen that some coefficients became equals to zero modulo but actually they are not equal to zero To get round that problem we can choose two three random modules and get the complexity The main author solution has the complexity FFT with complex numbers the second solution has the same complexity but uses NTT and the third solution has the improved complexity but it was already hacked by halyavin 
You are organizing a boxing tournament where boxers will participate is a power of and your friend is one of them All boxers have different strength from to and boxer wins in the match against boxer if and only if is stronger than The tournament will be organized as follows boxers will be divided into pairs the loser in each pair leaves the tournament and winners advance to the next stage where they are divided into pairs again and the winners in all pairs advance to the next stage and so on until only one boxer remains who is declared the winner Your friend really wants to win the tournament but he may be not the strongest boxer To help your friend win the tournament you may bribe his opponents if your friend is fighting with a boxer you have bribed your friend wins even if his strength is lower Furthermore during each stage you distribute the boxers into pairs as you wish The boxer with strength can be bribed if you pay him dollars What is the minimum number of dollars you have to spend to make your friend win the tournament provided that you arrange the boxers into pairs during each stage as you wish ,If our friend is the strongest boxer he wins without any bribing Otherwise we have to bribe the strongest boxer and he can defeat some other boxers directly or indirectly Suppose we chose the boxers he will defeat then there is another strongest boxer If our friend is the strongest now we don t need to bribe anyone otherwise we will bribe the strongest remaining boxer again and he can defeat other boxers and so on The only thing that s unclear is which boxers should be defeated by the ones we bribe We may use dynamic programming to bribe them is the minimum cost to bribe boxers so that all boxers among strongest ones are either bribed or defeated by some bribed boxer For each value of we know the maximum amount of boxers that are defeated by bribed boxers so the transitions in this dynamic programming are the following if we can t defeat the next boxer for free our bribed boxers have already defeated as many opponents as they could we have to bribe him otherwise we either bribe him or consider him defeated by some other boxer Overall complexity is 
You are given a tree an undirected connected acyclic graph consisting of vertices You are playing a game on this tree Initially all vertices are white On the first turn of the game you choose one vertex and paint it black Then on each turn you choose a white vertex adjacent connected by an edge to black vertex and paint it black Each time when you choose a vertex even during the first turn you gain the number of points equal to the size of the connected component consisting only of white vertices that contains the chosen vertex The game ends when all vertices are painted black Let s see the following example Vertices and are painted black already If you choose the vertex you will gain points for the connected component consisting of vertices and If you choose the vertex you will gain points for the connected component consisting of vertices and Your task is to maximize the number of points you gain ,I should notice that there is much simpler idea and solution for this problem without rerooting technique but I will try to explain rerooting as the main solution of this problem it can be applied in many problems and this is just very simple example What if the root of the tree is fixed Then we can notice that the answer for a subtree can be calculated as where is the set of children of the vertex The answer on the problem for the fixed root will be How can we calculate all possible values of for each root from to fast enough We can apply rerooting When we change the root of tree from the vertex to the vertex we can notice that only four values will change and Firstly we need to cut the subtree of from the tree rooted at Let s subtract and from then let s change the size of the subtree of subtract from it Now we have the tree without the subtree of Then we need to append as a child of Add to and add and to Now we have as a root of the tree and can update the answer with When we changes the root of the tree back from to we just need to rollback all changes we made So overall idea is the following calculate sizes of subtrees for some fixed root calculate dynamic programming for this root run dfs which will reroot the tree with any possible vertex and update the answer with the value of dynamic programming for each possible root The code of function that reroots the tree seems like this void dfs int v int p 1 ans max ans dp v for auto to g v if to p continue dp v dp to dp v siz to siz v siz to siz to siz v dp to siz v dp to dp v dfs to v dp to dp v dp to siz v siz to siz v siz v siz to dp v siz to dp v dp to 
One day Polycarp decided to rewatch his absolute favourite episode of well known TV series Tufurama He was pretty surprised when he got results only for season 7 episode 3 with his search query of Watch Tufurama season 3 episode 7 online full hd free This got Polycarp confused what if he decides to rewatch the entire series someday and won t be able to find the right episodes to watch Polycarp now wants to count the number of times he will be forced to search for an episode using some different method TV series have seasons numbered through the th season has episodes numbered through Polycarp thinks that if for some pair of integers and exist both season episode and season episode then one of these search queries will include the wrong results Help Polycarp to calculate the number of such pairs ,At first it doesn t matter if some season has more than episodes so we can set Let s maintain next invariant when we proceed th season we will have only seasons containing the episodes with indices Then the number of pairs is just number of seasons with index One of the ways to maintain this invariant is the following for each number of episodes store a list with indices of seasons with exactly episodes Then after proceeding of th season just erase all seasons with exactly episodes Maintaining seasons and counting them can be done by BIT with zeros and ones Finally notice that we counted each pair twice and also counted the pairs so we must subtract the number of pairs where and divide the result by two 
Luba needs your help again Luba has TV sets She knows that th TV set will be working from moment of time till moment inclusive Luba wants to switch off one of TV sets in order to free the socket Let s call some TV set if after switching it off the number of moments of time when at least one of TV sets is working won t decrease Luba will be very upset if she has to switch off a non TV set Help Luba by telling her the index of some TV set If there is no any print ,Firstly let s compress the moments of time Note that storing only and isn t enough consider pairs and you also should take Now moments of time are up to For every moment calculate the number of segments to cover it make and for each segment and take prefix sums over this array Then let be the number of moments of time covered by only one segment on some prefix up to th moment And finally if for some segment from the input is then you can safely delete this segment Overall complexity 
You are given two arrays and Array is sorted in ascending order for each from to You have to divide the array into consecutive subarrays so that for each from to the minimum on the th subarray is equal to Note that each element belongs to exactly one subarray and they are formed in such a way the first several elements of compose the first subarray the next several elements of compose the second subarray and so on For example if and then there are two good partitions of array You have to calculate the number of ways to divide the array Since the number can be pretty large print it modulo ,At first let s reverse arrays and Now array is sorted in descending order Now let s find minimum index such that If there is no such index or if then the answer is because minimum on any prefix of array will never be equal to Otherwise let s find the minimum index such that If there is no such index or if then the answer is Also let s find the minimum index such that it can t be greater than The first subarray starts in position and ends in any position because if it ends in position or further then the minimum in the first subarray is greater than So there are ways to split subarrays and A similar approach can be used to calculate the number of ways to split the second and third subarrays and so on After all you have to check that minimum in the last subarray is equal to otherwise the answer is 
Berland regional ICPC contest has just ended There were participants numbered from to who competed on a problemset of problems numbered from to Now the editorial is about to take place There are two problem authors each of them is going to tell the tutorial to of the problemset The authors choose the segment of consecutive tasks for themselves independently of each other The segments can coincide intersect or not intersect at all The th participant is interested in listening to the tutorial of all consecutive tasks from to Each participant always chooses to listen to only the problem author that tells the tutorials to the maximum number of tasks he is interested in Let this maximum number be No participant can listen to both of the authors even if their segments don t intersect The authors want to choose the segments of consecutive tasks for themselves in such a way that the sum of over all participants is maximized ,Consider some participant s segment and one of the author s segment How does the length of intersection change when you move from left to right It first increases until the centers of both segments coincide that s the easiest to notice on the segments of the same length and then decreases The increase is totally symmetrical to the decrease With that idea you can conclude that the author s segment whose center is the closest to the center of participant s segment has the larger intersection length Let s sort the participants segments by their center You can see that the first author will be optimal for the prefix of the segments and the second author for the remaining suffix So you can just iterate over the length of the prefix and update the answer with all options Overall complexity 
There are two water tanks the first one fits liters of water the second one fits liters of water The first tank has liters of water initially the second tank has liters of water initially You want to perform operations on them The th operation is specified by a single non zero integer If then you try to pour liters of water from the first tank into the second one If you try to pour liters of water from the second tank to the first one When you try to pour liters of water from the tank that has liters currently available to the tank that can fit more liters of water the operation only moves liters of water For all pairs of the initial volumes of water such that and calculate the volume of water in the first tank after all operations are performed ,Consider a naive solution Iterate over all pairs and apply all operations The complexity is The constraints obviously imply that it s too much What can we cut from it Well surely will still remain there Both of and also should So we can probably only hope to turn this into Let s try that Notice that no matter what operations are applied never changes You can also peek at the examples and see that the patterns are suspiciously diagonal shaped in the matrix Let s try to solve the problem by fixing and calculating the answer for all values of I will call the fixed variable Consider case where and Here all can fit into both and so we can avoid caring about one restriction on the operations We ll think what to do with large volumes later If there are no operations the answer for each initial is for all from to Now consider an operation for some For nothing changes Actually for all the result of the operation is the same as for Hmm but if the result is the same it will remain the same until the end Same from the other side The answers for and also get merged together To me it kind of looks like a primitive form of DSU on these volume states you merge some prefix of the answers together and merge some suffix of the answers together If the state was merged to either or then it s easy to calculate the actual answer for that state What happens to the remaining states Well since they weren t merged anywhere the operation for them was applied fully if was requested all was poured How to deal with multiple operations then I propose the following idea When applying an operation we only want to know which of the previously non merged states become merged Basically we can squish all previous operations into one just sum up the signed amounts of water Since they all were applied fully to the non merged states it s completely valid After the squish check for the new merges You can actually study the structure of the answers and see that they go like that for some values of and such that It isn t that important but it makes the code easier You can basically calculate the length of the merged prefix the length of the merged suffix then calculate the answer at the end of the prefix in and restore all answers from it We neglected larger values of earlier time to return to them Another kind of limit to each operation is added when extra water doesn t fit in another tank Well it doesn t change that much It only makes more prefix suffix merges To come up with the exact formulas I followed these points Something merges on an operation when any of these holds not enough water in the first tank not enough space in the second tank not enough water in the second tank not enough space in the first tank Replace all with and you get the constraints for prefix and suffix merges Overall complexity 
Polycarp plays a computer game yet again In this game he fights monsters using magic spells There are two types of spells spell of power deals damage to the monster and spell of power deals damage to the monster and the damage of the next spell Polycarp casts Each spell can be cast but Polycarp can cast them in any order For example suppose that Polycarp knows three spells a fire spell of power a lightning spell of power and a lightning spell of power There are ways to choose the order in which he casts the spells first second third This order deals damage first third second This order deals damage second first third This order deals damage second third first This order deals damage third first second This order deals damage third second first This order deals damage Initially Polycarp knows spells His spell set changes times each time he either learns a new spell or forgets an already known one After each change calculate the maximum possible damage Polycarp may deal using the spells he knows ,Let s solve this problem for fixed set of spells For example we have a fireball spells with powers and lighting spells with powers We reach the maximum total damage if we can double all spells with maximum damage It s possibly iff the set of largest by power spell let s denote this set as contains at least one fireball spell Otherwise if set contains only lightning spells the maximum damage reach when we double largest spells in set and one largest spell not from set if such spell exist Now how do you solve the original problem when spells are added and removed All we have to do it maintain the set of largest by power spells where is current number of lightning spells and change this set by adding or removing one spell Also you have to maintain the sum of spells power in set this set and the number of fireball spells in this set You can do it by in or on 
Vasya has a tree consisting of vertices with root in vertex At first all vertices has written on it Let be the distance between vertices and i e number of edges in the shortest path from to Also let s denote subtree of vertex set of vertices such that next two conditions are met is the ancestor of each vertex is the ancestor of itself Vasya needs you to process queries The th query is a triple and For each query Vasya adds value to each vertex from subtree of Report to Vasya all values written on vertices of the tree after processing all queries ,To solve this problem we can use a data structure which allows to add some value on segment and get a value from some point Fenwick tree segment tree or anything you are familliar with Let s run DFS from the root while maintaining current depth When entering a vertex on depth let s consider all queries having and for each such query add on segment Then for current vertex the answer is the value in point When leaving vertex we need to rollback everything we have done for all queries having subtract on segment 
Vasya owns three big integers Let s define a partition of such a sequence of strings that where is a concatanation of strings is the th element of the partition For example number has the following partitions and lots of others Let s call some partition of if each of its elements Vasya want to know the number of partitions of number which has each of satisfy the condition Note that the comparison is the integer comparison not the string one Help Vasya to count the amount of partitions of number such that they match all the given requirements The result can be rather big so print it modulo ,Let s use dynamic programming to solve the problem Let be the number of correct partitions for the long integer It s easy to see that if we have two big integers without leading zeroes we know the lengths of these integers and these lengths are not equal then we can determine which integer is greater in We will calculate the answers in the following order Suppose we want to calculate Let be the minimum position such that the number meets the following condition Let be the maximum position such that the number meets the following condition Initially let s consider will be less if will be less if To determine which of the numbers and is greater let s calculate z function for the string where is any character that doesn t occur in and After calculating z function we can easily find the first non equal character in and and this character will determine which number is greater To compare and we can act the same All that s left is to set to the sum of values from to This can be done by maintaining suffix sums There is a corner case which applies when If then because we cannot afford any leading zeroes Otherwise 
Vasya has a string of length consisting only of digits and Also he has an array of length Vasya performs the following operation until the string becomes empty choose some substring of erase it from the string and glue together the remaining parts any of them can be empty For example if he erases substring from string he will get the string Vasya gets points for erasing substring of length Vasya wants to maximize his total points so help him with this ,We set up a DP on start index end index number of consecutive digits matching our start index In other words the current string we are solving is the substring from start index to end index plus some number of additional digits all equal to S start added as a prefix to our substring We then have two choices from any given state Cash in on our consecutive digits at the start and recurse on Pick an index such that S start S i and collapse everything between those two indices in order to merge them together for an even larger prefix This results in a score of and we can loop over all to take the maximum The runtime is with a very good constant factor Code 49036191 Does anybody have 
Vasya is studying number theory He has denoted a function such that where is the greatest common divisor of and Vasya has two numbers and and he wants to calculate He tried to do it by himself but found out that calculating this function the way he wants to do that might take very long time So he decided to ask you to implement a program that will calculate this function swiftly ,One important fact is that when we subtract from new will be divisible by old And of course is always divisible by Let s factorize Consider the moment when changes If we denote old value of by the new value of will be divisible by some where is a prime divisor of Let s check all prime divisors of and for each of these divisors find the number of times we need to subtract from to get divisible by that is just don t forget that also has to be divisible by Among all prime divisors of pick one with the minimum required number of operations let this number of operations be add to answer subtract from and repeat the process 
Consider a system of water taps all pouring water into the same container The th water tap can be set to deliver any amount of water from to ml per second this amount may be a real number The water delivered by th tap has temperature If for every you set th tap to deliver exactly ml of water per second then the resulting temperature of water will be if then to avoid division by zero we state that the resulting water temperature is You have to set all the water taps in such a way that the resulting temperature is exactly What is the maximum amount of water you may get per second if its temperature has to be ,The following greedy strategy work Let s turn all the taps at full power If total temperature is greater than then we would like to decrease power on some taps with higher temperature We want to decrease as low power as possible so we should prioritize taps with the highest temperature Sort all taps by temperature and find the total power on suffix you should decrease to have equal temperatures This can be done with binary search The same works for smaller initial temperature Overall complexity 
Your friend is developing a computer game He has already decided how the game world should look like it should consist of locations connected by passages The passages are designed in such a way that it should be possible to get from any location to any other location Of course some passages should be guarded by the monsters if you just can go everywhere without any difficulties then it s not fun right Some crucial passages will be guarded by really fearsome monsters requiring the hero to prepare for battle and designing his own tactics of defeating them commonly these kinds of monsters are called And your friend wants you to help him place these bosses The game will start in location and end in location but these locations are not chosen yet After choosing these locations your friend will place a boss in each passage such that it is impossible to get from to without using this passage Your friend wants to place as much bosses as possible because more challenges means more fun right so he asks you to help him determine the maximum possible number of bosses considering that any location can be chosen as or as ,It s quite obvious that we can place bosses only on the bridges of the given graph if an edge is not a bridge then removing it doesn t make the graph disconnected so there still exists a path between any pair of vertices And if we fix two vertices and and then find some simple path between them then we will place the bosses on all bridges belonging to this path since the set of bridges would stay the same no matter which simple path between and we choose If we find bridges in the given graph and compress all 2 edge connected components two vertices belong to the same 2 edge connected component iff there exists a path between these vertices such that there are no bridges on this path into single vertices we will obtain a special tree called bridge tree Every edge of a bridge tree corresponds to a bridge in the original graph and vice versa Since we want to find the path with maximum possible number of bridges we only need to find the diameter of the bridge tree and this will be the answer to the problem 
Recently Max has got himself into popular CCG BrainStone As BrainStone is a pretty intellectual game Max has to solve numerous hard problems during the gameplay Here is one of them Max owns creatures th of them can be described with two numbers its health and its damage Max also has two types of spells in stock Doubles health of the creature Assigns value of of the creature to its Spell of first type can be used no more than times in total of the second type no more than times in total Spell can be used on a certain creature multiple times Spells can be used in arbitrary order It isn t necessary to use all the spells Max is really busy preparing for his final exams so he asks you to determine what is the maximal total damage of all creatures he can achieve if he uses spells in most optimal way ,At first let s prove that in optimal solution all spells of 1 st type are assigned to single creature By contradiction let s optimal answer contains indices where and If using spells of 1 st type is meaningless Otherwise if in general case then Contradiction So we can check for each creature maximal damage with its health multiplied At second if we sort all creatures in order by decreasing using spells on first creatures gives best answer So calculating answer for chosen creature invokes 2 cases if chosen creature is belong to first creatures then subtract from its contribution calculate new value and add it to otherwise we need one spell of second type which is optimal to take from th creature so along with replacing old value of chosen one we need to replace in contribution of th creature Result complexity is 
You are given a tree consisting of vertices A number is written on each vertex the number on vertex is equal to Recall that a simple path is a path that visits each vertex at most once Let the of the path be the bitwise XOR of the values written on vertices it consists of Let s say that a tree is if no simple path has weight You can apply the following operation any number of times possibly zero select a vertex of the tree and replace the value written on it with an arbitrary positive integer What is the minimum number of times you have to apply this operation in order to make the tree ,To begin with we note that there are no restrictions on the values that can be written on the vertices so we can use numbers of the form for the th replacement Then if we replaced the value of a vertex then no path passing through this vertex has weight Let s root the tree at the vertex number We can use a greedy approach consider some vertex such that it is the LCA for two vertices and the path between which has XOR equal to Among such vertices pick one with the maximum distance from the root We need to change at least one vertex on the path It turns out that changing the vertex is always no worse than changing any other vertex on this path because all the remaining bad paths that pass through the vertex also pass through the vertex that s why we have chosen the deepest LCA This means that in order to solve the problem it is necessary to quickly find the deepest LCA of some bad path For the convenience of solving the problem let s denote the XOR on the path as where is XOR on the path from the root to the vertex For all vertices let s maintain a set of values such that belongs to the subtree of Let s use the small to large method to obtain such sets Also during the union of sets we can check if there is a bad path in this subtree i e if two values in the sets we merge have the same XOR as the value written on the current vertex because that s when the XOR on path is If such a path exists then we have to change the value of the vertex and mark that the vertices of this subtree cannot be the ends of a bad path anymore that means we just clear the set instead of pulling it up the tree This solution works in 
You are given integers A sequence of integers is called a if for every the number of ones in the binary representation of the number s is a multiple of and for all The symbol is used for the binary exclusive or operation How many of length exist Output the answer modulo ,Let be the number of xor sequences of length with the last element equal to Let be equal to one if contains the number of ones in binary presentation that is multiple of three Otherwise let be equal to zero Consider a vectors and a matrix Easy to see that So Let s use the associative property of matrix multiplication at first let s calculate with binary matrix exponentiation and then multiply it to the vector 
You are given a string and strings All strings consist of lowercase Latin letters Let be the number of occurences of string in string For example and Calculate the value of where is the concatenation of strings and Note that if there are two pairs and such that you should include both and in answer ,Let s look at any occurrence of arbitrary pair There is exactly one special split position where the ends and starts So instead of counting occurrences for each pair we can iterate over the position of split and count the number of pairs This transformation is convenient since any which ends in split position can be paired with any which starts here So all we need is to calculate for each suffix the number of strings which starts here and for each prefix the number of strings which ends here But calculating the prefixes can be transformed to calculating suffixes by reversing both and all Now we need for each position calculate the number of strings which occur from It can be done by Aho Corasick Suffix Array Suffix Automaton Suffix Tree but do we really need them since constrains are pretty low The answer is NO We can use sqrt heuristic Let s divide all in two groups short and long The is short if There are no more than long strings and for each such string we can find all its occurrences with z function or prefix function It will cost as What to do with short strings Let s add them to trie The trie will have vertices but only depth So we can for each move down through the trie while counting the occurrences using only substring It will cost us So if we choose we can acquire complexity using only basic string structures 
A tourist wants to visit country Zeydabad for Zbazi a local game in Zeydabad The country Zeydabad is a rectangular table consisting of rows and columns Each cell on the country is either or The tourist knows this country is named Zeydabad because there are lots of s in the country A is a square which anti diagonal is completely filled with and its upper and lower rows are also completely filled with All other cells of a square can be arbitrary Note that a can consist of only one cell see the examples So he wants to count the number of s in the country a necessary skill for Zbazi Now your task is to help tourist with counting number of s As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,Let s precalculate the values the maximal number of letters z to the left to the right and to the left down from the position It s easy to do in time Let s fix some cell Consider the value It s the maximum size of the square with upper right ceil in But the number of z patterns can be less than Consider some cell diagonally down left from on the distance no more than The cells and forms z pattern if Let s maintain some data structure for each antidiagonal it can be described by formula that can increment in a point and take the sum on a segment Fenwick tree will be the best choice for that Let s iterate over columns from the right to the left and process the events we have some cell for which In that case we should increment the position in the tree number by one Now we should iterate over the cells in the current column and add to the answer the value of the sum on the segment from to in the tree number 
Now elections are held in Berland and you want to win them More precisely you want everyone to vote for you There are voters and two ways to convince each of them to vote for you The first way to convince the th voter is to pay him coins The second way is to make other voters vote for you and the th voter will vote for free Moreover the process of such voting takes place in several steps For example if there are five voters with then you can buy the vote of the fifth voter and eventually everyone will vote for you Set of people voting for you will change as follows Calculate the minimum number of coins you have to spend so that everyone votes for you ,Denote the number of voters with as Also denote i e is equal to number of voters with Let s group all voters by value We ll consider all these group in decreasing value of Assume that now we consider group with Then there are two cases if then all these voters will vote for you for free is equal to the number of votes bought in previous steps if then we have to buy additional votes Moreover the value of this bought voter must be greater than or equal to Since these voters indistinguishable we have to buy cheapest voter with a minimal value of So all we have to do it maintain values not yet bought voters in some data structure for example in 
You are given an integer array and an integer You perform the following code with it Your task is to calculate the expected value of the variable after performing this code Note that the input is generated according to special rules see the input format section ,I think it s easier to approach this problem using combinatorics instead of probability theory methods so we ll calculate the answer as the sum of values of over all ways to choose the index on each iteration of the loop If a number is chosen on the iteration of the loop then it is reduced to the maximum number divisible by that doesn t exceed the initial value So if a number is divisible by all integers from to i e divisible by it won t be changed in the operation Furthermore if then the value of this element won t become less than It means that we can interpret each number as where and The part with will always be added to the variable when this element is chosen so let s add to the answer which is the contribution of over all ways to choose the indices in the operations and work with instead of Now all elements of the array are less than We can use this constraint by writing the following dynamic programming to solve the problem is the number of appearances of the integer in the array over all ways to choose the indices for the first iterations For is just the number of occurrences of each integer in the array The transitions from are the following ones if this element is chosen in the operation then it becomes and we transition to the state otherwise the element is unchanged and we transition to the state multiplying the current value by which is the number of ways to choose some other element in the operation How can we use this dynamic programming to get the answer On the th iteration the number of times we choose the integer is exactly and the number of ways to use the integers in the next operations is so we add to the answer for every such state This solution runs in time which may be too slow if not implemented carefully Fortunately we have an easy way to optimize it use instead of which divides by in the worst case scenario for our solution We can do this because even if an integer is changed on the th operation we are not interested in this change since this is the last operation 
Recently Ivan noticed an array while debugging his code Now Ivan can t remember this array but the bug he was trying to fix didn t go away so Ivan thinks that the data from this array might help him to reproduce the bug Ivan clearly remembers that there were elements in the array and each element was not less than and not greater than Also he remembers facts about the array There are two types of facts that Ivan remembers for each such that for each such that Also Ivan thinks that this array was a permutation but he is not so sure about it He wants to restore some array that corresponds to the facts that he remembers and is very similar to permutation Formally Ivan has denoted the of array as follows where is the number of occurences of in the array Help Ivan to determine minimum possible of the array that corresponds to the facts ,This problem can be solved with mincost maxflow approach Let s construct a following network Construct a vertex for every number from to For each of these vertices add directed edges from the source to this vertex the capacity of each edge will be and the costs will be so pushing flow from the source to the vertex will cost exactly Also construct a vertex for every index of the array For each number make add a directed edge with capacity and cost to every position in the array such that this number can be put into this position and for every index make a directed edge from the vertex constructed for this index to the sink with capacity and cost Minimum cost maximum flow in this network will construct a suitable array with minimum cost so the answer to the problem is minimum cost of maximum flow in the network 
You are given three integers and conditions Calculate the number of distinct arrays consisting of integers such that for each bitwise AND of numbers for each Two arrays and are considered different if there exists such a position that The number can be pretty large so print it modulo ,We will solve the problem for each bit separately and then multiply the results Obviously if the position is covered by a segment with the value then we have no choice and we must put there For segments with the value there must be at least one position that they cover and its value is So we can write the following dynamic programming the number of arrays such that the last was exactly at the position and all segments to the left of it contain at least one zero It remains to determine which states we can update from The only restriction we have is that there should not be any segment with the value such that and Since in this case this segment will not contain any zero values For each position we may precalculate the rightmost position where some segment ending before begins and while calculating we should sum up only the values starting from position This can be done with prefix sums 
A string of length is called iff is even and for each Ivan has a string consisting of lowercase Latin letters is even He wants to form some string that will be an permutation of Also Ivan has denoted the of index as and the of as the sum of among all indices such that Help Ivan to determine maximum possible of he can get ,This problem has two different solutions a mincost maxflow approach and a greedy one We will tell you about the latter First of all let Then find all pairs of indices such that let the number of these pairs be It s obvious that we have to replace at least one letter in each of these pairs For each of these pairs let s replace the letter with lower with something Let s analyze the letters we are going to replace Let be the number of occurences of letter that we have to replace There are two cases There is no letter such that Then we can replace these letters without involving anything else and get an antipalindromic string with minimal possible cost There is a letter such that It s obvious that there is at most one such letter Let s replace some occurences of with other letters that are to be replaced Then we will still have some occurences of that need to be replaced Let s take one letter from each pair such that both of letters in a pair are not equal to Among these possibilities choose the required number of letters with minimum values of Then we can replace remaining occurences of with these letters 
 ants are on a circle of length An ant travels one unit of distance per one unit of time Initially the ant number is located at the position and is facing in the direction which is either or Positions are numbered in counterclockwise order starting from some point Positions of the all ants are distinct All the ants move simultaneously and whenever two ants touch they will both switch their directions Note that it is possible for an ant to move in some direction for a half of a unit of time and in opposite direction for another half of a unit of time Print the positions of the ants after time units ,The first observation if all the ants are indistinguishable we can consider that there are no collisions and all the ants are passing one through another So we can easily determine the final positions of all the ants but we can t say which ant will be in which position The second observation the relative order of the ants will be the same all the time So to solve the problem we should only find the position of one ant after seconds Let s solve that problem in the following way Consider the positions of all the ants after time units Easy to see that by the first observation all the positions of the ants will left the same but the order will be different we will have some cyclic shift of the ants If we find that cyclic shift we can apply it times After that we will have only time units So the problem now is to model the process for the one ant with and time units Note that in that time interval the fixed ant will have no more than two collisions with each other ant So if we model the process with ignoring all collisions except the ones that include the fixed ant we will have no more than collisions Let s model that process with two queues for the ants going to the left and to the right Each time we should take the first ant in the queue with opposite direction process the collision and add that ant to the end of the other queue Hint you will have a problem when the fixed ant can be in two different positions at the end but it s easy to fix with doing the same with the next ant 
Monocarp plays a computer game There are different sets of armor and different weapons in this game If a character equips the th set of armor and wields the th weapon their power is usually equal to but some combinations of armor and weapons synergize well Formally there is a list of ordered pairs and if the pair belongs to this list the power of the character equipped with the th set of armor and wielding the th weapon is not but Initially Monocarp s character has got only the st armor set and the st weapon Monocarp can obtain a new weapon or a new set of armor in one hour If he wants to obtain the th armor set or the th weapon he must possess a combination of an armor set and a weapon that gets his power to Of course after Monocarp obtains a weapon or an armor set he can use it to obtain new armor sets or weapons but he can go with any of the older armor sets and or weapons as well Monocarp wants to obtain the th armor set the th weapon What is the minimum number of hours he has to spend on it ,Among two armor sets one with the greater index is always better The same can be said about two different weapons So it is always optimal to use and obtain the best possible weapon or armor This observation allows us to model this problem with dynamic programming or shortest paths let be the minimum time in which Monocarp can obtain the armor and the weapon and in each transition we either get the best weapon we can or the best armor we can Similarly we can build a graph where the vertices represent these pairs and the edges represent getting the best possible weapon armor and find the shortest path from to using BFS Unfortunately it is But we can modify the BFS in the following fashion let s analyze each layer of BFS a layer is a set of vertices with the same distance from the origin In each layer there might be some redundant vertices if two vertices and belong to the same layer and then the vertex is redundant If we filter each layer removing all redundant vertices from it and continuing BFS only from non redundant ones the solution will be fast enough To prove it let s analyze the constraints on the answer Suppose The answer can be bounded as since we can reach the pair in steps using something similar to Fibonacci sequence building and then go from to in steps And the number of non redundant states on each layer is not greater than because of two states with the same weapon or the same armor set at least one is redundant So if we don t continue BFS from redundant vertices it will visit at most vertices There might be another logarithm in the asymptotic complexity of the solution if you use something like a set to store all combinations that synergize well but this implementation is still fast enough 
The Red Kingdom is attacked by the White King and the Black King The Kingdom is guarded by castles the th castle is defended by soldiers To conquer the Red Kingdom the Kings have to eliminate all the defenders Each day the White King launches an attack on one of the castles Then at night the forces of the Black King attack a castle possibly the same one Then the White King attacks a castle then the Black King and so on The first attack is performed by the White King Each attack must target a castle with alive defender in it There are three types of attacks a decreases the number of defenders in the targeted castle by or sets it to if there are already less than defenders an decreases the number of defenders in the targeted castle by or sets it to if there are already less than defenders a decreases the number of defenders in the targeted castle by or sets it to if there are already less than defenders The can be launched at any valid target at any castle with at least one soldier However the cannot be launched if the had the same type no matter when and by whom it was launched The same applies to the A castle that was not attacked at all can be targeted by any type of attack The King who launches the last attack will be glorified as the conqueror of the Red Kingdom so both Kings want to launch the last attack and they are wise enough to find a strategy that allows them to do it no matter what are the actions of their opponent if such strategy exists The White King is leading his first attack and you are responsible for planning it Can you calculate the number of possible options for the first attack that allow the White King to launch the last attack Each option for the first attack is represented by the targeted castle and the type of attack and two options are different if the targeted castles or the types of attack are different ,This problem seems like a version of Nim with some forbidden moves so let s try to apply Sprague Grundy theory to it First of all we may treat each castle as a separate game compute its Grundy value and then XOR them to determine who is the winner of the game When analyzing the state of a castle we have to know two things the number of remaining soldiers in it and the type of the last attack performed on it So the state of the game can be treated as a pair We can compute Grundy values for each state in a straightforward way but the constraints are too large to do it Instead we should try to search for a period five consecutive rows by row we mean a vector of Grundy values for the same number of remaining soldiers but different types of last attacks of Grundy values determine all of the values after them so as soon as we get the same five rows of Grundy values that we already met we can determine the period There are values stored in these five rows so the period can be up to but that s a really generous upper bound Some intuition can help us to prove something like or as an upper bound but it is better to check all cases with brute force and find out that the period is at most After we ve found the period of Grundy values it s easy to get them in for any castle To count the number of winning moves for the first player we can compute the XOR sum of all castles and for each castle check what happens if we make some type of attack on it if the XOR sum becomes then this move is winning 
There are bags each bag contains balls with numbers from to For every there is exactly one ball with number in each bag You have to take exactly one ball from each bag all bags are different so for example taking the ball from the first bag and the ball from the second bag is not the same as taking the ball from the first bag and the ball from the second bag After that you calculate the number of balls with numbers among the ones you have taken Let the number of these balls be Your task is to calculate the sum of over all possible ways to take balls one from each bag ,The main idea of this problem is to use a technique similar to contribution to the sum We will model the value of as the number of tuples where each element is an index of a bag from which we have taken an odd ball Let be the number of ways to take balls from bags so that all elements from tuple are indices of bags with odd balls then the answer to the problem can be calculated as the sum of over all possible tuples First of all let s obtain a solution in per test case We need to answer the following questions while designing a solution to the problem How do we calculate for a given tuple How do we group tuples and iterate through them The first question is not that difficult Every element from the tuple should be an index of a bag from which we have taken an odd ball so for every bag appearing in the tuple we can take only a ball with odd number but for every bag not appearing in the tuple we can choose any ball So if the number of elements in a tuple is then for the tuple can be calculated as This actually gives as a hint for the answer to the second question since depends on the number of distinct elements in the tuple let s try to group the tuples according to the number of distinct elements in them So the answer will be calculated as where is the number of tuples with exactly different elements How do we calculate First of all if then is obviously Otherwise we can use the following recurrence let be the number of tuples of elements with distinct ones then if and for a tuple with one element there are ways to choose it if and if and there is only one distinct element and it was already chosen if and we either add an element which did not belong to the tuple and there are ways to choose it or we add an already existing element and there are ways to choose it Obviously this recurrence can be calculated in with dynamic programming so we get a solution in per test case How do we speed this up Let s change the way we calculate Instead of considering tuples with values from to we will consider only tuples where values are from to and the first appearance of a value is only after the first appearance of the value So these tuples actually represent a way to split a set of integers into several subsets so they are the Stirling numbers of the second kind and we can calculate them in with dynamic programming outside of processing the test cases How do we calculate using these values If we use distinct integers as the elements of the tuple there are ways to choose the first one ways to choose the second one etc so where is the Stirling number of the second kind for the parameters and We can maintain the values of and while iterating on from to and that gives us a way to solve the problem in per test case Overall complexity for precalculation and per test case 
For an array of integers let s define as the number of elements in it Let s denote two functions is a function that takes an array of integers and a positive integer The result of this function is the array containing first elements of the array that you get by replacing each element of with exactly copies of that element For example is calculated as follows first you replace each element of the array with copies of it so you obtain Then you take the first elements of the array you obtained so the result of the function is is a function that takes an array of integers and two integers and The result of this function is the array with every element equal to replaced by and every element equal to replaced by For example An array is a of the array if either there exists a positive integer such that or there exist two different integers and such that An array is an of the array if there exists a finite sequence of arrays such that is is and for every is a parent of You are given two integers and Your goal is to construct a sequence of arrays in such a way that every array contains exactly elements and all elements are integers from to for every array consisting of exactly integers from to the sequence contains at least one array such that is an ancestor of Print the minimum number of arrays in such sequence ,First of all since the second operation changes all occurrences of some number to other number and vice versa then by using it we can convert an array into another array if there exists a bijection between elements in the first array and elements in the second array It can also be shown that so we can consider that if we want to transform an array into another array then we first apply the function then the function Another relation that helps us is that it means that every time we apply the function we can easily rollback the changes Considering that we have already shown that a sequence of transformations can be reordered so that we apply only after we ve made all operations with the function let s try to rollback the second part of transformations i e for each array find some which can be obtained by using the function Since applying the second operation several times is equal to applying some bijective function to the array we can treat each array as a partition of the set into several subsets So if we are not allowed to perform the first operation the answer to the problem is equal to where is the number of ways to partition a set of objects into non empty sets these are known as There are many ways to calculate Stirling numbers of the second kind but in this problem we will have to use some FFT related approach which allows getting all Stirling numbers for some value of in time For example you can use the following relation If we substitute and we can see that the sequence of Stirling numbers for some fixed is just the convolution of sequences and For simplicity in the following formulas let s denote We now know that this value can be calculated in Okay now back to the original problem Unfortunately we didn t take the operation into account Let s analyze it The result of function consists of several blocks of equal elements and it s easy to see that the lengths of these blocks except for maybe the last one should be divisible by The opposite is also true if the lengths of all blocks except maybe for the last one are divisible by some integer then the array can be produced as for some array What does it mean If the greatest common divisor of the lengths of the blocks except for the last one is not the array that we consider can be obtained by applying the function to some other array Otherwise it cannot be obtained in such a way Now inclusion exclusion principle comes to the rescue Let s define as the number of arrays that we consider which have the lengths of all their blocks except maybe for the last one divisible by It s easy to see that we can compress every consecutive elements into one Then using inclusion exclusion principle we can see that the answer is where is the Mobius function Using this formula we can calculate the answer in This inclusion exclusion principle handles the arrays according to the GCD of the blocks that they consist of except for the last one But what if the array consists only of one block These arrays can be counted wrongly so we should exclude them i e use instead of just and count the arrays consisting of the same element if we need any of them in the answer separately Depending on the way you implement this or or both may be a corner case 
Limak is an old brown bear He often goes bowling with his friends Today he feels really good and tries to beat his own record For rolling a ball one gets a score an integer maybe negative number of points Score for the th roll is multiplied by and scores are summed up So for rolls with scores the total score is The total score is if there were no rolls Limak made rolls and got score for the th of them He wants to maximize his total score and he came up with an interesting idea He can say that some first rolls were only a warm up and that he wasn t focused during the last rolls More formally he can cancel any prefix and any suffix of the sequence It is allowed to cancel all rolls or to cancel none of them The total score is calculated as if there were only non canceled rolls So the first non canceled roll has score multiplied by the second one has score multiplied by and so on till the last non canceled roll What maximum total score can Limak get ,The key is to use divide and conquer We need a recursive function f left right that runs f left mid and f mid 1 right where and also considers all intervals going through We will eventually need a convex hull of lines linear functions and let s see how to achieve it For variables we will try to write the score of interval as a linear function It would be good to get something close to where and depend on and depends on only For each we should find a linear function where should fit the equation Now we have a set of linear functions representing all possible left endpoints For each right endpoint we should find and to fit equation again With value of we can iterate over functions to find the one maximizing value of And still for fixed we should add to get the maximum possible score of interval ending in 
Limak is a grizzly bear He is big and dreadful You were chilling in the forest when you suddenly met him It s very unfortunate for you He will eat all your cookies unless you can demonstrate your mathematical skills To test you Limak is going to give you a puzzle to solve It s a well known fact that Limak as every bear owns a set of numbers You know some information about the set The elements of the set are distinct positive integers The number of elements in the set is The number is divisible by All elements are between and inclusive bears don t know numbers greater than For each in the set contains exactly elements that give remainder when divided by That is there are elements divisible by elements of the form elements of the form and so on Limak smiles mysteriously and gives you hints about his set The th hint is the following sentence If you only look at elements that are between and inclusive you will find exactly such elements in my set In a moment Limak will tell you the actual puzzle but something doesn t seem right That smile was very strange You start to think about a possible reason Maybe Limak cheated you Or is he a fair grizzly bear Given and hints check whether Limak can be fair i e there exists at least one set satisfying the given conditions If it s possible then print Otherwise print ,At the beginning to make things simpler we should add a query hint with and then sort queries by Sorted queries hints divide interval into disjoint intervals For each interval we know how many elements should be there Let s build a graph and find a max flow there The answer is YES only if the flow is The first group contains vertices representing possible remainders The second group contains vertices representing intervals Each vertex from should be connected with the source by an edge with capacity Each vertex from should be connected with the sink by an edge with capacity equal to the size of the interval Between each vertex from and from should be an edge with capacity equal to the number of numbers in the interval giving remainder when divided by You can also use see that it s similar to finding matching In fact we can use the Hall s marriage theorem For each of sets of vertices from sets of remainders iterate over intervals and count how many numbers we can take from with remainders from the fixed set of remainders 
You are given segments Each segment has one of two colors the th segment s color is Let s call a pair of segments and if the following two conditions are met the segments and intersect embed or touch i e there exists an integer such that and Calculate the maximum number of segments that can be selected from the given ones so that there is no pair among the selected ones ,There are two approaches to this problem Most of the participants of the round got AC by implementing dynamic programming with data structures such as segment tree but I will describe another solution which is much easier to code Let s consider a graph where each vertex represents a segment and two vertices are connected by an edge if the corresponding segments compose a bad pair Since each bad pair is formed by two segments of different colors the graph is bipartite The problem asks us to find the maximum independent set and in bipartite graphs the size of the independent set is equal to where is the number of vertices and is the size of the maximum matching The only thing that s left is finding the maximum matching Let s use event processing approach to do it for each segment create two events the segment begins and the segment ends While processing the events maintain the currently existing segments in two sets grouped by their colors and sorted by the time they end When a segment ends let s try to match it with some segment of the opposite color and it s quite obvious that we should choose a segment with the minimum to form a pair Overall this solution runs in 
You are given a permutation consisting of integers a permutation is an array where each element from to occurs exactly once Let s call an array if the following undirected graph is bipartite the graph consists of vertices two vertices and are connected by an edge if and Your task is to find a array of integers of size such that or or report that no such array exists If there are multiple answers print any of them ,To begin with let s understand that an array is bipartite if and only if there is no decreasing subsequence of length in the array Now we can write dynamic programming is there an array of length such that is the maximum last element of a decreasing subsequence of length and is the maximum last element of a subsequence of length Note that Let s consider all possible transitions from the state if we are trying to put the number on the th position where if then the new state will be if then the new state will be if then such a transition is not valid because a decreasing subsequence of length is formed in the array With a naive implementation such dynamic programming works in We can note that for fixed values of and and it is enough for us to store only the minimum available value of So we can write dynamic programming which is defined similarly to the above but now instead of being Boolean stores the minimum value of or infinity if the state is not valid We have speeded up our solution to but it is still too slow To speed up the solution even more we have to look at the transitions in dynamics and notice that for a fixed either or is always equal to So we can rewrite our dynamic programming in the following form Here the flag says which of the numbers and is equal to and the flag is responsible for the sign of and the minimum value of or is stored in the value itself depending on Thus we got a solution with a linear running time In fact this solution can be simplified if we see the following relation the number we use on position is not less than and not greater than This allows us to get rid of one of the states in our dynamic programming altogether so we get an easier solution This optimization wasn t required to get AC but the code becomes shorter 
You are given an undirected graph consisting of vertices Initially there are no edges in the graph Also you are given queries each query either adds one undirected edge to the graph or removes it After each query you have to check if the resulting graph is bipartite that is you can paint all vertices of the graph into two colors so that there is no edge connecting two vertices of the same color ,If the edges were only added and not deleted it would be a common problem that is solved with disjoint set union All you need to do in that problem is implement a DSU which maintains not only the leader in the class of some vertex but also the distance to this leader Then if we try to connect two vertices that have the same leader in DSU and the sum of distances to this leader is even then we get a cycle with odd length and graph is no longer bipartite But in this problem we need to somehow process removing edges from the graph In the algorithm I will describe below we will need to somehow remove the last added edge from DSU or even some number of last added edges How can we process that Each time we change some variable in DSU we can store an address of this variable and its previous value somewhere for example in a stack Then to remove last added edge we rollback these changes we rewrite the previous values of the variables we changed by adding the last edge Now we can add a new edge and remove last added edge All these operations cost because path compression doesn t work in intended time if we have to rollback Let s actually start solving the problem For convinience we change all information to queries like edge exists from query number till query number It s obvious that there are no more than such queries Let s use divide and conquer technique to make a function that answers whether the graph is bipartite or not after every query from some segment of queries First of all we add to DSU all the edges that are present in the whole segment and not added yet then we solve it recursively for and then we remove edges from DSU using the rollback technique described above When we arrive to some segment then after adding the edges present in this segment we can answer if the graph is bipartite after query Remember to get rid of the edges that are already added and the edges that are not present at all in the segment when you make a recursive call Of course to solve the whole problem we need to call our function from segment Time complexity is because every edge will be added only in calls of the function 
You are given a tree consisting of vertices There are chips placed in vertices All are distinct Vertices are colored black initially The remaining vertices are white You are going to play a game where you perform some moves possibly zero On the th move indexed you are going to move the st chip from its current vertex to an adjacent vertex and color that vertex So if you move chip on move chip on move chip on move chip on move chip on move and so on If there is no adjacent white vertex then the game ends What s the maximum number of moves you can perform ,The constraints tell us that the solution should be linear or pretty close to it Well in particular that implies that the solution almost certainly isn t dynamic programming since we have both and to care about Thus we ll think about something greedy When we know the number of move the game will last we can tell how many steps each chip should make Well since the more moves the game last the more steps each ship makes the answer is a monotonic function Let s apply binary search and think if we can check if each chip can make some known number of steps A common idea in the problems where you have to do something greedily on a tree is to root the tree arbitrarily and process everything bottom up Consider the bottommost chip If it can move its number of moves downwards it s always optimal to do that Since it s the bottommost chip it can only make things worse for chips above it And any of them can t pass through the initial vertex of this chip anyway If it can t it has to move to its parent vertex Let s move it there and deal with this chip later when it becomes the bottommost again If it can t move to its parent it can t move at all Thus the game can t last for this many steps Since we only apply either the move which is guaranteed to not interrupt any other moves or the move which is forced the greedy strategy is correct As for implementation details it s not too tricky Basically for each vertex we should maintain these values if this vertex has been visited the number of steps the chip in this vertex still has to make if any chip is in this vertex the longest path downwards from this vertex via non visited vertices The second value can be initialized beforehand and pushed to the parent when needed The rest of them are easily maintained with a single dfs Overall complexity per testcase 
You have a bag which contains cards There is a number written on each card the number on th card is You are playing the following game During each turn you choose and remove a random card from the bag all cards that are still left inside the bag are chosen equiprobably Nothing else happens during the first turn but during the next turns after removing a card let the number on it be you compare it with the card that was removed during the previous turn let the number on it be Possible outcomes are if the game ends and you lose if the game ends and you win if the game continues If there are no cards left in the bag you lose You have to calculate the probability of winning in this game It can be shown that it is in the form of where and are non negative integers and Output the value of ,Let s solve the problem by dynamic programming Let be the probability of winning if the last taken card has number on it and the number of taken cards is We win immediately next turn if we take card with number on it The probability of this is where is number of cards with Also we can win if we take a greater card next turn We take a card with number with probability with number with probability and so on The probability of winning in this case will be and respectively So the probability of winning for is Therefore all we need is to maintain the sum while calculating our dynamic programming 
Digital collectible card games have become very popular recently So Vova decided to try one of these Vova has cards in his collection Each of these cards is characterised by its power magic number and level Vova wants to build a deck with total power not less than but magic numbers may not allow him to do so Vova can t place two cards in a deck if the sum of the magic numbers written on these cards is a prime number Also Vova cannot use a card if its level is greater than the level of Vova s character At the moment Vova s character s level is Help Vova to determine the minimum level he needs to reach in order to build a deck with the required total power ,The most tricky part of the problem is how to check if some set of cards allows us to build a deck with the required power not taking the levels of cards into account Suppose we have not more than one card with magic number if there are multiple cards with this magic number then we obviously can use only one of these Then two cards may conflict only if one of them has an odd magic number and another has an even magic number otherwise their sum is even and not less than so it s not a prime number This allows us to solve this problem as follows Construct a bipartite graph each vertex represents a card and two vertices are connected by an edge if the corresponding pair of cards can t be put in a deck Then we have to find the maximum weight of independent set in this graph This can be solved using maximum flow algorithm construct a network where source is connected with every odd vertex a vertex that represents a card with an odd magic number by an edge with capacity equal to the power of this card then connect every odd vertex to all even vertices that are conflicting with this vertex by edges with infinite capacities and then connect every even vertex to the sink by an edge with capacity equal to the power of the card all edges have to be directed Then the maximum power of the deck is equal to where is the sum of all powers and is the minimum cut value between the source and the sink which is equal to the maximum flow This allows us to check if we can build a deck of required power using only some set of cards for example only cards with level less than or equal to some 
Consider the following experiment You have a deck of cards and exactly one card is a joker times you do the following shuffle the deck take the top card of the deck look at it and return it into the deck Let be the number of times you have taken the joker out of the deck during this experiment Assuming that every time you shuffle the deck all possible permutations of cards are equiprobable what is the expected value of Print the answer modulo ,1278F CardsFirst of all I would like to thank Errichto for his awesome lecture on expected value part 1 part 2 This problem was invented after I learned the concept of estimating the square of expected value from that lecture and the editorial uses some ideas that were introduced there Okay now for the editorial itself We call a number as good if and the th shuffle of the deck resulted in a joker on top from our problem is the number of such good numbers We can represent as the number of pairs such that every element of the pair is a good number as the number of triples and so on is the number of tuples such that each element of a tuple is a good number So we can rewrite the expected value of as the expected number of such tuples or the sum of over all tuples where is the probability that consists of good numbers How to calculate the probability that is a good tuple Since all shuffles of the deck result in a joker with probability should be equal to but that is true only if all elements in are unique How to deal with tuples with repeating elements Since all occurences of the same element are either good or bad with probability of being good the correct formula for is where is the number of distinct elements in the tuple Okay then for each we have to calculate the number of tuples with exactly distinct elements To do that we use dynamic programming let be the number of tuples with exactly distinct elements Each transition in this dynamic programming solution models adding an element to the tuple if we want to compute the transitions leading from we either add a new element to the tuple there are ways to choose it and we enter the state or we add an already existing element there are ways to choose it and we enter the state Overall complexity is or depending on your implementation 
A chainword is a special type of crossword As most of the crosswords do it has cells that you put the letters in and some sort of hints to what these letters should be The letter cells in a chainword are put in a single row We will consider chainwords of length in this task A hint to a chainword is a sequence of segments such that the segments don t intersect with each other and cover all letter cells Each segment contains a description of the word in the corresponding cells The twist is that there are actually two hints one sequence is the row above the letter cells and the other sequence is the row below the letter cells When the sequences are different they provide a way to resolve the ambiguity in the answers You are provided with a dictionary of words each word consists of lowercase Latin letters All words are pairwise distinct An instance of a chainword is the following triple a string of lowercase Latin letters the first hint a sequence of segments such that the letters that correspond to each segment spell a word from the dictionary the second hint another sequence of segments such that the letters that correspond to each segment spell a word from the dictionary Note that the sequences of segments don t necessarily have to be distinct Two instances of chainwords are considered different if they have different strings different first hints different second hints Count the number of different instances of chainwords Since the number might be pretty large output it modulo ,Let s use a trie to store the given words Now let s imagine a procedure that checks if some string of length can be represented as a concatenation of some of these words If the words were prefix independent no word was a prefix of another word that task would be solvable with a greedy algorithm We could iterate over a string and maintain the current vertex of the trie we are in Append a current letter If there is no such transition in a trie it can t be represented If the vertex we go to is a terminal jump to the root of the trie Otherwise just go to that vertex However since the words aren t prefix independent we have a terminal on a path to other terminals Thus we can t immediately decide if we should jump to the root or just go Let s handle this with dynamic programming can we put letters in such a way that the vertex of a trie we are in is Is building a chainword letter by letter that different from this process Apparently it isn t Consider how many ways are there to put letters in a string so that the first hint is in a vertex and the second hint is in a vertex For the transition we can try all letters to put and jump to the corresponding vertices That obviously is too slow The intuition tells us that this dp should be calculated with some kind of matrix exponentiation since That dp can be rewritten as a matrix pretty easily However its size is up to the maximum number of vertices in a trie squared Some say that there is a way to compute the th power of such a huge matrix fast enough with Berlekamp Massey but I unfortunately am not familiar with it Thus we ll have to reduce the size of our matrix First notice that the only reachable states are such that the word that is written on a path from the root to is a suffix of a word that is written on a path from the root to or vice versa Look at it the other way if we build a trie on the reversed words then one of the vertices will be an ancestor of another one Now it s easy to estimate the number of states as the sum of depths of all vertices However since we look at ordered pairs of we should more or less double that amount That should be states at max This can probably pass with an optimal enough implementation We can do better though Let s merge the states and into one state The intuition is basically that you can swap the hints at will That makes the pairs unordered now there are up to pairs That surely will work fast enough The way to generate all the possible states is the following run a dfs bfs starting from that makes all valid transition and record all the states that can be visited While preparing the tests I only managed to get up to states and I would really love to hear an approach to either prove a tighter bound or to generate a test closer to the bound of 
Alice and Bob play a game Alice has got treasure chests the th of which contains coins and keys the th of which she can sell Bob for coins Firstly Alice puts some locks on the chests There are types of locks the locks of the th type can only be opened with the th key To put a lock of type on the th chest Alice has to pay dollars Alice can put any number of different types of locks on each chest possibly zero Then Bob buys some of the keys from Alice possibly none possibly all of them and opens each chest he can he can open a chest if he has the keys for all of the locks on this chest Bob s profit is the difference between the total number of coins in the opened chests and the total number of coins he spends buying keys from Alice If Bob s profit is greater than zero he wins the game Otherwise Alice wins the game Alice wants to put some locks on some chests so no matter which keys Bob buys she always wins Bob cannot get positive profit Of course she wants to spend the minimum possible number of dollars on buying the locks Help her to determine whether she can win the game at all and if she can how many dollars she has to spend on the locks ,Firstly let s try to find some naive solution for this problem Let s iterate on the subset of locks Alice puts on the chests After choosing the subset of locks how to check whether Bob can gain positive profit We can iterate on the subset of keys he can buy as well but in fact this problem has a polynomial solution Construct a flow network as follows each chest and each key represents a vertex there are arcs from the source to the vertices representing the chests each having capacity arcs from the vertices representing the keys to the sink each having capacity and for each chosen lock an arc from the respective chest vertex to the respective key vertex with infinite capacity If we find the minimum cut from the source to the sink then Bob s profit is The reasoning behind this solution is the following one if Bob takes all the chests and all the keys belonging to the first part of the cut his profit is equal to the total cost of all chests he has taken minus the total cost of all keys he has taken minus infinity if he takes a chest he can t open And the value of the cut is equal to the total cost of chests he doesn t take plus the total cost of keys he takes plus infinity if he can t open some chest he takes since the arc from this chest vertex to one of the key vertices belongs to the cut So Bob s profit is and by minimizing the cut value we maximize his profit A minimum cut can be easily found using any maxflow algorithm Unfortunately even iterating through all subsets of locks is too slow To improve this solution we should look at the minimum cut and its usage a bit more in detail Notice that Bob can always take no keys and open no chests to get a profit of zero so Alice s goal is to ensure that it is the best Bob s option If Bob takes no chests and no keys it means that the cut divides the network into two parts the source and all other vertices And in terms of flows it means that the maximum flow in this network I highlighted it because it is the key idea of the solution Here the constraints on and come in handy We can use a dynamic programming with the flow over all arcs going from the source as one of the states One of the ways to implement it is to have as the state where through are the values of the flow going from the arcs from the source is the current vertex in the left part we consider is the current vertex in the right part we consider and is the flow we already pushed through the arc connecting vertex of the right part to the sink and the value we store for this state is the minimum cost Alice has pay to reach this state There are two basic types of transitions in this dynamic programming we either skip the arc from to or pick it and transfer some flow through it and no matter what we ve chosen we move to the next vertex of the left part or to and increase by if we are already considering the th vertex of the left part The constraints were loose enough to implement this dp basically in any form there was no need to compress the states into single integers for example which was what the most participants of the round did 
Petya recently found a game Choose a Square In this game there are points numbered from to on an infinite field The th point has coordinates and cost You have to choose a square such that its sides are parallel to coordinate axes the lower left and upper right corners belong to the line and all corners have integer coordinates The score you get is the sum of costs of the points covered by the selected square minus the length of the side of the square Note that the length of the side can be zero Petya asks you to calculate the maximum possible score in the game that can be achieved by placing exactly one square ,Notice that the square covers the point if and only if Using this fact let s reformulate the problem the following way we have to find the segment such that the sum of the segments fully covered by it is maximal Let s build a segment tree the th of its leaves stores the sum of the segments covered by the segment Initially it s built for some such that it is to the right of all segments Other nodes store the maximum in them Now let s iterate over the values of in descending order Let there be some segment starting in with the cost All the answers for won t change because they don t cover that new segment And the values on the suffix from the position will increase by The only thing left is to learn how to handle the subtraction of the length of the side That term is and the thing we are looking for is Rewrite it in form and you ll see that you can just subtract from the value of the th leaf of the segment tree at the beginning to get the correct result Surely you ll need to add that after you ask the maximum of all the segtree to obtain the answer You ll probably need to compress the coordinates leave only such positions that there is at least one or Implicit segtree might work but neither ML nor TL are not friendly to it Also be careful with the case with all points being negative 
You are given an undirected unweighted tree consisting of vertices An undirected tree is a connected undirected graph with edges Your task is to choose two pairs of vertices of this tree all the chosen vertices and in such a way that neither nor belong to the simple path from to and vice versa neither nor should not belong to the simple path from to Among all possible ways to choose such pairs you have to choose one with the between paths from to and from to And among all such pairs you have to choose one with the of these two paths The length of the path is the number of edges in it The simple path is the path that visits each vertex at most once ,Firstly let s call a path from to if is a leaf is a vertex of degree at least the number of their neighbors is at least and there are no other vertices of degree at least on this path expect the vertex The first step of the solution is to remove all the paths from to but we should not remove the vertex and remember for each vertex the sum of two maximum lengths of paths which end in the vertex Let this value for the vertex be For example if for some vertex there are good paths with end in it of lengths and correspondingly then will be Okay it is easy to see that the maximum intersection of two paths in the answer will be equal to the length of the diameter of the obtained tree But we can not take diameter of this tree and call it the answer because of the second constraint we need to find some diameter from to such that the sum is maximum possible How do we do that There is such an awesome and well known fact that the center of a tree belongs to all diameters of this tree Let s root the tree by the center of a tree if the length of the diameter is odd the center of a tree is an edge then let s root the tree by any end of this edge it does not matter There is one case when the length of the diameter is but it is pretty trivial to handle it Now our problem is to find two neighbors of the root of the new tree such that in their subtrees are vertices which form some diameter of this tree and the sum of values of these vertices is maximum possible Let s calculate the vertex with the maximum distance from a root and with the maximum possible for equals distances by simple for each neighbor of a root It can be done in and the last part is to find two maximums of this list it also can be done in or depends on implementation 
You are given a matrix with rows and columns Each element of the matrix is either an asterisk or a dot You may perform the following operation arbitrary number of times choose a square submatrix of with size where and replace each element of the chosen submatrix with a dot Choosing a submatrix of size costs coins What is the minimum number of coins you have to pay to replace all asterisks with dots ,Constraints lead us to some kind of dp solution is it usually called dp on broken profile Let will be the minimum price to get to th column and th row with selected is the previous cells inclusive from if then its exactly current column and two previous ones Transitions for submatrices and are straighforward just update mask with new ones and add to current value If the first cell of these is empty or is set in this position then you can go to or and if for free Finally you can go to with the price of Initial value can be in the first cells of the matrix The answer will be stored in some valid of However you can add extra empty columns and take the answer right from it will be of the same price Overall complexity 
You are given a string of length consisting of lowercase Latin letters You may apply some operations to this string in one operation you can delete some contiguous substring of this string if all letters in the substring you delete are equal For example after deleting substring from string we get the string Calculate the minimum number of operations to delete the whole string ,We will solve the problem by dynamic programming Let be the answer for substring Then we have two cases The first letter of the substring is deleted separately from the rest then The first letter of the substring is deleted alongside with some other letter both letters must be equal then 
You re given a tree with vertices The color of the th vertex is The value of the tree is defined as where is the number of edges on the shortest path between and The color of each vertex is lost you only remember that can be any integer from inclusive You want to calculate the sum of values of all trees meeting these conditions modulo the set of edges is fixed but each color is unknown so there are different trees ,Let s set the root as Define as the lowest common ancestor of vertices and as the depth of vertex Obviously The answer we want to calculate is where represent all possible colorings of the tree We can enumerate the color For a fixed color we need to calculate Let Also denote as a predicate which is true iff Now our problem is how to maintain this formula while enumerating the color can be easily maintained For we can add to all vertices in path to for each existing vertex and when new vertex is added just calculate the sum of vertices on path from to minus the contribution of vertex because there are vertices in the path to and multiply it Similar operation can be used to handle the situation when some vertex disappears All of this can be done with HLD Overall it s 
Alice and Bob want to play a game They have colored paper strips the th strip is divided into cells numbered from to Each cell can have one of colors In the beginning of the game Alice and Bob put chips the th chip is put in the th cell of the th strip Then they take turns Alice is first Each player during their turn has to choose one chip and move it or cells backwards i e if the current cell is then the chip can be moved to the cell or There are two restrictions the chip cannot leave the borders of the strip for example if the current cell is then you can t move the chip cells backwards and some moves may be prohibited because of color of the current cell a matrix with size is given where if it is possible to move the chip cells backwards from the cell which has color or if such move is prohibited The player who cannot make a move loses the game Initially some cells may be uncolored Bob can color all uncolored cells as he wants but he cannot leave any cell uncolored Let s call a coloring if Bob can win the game no matter how Alice acts if the cells are colored according to this coloring Two colorings are different if at least one cell is colored in different colors in these two colorings Bob wants you to calculate the number of good colorings Can you do it for him Since the answer can be really large you have to print it modulo ,Suppose there is only one strip and we want to count the number of ways to paint it We can do it with some dynamic programming let dp i r 1 r 2 r 3 be the number of ways to paint first i cells of the strip so that r 1 denotes the result of the game if it starts in the last cell r 1 0 if the player that makes a turn from this state loses or r 1 1 if he wins r 2 the result if the game starts in the second to last and so on Then if we paint the next cell we can easily determine the result of the game starting in it using the values of r i and the set of possible moves if there is a value r i 0 such that we can move the chip i cells backwards from the cell we just painted then that cell is a winning one if the game starts in it the first player wins otherwise it is a losing one This dynamic programming works too slow since the strip can be very long but we can skip long uncolored segments converting the transitions of this dp into matrix vector multiplication each possible combination of values of r 1 r 2 r 3 can be encoded as a number from 0 to 7 and we may construct a 8 times 8 transition matrix T T i j will be equal to the number of ways to color one cell so that the previous values of r 1 r 2 r 3 have code i and the next values have code j To model painting k consecutive uncolored segments we may compute T k with fast exponentiation method Now we can solve the problem for one strip What changes if we try to apply the same method to solve the problem with many strips Unfortunately we can t analyze each cell as winning or losing now we need more information When solving a problem related to a combination of acyclic games we may use Sprague Grundy theory you can read about it here https cp algorithms com game theory sprague grundy nim html Instead of marking each cell as winning or losing we can analyze the Grundy value of each cell When considering a strip we should count the number of ways to color it so that its Grundy is exactly x we should do it for every possible value of x which can help us to solve the initial problem with the following dynamic programming z i j is the number of ways to color i first strips so that the Grundy value of their combination is exactly j The only thing that s left to consider is how do we count the number of ways to color a single strip so that its Grundy value is fixed We can to it by modifying the method described in the first paragraph let dp i r 1 r 2 r 3 be the number of ways to paint i first cells so that the Grundy value of the last cell is r 1 the value of the previous to last cell is r 2 and so on Since we have only 3 possible moves the Grundy values are limited to 3 and each possible combination of values of r 1 r 2 r 3 can be encoded as a number from 0 to 63 The transition matrix T that allows us to skip long uncolored segments will be a 64 times 64 one so if we will just exponentiate it every time we want to skip a segment we ll get TL but we can optimize it by precalculating T T 2 T 4 T 2 30 and using matrix vector multiplication instead of matrix matrix multiplication every time we skip an uncolored segment 
There are communication towers numbered from to and bidirectional wires between them Each tower has a certain set of frequencies that it accepts the th of them accepts frequencies from to Let s say that a tower is accessible from a tower if there exists a frequency and a sequence of towers where consecutive towers in the sequence are directly connected by a wire and each of them accepts frequency Note that accessibility is not transitive i e if is accessible from and is accessible from then may not be accessible from Your task is to determine the towers that are accessible from the st tower ,Let s consider the sweep line approach by the value of the variable x the vertex i is active from the moment l i to the moment r i And we have to find vertices that are reachable in the graph of active vertices from the vertex 1 So we rephrased the problem as follows there are vertices that are active at some moments and we want to get some information about connectivity during each moment of time This is a standard offline dynamic connectivity problem which can be solved with a divide and conquer approach described here Now we are able to find the connectivity component of the 1 th vertex for each value of x It remains to understand how to combine answers for all values of x fast enough Let s try to visualize the components as vertices of a directed graph We assign a vertex to each component and when two components merge we add two directed edges from the new vertex to the vertices corresponding to the components and now we can use the reachability information in this graph Each vertex of the original graph corresponds to one of the sinks in this graph and sinks that correspond to the vertices of some component are reachable from the vertex corresponding to that component To restore all the vertex indices later we will mark all components containing the vertex 1 while we run our dynamic connectivity approach Then the vertex v of the original graph is included in the answer if the vertex representing the component containing only the vertex v is reachable from any of the marked vertices Now all you need to do is run DFS or BFS from all the marked vertices in the component graph 
There are points marked on the plane The points are situated in such a way that they form a regular polygon marked points are its vertices and they are numbered in counter clockwise order You can draw segments each connecting any two marked points in such a way that all points have to be connected with each other directly or indirectly But there are some restrictions Firstly some pairs of points cannot be connected directly and have to be connected undirectly Secondly the segments you draw must not intersect in any point apart from the marked points that is if any two segments intersect and their intersection is not a marked point then the picture you have drawn is invalid How many ways are there to connect all vertices with segments Two ways are considered different iff there exist some pair of points such that a segment is drawn between them in the first way of connection but it is not drawn between these points in the second one Since the answer might be large output it modulo ,We can use dynamic programming to solve this problem but we need to choose the states we maintain very carefully One of the approaches might be the number of ways to connect the vertices between and to vertices or if and are already connected so there is no possibility to connect any vertex between and to some vertex outside What values should we access if we for example try to connect th vertex to some vertex To get everything connected we then have to connect vertices from interval to these two and vertices from to or and connections to from the second interval are difficult to handle We need to somehow get rid of them and the solution is to And vice versa if we connect something to then we choose the index of vertex to be connected with directly But that s not all we have to handle Suppose we have four vertices and is already connected to One of the possibilities to finish it is to connect to and to but if we process current dynamic programming as it is we will count it twice if we choose to connect to firstly or if we connect to To get rid of this problem we will use a flag that will denote whether we can connect anything to vertex and if we choose to pick the first connection from then we don t connect anything to So the solution is the number of ways to connect the vertices from interval to and and denotes if we can connect anything to How to calculate it If then there is nothing left to connect Otherwise set If then iterate on vertex we connect to and add Iterate on vertex we connect to and add The answer is if vertices are indexed Vertex is actually vertex so don t forget to update the matrix for it 
Alice and Bob play a game The game consists of several sets and each set consists of several rounds Each round is won either by Alice or by Bob and the set ends when one of the players has won rounds in a row For example if Bob won five rounds in a row and then two sets ends You know that Alice and Bob have already played rounds and you know the results of some rounds For each from to calculate the maximum possible number of sets that could have already finished if each set lasts until one of the players wins rounds in a row It is possible that the last set is still not finished in that case you should not count it in the answer ,Let s consider the following function minimum index such that there is a substring of string of length consisting of only characters and or and If this function has asymptotic then we can solve problem for Now let s precalculate two array and is equal the maximum integer such that substring consist only characters and is equal the maximum integer such that substring consist only characters and Also let s precalculate the arrays and of size contain all positions such that substring consist only characters and and or contain all positions such that substring consist only characters and and or After that let s solve problem for some Suppose that now we already processed first elements of If or then we increase the answer and change Otherwise we have to find the minimum element denote this element as in or such that If there is no such element then we found the final answer Otherwise let s increase answer and change and continue this algorithm 
Let s call a non empty sequence of positive integers if the greatest common divisor of all elements of this sequence is equal to Given an array consisting of positive integers find the number of its subsequences Since the answer may be very large print it modulo Note that two subsequences are considered different if chosen indices are different For example in the array there are different subsequences and ,This problem can be solved using inclusion exclusion Let be the number of subsequences such that all elements of the subsequence are divisible by We can calculate which is the number of elements divisible by by factorizing all elements of the sequence and generating their divisors and Then we can apply the inclusion exclusion principle and get the resulting formula where is the M bius function 
Couple Cover a wildly popular luck based game is about to begin Two players must work together to construct a rectangle A bag with balls each with an integer written on it is placed on the table The first player reaches in and grabs a ball randomly all balls have equal probability of being chosen the number written on this ball is the rectangle s width in meters This ball is not returned to the bag and the second player reaches into the bag and grabs another ball the number written on this ball is the rectangle s height in meters If the area of the rectangle is greater than or equal some threshold square meters the players win Otherwise they lose The organizers of the game are trying to select an appropriate value for so that the probability of a couple winning is not too high and not too low but they are slow at counting so they have hired you to answer some questions for them You are given a list of the numbers written on the balls the organizers would like to know how many winning pairs of balls exist for different values of Note that two pairs are different if either the first or the second ball is different between the two in pair and two different balls with the same number are considered different ,Let s count the number of pairs with multiple less than To get the number of not less pairs we should sumply subtract from the number of less pairs Let be the number of values in equal to and be the number of pairs from with the multiple equal to To calculate the values from we can use something like Eratosthenes sieve let s iterate over the first multiplier and the multiple of it and increment by the value After calculating the array we should calculate the array of its partial sums and find the number of less pairs in time 
You are given a string of length Each character is one of the first lowercase Latin letters You are also given a matrix with binary values of size This matrix is symmetric means that the string can have the th and th letters of Latin alphabet adjacent Let s call the string if in it can be adjacent have 1 in the corresponding cell of matrix You are allowed to do the following move Choose any letter remove and join the remaining parts of the string without changing their order For example removing letter a from abacaba will yield bcb The string you are given is The string should remain You are allowed to do arbitrary number of moves possible zero What is the shortest resulting string you can obtain ,Each state of the string can be denoted as the set of characters we deleted from it and each such set can be represented as a bit binary mask where th bit is equal to if th character of the alphabet is already deleted and otherwise Let s call a mask if the string formed by this mask is not crisp Let s also say that a pair of characters forbids mask if is a pair of characters that should not be adjacent but they are adjacent in the string formed by mask If we somehow find all bad masks then the solution would be writing simple bitmask dp to find the best mask that is not bad and reachable from the initial mask the one having all bits set to So let s focus on finding all bad masks Obviously if some pair of characters forbids a mask then it s bad and vice versa Let s pick some pair of characters and find all masks forbidden by it we will do the same for every pair of characters that cannot be adjacent Let s check every occurence of in the initial string For each occurence we will find the closest occurence of to the right of it If there s no any or if there s another between them let s ignore the occurence of we have chosen and move to the next one Otherwise let s find all characters that occur at least once between the fixed occurences of and If all those characters are deleted then these occurences of and will be adjacent so pair forbids any mask that has bits representing and set to bits representing every character occuring in between to and all other bits to any values Let s mark all these masks as forbidden as follows we will write a recursive function that marks mask and every its submask that has bits and set to as forbidden This function should check if is not forbidden if not then mark it as forbidden iterate on the bit we may remove from and call recursively but only if is set to in mask and if and If we implement it in such a way then for each pair it will take operations to mark all masks forbidden by this pair of characters so overall complexity will be or depending on your implementation 
Today Adilbek is taking his probability theory test Unfortunately when Adilbek arrived at the university there had already been a long queue of students wanting to take the same test Adilbek has estimated that he will be able to start the test only seconds after coming Fortunately Adilbek can spend time without revising any boring theorems or formulas He has an app on this smartphone which contains Japanese crosswords to solve Adilbek has decided to solve them all one by one in the order they are listed in the app without skipping any crossword For each crossword a number is given that represents the time it takes an average crossword expert to solve this crossword the time is given in seconds Adilbek is a true crossword expert but unfortunately he is sometimes unlucky in choosing the way to solve the crossword So it takes him either seconds or seconds to solve the th crossword equiprobably with probability he solves the crossword in exactly seconds and with probability he has to spend an additional second to finish the crossword All these events are independent After seconds pass or after solving the last crossword if he manages to do it in less than seconds Adilbek closes the app if he finishes some crossword at the same moment that crossword is considered solved otherwise Adilbek does not finish solving the current crossword at all He thinks it would be an interesting probability theory problem to calculate the expected number of crosswords he will be able to solve completely Can you calculate it Recall that the expected value of a discrete random variable is the probability weighted average of all possible values in this problem it means that the expected value of the number of solved crosswords can be calculated as where is the probability that Adilbek will solve exactly crosswords We can represent as rational fraction with To give the answer you should print ,Let s use as usual linearity of an expected value where is an indicator function and equal to iff Adilbek will be able to solve the th crossword How to calculate If then is always On the other hand if is always Otherwise we need to calculate the needed probability To calculate we can iterate over the number of crosswords among first ones which will require extra time Obviously if then we don t have enough time to solve the th crossword also Let s denote There are ways to choose crosswords with extra time among all variants So the final formula is following The only problem is the efficiency But we can find out several interesting properties At first The other one since then And this exactly the efficient way to transform to by multiplying and adding one coefficient we can transform the prefix sum of the th row to the prefix sum of the row And to reduce the length of the prefix sum we can just subtract unnecessary coefficients In result the total complexity is maybe with extra factor because of modular arithmetic 
You are given an undirected connected graph consisting of vertices and edges Your goal is to destroy all edges of the given graph You may choose any vertex as the starting one and begin walking from it along the edges When you walk along an edge you destroy it Obviously you cannot walk along an edge if it is destroyed You can perform the operation at most once during your walk and this operation can only be performed when you are at some vertex you cannot perform it while traversing an edge After the the edges you go through are deleted in the following way the first edge after the is not destroyed the second one is destroyed the third one is not destroyed the fourth one is destroyed and so on You cannot switch back to the original mode and you don t have to perform this operation if you don t want to Can you destroy all the edges of the given graph ,Let s suppose our graph is split into two graphs and the first graph contains the edges we delete before the mode shift the second graph contains the edges we delete after the mode shift It s quite obvious that the graph has an eulerian path The structure of is a bit harder to analyze but we can prove that it is always a star graph a vertex and some other vertices connected directly to it and the center of the star coincides with the last vertex in the eulerian path in To prove that is a star graph we can consider the second part of the path after the mode shift backward the last edge we traversed was deleted and the previous to last move could have been only along that edge The third last and the fourth last moves should have been along another edge connecting some vertex to the center of the star and so on Okay how do we find a way to split the graph into and Iterate on the center of the star let it be For the graph to contain an eulerian path it should have at most vertices with an odd degree Let s construct in such a way that we minimize the number of odd vertices in for each edge incident to we either move it to or in such a way that the resulting degree of the other vertex is even All other edges belong to If there is an eulerian path in that ends in we are done Otherwise we should iterate on some edge adjacent to and change its status in order to check if can have an eulerian path after that We can t flip two edges because flipping two edges increases the number of odd vertices in at least by if it is already or greater the eulerian path won t exist and if it s then flipping two edges creates two odd vertices none of which is so eulerian path can t end in After flipping each edge we try to find an eulerian path in once again and flip the edge back After checking the vertex as the center of the star we return all adjacent edges to and move to the next vertex The whole algorithm requires checking for the existence of the eulerian path times so it should work in or depending on the implementation Fun fact initially I wanted to give a harder version of a problem with that would require some sort of dynamic connectivity to check for an eulerian path fast but when I started coding it I realized that implementation there was a bit painful so I ve decided to drop the constraints to allow quadratic solutions 
The whole delivery market of Berland is controlled by two rival companies BerEx and BerPS They both provide fast and reliable delivery services across all the cities of Berland The map of Berland can be represented as an graph The cities are vertices and the roads are edges between them Each pair of cities has no more than one road between them Each road connects different cities BerEx and BerPS are so competitive that for each pair of cities they have set up their paths from to in such a way that It is guaranteed that it was possible Now Berland government decided to cut down the road maintenance cost by abandoning some roads Obviously they want to maintain as little roads as possible However they don t want to break the entire delivery system So BerEx and BerPS should still be able to have their paths between every pair of cities non intersecting What is the minimal number of roads Berland government can maintain ,Let s use dynamic programming to solve this problem We will start with a single biconnected component consisting of vertex and connect other vertices to it So the state of our dynamic programming will be a of vertices that are in the same biconnected component with How can we extend a biconnected component in such a way that some other vertices are added into it but it is still biconnected We will add a path possibly cyclic that starts in some vertex belonging to the goes through some vertices and ends in some vertex belonging to the possibly If for every triple we precalculate some path that starts in goes through vertices from and ends in and does not contain neither nor then we can solve the problem in there will be states for every state we will iterate on two vertices and belonging to the and the number of possible pairs of non intersecting masks and is The only thing that s left is precalculating the paths for triples That can be done with auxiliary dynamic programming which will denote whether such a path exists For every edge of the original graph is true and we can go from to some state where will contain all vertices from and vertex and we should ensure that there is an edge in the graph and the didn t contain vertex earlier We should also somehow be able to restore the paths from this dp and we also should be careful not to choose the same edge twice for example if we start a path by edge we should not use the same edge to return to both these things can be done for example by storing next to last vertex in the path 
You are given an integer and an undirected tree consisting of vertices The length of a simple path a path in which each vertex appears at most once between some pair of vertices is the number of edges in this path A diameter of a tree is the maximum length of a simple path between all pairs of vertices of this tree You are about to remove a set of edges from the tree The tree splits into multiple smaller trees when the edges are removed The set of edges is valid if all the resulting trees have diameter less than or equal to Two sets of edges are different if there is an edge such that it appears in only one of the sets Count the number of valid sets of edges modulo ,The task is obviously solved by dynamic programming so our first reaction should be to start looking for meaningful states for it Obviously one of the states is the vertex which subtree we are processing We can choose the root for the tree arbitrarily let it be vertex What can be the other helpful state Consider the method to find the diameter of the subtree of vertex The diameter can be one of the following paths either the longest path that is completely in some subtree of or the concatenation of the longest paths that start in vertex and end in different subtrees The diameter is the longest path Thus the diameter being less than or equal to means that all paths should have length less than or equal to If we can guarantee that no path that is completely in some subtree of have length greater than then we will only have to worry about not concatenating long paths from different subtrees Phrase it the other way around if we never concatenate the paths from the different subtrees in such a way that their total length is greater than then no diameter will be greater than Thus we can attempt to have the number of ways to cut some edges in the subtree of in such a way that there is no path of length greater than and the longest path starting at vertex has length Now for the transitions For the simplicity let vertex have exactly two children It s not too hard to merge their s Iterate over the length of the first child the length of the second child If then you can concatenate their longest paths and the longest path for will be of length You can also cut either of the edges from to the first child or to the second child The approach is good however it s not clear how to make it work on a larger number of children Also the complexity sounds pretty bad Instead of merging children to each other let s merge each child to the of one by one can store the current maximum length over all processed children When processing a new child you can choose to cut or not to cut the edge to it So you can iterate over the current longest path from and the longest path from that child So far the only way to estimate the complexity is to say that each child has to merge its dp to the parent in thus making the algorithm That s obviously too slow The trick that makes the solution fast is to iterate not to but to the height of the subtree of and the subtree of a child Surely that is allowed since the path just can t grow longer than that value Consider the even worse option not the height but the size of the subtree It s easy to see that the size is always greater or equal than the height Interpret the merge the following way enumerate the vertices inside all the subtrees of the processed children and the vertices inside the subtree of the new child Iterating up to the size of the subtree is the same number of moves as going over the vertices in it The merge will go over all the pairs of vertices such that the first vertex of the pair is in the first set and the second vertex is in the second set Thus each pair of vertices of the tree will be processed exactly once in lca of these vertices There are such pairs thus such s work in Overall complexity 
You are given a tree consisting of vertices Initially each vertex has a value You need to perform queries of two types You are given a vertex index Print the value of the vertex You are given two vertex indices and and values and You need to add to the value of each vertex such that the distance from that vertex to the path from to is less than or equal to The between two vertices and is equal to the number of on the path from to For example the distance from to itself is equal to The distance from the vertex to some path from to is equal to the minimum among distances from to any vertex on the path from to ,For the purpose of solving the task let s choose some root in the tree and introduce another operation to the tree add to all vertices that are in the subtree of the given vertex and on the distance from For example if it s itself or if then it s all children of Let s be the parent of vertex and so on So how to perform this operation Instead of adding to all vertices in the subtree we can add only to the vertex And when we need to get the answer for some vertex we will get it from Of course since there are different s we ll create different arrays for each possible So the answer for the vertex will be equal to Now let s discuss how to use the introduced operation to perform the given one We can make the given operation using ours in the following way Let s find using any standard algorithm binary lifting for example Let s split all affected vertices in three groups subtrees of path inclusive exclusive subtrees of path and subtrees of path Note that in such way all affected vertices belong to at least one group Let s look at group of path The lowest vertices are on distance from the next level are on distance from the next level are on distance from and so on The last level we ll consider in this group is the vertices in the subtree of the on distance from it In such a way all we need to do is add to all on the path from The group of the path is handled in the same way What s left It s vertices in subtree of on distances in subtree of on distances in subtree of on distances in subtree of on distance Note that vertices in subtree of on distance are included in vertices in subtree of on distance Analogically vertices on distance from are included in vertices on distance from Moreover vertices on distance from are included in from that are included in from and so on In other words all we need to proccess are vertices in subtree of on distances and in subtree of on distances and in subtree of on distances and In total it s at most operations add to some vertex As a result all we need to do is add on path from to some ancestor of add in some vertex can be done as operation on path ask value in some vertex We can do all of these operations in using Fenwick tree BIT on s and s we can get from binary lifting So the first statement operation will work in time and the second one also in In total complexity is time and space P S the second operation can be further optimized to but it s not really necessary 
You are given a multiset of powers of two More precisely for each from to exclusive you have elements equal to In one operation you can choose any one element and divide it into two elements You should perform queries Each query has one of two types assign calculate the minimum number of operations you need to make at least elements with value lower or equal to Note that all queries of the second type don t change the multiset that is you just calculate the minimum number of operations you don t perform them ,Several observations Generally we have two types of operations divide and either or If then in one division we ll get element so we can just keep track of the total possible number of these operations as If then if we decide to split whole to s then we get elements but in operations i e in one division we ll get elements So it s preferably to fully split than Also the less the more profitable each division As a result let s act greedy let s say we need more elements Let s iterate over in the increasing order If then let s fully split in in operations decrease increase a counter of operations and increase accordingly If then the situation becomes complicated We can either don t touch and try to use preserved operations with small if or split in two s Now we spent one operation and get two If then we don t need one of and can split further only one If then it s optimal to fully split one of and proceed further with only one and recalculated and In both cases we can solve optimal splitting of recursively in the same manner as Since in each step we lower then we need to check only cases per each query Note that we can treat situation in packs for several with equal so the first part also works in The resulting complexity is per query 
You are given a rooted undirected tree consisting of vertices Vertex is the root Let s denote a of vertex as an infinite sequence where is the number of vertices such that both conditions hold is an ancestor of the simple path from to traverses exactly edges The of a of vertex or shortly the of vertex is an index such that for every for every For every vertex in the tree calculate its ,In this problem we can use small to large merging trick also known as DSU on tree when building a depth array for a vertex we firstly build depth arrays recursively for its children then pull them upwards and merge them with small to large technique In different blogs on this technique it was mentioned that this will require operations with structures we use to maintain depth arrays overall However in this problem we may prove a better estimate it will require operations That s because the size of depth array if considering only non zero elements for a vertex is equal to the height of its subtree not to the number of vertices in it To prove that the number of operations is one can use the intuitive fact that when we merge two depth arrays all elements of the smaller array are destroyed in the process so if the size of smaller array is then we require operations to destroy elements The main problem is that we sometimes need to pull our depth arrays upwards thus inserting a to the beginning of the array Standard arrays don t support this operation so we need to either use something like and the complexity will be or keep the depth arrays in reversed order and handle them using and then complexity will be 
You are given two permutations and both of size A permutation of size is an array of elements where each integer from to appears exactly once The elements in each permutation are indexed from to You can perform the following operation any number of times choose an integer from to let be the integer such that Swap with let be the integer such that Swap with Your goal is to make both permutations i e the conditions and must be satisfied using Note that both permutations must be sorted after you perform the sequence of operations you have chosen ,The solution to this problem uses cyclic decomposition of permutations A cyclic decomposition of a permutation is formulated as follows you treat a permutation as a directed graph on vertices where each vertex has an outgoing arc This graph consists of several cycles and the properties of this graph can be helpful when solving permutation based problems First of all how does the cyclic decomposition of a sorted permutation look Every vertex belongs to its own cycle formed by a self loop going from that vertex to itself We will try to bring the cyclic decompositions of the given permutations to this form What does an operation with integer do to the cyclic decomposition of the permutation If is in its own separate cycle the operation does nothing so we swap an element with itself Otherwise let s suppose that is the element before in the same cycle and is the element after in the same cycle Note that this can be the same element When we apply an operation on we swap with so after the operation and So leaves the cycle and forms its separate cycle and becomes the next vertex in the cycle after So using the operation we exclude the vertex from the cycle Suppose we want to sort one permutation Then each cycle having length must be broken down for a cycle of length we need to exclude vertices from it to break it down The vertex we don t touch can be any vertex from the cycle and all other vertices from the cycle will be extracted using one operation directed at them It s easy to see now that if we want to sort a permutation we don t need to apply the same operation twice and the order of operations does not matter Okay then what about sorting two permutations in parallel Let s change the problem a bit instead of calculating the minimum number of operations we will try to maximize the number of integers such that we don t perform operations with them So an integer can be left untouched if it is the only untouched vertex in its cycles in both permutations Can you see where this is going Suppose we want to leave the vertex untouched It means that in its cycles in both permutations every other vertex has to be extracted with an operation So if two cycles from different permutations have a vertex in common we can leave this vertex untouched as long as there are no other vertices left untouched in both of these cycles Let s build a bipartite graph where each vertex in the left part represents a cycle in the first permutation and each vertex in the right part represents a cycle in the second permutation We will treat each integer as an edge between two respective vertices in the bipartite graph If the edge corresponding to is used is left untouched we cannot use any edges incident to the same vertex in left or right part So maximizing the number of untouched numbers is actually the same as finding the maximum matching in this bipartite graph After you find the maximum matching restoring the actual answer is easy Remember that the edges saturated by the matching correspond to the integers we don t touch with our operations the order of operations does not matter and each integer has to be used in an operation only once So the actual answer is the set of all integers without those which correspond to the edges from the matching This solution runs in even with a straightforward implementation of bipartite matching since the bipartite graph has at most vertices and edges 
 fishermen have just returned from a fishing vacation The th fisherman has caught a fish of weight Fishermen are going to show off the fish they caught to each other To do so they firstly choose an order in which they show their fish each fisherman shows his fish exactly once so formally the order of showing fish is a permutation of integers from to Then they show the fish they caught according to the chosen order When a fisherman shows his fish he might either become happy become sad or stay content Suppose a fisherman shows a fish of weight and the maximum weight of a previously shown fish is if that fisherman is the first to show his fish Then if the fisherman becomes happy if the fisherman becomes sad if none of these two conditions is met the fisherman stays content Let s call an order in which the fishermen show their fish if after all fishermen show their fish according to this order each fisherman becomes either happy or sad Calculate the number of orders modulo ,First of all sort the fishermen so it is easier to consider them in ascending order The key observation that allows us to solve the problem is the following there will be an increasing sequence of happy fishermen and all other fishermen will be unhappy Consider the fisherman which belongs to the increasing sequence Let s analyze which fisherman will be next to it in the order It is either a fisherman that will be happy or a fisherman that will be sad In the first case the fish caught by this fisherman must have a size of at least in the second case at most The first case will be considered later For the second case if we know the number of fishermen that were already placed in the order we know that all of them except the th one belong to the sad category that is the fish of every already placed fisherman except for the th one is at least two times smaller than the fish of the th fisherman So if we have already placed fishermen the last happy fisherman was the th one and we want to place a sad fisherman then the number of ways to choose this sad fisherman is exactly where is the number of fishermen such that If we can handle the first case this observation will allow us to solve the problem with dynamic programming Let be the number of ways to choose first fishermen in the order so that the th fisherman is the last happy one The case when the next fisherman is sad can be handled with a transition to the state don t forget to multiply by the number of ways to choose the next sad fisherman as described earlier What about the case when the next fisherman is happy We should iterate on the fisherman such that and transition from to but this part works in To get an solution we have to speed it up with prefix sums or something like that 
You are given four integers and Let s name a tuple as if Find any good tuple ,Let s look at where It can be proven that there always exists such pair and that and Brief proof is following calculate then let and Obviously such will make from and from if And since and since As we can see divides so if we will iterate over all pairs where there will be pairs in total Let s fix value of Then from one side but from the other side since then Anyway all valid form a segment possibly empty segment And we need to find any that divides any from the segment and doesn t exceed Obviously it s optimally to find the minimum possible such and just check inequality We can find such for a fixed using for example built in in a set with all divisors for all valid To maintain this set we can note that simillary So we can move valid segment s ends as two pointers Each pair will be added and erased from the segment exactly once That s why the total complexity of maintaining the set of divisors as well as the total complexity of queries for each will be equal to All pairs and can be precalculated in using the sieve like algorithm 
Let be an array of integers Let s define as a minimal size of a partition of into subsegments such that all elements in each subsegment are equal For example using next partition Now you don t have any exact values of but you know that can be any integer value from uniformly at random All are independent Calculate expected value of or It s guaranteed that the expected value can be represented as rational fraction where so print the value ,As usual with tasks on an expected value let s denote as indicator function if and otherwise Then we can note that Now we can make some transformations Now we d like to make some casework if and aren t consecutive then and are independent that s why if then need further investigation For the simplicity let s transform segment to by increasing Let s denote as the probability that and Let s denote In result The final observation is the following is equal to the probability that and and can be calculated by inclusion exclusion principle where In result and can be calculated in time 
You are given strings Each string has cost Let s define the function of string where is the number of occurrences of in is the length of the string Find the maximal value of function over all strings Note that the string is not necessarily some string from ,This problem is a typical problem for some suffix data structure Four competitors who solved this problem during the contest used suffix automaton and one competitor used suffix tree My own solution used suffix tree so I ll describe solution with tree I think it s simple except of the building of the tree Let s build the new string by concatenation of all strings from input separating them by different separators The number of separators is so the alphabet is also So we should use map int int to store the tree and the complexity is increased by Let s build the suffix tree for the new string Let s match all the separators to the strings from the left of the separator Let s run dfs on the suffix tree that doesn t move over separators and returns the sum of the costs of the strings matched to the separators from the subtree of the current vertex Easy to see that we should simply update the answer by the product of the depth of the current vertex and the sum in the subtree of the current vertex 
For a given set of two dimensional points let s denote its extension as the result of the following algorithm Create another set of two dimensional points which is initially equal to Then while there exist four numbers and such that and add to When it is impossible to find such four integers let be the result of the algorithm Now for the problem itself You are given a set of two dimensional points which is initially empty You have to process two types of queries add some point to or remove some point from it After each query you have to compute the size of ,Let s try to analyze how the size of can be calculated Let s connect points having same coordinates to each other and do the same for points having same coordinates Then we can solve the problem for each component separatedly after the algorithm is run the component will contain the points such that at least one point in the component has coordinate equal to and at least one point in the component maybe same maybe another one has coordinate equal to So the answer for each component is the product of the number of distinct coordinates and the number of distinct coordinates in the component Now we can process insertion queries there are many ways to do it but in my opinion the easiest way to handle them is to create a separate vertex for every coordinate and coordinate and process each point as an edge connecting vertices corresponding to its coordinates edges can be easily added by using DSU with rank heuristics To handle removals we will get rid of them completely Transform the input into a set of events some point exists from query to query Then build a segment tree over queries and break each event into segments with this segment tree Then we can initialize a DSU and run DFS on the vertices of the segment tree to get answers for all queries When we enter some node we add all edges that exist on the corresponding segment into DSU If we are in a leaf node we may compute the for the corresponding query And when we leave a vertex we can rollback all changes we made when we entered it One important moment is that using path compression in DSU here is meaningless since it doesn t work with rollbacks well This solution works in 
You are given a binary string each character of this string is either or Let s denote the cost of string as the number of occurences of in For example if is and is then the cost of is Let s also denote the Fibonacci strings sequence as follows is is if where means the concatenation of two strings Your task is to calculate the sum of costs of all subsequences of the string Since answer may be large calculate it modulo ,If was not really large then we could run the following dynamic programming solution Let be the number of ways to process first characters of so that the suffix of the subsequence of length matches the prefix of with length This is not really different from a usual approach with dynamic programming on KMP constraints in this problem allow us to build KMP automaton naively without the help of any fast prefix function algorithm However the length of is really large Let s consider the traversions we make in dynamic programming Let be the KMP automaton matrix that is let be the new value of prefix function if the previous value was and we added a character Then from the state if the following character is we make traversions to and to This actually leads to rewriting traversions as a matrix Let be the vector such that its th element is equal to Then advancing from to if th character is can be represented as follows where can be filled with the help of KMP automaton for every we add to and also add to The same approach can be used to form matrix that denotes adding character and if we want to add the string we can actually represent its matrix as This matrix multiplication approach will run in but the problem is that it doesn t give us the answer To obtain it we may add an auxiliary state to the dynamic programming add to it each time we traverse to state multiply it by each time we add a character and rewrite it into matrix form Model solution https pastebin com ctSVxmnD
There are fishermen who have just returned from a fishing trip The th fisherman has caught a fish of size The fishermen will choose some order in which they are going to tell the size of the fish they caught the order is just a permutation of size However they are not entirely honest and they may increase the size of the fish they have caught Formally suppose the chosen order of the fishermen is Let be the value which the th fisherman in the order will tell to the other fishermen The values are chosen as follows the first fisherman in the order just honestly tells the actual size of the fish he has caught so every other fisherman wants to tell a value that is than the value told by the previous fisherman and is divisible by the size of the fish that the fisherman has caught So for is the smallest integer that is both than and For example let If the chosen order is then is the smallest integer divisible by and greater than which is is the smallest integer divisible by and greater than which is is the smallest integer divisible by and greater than which is is the smallest integer divisible by and greater than which is is the smallest integer divisible by and greater than which is is the smallest integer divisible by and greater than which is You have to choose the order of fishermen in a way that yields the minimum possible ,Suppose we have fixed some order of fishermen and calculated the values of Then we have the following constraints on all values of are pairwise distinct for every divides Not every possible array meeting these constraints can be achieved with some order of fishermen but we can show that if we choose an array with the among the arrays meeting these two constraints there exists an ordering of fishermen which yields this array The proof is simple suppose the ordering of fishermen is the following one the first fisherman is the one with minimum the second one the one with the second minimum and so on It s obvious that if we generate the values of according to this order they won t be greater than the values in the array we have chosen And if some value is less than the value in the chosen array it means that we haven t chosen the array with the minimum possible sum So we can rephrase the problem as the following one for each choose the value of so that it is divisible by all are distinct and their sum is minimized Using the pigeonhole principle we can show that for every we need to consider only the values of among So we can formulate the problem as an instance of the weighted bipartite matching build a graph with two parts where the left part contains nodes representing the values of the right part represents the values of the form where and there exists an edge between a vertex in the left part representing the number and a vertex in the right part representing the number with cost if and only if for some integer Okay now we need to solve this weighted matching problem but how The number of vertices is and the number of edges is as well so mincost flow will run in or which is too much Instead we can notice that the cost of the edges incident to the same vertex in the right part is the same so we can swap the parts of the graph sort the vertices of the new left part representing the numbers according to their costs and run the classical Kuhn s algorithm in sorted order Kuhn s algorithm in its original implementation will always match a vertex if it is possible so it obtains the minimum total cost for the matching if we do it in sorted order But this is still What should we do Well there are some implementations of Kuhn s algorithm which can run on graphs of size about sometimes even Why can t we use one of these Unfortunately For example greedy initialization of matching won t work So we need to choose optimizations carefully The model solution uses the following optimization of Kuhn s algorithm With this optimization Kuhn s algorithm works in where is the size of the maximum matching is the number of edges and is the number of vertices So this results in a solution with complexity of I think it s possible to show that some other optimizations of Kuhn can also work but the one I described is enough 
You have to handle a very complex water distribution system The system consists of junctions and pipes th pipe connects junctions and The only thing you can do is adjusting the pipes You have to choose integer numbers and use them as pipe settings th pipe will distribute units of water per second from junction to junction if is negative then the pipe will distribute units of water per second from junction to junction It is allowed to set to any integer from to In order for the system to work properly there are some constraints for every th junction has a number associated with it meaning that the difference between incoming and outcoming flow for th junction must be if is not negative then th junction must receive units of water per second if it is negative then th junction must transfer units of water per second to other junctions Can you choose the integers in such a way that all requirements on incoming and outcoming flows are satisfied ,The answer is if and only if the sum of values is not equal to Writing some number on edge does not change the total sum and the goal of the problem is to make in each vertex thus getting in total The algorithm is simple you get an arbitrary spanning tree with dfs or dsu output the difference between sums of values of subtrees can be calculated with dfs for edges in this tree and for the rest of edges Let s take an arbitrary correct answer If is has some cycle in graph of edges with non zero numbers on them then you can remove it For example select any edge on it and subtract the number on it from all the edges of the cycle This doesn t break the correctness of the answer as you change both in and out flows for each vertex by the same value Now that edge has This way any answer can be transformed to tree And for any edge on tree we want to tranfer excess water units from the larger subtree to the smaller Overall complexity 
You are given a string consisting of lowercase Latin letters Some indices in this string are marked as You want to find a string such that the value of is maximum possible where is the number of occurences of in such that these occurences end in non forbidden indices So for example if is is and index is forbidden then because there are three occurences of in starting in indices and but one of them starting in index ends in a forbidden index Calculate the maximum possible value of you can get ,This problem can be solved with different suffix structures Model solution uses suffix array First of all let s reverse so for we will count only occurences that start in non forbidden indices Then if there is at least one non forbidden index there are two cases then the best option to choose is to use a suffix which begins in the leftmost after reversing non forbidden index then is the longest common prefix of some two suffixes of Let s build a suffix array then calculate the LCP array Then recall the fact that a LCP of two suffixes is the minimum on the segment of LCP array between these two suffixes so we can use a common stack algorithm that will for each LCP find the segment of suffixes such that this LCP is a prefix of these suffixes to do this for each element of LCP array we find the largest segment such that this element is minimal on that segment and then we can use prefix sums to find the number of non forbidden suffixes such that chosen LCP is a prefix of this suffix and so calculate easily for each LCP 
You are given an undirected graph with vertices numbered from to Initially there are no edges You are asked to perform some queries on the graph Let be the answer to the latest query of the second type it is set to before the first such query Then the queries are the following add an undirected edge between the vertices and if it doesn t exist yet otherwise remove it check if there exists a path between the vertices and which goes only through currently existing edges and set to if so and otherwise Good luck ,The problem directly tells you do solve some kind of Dynamic Connectivity Problem You could use the online approach with Link Cut Tree if you d had its implementation beforehand There is also a nice modification to the solution of the offline version of DCP check out the comment I d tell the solution which is probably the easiest to come up with and to code Let s recall the sqrt optimization method of solving DCP Process blocks of queries of size one at a time Split the edges into two groups The edges which were added on queries before the block and aren t touched by the queries in the block the edges modified by the queries in the block The first type of edges can be added to the graph before the block processing starts You can use DSU for that The second type contains no more than edges Maintain the list of those of them which exist in the graph On each ask query add them to graph then delete them This can be done explicitly by doing DFS only over these edges and the vertices which correspond to the connected components on the edges of the first type Implicitly doing DSU merges for these edges and rolling them back is a viable option as well costs extra log factor but has lower constant It s easy to see that it isn t hard to modify this solution to our problem Let s define the edges of the first type more generally the edges which were added on queries before the block and touched by the queries in the block So neither from the add query nor could be of the first type Now there might be edges of the second type in the list However that doesn t make the complexity any worse Process block the same way rebuild the DSU with the edges of the first type every queries The overall complexity can be if you use DFS or if you use DSU notice how the rebuild is and the query is and set the size of the block so that these parts are about the same 
If an integer is divisible by another integer then is called the divisor of For example has positive divisors They are and Let s define a function number of integers between and inclusive which has exactly four positive divisors Between and only the integers and has exactly four positive divisors So You are given an integer You have to calculate ,Easy to see that only the numbers of the form and for different prime have exactly four positive divisors We can easily count the numbers of the form in where is the number from the problem statement Now let and be the number of primes from to Let s iterate over all the values Easy to see that So for fixed we should increase the answer by the value So the task is ot to find the number of primes not exceeding for all Denote the th prime number Denote the number of such that and all prime divisors of are at least note that 1 is counted in all since the set of its prime divisors is empty satisfy a simple recurrence since 2 hence Let be the smallest prime greater than Then by definition the first summand accounts for all the primes not less than If we evaluate the recurrence straightforwardly all the reachable states will be of the form We can also note that if and are both greater than then Thus for each it makes sense to keep only values of Instead of evaluating all DP states straightforwardly we perform a two step process Choose Run recursive evaluation of If we want to compute a state with memorize the query count the numbers not exceeding with all prime divisors at least Answer all the queries off line compute the sieve for numbers up to then sort all numbers by the smallest prime divisor Now all queries can be answered using RSQ structure Store all the answers globally Run recurisive evaluation of yet again If we want to compute a state with then we must have preprocessed a query for this state so take it from the global set of answers The performance of this approach relies heavily on the number of queries we have to preprocess Statement Proof Each state we have to preprocess is obtained by following a transition from some greater state It follows that doesn t exceed the total number of states for The preprocessing of queries can be done in and it is the heaviest part of the computation Choosing optimal we obtain the complexity 
There are frogs sitting on the coordinate axis For each frog two values are known the position and the initial length of the tongue of the th frog it is guaranteed that all positions are different mosquitoes one by one are landing to the coordinate axis For each mosquito two values are known the coordinate of the position where the th mosquito lands and the size of the th mosquito Frogs and mosquitoes are represented as points on the coordinate axis The frog can eat mosquito if mosquito is in the same position with the frog or to the right and the distance between them is not greater than the length of the tongue of the frog If at some moment several frogs can eat a mosquito the leftmost frog will eat it with minimal After eating a mosquito the length of the tongue of a frog increases with the value of the size of eaten mosquito It s possible that after it the frog will be able to eat some other mosquitoes the frog should eat them in this case For each frog print two values the number of eaten mosquitoes and the length of the tongue after landing all mosquitoes and after eating all possible mosquitoes by frogs Each mosquito is landing to the coordinate axis only after frogs eat all possible mosquitoes landed before Mosquitoes are given in order of their landing to the coordinate axis ,Let s maintain the set of not eaten mosquitoes for example with set in C or with TreeSet in Java and process mosquitoes in order of their landing Also we will maintain the set of segments ai bi where ai is the position of the i th frog and bi ai li where li is the current length of the tongue of the i th frog Let the current mosquito landed in the position x Let s choose segment ai bi with minimal ai such that bi x If the value ai x we found the frog that will eat mosquito Otherwise the current mosquito will not be eaten and we should add it to our set If the i th frog will eat mosquito then it s tongue length will be increased by the size of mosquito and we should update segment ai bi After that we should choose the nearest mosquito to the right the from frog and if it s possible eat that mosquito by the i th frog this can be done with lower bound in C Possibly we should eat several mosquitoes so we should repeat this process several times Segments ai bi we can store in segment tree by position ai and value bi Now to find segment we need we can do binary search by the value of ai and check the maximum bi value on the prefix to be at least x This will work in O nlog2n time We can improve this solution Let s go down in segment tree in the following manner if the maximum value bi in the left subtree of segment tree is at least x then we will go to the left otherwise we will go to the right Complexity O n m log n m 
Monocarp plays a computer game called Goblins and Gnomes In this game he manages a large underground city of gnomes and defends it from hordes of goblins The city consists of halls and one directional tunnels connecting them The structure of tunnels has the following property if a goblin leaves any hall he cannot return to that hall The city will be attacked by waves of goblins during the th wave goblins attack the city Monocarp s goal is to pass all waves The th wave goes as follows firstly goblins appear in some halls of the city and pillage them Then goblins start moving along the tunnels pillaging all the halls in their path Goblins are very greedy and cunning so they choose their paths so that no two goblins pass through the same hall Among all possible attack plans they choose a plan which allows them to After goblins are done pillaging they leave the city If all halls are pillaged during the wave Monocarp loses the game Otherwise the city is restored If some hall is pillaged during a wave goblins are still interested in pillaging it during the next waves Before each wave Monocarp can spend some time preparing to it Monocarp doesn t have any strict time limits on his preparations he decides when to call each wave by himself but the longer he prepares for a wave the fewer points he gets for passing it If Monocarp prepares for the th wave for minutes then he gets points for passing it obviously if he doesn t lose in the process While preparing for a wave Monocarp can block tunnels He can spend one minute to If Monocarp blocks a tunnel while preparing for a wave it stays blocked during the next waves as well Help Monocarp to defend against all waves of goblins and get the maximum possible amount of points ,First of all let s try to solve the following problem given a DAG cover its vertices with the minimum number of vertex disjoint paths Solving this problem allows us to calculate the number of goblins that can pillage all of the halls when the tunnel network is fixed This problem is a fairly classical one since the number of vertices in each path is greater than the number of arcs in it exactly by we should take the maximum possible number of arcs into our paths So we can reduce this problem to bipartite maximum matching build a bipartite graph where each part consists of vertices and for every directed arc in the original graph connect the vertex of the left part to the vertex in the right part of the bipartite graph The maximum matching in this graph allows us to pick the maximum number of arcs into the paths of the original problem the matching ensures that each vertex has at most one chosen ingoing arc and at most one chosen outgoing arc so the paths are vertex disjoint Okay now we at least can check if the goblin wave can pillage all of the halls Let s say that the minimum number of goblins required to pillage the original city is Obviously in order to pass the th wave and waves after it we have to increase this number In one minute Monocarp can block all of the tunnels leading to some hall or out of some hall and in terms of our reduction to the bipartite matching problem it means that we remove all edges connected to some vertex of the bipartite graph Obviously in one minute we can increase by at most since is equal to the difference between and the maximum matching size It turns out that it s always possible to choose a vertex that belongs to all maximum matchings in the bipartite graph note that it doesn t work in non bipartite graphs but in our problem it doesn t matter For the proof of this fact you can check the last paragraph of the editorial So each minute Monocarp prepares for a wave he increases the maximum number of goblins he can repel by Now the solution splits into two much easier parts The first part is finding a sequence in which Monocarp blocks the tunnels so that each his action reduces the size of the maximum matching by Since the constraints are small even a naive approach in always iterate on the vertex we try to remove from the graph and check that removing it is possible by running Kuhn s algorithm is fast enough The second part is to choose when Monocarp calls waves of goblins and when he prepares for them this can be easily done with dynamic programming let be the maximum Monocarp s score if he has already passed waves and the current size of the maximum matching is The most naive implementation of this dynamic programming runs in so the whole solution works in We can improve it to though it is not needed under these constraints Instead of finding the vertices to remove from the bipartite graph one by one let s find all of them at once in Recall that the size of maximum matching in a bipartite graph is equal to the size of its minimum vertex cover and the minimum vertex cover can be reconstructed after finding the maximum matching If we remove a vertex from the minimum vertex cover the size of the minimum vertex cover of the remaining graph is reduced by so the size of the maximum matching is reduced by as well It means that we can always choose to remove a vertex from the minimum vertex cover we found By the way it also proves that it s always possible to remove a vertex from a bipartite graph so the size of the maximum matching decreases by obviously if it s not already 
An online contest will soon be held on ForceCoders a large competitive programming platform The authors have prepared problems and since the platform is very popular coder from all over the world is going to solve them For each problem the authors estimated the number of people who would solve it for the th problem the number of accepted solutions will be between and inclusive The creator of ForceCoders uses different criteria to determine if the contest is good or bad One of these criteria is the number of inversions in the problem order An inversion is a pair of problems such that is located earlier in the contest but the number of accepted solutions for is greater Obviously both the creator of ForceCoders and the authors of the contest want the contest to be good Now they want to calculate the probability that there will be inversions in the problem order assuming that for each problem any number of accepted solutions for it between and is equally probable and all these numbers are independent ,The naive solution is dynamic programming let be the probability that the first problems don t have any inversions and the th one got accepted solutions Let s somehow speed it up For convenience I will modify the variable denoting the maximum number of accepted solutions for each problem and I will also reverse the problem order so that we don t want the number of solutions to decrease from problem to problem We know that if and otherwise Let s divide the whole segment between and into segments with the values of and and analyse the behavior of values on each such segment Let If we consider the behavior of on some segment we got we can prove by induction that it is a polynomial of degree not exceeding All that is left is to carefully calculate and maintain these polynomials on segments The main thing we will use to calculate the polynomials is interpolation To transition from to we will consider each segment separately calculate the first several values of on each segment we need to calculate the sum fast if is a polynomial this can also be done with interpolation and then interpolate it on the whole segment This is actually slow we have to interpolate at least polynomials and not easy to write Let s consider a better solution We will use combinatoric approach instead of calculating probabilities we will count all the non descending sequences such that and divide it by the number of all sequences without the non descending condition that is just Let s again divide into segments using the points and enumerate these segments from left to right If there are two neighboring values and they either belong to the same segment or the segment belongs to is to the right of the segment belongs to We could try to write the following dynamic programming solution is the number of non descending prefixes of the sequence such that there are elements in the prefix and the last one belongs to segment It s easy to model transitions from to where but we don t know how to model the transition to Let s get rid of them altogether We will introduce an additional constraint in our dynamic programming is the number of prefixes of the sequence of length The transitions in this dynamic programming are different we iterate on the number of elements belonging to the next segment and transition into if possible Calculating the number of ways to take elements from an interval in sorted order can be reduced to calculating the number of ways to compose as the sum of non negative summands order matters We should be able to calculate binomial coefficients with fairly large and not so large but that s not really hard if we use the formula 
You have an undirected graph consisting of vertices with weighted edges A simple cycle is a cycle of the graph without repeated vertices Let the of the cycle be the XOR of weights of edges it consists of Let s say the graph is if all its cycles have weight A graph is bad if it s not good Initially the graph is empty Then queries follow Each query has the next type add edge between vertices and of weight if it doesn t make the graph bad For each query print was the edge added or not ,Firstly let s prove that a good graph has one important property any two of its simple cycles intersect by at most one vertex i e there is no edge that belongs to more than one simple cycle cactus definition yeah Let s prove it by showing that if two simple cycles of weight k 0 intersects by edges then they will induce a simple cycle of weight neq k There are two cases if cycles intersect by a single path then we can create a new cycle by merging parts of cycles excluding the intersecting path it will be simple and will have weight k oplus k 0 neq k if cycles intersect by more than one path we can do the next transformation suppose the common paths are u 1 v 1 u 2 v 2 dots and they are ordered in the way how they lie on the first cycle Let s create a third cycle using two paths from v 1 to u 2 from the first cycle and from the second cycle It s easy to see that the third cycle is simple and more over it has only one common path with the second cycle So it s either the third cycle has weight not equal to k or the case 1 Okay let s analyze the edges we try to add Let s divide all edges in two types edges and all other edges we will name them edges Let s name an edge as a edge if it connects two different components at a moment when we are trying to add it in the graph It s obvious that we will add all tree edges in the graph since they can t make it bad since they don t induce new cycles But there is a more interesting observation when we try to add a cycle edge u v it should induce an only one simple cycle where all other edges are tree edges and these tree edges can t be used in any other cycle It induces at least one all tree edge cycle since u and v are already connected It can t induce more than one all tree edge cycle since it contradicts with definition and if it induces a cycle with some other cycle edge then we can replace that cycle edge with its own tree edge path our cycle will become all tree edge cycle but it will use already used tree edges In other words it s enough to consider only one all tree edge cycle induced by any cycle edge The final trick is to calculate the answer in two steps at the first step we will find only tree edges using DSU that will form a spanning forest in our graph The second step is for each cycle edge u v to calculate the operatorname XOR X on a path between u and v in our spanning forest check that X oplus text edge weight 1 and check that none of edges on the path from u to v are used in other cycle Calculating X is easy if we precalculate for each vertex v the operatorname XOR on path from v to root mathit xr v then X mathit xr u oplus mathit xr v Checking that none of the edges are used on the path from u to v is a bit tricky if we mark an edge by adding 1 to it then we should be able to take a sum on path and add on path There are structures that are capable of it like HLD and other but let s look closely Note that we mark each tree edge at most once so we can manually add 1 to each edge and only asking sum on path should be fast In other words we need a data structure DS that can add value at edge and take the sum on path and such DS is a Fenwick tree BIT built on Euler tour of tree it can add value at edge and ask a sum on path from v to root So we need to find LCA as well since sum of path u v is equal to sum u sum v 2 cdot sum LCA u v As a result complexity is O n m log n with quite a low constant from LCA and BIT 
Polycarp owns a shop in the capital of Berland Recently the criminal activity in the capital increased so Polycarp is thinking about establishing some better security in the storehouse of his shop The storehouse can be represented as a matrix with rows and columns Each element of the matrix is either an empty space or a wall Polycarp wants to hire some guards possibly zero to watch for the storehouse Each guard will be in some cell of matrix and will protect every cell to the right of his own cell and every cell to the bottom of his own cell until the nearest wall More formally if the guard is standing in the cell then he protects cell if all these conditions are met is an empty cell either and or and there are no walls between cells and Guards can be placed only in empty cells and can protect only empty cells The of placing the guards is some set of cells where guards will be placed of course two plans are different if there exists at least one cell that is included in the first plan but not included in the second plan or vice versa Polycarp calls a plan if there is empty cell that is not protected Polycarp wants to know the number of suitable plans Since it can be very large you have to output it modulo ,This problem can be solved using dynamic programming with broken profile First of all we have to make the number of rows not larger than if it is larger then we can just rotate the given matrix Let s fill the matrix from left to right and in each column from top to bottom Let be the number of ways to achieve the following situation we now want to fill cell with index denotes the rows which are already protected in this column so there is a wall in this row or there is a guard to the left is a flag that denotes if current cell is protected by some guard above and is a flag that denotes if there was a cell that was not protected When advancing from one column to another we have to change the mask so we update the rows that are currently protected The rows such that in the previous column there was a wall in this row become un protected and the rows such that there is a wall in current column in this row become protected And of course becomes zero When we place a guard we set to one and make the corresponding row protected And when we are at the wall we have to set to zero so the guard from above doesn t protect next cell The answer is the sum of all values 
You are given a tree consisting of vertices A number is written on each vertex the number written on vertex is Let s denote the function as the difference between maximum and minimum value of on a simple path connecting vertices and Your task is to calculate ,Let s calculate the answer as the difference between sum of maxima and sum of minima over all paths These sums can be found by the following approach Consider the sum of maxima Let s sort all vertices in ascending order of values of if two vertices have equal values their order doesn t matter This order has an important property that we can use for every path the maximum on this path is written on the vertex that has the greatest position in sorted order This allows us to do the following Let s denote as a tree rooted at vertex that is formed by the set of such vertices that are directly connected to or some other vertex from the set and have Consider the vertices that are connected to in this tree Let s denote them as the order doesn t matter and denote by the size of the subtree of in the tree Let s try to calculate the number of paths going through in this tree paths that have as its endpoint paths connecting a vertex from subtree of to a vertex from subtree of So vertex adds the sum of these values multiplied by to the sum of maxima To calculate these sums we will use the following algorithm Initialize a DSU disjoint set union making a set for each vertex Process the vertices in sorted order When we process some vertex find all its already processed neighbours they will be in For every neighbour denote the size of its set in DSU as Then calculate the number of paths going through using aforementioned formulas to do it in linear time use partial sums Add this number multiplied by to the sum of maxima and merge with in DSU To calculate the sum of minima you can do the same while processing vertices in reversed order Time complexity of this solution is 
You are given segments on the coordinate axis The th segment is Let s denote the set of all integer points belonging to the th segment as Let be the union of two sets and be the intersection of two sets and and be the symmetric difference of and a set which contains all elements of and all elements of except for the ones that belong to both sets Let be an array where each element is either or Over all ways to choose this array calculate the sum of the following values In this expression denotes the size of the set ,We will use the Contribution to the Sum technique to solve this problem for every integer from to let s calculate the number of ways to choose the operators so it belongs to the result and add all of the results For a fixed integer the number of ways to choose the operators so that belongs to the result can be done as follows let be the number of ways to choose the first operators so that after applying them the resulting set contains if and does not contain if The transitions from to depend on whether the number belongs to the segment Obviously this is too slow if we compute the dynamic programming from scratch for every integer Instead we can notice that the transitions from to are linear combinations both and are linear combinations of and with coefficients depending on whether the element belongs to the set or not So transitioning from to can be written in terms of multiplying by a matrix Let s build a segment tree where each vertex stores a transition matrix and operations are calculate the product of matrices on a segment and replace a matrix at some index We can build a sequence of these transition matrices for and store them in the segment tree for this sequence of transition matrices will change only in positions such that either belongs to and does not belong to it or vice versa So we can go from to by replacing these transition matrices in the segment tree For the only changes from are in positions such that either belongs to and does not belong to it or vice versa and we can replace the matrices in these positions as well In total there will be only such replacements so we solve the problem in where is the constraint on the numbers belonging to the sets 
A permutation of size is an array of size such that each integer from to occurs exactly once in this array An inversion in a permutation is a pair of indices such that and For example a permutation contains inversions You are given a permutation of size However the numbers on some positions are replaced by Let the valid permutation be such a replacement of in this sequence back to numbers from to in such a way that the resulting sequence is a permutation of size The given sequence was turned into a valid permutation randomly with the equal probability of getting each valid permutation Calculate the expected total number of inversions in the resulting valid permutation It can be shown that it is in the form of where and are non negative integers and Report the value of ,Let s break the problem into four general cases Case 1 Inversions between two unknown numbers Each pair of numbers can either be or inversion or not and the number of permutations for both cases is the same Thus the expected value of that is Case 2 and 3 Inversions between the known and unknown number Let s check the case with left number being unknown and right being known The opposite will be done similarly For each known number calculate the number of unknowns to the left of it and the total number of unknowns greater than it Then you ll need to put a greater number out of all possible to make an inversion Add to the answer Case 4 Inversions between two known numbers Just calculate that number ignoring all and add it to answer Overall complexity for the lase case all others are done in 
You are given a string of length consisting of lowercase English letters For two given strings and say is the set of distinct characters of and is the set of distinct characters of The strings and are if their lengths are equal and there is a one to one mapping bijection between and for which Formally for any index for any character there is exactly one character that for any character there is exactly one character that For example the strings and are isomorphic Also the strings and are isomorphic The following pairs of strings are not isomorphic and and You have to handle queries characterized by three integers For each query check if two substrings and are isomorphic ,Yes authors also implemented hashes Note that if substrings and are isomophic then position of first encounter of some character in must be position of first encounter of some character in More over if we sort all positions for all distict characters in and sort all positions for then must be equal for any This observation gives us fact that So to check isomorphism of and we need check for each that positions of all encounters of character equal to posistions of all encounters of character To do that we can generate for each character boolean array with checked positions of its encounter and calculate prefix hashes on this arrays Also we need precalculate order of first encounters for each suffix of string To do it fast note that in transition from to only can change its relative order Result complexity is with quite big constant from hashing 
You are given a simple weighted connected undirected graph consisting of vertices and edges A path in the graph of length is a sequence of vertices such that for each the edge is present in the graph A path from some vertex also has vertex Note that edges and vertices are allowed to be included in the path multiple times The weight of the path is the total weight of edges in it For each from to consider a path from vertex of length of the maximum weight What is the sum of weights of these paths Answer can be quite large so print it modulo ,Let s observe what does the maximum weight of some fixed length path look like Among the edges on that path the last one has the maximum weight If it wasn t then the better total weight could be achieved by choosing a bigger weight edge earlier and going back and forth on it for the same number of steps It actually helps us arrive to a conclusion that all optimal paths look like that some simple path to an edge and then back and forth movement on it Any simple path in the graph has its length at most Let s separate the queries into two parts will be handled in a straightforward manner Let be the maximum weight of a path that ends in and has exactly edges in it That s pretty easy to calculate in You can also think of this as some kind of Ford Bellman algorithm let on the th step be the maximum weight of the path to of length Iterate over all edges and try to update and for each edge that s what I do in my solution if you refer to it Now for There was a very common assumption that after a bit more steps some edge will become the most optimal and will stay the most optimal until the end of time However that a bit cut off is in fact too high to rely on it must be somewhere around So the best path of length exactly ending in each vertex is Let the maximum weight adjacent edge to vertex be So the path of length will have weight Treat it like a line with coefficients and How do determine which line is the best for some Sure experienced participants will immediately answer convex hull Build a lower envelope of the convex hull of these lines If was a little smaller than we could query with binary search for each the same how convex hull is usually used We have to examine the hull further Each line in it becomes the best in some point then stays the best for some interval and then never appears the best again What are these line changing points Well it s just the intersection point of the adjacent lines in the hull So having these points and the parameters of the line we can calculate its contribution to the answer with a sum of arithmetic progression formula There were just lines in the hull so you can build the hull in any complexity I think I saw up to performances in the participants codes There is a cool solution that involves some kind of Divide Conquer on these lines I personally thought of it in a sense of traversing a Li Chao tree without actually building it If anyone wants to explain this solution feel free to do it in comments Overall complexity 
There is an infinite pond that can be represented with a number line There are rocks in the pond numbered from to The th rock is located at an integer coordinate The coordinates of the rocks are pairwise distinct The rocks are numbered in the increasing order of the coordinate so A robot frog sits on the rock number The frog is programmable It has a base jumping distance parameter There also is a setting for the jumping distance range If the jumping distance range is set to some integer then the frog can jump from some rock to any rock at a distance from to inclusive in any direction The distance between two rocks is an absolute difference between their coordinates You are assigned a task to implement a feature for the frog Given two integers and determine if the frog can reach a rock number from a rock number performing a sequence of jumps with the jumping distance range set to The sequence can be arbitrarily long or empty You will be given testcases for that feature the th testcase consists of two integers and Print if the th rock is reachable and otherwise You can output and in any case for example strings and will be recognized as a positive answer ,Notice that increasing only increases the range of the jump distances in both directions So every rock that was reachable with some will be reachable with as well Thus let s try to find the smallest possible value of to reach each rock Let s imagine this problem as a graph one and consider the following algorithm For every pair of rocks make an edge of weight equal to the smallest required to jump from one to another For some rocks and that is How to check the reachability with these edges Well if the jump range value is then there should exist of path by edges of weight no more than So we can start with an empty graph first add the edges of the smallest weight then the second smallest and so on The first time a pair of vertices becomes reachable from each other is the minimum such weight An experienced reader can notice the resemblance with the Kruskal algorithm for finding the minimum spanning tree After the spanning tree is constructed the minimum is the maximum value on a path between the vertices The issue is that Kruskal requires to construct an MST for a complete graph Prim can make it which is still too much Thus the solution is to resort to Boruvka On each iteration of Boruvka we have to find the smallest weight edge from each component to some other one We can solve it the following way Maintain a sorted set of rocks coordinates The smallest weight edges are the ones that are the closest to distance from each rock So we could query a lower bound of and on each rock to find them Don t forget to look at the both sides of the lower bound result However the issue is that we can bump into the rocks from the same component Thus let s process components one by one When processing a component first remove all its vertices from the set Then query the edges for each vertex Then add the vertices back This way only the edges to other components will be considered That makes it an construction with one log from the number of Boruvka iterations and another from finding the edges That should pass if coded carefully enough and that is basically the intended solution Still there exists a construction That will require a algorithm for finding the edges So there are four possible edges for each rock the closest to from the left from the right and the same for Let s consider only the first case the rest will be similar The coordinates are sorted beforehand and we are processing the rocks from left to right We can maintain a pointer to the latest encountered rock to the left of The issue with it being from the same component is still there Let s go around it by also storing the second latest encountered rock such that it s from the different component from the actual latest one This can be updated in the same manner one calculates the second maximum of the array Now you just have to do that for all four cases This two pointers approach makes it for each iteration thus making the construction Since the queries ask for a path from some fixed vertex to a certain vertex it s the same as calculating the maximum edge on a path from the root of the tree to each vertex Can be done with a simple dfs The only thing left is to check if the minimum possible is less than or equal to the one provided in the query Overall complexity or 
You are given a string consisting of lowercase Latin letters Let s denote substring of as a string Obviously and there are exactly such substrings Let s call some string an of a string iff the following conditions are met is an odd number is simultaneously a prefix and a suffix of For evey substring of you have to calculate the maximum length of its odd proper suprefix ,Let s look at suprefix of fixed substring we can t find its maximal length via binary search because this function isn t monotone in general case But by fixing not the left border but the center of the prefix we also fix the center of the corresponding suffix center of a prefix in position is tied with the center of the suffix in position and more important function becomes monotone So solution is next iterate over all valid centers of prefix and try to binary search maximal length of such substring that its center is in position and it s equal to the substing with center in then can be updated with value And don t forget to update each with value Easy way to check substrings for equality is to use hashes Harder way is to use string suffix structures like bundle of Suffix Array LCP Sparse Table or Suffix Tree LCA Note for SuffArray users don t forget about changing sort to stable sort merge sort and breaking if all suffixes are different This optimizations can save you from writing radix or bucket sort 
Monocarp has a dictionary of words consisting of first letters of the Latin alphabet The words are numbered from to In every pair of adjacent characters in each word the characters are different For every word Monocarp also has an integer denoting how often he uses this word Monocarp wants to design a keyboard that would allow him to type some of the words easily A keyboard can be denoted as a sequence of first letters of the Latin alphabet where each letter from to appears exactly once A word can be typed with the keyboard easily if for every pair of adjacent characters in the word these characters are adjacent in the keyboard as well The of the keyboard is the sum of over all words that can be typed easily with it Help Monocarp to design a keyboard with the maximum possible optimality ,For each word let s consider a graph on vertices where the th and the th vertices are connected by an edge iff the th character of the alphabet is adjacent to the th character of the alphabet in this string Obviously this graph is connected except for the isolated vertices If there is a vertex of degree or more in this graph or if there is a cycle in this graph it is impossible to design a keyboard to type the word easily in the first case the letter represented by that vertex must have at least three neighbors on the keyboard but can have only at most two in the second case the keyboard must be cyclic and it is not So the word can be typed easily only if the graph representing it consists of one path and several isolated vertices Let s write the letters along the path we constructed for the word in a single string For example for the word we get edges and in the graph so the letters along the path are either or and obviously one can be obtained from the other by reversing the string Let and be the two strings we obtain from the word using this method Now we claim that the word can be typed easily if and only if one of these two strings and is a substring of the keyboard this would mean that every pair of letters that should be on adjacent positions are actually on adjacent positions Okay now we construct and for each word and our goal is to find the permutation of the first characters of Latin alphabet such that the sum of over all words having either or as a substring is the maximum possible There are two key observations that allow us to solve this problem and cannot be the substrings of the same keyboard the proof is simple if is a substring its first character must be before its second character and if is a substring its second to last character which is the second character of must be before its last character which is the first character of neither nor can appear in the keyboard twice it s obvious since the keyboard is a permutation So we can reformulate the problem as follows let be the cost of the string and the cost of the string as well find the permutation of the first characters of the Latin alphabet so that its cost which is the sum of costs of its substrings is the maximum possible To solve this problem we can store the strings in an Aho Corasick automaton and for every state of the automaton precalculate the total cost of all string ending in this state that is the cost of this state and all states reachable from it via the suffix links Then run a dynamic programming of the form the maximum possible cost of a partial keyboard if we used a of characters and the Aho Corasick automaton is currently in the state This dynamic programming runs in where is the size of the alphabet and is the size of the automaton up to 
There are lanterns in a row The lantern is placed in position and has power equal to Each lantern can be directed to illuminate either some lanterns to the left or some lanterns to the right If the th lantern is turned to the left it illuminates all such lanterns that Similarly if it is turned to the right it illuminates all such lanterns that Your goal is to choose a direction for each lantern so each lantern is illuminated by at least one other lantern or report that it is impossible ,The main idea of the solution is to calculate the following dynamic programming is the maximum prefix we can fully cover with first lanterns Let s look at how can we solve it in with this kind of dynamic programming First of all let s write it forward Which transitions from do we have iterate on the lantern facing left that will cover the lantern Let this lantern be It should cover all lanterns in so all lanterns from can be turned to the right and we need a max query to determine the new covered prefix if lantern is already covered we can just extend the prefix by turning the th lantern to the right Note that turning it to the right when it is not covered yet will be modeled by the first transition It is obviously how can we optimize it Let s write this dynamic programming backward The second transition is changed to backward dp easily what about the first one Suppose we want to turn some lantern to the left Let s iterate on the prefix that we will connect to it for this prefix should be at least and we update with the maximum of since it is covered by lantern and the result of max query on In fact we need only one such prefix the one with the minimum among those which have So we build a minimum segment tree where each pair is interpreted as the value of in position and with min query on the suffix from we find this optimal prefix from which we should update and to update we can use any DS that allows max queries on segment in my solution it s another segment tree 
Lena is a programmer She got a task to solve at work There is an empty set of pairs of integers and queries to process Each query is one of three types Add a pair to the set Remove a pair added in the query number All queries are numbered with integers from to For a given integer find the maximal value over all pairs from the set Help Lena to process the queries ,Let s interpret the problem geometrically the pairs from the set are the lines and the problem to find to topmost intersection of the vertical line with the lines from the set Let s split the queries to blocks Consider the lines added before the current block and that will not deleted in the current block Let s build the lower envelope by that lines Now to calculate the answer to the query we should get maximum over the lines from the envelope and the lines from the block before the current query that is not deleted yet There are no more than lines from the block so we can iterate over them Let s find the answers from the envelope for all queries of the third type from the block at once we should sort them and iterate over envelope using two pointers technique 
You are given a simple connected undirected graph consisting of vertices and edges The vertices are numbered from to A vertex cover of a graph is a set of vertices such that each edge has at least one of its endpoints in the set Let s call a vertex cover such a vertex cover that edge in it has both endpoints in the set Find a vertex cover of a graph or report that there is none If there are multiple answers then print any of them ,Let s think about why we can t always make a perfect vertex cover such a vertex cover that each edge has exactly one endpoint in it Or why the answer can not exist at all Consider a bamboo It s always possible to find a perfect vertex cover Just choose every other vertex in it and account for parity Make a bamboo into a loop Now you can see that an even length loop has a perfect vertex cover An odd length doesn t That tells us that each odd length loop in a graph will have a bad edge on it Odd length loops should instantly make you think about bipartite colorings So we can see that a bipartite graph always has a perfect vertex cover Just choose one of the parts into a cover and each edge will have exactly one endpoint in it At the same time a non bipartite graph never has a perfect cover So our general goal is to remove basically mark as bad at most one edge in such a way that the remaining graph is bipartite Consider a dfs tree of the graph colored bipartitely Every edge in the tree is good has endpoints in different parts Every edge outside the tree can be either good or bad What happens to the tree if we remove an edge If we remove an edge outside the dfs tree then nothing happens to it So if there is no more than one bad edge outside the tree then we found the answer That was the easy part Now what happens if we remove an edge from the tree The back edges from the subtree of the edge can force the subtree to either remain colored the same or flip all its colors We don t really care if it remains the same because we already took care of it in the first part So let s pretend it always flips the colors Thus all edges that go from the subtree upwards above the removed edge have only one of their endpoints colors changed Good edges turn bad bad edges turn good All other edges don t change So you should choose such an edge to remove that all bad edges in the graph go from its subtree upwards above that edge and no good edges go from its subtree upwards above that edge That can be calculated with a dfs Since all non tree edges in the dfs tree are back edges you can simply increment a counter on the bottom vertex decrement the counter on the top vertex and collect sums from the bottom The sum in the vertex will tell you the number of edges that start below or in the vertex and end above the vertex Do this for both kinds of edge and check the conditions for all vertices Finally choose such a part to be a vertex cover that the removed edge has both ends in it if you choose the other part that edge won t be covered at all The solution is linear but the problem still requires a massive time and memory limit only because of recursion in the dfs Overall complexity per testcase 
Ivan is developing his own computer game Now he tries to create some levels for his game But firstly for each level he needs to draw a graph representing the structure of the level Ivan decided that there should be exactly vertices in the graph representing level and the edges have to be bidirectional When constructing the graph Ivan is interested in special edges called An edge between two vertices and is called a if this edge belongs to every path between and and these vertices will belong to different connected components if we delete this edge For each level Ivan wants to construct a graph where at least half of the edges are He also wants to maximize the number of edges in each constructed graph So the task Ivan gave you is given numbers for each tell the maximum number of edges in a graph with vertices if at least half of the edges are ,The best way to build a graph is to make a edge connected component with vertices and connect each of the remaining vertices to it with a single edge Then we will have bridges outside the component and edges in the component So the answer for some fixed and is let s denote is at Now since is increasing and is decreasing there exists some such that if then and if then Then is strictly increasing on the segment and strictly decreasing on the segment and this proves that we can use ternary search to find its maximum 
Vova plays a computer game known as Mages and Monsters Vova s character is a mage Though as he has just started his character knows no spells Vova s character can learn new spells during the game Every spell is characterized by two values and damage per second and mana cost per second respectively Vova doesn t have to use a spell for an integer amount of seconds More formally if he uses a spell with damage and mana cost for seconds then he will deal damage and spend mana no rounding If there is no mana left mana amount is set in the start of the game and it remains the same at the beginning of every fight then character won t be able to use any spells It is prohibited to use multiple spells simultaneously Also Vova can fight monsters Every monster is characterized by two values and monster kills Vova s character in seconds and has health points Mana refills after every fight or Vova s character revives with full mana reserve so previous fights have no influence on further ones Vova s character kills a monster if he deals damage to it in no more than seconds using his spells it is allowed to use more than one spell in a fight and spending no more mana than he had at the beginning of the fight You have to write a program which can answer two types of queries Vova s character learns new spell which deals damage per second and costs mana per second Vova fights the monster which kills his character in seconds and has health points For every query of second type you have to determine if Vova is able to win the fight with corresponding monster ,Let s represent spells as points on cartesian plane If we consider three spells and such that and is above on the cartesian plane or belongs to it then we don t need to use spell because we can replace it with a linear combination of spells and without any additional mana cost We can maintain the lower boundary of the convex hull of all points from type queries and the point Then to process type query we have to find the intersection of aforementioned lower boundary and the line our average damage in this fight has to be at least this value If there is no intersection then the answer is because even with infinite mana Vova s character can t deal that much damage before dying If there is an intersection we have to check that it is not higher than the line to ensure that we have enough mana to kill the monster in given time Model solution uses only integral calculations but it seems that precision is enough Time complexity 
You re given a matrix of size Let s call the matrix with nonnegative elements magic if it is symmetric so and for all triples Note that do not need to be distinct Determine if the matrix is magic As the input output can reach very huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,Consider the undirected complete graph with nodes with an edge between nodes with cost Let denote the minimum possible value of the max edge of a path from to We know that by definition If the matrix is magic we can choose arbitrary such that by repeating invocations of the inequality given Also you can show that if this inequality is satisfied then the matrix is magic by choosing an and arbitrary So this shows that the matrix is magic if and only if Thus combining with we have We need a fast way to compute for all pairs This can be computed as the MST as the path in the MST minimizes the max edge between all pairs of nodes So the algorithm works as follows First find the MST on the complete graph Then the matrix is magic if and only if the max edge on the path between in the MST is exactly equal to Also you shouldn t forget to check symmetry of the matrix and diagonal for zeros P S Unfortunately we couldn t increase the value in this problem the tests already had the size about 67MB and they couldn t be given with generator So most of the users who solved this problem uses bitset s The complexity of their solution is where or 
You are given an array consisting of elements You may apply several operations possibly zero to it During each operation you choose two indices and increase by and remove the th element from the array so the indices of all elements to the right to it decrease by and also decreases by Your goal is to make the array strictly ascending That is the condition should hold where is the resulting size of the array Calculate the minimum number of actions required to make the array strictly ascending ,Suppose we don t have any constraints on the order of elements the resulting array just should not contain any duplicates Let s build the result one element after another in ascending order so each element we create is strictly greater than the previous To create an element just use some subset of elements and merge them into new element This process can be efficiently modeled with the following dynamic programming dp cnt mask is the minimum value of the last element if we merged all the elements from mask into cnt ascending numbers To model transitions we simply iterate on the mask of elements that will be merged into a new one and check if its sum is greater than the last element we created This runs in O n3 n if we use an efficient way to iterate on all masks that don t intersect with the given mask Okay how about maintaining the order When we create an element by merging some elements of the original array let s choose some position of an element we use in merging and state that all other elements are added to it Then to ensure that the result is ascending the position of this element should be greater than the position of the element we chose while building the previous number We can add the position we have chosen for the last element to the states of our dynamic programming so it becomes dp cnt mask pos the minimum value of the last element if we merged the mask of elements into cnt numbers and the last element originally had index pos in the array Using some greedy optimizations for example we should not iterate on the position we are choosing to merge it can be chosen greedily as the leftmost position after the position of previous element we are taking into consideration we can make it O n 2 3 n yet with a small constant factor To restore the answer we can maintain the previous values of mask and pos in each state since cnt just increases by 1 with each transition 
Let s call two numbers if their binary representations contain the same number of digits equal to For example and are similar binary representations are and and are similar binary representations are and and are not similar binary representations are and and are similar binary representations are and You are given an array of integers You may choose a non negative integer and then get another array of integers where denotes bitwise XOR Is it possible to obtain an array where all numbers are similar to each other ,Iterating over all possible values of and checking them may be too slow though heavily optimized brute force is difficult to eliminate in this problem so we need to speed this approach up The resulting number consists of bits Let s use the classical meet in the middle trick try all combinations of lowest bits try all combinations of highest bits and somehow merge the results When we fix a combination of lowest bits we fix lowest bits in every Suppose that there are ones among lowest bits of Analogically when we fix a combination of highest bits we fix highest bits in every Suppose that there are ones among highest bits of We want to find a combination of lowest and highest bits such that is the same for each Let s represent each combination of lowest bits with an dimensional vector with coordinates Let s also represent each combination of highest bits with an dimensional vector with coordinates We want to find a combination of lowest bits and a combination of highest bits such that their vectors are opposite We can do so for example by precalculating all vectors for all combinations of lowest bits storing them in a map or a trie iterating on a combination of highest bits and searching for the opposite vector in the map trie 
You are given a bipartite graph with vertices in the first part vertices in the second part and edges The maximum matching in this graph is the maximum possible by size subset of edges of this graph such that no vertex is incident to more than one chosen edge You have to process two types of queries to this graph remove the number of vertices from this graph so that the size of the maximum matching gets reduced and print the vertices that you have removed Then find any maximum matching in this graph and print the sum of indices of edges belonging to this matching query of this type will be asked only after a query of type As the answer to this query you have to print the edges forming the maximum matching you have chosen in the previous query Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query Use functions in and in languages after each writing in your program ,Let s start by finding the maximum matching in the given graph Since the constraints are pretty big you need something fast The model solution converts the matching problem into a flow network and uses Dinic to find the matching in but something like heavily optimized Kuhn s algorithm can also work Okay then what about finding the minimum possible number of vertices to delete in order to reduce the maximum matching We claim that it is always enough to remove one vertex and the proof will also provide a way to quickly search for such vertices Let s recall that the size of the maximum matching is equal to the size of the minimum vertex cover So we will try to find a way to reduce the minimum vertex cover by and it s actually pretty easy just remove any vertex belonging to the vertex cover it s obvious that it reduces the vertex cover by and the maximum matching by as well So we can find the minimum vertex cover in the graph using the standard algorithm to convert the MM into MVC or if you re using Dinic to find the maximum matching you can represent the minimum vertex cover as the minimum cut problem and for each query of type just take a vertex from the vertex cover we found Now the only thing that s left is discussing how to maintain the structure of the maximum matching in the graph In fact it s quite easy on the one hand since we remove the vertices belonging to the minimum vertex cover every edge including the edges from the matching will be incident to one of the vertices we will remove on the other hand due to the definition of the maximum matching there is no vertex that is incident to two or more edges from the maximum matching so every vertex from the vertex cover has exactly one edge from the maximum matching that is incident to it and when we remove a vertex we can simply remove the corresponding edge from the maximum matching So the only thing we need to do is to maintain which edge from the matching corresponds to which vertex from the minimum vertex cover and it will allow us to maintain the structure of the maximum matching and since these pairs don t change when we remove a vertex it is enough to get this information right after we have constructed the maximum matching in the given graph we won t need to rebuild it 
Let s call the set of positive integers if the following two conditions are met if and then and For the given values and you have to find the maximum size of the set ,The key idea of the task is to prove that there is an optimal answer where the chosen elements in has a period equal to Let s work with instead of Firstly let s prove that if we ve chosen correct set in interval then if we take all then set will be corect as well By contradiction suppose we have then or contradiction It means that if we take the correct set in interval we can create a periodic answer by copying this interval several times Next let s prove that there is an optimal periodic answer Let s look at any optimal answer and its indicator vector binary vector of length where iff is in the set Let Let s split the vector in intervals The st rd th segments have length and nd th segments have length If we choose any two consecutive segments its total length will be equal to and we can use it to make periodic answer by replacing all length segments with the chosen one and segments with the other one We can prove that we can always find such two consecutive segments that the induced answer will be greater or equal to the initial one If we create vector where is equal to the sum of in the th segment then the task is equivalent to finding and such that replacing all by and all by won t decrease array sum The proof is down below Now since the answer is periodical taking element is equivalent to taking all elements so for each we can calc the number of integers with the same remainder And for each we either take it or not So we can write where is the maximum sum if we processed elements and last elements are described by mask We start with and when look at the th element either take it if we can or skip it Time complexity is Let s prove that for any array we can find pair such that replacing all with and all with won t decrease the total sum Let s define and Let s make array where and The meaning behind is how changes the total sum if we replace corresponding elements by Note that finding a good pair is equivalent to finding Also note that and analogically Let s prove by contradiction suppose that for any Let s look at But from the other side we know that so otherwise will be negative In the same way since then Analogically we can prove that each but contradiction So there is always a pair i e a pair 
You are given a graph consisting of vertices and directed arcs The th arc goes from the vertex to the vertex has capacity and weight No arc goes into the vertex and no arc goes from the vertex There are no cycles of negative weight in the graph it is impossible to travel from any vertex to itself in such a way that the total weight of all arcs you go through is negative You have to assign each arc a flow an integer between and its capacity inclusive For every vertex the total flow on the arcs going to this vertex must be equal to the total flow on the arcs going from that vertex Let the flow on the th arc be then the cost of the flow is equal to You have to find a flow which the cost Sounds classical right Well we have some additional constraints on the flow on every edge if is even must be even if is odd must be odd Can you solve this problem ,This problem is solved using minimum cost flows duh Suppose all arcs have even capacity Then we can just divide each arc s capacity by and solve a usual minimum cost flow problem However when we have arcs with odd capacity it s not that simple We will deal with them as follows split an arc with capacity into two arcs one with capacity the other with capacity and somehow enforce that the second arc must be saturated We cannot divide all arcs by now because that would lead to non integer capacities instead we will exclude these arcs with capacity and somehow handle the fact that they must be saturated and only then divide all capacities by Okay how do we handle the edges we deleted For each vertex let s check if the number of such arcs connected to it is even If it is not the total flow for this vertex cannot be so it s impossible to find the answer the only case when it might be possible is if this vertex is the source or the sink in this case we need to check that both of these vertices have an odd number of arcs we want to delete connected to them and consider an additional arc with capacity and weight to make it even If for each vertex the number of odd arcs connected to it is even let s consider how much excess flow these arcs bring into the vertices For example if a vertex has ingoing odd arcs it has units of flow going into it which will be lost if we remove the edges we want to ignore To handle this add a new source and a new sink to our network let s call them and and process excess flow going into the vertex using an arc from to that vertex in the previous example we can add an arc from to the vertex with capacity not since we divide all capacities by Similarly excess flow going outside the vertex can be processed with an arc from that vertex to We need to make sure that all these edges must be saturated Okay what about actually running the flow from to We can do it as in flow with lower bounds problem by adding an arc with infinite capacity Wait a minute this may cause a negative cycle to appear If your implementation of mincost flow handles them you can use this approach but if you don t want to mess with negative cycles instead do the following add an arc and an arc both with infinite capacities to make sure that flow can go from to since these arcs don t have to be saturated but other arcs going from or into must be saturated set the costs of these other arcs to Okay that s it we just need to find the minimum cost flow in the resulting network The constraints are low enough so any minimum cost flow algorith can pass 
You are given a set of integer numbers initially it is empty You should perform queries There are three different types of queries Add all missing numbers from the interval Remove all present numbers from the interval Invert the interval add all missing and remove all present numbers from the interval After each query you should output of the set the smallest positive integer number which is not presented in the set ,There are many ways to solve this problem you can use cartesian tree segment tree sqrt decomposition maybe something else I personally see the solution with the segment tree the easiest one so let me describe it Firstly let s notice that the queries are offline So we can compress the numbers by taking and of each query will be either one of these numbers or So now we have numbers up to and pretty basic task on segment tree The first two types of queries are translated to assign value or on a segment set the number on some position is either present or not The third is for each in segment assign to this will inverse the segment as described in statement Segment tree should keep sum of the segment in its nodes XOR on segment will turn into is the length of the segment being covered by the node The leftmost zero cell is While standing in some node check if its left son is full has in every cell of the segment like if you use 1 indexed tree and intervals for it If it is full then go down to the right son otherwise there exists some zero cell in a segment of the left child and you should go down to it You should use lazy propagation to guarantee per query Overall complexity 
One day Masha came home and noticed mice in the corridor of her flat Of course she shouted loudly so scared mice started to run to the holes in the corridor The corridor can be represeted as a numeric axis with mice and holes on it th mouse is at the coordinate and th hole at coordinate th hole has enough room for mice so not more than mice can enter this hole What is the minimum sum of distances that mice have to go through so that they all can hide in the holes If th mouse goes to the hole then its distance is Print the minimum sum of distances ,This problem can be solved using dynamic programming Let be the answer for first holes and mice If the constraints were smaller then we could calculate it in just trying to update by all values of where and calculating the cost to transport all mice from the segment to th hole To calculate this in we will use a deque maintaining the minimum or a queue implemented on two stacks for example We iterate on and update all the values of with the help of this deque for each index we insert a value in the deque equal to where is the total distance required to move first mice to hole Updating the value is just extracting the minimum and adding this to it Don t forget to delete values from the deque to ensure that we don t send too much mice to the hole Time complexity 
You are given a bipartite graph is the set of vertices of the first part is the set of vertices of the second part and is the set of edges There might be multiple edges Let s call some subset of its edges iff the graph has each of its vertices incident to at least edges is such a covering that the size of the subset is minimal possible Your task is to find minimal covering for each where is the minimal degree of any vertex in graph ,To get the answer for some we can build the following network connect the source to every vertex of the first part with edge with capacity where is the degree of vertex then transform every edge of the original graph into a directed edge with capacity and then connect each vertex from the second part to the sink with capacity Then edges saturated by the maxflow are not present in the answer and all other edges are in the answer To solve it fastly we might just iterate on from its greatest value to and each time augment the flow we found on previous iteration Since maxflow in the network is at most and we will do not more than searches that don t augment the flow this solution is 
You are given three integers and Consider all binary strings i e all strings consisting of characters and or of length from to For every such string you need to choose an integer from to A multiset of binary strings of length is considered beautiful if for every binary string with length from to the number of strings in the multiset such that is their prefix is not exceeding For example let and The multiset of strings is beautiful since for the string there are strings in the multiset such that is their prefix and for the string there is one string in the multiset such that is its prefix and for the string there are strings in the multiset such that is their prefix and for the string there is one string in the multiset such that is its prefix and for the string there are strings in the multiset such that is their prefix and for the string there is one string in the multiset such that is its prefix and Now for the problem itself You have to calculate the number of ways to choose the integer for every binary string of length from to in such a way that the possible size of a beautiful multiset is ,First of all let s visualize the problem in a different way We have to set some constraints on the number of strings which have some kind of prefix Let s think about a data structure that would allow us to understand it better One of the most common data structures to store strings which works with their prefixes and maintains the number of strings with some prefix is a trie so we can reformulate this problem using tries Now the problem is the following one we have a binary trie of depth the leaves of this trie may store strings and for each vertex except for the root we can set a constraint on the number of strings stored in the subtree what is the number of ways to choose these constraints so that the maximum number of strings possibly with copies the trie can store is exactly To handle it we can use dynamic programming of the form the number of ways to choose the constraints for the vertex and its subtree so that the maximum number of strings which can be stored in the subtree is exactly When calculating we can iterate on the constraint for the vertex let it be and the maximum number of strings in the subtrees of and let these be and and make updates of the form add to the value of This dynamic programming will work in or depending on the implementation which is too slow However we can use the following optimizations to improve the complexity of the solution all vertices on the same depth can be treated as equivalent so we can actually calculate this dynamic programming not for vertices but just for when handling transitions from some node s children to that node let s split these transitions into two steps The first step is iterating on the number of strings which fit into the subtrees of the children the second step is iterating on the constraint for the subtree of the node The first step is actually a convolution if we don t consider the constraint for the node itself then the transitions would be something like add to the value of so it can be improved to with FFT The second step can be improved to as well if we iterate on the minimum between the constraint for the node and the total number of strings which can be stored in the children and maintain the sum on suffix for the values of dynamic programming Overall these optimizations lead to a solution with complexity 
The government of Berland decided to improve network coverage in his country Berland has a unique structure the capital in the center and cities around the capital The capital already has a good network coverage so the government ignores it but the th city contains households that require a connection The government designed a plan to build network stations between all pairs of neighboring cities which will maintain connections only for these cities In other words the th network station will provide service only for the th and the th city the th station is connected to the th and the st city All network stations have capacities the th station can provide the connection to at most households Now the government asks you to check can the designed stations meet the needs of all cities or not that is is it possible to assign each household a network station so that each network station provides the connection to at most households ,There are plenty of different solutions to this problem Here is one that doesn t use Hall s theorem Let s look at pair as fuction how many connections will be left for the th city if we take connections from the th station This function has the following structure there is a minimum required let s name it to meet the needs of the th city and with borrowed connections there will be free connections to the th city Increasing by some we can get free connections but there is upper bound to number of free connections In other words the function where For example let s calculate the corresponding coefficients for the th function if then and if then and Why did we define such functions If we can calculate result function then we can check the possibility of meeting all needs by checking that this fuction exists and i e the minimum free can be used as borrowed Fortunately it turns out that the superposition is either don t exists if for example or it has the same structure as any function So we can calculate in one pass and find the answer We will skip the detailed formulas to calculate you can either find them by yourself or look at function in author s solution The resulting complexity is 
New Year is getting near So it s time to change handles on codeforces Mishka wants to change his handle but in such a way that people would not forget who he is To make it work he only allowed to change letters case More formally during handle change he can choose any segment of his handle and apply or to all letters of his handle on this segment more fomally replace all uppercase letters with corresponding lowercase or vice versa The length is fixed for all changes Because it is not allowed to change codeforces handle too often Mishka can perform at most such operations What is the value of where is the number of lowercase letters and is the number of uppercase letters can be obtained after optimal sequence of changes ,Let s simplify the problem a bit we need either to minimize the number of lowercase letters or to minimize the number of uppercase letters Both variants can be described by the following model we have a binary array a where a i 0 if s i is in the correct case and a i 1 otherwise We can do at most k operations set 0 on the segment i i l 1 and we d like to minimize the total sum of a At first let s start with a solution which is pretty slow but correct Let dp len c be the minimum sum of the prefix a 0 dots a len 1 such that c operations was already applied on it In order to calculate this dp somehow efficiently we need to understand that it s optimal to avoid intersections of segments of applied operations so we can further specify the state of dp with the following all c applied operations have their right borders le len 1 It s easy to specify the transitions we either apply set operation on len len l 1 and relax dp len l c 1 with dp len c or not and relax d len 1 c with dp len c a len It still O nk so we d like to optimize it more and we can do it using the lambda optimization i e aliens trick Here we will try to describe what aliens trick is and the features of its application on the discrete calculations In general aliens trick allows you to get rid of the restriction on the total number of operations applied to the array sometimes it s the number of segments in the partition of the array by replacing it with the binary search of the value lambda connected to it The lambda is the cost of using the operation or the cost to use one more segment in the partition In other words we can use as many operations as we want but we need to pay for each of them Often we can calculate the answer without the restriction faster The main restriction of the using this dp optimization is the following in case of the discrete model consider the answer ans c for the fixed c or dp n c If we look at the function ans c it should be somewhat convex i e ans c 1 ans c ge ans c ans c 1 or sometimes ans c ans c 1 ge ans c 1 ans c for all possible c Let s look at the answers of the modified version of the problem with cost lambda for each used operation as function res lambda c It s easy to prove that res lambda c ans c lambda c and it s also somewhat convex for a fixed lambda as a sum of convex functions But more important it has the following property let c lambda be the position where the res lambda c is the minimum possible It can be proven from the convex property that c lambda ge c lambda 1 This property leads to the solution binary search lambda while keeping track of the c lambda i e find the minimum lambda that c lambda le k But there are several problems related to the discrete origin of the problem The c lambda is not unique In general case there is a segment cl lambda cr lambda where the minimum res lambda c can be achieved But there is still a property that cl lambda ge cl lambda 1 and cr lambda ge cr lambda 1 So we need to ensure that we will always find either minimum such c lambda or maximum such c lambda The second problem comes from the first one There are situations when c lambda c lambda eps 1 It creates a problem in the next situation suppose the binary search finished with lambda opt the c lambda opt 1 k and c lambda opt k But we need to use exactly k operations what to do Using float values will not help so we don t need them so we ll use usual integer bs Suppose we minimized the c lambda opt then we can show that k in cl lambda opt cr lambda opt or in other words res lambda opt k res lambda opt c lambda opt So we can claim that we calculated the value not only for c lambda opt but also for k In the end if we can efficiently calculate c lambda and res lambda c lambda for the fixed lambda then we can binary search lambda opt extract res lambda opt c lambda opt and claim that the dp n k res lambda opt c lambda opt lambda opt k Finally let s discuss how to calculate c lambda and res lambda c lambda for a fixed lambda Since res lambda c lambda is just a minimum cost and the c lambda is the minimum number of operations with such cost We can calculate it by simplifying our starting dp Remember the cost is calculated in a next way for each remaining 1 in a we pay 1 and for each used operation we pay lambda Let d len cost len cnt len where cost len is minimum cost on the prefix of length len and cnt len is minimum number of operations cost len can be achieved Then the transitions are almost the same we either let a len be and relax d pos 1 with cost len a len cnt len or start new operation and relax d pos len with cost len lambda cnt len 1 The result is pair d n Some additional information we should carefully choose the borders of the binary search we should choose the left border so it s optimal to use operation whenever we can usually 0 or 1 And we should choose the right border so it s never optimal to use even one operation usually more than the maximum possible answer The total complexity is O n log n P S We don t have the strict proof that the ans c is convex but we have faith and stress We d appreciate it if someone would share the proof in the comment section 
You are given a matrix initially filled with zeroes We define as the element in the th row and the th column of the matrix Two cells of the matrix are if they share a side and the elements in these cells are equal Two cells of the matrix belong to the same if there exists a sequence such that is the first cell is the second cell and for every and are connected You are given queries of the form For every such query you have to do the following replace the element with count the number of connected components in the matrix There is one additional constraint for every ,Note that because of the low constraints on the number of colors the problem can be solved independently for each color Now you can divide the queries into two types add a cell to the field and delete it You have to maintain the number of components formed by added cells Cell deletions will occur after all additions because of the condition The first part of the solution will be to calculate the number of components while adding new cells This is a standard problem that can be solved using the DSU After that we should note that if we consider the process of removing cells from the end this process is similar to the process of adding Therefore we have to process delete requests from the end in the same way as add requests only their contribution to the number of components will be opposite in sign 
A subarray of array from index to the index is the array The number of occurrences of the array in the array is the number of subarrays of such that they are equal to You are given arrays the elements of these arrays are integers from to You have to build an array consisting of integers from to in such a way that for given subarray the number of occurrences of in the array is than the number of occurrences of each non empty subarray of in Note that if doesn t occur in and no subarray of occurs in this condition is still met for Your task is to calculate the number of different arrays you can build and print it modulo ,What does the condition the number of occurrences of in the array is than the number of occurrences of each non empty subarray of in mean First if contains two or more equal elements then any occurrence of introduces at least two occurrences of that element so any element in is forbidden it should not appear in the resulting array Now let s consider an array such that every its element is unique Every element of should be a part of an occurrence of in the array Let s rephrase this condition as follows Let s build a directed graph on vertices where an arc from vertex to vertex means that each occurrence of should be followed by and each occurrence of should be preceded by i e is followed by in some array Let s consider the weakly connected components in this graph If we have at least one occurrence of some element from a component in it means that all other elements from this component occur in as well Some integers from and are bad in a sense that we cannot uniquely determine which element should follow precede them in terms of graph theory it means that the in degree or out degree of a vertex is at least Since by picking one element from a component we will have to use all elements from a component it means that if a component contains at least one bad element the whole component will be bad we cannot use any element from it If a component is a cycle no vertex has in degree or out degree greater than but the component is still bad since if we include at least one element from we cannot finish the cycle the array is not infinite but the cycle is Okay the only good components are chains When we use an element from a chain in all elements from this chain will be used in exactly the same order that they were in the chain so should consist of some chains linked together chains may repeat and some chains may be absent from We can write a solution with dynamic programming let be the number of ways to construct an array of length using these chains The transitions are as follows where is the number of chains and is the length of the th chain The number of chains is up to and the number of states in dynamic programming is so the solution works in which is too slow We can improve it with the following two facts all chains of the same length are indistinguishable there are different lengths of chains So instead of iterating on the chains themselves in dynamic programming we will iterate on the lengths of the chains considering only lengths having at least one chain and process all chains of the same length as one by introducing a multiplier in our dynamic programming where is the number of chains of length That way our dynamic programming will work in if we skip the values of with 
You are given an array consisting of integers and queries to it th query is denoted by two integers and For each query you have to find integer that occurs in the subarray of from index to index a subarray is a contiguous subsegment of an array For example if then for query the subarray we are interested in is and possible answers are and for query the subarray we are interested in is and there is no such element that occurs exactly once Can you answer all of the queries ,Suppose all queries have the same right border Then the answer for the query can be some integer such that the last occurence of on the prefix of the array is inside the segment but the second to last occurence is outside the segment or even does not exist More formally let be the maximum index such that and or if there is no such the answer to the query is some number such that and and is the rightmost occurence of in the segment For a fixed right border we can build a segment tree which for every index such that is the rightmost occurence of on stores the value of and if we query minimum on the segment in such tree we can try to find the answer Let the position of minimum be If then can be the answer otherwise there is no answer But this is too slow since we can t afford to build a segment tree for every possible value of There are two methods how to deal with this problem you may sort all queries by their right borders and maintain the segment tree while shifting the right border when going from to we have to update the values in the positions and or we may use a persistent segment tree and get an online solution We tried to eliminate solutions using Mo s algorithm but in fact it s possible to squeeze some implementations of it into TL There are two optimizations that might help there When dividing the elements into blocks we may sort the first block in the ascending order of right borders the second in descending the third in ascending order again and so on And also it s possible to obtain a Mo based solution with worst case complexity of if we maintain the set of possible answers using sqrt decomposition on it 
You are given a positive greater than zero integer You have to represent as the sum of integers possibly negative consisting only of ones digits For example and Among all possible representations you have to find the one that uses the minimum number of ones in total ,Let s build the number from the lowest digit to the highest digit with the following dynamic programming the minimum number of ones if least significant digits are already fixed the carry to the next digit is can be negative there are positive numbers of the form of length greater than or equal to and negative numbers of length greater than or equal to First consider the transitions when we reduce the values of and or Such transitions correspond to the fact that in the optimal answer there were several numbers of length exactly and they should not be considered further If the value of matches the th least significant digit in then we can use transition to th state with the new value of and the number of ones in the answer increased by It remains to estimate what the maximum value of and we need The value of doesn t exceed the total number of numbers that we use in the answer Using at most numbers we can decrease the length of by at least Thus the maximum value of and is at most where n is the length of the number For the value of the condition should be met similarly for a negative value Thus we can assume that the absolute value of doesn t exceed The total complexity of this solution is yet with a high constant factor 
You are given a simple undirected graph with vertices is even You are going to write a letter on each vertex Each letter should be one of the first letters of the Latin alphabet A path in the graph is called Hamiltonian if it visits each vertex exactly once A string is called palindromic if it reads the same from left to right and from right to left A path in the graph is called palindromic if the letters on the vertices in it spell a palindromic string without changing the order A string of length is good if each letter is one of the first lowercase Latin letters if you write the th letter of the string on the th vertex of the graph there will exist a palindromic Hamiltonian path in the graph Note that the path doesn t necesserily go through the vertices in order Count the number of good strings ,Let s start with making some implications from the low constraints What s the upper estimate on the number of answers Too high let s think of a better one Using some combinatorics we can normalize the answers in such a way that there are at most th Bell s number of them The method basically defines the components of equal letters Given a string we write down the letters in it in the order they appear for the first time in the string and rename the first of them to the second one to and so on Only possible answers already Hmm but we should also have an even amount of each letter That is the absolute lowest estimate and it s equal to about What does it exactly mean for a string to be good There exists a path such that there s a pair of equal letters that occupy the st and the th vertex in the path a pair on the nd and th and so on So for each of possible answers we want to determine if there s a way to split the groups of equal letters into pairs of equal letters such that there exists a path through these pairs Such a path would mean building a palindrome from inside out A quick estimation on a number of splittings into pairs The first letter can be matched against other letters the first among the unmatched ones against other letters and so on Thus it s equal to For each splitting into pairs we can determine if there exists a path That is a straightforward dynamic programming similar to a usual hamiltonian path search It stores a mask of visited and the last visited pair For a transition you want to either go from the first vertex of one pair to the first vertex of another one and from the second to the second or the other way around That would take for each splitting The only thing left is to propagate the results from the splitting into pairs to splitting into even sized components of equal letters A splitting into pairs is a splitting into components of size Let that be a base case for the dp For every splitting into components find a component of size at least we still have to split it into pairs and separate it into a component of size a pair and the rest of the component Moreover a pair can always be chosen in such a way that one of its elements is the first element of the component So there are states and at most transitions from each of them Maybe there s a more convenient way to store the states but the one I found to be fast enough is hashing the state into a base integer since there are no more than components numbered through and storing it in a map hashmap 
You are given a tree consisting of vertices numbered from to and edges numbered from to Initially all vertices except vertex are inactive You have to process queries of three types activate the vertex It is guaranteed that the vertex is inactive before this query and one of its neighbors is active After activating the vertex you have to choose a subset of edges of the tree such that each vertex is incident to chosen edge and each vertex is not incident to any of the chosen edges in other words this subset should represent a perfect matching on the active part of the tree If any such subset of edges exists print the sum of indices of edges in it otherwise print queries of this type will be asked only right after a query of type and there will be such queries If your answer to the previous query was simply print otherwise print the subset of edges for the previous query as follows first print the number of edges in the subset then print the indices of the chosen edges The sum of indices should be equal to your answer to the previous query terminate the program Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query Use functions in and in languages after each writing in your program ,Let s root the tree at vertex and try to analyze when a tree contains a perfect matching If we want to find the maximum matching in a tree we can use some greedy approaches like take a leaf of the tree match it with its parent and remove both vertices repeat this process until only isolated vertices remain If we are interested in a perfect matching then this process should eliminate all of the vertices Let s modify this process a bit by always picking the deepest leaf If there exists a perfect matching picking the deepest leaf will ensure that the tree always remains a tree and doesn t fall apart i e there will always be one connected component It means that when we remove the leaf with its parent this leaf is the only descendant of its parent It s easy to see that whenever we remove a pair of vertices in this process for each remaining vertex the number of its descendants is either left unchanged or decreased by It means that if a vertex has an even number of descendants it will have an even number of descendants until it is removed and the same for odd number of descendants Let s call the vertices with even number of descendants including the vertex itself and all the other vertices A vertex cannot change its status in the process of building the perfect matching Each leaf is and odd vertex and if its parent has only one child this parent is an even vertex So when we remove a pair of vertices one of them the child is odd and the other of them the parent is even This leads us to another way of building the perfect matching match each odd vertex with its parent and make sure that everything is correct Unfortunately implementing it is per query so we need something faster We can see that each even vertex has at least one odd child because if all children of a vertex are even then the number of its descendants including the vertex itself is odd In order to find a perfect matching we have to make sure that each even vertex has one odd child each odd vertex has an even vertex as its parent All this means is that it cannot be greater since each even vertex has at least one odd child and if it is smaller it s impossible to match the vertices The perfect matching itself consists of edges that connect odd vertices with their parents Okay now we need some sort of data structure to maintain the status of each vertex and the sum of edges that lead to an odd vertex if directed from top to bottom In our problem we have to add new leaves to the tree it happens when a vertex is activated and this increases the number of descendants for every vertex on the path from the root to this new leaf So we need some sort of data structure that supports the operations add a new leaf and flip the status of all vertices on a path One of the structures that allow this is the Link Cut Tree but we can use the fact that the whole tree is given in advance to build a Heavy Light Decomposition on it which is much easier to code Operations on segments of paths can be done with a lazy segment tree and each vertex then will be added in 
Calculate the number of permutations of size with exactly inversions pairs of indices such that and and exactly indices such that Yep that s the whole problem Good luck ,A lot of solutions which were written during the contest use Berlekamp Messey or some other algorithms related to analyzing linear recurrences but the model solution is based on other principles First of all if the number of inversions is at most it means that most elements of the permutation will stay at their own places and those which don t stay at their places can t be too far away from them Let s denote a block in a permutation as a segment of indices such that all elements less than are to the left of the block all elements greater than are to the right of the block all elements from belong to the block Let s say that a block is non trivial if it contains at least two elements Suppose we split a permutation into the maximum number of blocks Then for each block we can see that if its length is it has at least inversions to prove it you can use the fact that the number of inversions is equal to the number of swaps of adjacent elements required to sort the permutation and if we cannot split the block into other blocks it means that we have to swap each pair of adjacent elements in it at least once to sort it if the block is non trivial it has at least one such that From these two facts we can see that there will be at most non trivial blocks there will be at most elements in total belonging to non trivial blocks the maximum possible length of a block is The main idea of the solution is to calculate the following dynamic programming is the number of ways to split elements into non trivial blocks such that there are exactly inversions in them and exactly pairs Then to get the answer for the test case we can iterate on the number of non trivial blocks and the number of elements in them and choose the elements belonging to that blocks with a binomial coefficient The only thing that s left is how to calculate this dynamic programming efficiently There are a few ways to do it but the model solution uses a table the number of different non trivial blocks of length with elements and inversions to handle transitions This table is not very big so you can run an exhaustive search for minutes to calculate it and then just paste its results into the source code of your program Note that you have to make sure that you consider only the blocks which cannot be split any further 
A triple of points and on a coordinate line is called if and You are given a set of points on a coordinate line initially empty You have to process queries of three types add a point remove a point calculate the number of beautiful triples consisting of points belonging to the set ,We are going to calculate the answer as follows for every point let be the number of points such that i e the number of points that are to the right of and have distance at most from it Then the number of beautiful triples where is the leftmost point is We can sum these values over all points to get the answer so the solution should somehow maintain and update the sum of these values efficiently Let s see what happens when we add a new point or remove an existing point For all points to the left of it with distance no more than the value of increases or decreases by So we need some sort of data structure that allows adding subtracting on segment and maintains the sum of This looks like a lazy segment tree but updating the sum of can be tricky One way to do this is to notice that So maybe we can maintain the sum of and the sum of on the segment It turns out we can The model solution does this as follows the leaf of the segment tree corresponding to the position stores a vector with three values The inner nodes store the sums of these vectors in the subtree We can find a matrix which when multiplied by gets the vector and the inverse matrix to it Then adding to on segment means multiplying all vectors on segment by that matrix and subtracting means multiplying by the inverse matrix and since matrix multiplication is both associative and distributive the segment tree can handle these queries Okay there s only one small issue left right now our structure can store the sum of and over all possible points we build it on segment for example but we only need the sum over points One way to handle it is to use a flag for each leaf of the segment tree and pull the value up from the leaf only if this flag is true We will need a function that changes the value of this flag for a single leaf but it s not very different from a function that changes one value in a lazy segment tree Time complexity of the solution is where is the maximum coordinate of the point although the constant factor of the described approach is fairly large since it involves matrix multiplications You can improve the constant factor by getting rid of the matrices as mentioned earlier 
 Define a chain a chain of length is a single vertex a chain of length is a chain of length with a new vertex connected to the end of it with a single edge You are given chains of lengths You plan to build a tree using some of them Each vertex of the tree is either white or black The tree initially only has a white root vertex All chains initially consist only of white vertices You can take one of the chains and connect any of its vertices to any white vertex of the tree with an edge The chain becomes part of the tree Both endpoints of this edge become black Each chain can be used no more than once Some chains can be left unused The distance between two vertices of the tree is the number of edges on the shortest path between them If there is at least white vertices in the resulting tree then the value of the tree is the distance between the root and the th closest white vertex What s the minimum value of the tree you can obtain If there is no way to build a tree with at least white vertices then print ,At first let s realize that the tree structure doesn t matter that much What we actually need is the array such that it stores the number of white vertices on depth Initially and all other are zero If you take a chain and attach it to some vertex on depth then the number of vertices on depth decreases by Also the added vertices update some other counts So far it s extremely unclear what to begin with Let s start by introducing some greedy ideas For each let s find the most optimal tree using exactly chains and update the answer with each of them First it s always optimal to attach a chain with its middle vertex Just consider the changes in the white vertices counts Second for each it s always optimal to take the longest chains to use If not the longest are used then you can replace any of them and there will be more white vertices It would be nice if we were able to just add another chain to the tree for to get the tree for However that s not always the case But we can still attempt it and show that the optimal answer was achieved somewhere in the process Let s show that it s always optimal to attach a new chain to the closest white vertex So there are basically two cases there is not enough white vertices yet and there is enough What happens if there is not enough vertices and we pick the closest one to attach a chain to If there are still not enough vertices then we ll just continue Otherwise we ll have to show that the answer can t get any smaller by rearranging something Consider what the answer actually is Build a prefix sum array over then the answer is the shortest prefix such that its prefix sum is greater or equal to So we put the th chain to the closest white vertex at depth It decreases by and increases and further by or Every chain we have put to this point was attached to a vertex at depth less or equal to the answer otherwise we could ve rearranged it and obtain the answer before The optimal answer can be neither nor also because we could ve rearranged Thus the answer is at least and every single chain we have put was packed as tightly as possible below that depth The second case works similarly We could ve obtained the optimal answer before So the answer is below and we can do nothing about that Or the optimal answer is ahead of us so putting the chain at can decrease it as much or stronger as any other choice Thus updating the answer on every iteration will give us the optimal result Now we are done with the greedy time to implement it I chose the most straightforward way We basically have to maintain a data structure that can add on range get the value of a cell and find the shortest prefix with sum at least That can be easily done with segtree Overall complexity 
Consider the function where is an array of integers which returns an array consisting of integers such that is equal to the sum of first elements of array You have an infinite sequence of arrays where is given in the input and for each Also you have a positive integer You have to find minimum possible such that contains a number which is larger or equal than ,Let s delete all zeroes from the beginning of the array they won t affect the answer Also we will return an array of elements when calculating prefix sums sum of zero elements becomes a zero in the beginning of the array and so has to be removed If the size of array is at least then we will get after calculating only a few prefix sums so we can use simple iteration So now we have to obtain the solution in case array has less than elements If we remove zeroes from the beginning of each array then where is a matrix if otherwise Then we can use matrix exponentiation to check whether contains a number which is equal to or greater than and we can use binary search to find the answer To avoid overflows each time we get a number greater than we can set it to 
Let s call a set of positive integers if the product of the factorials of its elements is a square of an integer i e for some integer You are given a positive integer Your task is to find a subset of a set of maximum size If there are multiple answers print any of them ,A good start to solve the problem would be to check the answers for small values of One can see that the answers the sizes of the maximum subsets are not much different from itself or rather not less than Let s try to prove that this is true for all Consider is even Let let s see what the product is equal to if we take all the numbers from to From here we can see that for even the answer is at least because we can delete and the product of the remaining factorials will be the square of an integer for odd the answer is at least because we can delete and It remains to prove that the answer is at least for odd This is easy to do because the answer for is not less than the answer for minus because we can delete and solve the task with a smaller value Moreover it can be seen from the previous arguments that the answer can only be for and we already know that in this case one of the correct answers is to remove the factorials It remains to learn how to check whether it is possible to remove or numbers so that the remaining product of factorials is the square of an integer To do this we can use XOR hashes Let s assign each prime number a random bit number For composite numbers the hash is equal to the XOR of hashes of all its prime divisors from factorization Thus if some prime is included in the number an even number of times it will not affect the value of the hash which is what we need The hash of the product of two numbers is equal to the XOR of the hashes of these numbers Let s denote the hash function as Using the above let s calculate for all from to as well as for all from to this is easy to do because We will also store a map Let s calculate the hash and denote it as It remains to consider the following cases if then the current product is already the square of an integer for an answer of size we have to check that there exists such a that To find such let s check whether the map contains for an answer of size we have to check that there are such and that To do this iterate over and then check whether map contains otherwise the answer is and there is an answer where all numbers except are taken 
You are given an array consisting of positive integers You pick two integer numbers and from to inclusive numbers are picked randomly equiprobably and independently If then you swap values of and You have to calculate the expected value of the number of unique elements in segment of the array from index to index inclusive indexed ,For each index we will find the number of pairs before swapping such that is the first occurence of in the chosen segment Let be previous occurence of before if is the first occurence then if we suppose the array to be indexed Let s find the number of pairs such that and then multiply it by and subtract for this index has to be in segment and has to be in segment so the number of ways to choose this pair is The value we receive as the sum of these values over all segments is the total number of distinct elements over all pairs so we need to divide it by the number of these pairs 
A bracket sequence is a string containing only characters and A regular bracket sequence or shortly an RBS is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and bracket sequences and are not Let s denote the concatenation of two strings and as For example You are given bracket sequences You can rearrange them in any order you can rearrange only the strings themselves but not the characters in them Your task is to rearrange the strings in such a way that the string has as many non empty prefixes that are RBS as possible ,The constraint is a clear hint that we need some exponential solution Of course we cannot try all permutations Let s instead try to design a solution with bitmask dynamic programming A string is an RBS if its balance the difference between the number of opening and closing brackets is and the balance of its each prefix is non negative So let s introduce the following dynamic programming is the greatest number of RBS prefixes of a string if we considered a mask of strings the current balance of the prefix is and is a flag that denotes whether there already has been a prefix with negative balance We can already get rid of one of the states the current balance is uniquely determined by the mask So this dynamic programming will have states To perform transitions we need to find a way to recalculate the value of and the answer if we append a new string at the end of the current one Unfortunately it s too slow to simply simulate the process Instead for every string let s precalculate the value how does the flag and the answer change if the current flag is and the current balance is The resulting flag will be in one of the following two cases it is already the string we append creates a new prefix with non positive balance The second case can be checked as follows let s precalculate the minimum balance of a prefix of let it be If the flag will be Calculating how the answer changes is a bit trickier If the current flag is already the answer doesn t change But if it is the answer will increase by the number of new RBS prefixes If the balance before adding the string is then we get a new RBS prefix for every prefix of such that its balance is exactly to compensate the balance we already have there is no prefix with balance in before this prefix To quickly get the number of prefixes meeting these constraints we can create a data structure that stores the following information for every balance store a sorted vector of positions in with balance equal to Then to calculate the number of prefixes meeting the constraints we can find the first position in with balance equal to by looking at the beginning of the vector for and then get the number of elements less than this one from the vector for balance by binary search These optimizations yield a solution in although it s possible to improve to if you precalculate each value of for every string 
You know it s hard to conduct a show with lots of participants and spectators at the same place nowadays Still you are not giving up on your dream to make a car crash showcase You decided to replace the real cars with remote controlled ones call the event Remote Control Kaboom Show and stream everything online For the preparation you arranged an arena an infinite 2D field You also bought remote controlled cars and set them up on the arena Unfortunately the cars you bought can only go forward without turning left right or around So you additionally put the cars in the direction you want them to go To be formal for each car you chose its initial position and a direction vector Moreover each car has a constant speed units per second So after car is launched it stars moving from in the direction with constant speed The goal of the show is to create a car collision as fast as possible You noted that launching every car at the beginning of the show often fails to produce any collisions at all Thus you plan to launch the th car at some moment Note that it s not necessary for to be integer and is allowed to be equal to for any The show starts at time The show ends when two cars and collide i e come to the same coordinate at the same time The duration of the show is the time between the start and the end What s the fastest crash you can arrange by choosing all If it s possible to arrange a crash then print the shortest possible duration of the show Otherwise report that it s impossible ,Let be true if it s possible to have a collision before time That function is monotonous thus let s binary search for For some fixed car can end up in any point from to units along the ray That makes it a segment So the collision can happen if some pair of segments intersects Let s learn how to find that out The general idea is to use sweep line So let s add the events that the th segment such that opens at and closes at There were no vertical segments so and are always different At every moment of time we want to maintain the segments ordered by their intersection with the line Note that if two segments change their order moving along the sweep line then they intersect So we can maintain a set with a custom comparator that returns if one segment intersects the current line lower than the other one When adding a segment to set you want to check it s intersections with the next segment in the order and the previous one When removing a segment you want to check the intersection between the next and the previous segment in the order If any check triggers then return true immediately It s easy to show that if the intersection happens between some pair of segments then the intersection between only these pairs of segment also happens Now for the implementation details Precision errors play a huge role here since we use binary search and also store some stuff dependant on floats in the set The solution I want to tell requires no epsilon comparisons thus it calculates the answer only with the precision of binary search So the first issue rises when we have to erase elements from the set Notice that we can make a mistake when we are adding the segment and there is a segment with almost the same intersection point That will not make the answer incorrect that s not trivial to show but it s possible if you consider some cases If you can find it later to remove then it s not an issue at all However that will probably mess up the lower bound in the set Thus let s save the pointer to each element in the set and remove it later by that pointer The second issue comes when you have to check the intersection of two segments The error might appear when one segment let the first point be the original and the second point be calculated depending on has it s intersection point with segment at exactly So the slightest miscalculations could matter a lot Let s learn to intersect in such a way that no epsilon comparisons are required Firstly we can store lines in the set instead of segments Second we can check the intersection of rays first and only then proceed to check the intersection of segments So two rays intersect if their lines intersect easy to check in integers the intersection point lies in the correct direction of both rays the intersection point is always a pair of fractions and you want to compare the signs of and Finally if all the checks hold then you can compare maximum of distances from and to the intersection point and If is greater or equal then they intersect in time There is no way to make that comparison in integers However it s precision only depends on the precision of as in the error here can t affect the answer greatly Overall complexity 
Recently you ve discovered a new shooter They say it has realistic game mechanics Your character has a gun with magazine size equal to and should exterminate waves of monsters The th wave consists of monsters and happens from the th moment of time up to the th moments of time All monsters spawn at moment and you have to exterminate all of them before the moment ends you can kill monsters right at moment For every two consecutive waves the second wave starts not earlier than the first wave ends though the second wave can start at the same moment when the first wave ends formally the condition holds Take a look at the notes for the examples to understand the process better You are confident in yours and your character s skills so you can assume that aiming and shooting are instant and you need exactly one bullet to kill one monster But reloading takes exactly unit of time One of the realistic mechanics is a mechanic of reloading when you reload you throw away the old magazine with all remaining bullets in it That s why constant reloads may cost you excessive amounts of spent bullets You ve taken a liking to this mechanic so now you are wondering what is the minimum possible number of bullets you need to spend both used and thrown to exterminate all waves Note that you don t throw the remaining bullets away after eradicating all monsters and you start with a full magazine ,Note some observations if we meet a new wave and start shooting it s optimal to shoot monsters in the wave using full magazines while we can and there are no reasons to take breaks between shooting monsters from one wave That s why we can track only moments when waves start and the number of remaining bullets in magazine we have at these moments Moreover since the next wave starts not earlier than the previous ends we can think that when we start dealing with one wave we ve already dealt with the previous one Also instead of keeping track of the remaining bullets let s just look only at such indices of waves when we reloaded and threw remaining bullets before reaching them So we can write the next dp is the minimum number of bullets we spend dealing with the first waves and now we standing at the moment with full magazine Obviously Now with fixed we can iterate over the index of a wave before which we ll reload throwing away remaining bullets And for waves we need to check that we are able to exterminate all these waves without throwing away any bullets We can check it with several formulas If it s possible for segment then the possibility for the segment is just checking that we can exterminate the th wave having bullets in the start in no more than reloads plus checking that we have at least one unit before for a reload As a result the time complexity of the solution is 
You are given a bipartite graph the first part of this graph contains vertices the second part contains vertices and there are edges Initially each edge is colorless For each edge you may either leave it uncolored it is free paint it red it costs coins or paint it blue it costs coins No edge can be painted red and blue simultaneously There are three types of vertices in this graph colorless red and blue Colored vertices impose additional constraints on edges colours for each red vertex the number of red edges indicent to it should be than the number of blue edges incident to it for each blue vertex the number of blue edges indicent to it should be than the number of red edges incident to it Colorless vertices impose no additional constraints Your goal is to paint some possibly none edges so that all constraints are met and among all ways to do so you should choose the one with minimum total cost ,A lot of things in this problem may tell us that we should try thinking about a flow solution Okay let s try to model the problem as a flow network First of all our network will consist of vertices and edges of the original graph We somehow have to denote red blue and colorless edges we will do it as follows each edge of the original graph corresponds to a bidirectional edge with capacity in the network if the flow goes from the left part to the right part along the edge it is red if the flow goes from right to left it is a blue edge and if there is no flow along the edge it is colorless Okay we need to impose some constraints on the vertices Consider some vertex from the left part Each red edge incident to it transfers one unit of flow from it to some other vertex and each blue edge incident to it does the opposite So the difference between the number of blue and red edges incident to is the amount of excess flow that has to be transfered somewhere else If is colorless there are no constraints on the colors of edges so this amount of excess flow does not matter to model it we can add a directed edge from source to with infinite capacity and a directed edge from to sink with infinite capacity What if is red At least one unit of flow should be transfered to it so we add a directed edge from the source to with infinite capacity And if is blue we need to transfer at least one unit of excess flow from it so we add a directed edge from to the sink with infinite capacity such that there is at least one unit of flow along it The colors of the vertices in the right part can be modeled symmetrically How to deal with edges such that there should be some flow along them You may use classic flows with demands approach from here https cp algorithms com graph flow with demands html Or you can model it with the help of the costs if the flow along the edge should be between and we can add two edges one with capacity and cost where is a negative number with sufficiently large absolute value for example and another with capacity and cost Okay now we know how to find at least one painting How about finding the cheapest painting that meets all the constraints One of the simplest ways to do it is to impose costs on the edges of the original graph we can treat each edge of the original graph as a pair of directed edges one going from left to right with capacity and cost and another going from right to left with capacity and cost 
Polycarp wants to build a fence near his house He has white boards and red boards he can use to build it Each board is characterised by its length which is an integer A good fence should consist of red board and several possibly zero white boards The red board should be the longest one in the fence every white board used in the fence should be strictly shorter and the sequence of lengths of boards should be ascending before the red board and descending after it Formally if boards are used and their lengths are in the order they are placed in the fence from left to right let s call this array the following conditions should hold there should be exactly one red board in the fence let its index be for every for every When Polycarp will build his fence he will place all boards from left to right on the same height of without any gaps so these boards compose a polygon Polycarp is interested in fences of some special perimeters He has integers he really likes these integers are and for every such integer he wants to calculate the number of different fences with perimeter he can build two fences are considered different if their are different Can you help him calculate these values ,Let s analyze how the perimeter of the fence can be calculated if we know its array of lengths Suppose there are boards in the fence The perimeter of the fence can be composed of the three following values the lower border of the fence with length horizontal segments in the upper border of the fence with total length vertical segment of the border The total length of all vertical segments before the red board including its left border is The total length of all vertical segments after the red board including its right border is too So the perimeter of the fence is where is the number of boards used in constructing the fence and is the length of the red board So for example if we want to create a fence that contains a red board with length and has perimeter it should contain exactly white boards Now let s solve the problem as follows iterate on the length of the red board that will be used and for each calculate the number of ways to construct a fence with a red board of length and exactly white boards which are shorter than Suppose all white boards shorter than have distinct lengths Then for each board there are three options not place it at all place it in the left part to the left of the red board or place it in the right part So if there are different white boards shorter than the number of ways to build a fence with white boards is Okay now let s consider the opposite situation there is no unique white board that is for each length we have either boards or at least boards Suppose the number of different lengths is For each length we can choose whether we place a board of such length in the left side and in the right side So the number of ways to build a fence with white boards is And now let s consider the general case Divide all boards into two categories unique and non unique If we want to build a fence with exactly white boards there are ways to do it Since we should calculate these values for many different values of we have to use FFT we should form two polynomials and and then multiply them Since the modulo is special it s better to use NTT 
Consider some positive integer Its prime factorization will be of form Let s call if the greatest common divisor of the sequence is equal to For example numbers are and numbers are not Count the number of integers from to Each testcase contains several values of for each of them you are required to solve the problem separately ,Whoops it seems this problem can be done in a similar manner as in problem Firstly is some number has of the prime powers not equal to then you can take root th power from it That is the same as dividing all powers by Now it turned out there are really a small amount of these numbers up to if you take the squares out Actually our solution wasn t that Let s count the answer using inclusion exclusion principle For this Mobius function can be used The answer is The power part is the amount of numbers which raised to the th power becomes less ot equal to This turns zero for like iterations on for any up to However calculating each log as it is will lead to a solution which might be too slow Let s process the queries in the decreasing order of will be calculated naively each time in or however complexity has the built in function maybe or The rest powers will be initialized with their upper limits in the start like for for and so on Now proceeding to the next number will only decrease the current maximum number for each power Subtract one until you reach the needed number and check in Overall complexity 
You are given an array consisting of integers numbered from to Initially all elements of are zero You have to process two types of queries to this array increase by compute where is the set of all integers from to which have remainder modulo Can you process all the queries ,Let s notice that if we process the queries of type naively then each such query consumes time where is the size of the array So queries with large can be processed naively For queries with small we may notice two things there are only possible queries each number in the array affects only possible queries So for small we may maintain the exact answer for each query and modify it each time we modify an element in the array If we process naively all queries with and maintain the answers for all queries with we will obtain a solution having time complexity Note that as in most problems related to sqrt heuristics it may be optimal to choose the constant that is not exactly but something similar to it but most solutions should pass without tuning the constant 
There are cities in the country of Berland Some of them are connected by bidirectional roads in such a way that there exists path which visits each road no more than once between every pair of cities Each road has its own length Cities are numbered from to The travelling time between some cities and is the total length of the roads on the shortest path from to The two most important cities in Berland are cities and The Berland Ministry of Transport decided to build a single new road to decrease the traffic between the most important cities However lots of people are used to the current travelling time between the most important cities so the new road shouldn t change it too much The new road can only be built between such cities and that and and aren t already connected by some road They came up with possible projects Each project is just the length of the new road Polycarp works as a head analyst at the Berland Ministry of Transport and it s his job to deal with all those projects For the th project he is required to choose some cities and to build the new road of length between such that the travelling time between the most important cities is Unfortunately Polycarp is not a programmer and no analyst in the world is capable to process all projects using only pen and paper Thus he asks you to help him to calculate the maximal possible travelling time between the most important cities for each project Note that the choice of and can differ for different projects , editorial by PikMike Firtsly we can notice that we get the most profit by placing the edge in a same position no matter the query Moreover once you have calculated the minimum difference you can apply to the shortest path by adding edge of the weight you can answer the queries in each Let the current shortest distance between and be Then the answer to some query is Let s proceed to proofs of the following Consider any of the optimal positions for the edge of weight Then weight will add to the answer in this position if the path isn t already but that is trivial Let there be another position such that the answer in it is less than the current one That means that the answer for weight in it is less by which is smaller than the first one we got which leads to contradiction The second fact can deduced from the first one Then let me introduce the next bold statement We root the tree with vertex Then if there exists such a vertex in that it s not an ancestor of vertex and the number of vertices in its subtree inclusive is greater than then That is simple just put the edge between the parent of this vertex and any of vertices of the subtree there always be such that the edge doesn t exist yet That won t change the shortest path no matter which it is Then we have a graph of the following kind That is the simple path between and and some vetices on it have additional children leaves Finally let s proceed to the solution We want to choose such a pair of vertices that the sum of edge on a path between them which are also a part of the path between and plus the weights of the newly included to shortest path edges if any is minimal possible Let s precalc the sum of weights of edges from vertex to vertex and parent of vertex Let be the weight of an edge between and Then we end up with the four basic cases for these vertices and with having greater or equal number of edges on path to than each of the form whether belongs to the simple path between and whether belongs to it doesn t belong the answer is belongs doesn t both belongs Each of these formulas can be broken down to parts with exacly one of the vertices Let s call them and That means minimizing the result is be the same as minimizing each of the parts We run depth first search on vertices which belong to a simple path between and inclusive Maintain the minimum value of you have already passed by Try connecting each vertex with this and also parent of the parent of the current vertex using all the possible formulas and updating with the resulting value Finally after the precalc is finished asnwer the queries in with Overall complexity editorial by BledDest Let s denote the distance from vertex to vertex in the tree as Similarly denote the distance from to in the tree as Suppose we try to add a new edge between vertices and with length Then two new paths from to are formed one with length and another with length Then the new length of shortest path becomes So if we find two non adjacent vertices such that is maximum possible then it will always be optimal to add an edge between these two vertices How can we find this pair of vertices Firstly let s suppose that when we pick vertex we will try to pair it only with vertices corresponding to the aforementioned constraint This can be done by sorting vertices by the value of and then for each vertex pairing it only with vertices that are later than in the sorted order How do we find the best pair for The best pair could be just the vertex with maximum possible but it is not allowed to connect a vertex with itself or its neighbour To handle it we may maintain a set of possible vertices delete all neighbours of from it pick a vertex with maximum and then insert all neighbours of back into the set This solution works in time 
You are running through a rectangular field This field can be represented as a matrix with rows and columns denotes a cell belonging to th row and th column You start in and have to end your path in From the cell you may advance to only if or only if However there are obstacles blocking your path th obstacle is denoted by three integers and and it forbids entering any cell such that You have to calculate the number of different paths from to and print it modulo ,There is a simple dynamic programming solution that works in Let s try to improve it Firstly if there are no obstacles in some column and we have calculated the number of paths to every cell of the previous column then we may get the values in column by multiplying the vector of values in column by the following matrix Then we may use binary exponentiation to skip long segments without obstacles in where is the length of the segment Let s try to modify this matrix if we have to forbid some rows All we need to change is to set every value in th row to if th row is forbidden So we may skip long segments not only if they don t contain any obstacles but also if the set of forbidden rows doesn t change on this segment So the solution is the following divide the whole matrix into segments by the endpoints of the obstacles then in every segment the set of forbidden rows doesn t change so we can skip it using fast matrix exponentiation 
You are given an array All are pairwise distinct Let s define function as follows let s define array where sort array in increasing order result of the function is Calculate i e total sum of for all subsegments of modulo ,Let s define some functions at first indicator function if is true and otherwise is a number of that and Good observation Another observation Now it s time to transform what we d like to calculate Since transformation of the second sum was standard we ll look at the first sum So we can iterate over and we d like to calculate this two sums fast enough So more transformations So while iterating over we need to make queries of two types set value in position and calculate It can be done by BIT with coordinate compression can be calculated in the same way iterating over in reverse order Result complexity is 
Polycarp studies in Berland State University Soon he will have to take his exam He has to pass exactly exams For the each exam there are known two days day of the first opportunity to pass the exam day of the second opportunity to pass the exam Polycarp during each day For each exam Polycarp chooses by himself which day he will pass this exam He has to pass all the exams Polycarp wants to pass all the exams as soon as possible Print the minimum index of day by which Polycarp can pass all the exams or print if he cannot pass all the exams at all ,This problem has many approaches as Hall s theorem Kuhn algorithm and so on I will explain one or two of them Let s find the answer using binary search It is obvious that if we can pass all the exams in days we can also pass them in days For the fixed last day let s do the following thing firstly if there exists some exam with the day of the first opportunity to pass it greater than then the answer for the day is false Next while there exist exams having only one possibility to pass them because of the upper bound of the maximum possible day or constraints imposed by the other exams we choose this day for this exam and continue after choosing such day there can appear some new exams with the same property Now there are no exams having only one day to pass them Let s take a look on the graph where vertices represent days and edges represent exams the edge between some vertices and exists iff there is an exam with the first day to pass it equal to and the second day to pass it equal to Let s remove all the exams for which we identified the answer Now let s take a look on the connected components of this graph and analyze the problem which we have now Our problem is to choose exactly one vertex incident to each edge of the connected component such that no vertex is chosen twice and we have to do this for all the connected components we have Let be the number of vertices in the current connected component and be the number of edges in the current connected component The answer for the connected component is true iff for obvious reasons There is very easy constructive method to see how we can do this If then the current connected component is a tree Let s remove some leaf of this tree and set it as the chosen vertex for the edge incident to this leaf and remove this edge too If then let s remove all leaves as in the algorithm for the tree For the remaining cycle let s choose any edge and any vertex incident to it set this vertex as the chosen to this edge and remove them Now we have a chain Chain is a tree so let s apply the algorithm for the tree to this chain So if for some connected component holds then the answer for the day is false Otherwise the answer is true Overall complexity because of numbers compressing or using logarithmic data structures to maintain the graph Also there is another solution which can be too slow I don t know why it works It is well known fact that if we will apply Kuhn algorithm to the some bipartite graph in order of increasing indices of vertices of the left part then the last vertex in the left part of this graph which is in the matching will be minimum possible Oh that s what we need Let the left part of this graph consist of days and the right part consist of exams The edge between some vertices from the left part and from the right part exists iff is one of two days to pass the exam Let s apply Kuhn algorithm to this graph considering days in increasing order The first day when matching becomes all exams are in the matching will be the answer I don t know its complexity really Maybe it works too fast because of the special properties of the graph If someone can explain in which time it works I will very happy 
You are given a circular array with elements The elements are numbered from some element with values from to in clockwise order The th cell contains the value The robot Simba is in cell Each moment of time the robot is in some of the cells at the begin he is in In one turn the robot can write out the number written in current cell or move to the adjacent cell in clockwise or counterclockwise direction To write out the number from the cell Simba doesn t spend any time but to move to adjacent cell Simba spends one unit of time Simba wants to write the number from each cell one time so the numbers will be written in a non decreasing order Find the least number of time units to write out all numbers ,The author solution for this problem uses dynamic programming I think that this problem can t be solved by greedy ideas Let s calculate two dp s z1i is the answer to the problem if all numbers less than ai are already printed but the others are not and z2i is the answer to the problem if all numbers less than or equal to ai are already printed but the others are not Let s denote dij the least distance between i and j on the circular array and odij is the distance from i to j in clockwise order Easy to see that z2i minj zj dij for all j such that the value aj is the least value greater than ai Now let s calculate the value z1i Consider all elements equals to ai in one of them we are If there is only one such element then z1i z2i Otherwise we have two alternatives to move in clockwise or counterclockwise direction Let we are moving in clockwise direction the last element from which we will write out the number would be the nearest to the i element in counterclockwise direction let s denote it u Otherwise at last we will write out the number from the nearest to the i element in clockwise direction let s denote it v Now z1i min z2u odiu z2v odvi Easy to see that the answer to the problem is mini z1i dsi over all i such that ai is the smallest value in array and s is the start position Additionally you should restore the answer To do that on my mind the simplest way is to write the recursive realization of dp test it carefully and then copy it to restore answer see my code below Of course it s possible to restore the answer without copy paste For example you can add to your dp parameter b which means it s need to restore answer or not Complexity O n2 Code 
Polycarp s phone book contains phone numbers each of them is described by the number itself and the number of times Polycarp dials it in daily Polycarp has just bought a brand new phone with an amazing feature More precisely buttons on it can have a number assigned to it not necessary from the phone book To enter some number Polycarp can press one of these buttons and then finish the number using usual digit buttons entering a number with only digit buttons is also possible button can only be used when no digits are entered No button can have its number reassigned What is the minimal total number of Polycarp can achieve after he assigns numbers to buttons and enters each of the numbers from his phone book the given number of times in an optimal way ,The first thing to come to one s mind is dynamic programming on a trie The most naive of the solutions take where is the total length of strings I ll introduce the faster approach Let be the solution for subtree of the vertex with buttons remaining and is the closest ancestor vertex with the button used in it This dp will be recalced via the other dp Let be the same thing as but only first children of is taken into consideration and doesn t have a button in it Give buttons to the current child then update with will then have two options for having button in it and for not having button in it has transitions and states has total transitions and also states 
Let and be some non negative integers Let s define of and as following write down the numbers one under another and align them by their least significant digit add them up digit by digit and concatenate the respective sums together Assume that both numbers have an infinite number of leading zeros For example let s take a look at a of numbers and You are given a string consisting of digits from to You are also given updates of form replace the digit at the th position of with a digit Note that string might have leading zeros at any point of time After each update print the number of pairs such that both and are non negative integers and the result of a of and is equal to Note that the numbers of pairs can be quite large so print them modulo ,Let s solve the task as if there are no updates This can be done with a pretty straightforward dp is the number of pairs such that the result of the strange addition of and is the prefix of of length From each state you can add a single digit to and to at the same time You can either go to and multiply the answer by the number of pairs of digits than sum up to Or go to and multiply the answer by the number of pairs of digits than sum up to Note that no pair of digits can sum up to a three digit value so it makes no sense to go further Let s optimize this dp with some data structure Segment tree will work well Let the node store the number of ways to split the segment into blocks of size or so that both the leftmost character and the rightmost character are not taken into any block the leftmost character is taken into some block and the rightmost character is not taken into any block the leftmost character is not taken into any block and the rightmost character is taken into some block both the leftmost and the rightmost characters are taken into some blocks This structure makes the merge pretty manageable You should glue up the segments in such a way that all the middle characters are taken into some block either in separate blocks in their own segments or into the same block of length The answer will be in the root of the tree in a value such that both characters are taken The update in the segment tree will still work in Overall complexity 
Let s denote the following function This function takes an array of length and returns an array Initially the result is an empty array For each integer from to we add element to the end of the resulting array if it is greater than all previous elements more formally if Some examples of the function if then if then if then if then You are given two arrays array and array You can delete some elements of array possibly zero To delete the element you have to pay coins the value of can be negative then you get coins if you delete this element Calculate the minimum number of coins possibly negative you have to spend for fulfilling equality ,The naive version of the solution is just dynamic programming let be the minimum cost of removed elements or the maximum cost of remaining elements if we considered first elements of and the resulting sequence maps to the first elements of There are two versions of this solution both working in calculate this dp as it is so there are states and transitions from each state ensure that the th element is taken into so there are states since each element appears in exactly once the second state can be deduces from the first one but up to transitions from each state It turns out that we can optimize the second approach Let s calculate the values of in ascending order of first of all we calculate the values of such that then transition into states such that and so on Calculating for is easy since the first element of is always the first element of we should delete all elements before the th if we want it to be the first element in So if is the maximum possible sum of costs of remaining elements if we considered the first elements of and the th element gets included in then for indices such that Okay now let s consider advancing from to If we want to go from to such that and we should leave the element in the array and delete some elements between indices and Which ones should be deleted First of all they are all elements with negative deletion cost but we should also get rid of all elements which could replace in that is all elements that are greater than So the remaining elements are which have and and we should be able to compute the sum of such elements Even if we manage to do it in which is possible there may be up to possible pairs of and to consider The easiest way to get rid of that is to sort all occurences of and and process them in ascending order maintaining the best that was already met That way each of the elements of will be considered at most twice so this solution runs in We know how to calculate the values now but how to determine the answer We should consider all values of such that and delete all elements with negative costs and all elements that are greater than from the suffix so this is another query of the form compute the sum of over which have and The most straightforward way to process them in is to use a persistent segment tree but since does not decrease in these queries as we process them we may maintain the elements we are interested in with a much simpler data structure for example Fenwick tree 
You are given an integer and two sequences and Let s call a set of integers such that if for every element of the following condition is met for every if divides then is also included in An empty set is always The of the set is You have to calculate the maximum possible of a set ,We will model the problem as the minimum cut in a flow network Build a network as follows create a source node a sink node and a vertex for every number from to Let s say that we are going to find the minimum cut in this network and the vertices belonging to the same cut part with represent the numbers that are taken into the answer Using the edges of the network we should model these constraints taking an element that depends on another element should force us to take as well taking an element with should add to our score taking an element with should subtract from our score Constraint can be modeled in the following way for every pair such that element depends on element and add a directed edge with infinite capacity from to That way if is taken and is not the value of the cut will be infinite because of this edge and this cut cannot be minimum Constraint is modeled in the following way for every such that add a directed edge with capacity from to That way if we take some element with into the answer is added to the value of the cut And for constraint for every such that add a directed edge with capacity from to That way if we take some element with is added to the value of the cut It s now easy to see that the answer is since it is exactly the sum of elements that were taken for positive elements we add them all up and then subtract the ones that don t belong to the answer for negative ones we just subtract those which belong to the answer To find a minimum cut just run maximum flow in this network There s one caveat though If for example all are equal or many are divisible by many other values in this network can contain edges To reduce the number of edges let s see that if for some index there exist two equal divisors of to the left of it let s say that these divisors are and then we only need to add an edge from to because taking also should force taking into the answer So for every divisor of we are interested in only one closest occurrence of this divisor to the left and we need to add a directed edge only to this occurrence and ignore all other occurrences That way for every vertex we add at most edges to other vertices where is the number of divisors of It can be proven that any maximum flow algorithm that relies on augmenting paths will finish after iterations in this network so it won t work longer than and both and are proportional to so any maximum flow solution will run in 
Let s call a triple of positive integers if the equality holds where is the concatenation of and and is the concatenation of and For the purpose of concatenation the integers are considered without leading zeroes For example if and then the triple is strange because But and is not strange because You are given three integers and Calculate the number of strange triples such that and ,Let be the length of number Then Let then and and we get Note that the right part is divisible by so the left part should as well Then we can see that should be divisible by since Let s say then divide both sides by We get Let s rearrange it and get the following Since is integer then should be integer In other words we can define such that is divisible by and is divisible by and is Since has a very special structure let s iterate over all lengths and all divisors of for a fixed Let s say and Then For a fixed and we know but don t know So let s just iterate over all possible and let s also iterate over all since is small since is a divisor of Next step is following let s look at previous equation but modulo Since then there is a solution to the previous module equation or Now we know exact value and so now the time to guess let s recall that Since we fixed then or Let s name the left border as and right border so inequality earlier is But we can make constrains even tighter note that but lately we said that or So or should be divisible by In total we can iterate in range with since we are interested only in divisible by Now we have enough variables to construct a triple we know and so If is already big we can skip that candidate Also we can calculate and check that pair is valid i e is really minimum possible We can understand it by checking that otherwise we can reduce by Value can be calculated from one of the formulas above as After that we calculate and check that is not too big Value can be calculated as At last we should check that the given triple satisfy all remaining assumptions we made is not too big is really and length of calculated is exactly we fixed If it s all fine then we found a correct triple It looks like thanks to all previous checks the triple we found is unique but just for safety let s push them all in one set to get rid of copies Calculating complexity is not trivial but let s note something the total number of divisors of for all is around For a fixed pair we iterate over all from to and for each we iterate from to but it s easy to prove that the total number of pairs is at most Now the last cycle iteration of with step where If we assume that is quite small then is proportional to and pairs are something like harmonic series with complexity In total the complexity is around 
You are given a string consisting of characters These characters are among the first lowercase letters of the Latin alphabet You have to perform operations with the string During the th operation you take the character that the th position and perform of the following actions with it swap it with the previous character in the string if it exists This operation is represented as swap it with the next character in the string if it exists This operation is represented as cyclically change it to the previous character in the alphabet becomes becomes and so on becomes the th letter of the Latin alphabet This operation is represented as cyclically change it to the next character in the alphabet becomes becomes and so on the th letter of the Latin alphabet becomes This operation is represented as do nothing This operation is represented as For example suppose the initial string is and the sequence of operations is Then the string is transformed as follows the first operation is so we change the underlined letter in to the next one in the first Latin letters which is The string is now the second operation is so we swap the underlined letter with the next one in the string The string is now the third operation is so we swap the underlined letter with the previous one in the string note that this is now the nd character of the string but it was initially the rd one so the rd operation is performed to it The resulting string is the fourth operation is so we change the underlined letter in to the previous one in the first Latin letters which is The string is now The result of performing the sequence of operations is Given the string and the value of find the lexicographically smallest string that can be obtained after applying a sequence of operations to ,The crucial observation that we have to make is that the character that initially occupied the position cannot occupy the positions to the left of we can shift some character two positions to the left using a combination of operations but we can t go any further So the prefix of the first characters of the resulting string can only be affected by the prefix of the first characters of the initial string Let s use the following dynamic programming to solve the problem let be the that we can obtain by applying operations to the first characters that is is the answer to the problem if we consider only first characters of the original string The transitions here are a bit tricky If we apply the operation or to the character then where is the character we get when we apply the aforementioned operation to that character is a bit more complicated we have to insert the character just before the last character of Modeling that we can apply the operation is likely the most complex transition in our dynamic programming First of all we can t just make an update to or since it leads us to a situation where we can still apply some operations to the prefix we have built Instead we have to consider the operation we will be able to do with the character Using another operation is useless since the result is like performing no operations with those two characters at all so we have to consider two options for operation with the th character or whichever is better or In the first case we update by appending the resulting two characters to the one that we get when we change and the one that initially was In the second case things are a bit trickier but still not very complicated the character that was moves two positions backward so it is inserted right before the last character of and then we append to the string we get So there are four transitions we have to make a transition from to that models the case when we apply or to the th character a transition from to that models the case when we apply to the th character a transition from to to model the operations or a transition from to to model the operations Overall complexity is but it can be improved to with some complicated data structures like persistent segment tree with hashes to compare strings and append characters to them in 
Ivan wants to write a letter to his friend The letter is a string consisting of lowercase Latin letters Unfortunately when Ivan started writing the letter he realised that it is very long and writing the whole letter may take extremely long time So he wants to write the of string instead of the string itself The of string is a sequence of strings where is the decimal representation of number without any leading zeroes and is some string consisting of lowercase Latin letters If Ivan writes string exactly times then string exactly times and so on the result will be string The length of a is Among all Ivan wants to choose a version such that its length is minimum possible Help Ivan to determine minimum possible length ,Let be the answer for the prefix of consisting of first characters How can we update from Suppose that we try to represent the substring from index to index indexed by writing it as some other string times Then this string has to be the smallest period of the substring and where is the length of the smallest period The smallest period of some string can be calculated as follows compute prefix function for and if is divisible by is the last value of prefix function then the length of the smallest period is if not then the length of the smallest period is This allows us to write a solution with complexity To improve it to we can use the fact that when we compute prefix function for some string we compute it for every prefix of this string So to obtain all values of we need in our solution we only need to compute prefix functions for every suffix of 
Suppose you are given two strings and You can apply the following operation any number of times choose any substring of or and sort the characters in it in non descending order Let the minimum number of operations you have to apply in order to make them equal or if it is impossible to make and equal using these operations For example in one operation we can sort the whole first string in one operation we can sort the substring of the second string starting from the nd character and ending with the th character You are given strings having equal length Calculate ,Disclaimer the model solution is very complicated compared to most participants solutions Feel free to discuss your approaches in the comments First of all it s easy to determine when two strings cannot be made equal using these operations it s when their multisets of characters differ So we divide the strings into different equivalence classes and for any pair of strings from different classes the answer is For any pair of strings from the same class the answer is either or since operations are always enough to make the strings from the same equivalence class equal we just sort both of them Okay now for each class we have to calculate the number of pairs of strings with the distance equal to Okay suppose you have two strings and and you want to make them equal using one operation Suppose that lexicographically Since applying an operation can t result in getting a lexicographically larger string we should apply the operation on the string not Suppose we choose a substring of the string and sort it All characters to the left of position and to the right of position are untouched and all characters in are ordered in non descending order so in order to transform into we should choose a subsegment such that all characters outside this segment are the same in both strings and the substring of is sorted So the best way to choose a subsegment is to compute the longest common prefix of and the longest common suffix of and and try sorting everything in the middle in This gives us a solution in for a pair of strings we can check that one of them can be transformed into the other in To do so we need to build some data structure allowing to query longest common prefixes suffixes in a trie with LCA or precalculating LCP and building a sparse table of them can do the trick furthermore we want to be able to check if some subsegment of some string is sorted in but precalculating them is quite easy So we have a solution that works if the strings are long in the model solution this approach is used on classes having not more than strings The second approach can be used on classes having many strings If the number of strings is big it means that they are short so we can do the following thing for each string iterate on the subsegment we will sort and check if the resulting string exists The model solution uses some very complicated data structures to implement this but I believe that it s quite easy to get this approach working using string hashes The only dangerous thing in the second solution you have to consider is that choosing different substrings to sort may result in getting the same resulting string One good way to deal with this is to ignore some substrings if sorting them doesn t change the leftmost or the rightmost character in the substring for example if we sort the substring in the string the character in the beginning of this substring is unchanged so we can get the same result by sorting So we consider sorting the substring only if it changes both the first and the last characters of the substring Okay so we have two approaches one works well with a small number of long strings and the other works well with a big number of short strings We can choose which of them to run depending on the size of the equivalence class we are considering and this idea gives us a working solution 
You should process queries over a set of strings Each query is one of three kinds Add a string to the set It is guaranteed that the string was not added before Delete a string from the set It is guaranteed that the string is in the set For the given string find the number of occurrences of the strings from the set If some string from has several occurrences in you should count all of them Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query of the third type Use functions in and in languages after each writing in your program ,Let s get rid of the queries for deleting a string There are no strings that will be added two times so we can calculate the answer for the added but not deleted strings and for the deleted separately and subtract the second from the first to get the answer So we can consider that there are no queries of deletion Now let s use Aho Corasik algorithm The only difficulty is that the strings are adding in online mode but Aho Corasik algorithm works only after adding all the strings Note that the answer for the given set of strings equal to the answer for any part of the set plus the answer for the remaining part Let s use the trick with converting the static data structure Aho Corasik in this case to the dynamic one For the set of strings let s maintain a set of no more than sets of the strings with sizes of different powers of two After adding new string we should move the sets from the lowest powers of two to the largest until we got an invariant set of sets Easy to see that each string will be moved no more than times so we can process each query in time 
You are given a rooted tree consisting of vertices Each vertex has a number written on it number is written on vertex Let s denote as the distance between vertices and in the tree that is the number of edges in the shortest path from to Also let s denote the of vertex as the set of vertices such that both these conditions are met is an ancestor of every vertex is an ancestor of itself You are given queries to the tree th query is represented by two numbers and and the answer to this query is the minimum value of among such vertices such that belongs to blocked subtree of Write a program that would process these queries quickly ,The main idea is to use a two dimensional data structure one dimension is depth of vertices and other dimension is the time we entered a vertex during DFS Model solution uses sparse table for these purposes First of all let s renumerate the vertices so we can handle them easier We run DFS from the root and then sort the vertices by their depth and if depths are equal by time we entered them in DFS Then we renumerate vertices in this sorted order We need to denote some functions in order to continue depth of vertex in the tree the time we entered during DFS the time we left during DFS For each depth we can store a sorted array of vertices belonging do this depth This will allow us to build an auxiliary sparse table where is such vertex that is minimal among all vertices that meet first two conditions We also need a second sparse table where is iff is minimal among all vertices that meet first two conditions These sparse tables can be built using binary search in arrays we created for depths Okay why do we need them To create a third sparse table that will process the queries themselves the minimum value of among vertices such that belongs to blocked subtree of some vertex with index included in This table can be built backwards with the help of auxiliary tables So how do we answer the queries We need to look at the binary representation of and do something like binary lifting but descending the tree instead of ascending and maintain the leftmost and the rightmost vertices on current depth which belong to the subtree we are interested in and make queries to on the segment between these two vertices This solution works in but unfortunately or fortunately to some participants we made the time limit too high so the structures that require time to process each query such as two dimensional segment trees might also get AC 
Let be the number of positive divisors of a positive integer For example is divisible by and is divisible by and You are given an array of integers You have to process two types of queries for every replace with calculate Print the answer for each query ,At first let s notice that this function converges very quickly for values up to it s at most steps Now we should learn how to skip updates on the numbers and The function values can be calculated from the factorization of numbers in with Eratosthenes sieve Let s write two segment trees one will store maximum value on segment the other will store the sum When updating some segment check if its maximum is greater than Updates are done in the manner one can usually write build function you go down to the node corresponding to the segment of length and update the value directly Overall complexity as we access any segment no more than times 
Vova has taken his summer practice this year and now he should write a report on how it went Vova has already drawn all the tables and wrote down all the formulas Moreover he has already decided that the report will consist of exactly pages and the th page will include tables and formulas The pages are numbered from to Vova fills the pages one after another he can t go filling page before finishing page and he can t skip pages However if he draws than tables in a row or writes than formulas in a row then he will get bored Vova wants to rearrange tables and formulas in each page in such a way that he doesn t get bored in the process Vova can t move some table or some formula to another page Note that the count doesn t reset on the start of the new page For example if the page ends with tables and the next page starts with tables then it s counted as tables in a row Help Vova to determine if he can rearrange tables and formulas on each page in such a way that there is no more than tables in a row and no more than formulas in a row ,Let s intruduce the following dynamic programming approach is the smallest number of elements of type page can end with If we learn to recalculate it the answer will be if or I will try to prove it on the fly Let s look into the constructing of each page from the following perspective I ll consider the cases when the current page ends with tables and the previous page ends with either tables or formulas Let s write down all the tables and then put formulas as separators to them I will call number of tables on the end of the previous page the number of formulas on the end of the previous page the number on tables on the current page and the number of formulas on the current page In the case with tables on the end of the previous page the smallest number of separators you can have is Moreover if you have you can put one of the formulas right before the end of the page ending it with table The only case is when there are too many separators should be less or equal to you can put up to separators before each table The case with formulas on the end of the previous page isn t that different The smallest number of separators is and the limit to the number of separators is you can t put separators before the first table as in the first case the maximum number to that position is determined by the previous page Now let s take a look at resulting expressions You can notice that lowering can only decrease the lower bound on the number of separators and lowering can only increase the upper bound on the number of separators That shows that minimizing the values in is always profitable Overall complexity 
Polycarp plays a computer game In this game the players summon armies of magical minions which then fight each other Polycarp can summon different minions The initial power level of the th minion is and when it is summoned all previously summoned minions power levels are increased by The minions can be summoned in any order Unfortunately Polycarp cannot have more than minions under his control To get rid of unwanted minions after summoning them he may destroy them Each minion can be summoned and destroyed only once Polycarp s goal is to summon the strongest possible army Formally he wants to maximize the sum of power levels of all minions under his control those which are summoned and not destroyed Help Polycarp to make up a plan of actions to summon the strongest possible army ,First of all let s try to find the best strategy to play minions All minions should be summoned if someone is not summoned summoning and deleting it won t make the answer worse the resulting number of minions should be exactly if it is less then we didn t need to delete the last deleted minion Furthermore if some minion should be deleted we can delete it just after it is summoned All these greedy ideas lead to the following structure of the answer we choose minions and summon them in some order we choose minions which will be summoned and instantly deleted we summon the remaining minion Let s analyze how these minions affect the answer The first minion has power and does not give bonus to anyone the second one has power and gives bonus to one minion and so on the th minion from the first group adds to the answer Minions from the second group buff minions each so they add to the answer and the last minion adds Let s unite the first group and the last minion then we will have two groups of minions those which are destroyed the second group and those which are not destroyed the first group From there we will have two possible ways to finish the solution there are minions and positions for them and for each pair minion position we may calculate the value this pair adds to the answer After that we should assign each monster a position in such a way that each position is chosen exactly once and the sum of values is maximized It can be done with mincost flows or Hungarian algorithm the minions from the first group should be played in non descending order of their Let s sort all minions by and write the following dynamic programming is the maximum answer if we considered first minions and of them were assigned to the first group Since the minions are sorted by whenever we add a minion to the first group it should add exactly to the answer and increase by and if a minion is added to the second group the answer is increased by 
There are teleporters on a straight line located in points It s possible to teleport from point to point if there are teleporters in of those points and it costs energy You want to install some additional teleporters so that it is possible to get from the point to the point possibly through some other teleporters spending than energy in total Each teleporter you install must be located in an What is the minimum number of teleporters you have to install ,Initial portals divide the path from to into separate sections If we place a new portal between two given ones it only affects the section between these two portals Let s suppose we want to place new portals into a section of length This will divide it into sections and it s quite easy to prove that these sections should be roughly equal in size to prove it we can show that if the sizes of two sections differ by more than the longer one can be shortened and the shorter one can be elongated so the sum of squares of their lengths decreases So a section of length should be divided into sections of length and sections of length Let s denote the total energy cost of a section of length divided by new portals as since we divide it in roughly equal parts it s easy to see thatThe key observation that we need to make now is that i e if we add more portals to the same section the energy cost change from adding a new portal doesn t go up Unfortunately we can t give a simple strict proof of this fact but we have faith and stress this would be easy to prove if it was possible to place portals in non integer points we could just analyze the derivative but in integer case it s way more difficult Okay what should we do with the fact that for a section of length The main idea of the solution is binary search over the value of i e we use binary search to find the minimum possible change that a new portal would give us Let s say that we want to check that using the portals that give the cost change is enough then for each section we want to find the number of new portals such that but we can use another binary search to do that For a fixed integer we can calculate not only the number of new portals that we can add if the cost change for each portal should be at least but also the total cost of the path after these changes let s denote as the total cost of the path if we place new portals until the cost change is less than and is the number of portals we will place in that case We have to find the minimum value of such that Now it looks like is the answer but this solution gives WA on one of the sample tests The key observation we are missing is that for the value we don t have to add all of the portals that change the answer by we might need only some of them To calculate the answer let s compute four values If we place portals and add new portals one by one until the total cost becomes not greater than the cost change from each new portal will be equal to or just if we consider the fact that we start using the portals which change the cost by So we can easily calculate how many more additional portals we need to add if we start from portals and cost The total complexity of our solution is we have a binary search over the cost change for each new portal and for a fixed cost change to determine the number of portals we place in each section we run another binary search in every section separately 
Assume that you have one dimensional segments each segment is denoted by two integers its endpoints Then you can build the following graph on these segments The graph consists of vertexes and there is an edge between the th and the th vertexes if and only if the segments and intersect there exists at least one point that belongs to both of them For example if then the resulting graph is the following A tree of size is good if it is possible to choose one dimensional segments so that the graph built on these segments coincides with this tree You are given a tree you have to find its good subtree with maximum possible size Recall that a subtree is a connected subgraph of a tree Note that you have to answer independent queries ,At first let s understand which trees are good For this let s consider some vertex we denote its segment as which is not a leaf Also let s consider some adjacent vertex we denote its segment as which also is not leaf It is claimed that segment can t be inside segment it s means and vice versa It s true because if segment is inside the segment then some vertex adjacent with also will be adjacent with So any non leaf vertex can be adjacent with at most non leaf vertexes Therefore good tree is a path with a leafs adjacent to this path So all the have to do it s find the such subtree of maximum size We can do it by subtree dynamic programming At first let chose the root of the tree some not leaf vertex Let be the answer for the subtree with root in and dp v 1 be the answer for the subtree with root in if we already took and its parent to the answer It can be calculated as follows there is a first maximum of all and is a second maximum and is a degree of vertex 
You have an array Let s call some subarray of this array a if it contains all integers from to exactly once For example array contains subarrays which are subpermutations You are asked to calculate the number of subpermutations ,At first let s represent permutations in the next form We assign to all numbers from to random 128 bit strings so the th number gets the string Then the permutation of length can be hashed as where is bitwise exclusive OR for example This representation is convenient because if we have two sets of numbers with a total number of elements equal to let s represent them as and we can easily check whether their union is a permutation of length condition must be hold Let s denote as Now let s iterate over position such that and calculate the number of permutations that contain this element To do it let s iterate over the right boundary and suppose that maximum element of permutation and its length at the same time is one of positions If it s true then the subpermutation should be on the positions And to check that this segment is a subpermutation we should just compare and Thus we will calculate all permutations in which the position of the maximum is to the right of the position of the To calculate all permutations we need to reverse array and repeat this algorithm and then add the number of ones in the array 
You are given a weighed undirected graph consisting of vertices and edges You should answer queries the th query is to find the shortest distance between vertices and ,Firstly let s find any spanning tree and root it at any vertex For each vertex we calculate the distance to the root let it be for vertex There are no more than edges that don t belong to the tree For each of these edges let s run Dijkstra s algorithm from some vertex incident to this edge Suppose we are answering a query If the shortest path between these vertices passes only along the edges of the tree then it can be calculated by the formula where is the lowest common ancestor of vertices and You may use any fast enough algorithm you know to calculate Otherwise there exists at least one vertex such that we ran Dijkstra s algorithm from it and it belongs to the shortest path Just iterate on every vertex for which we ran Dijkstra and update the answer with the value of where is the shortest path to the vertex from the fixed vertex 
There are well known formulas Also mathematicians found similar formulas for higher degrees Find the value of the sum modulo so you should find the remainder after dividing the answer by the value ,Statement the function of the sum is a polynomial of degree over variable This statement can be proved by induction to make step you should take the derivative Denote the value of the sum for We can easily calculate the values of for from to in time If then we already have the answer Otherwise let s use Lagrange polynomial to get the value of the sum for the given value The Largange polynomial have the following form In our case and To calculate in a linear time we should use that for all It s help us because with that property we can recalculate the inner product for from the inner product for simply by multiplying by two values and dividing by two values So we can calculate the sum in linear time over 
You are asked to build an array consisting of integers each element should be from to The array should be non decreasing for all from to You are also given additional constraints on it Each constraint is of one of three following types be equal to should be less than or equal to should be greater than or equal to Build any non decreasing array that satisfies all constraints or report that no such array exists ,Imagine there were no constraints of the second or the third types Then it would be possible to solve the problem with some greedy algorithm Unfortunately when both these constraints are present it s not immediately clear how to adapt the greedy Dynamic programming is probably also out of question because you can t maintain all possible cuts between equal values on each prefix Thus let s try to make a graph problem out of this Who knows maybe a flow or something else could work Create nodes for each position Let the th of them on the th position represent the condition of kind is equal to Then all constraints can be described as edges on this graph Binary variables restrictive edges Surely this is 2 SAT Connect the pairs of values that satisfy each constraint Add the edges between the adjacent positions to enforce the restriction on the non decreasing order Prohibit each position to be assigned to multiple values Force each position to be assigned at least one value Huh it s not that easy That s where the 2 SAT idea fails We want the conditions of form But that is not allowed since 2 SAT has to have two variables in a clause That s where the main idea of the problem comes up Instead of making our nodes represent let s make them and try building the graph again If then all nodes for will be true and the rest will be false So if is false then is false That will enforce the validity of the nodes themselves First the order If is true then is true The first type of constraints is basically the same as or For our conditions it s rather not or The second type of constraints Let be greater than or equal to some Then for this constraint to hold should be no greater than Thus if is true then should be false Same for and swapped The third type of constraints is similar Let be less than or equal to some Then for this constraint to hold should be greater than or equal to Thus if is false then should be true Same for and swapped And that s it Solve the 2 SAT and restore the answer I can advise making not but actually nodes for and force the values to be between and That will simplify the checks while adding the constraints Overall complexity 
Monocarp is playing a tower defense game A level in the game can be represented as an OX axis where each lattice point from to contains a tower in it The tower in the th point has mana capacity and mana regeneration rate In the beginning before the th second each tower has full mana If at the end of some second the th tower has mana then it becomes mana for the next second There are monsters spawning on a level The th monster spawns at point at the beginning of th second and it has health Every monster is moving point per second in the direction of increasing coordinate When a monster passes the tower the tower deals damage to it where is the current health of the monster and is the current mana amount of the tower This amount gets subtracted from both monster s health and tower s mana Unfortunately sometimes some monsters can pass all towers and remain alive Monocarp wants to know what will be the total health of the monsters after they pass all towers ,Let s start thinking about the problem from the easy cases How to solve the problem fast if all towers have full mana We can store prefix sums of their capacities and find the first tower that doesn t get drained completely with a binary search Let s try the opposite How to solve the problem fast if all towers were drained completely in the previous second It s the same but the prefix sums are calculated over regeneration rates What if all towers were drained at the same second earlier than the previous second and no tower is fully restored yet It s also the same but the regeneration rates are multiplied by the time passed since the drain What if we drop the condition about the towers not being fully restored How would a data structure that can answer prefix sum queries work It should store the total mana capacity of all towers that are full Then mana regeneration rates for all towers that aren t If these are kept separately then it s easy to obtain the prefix sum by providing the time passed This will be total capacity plus total regeneration rate multiplied by the time passed How to determine if the tower is fully restored since the drain or not That s easy For each tower we can calculate the number of seconds it takes it to get restored from zero That is Thus all towers that have this value smaller than the time passed won t get restored All the rest will Unfortunately in the actual problem not all towers were last drained at the same time However it s possible to reduce the problem to that Store the segments of towers that were drained at same time There are also towers that weren t drained completely but they can be stored as segments of length too When a monster comes it drains some prefix of the towers completely and possibly one more tower partially In terms of segments it removes some prefix of the them and possibly cuts one Then it creates a segment that covers the prefix and possibly a segment of length with a partially drained tower So each monster creates segments and removes no more segments than were created Thus if we were to process each creation and removal in some then the complexity will be All towers on each segment have the same time passed since the drain We want to query the sum on the entire segment If it is greater than the remaining health of the monster we want to find the largest prefix of this segment that has a smaller or equal sum than the monster health Given time passed let s learn to query the range sum If we knew the queries beforehand it would be easy Initialize a segment tree as if all towers are completely restored Then make events of two kinds a tower with restore time and a query with time Sort them in the decreasing order and start processing one by one When a tower event happens update a single position in the segment tree from capacity to regeneration rate When a query event happens find the sum Since the queries are not known beforehand make that segment tree persistent and ask specific versions of it If a segment of towers was last drained at time and the query is at time then you should query the segment tree in version Obviously you can store not all versions but only ones that have some tower change Moreover it s more convenient to make one version responsible for one tower update Then you can lower bound the array of sorted to find the version you want to ask at To determine the largest prefix of this segment that has a smaller or equal sum than the monster health you can either binary search for or traverse the segment tree for The time limit might be a little tight for the first approach but it can still pass Overall complexity 
There are cities in Berland arranged in a circle and numbered from to in clockwise order You want to travel all over Berland starting in some city visiting all the other cities and returning to the starting city Unfortunately you can only drive along the Berland Ring Highway which connects all cities The road was designed by a very titled and respectable minister so it is one directional it can only be traversed clockwise only from the city to the city i e from to from in from to The fuel tank of your car holds up to liters of fuel To drive from the th city to the next one liters of fuel are needed and are consumed in the process Every city has a fuel station a liter of fuel in the th city costs burles Refueling between cities is not allowed if fuel has run out between cities then your journey is considered incomplete For each city calculate the minimum cost of the journey if you start and finish it in that city ,The problem has a rather obvious naive solution in for each starting city but it s too slow So we have to speed up this solution somehow Binary lifting is one of the options but here we have a problem that it is difficult to connect two consecutive groups of steps because after the first group there is a certain amount of fuel left Therefore one of the solutions is to switch to such steps that liters of fuel remains after it Let s consider one of such greedy steps Suppose we are in the city with fuel then the following situations are possible let s buy exactly liters of fuel to reach the next city then the step length is and the cost is and where is the maximum number such that i e the number of consecutive cities with the cost let s buy exactly liters of fuel to reach the next city then the step length is and the cost is and let s find a minimum such that and i e such that you can reach it by spending all of liters let s buy exactly liters with the cost in the city then the step length is and the cost is let s buy liters with the cost in the city and the remainder of liters with the cost in the city then the step length is and the cost is Now using these types of steps we maintain an important invariant after each step the amount of fuel is So we can easily calculate the total distance and cost for several consecutive steps Which leads us to a solution using binary lifting for each city calculate the length and cost of the path with for all up to greedy steps And then using this data we can calculate the answer for each starting city in 
You are given a rooted tree consisting of vertices numbered from to The root of the tree is the vertex You have to color all vertices of the tree into colors also numbered from to so that there is exactly one vertex for each color Let be the color of vertex and be the parent of vertex in the rooted tree The coloring is considered beautiful if there is no vertex such that i e no vertex such that its color is less than the color of its parent by Calculate the number of beautiful colorings and print it modulo ,When a problem asks us to calculate the number of combinatorial objects that meet some constraints we can sometimes use inclusion exclusion formula Let s try to apply it in this problem We could use constraints that should not be violated The th constraint is formulated as follows there will be a constraint of this type for each Suppose we violated of these constraints and have chosen which constraints to violate then the number of colorings that meet these violations is for vertices the colors on them depend on some other independent vertices so we can assign only colors for independent vertices So the answer can be calculated as follows where is the number of ways to choose constraints to violate One initial guess how to calculate is that as it would be calculated in other more usual inclusion exclusion problems Unfortunately in this problem the constraints we violate are not independent For example if a vertex has several sons we can violate the constraint only on at most one edge leading from a vertex to its son simultaneously we cannot violate two or more such constraints Let s take care of this issue as follows we can write a dynamic programming of the form is the number of ways to process first vertices of the tree and choose exactly edges leading from these nodes to their sons so that no vertex has more than one edge leading to its sons chosen Then is exactly the number of ways to choose edges in the tree so that no vertex has more than one chosen edge leading to its sons and that will be equal to We can calculate this dynamic programming in a knapsack fashion in but it is too slow Instead let s optimize this knapsack DP with FFT for each vertex introduce a polynomial where is the number of children of the vertex Coefficients of this polynomial for the first vertex are the values of coefficients of the product of this polynomial with the polynomial for the second vertex are the values of and so on to obtain the values of we have to multiply all these polynomials and using FFT divide and conquer we can do it in 
You are given an unweighted tree with vertices Then following operations are applied to the tree A single operation consists of the following steps choose two leaves add the length of the simple path between them to the answer remove one of the chosen leaves from the tree Initial answer before applying operations is Obviously after such operations the tree will consist of a single vertex Calculate the maximal possible answer you can achieve and construct a sequence of operations that allows you to achieve this answer ,The solution is to choose some diameter of given tree then delete all the leaves which don t belong to diameter iteratively and then delete the diameter I e while tree includes vertices aside from the ones forming diameter we choose some leaf increase answer by the length of the path between this leaf and farthest endpoint of the diameter from this leaf and delete this leaf Then while tree consists of more than one vertex we choose two endpoints of diameter increase answer by the length of the path between it and delete any of them At first we need to prove that we can choose any diameter It can be proved by next fact we can find the diameter by two graph traversals DFS BFS we need to find farthest vertex and then again find farthest vertex from found farthest vertex given path is a diameter of the tree It means that for each vertex that doesn t belongs to the diameter we will add maximal possible path length by the algorithm described above And finally obviously that at some moment we need to delete the diameter and there is no way to do this better than we do it in described solution 
You are given a tree consisting of vertices Recall that a tree is an undirected connected acyclic graph The given tree is rooted at the vertex You have to process queries In each query you are given a vertex of the tree and an integer To process a query you may delete any vertices from the tree in any order except for the root and the vertex When a vertex is deleted its children become the children of its parent You have to process a query in such a way that maximizes the value of where is the resulting number of children of the vertex and is the number of vertices you have deleted Print the maximum possible value you can obtain The queries are independent the changes you make to the tree while processing a query don t affect the tree in other queries ,A naive solution to this problem would be to implement a recursive function which answers each query let be the answer to the query we can calculate it as since for each child of vertex we either delete it and change the score by or choose to let it remain and this increases the score by Unfortunately it is too slow Let s try to optimize it First of all since if we choose the exact same subset of vertices to delete for the query as we ve chosen for the query our score won t decrease Using this fact we can show that if it s optimal to remove some vertex in the query it s also optimal to remove a vertex in the query because it s optimal to remove vertex if and if this condition holds for some value of then it holds for each smaller value of Let be the maximum value of when it s optimal to remove the vertex We will calculate these values for all vertices of the tree using an event processing method we ll process the values of from to and use a set or a priority queue to store events of the form at the value vertex becomes optimal to delete This set priority queue should sort the events in descending order of the value of and in case of ties in descending order of depths of the vertices to make sure that vertices with the same value of are processed from bottom to up Let s analyze the implementation of this process more in detail For each vertex we will store two values the number of vertices we should remove from its subtree and the number of children this vertex will optimally have Using these two values we can easily calculate the value of for a vertex When a vertex is removed that is the event corresponding to this vertex is processed these values for this vertex should be added to its current parent we can use DSU to find the current parent easily for example and don t forget that the number of vertices we have to remove for this new parent also increases by then we recalculate the value of for the current parent and change the event corresponding to this current parent note that the value of for the current parent shouldn t be greater than the value of for the vertex we ve deleted Okay this allows us to calculate when it s optimal to delete each vertex But how do we answer queries One of the ways to do this is to process queries in the same event processing algorithm and for every value of we first remove the vertices with then process the queries There is an issue that when we remove a vertex it can affect the answer not only for its current parent but also for the vertices that could be its parents but are already deleted to handle this instead of adding the values of the deleted vertex only to the values of its current parent we perform an addition on the whole path from the vertex to the current parent excluding the vertex itself This path addition can be performed with a Fenwick or Segment tree over the Eulerian tour of the tree and this yields a compexity of though with a high constant factor 
There are cities along the road which can be represented as a straight line The th city is situated at the distance of kilometers from the origin All cities are situated in the same direction from the origin There are trucks travelling from one city to another Each truck can be described by integers starting city finishing city fuel consumption and number of possible refuelings The th truck will spend litres of fuel per one kilometer When a truck arrives in some city it can be refueled but refueling is impossible in the middle of nowhere The th truck can be refueled at most times Each refueling makes truck s gas tank full All trucks start with full gas tank All trucks will have gas tanks of the same size litres You should find minimum possible such that all trucks can reach their destinations without refueling more times than allowed ,First bonus solution implement idea from Blogewoosh 6 Time complexity will be somewhat and space complexity is Honest solution Note that for each truck lower bound on the answer is where is optimal partition of on segments partition which minimize maximum length of segment and doesn t depend on of truck So it enough to calculate optimal partition of segment on segments Let be position where last segment starts in partition with value Note that On the other hand But and then is somewhat convex Finally best is no more than And we can look at as second pointer along with as first pointer So we can for each move while answer relaxes while answer is decreasing or staying same In result for each and there will be operations in total Optimizing memory consumption is easy if we notice that we can iterate over but not save it as state of dp In the end time complexity is and space complexity is 
You are given a rooted tree consisting of vertices The vertex is the root Each vertex has an integer written on it this integer is for the vertex You are given queries to the tree The th query is represented by two vertices and To answer the query consider all vertices that lie in the subtree of or For all vertices in these two subtrees list all integers written on them and find the integer with the maximum number of occurrences If there are multiple integers with maximum number of occurrences the among them is the answer ,First let s solve the following problem we need to maintain a multiset of numbers and process queries of 3 th types add a number to the multiset remove one occurrence of a number from the multiset it is guaranteed that it exists calculate the mode on this multiset To do this we will maintain the array cnt i the frequency of i in the multiset Now the mode is the position of the leftmost maximum in this array There are many ways to search for this position we will use the following we will build a sqrt decomposition on the array cnt for a block we will maintain a maximum on this block and an array c i the number of positions j in this block such that cnt j i Since in each of the initial requests cnt i changes by no more than 1 the maximum in the block also changes by no more than 1 and using the c array it is easy to update it after each query Now to find the mode the position of the leftmost maximum in the cnt array you first need to go through all the blocks to find the value of the maximum and the leftmost block in which this maximum occurs then iterate over the desired position in this block Thus queries to add and remove an element run in O 1 and a mode search query runs in O sqrt A where A is the number of possible distinct values in a given problem A 2 cdot 10 5 Now let s get back to the problem itself Let s build a Preorder traversal of our tree Let tin v be the position in the 0 indexing of the vertex v in the Preorder traversal tout v be the size of the Preorder traversal after leaving the vertex v Then the half interval tin v tout v of the Preorder traversal represents the set of vertices of the subtree of the vertex v For the i th query we will consider tin v i le tin u i Let sz v tout v tin v be the size of the subtree of v B be some integer then v will be called light if sz v B and heavy otherwise A query i is called light heavy if v i is a light heavy vertex We will solve the problem for light and heavy queries independently Let s use the small to large technique and maintain the multiset described at the beginning of the solution Let at the moment we have this multiset for the vertex w Let s answer all light queries for which u i w To do this take all the vertices from the subtree of v i and add the numbers written on them calculate the mode on the current multiset this will be the answer to the query and then delete the newly added vertices In the standard implementation of small to large you need to maintain several structures at the same time which in this case is impossible due to the fact that each of them takes up O A sqrt A of memory This problem can be avoided for example as follows before constructing the Preorder traversal for each vertex v put its heaviest son at the head of the adjacency list Then it will be possible to iterate over the vertices in the order of the Preorder traversal preserving the asymptotics This part of the solution runs in O n log n qB q sqrt A Let s divide all heavy vertices into non intersecting vertical paths so that two vertices from the same path have subtrees that differ by no more than B vertices and the number of the paths themselves is O frac n B To do this let s take the deepest of the unused heavy vertices and build one of the desired paths going up to the parent while the first of these conditions is met Then we mark all the vertices in this path as used and start over We will continue to do this while there are still unused heavy vertices It is easy to see that the resulting paths are vertical and the subtrees of two vertices from the same path differ by no more than B by construction Let s prove that there are not very many of these paths To do this we will understand in which cases the path breaks If the current path contains a root then since the root has no parent the path will terminate Obviously this path is only 1 If the parent of the last vertex of the path has only one heavy child this last vertex itself From the construction a break means that the number of vertices in this path plus the number of children outside the heaviest son subtree of the parent of the last vertex and each vertex of the path except for the initial one is more than B in total but each of the counted vertices can be counted in only one of such cases that is the number of paths that terminate in this way does not exceed frac n B If the parent of the last node has more than one heavy child Let s leave only heavy vertices in the tree since the parent of a heavy vertex is a heavy vertex too it will indeed be a tree or an empty graph This tree contains at most frac n B leafs Calculating the total degree of the vertices of this tree we can see that there are at most frac n B additional sons all sons of a vertex except one This means that the number of paths terminating in this way is at most frac n B We got that the paths are O frac n B Let s divide the heavy queries according to the paths where the v i is situated We will answer queries with vertices v from the same path together We will do it similarly to the case with light queries with minor differences at the very beginning we add to the multiset all the vertices of the subtree of the initial vertex of the path and mentally remove these vertices from the subtrees of v i vertices Everything else is preserved Let s calculate how long it takes add all vertices from one subtree O n small to large O n log n to answer one query due to condition on vertices from one path we have to add at most B vertices Since there are only O frac n B paths the whole solution will take O frac n 2 log n B qB q sqrt A We take B sqrt frac n 2 log n q and counting n approx q we get B sqrt n log n and total running time O n sqrt n log n n sqrt A As already mentioned a subtree corresponds to a segment of the Preorder traversal so 2 subtrees are 2 segments We will maintain the data structure described at the beginning on the sum of 2 segments By moving the boundaries of these segments you can move from one query to another as in Mo s algorithm It remains only to sort the queries Heavy queries are sorted first by path number of v i then by tin u i Light queries are sorted only by tin u i but here you can t just move the segment of the v subtree you need to rebuild it for each query Solve this problem for two subtrees and a path connecting the roots of these subtrees This solution partially intersects with the one described by the problem author We will use the same data structure for maintaining the mode and we will also use DFS order of the tree but before constructing it we will reorder the children of each vertex so that the heaviest child is the first one Let tin v be the moment we enter the vertex v in DFS and tout v be the moment we leave the vertex As usual the segment tin v tout v represents the subtree of vertex v and we can change the state of the structure from the subtree of the vertex x to the subtree of the vertex y in tin x tin y tout x tout y operations Let this number of operations be cost x y Let v 1 v 2 dots v n be the DFS order of the tree We can prove that cost v 1 v 2 cost v 2 v 3 dots cost v n 1 v n is estimated as O n log n if we order the children of each vertex in such a way that the first of them is the heaviest one Let s analyze how many times some vertex v is added when we go in DFS order and maintain the current set of vertices When some vertex is added to the current subtree this means that the previous vertex in DFS order was not an ancestor of the current vertex so the current vertex is not the first son of its parent So the size of the subtree of the parent is at least 2x the size of the current vertex Since the path from v to root can have at most O log n such vertices then the vertex v is added at most O log n times Okay how do we use it to process queries efficiently Let s say that the vertex v i the i th vertex in DFS order has coordinate equal to cost v 1 v 2 cost v 2 v 3 dots cost v i 1 v i Let this coordinate be c v i Then if we have the data structure for the query x 1 y 1 and we want to change it so it meets the query x 2 y 2 we can do it in at most c x 1 c x 2 c y 1 c y 2 operations which can be treated as the Manhattan distance between points c x 1 c y 1 and c x 2 c y 2 Do you see where this is going We can map each query x y to the point c x c y and then order them in such a way that the total distance we need to travel between them is not too large We can use Mo s algorithm to do this Since the coordinates are up to O n log n but there are only q points some alternative sorting orders for Mo like the one that uses Hilbert s curve may work better than the usual one 
You are given a tree consisting of vertices Each edge has an integer value written on it Let be the number of values that appear on the edges of a simple path between vertices and Calculate the sum of over all pairs of vertices and such that ,Let s use contribution to the sum technique to simplify the problem Instead of counting the number of colors that occure only once for each path let s for each color count the number of paths that contain this color exactly once Now we can solve the problem independently for each color and sum up the answers The first intended solution was the following So we want to calculate the answer for some color Mark all edges of color as good the rest are bad Then we can calculate the number of paths up to vertex such that they contain either or good edges The transitions should be pretty easy and the answer should be updated when you consider gluing up paths from different children in each vertex Obviously this is per color so overall However we can only calculate this dynamic programming as easily on a virtual tree of vertices adjacent to all good edges How to calculate the dp for some vertex First push the paths from all virtual children to That was enough in the dp for the entire tree but now there are also removed vertices that could also have paths starting in them All these paths contain good edges otherwise they would have had virtual vertices on them Their amount is the following the size of the real subtree of minus the sizes of real subtrees of all its virtual children The rest is exactly the same as in the dp on the real tree A little fun trick Usually you want to add lca of adjacent vertices to the virtual tree But that s actually not needed here you can just add the root of the tree and link the vertices without a parent to them That won t change the result of the dp That solution works in or The second intended solution is slower complexity wise but not time wise In the first solution we wanted to leave only the good edges in the tree Here we want to remove only them Consider the resulting connected components What s the number of paths that contain only one of the good edges It s actually the product of sizes of the connected components this edge connects So we want to remove edges add edges and maintain the sizes of the connected components of the tree That s basically the same problem as dynamic connectivity The implementation works well enough 
You are given a tree with vertices its root is vertex Also there is a token initially placed in the root You can move the token to other vertices Let s assume current vertex of token is then you make any of the following two possible moves move down to any in subtree of if vertex is a leaf then move up to the parent no more than times In other words if is the depth of vertex the depth of the root is then you can move to vertex such that is an ancestor of and Consider that root is not a leaf even if its degree is Calculate the maximum number of different leaves you can visit during one sequence of moves ,Let s calculate answer in two steps At first let s calculate for each vertex what we can gain if we must return from subtree of in the end We need only pair of values minimal possible depth we can acquire to move up from subtree of and maximal number of different leaves we can visit Note that this two values are independent since we must return from and if for some child of we can return from it it s profitable to visit and return But if we can t return from so we are prohibited to descent to So number of visited leaves is just a sum of all if Also note that we can always reorder all children in such way that last visited vertex will have minimal So minimal possible depth is a minimum over all At second let s calculate maximal number of different leaves we can visit if we don t need to return from subtree of It can be calculated quite easy using array We just need to choose child we will not return from so from vertex we will take value and from other childen which we can return from value Result complexity is 
Vasya has got an array consisting of integers and two integers and in addition All numbers in the array are either between and inclusive or equal to The array is good if there is no segment of consecutive numbers Vasya will replace each with some number from to inclusive in such a way that the resulting array is good Tell him the number of ways to do this replacement Since the answer may be large print it modulo ,Let s try dynamic programming approach to this problem Let be the number of ways to replace all with numbers from to in such a way that array is good and the last number of that array is Let Then initially it s if equals to or However we could include incorrect states such that segment consist of the same value It happens when as we should have at least elements segment has all its elements either equal to or If both of these conditions hold then you should subtract all the bad states from The number of them is 
Vasya wants to buy himself a nice new car Unfortunately he lacks some money Currently he has exactly burles However the local bank has credit offers Each offer can be described with three numbers and Offers are numbered from to If Vasya takes the th offer then the bank gives him burles at the beginning of the month and then Vasya pays bank burles at the end of each month for the next months including the month he activated the offer Several credits can be active at the same time It implies that Vasya pays bank the sum of over all the of active credits at the end of each month Vasya wants to buy a car in the middle of some month He just takes all the money he currently has and buys the car of that exact price Vasya don t really care what he ll have to pay the bank back after he buys a car He just goes out of the country on his car so that the bank can t find him anymore What is the maximum price that car can have ,Notice that if we take offer exactly months before we buy the car it will provide us with money at the time of the car purchase Moreover the only values of that make sense are This means we can immediately solve the problem via an algorithm for the assignment problem such as min cost flow or the Hungarian algorithm This has a runtime of or which manages to fit under the time limit with a good implementation Code 49033783 The better solution is to notice that for all offers where we don t use up all months it s best to sort them by so that the highest values of have the lowest values of This leads to a very nice DP solution 49035446 
You are given a tree consisting of vertices and triples where and are integers from to and is a string You want to write a lowercase Latin letter on each vertex in such a way that for each of given triples at least one of the following conditions holds if you write out the letters on the vertices on the simple path from to in the order they appear on this path you get the string if you write out the letters on the vertices on the simple path from to in the order they appear on this path you get the string Find any possible way to write a letter on each vertex to meet these constraints or report that it is impossible ,Let s design a naive solution first For each of the given triples we have two options either write the string on the tree in the order from to or in reverse order Some options conflict with each other So we can treat this problem as an instance of 2 SAT create a variable for each of the given strings which is true if the string is not reversed and false if it is reversed find all conflicting pairs of options and then run the usual algorithm for solving 2 SAT Unfortunately the number of conflicting pairs can be up to so we need to improve this solution Let s introduce a variable for each vertex of the tree which will define the character we write on it At first it looks like we can t use these variables in 2 SAT since the number of possible characters is not But if a vertex is covered by at least one path in a triple then there are only two possible characters we can write in this vertex either the character which will land on this position if we write the string from to or the character on the opposite position in the string And obviously if a vertex is not covered by any triple we can write any character on it Okay now for each vertex we have two options for a character and Let the variable be true if we write on vertex and false if we write Also for each triple let s introduce a variable which is true if the string is written from to and false if it is written in reversed order If the vertex is the th one on the path from to then we should add the following constraints in our 2 SAT if we need a constraint NOT OR NOT if we need a constraint OR NOT if we need a constraint NOT OR if we need a constraint OR Thus we add at most constraints in our 2 SAT The only thing we haven t discussed is how to actually restore each path from to this can be done either with any fast algorithm that finds LCA or by searching for LCA naively by ascending from one of those vertices until we arrive at the ancestor of another vertex this approach will visit at most vertices Overall this solution runs in 
You are given an integer value and a string consisting of digits from to inclusive A substring of a string is a contiguous subsequence of that string Let be the sum of digits of a substring Let s call substring if there are no values such that is divisible by You are allowed to erase some characters from the string If you erase a character the two resulting parts of the string are concatenated without changing their order What is the minimum number of characters you should erase from the string so that there are no substrings in it If there are no substrings in the given string then print ,The key observation is that since is only up to 20 there can t be that many different prime strings total turns out there are only about 2400 for the worst case of So we can generate all of them and perform a DP where our state is represented by the longest prefix of any of the strings we currently match We can do this by building a trie of all of the prime strings We then need to be able to transition around in this trie it turns out this is exactly what Aho Corasick does for us In particular knowing which node of the Aho Corasick tree we are currently at gives us the full information we need to determine whether or not we will match one of the strings after adding more characters later This leads to a fairly simple DP 90977148 
You are given an array with integers and queries Each query is described by two integers Let s define the function The function is defined for only For each query print the maximal value of the function over all ,We gave bad constraints to this problem so some participants solved it in time Note that The values can be simply precomputed Also you can notice that the value is equal to depending on the value modulo Let s use Mo s algorithm we should group all the queries to blocks by the left end and sort all the queries in each block by the right end Let be the maximal left end inside the current group then all left ends will be in distance not greater than from and right ends will be in nondecreasing order so we can move the right end by one total we will made no more than movements in each block During moving of the right end inside some group from the value to the value of the current right end we will maintain two tries the first for the values and the second for the values in the first we will maintain the minimal value of in the second the maximal After adding some values to the trie we should find the maximal value that can be formed by the current value To do that we should go down in the first trie maintaining the invariant that in the current subtree the minimal value is not greater than Each time we should go by the bit that is not equal to the corresponding bit in if we can do that otherwise we should go by the other bit In the second trie we should do the same thing with the difference that we should maintain the invariant that the maximal value in the current subtree is not less than the value After moving the right end we should iterate from the left end of the query to and update the answer without adding the current value to the tries Also after that all we should iterate over all the queries and with new empty tries iterate from the left end to add the current values to the tries and update the answer 
You are given uppercase Latin letters A and letters B The period of the string is the smallest such positive integer that indexed for each Note that this implies that won t always divide For example the period of string ABAABAA is the period of AAAA is and the period of AABBB is Find the number of different periods over all possible strings with letters A and letters B ,Let s introduce the slightly naive solution Iterate over all values for periods and check the possibility of each one being correct The conditions for some period can be formulated the following way is the total length of the string is the number of full periods of length Let s find at least one such pair and such that and the remainder part of the string can be filled with letters A and letters B By easy construction one can deduce that the conditions of and are enough Thus should be greater or equal to and In order to move to the faster solution one should also remember that both remainder parts and should be non negative Let s learn how to solve the problem for the whole range of lengths which all have the number of full periods equal to the same value Let this range be From the aforementioned formulas one can notice that the restrictions on both and don t depend on the length itself but only on value of To be more specific The lowest and the highest values for and will be the following It is claimed that every value between and exists if the values are valid and The full proof about the given conditions being sufficient and the existence of every value on that range is left to the reader Some kind of a hint might be the suggestion to check how the inequalities change on the transition from some period to Restrict the values by and to count each answer on exactly one range of lengths Finally the value of is added to the answer The number of ranges with the same is Overall complexity 
You are given an undirected complete graph on vertices A complete graph is a graph where each pair of vertices is connected by an edge You have to paint the edges of the graph into two colors red and blue each edge will have one color A set of vertices is if for every pair of vertices such that and there exists a path from to that goes only through red edges and vertices from Similarly a set of vertices is if for every pair of vertices such that and there exists a path from to that goes only through blue edges and vertices from You have to paint the graph in such a way that there is at least one red edge there is at least one blue edge for each set of vertices such that is either red connected or blue connected but Calculate the number of ways to paint the graph and print it modulo , if an undirected graph is disconnected then its complement is connected Similarly if its complement is disconnected then the graph itself is connected suppose a graph is disconnected Pick two vertices and from different components Every vertex outside of s component is connected to in the complement and every vertex outside of s component is connected to in the complement the complement also contains the edge from to so all vertices in the complement graph belong to the single component Why do we need this lemma at all We can treat the graph formed by blue edges as the complement to the graph formed by red edges So if the red graph is disconnected then the blue graph is connected so we don t need to consider the case when some set of vertices is connected by neither color We only need to make sure that no set of vertices is connected by both colors Let be the answer for Every graph counted in is either red disconnected or blue disconnected since there is a bijection between red disconnected and blue disconnected graphs you can flip the colors of all edges to transform one type into the other we will count only red disconnected graphs and multiply it by Let be the number of blue connected graphs with vertices meeting the properties of the problem statement It s easy to see that if otherwise the case is special because a graph on one vertex is both red connected and blue connected To calculate let s iterate on the number of vertices which are in the same red component as This component must be a red connected graph which meets the problem statement so the number of ways to build the graph on these vertices is there are ways to choose the vertices in the same component as and the remaining graph can be either red connected or blue connected so the number of ways to build the remaining graph is Thus we get the following two relations We can calculate all values with dynamic programming using these formulas in 
You are given an undirected complete graph on vertices A complete graph is a graph where each pair of vertices is connected by an edge You have to paint the edges of the graph into two colors red and blue each edge will have one color A set of vertices is if for every pair of vertices such that and there exists a path from to that goes only through red edges and vertices from Similarly a set of vertices is if for every pair of vertices such that and there exists a path from to that goes only through blue edges and vertices from You have to paint the graph in such a way that there is at least one red edge there is at least one blue edge for each set of vertices such that is either red connected or blue connected but Calculate the number of ways to paint the graph and print it modulo , Okay we need more definitions Here they come This way we can transform the formula for to the following Or even this since This is almost the convolution of the sequences and with a bit extra additional operations after the convolution so to compute the sequence we just need to compute the sequences and and then calculate their convolution with NTT All that s left is to multiply every element by the corresponding factorial But wait that s not so easy In order to calculate and we need to know Note that we can ignore the fact that and appear in the formula for since they are multiplied by so at least we don t have a dependency cycle Unfortunately we cannot just straightforwardly use convolution if we don t know the sequences and The model solution handles it using the following approach Let s generate and in parallel on the th iteration calculate then calculate and using it And we will calculate the convolution of the sequences and Suppose we want to calculate and the last time we calculated the convolution of and was after the iteration Back then we knew all elements from to and from to So the th term in the convolution of and contained the sum of over all such that and So in order to calculate we have to pick this value from the convolution and then add the sum of over all such that or and there are such values Suppose we compute the convolution every iterations Then the maximum value of is and every value of is calculated in We also make convolutions so the total complexity of this solution will be which can be transformed into if we pick 
You are given an array of integer numbers Your task is to divide the array into the maximum number of segments in such a way that each element is contained in segment each segment contains at least one element there doesn t exist a non empty subset of segments such that bitwise XOR of the numbers from them is equal to Print the maximum number of segments the array can be divided into Print if no suitable division exists ,Let s consider some division Represent the XOR sum of the subset via prefix XOR Those are I claim that you can collect any subset that is a XOR of an even number of for pairwise distinct values of Let s take a look on some prefix of processed segments where the last segment is taken into subset The previous taken s can t be changed the last taken can either be eliminated if we also take the current segment and that segment erases one value and adds one or added to the answer if we don t take it but the next taken segment will add two values You can see that the parity doesn t change Moreover you can collect any subset that is a XOR of an odd number of for pairwise distinct values of Just forget about taken into the answer as its value is Then all the even subsets which included it will become odd This way we can collect all subsets of for some division Now you just want find the division that produces the maximum number of linearly independent numbers binary vectors That is the size of the basis of the space of chosen numbers binary vectors Now it s time to abuse the fact that adding a number into the set can only increase the size of basis of the space Thus adding anything to the maximum set won t change the answer otherwise the result would be greater than the maximum Finally you say that the maximum basis size is equal to the basis size of all the prefix XOR and easily calculate in The only corner case is being itself Then for any division the full subset will also give result That is the only case with answer Overall complexity 
Adilbek has to water his garden He is going to do it with the help of a complex watering system he only has to deliver water to it and the mechanisms will do all the remaining job The watering system consumes one liter of water per minute if there is no water it is not working It can hold no more than liters Adilbek has already poured liters of water into the system He is going to start watering the garden right now and water it for minutes and the watering system should contain at least one liter of water at the beginning of the th minute for every from to Now Adilbek wonders what he will do if the watering system runs out of water He called his friends and asked them if they are going to bring some water The th friend answered that he can bring no more than liters of water he will arrive at the beginning of the th minute and pour all the water he has into the system if the system cannot hold such amount of water the excess water is poured out and then he will ask Adilbek to pay dollars for each liter of water he has brought You may assume that if a friend arrives at the beginning of the th minute and the system runs out of water at the beginning of the same minute the friend pours his water fast enough so that the system does not stop working Of course Adilbek does not want to pay his friends but he has to water the garden So he has to tell his friends how much water should they bring Formally Adilbek wants to choose integers in such a way that if each friend brings exactly liters of water then the watering system works during the whole time required to water the garden the sum is minimum possible Help Adilbek to determine the minimum amount he has to pay his friends or determine that Adilbek not able to water the garden for minutes You have to answer independent queries ,Despite the fact that statement sounds like some dp or flow the actual solution is pretty greedy Let s iterate over all minutes Adilbek has to water at and maintain the cheapest liters he can obtain to this minute Let this be some structure which stores data in form price for 1 liter total volume Adilbek can buy for this price Pairs will be sorted by the price of a liter The most convenient structure for that might be a C map for example When moving to the next minute pop the cheapest liter out of this structure and add it to the answer If that minute some friend comes then push his water to the structure if the total updated volume in the structure is greater than then pop the most expensive left overs out of it so that the structure holds no more than liters total That prevents out solution to fill the watering system over its capacity The main idea for why this greedy strategy works is that it s never optimal to take not the cheapest liter because a liter of that price or cheaper will still be available in the future minutes Note that between each pairs of adjacent coming friends basically nothing happens Thus you can find the time between them and pop that number of cheapest liters right away instead of iterating minute by minute Overall complexity per query 
Polycarp has just launched his new startup idea The niche is pretty free and the key vector of development sounds really promising so he easily found himself some investors ready to sponsor the company However he is yet to name the startup Actually Polycarp has already came up with the name but some improvement to it will never hurt So now he wants to swap letters at some positions in it to obtain the better name It isn t necessary for letters to be adjacent In addition each of the investors has chosen some index in the name and selected a set of letters that can go there Indices chosen by different investors are pairwise distinct If some indices aren t chosen by any investor then any letter can go there Finally Polycarp is sure that the smallest lexicographically name is the best Like why do you think Google decided to become Alphabet More formally you are given a string consisting of lowercase Latin letters from to You can swap letters at any positions arbitrary number of times zero swaps is also possible What is the smallest lexicographically name you can obtain such that the letter at every position is among the allowed letters If Polycarp can t produce any valid name then print ,The idea of solution is the following we build the answer letter by letter when choosing a character for some position we try all possible characters and check that we can build the suffix after placing this character But we need to somehow do this checking fast As in many previous Educational Rounds in this round some participants solutions were much easier to write and understand than our own model solution Let s build a flow network where we have vertices representing the characters of the string and vertices representing the masks of characters Add directed edges from the source to every node representing some character with capacity equal to the number of such characters in the original string also add directed edges from every node representing some character to all vertices representing masks where this character is contained with infinite capacity and finally add a directed edge from every mask node to the sink with capacity equal to the number of positions where this mask of characters is allowed If we find maximum flow in this network we can check that the answer exists and if it exists build some answer Now let s try to build optimal answer by somehow rebuilding the flow in the network Suppose we are trying to place a character to position containing mask To check whether we can do it we have to try rebuilding the flow in such a way that the edge from vertex corresponding to to vertex corresponding to has non zero flow If it is already non zero then we are done otherwise we may cancel a unit of flow going through an edge from source to vertex then cancel a unit of flow going through an edge from vertex to sink decrease the capacity of these two edges by and check that there exists an augmenting path If it exists then returning the capacities back and adding one unit of flow through the path actually builds some answer where some character is placed on some position with mask so we may place it there otherwise it s impossible When we finally decided to place on position we have to decrease the flow through and the capacities of edges and All this algorithm runs in where is the size of the alphabet Hall s theorem allows us to check that we may build the suffix of the answer much easier Each time we try to place some character we need to iterate on all possible subsets of characters we still need to place and check that the number of positions that are suitable for at least one character in a subset is not less than the size of subset just like in regular Hall s theorem The key fact here is that if we have for example characters yet to place then we don t need to check any subset containing exactly or characters since the number of suitable positions for this subset won t become larger if we add all remaining characters to a subset So the subsets we have to consider are limited by the masks of possible characters and there will be only of them 
We call an array if we can erase not more than one element from it so that the array becomes strictly increasing that is every element is striclty greater than every element before it You are given an array consisting of elements You are allowed to replace any element with any integer number and you may do so any number of times you need What is the minimum number of replacements you have to perform in order to make the array ,If the problem was to make the array strictly increasing then we could use the following approach for every element subtract its index from it find the longest non decreasing subsequence and change every element not belonging to this sequence In this problem we can use a similar technique Let s iterate on the element we will remove after changing everything we need let s call it For every we will subtract from and for every we will subtract from Let s maintain the longest non decreasing subsequence ending in every element on prefix and the longest non decreasing subsequence starting in every element on suffix this can be done by a lot of different techniques for example two segment trees and rollbacking which is used in our model solution Then we need to somehow merge these sequences The easiest way to do it is to consider only the subsequence ending in element since if we will need to consider the subsequence ending in some index less than we would check this possibility choosing other value of and use some data structure BIT segment tree or something similar to find the longest subsequence that can be appended to the one we fixed After checking if we need to delete element we add it to the data structure on prefix remove element from the data structure on suffix check if we have to remove element and so on Model solution https pastebin com BiaFgYx6
Let s call a fraction good if there exists at least one another fraction such that the digit denoting is contained in the decimal representation of and the digit denoting is contained in the decimal representation of For example is a good fraction because You are given an integer number Please calculate the number of good fractions such that and The answer may be really large so print it modulo ,Let s fix an fraction such that Obviously each good fraction is equal to exactly one of such irreducible fractions So if we iterate on and check that and find the number of good fractions that are equal to we will solve the problem Okay suppose we fixed and Any good fraction can be represented as where is some positive integer Let s try all possible values of and for them check whether they correspond to a good fraction How do we try all values of without iterating on them Let s construct the decimal representation of from the least significant digit to the most As soon as we fix least significant digits of we know least significant digits of and So let s try to use digit DP to try all possible values of Which states do we have to consider Of course we need to know the number of digits we already placed so that will be the first state After we placed digits we know first digits of the numerator of the fraction but to get the value of digit knowing only the value of the corresponding digit in is not enough there could be some value carried over after multiplying already placed digits by For example if and we placed the first digit of and it is we know that the first least significant digit of is and we know that after fixing the second digit of we should add to it to get the value of this digit in since is carried over from the first digit So the second state of DP should represent the number that is carried over from the previous digit in the numerator and the third state should do the same for the denominator Okay in order to know whether the fraction is good we have to keep track of some digits in the numerator and denominator If and then we have to keep track of the digit representing in the numerator and the digit representing in the denominator So we have two additional states that represent the masks of interesting digits we met in the numerator and in the denominator The only thing that s left to check is that both and are not greater than Let s construct the decimal representation of and prepend it with some leading zeroes and keep constructing the numerator and the denominator until they have the same number of digits as the decimal representation as Then we can compare the representation of for example numerator with the representation of as strings Comparing can be done with the following technique let s keep a flag denoting whether the number represented by the least significant digits of the numerator is less or equal than the number represented by the same digits from When we place another digit of the numerator we can get the new value of this flag as follows if new digit of the numerator is not equal to the corresponding digit of then the value of the flag is defined by comparing this pair of digits otherwise the value of the flag is the same as it was without this new digit Of course we should do the same for the denominator Okay now we can actually start coding this DP is the number of possible ways to put least significant digits in in such a way that the value carried over to the next digit of the numerator is and for the denominator denotes whether the current numerator is less or equal to the number represented by least significant digits of does the same for the denominator denotes which interesting digits we already met in the numerator of course does the same for the denominator If you are feeling confident in your programming abilities you can just start implementing this DP on a seven dimensional array I was too afraid to do it but looking at participants solutions I realize that it sounds much more scary than it looks in the code so I decided to write the model solution using a structure representing each state and a map to store all these structures This is a common technique when a dynamic programming solution you come up with has some really complex states and transitions it is sometimes better to use some self implemented structures to define these states and store them in a map or a hashmap Some advantages of this technique are it s sometimes much easier to code the code may be longer than the same solution with regular DP stored in a multi dimensional array but it s easier to write and understand this code if most states are unreachable they won t even appear in our map so we skip them altogether it is easy to add some optimizations related to reducing the number of states For example the number of different values for and may be too much so we can use the following optimization as soon as we find some pair of numbers in and that can represent and we can change these masks to some values that will mark that they are finished and stop updating them at all 
Berland has a long and glorious history To increase awareness about it among younger citizens King of Berland decided to compose an anthem Though there are lots and lots of victories in history of Berland there is the one that stand out the most King wants to mention it in the anthem as many times as possible He has already composed major part of the anthem and now just needs to fill in some letters King asked you to help him with this work The anthem is the string of no more than small Latin letters and question marks The most glorious victory is the string of no more than small Latin letters You should replace all the question marks with small Latin letters in such a way that the number of occurrences of string in string is maximal Note that the occurrences of string in can overlap Check the third example for clarification ,Let s denote the string obtained by concatenation where is some dividing character that isn t a part of the alphabet as Recall that KMP algorithm builds the prefix function for this string We can calculate on this string where is the position in this string and is the value of prefix function in this position The value of is the maximum number of occurences of found so far or if this situation is impossible If th character is a Latin letter then we just recalculate prefix function for this position the fact that in KMP the value of prefix function won t exceed allows us to do so If th character is a question mark then we check all possible characters and recalculate prefix function for all of these characters and update the corresponding values The size of and is pretty big so we need to recalculate these values in time this can be done by precalculating the values of is the value of prefix function is a new character and is the value of prefix function after adding this character 
Let s define the sequence of Fibonacci strings as follows is is is for denotes the concatenation of two strings So for example is is is For a given string let s define as the number of ways to cut it into several any number possibly even just one strings such that none of these strings are Fibonacci strings For example if is since there are three ways to cut it You are given a sequence of strings Calculate Since these values can be huge print them modulo ,The first idea that comes to mind is running some sort of dynamic programming the number of ways to cut the string consisting of the first characters When we calculate we need to take the sum of the previous values of and then subtract for every such that the string from the th character inclusive to the th character non inclusive is a Fibonacci string Unfortunately there are two main issues with this solution firstly we cannot store the array in memory and secondly we have to search for the Fibonacci strings ending in a certain index quickly something like Aho Corasick could work with a less strict memory limit but right now we cannot use it We will try to resolve both of these issues with the following approach while we process the characters we will maintain the list of tuples such that the string from the th character to the current one is a prefix of some Fibonacci string How do we maintain them Every Fibonacci string except for is a prefix of So all Fibonacci strings we are interested in except for again are prefixes of the same long Fibonacci string Suppose a tuple represents some index such that the string from the th character to the current one is a prefix of that long Fibonacci string Each time we append a character we filter this list of tuples by trying to check if this new character matches the next character in the prefix if it does not the tuple is discarded For the tuples that represent the prefixes equal to Fibonacci strings we need to subtract the value of from the new value we are trying to calculate checking if a prefix is a Fibonacci string is easy we just need to check its length How do we check that if we add a character or it is still a prefix There are two ways to do this either generate the first characters of the long Fibonacci string or represent the current prefix as the sum of Fibonacci strings such that for every the condition holds i e the Fibonacci strings we split the current prefix into are arranged in descending order and there is no pair of equal or adjacent by index Fibonacci strings in the split This representation is very similar to writing an integer in Zeckendorf system The next character in the prefix depends on whether belongs to this split if it belongs it is the last string in the split so we need to append to transform into otherwise we need to append Okay so now we can solve the problem in time where is the total length of the strings in the input and is the size of the list of tuples we discussed earlier This actually works since it looks like the size of the list of tuples is bounded as Unfortunately we don t have a strict mathematical proof of this we checked this by brute force with up to so it definitely works under the constraints of the problem 
Since next season are coming you d like to form a team from two or three participants There are candidates the th candidate has rank But you have weird requirements for your teammates if you have rank and have chosen the th and th candidate then and must be met You are very experienced so you can change your rank to any non negative integer but and are tied with your birthdate so they are fixed Now you want to know how many are there pairs such that there exists an integer meeting the following constraints and It s possible that and you form a team of two is the greatest common divisor of two number the least common multiple ,At first must be met since and Now let and From now on let s consider only such that Now let s look at must be met Let Since if then must have to the power of in its factorization otherwise power of can be any non negative integer It leads us to the bitmask of restrictions with size equal to the number of different prime divisors of In the same way let s process Of course and if then must have to the power of in its factorization This is another restriction bitmask So for any pair there exists if and only if Since we look only at where then can t have power of equal to and at the same time For any other it is enough to have power of in equal to the power of in even if it s equal to So for each we need to know the number of such that is a submask of So we just need to calculate sum of submasks for each mask it can be done with or Finally how to factorize number up to Of course Pollard algorithm helps but there is another way which works sometimes Let s factorize with primes up to So after that if there is only three cases or is easy to check helps Otherwise just check with all and if you have found and then and you have found Otherwise you can assume that because this probable mistake doesn t break anything in this task Result complexity is where is the number of prime divisors of 
Consider a following game between two players There is an array consisting of positive integers Initially a chip is placed into the first cell of the array and is decreased by Players move in turns Each turn the current player has to do the following if the index of the cell where the chip is currently placed is then he or she has to choose an index such that move the chip to the cell and decrease by If it s impossible to make a valid move the current player loses the game Your task is the following you are given an array consisting of positive integers and queries to it There are two types of queries for every increase by tell who is the winner of the game that is played on the subarray of from index to index inclusive Assume both players choose an optimal strategy ,Suppose there is only one query i e we are given some array and we want to know who is the winner if the game is played on this array One of the obvious solutions is will the current player win if the chip is currently in the cell and the number in cell is We can already see that we don t need to know the exact value of we only want to know whether it s odd if there is a cell such that we can go from to and is a state where current player will lose then we should go to this cell since our opponent will enter a losing state of the game Otherwise we want to force our opponent to move out of cell and we can do so only if is odd So we found a dynamic programming solution with states but what is more important is that we can take all the elements in our array modulo Okay now let s solve the problem when there are only queries of type no modifications Since when calculating the values we are interested only in next cells and there are only variants of whether these cells are winning or losing we may consider each element of the array as a function that maps a mask of next states into a new mask of states if we pushed our new element into the front For example if the th element is even and states are winning losing losing winning and losing respectively and then we may consider a mask of next states as and then we can check if th state is winning and push a bit to the front of this mask discarding the last bit since new state is winning we will get a mask of It allows us to denote two functions and what will be the resulting mask of next states if current mask is and we push an even or odd element to the front Okay what about pushing more than one element We can just take the composition of their functions Since a function can be stored as an array of integers and the composition needs only time to be calculated then we can build a segment tree over the elements of the array and store a composition of all functions on the segment in each node This allows us to answer queries of type in The only thing that s left is additions on segment Adding an even number is easy just ignore this query To be able an odd number let s store another function in each node of the segment tree which would be the composition of all functions on the segment if we would add to all elements on the segment so the elements which were odd become even and vice versa This allows us to use lazy propagation if the query affects the whole node we may just swap two functions in it and push the query to the children of this node Overall complexity is It turns out we didn t think about it before the contest but some contestants submitted such solutions that it can be reduced to if we will use the distance to closest losing state instead of a mask of winning and losing states 
You are given a set of strings Each string consists of lowercase Latin letters For each string in this set you want to calculate the minimum number of seconds required to type this string To type a string you have to start with an empty string and transform it into the string you want to type using the following actions if the current string is choose some lowercase Latin letter and append it to the back of so the current string becomes This action takes second use autocompletion When you try to autocomplete the current string a list of all strings such that is a prefix of is shown to you and the strings are ordered lexicographically You can transform into the th string from this list in seconds Note that you may choose any string from this list you want it is not necessarily the string you are trying to type What is the minimum number of seconds that you have to spend to type each string from ,First of all the information given in the input is the structure of a trie built on and some other strings so we can store this information in the same way as we store a trie Okay now let s calculate the number of seconds required to type each string with dynamic programming let be the number of seconds required to arrive to the th vertex of the trie For regular vertices where is the parent of vertex for vertices corresponding to strings from values should be updated with the time required to autocomplete some of the parents to the current vertex To do these updates let s calculate the answers for all strings in lexicographical order We will run DFS on the trie and maintain a segment tree on the path from the root to the current vertex In the segment tree we will store the values of where is the number of seconds required to autocomplete from to the current vertex Obviously if we are currently in a vertex representing a word from then we have to find the minimum in this segment tree and that will be the cost to get to current vertex using autocompletion How to maintain Recall that we are running DFS on trie in lexicographical order When we want to compute the answer for the first string the value of for all vertices is since our string will be the first in all autocompletion lists And here s a trick to maintain these values for other strings whenever we compute the answer for some string add on the whole tree For vertices that are ancestors of both current string and some next string this will stay and increase the cost to autocomplete the next string accordingly but for vertices which are not on the path to some next string the values of will be already deleted from the segment tree and replaced by new values so this addition does not affect them Overall this works in but it can be written in with a vector instead of a segment tree since all additions and minimum queries affect the whole structure 
Today you are going to lead a group of elven archers to defend the castle that is attacked by an army of angry orcs Three sides of the castle are protected by impassable mountains and the remaining side is occupied by a long wall that is split into sections At this moment there are exactly archers located at the th section of this wall You know that archer who stands at section can shoot orcs that attack section located at distance not exceeding that is all such sections that In particular means that archers are only capable of shooting at orcs who attack section Denote as of section the total number of archers who can shoot at the orcs attacking this section of the defense plan is the minimum value of defense level of individual wall section There is a little time left till the attack so you can t redistribute archers that are already located at the wall However there is a reserve of archers that you can distribute among wall sections in arbitrary way You would like to achieve maximum possible reliability of the defence plan ,Firstly if we may obtain reliability at least then we may obtain reliability not less than with the same number of archers So we may use binary search and check whether we may obtain reliability at least How can we check it Let s find the leftmost section such that its defense level is less than Let its index be We obviously have to add some archers controlling this section and since every section to the left of it is already controlled the best option where to add archers is the section with index After we added enough archers we move to next section such that its defense level is less than and do the same If we run out of archers without protecting all the sections then it s impossible to obtain reliability To do checking in we may use prefix sums or sliding window technique 
Alice and Bob have a rectangular board consisting of rows and columns Alice and Bob play the following game They choose two integers and such that and cut the board in such a way that only the part of it between column and column inclusive remains So all columns to the left of column and all columns to the right of column no longer belong to the board After cutting the board they move chips on the remaining part of the board the part from column to column They make alternating moves and the player which cannot make a move loses the game The first move is made by Alice the second by Bob the third by Alice and so on During their move the player must choose one of the chips from the board and move it any positive number of cells to the left so if the chip was in column it can move to any column and the chips in the leftmost column cannot be chosen Alice and Bob have pairs of numbers and For each such pair they want to determine who will be the winner of the game if and Note that these games should be considered independently they don t affect the state of the board for the next games and both Alice and Bob play optimally ,The model solution is where but it seems that there are faster ones I ll explain the model solution nevertheless It s easy to see using simple Nim theory that the answer for a query is iff the xor of for all chips such that is equal to Let s calculate this xor for every query This number contains at most bits and we will process these bits differently we will choose some number and use one solution to calculate lowest bits and another solution to compute highest bits One idea is common in both solutions we split each query into two queries a query can be represented as a combination of two queries and where is the xor of all numbers such that After converting the queries for every store each query of the form in some sort of vector or any other data structure We will use an approach similar to sweep line iterate on and solve the queries for the current These ideas will be used both for the solution calculating lowest bits and for the solution calculating highest bits How to find lowest bits in each query Iterate on from to and maintain the number of occurrences of each number we met so far Then at a moment we want to calculate simply iterate on all of the values of and process each value in if the number of occurrences of some value is odd update the current answer to the query by xoring the number with otherwise just skip it And since we are interested only in lowest bits for each we need only the remainder so the number of different values is Thus this part of the solution runs in Okay what about highest bits in each query We can see that for every number the highest bits of don t change too often when we iterate on there will be about segments where the highest bits of have different values We can build a data structure that allows use to process two queries xor all numbers on a segment with some value and get the value in some position Fenwick trees and segment trees can do it Then we again iterate on from to When we want to process a number we find the segments where the highest bits of have the same value and perform updates on these segments in our data structure When we process a query of the form we simply get the value in the position from our data structure This part of the solution works in By choosing optimally we can combine these two parts into a solution with complexity of 
You are creating a level for a video game The level consists of rooms placed in a circle The rooms are numbered through Each room contains exactly one exit completing the th room allows you to go the th room and completing the th room allows you to go the st room You are given the description of the multiset of chests the th chest has treasure value Each chest can be of one of two types regular chest when a player enters a room with this chest he grabs the treasure and proceeds to the next room mimic chest when a player enters a room with this chest the chest eats him alive and he loses The player starts in a random room with each room having an equal probability of being chosen The players earnings is equal to the total value of treasure chests he d collected before he lost You are allowed to choose the order the chests go into the rooms For each from to place the chests into the rooms in such a way that each room contains one chest chests are mimics the expected value of players earnings is possible Please note that for each the placement is chosen independently It can be shown that it is in the form of where and are non negative integers and Report the values of ,At first let s say that the expected value is equal to the average of total earnings over all positions and is equal to the sum of earnings over all positions divided by So we can trasition to minimizing the sum Let s learn how to solve the task for some fixed Fix some arrangement and rotate the rooms so that the last room contains a mimic So now you have regular chests then a single mimic regular chests single mimic regular chests single mimic All and Take a look at some of these intervals of length The last chest in the interval is taken from starting positions the second to last is taken times and so on Now let s find the optimal way to choose Fix some values of Take a look at the smallest of these values and the largest of them Let the values be and If they differ by at least then the smaller result can always be achieved by moving a regular chest from the larger one to the smaller one ProofConsider two sequences of coefficients for both intervals and However if you remove one chest then they will be equal to and If you only consider the difference between the numbers of both sequences then you can see that only coefficient got removed and coefficient was added So you can rearrange the chests in such a way that all chests are assigned to the same value and only the chest that was assigned to becomes assigned to thus decreasing the total value Now we have all set now The only thing left is to assign chests optimally Write down the union of all the coefficient sequences from all the intervals and sort them in the non decreasing order It s easy to show that the chests should be sorted in the non increasing order really classical thing you can try proving that by showing that any other arrangement can easily be improved once again That allows us to write a solution in Sort all the chests in the beginning after that for some multiply the value of the th chest by and sum up the results Finally let s speed this up with prefix sums Notice that the first values are multiplied by the second values by and so on If is not divisible by then the last block just has length smaller than Thus we can calculate the answer for some in And that s equal to Overall complexity 
Let s denote the function that takes a string consisting of lowercase Latin letters and dots and returns a string consisting of lowercase Latin letters as follows let be an empty string process the characters of from left to right For each character do the following if is a lowercase Latin letter append at the end of the string otherwise delete the last character from if is empty before deleting the last character the function crashes return as the result of the function You are given two strings and You have to delete the minimum possible number of characters from so that and the function does not crash Note that you aren t allowed to insert new characters into or reorder the existing ones ,The core idea of the solution is the following dynamic programming is the minimum number of characters we have to delete if we considered a subsequence of first characters of and it maps to first characters of There are three obvious transitions in this dynamic programming we can go from to by skipping if we can go from to if is a dot we can go from to Unfortunately these transitions cannot fully handle the case when we want to put some character and then delete it these transitions don t allow us to do it for any character only for some specific ones in specific situations To handle it suppose we want to take the character and then delete it and we model it as follows there exists the fourth transition from to without deleting anything where is the length of the shortest substring of starting from that becomes empty if we apply the function to it This substring can be described as a regular bracket sequence where opening brackets correspond to letters and closing brackets to dots We can precalculate this substring for each in Why is this transition enough Suppose we don t want to take some letter from this shortest substring in the optimal answer since it is the shortest substring meeting these constraints the number of letters on each prefix of it excluding the substring itself is greater than the number of dots so we can instead skip the first letter and try applying this transition from so this case is handled And skipping any dots from this shortest substring is also suboptimal since we have to get rid of the character 
Let s call an array of size iff where is the greatest common divisor of the arguments You are given two numbers and For each you have to determine the number of arrays of size such that for every Since the answers can be very large you have to calculate them modulo ,For a fixed upper bound this is a well known problem that can be solved using inclusion exclusion Let s denote by the number of arrays with elements in range such that is divisible by Obviously With the help of inclusion exclusion formula we can prove that the number of arrays with is the sum of the following values over all possible sets where is some set of prime numbers possibly an empty set and is the product of all elements in the set in this formula denotes the number of arrays such that their is divisible by every number from set However the number of such sets is infinite so we need to use the fact that if With the help of this fact we can rewrite the sum over every set in such a way where is if there is no any set of prime numbers such that if this set exists and the sign is determined by the size of if is even otherwise An easier way to denote and calculate is the following by the way it is called M bius function if there is some prime number p such that Otherwise where is the number of primes in the factorization of Okay so we found a solution for one upper bound it s How can we calculate it for every from to Suppose we have calculated all values of for some and we want to recalculate them for The important fact is that these values change and thus need recalculation only for the numbers such that So if we recalculate only these values and each recalculation can be done in time if we precompute the for every then we will have to do only recalculations overall 
For the simplicity let s say that the Death Note is a notebook that kills a person when their name is written in it It s easy to kill with it but it s pretty hard to keep track of people you haven t killed and still plan to You decided to make a Death Database Management System a computer program that provides the easy access to the database of possible victims Let me describe its specifications to you Let s define a victim entity a victim has a name not necessarily unique that consists only of lowercase Latin letters and an integer suspicion value At the start of the program the user enters a list of victim names into a database each suspicion value is set to Then the user makes queries of two types set the suspicion value of the th victim to given a string find the maximum suspicion value of a victim whose name is a contiguous substring of Just to remind you this program doesn t kill people it only helps to search for the names to write down in an actual notebook Thus the list of the victims in the database doesn t change throughout the queries What are you waiting for Write that program now ,I m feeling extremely amused by the power of Aho Corasick lately so I will describe two solutions of this problem with it Feel free to point out how cool you are solving the task with hashes or some suffix structure but Aho solutions will still be cooler I also want to mention I m quite proud of the name I came up with for that task First let s assume that the words in the dictionary are unique Build an Aho Corasick automaton on the dictionary Then build the tree of its suffix links For the first solution you can use the fact that there are not a lot of words in the dictionary that can end in each position To be exact at most one word per unique word length Thus that s bounded by the square root of the total length For that reason you can iterate over all the words that end in all positions of the queries in How to do that fast For each vertex of the automaton precalculate the closest vertex up the suffix link tree that s a terminal Feed the query word into the automaton and from each vertex you stay at just jump up the tree until you reach the root Take the maximum value over all the visited terminals The second solution actually involves an extra data structure on top of that No it s not HLD You are boring for using it Let s abuse the fact that you are allowed to solve the problem fully offline For each word you can save the list of pairs time value of the times the value of the word changed For each vertex of the automaton you can save all the times that vertex has been queried from Now traverse the tree with dfs When you enter the vertex you want to apply all the updates that are saved for the words that are terminals here What are the updates From the list we obtained for a word you can generate such triples that this word had value from query to query Don t forget the value from to the first update to this word Then ask all the queries Then go to children When you exit the vertex you want all the updates to be gone Well there is a trick for these kinds of operations it s called rollbacks Maintain a segment tree over the query times the th leaf should store the maximum value during the th query The update operation updates the range with the new possible maximum How to avoid using lazy propagation with such updates Well on point query you can collect all the values from the segtree nodes you visit on your way down That way you don t have to push the updates all the way to the leaves Not that it matters that much but the number of values to be saved for future rollbacks is decreased dramatically That solution works in 
You are given an undirected connected graph consisting of vertices and edges vertices of this graph are special You have to direct each edge of this graph or leave it undirected If you leave the th edge undirected you pay coins and if you direct it you don t have to pay for it Let s call a vertex if it is reachable from each special vertex along the edges of the graph if an edge is undirected it can be traversed in both directions After you direct the edges of the graph possibly leaving some of them undirected you receive coins for each saturated vertex Thus your total profit can be calculated as where is the set of saturated vertices and is the set of edges you leave undirected For each vertex calculate the maximum possible profit you can get if you have to make the vertex saturated ,Suppose we want to calculate the maximum profit for some vertex in Let s try to find out how it can be done and then optimize this process so we don t have to run it times First of all we have to find the bridges and biconnected components in our graph Why do we need them Edges in each biconnected component can be directed in such a way that it becomes a strongly connected component so we don t have to leave these edges undirected it is never optimal Furthermore for each such component either all vertices are saturated or no vertex is saturated Let s build a tree where each vertex represents a biconnected component of the original graph and each edge represents a bridge We can solve the problem for this tree and then the answer for some vertex of the original graph is equal to the answer for the biconnected component this vertex belongs to Okay now we have a problem on tree Let s implement the following dynamic programming solution root the tree at the vertex we want to find the answer for and for each vertex calculate the value of the maximum profit we can get for the subtree of vertex if it should be reachable by all special vertices from its subtree Let s analyze how we can calculate these values Suppose we have a vertex with children we have already calculated the values for the children and we want to calculate First of all since the vertex is going to be saturated we will get the profit from it so we initialize with Then we should decide whether we want to get the profit from the children of vertex Suppose the edge leading from to has weight If we want to take the profit from the subtree of we usually have to make this edge undirected so both vertices are saturated thus we get as profit or we could leave this edge directed from to so the vertex is saturated and is not and get as the profit But sometimes we can gain the profit from the vertex and its subtree without leaving the edge undirected if all special vertices belong to the subtree of we can just direct this edge from to and there is no reason to choose the opposite direction or leave the edge undirected Similarly if all special vertices are outside of this subtree there s no reason to direct the edge from to So if one of this conditions is met we can get the full profit from the subtree of without leaving the edge undirected Okay let s summarize it We can calculate as where is either if one of the aforementioned conditions is met we don t have to leave the edge undirected if we want to saturate both vertices or otherwise Now we have an solution Let s optimize it to Root the tree at vertex and calculate the dynamic programming as if is the root Then we shall use technique to recalculate the dynamic programming for all other vertices we will try each vertex as the root of the tree and is the answer for the vertex if it is the root The rerooting technique works as follows let s run DFS from the initial root of the tree and when we traverse an edge by starting or finishing a recursive call of DFS we move the root along the edge so if we call is the current root if it has some child we move the root to the same moment when we call and when the call of ends the root moves back to Okay the only thing that s left is to describe how we move the root If the current root is and we want to move it to a vertex adjacent to then we have to change only the values of and first of all since is no longer a child of we have to subtract the value that was added to while we considered vertex then we have to make the child of vertex so we add the profit we can get from the vertex to It can be done in so our solution runs in though with a very heavy constant factor 
Suppose you are given a sequence of pairs of integers You can perform the following operations on it Choose some position and by That can be performed only if there exists at least one such position that and The cost of this operation is Choose some position and by That can be performed only if there exists at least one such position that The cost of this operation is Each operation can be performed arbitrary number of times possibly zero Let be minimum possible such that there exists a sequence of operations with total cost after which all from are pairwise distinct You are given a sequence consisting of pairs of integers All are pairwise distinct Let be the sequence consisting of the first pairs of Your task is to calculate the values of ,Let s firstly try to come up with some naive solution Suppose we have a list and want to calculate for it Let s sort this list comparing the pairs by their values of and then process them one by one We will divide this list into some parts we will call them with the following process when processing the first pair in the sorted order let s iterate on the next pairs also in the sorted order and add them to the first pair s component until the following condition is met where is the index of the first pair we added and is the index of the pair we are currently trying to add to s component remember that we consider all these pairs in the sorted order What is the meaning of this condition means that the number of pairs between and including these two is not less that the number of integers in and while this condition is met we can use the first operation in order to make a pair having for every And the first time when the condition is met we obviously cannot expand the segment in such a way It means that the value of will always be greater than value of and won t belong to the same component with and will start creating its own component instead These components we form have one special property Suppose we expanded the component so that there are no two equal values of in it Then we may reorder the pairs in this component as we wish to do so we may contract the component using the second operation and then expand it again Of course the best course of action is to sort the pairs in the component by their values of in descending order After doing this for every component we will obtain an optimal configuration such that all values of are distinct and it s easy to calculate the answer Okay now we need to do it fast The following will help us DSU Some implicit logarithmic data structure the operations we need are count the sum of elements less than and count the number of elements greater than your implementation might use other operations Small to large merging DSU will help us maintain the components A data structre will be built for each component containing the values of in it it will help us to maintain the sum of where is the optimal index of in this component Depending on your implementation you may or may not need to store the minimum value of in the component When inserting some element having into some component the elements having don t change their position the new element will be added right after them and the remaining elements will be shifted to the right so the sum of can be maintained if we query the number of elements greater than and the sum of elements less than Okay but we still don t know how we create the components and how we determine if two components are to merge We will keep these components in expanded form that is when processing a pair let s find the leftmost unoccupied position after or if it is not occupied and occupy it with the new pair creating a new component for it If the newly occupied index is let s try to merge new component with components occupying and if there are any to merge two components do the required operations in DSU and unite the data structures built in these components with small to large method All this works in the most time consuming part is merging the data structures 
You are given an integer represented as a product of its divisors Let be the set of positive integer divisors of including and itself We call a set of integers if and only if there is no pair such that and divides Find a subset of with maximum possible size Since the answer can be large print the size of the subset modulo ,The problem consists of two parts what do we want to calculate and how to calculate it What do we want to calculate There are several ways to figure it out At first you could have met this problem before and all you need is to remember a solution At second you can come up with the solution in a purely theoretical way Hasse diagram can help with it greatly Let s define as the number of primes in prime factorization of For example and If you look at Hasse diagram of you can see that all divisors with lies on level If is divisible by then so all divisors on the same level don t divide each other Moreover the diagram somehow symmetrical about its middle level and sizes of levels are increasing while moving to the middle It gives us an idea that the answer is the size of the middle level i e the number of divisors with The final way is just to brute force the answers for small s and find the sequence in OEIS with name A096825 where the needed formulas are described The second step is to calculate the number of divisors with Suppose we have distinct primes and the number of occurences of is equal to Then we need to calculate pretty standard knapsack problem where you need to calculate number of ways to choose subset of size where you can take each up to times Or formally number of vectors with and Calculating the answer using will lead to time limit so we need to make the following transformation Let s build for each a polynomial Now the answer is just a coefficient before in product Note that the product has degree so we can multiply polynomials efficiently with integer FFT in the special order to acquire time complexity There several ways to choose the order of multiplications At first you can at each step choose two polynomials with the lowest degree and multiply them At second you can use the divide and conquer technique by dividing the current segment in two with pretty same total degrees At third you can also use D n C but divide the segment at halves and it seems still to be in total What about the proof of the solution Thanks to tyrion for the link at the article https pure tue nl ws files 4373475 597494 pdf The result complexity is time and space if carefully written Note that the hidden constant in integer FFT is pretty high and highly depends on the implementation so it s possible for poor implementations not to pass the time limit 
You are given a special undirected graph It consists of vertices numbered from to The following properties hold for the graph there are exactly edges in the graph edges connect vertices having odd numbers with vertices having even numbers edges connect vertices having odd numbers with each other and edges connect vertices having even numbers with each other for each edge between a pair of vertices with odd numbers there exists an edge and vice versa for each odd number there exists an edge the graph is connected moreover if we delete all vertices with even numbers from it and all edges incident to them the graph will become a tree the same applies to deleting odd vertices So the graph can be represented as two trees having the same structure and edges connecting each vertex of the first tree to the corresponding vertex of the second tree Edges of the graph are weighted The length of some simple path in the graph is the sum of weights of traversed edges You are given queries to this graph in each query you are asked to compute the length of the shortest path between some pair of vertices in this graph Can you answer all of the queries ,Suppose we want to minimize the number of traversed edges of the second type edges that connect odd vertices to each other or even vertices to each other and minimizing the length of the path has lower priority Then we exactly know the number of edges of the second type we will use to get from one vertex to another and when building a path we each time either jump from one tree to another using an edge of the first type or use the only edge of the second type that brings us closer to the vertex we want to reach So in this case problem can be solved either by binary lifting or by centroid decomposition The model solution uses the latter merge the graph into one tree vertices and of the original graph merge into vertex in the tree build its centroid decomposition and for each centroid and vertex of its centroid subtree calculate the length of the shortest path from and to and using dynamic programming Then the answer for each pair of vertices and may be calculated as follows find the deepest centroid controlling the both vertices and try either shortest path or shortest path But this solution won t work in the original problem because sometimes we want to choose an edge of the second type that leads us further from the vertex we want to reach in the merged tree but allows us to use a cheaper edge of the first type to jump from one tree to another Let s make this situation impossible We may change the weights of all edges of the second type so that the weight of edge between and becomes the length of the shortest path between and This can be done by solving a SSSP problem build a graph of vertices where each vertex from to represents the path between from and Add a directed edge with weight equal to going from vertex to vertex And finally for every pair such that and are connected by edge of weight and and are connected by edge of weight add an undirected edge connecting and in the new graph its weight should be Then the distance from to in this graph will be equal to the length of the shortest path from to in the original graph 
Let s denote yet again the sequence of Fibonacci strings where the plus sign denotes the concatenation of two strings Let s denote the sequence of suffixes of string as For example is and is the following sequence Elements in this sequence are numbered from Your task is to print first characters of th element of If there are less than characters in this suffix then output the whole suffix ,Suppose we added all the suffixes of into a trie Then we can find th suffix by descending the trie checking the sizes of subtrees to choose where to go on each iteration The model solution actually does that but computes the sizes of subtrees without building the whole trie Recall that if we insert all suffixes of a string into the trie then the size of subtree of some vertex is equal to the number of occurences of the string denoted by this vertex in the original string Since in our problem the strings are recurrent we may use prefix automaton to count the number of occurences To calculate the number of occurences of string in let s build prefix function for and an automaton which tells the value of prefix function if the previous value was and we appended to the string the same approach is used in KMP substring search algorithm Then let s build another automaton that will help us work with Fibonacci string what will be the value of prefix function if we append to the string For and this automaton can be easily built using and and for we may build using the automatons for and We also have to keep track of the number of occurences that can be done with another automaton on fibonacci strings There is a corner case when we need to stop descending the trie to handle it we need to check whether some string is a suffix of but that can be easily made by checking if Each step in trie forces us to do up to three depending on your implementation queries like count the number of occurences of some string in so overall the solution works in 
There are gift boxes in a row numbered from to from left to right It s known that exactly of them contain valuable gifts other boxes contain just lucky stones All boxes look the same and differ only in weight All than boxes with valuable items But valuable gifts may be different so the boxes with valuable items may have different weights You can ask no more than queries printing an answer doesn t count By each query you can compare total weights of two non intersecting subsets of boxes and In return you ll get one of four results if subset is strictly if subset is strictly if subsets have equal total weights if the query is incorrect or the limit of queries is exceeded Using such queries or maybe intuition find the box with a valuable gift with ,The solution consists of several steps Let s find out does the first box contain stone or valuable gift using random Let s make queries to compare the weight of the first box with the weight of another random box If the first box is lighter than we found an answer otherwise the probability of the first box having stones is at least Let s compare the weights of the first box and the second one If they are equal then let s compare the weights of boxes and If they are equal then let s compare the boxes and and so on In other words let s find the minimum such that contains only boxes with stones but contain at least one box with a valuable gift It s easy to see that we d spend no more than queries We have segment with only stones and with at least one gift Let s just binary search the leftmost gift in the segment using boxes from as reference if we need to know does segment of boxes have at least one gift let s just compare it with segment which have only stones if is lighter then it has otherwise doesn t have This part also requires no more than queries 
Polycarp is editing a complicated computer program First variable is declared and assigned to Then there are instructions of two types assign a value or spend burles to remove that instruction thus not reassign block execute instructions inside the block if the value of is and ignore the block otherwise blocks can contain instructions and other blocks inside them However when the value of gets assigned to the computer breaks and immediately catches fire Polycarp wants to prevent that from happening and spend as few burles as possible What is the minimum amount of burles he can spend on removing instructions to never assign to ,Consider the following dynamic programming the minimum cost to make have value after the th line The transitions here are pretty easy on set you just consider two options of skipping or not skipping the instructions and on if you either go to the next line or to the end of the block depending on the value There are a lot of possible values so that dp works in First let s notice that all the values that don t appear in the input won t matter so you can keep only the existing values in the dp Next let s consider the following modification to it What happens when you enter an if block It s actually the same dp but the only starting value is not with cost as in the beginning of the whole program but some value with some cost So let s calculate this dp separately from the outer one and just merge the values together Notice that if some value doesn t appear inside the if block then its cost can not decrease exiting out of it Thus it s enough to calculate the inner dp only for values that appear inside the if block Okay the transitions for if became easier The set transitions are still slow though Examine the nature of them All the values besides the written on the set instruction increase their cost by As for the its cost becomes equal to the cost of the cheapest value before the instruction Thus let s maintain the dp in some data structure that allows to add the same integer to all elements and take the minimum of its elements That can be done with a set and a single integer that stores the current shift that should be applied to all elements Surely you ll also need a map to retrieve the current cost of particular values The final part is fast merging of the if block dp and the outer one It might not appear obvious but if you do that in a straightforward manner of adding all the costs from if one by one it can become in total So we can apply small to large and swap these dp s based on their sizes Overall complexity 
Alice is a composer and recently she had recorded two tracks that became very popular Now she has got a lot of fans who are waiting for new tracks This time Alice wants to form four melodies for her tracks Alice has a sheet with notes written on it She wants to take four such non empty non intersecting subsequences that all of them form a and sum of their lengths is maximal Subsequence forms a melody when each two adjacent notes either differ by or are congruent modulo You should write a program which will calculate maximum sum of lengths of such four non empty non intersecting subsequences that all of them form a melody ,Let s build a directed graph where vertices represent notes and a directed edge comes from vertex to vertex iff and and can be consecutive notes in a melody Now we have to find four longest vertex disjoint paths in this graph This problem can be solved with mincost flow algorithms We build a network where each vertex of the graph is split into two let s denote the vertices that we obtain when we are splitting some vertex as and Then each directed edge transforms into a directed edge from vertex to vertex in the network the capacity of this edge is and the cost is Also we add directed edges from the source to every vertex and from every vertex to the sink they have the same characteristics capacity is cost is And for each we add a directed edge between and these edges actually represent that we are using some note in a melody so their capacities are also equal to and their costs are The answer to the problem is equal to the absolute value of minimum cost of flow in this network The bad thing is that the network is really large So we have to use some advanced mincost algorithm here Model solution uses Dijkstra s algorithm with Johnson s potentials to find augmenting paths of minimum cost We set a number for each vertex of the network these numbers are called potentials Then we modify costs of the edges if some edge had cost now it s cost is It s easy to prove that if some path from vertex to vertex was the shortest one between these vertices without modifying the costs with potentinals then after modifying it will also be the shortest between these vertices So instead of looking for an augmenting path in the original network we can try looking for it in a network with modified edges Why Because it is always possible to set all potentials in such a way that all costs of edges will be non negative and we will be able to use Dijkstra to find the shortest path from the source to the sink Before looking for the first augmenting path we calculate potentials recursively we check all s such that there is an edge in the network The network is acyclic before we push flow so there is always a way to calculate these potentials with dynamic programming Then each time we want to find an augmenting path we run Dijkstra s algoritm on modified network push flow through the path we found and modify the potentials new potential of each vertex becomes where is the distance between the source and vertex in the modified network and we found this distance with Dijkstra When we have found four augmenting paths we are done and it s time to evaluate the cost of the flow 
Alice and Bob are playing a game They have a tree consisting of vertices Initially Bob has chips the th chip is located in the vertex all these vertices are unique Before the game starts Alice will place a chip into one of the vertices of the tree The game consists of turns Each turn the following events happen sequentially exactly in the following order Alice either moves her chip to an adjacent vertex or doesn t move it for each Bob s chip he either moves it to an adjacent vertex or doesn t move it Note that this choice is done independently for each chip The game ends when Alice s chip shares the same vertex with one or multiple of Bob s chips Note that Bob s chips may share the same vertex even though they are in different vertices at the beginning of the game Alice wants to maximize the number of turns Bob wants to minimize it If the game ends in the middle of some turn Alice moves her chip to a vertex that contains one or multiple Bob s chips this turn is counted For each vertex calculate the number of turns the game will last if Alice places her chip in that vertex ,This task was inspired by an older edu task and another task proposed by RockyB Let s learn to solve the problem for at least one starting vertex for Alice Let this vertex be In general Alice s strategy is basically this run to some vertex as fast as possible and stay in it until Bob reaches Hesitation on a way to this vertex won t be optimal Visiting the same vertex multiple times won t as well I guess that can be proven more formally by analyzing the set of possible solutions after each move What properties should vertex have for Alice to be able to escape to it There shouldn t be a way for Bob to catch her midway However it s not necessary to check any midway intersections If Bob can catch her anywhere on a path she can also follow her to the end by moving the same path and catch her at the destination Thus this vertex should be further from any Bob s chips than from So you can precalculate the distance to the closest Bob s chip to each vertex Just push all chips to a queue and run a bfs We ve learned to solve the problem in for each vertex Just iterate over all vertices and take the maximum of over such of them that have greater than the distance from to Now the solution can go two ways You can stop thinking here and obtain an one or think more and get an The first one goes like that Notice that the function if the Alice can make at least moves from vertex is monotonous in regard to So we can binary search the answer The check query transforms to the following Consider all vertices with distance less or equal to from There should exist at least one vertex with value for the check to return true So at least the maximum value of them should be greater than That is basically a centroid exercise Let each centroid store such an array that is the maximum value of over all such that belong to this centroid s subgraph and are no further than distance from the centroid That array can be constructed in for all centroids in total You can easily see that the length of this array doesn t exceed the number of vertices in the subgraph of the corresponding centroid that is be definition For the query iterate over all centroids belongs to and check the value from some cell of each one s array For the second solution let s reverse the problem Consider the vertex Alice escapes to If there is a starting vertex no further than from it then the answer for can be updated with So we can update the subgraph of vertices with distance no more than with the maximum of their current answer and The solution will be almost the same centroid Iterate over all centroids belongs to and write into the cell of each one s array where is the distance from to this centroid Then build an array of prefix maximums over this array Finally for each collect the best answer over all centroids belongs to Overall complexity or 
The leader of some very secretive organization has decided to invite all other members to a meeting All members of the organization live in the same town which can be represented as crossroads connected by two directional streets The meeting will be held in the leader s house near the crossroad There are members of the organization invited to the meeting th of them lives near the crossroad All members of the organization receive the message about the meeting at the same moment and start moving to the location where the meeting is held In the beginning of each minute each person is located at some crossroad He or she can either wait a minute at this crossroad or spend a minute to walk from the current crossroad along some street to another crossroad obviously it is possible to start walking along the street only if it begins or ends at the current crossroad In the beginning of the first minute each person is at the crossroad where he or she lives As soon as a person reaches the crossroad number he or she immediately comes to the leader s house and attends the meeting Obviously the leader wants all other members of the organization to come up as early as possible But since the organization is very secretive the leader does not want to attract much attention Let s denote the of the leader as follows initially the discontent is whenever a person reaches the crossroad number the discontent of the leader increases by where is some fixed constant and is the number of minutes it took the person to reach the crossroad number whenever members of the organization walk is added to the discontent where is some fixed constant This is not cumulative for example if two persons are walking along the same street in the same direction at the same moment then is added to the discontent not Before sending a message about the meeting the leader can tell each member of the organization which path they should choose and where they should wait Help the leader to establish a plan for every member of the organization so they all reach the crossroad and the discontent is minimized ,First of all one crucial observation is that no person should come to the meeting later than minutes after receiving the message the length of any simple path in the graph won t exceed and even if all organization members should choose the same path we can easily make them walk alone if the first person starts as soon as he receives the message the second person waits one minute the third person waits two minutes and so on Let s model the problem using mincost flows First of all we need to expand our graph let s create time layer of the graph where th layer represents the state of the graph after minutes have passed The members of the organization represent the flow in this graph We should add a directed edge from the source to every crossroad where some person lives with capacity equal to the number of persons living near that crossroad of course this edge should lead into th time layer since everyone starts moving immediately To model that some person can wait without moving we can connect consecutive time layers for every vertex representing some crossroad in time layer let s add a directed edge with infinite capacity to the vertex representing the same crossroad in the layer To model that people can walk along the street for every street and every layer let s add several edges going from crossroad in the layer to crossroad in the layer the costs and the capacities of these edges will be discussed later And to model that people can attend the meeting for each layer let s add a directed edge from the vertex representing crossroad in that layer to the sink the capacity should be infinite the cost should be equal to Okay if we find a way to model the increase of discontent from the companies of people going along the same street at the same moment then the minimum cost of the maximum flow in this network is the answer maximization of the flow ensures that all people attend the meeting and minimization of the cost ensures that the discontent is minimized To model the increase of discontent from the companies of people let s convert each edge of the original graph into a large set of edges for each layer let s add edges with capacity from the crossroad in the layer to the crossroad in the layer The first edge should have the cost equal to the second edge equal to the third and so on so if we choose minimum cost edges between this pair of nodes their total cost will be equal to Don t forget that each edge in the original graph is undirected so we should do the same for the node representing in layer and the node representing in layer Okay now we have a network with vertices and edges and we have to find the minimum cost flow in it and the total flow does not exceed Strangely enough we could not construct a test where the basic implementation of Ford Bellman algorithm with a queue runs for a long time but perhaps it s possible to fail it But if you are not sure about its complexity you can improve it with the following two optimizations use Dijkstra with potentials instead of Ford Bellman with queue compress all edges that connect the same nodes of the network into one edge with varying cost 
You are given a tree consisting of vertices A number is written on each vertex the number on vertex is equal to Let s denote the function as the greatest common divisor of the numbers written on the vertices belonging to the simple path from vertex to vertex including these two vertices For every integer from to you have to count the number of pairs such that is equal to this number ,Firstly for every we can calculate the number of paths such that is divisible by We can do it as follows generate all divisors of numbers numbers not exceeding have at most divisors so this will be fast enough and then for every analyze the graph containing the vertices that have as its divisor Each component of this graph gives us paths if its size is and this is the only formula we need to calculate the number of paths where is divisible by let this be How can we get the answer if we know the values of We can use inclusion exclusion with Mobius function for example to prove that and then if we want to apply the same technique for finding with any possible we could divide all numbers by and do the same thing But it might be too slow so it s better to rewrite this formula as because we will do exactly the same when dividing all numbers by In fact most contestants have written a much easier version of this solution so this might be a bit too complicated This problem can also be solved with centroid decomposition 
You are given an undirected graph with vertices and edges You have to write a number on each vertex of this graph each number should be either or After that you write a number on each edge equal to the sum of numbers on vertices incident to that edge You have to choose the numbers you will write on the vertices so that there is at least one edge with written on it at least one edge with and at least one edge with How many ways are there to do it Two ways to choose numbers are different if there exists at least one vertex which has different numbers written on it in these two ways ,Let be the number of ways to paint the graph so that all numbers on edges belong to the set Using inclusion exclusion we may get that the answer is Okay let s analyze everything separatedly is because every number is allowed will be analyzed later is where is the number of connected components in each component we have to use the same number is where is the number of isolated vertices every non isolated vertex should have number on it and all isolated vertices may have any numbers since these cases are symmetric is the number of bipartite colorings of the graph It is if the graph contains an odd cycle or if it is bipartite since these cases are symmetric is if there are no edges in the graph otherwise it is So the only thing left to consider is Actually it is easier to calculate it is the number of independent sets of this graph This problem is NP complete but when we may apply meet in the middle technique as follows divide all vertices into two sets and of roughly equal size for find all its independent subsets and for each such subset find which vertices from can be added to it without breaking its independency for each subset of find the number of independent subsets of such that no vertex from chosen subset of is adjacent to any vertex from chosen subset of you may use subset DP and OR convolution here find all independent subsets of and for every such subset add the number of subsets of that can be merged with it so the resulting set is independent The most time consuming part is counting all independent sets so the time complexity is 
You are given a bipartite graph consisting of vertices in the first part vertices in the second part and edges numbered from to You have to color each edge into one of two colors red and blue You have to minimize the following value where is the set of vertices of the graph is the number of red edges incident to and is the number of blue edges incident to Sounds classical and easy right Well you have to process queries of the following format add a new edge connecting the vertex of the first part with the vertex of the second part This edge gets a new index as follows the first added edge gets the index the second and so on After adding the edge you have to print the of the current optimal coloring if there are multiple optimal colorings print the of any of them print the optimal coloring of the graph with the same you printed while processing the previous query The query of this type will only be asked after a query of type and there will be at most queries of this type If there are multiple optimal colorings corresponding to this print any of them Note that if an edge was red or blue in some coloring it may change its color in next colorings The of the coloring is calculated as follows let be the set of indices of red edges then the is Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query Use functions in and in languages after each writing in your program ,Let s split all edges of the graph into several paths and cycles each edge will belong to exactly one path or cycle Each path and each cycle will be colored in an alternating way the first edge will be red the second blue the third red and so on or vice versa Since the graph is bipartite each cycle can be colored in an alternating way The main idea of the solution is to add the edges one by one maintain the structure of cycles and paths and make sure that for each vertex at most one path starts ends in it If we are able to maintain this invariant then the value of for every vertex will be minimum possible each cycle going through a vertex covers an even number of edges incident to it half of them will be red half of them will be blue so if the degree of a vertex is odd one path will have this vertex as an endpoint and otherwise it won t be an endpoint of any path so Okay how do we maintain this structure Let s add edges one by one even the original edges of the graph and rebuild the structure in online mode For each vertex we will maintain the indices of the paths that have this vertex as an endpoint If some vertex has or more paths as its endpoints we can choose two of them and link them together Whenever we add an edge from to we just create a new path and check if we can link together some paths that have or as their endpoints How do we link the paths together If we try to link a path with itself it means that we try to close a cycle and when we do it we just forget about the resulting cycle its structure won t change in future queries When we link a path with some other path we might need to reverse and or repaint the paths before merging them into one There are at least two possible data structures we can use to do this either an implicit key treap that supports reversing and repainting or a deque with small to large merging whenever we try to link two paths together we repaint and or reverse the smaller one Both of those methods give a solution in or depending on your implementation The model solution uses deques and small to large merging 
For some array let s denote a as a sequence of indices such that and for each is the minimum number such that and You are given an array For each its subsegment of length calculate the length of its longest greedy subsequence ,Let s calculate for each position position the closest greater from the right element to and add directed edge from to Then we will get oriented forest or tree if we d add fictive vertex where all edges are directed to some root So we can look at current subsegment we need to calculate the answer for as at a number of marked vertices in the tree Then the answer itself is a longest path up to the tree consisting only from marked vertices Key observation is next if and are marked and is an ancestor of then any vertex on path from to is also marked So the longest path up to the tree consisting only from marked vertices has length equal to a number of marked vertices on path to the root And we have three types of queries mark a vertex unmark a vertex and calculate maximum number of marked vertices among all paths to the root It can be done with Segment Tree on Euler Tour of the tree if we calculate and for each vertex in dfs order then marking unmarking is just adding to a segment and maximum among all paths is a maximum on the whole tree Result time complexity is and space complexity is 
Consider a segment of the coordinate line There are lanterns and points of interest in this segment For each lantern you can choose its power an integer between and inclusive A lantern with coordinate illuminates the point of interest with coordinate if is less than or equal to the power of the lantern A way to choose the power values for all lanterns is considered if every point of interest is illuminated by at least one lantern You have to process queries Each query is represented by one integer To answer the th query you have to add a lantern on coordinate calculate the number of valid ways to assign power values to all lanterns and print it modulo remove the lantern you just added ,Let s start without the queries How to calculate the number of ways for the given lanterns First it s much easier to calculate the number of bad ways some point of interest is not illuminated If at least one point of interest is not illuminated then all lanterns have power lower than the distance from them to this point of interest More importantly it s less than Thus the number of good ways is minus the number of bad ways Let s use inclusion exclusion For a mask of non illuminated points of interest let s calculate the number of ways to assign the powers to the lanterns in such a way that at least these points of interest are not illuminated All other points can be either illuminated or not Let s call it With the values for all masks the answer is the sum of over all masks How to calculate the value for the mask First let s do it in for each mask Each lantern can have any power from to the distance to the closest point of interest inside the mask non inclusive Thus we can iterate over the lanterns and find the closest point to each of them then multiply the number of ways for all lanterns Let s calculate it the other way around Initialize the answers for the masks with Then iterate over the lantern and the point of interest that will be the closest non illuminated one to this lantern Let the distance between them be some value Which masks will this pair affect Let the lantern be to the right of that point of interest The opposite can be handled similarly All points to the left of the chosen point can be in either state All points between the chosen one and the lantern must be illuminated All points to the right of the lantern and with distance smaller than must also be illumunated All point to the right of these can be in either state Thus the masks look like 1000 000 where 1 denotes the chosen non illuminated point All masks that correspond to this template will be multiplied by You have to be careful when there are two points of interest with the same distance to some lantern one to the left of it and one to the right of it In particular in one case you should force illumination on all points with distance In another case you should force illumination on all points with distance How to multiply fast enough We ll use a technique called sum over subsets Let s express the template in terms of submasks For a template 100000 all submasks of 111100000111 will be multiplied by However we accidentally multiplied masks of form 000000 too Let s cancel them by dividing the submasks of 111000000111 by Record all multiplications for all pairs them force push them into submasks with sum over subsets well product over subsets in this case Now we have the values of for all masks in basically give or take the time to find the points that must be forced illuminated extra from lower bound or two pointers which is not really faster Now for the queries How does the answer change after an extra lantern is added Again let s iterate over the closest point of interest and find the mask template All masks corresponding to this template will get multiplied by Thus the answer will change by the sum of values of these masks multiplied by including the inclusion exclusion coefficient How to handle that Well yet another sum over subsets Just collect the sum of values over the submasks beforehand and use these during the query That gives us an per query Overall complexity 
Mishka s favourite experimental indie band has recently dropped a new album Songs of that album share one gimmick Each name is one of the following types a single lowercase Latin letter name with a single lowercase Latin letter appended to its end Songs are numbered from to It s guaranteed that the first song is always of type Vova is rather interested in the new album but he really doesn t have the time to listen to it entirely Thus he asks Mishka some questions about it to determine if some song is worth listening to Questions have the following format count the number of occurrences of string in the name of the th song of the album as a continuous substring consists only of lowercase Latin letters Mishka doesn t question the purpose of that information yet he struggles to provide it Can you please help Mishka answer all Vova s questions ,There is a common approach for the problem you are given a lot of strings and texts count the number of occurences of the strings in the texts build an Aho Corasick automaton on the given strings and somehow process the texts with it Let s see if it can handle this problem The names of the songs can be represented as a tree We may build an Aho Corasick on the strings given in the queries then try to input the names of the album into the automaton character by character with DFS on the aforementioned tree feeding a character to the automaton when we enter a node and reverting the automaton to the previous state when we leave that node Suppose that when we are in the vertex corresponding to the th song the automaton is in state If is a terminal state corresponding to some string from the queries it means that the string from the query is a suffix of the th song But some other strings can also be the suffixes of the same song to find all such strings we can start ascending from the state to the root of Aho Corasick automaton using suffix links or dictionary links Since suffix links can be represented as the edges of some rooted tree then we can build some data structure on this tree that allows adding an integer to all vertices on the path from the root to the given vertex for example we can use Fenwick tree over Euler tour of the tree Then to check whether some string from the query is a suffix of the song we may add to all vertices on the path to state and then check the value in the state corresponding to Okay what about counting the occurences of in Let s consider the path from the root to in the song tree Every vertex on this path corresponds to some prefix of the song so we can add on the path to state corresponding to some prefix and then extract the answer from the state corresponding to In fact that s all we have to do to obtain a solution Build an automaton on strings from queries a tree of suffix links over this automaton and a data structure on this tree for each vertex of the song tree store all queries to it Then run a DFS on the song tree When we enter some vertex input the corresponding character into the automaton and add to all states from the root of suffix link tree to the current state when we have to process queries to the current vertex extract the values from the data structure and when we leave a vertex subtract from all states from the root of suffix link tree to the current state and revert to the previous state This solution has complexity of where is the total length of all strings in the input 
You are given a string and an array of strings Each string consists of lowercase Latin letters from to consists of lowercase Latin letters from to and question marks Each string has its cost an integer number The value of some string is calculated as where is the number of occurences of string in as a substring For example You have to replace all question marks in with lowercase Latin letters from to so the value of is maximum possible ,Suppose we want to calculate the value of some already fixed string we should be able to do so at least to solve the test cases without question marks How can we do it We can use some substring searching algorithms to calculate but a better solution is to build an Aho Corasick automaton over the array and then for each node calculate the sum of costs of all strings ending in that node these are the strings represented by that node and the strings represented by other nodes reachable by suffix links After that process by the automaton and calculate the sum of the aforementioned values over all states that were reached Building an Aho Corasick automaton can be done in and processing the string in Okay what if we ve got some question marks in our string The first solution that comes to mind is to calculate we processed first positions in used a of characters for question marks and the current state of the automaton is then denotes the maximum value of first characters of we could have got But it s where and is the size of the alphabet which is too slow To speed it up we can see that there are only positions in our string where we actually choose something in our dynamic programming All substrings not containing question marks can be skipped in as follows for each substring of bounded by two question marks or bounded by one question mark and one of the ends of and each state of the automaton we may precalculate the resulting state of the automaton and the change to the value of the string if we process this substring by the automaton with the initial state This precalculation is done in overall and using this we may skip the states of dynamic programming such that is not a position with a question mark so our complexity becomes A note about the model solution it s a bit more complicated because we wanted to increase the constraints to but then we decided that it would be too complicated to code so the main function still contains some parts of the code that were used to improve its complexity We will post a clearer version of the model solution soon 
Let s denote as an infinite sequence of integers such that and where is the greatest common divisor of two integer numbers sorted in ascending order The elements of are indexed for example and are the first the second and the third elements of respectively You have to process queries Each query is denoted by three integers and and the answer to this query is th element of ,Let s use binary searching to find the answer Denote as the number of positive integers such that and the answer is the smallest integer such that We may use for example as the right border of segment where we use binary searching although the answers are a lot smaller than this number for it is obvious that will be really large for any from How can we calculate fastly Let s factorize and use inclusion exclusion Let be a subset of the set of prime divisors of and be the product of all numbers from For each possible subset we have to add to the result since there are exactly integers from divisible by every prime from Since any number from has at most prime divisors there are at most subsets to process 
So we got bored and decided to take our own guess at how would Inception production go if the budget for the film had been terribly low The first scene we remembered was the one that features the whole city bending onto itself It feels like it will require high CGI expenses doesn t it Luckily we came up with a similar looking scene which was a tiny bit cheaper to make Firstly forget about 3D that s hard and expensive The city is now represented as a number line Secondly the city doesn t have to look natural at all There are buildings on the line Each building is a square Lower corners of building are at integer points and of the number line Also the distance between any two neighbouring buildings and doesn t exceed Distance between some neighbouring buildings and is calculated from the lower right corner of building to the lower left corner of building Finally curvature of the bend is also really hard to simulate Let the bend at some integer coordinate be performed with the following algorithm Take the ray from to and all the buildings which are on this ray and start turning the ray and the buildings counter clockwise around point At some angle some building will touch either another building or a part of the line You have to stop bending there The only thing left is to decide what integer point is the best to start bending around Fortunately we ve already chosen candidates to perform the bending So can you please help us to calculate terminal angle for each bend from our list of candidates ,Let s solve the problem for a single query at first There are two possible types of collisions between two buildings and between a building and a ray Obviously if the collision of the second type happens then it s the building which is the closest to the bend point from either left or right The less obvious claim is that among all buildings collisions the closest is the biggest angle one Let s boil down some possibilities of colliding buildings Let two buildings be the same distance from the bend point Then they will collide and the collision point will Two buildings also collide if the left one is from and the right one is Then the point of collision is And for the opposite case the point of collision is also These points can be easily proven by checking the distances to upper corners of each building No other two buildings will collide Now that we know this we can transition to solving a problem of checking if there exists such a pair that the distances to from them differ by at most one Finding such a pair with minimal is enough Obviously this can be done with some sort of two pointers However that s not the intended solution Let s constuct bitset of 7000 positions to the left of the bend and to the right of the bend AND of these bitsets will give you the pairs such that the distance is the same for them However you can put 1 in points and for each building to the left and and for each building to the right This way AND will give you the exact pairs you need Use Find first to find the closest one Let collision happen on distance Then the collision of the first type will have angle and the collision of the second type will have angle The answer is the maximum of these two values Be careful with cases where How to process lots of queries Let s just move the bitsets to the right while going through queries in ascending order Bitsets can be updated in for each query and only buildings will be added to them in total Overall complexity 
All bus tickets in Berland have their numbers A number consists of digits is even Only decimal digits can be used to form ticket numbers If is among these digits then numbers may have leading zeroes For example if and only digits and can be used then are valid ticket numbers and are not A ticket is lucky if the sum of first digits is equal to the sum of remaining digits Calculate the number of different lucky tickets in Berland Since the answer may be big print it modulo ,The naive solution would be the number of sequences of allowed digits with length and sum We compute it for and for every possible and the answer is Let s speed this up Let s denote the following polynomial where if is an allowed digit otherwise It s easy to see that the coefficients of are equal to the values of Using mathematical induction we may prove that the coefficients of are equal to So now we need to compute There are two possible ways to do this that result in complexity The first option is to apply binary exponentiation with NTT polynomial multiplication The second option is to use the fact that if we apply NTT to a polynomial we get a set of its values in some points So if we exponentiate these values we get a set of values of exponentiated polynomial in the same points So we may apply NTT to treating it as a polynomial of degree raise each resulting value to the power of and apply inverse transformation 
You are given an array consisting of integers You have to process queries to this array each query is given as four numbers and denoting that for every such that and you have to set equal to Print the array after all queries are processed ,We can represent a query as a function if If we want to apply two functions then we can calculate a composition of these functions in time in this problem is So we can do the following Use scanline technique Build a segment tree over queries where we store a composition of functions on segment in each vertex Initially all transformations are When a segment where we apply a query begins we update the segment tree we change the transformations on this query s index to the following if When a segment ends we revert the transformation on this index to The trick is that the composition of all current transformations is stored in the root of the segment tree so we can easily calculate the result of transformation 
You are given an array An array is constructed in such a way that it consists of integers and for each there are exactly occurrences of integer in So the number of elements in is exactly Let s define for such array the value as In other words is the total sum of distances between all pairs of equal elements Your task is to calculate the maximum possible value of and the number of arrays yielding the maximum possible value of Two arrays are considered different if elements at some position differ ,Firstly let s prove that at first and last positions of the most frequent elements should be placed but not necessary the same WLOG let s prove that for any By contradiction let s be the smallest index such that What happens if we swap them Since is the first such index then there are no for so contribution of will increase by exactly From the other side contribution of consists of two parts pairs with elements from and from For all elements from decrease will be equal to and from elements in So the total decrease after moving to position equal to The total difference in such case is equal to So our placement is not optimal contradiction Let s suggest that there is exactly one with maximum According to what we proved earlier both and must be equal to Contribution of the first and last elements will be equal to for pair and for each element with we add for pairs and So the total contribution of is equal to Note that this contribution is independent of positions of other in the array so that s why we can cut first and last elements of and solve the task recursively Unfortunately in the initial task we may have several with maximum But we in the similar manner can prove that the first and last elements should be some permutation of Now let s prove that any permutation of first and last elements is optimal Suppose positions of are and Then the contribution of is equal to The total contribution of all is This contribution doesn t depend on chosen and so any permutation of first elements and any permutation of last elements give optimal answer As a result the algorithm is following Find all maximums in If then any permutation of remaining elements has there are such permutations Otherwise add to the total balance and multiply the number of variants by Cut prefix and suffix by making for each obviously and repeat the whole process We can implement the algorithm fast if we keep the number of equal to each from to So the total complexity is 
Polycarp plays a yet another strategic computer game In this game he leads an army of mercenaries Polycarp wants to gather his army for a quest There are mercenaries for hire and the army should consist of some subset of them The th mercenary can be chosen if the number of chosen mercenaries is not less than otherwise he deems the quest to be doomed and not greater than he doesn t want to share the trophies with too many other mercenaries Furthermore pairs of mercenaries hate each other and cannot be chosen for the same quest How many subsets does Polycarp need to consider In other words calculate the number of non empty subsets of mercenaries such that the size of this subset belongs to for each chosen mercenary and there are no two mercenaries in the subset that hate each other The answer may be large so calculate it modulo ,In order to take care of the and constraints we can iterate on the number of mercenaries we ll choose and find the number of choices for each count The key constraint in this problem is that is at most 20 which means that there can only be a few connected components that aren t just a single node In particular the largest possible connected component size is 21 since a connected graph with edges has at most nodes This means that for each connected component we can iterate over all of the subsets of nodes in that component and check whether the subset is a valid choice i e is an independent set We can then do a DP for each component where dp mask k the number of submasks of mask that have k ones and represent a valid independent set subset of the component Finally we can iterate over the total number of mercenaries we want We can then do a knapsack over each of the components making sure to only consider nodes in each component where and work with our number of mercenaries Finally we determine how many valid mercenaries are available outside of our components and the rest is a simple choose function Code 90977154 
You are given an integer array of size You have to perform queries Each query has one of two types calculate the minimum value such that there are exist integers such that for every and for every where is the number of occurrences of in the subarray If it is impossible to choose integers report it assign ,Let s consider a problem without queries of the second type Now we can try to solve the problem using Mo s algorithm Let s maintain array the number of occurrences of on the current segment and array array sorted in descending order Let s take a look at how we should handle adding an element equal to Surely we should increase by but now we should erase an element equal to from the array and insert an element is such a way that the array is still sorted Instead we can increase the leftmost element equal to by Similarly we can handle deleting an element decrease the rightmost element equal to by In order to quickly find the leftmost rightmost element equal to we can store the left and the right bounds of the array where all the numbers are equal to To answer the query of type we should find two elements in the array at distance whose absolute difference is minimal Since the size of the array without zero elements is we can t look at the whole array But using the fact that there are no more than different values in the array we can create an auxiliary array of pairs the value from the array and the number of occurrences of that value In such an array we need to find a subarray where the sum of the second elements in the pairs is at least and the absolute difference between the first elements in the pairs is minimal That can be solved using standard two pointers method in The total complexity of the solution is In fact we can use Mo s algorithm even with updates But its complexity is You can read the editorial of the problem 940F on Codeforces or the following blog to learn about processing updates in Mo https codeforces com blog entry 72690
You are given an array of points in dimensional space Let the distance between two points and be it is also known as Manhattan distance You have to process queries of the following two types set th element of to the point find the maximum distance between two points and where ,Let s rewrite the formula of distance between two points as follows where if otherwise Consider what will happen if we change some to the opposite value The result of this formula obviously won t increase so we may try all possible values of and pick maximum result This allows us to consider every option to set values of there are such options separately and when we fix a set of values of find two points that maximize the distance if it is expressed with fixed To do so we have to find the point having maximum and having minimum So actually our problem is reduced to the following we have arrays we want to process some queries in the form change an element of some array and find maximum and minimum on some segment of some array This can be done simply by building a segment tree over each array and then we will get the solution having time complexity 
Let s analyze a program written on some strange programming language The variables in this language have names consisting of to characters and each character is a lowercase or an uppercase Latin letter or a digit There is an extra constraint that the first character should not be a digit There are four types of operations in the program each denoted by one of the characters or Each line of the program has one of the following formats where and are valid variable names where and are valid variable names and op is an operation character The program is executed line by line and the result of execution is stored in a variable having the name If is never assigned in the program then the result will be equal to the value of before running the program Two programs are called equivalent if no matter which operations do characters and denote but obviously performing the same operation on the same arguments gives the same result and which values do variables have before execution of program the value of after running the first program is equal to the value of after running the second program the programs are executed independently You are given a program consisting of lines Your task is to write a program consisting of minimum possible number of lines that is equivalent to the program you are given ,I could ve explained the jury solution however after the contest I found a much easier and more understandable solution by one of the participants I put one of jury s solutions under the spoiler along with a link to the solution I m explaining Let s restate the problem in a more convinient way Initially we are given some directed acyclic graph Let there be nodes of two kinds For a direct set operation These will have a single outgoing edge to another node For a binary operation These will have two outgoing edges to other nodes However it s important which edge is the left one and which is the right one We also have to make dummy vertices for the variables which only appeared at the right side of some operation We are allowed to remove any direct set operations we will simulate this by compressing the edges of the graph Instead of doing we ll do Value wise this is the same but variable don t rely on anymore so might be deleted We ll build the entire graph line by line Let s maintain array which will keep the current value of each variable It will store the node itself It s probably better to store both kinds of nodes in a separate array so that and the pointers to the ends of the edges could be integers If we encountered no variable getting set then the answer is 0 Otherwise let s traverse from the node representing the current value of to every reachable node While building the graph we were compressing every unoptimal operation thus all reachable nodes matter Finally the last operation on might have been just a direct set That s unoptimal so we ll handle that case separately 
You are given a set of elements indexed from to The weight of th element is The weight of some subset of a given set is denoted as The weight of some partition of a given set into subsets is recall that a partition of a given set is a set of its subsets such that every element of the given set belongs to exactly one subset in partition Calculate the sum of weights of all partitions of a given set into exactly subsets and print it modulo Two partitions are considered different iff there exist two elements and such that they belong to the same set in one of the partitions and to different sets in another partition ,Let s look at some facts At first the answer is the sum of weights taken with some coefficients So it s enough to calculate those coefficients Then can be calculated by iterating on the size of the subset containing th element where is the number of partitions of set with elements into nonempty subsets with one subset of fixed size where belongs This solution is still quite slow so the next fact is if two elements and belong to the same subset then increases the coefficient before So for each element we can iterate over all elements which will lie in one subset with In other words is the number of ways to divide set with elements into subsets in such a way that elements and wil lie in one subset can be calculated using Stirling numbers of the second kind let be the number of partitions of set with elements into non empty subsets If then else we just merge and into one element and let Final formula is And the answer is Counting Stirling numbers can be done with inclusion exclusion principle or by searching Wiki Resulting complexity is 
You are given a chessboard consisting of rows and columns Rows are numbered from bottom to top from to Columns are numbered from left to right from to The cell at the intersection of the th column and the th row is denoted as Furthermore the th column is a special column Initially the board is empty There are changes to the board During the th change one pawn is added or removed from the board The current board is good if we can move all pawns to the special column by the followings rules Pawn in the cell can be moved to the cell or You can make as many such moves as you like Pawns can not be moved outside the chessboard Each cell can not contain more than one pawn The current board may not always be good To fix it you can add new rows to the board New rows are added at the top i e they will have numbers After each of changes print one integer the minimum number of rows which you have to add to make the board good ,For each pawn with initial position there exists a minimum index of row such that the pawn can reach the cell but cannot reach the cell It s easy to see that In the resulting configuration this pawn can occupy the cell or any other cell having Suppose the board consists of rows For each row the number of rows above it should be not less than the number of pawns that occupy the cells above it that is having greater than the index of that row because if this condition is not fulfilled we can t assign each pawn a unique cell If we denote the number of pawns that should go strictly above the th row as then for every row the condition must be met To prove that this condition is sufficient we may for example use Hall s theorem Okay now what about finding the minimum satisfying it Let s initially set to and for each row maintain the value of the minimum number of rows we have to add to our board so that the condition for the row is met we also have to maintain this value for auxiliary rows from to since some pawns cannot fit in the initial board at all Finding the minimum value we have to add to equals finding the maximum of all these values on some prefix we don t need to look at the values on some rows with large indices if there are no pawns after them so we need a maximum query on the segment where is the maximum index among all pawns and when a pawn is added or removed we should add or to all values on some suffix A segment tree with lazy propagation will do the trick solving the problem for us in 
You are given an array consisting of positive integers and queries to this array There are two types of queries for each index such that set find the minimum among such that We decided that this problem is too easy So the array is given in a compressed form there is an array consisting of elements and a number in the input and before all queries is equal to the concatenation of arrays so the size of is ,Most of the solutions used the fact that we can read all the queries compress them and process after the compression using simple segment tree But there is also an online solution Let s build a sparse table on array to answer queries on segments that are not modified in To process modification segments we will use implicit segment tree and lazy propagation technique We do not build the whole segment tree instead in the beginning we have only one node for segment and if some modification query accesses some node but does not modify the complete segment this node maintains only then we create the children of this node So the leaves of the segment tree are the nodes such that their segments are completely set to some value or not modified at all Since each modification query affects only nodes the resulting complexity will be 
Petya has a simple graph that is a graph without loops or multiple edges consisting of vertices and edges The weight of the th vertex is The weight of the th edge is A subgraph of a graph is some set of the graph vertices and some set of the graph edges The set of edges must meet the condition both ends of each edge from the set must belong to the chosen set of vertices The weight of a subgraph is the sum of the weights of its edges minus the sum of the weights of its vertices You need to find the maximum weight of subgraph of given graph ,This problem can be reduced to one of well known flow problems Projects and Instruments In this problem we have a set of projects we can do each with its cost and a set of instruments each also having some cost Each project depends on some instruments and each instrument can be used any number of times We have to choose a subset of projects and a subset of instruments so that if a project is chosen all instruments that this project depends on are also chosen and we have to maximize the difference between the sum of costs of chosen projects and the sum of costs of chosen instruments The problem about projects and instruments can be solved with the following flow network for each project create a vertex and add a directed edge from the source to this vertex with capacity equal to the cost of this project for each instrument create a vertex and add a directed edge from this vertex to the sink with capacity equal to the cost of this instrument for each project create edges with infinite capacity from the vertex denoting this project to all vertices denoting the required instruments for this project Let s analyze an cut between the source and the sink in this vertex and construct some answer based on this cut as follows if a project vertex belongs to then we take this project if an instrument vertex belongs to then we take this instrument all other projects and instruments are discarded If an edge between some project and some instrument is cut then it means that the answer is incorrect we try to take a project requiring some instrument we don t take and the cut value is infinite Otherwise the value of the cut is equal to the total cost of taken instruments and discarded projects and we need to minimize it So the minimum cut in this network denotes the best answer Reducing the given problem to this problem is easy edges of the given graph are projects vertices of the given graph are instruments Regarding implementation any flow algorithm using capacity scaling should be sufficient It seems that Dinic also passes even though its complexity is 
Consider a tournament with participants The rating of the th participant is The tournament will be organized as follows First of all organizers will assign each participant an index from to All indices will be unique Let be the participant who gets the index Then games will be held In the first game participants and will play In the second game the winner of the first game will play against In the third game the winner of the second game will play against and so on in the last game the winner of the th game will play against Monocarp wants to predict the results of all games of course he will do the prediction only after the indices of the participants are assigned He knows for sure that when two participants with ratings and play and the participant with the higher rating wins But if any of the two participants may win Among all ways to assign the indices to participants calculate the number of ways to do this so that Monocarp can predict the results of games Since the answer can be large print it modulo ,We need some sort of better criterion other than all matches can be predicted first Suppose the ratings of the participants are in the order of their indices Then if all games are predictable the th game should be won by the participant with the rating equal to and in the th game they will play against the participant with rating So in order for each game to be predictable This is the criterion we will use So we will try to count the number of orderings meeting this condition One very important observation we need to make is that if we remove several participants with the lowest ratings from the ordering that ordering still satisfies the condition for each element either the prefix before it is removed completely or the maximum on it is unchanged So this allows us to construct the correct ordering by placing the sportsmen from the maximum rating to the minimum rating and making sure that on every step the order stays correct Okay Let s reverse the ratings array and try to write the following dynamic programming is the number of correct orderings of the first sportsmen the highest rated sportsmen since we reversed the ratings array Let s try to place the next sportsman We run into the following issue for some orderings of the first sportsmen it is possible to place the next one anywhere these orderings are where the first sportsman in the ordering doesn t conflict with the sportsman we are trying to place but for other orderings some positions might be forbidden And to keep track of which positions are forbidden and for which sportsmen we probably need some additional states for the dynamic programming which we don t really want to since states is probably the most we can allow Okay so let s avoid this issue entirely We don t like the orderings where the next sportsman can t be placed anywhere so let s find a way to ignore them discard the previous definition of Now let is the number of correct orderings of the highest rated sportsmen when we place the next sportsman in case it becomes the first element and conflicts with some of the elements we haven t placed yet So this leads to the following transitions in the dynamic programming if we place the th sportsman on any position other than the first one there are ways to do it and we transition from to otherwise if we place the th sportsman on the first position let be the last sportsman conflicting with the sportsman Let s try placing all sportsmen from to before placing the sportsman They cannot be placed on the first position otherwise they will conflict either with each other or with the sportsman so the first one can be placed in ways the second one in ways and so on this product can be easily calculated in by preparing factorials and inverse factorials So then we transition from to There is a special case in our dynamic programming It should start with but what if the st sportsman conflicts with someone Then the ordering of the first sportsmen is incorrect In this case the answer is since the st and the nd sportsmen are conflicting Overall complexity of this solution is or depending on your implementation 
You are given a permutation You should answer queries Each query is a pair and you should calculate Let s denote as the position of the maximum in subsegment Then if or otherwise ,Let s denote and analogically Then we can note that So we can switch to calculating and Let s be the closest from the left to element such that To calculate we will look from the other side we will look at it as the sum of lengths of segments induced by each element from Each element will add to value equal to or a piecewise linear function if we look at as a variable And is a value of a sum of linear functions induced by in a point To process it efficiently we can one by one add induced linear functions to the corresponding subsegments using BIT or Segment Tree and if we ve added functions induced by we can calculate answer for all queries which looks like To calculate we can just reverse array and all queries Result time complexity is Note that it s still works quite slow so you should use fast data structures like BIT of iterative segment tree 
You are given a simple undirected graph consisting of vertices and edges The vertices are numbered from to The th vertex has a value written on it You will be removing vertices from that graph You are allowed to remove vertex only if its degree is equal to When a vertex is removed all edges incident to it are also removed thus decreasing the degree of adjacent non removed vertices A valid sequence of removals is a permutation such that the th vertex to be removed is and every removal is allowed A pair of vertices is if there exist two valid sequences of removals such that is removed before in one of them and is removed before in the other one Count the number of pairs such that ,Let s consider what the sequence of removals looks like in general We will base some intuition on a fact that at least one valid sequence is guaranteed to exist Remove all vertices that have their degree correct from the start at once There surely be such vertices since a valid sequence would have to start with some of them Notice that there can t be any adjacent vertices among them If there were we wouldn t be able to remove such a pair regardless of the order we choose since removing one of them makes another one s degree too low Now remove the vertices that just got their degrees correct from removing the first layer Once again these must exist if the graph is not empty yet because otherwise any valid sequence would get stuck Process until nothing is left This algorithm is basically a bfs and you can implement it like one Note that each vertex becomes available to be removed only after a certain subset of its neighbours is removed No matter what order you choose to remove the vertices in these vertices will always be the same Huh so for each vertex some of its neighbours have to be removed before it and the rest have to be removed after it since otherwise the degree of that vertex will become too low That actually means that our graph is not as undirected as it seemed We can direct each edge from a vertex that is removed before the other This makes a valid sequence of removals just a topological sort of that directed graph So a pair is nice if there exist two topological orders such that and go one before another in them We can make a bold but perfectly reasonable guess about all nice pairs A pair is nice if neither of and are reachable from each other The necessity of this condition is obvious Let s show sufficiency Let s show the construction such that goes before To remove we first have to remove all vertices that have edges to To remove them we have to remove vertices with edge to them And so on Basically to remove we have to remove all vertices that are reachable from on the transposed directed graph Since is not reachable from it doesn t have to be removed before So we can first remove all the required vertices then remove then continue removing vertices until we are able to remove By switching and in the description of that construction we can obtain the construction for before Thus we reduced the problem to a rather well known one Calculate the number of reachable pairs of vertices in a directed graph As far as I know it s not known to be solvable in sub quadratic time And we are not given a specific graph Yes it s obviously acyclic but turns out every acyclic graph can be made into a test for this problem You just have to make equal to the number of the outgoing edges for each Somehow we are still given vertices and edges If you are more familiar with that problem you might know that you can use bitset to solve it In particular let be a bitset such that if if reachable from Then you can initialize for all vertices and propagate the knowledge in reverse topological order by applying for all edges Unfortunately that requires memory and bits is over a gigabyte Let s use of my favorite tricks to make a solution with memory and the same complexity Man I love that trick Process vertices in batches of Let s calculate which vertices can reach vertices from to The algorithm is basically the same For each vertex store a smaller bitset of size also known as an unsigned long long Initialize the bitset for vertices from the batch and propagate the same way for all vertices Now just add up the number of ones in each bitset builtin popcountll Proceed to the next batch That makes it iterations of a algorithm This might require some constant optimizations In particular I suggest not to use dfs inside the iteration since the recursion makes it really slow You might iterate over a vertex in reverse topological order and its outgoing edges Or which is way faster unroll that graph into a list of edges and iterate over it directly 
A running competition is going to be held soon The stadium where the competition will be held can be represented by several segments on the coordinate plane two horizontal segments one connecting the points and the other connecting the points and vertical segments numbered from to The th segment connects the points and For example here is a picture of the stadium with and A is a route that goes along the segments starts and finishes at the same point and never intersects itself the only two points of a lap that coincide are its starting point and ending point The length of a lap is a total distance travelled around it For example the red route in the picture representing the stadium is a lap of length The competition will be held in stages The th stage has length and the organizers want to choose a lap for each stage such that the length of the lap is a The organizers don t want to choose short laps for the stages so for each stage they want to find the maximum possible length of a suitable lap Help the organizers to calculate the maximum possible lengths of the laps for the stages In other words for every find the maximum possible integer such that and there exists a lap of length If it is impossible to choose such a lap then print ,First of all let s find all possible lengths of the laps after doing that we can just check every divisor of to find the maximum possible length of a lap for a given query A lap is always a rectangle you can t construct a lap without using any vertical segments or using an odd number of vertical segments and if you try to use or more vertical segments you can t go back to the point where you started because both horizontal segments are already partially visited So a lap is a rectangle bounded by two vertical segments and if we use vertical segments and the perimeter of this rectangle is Let s find all values that can be represented as A naive approach will be too slow we have to speed it up somehow Let s build an array of numbers where is some integer greater than Each number that can be represented as can also be represented as so we have to find all possible sums of two elements belonging to different arrays The key observation here is that if and are small we can treat each array as a polynomial let and similarly Let s look at the product of that polynomials The coefficient for is non zero if and only if there exist and such that so finding all possible sums and all possible differences can be reduced to multiplying two polynomials which can be done faster than using Karatsuba s algorithm or FFT 
You are given an undirected graph with weighted edges The length of some path between two vertices is the bitwise xor of weights of all edges belonging to this path if some edge is traversed more than once then it is included in bitwise xor the same number of times You have to find the minimum length of path between vertex and vertex ,Let s find some path from to Let its length be then the answer to the problem can be represented as where is the total length of some set of cycles in the graph they can be disconnected it doesn t matter because we can traverse the whole graph and return to the starting vertex with cost Let s treat each cycle s cost as a vector where is the th bit in binary representation of cycle s cost We can use Gaussian elimination to find the independent set of vectors that generates all these vectors To do this let s build any spanning tree of the graph and then for any edge not belonging to the spanning tree we can try to add to the independent set is the length of the path from the root to in the spanning tree When trying to add some vector we firstly need to check if it can be represented as a combination of some vectors from the set and only if it s impossible then we add it to the set The number of vectors in the set won t exceed so we can use Gaussian elimination to check if the vector is a combination of elements from the set Then after we found the basis let s build the answer greedily from the most significant bit to the least we will check if we can set the current bit so it is equal to the corresponding bit of while maintaining all the previous bit To check it we also can use Gaussian elimination 
You are given an acyclic directed graph consisting of vertices and edges The graph contains no multiple edges and no self loops The vertex is called a if it has no incoming edges The vertex is called a if it has no outgoing edges These definitions imply that some vertices can be both source and sink The number of sources in the given graph is equal to the number of sinks in it and each of these numbers doesn t exceed The following algorithm is applied to the graph if the graph has no sources and sinks then quit choose arbitrary source arbitrary sink add an edge from to to the graph and go to step that operation pops out of sources and out of sinks Note that and may be the same vertex then a self loop is added At the end you check if the graph becomes strongly connected that is any vertex is reachable from any other vertex Your task is to check that the graph becomes strongly connected no matter the choice of sources and sinks on the second step of the algorithm ,Since the graph is acyclic then for every vertex there exists a path to some sink and to every vertex there exists a path from some source So our problem can be reduced to the following check that after running our algorithm all vertices from the initial set of sources and sinks belong to the same strongly connected component Let be the number of sources or sinks in the initial graph First of all let s run DFS or any other graph traversal from every source to form a set of reachable sinks for every source This part of solution has complexity of If is some set of sources of the original graph let be the set of sinks such that every sink from is reachable from at least one source from It s easy to see that there exists some set such that and then the answer is if we connected the sinks from with the sources from then any sink not belonging to would be unreachable from any sink belonging to Checking every possible set can be done in or in Let s prove that there is no such set then the answer is Let be an arbitrary sink of the original graph Also if is some set of sinks let be the set of sources containing every source directly connected to some sink from We can use mathematical induction to prove that every source and every sink is reachable from in the resulting graph Initially we state that is reachable from quite obvious If there is a set of sinks reachable from then either and the whole graph is reachable from or the number of sinks reachable from is at least so some set of sinks is reachable from So in fact checking every possible subset of sources is enough 
You have letters letters letters You want to build a string of length from them obviously you cannot use the th letter more than times A string is called if there are no palindromic contiguous substrings of odd length greater than in it For example the string is not beautiful it has several palindromic substrings of odd length greater than for example Another example the string is Calculate the number of different strings you can build and print the answer modulo ,Suppose there is no constraint on the number of letters used Then this problem can be solved with the following dynamic programming let be the number of strings of length ending with characters and that don t contain palindromes of odd length greater than obviously each forbidden palindrome contains a subpalindrome of length so we only need to ensure that there are no palindromes of length The thing we are going to use in order to ensure that all the constraints on the number of characters are met is inclusion exclusion Since each at most two characters can violate their constraints in a single string so we will iterate on some character of the alphabet and subtract the number of strings violating the constraint on this character from the answer then iterate on a pair of characters and add the number of strings violating the constraints on these two characters to the answer Okay how to calculate the number of strings violating the constraint on some fixed character Let s use dynamic programming the number of strings such that they contain characters of them have the same type that we fixed the previous to last character is and the last character is The number of states here seems to be something about but in fact and can be optimized to have only two different values since we are interested in two types of characters the ones that coincide with the character we fixed and the ones that don t Okay what about violating the constraints on two characters The same method can be used here let be the number of strings consisting of characters such that the number of occurrences of the first fixed character is the number of occurrences of the second fixed character is the previous to last character is and the last character is Again at first it seems that there are up to states but and can be optimized to have only different values so the number of states is actually It seems that we have to run this dynamic programming for each pair of characters right In fact no the only difference is which states violate the constraints and which don t We can run this dp only once and when we need an answer for the pair of characters we can use two dimensional prefix sums to query the sum over with and in In fact this dynamic programming can also be used for the first and the second part of the solution calculating the strings that don t violate any constraints and the strings that violate the constraints on one character so the hardest part of the solution runs in though with a pretty big constant factor 
For a sequence of strings let s define the function as the number of different strings that are subsequences of string i e the number of such strings for an empty sequence is You are given a sequence of strings Every string in this sequence consists of lowercase Latin letters and is i e each string begins with several maybe zero characters then several maybe zero characters ends with several maybe zero characters For each of subsequences of calculate the value of the function modulo ,For a string let s define its as the mask of bits where th bit is if and only if is a subsequence of Let s suppose we somehow calculate the number of strings for each and we denote this as for a mask How can we use this information to find Suppose this set of strings is represented by a mask then the strings which are included in are the strings such that their characteristic mask has bitwise AND with equal to i e these characteristic masks are submasks of We can use SOS DP to calculate these sums of over submasks in The only problem is how to calculate for every mask Let s analyze when a string is a subsequence of a sorted string The subsequence should be sorted as well and the number of occurrences of every character in a subsequence should not exceed the number of occurrences of that character in So if there are characters in characters in and so on then the number of its subsequences is What about subsequences of every string from a set These conditions on the number of occurrences should apply to every string in the set so for each character we can calculate the minimum number of occurrences of this character in each string of the set add and multiply these numbers to get the number of strings that are subsequences of each string in a set These values can be calculated in for all subsequences of using recursive approach Can these numbers be used as Not so fast Unfortunately these values let s call them are the numbers of subsequences of the chosen sets of strings but we have no information about the strings that are not included in the chosen set of strings To handle it we can use the following equation where means that is a submask of To transform the values of into the values of we can flip all bits in the masks so is the sum of over all submasks of apply inverse SOS DP also known as Mobius transformation and then flip all bits in the masks again So we found a way to calculate all values of in and we have already discussed what to do with them in the first paragraph of the editorial The overall complexity of the solution is 
You are given a permutation consisting of exactly integers from to since it is a permutation each integer from to occurs in exactly once and two strings and consisting of lowercase Latin letters A substring of string is an of string if the following conditions are met for each either or where is the index of character in Latin alphabet For example if then three substrings of are occurences of they are and For each substring of having length equal to check if it is an of ,We will run two tests for each substring of we are interested in If at least one of them shows that the substring is not an occurence of we print otherwise we print The first test is fairly easy The given permutation can be decomposed into cycles Let s replace each character with the index of its cycle in both strings and check if each substring of is equal to after this replacement for example using regular KMP algorithm If some substring is not equal to after the replacement then it is definitely not an occurence The second test will help us distinguish the characters belonging to the same cycle Let be some cycle in our permutation elements are listed in the order they appear in the cycle so We will replace each character with a complex number in such a way that the case when they match are easily distinguishable from the case when they don t match One of the ways to do this is to replace with a complex number having magnitude equal to and argument equal to if this character belongs to or to if this character belongs to How does this replacement help us checking the occurence If we multiply the numbers for two matching characters we get a complex number with argument equal to or to and its real part will be In any other case the real part of the resulting number will be strictly less than and the difference will be at least So if we compute the value of for the th substring of where is the number that replaced the character we can check if the real part of the result is close to the value we would get if we matched with itself and if the difference is big enough at least one pair of characters didn t match The only case when this method fails is if we try to match characters from different cycles of the permutation that s why we needed the first test Overall the first test can be done in using prefix function or any other linear substring search algorithm and the second test can be done in if we compute the aforementioned values for each substring using FFT 
We define the of an array as You are given a tree consisting of vertices Each vertex has an integer written on it We define the value of the path from vertex to vertex as follows consider all vertices appearing on the path from to write down all the numbers written on these vertices in the order they appear on the path and compute the of the resulting sequence Your task is to calculate the maximum value over all paths in the tree ,Let s use centroid decomposition to solve the problem We need to process all the paths going through each centroid somehow Consider a path from vertex to vertex going through vertex which is an ancestor of both and in the centroid decomposition tree Suppose the sequence of numbers on path from to including both these vertices is and the sequence of numbers on path from to including but excluding is Let and We can show that the sum of prefix sums of is equal to Now suppose we fix the second part of the path and are fixed and we want to find the best first part for this second part Each possible first part is represented by a linear function and our goal is to find the maximum over all these linear functions in the point and add to this maximum This can be done with the help of convex hull or Li Chao tree The most difficult part of implementation is how to process each centroid s subtree It s easy to obtain all first parts and second parts of paths going through the centroid but pairing them up can be complicated for each second part we have to build a convex hull or Li Chao tree on all first parts going to this centroid excluding those which go through the same child of the centroid as the second part we are considering One of the best ways to implement this is the following Suppose our centroid has children is the set of first parts going from the th child of the centroid and is the set of second parts going to the th child We will create a new data structure initially empty process all second parts from add all first parts from process all second parts from add all first parts from and so on After that we will clear our data structure process all second parts from add all first parts from process all second parts from add all first parts from and so on until we add all first parts from That way we will consider all possible first parts for each second part we are trying to use 
There are players numbered from to with ranks The th player has rank Players can form teams the team should consist of three players and of players in the team should have a conflict The rank of the team is calculated using the following algorithm let be the ranks of players in the team and then the rank of the team is equal to You are given information about the pairs of players who a conflict Calculate the total sum of ranks over all possible valid teams modulo ,Let s solve this task in several steps At first let s calculate sum of all triples For each player consider three cases there are exactly ways to choose triple there are ways there are ways At second let s calculate sum over all triples such that exists pair or To calculate it we need for each iterate over all neighbors of Again some cases if then there are exactly ways to choose if there are ways to choose But we calculated some triples twice so we need to subtract triples where both and exists It is easy to calculate sorting adjacency lists of all At third let s calculate sum over all triple where exists pair but pairs and are not is a sum of all triples where pair exists It can be calculated while iterating in increasing order is a sum of all triples where pairs and exists It can be calculated while iterating and asking sum on segment of adjacency list of with prefix sums for each vertex is a sum of all triples where pairs and exists It can be calculated while iterating and asking sum on prefix of adjacency list of same is a sum of all triples where all pairs and exists It is modification of calculating number of triangles in graph It can be done in and will be explained below Then result The algorithm of finding in the given graph is following Let s call vertex if and otherwise For each heavy vertex precalculate boolean array of adjacency of vertex It s cost of memory and time but memory can be reduced by using bitsets To calculate number of triangles let s iterate over There are two cases if is heavy then just iterate over all edges and check and This part works with time since there are heavy vertices if is light then iterate over all pair where at first fix then iterate To check existence of edge consider two more cases if is heavy just check It works in if is light just check in some global array all neighbors of check all with and uncheck neighbors of Checking in array require time and will be done times So it will be in total Similarly iterating pairs works with in total So comlexity of algorithm and all task is 
Let s call a positive integer if there is no digit in its decimal representation For an array of a numbers one found out that the sum of some two neighboring elements is equal to i e for some had turned out to be a number as well Then the elements of the array were written out one after another without separators into one string For example if then You are given a string and a number Your task is to determine the positions in the string that correspond to the adjacent elements of the array that have sum If there are several possible answers you can print any of them ,Let s denote as the largest of the terms of the sum and is the smaller one Consider cases or If then So we need to find two consecutive substrings of length such that if we convert these substrings into integers their sum is equal to If let be the largest common prefix of and if we consider them as strings Then or So it is necessary to check only these two cases and whether goes before or after in the string Thus we have reduced the number of variants where the substrings for and are located to It remains to consider how to quickly check whether the selected substrings are suitable To do this you can use hashes preferably with several random modules 
You are given an array consisting of integers We denote the subarray as the array A subarray is considered if every integer that occurs in this subarray occurs there For example the array has three good subarrays Calculate the number of good subarrays of the given array ,Let s consider two solutions a non deterministic and a deterministic one The random solution goes like that Let s assign a random integer to each value from to to value not to a position Let the value of the subarray be the trit wise sum of the assigned integers of all values on it Trit wise is the analogue of bit wise sum xor but in ternary system So adding up the same integer three times trit wise is always equal to zero Thus if the value on a subarray is zero then each value appears on it a multiple of three times How to count the number of such subarrays Process the array from left to right and store the prefix trit wise sums in a map The number of the valid subarrays that end in the current position is the number of occurrences of the current prefix trit wise sum in a map The current sum should be added to the map afterwards However that s not what the problem asks us to find Let s consider another problem count the number of subarray such that each number appears no more than three times This can be done with two pointers Process the array from left to right and for each number store the positions it occurred on If some number appears at least four times than the left pointer should be moved to the next position after the fourth to last position The number of valid subarrays the end in the current position is the distance to the left pointer Let s combine these problems maintain the pointer to only the valid positions and remove the prefix trit wise sums from the map as you increase the pointer That way the map will only store the valid sums and they can be added to answer as they are Assume you use trits I guess the probability of the collision is the same as two vectors out of colliding in a dimensional space with their coordinates being from to That will be about when according to birthday paradox and way less if we increase Overall complexity The deterministic solution a k a the boring one goes like that Let s again process the array from left to right Let the current position be the right border of the segment Each number makes some constraints on where the left border might be More specifically it s two possible segments between its last occurrence and the current position and between its fourth to last occurrence and its third to last one Let s actually invert these segments Bad segments are from the beginning of the array to the fourth to last occurrence then from the second to last occurrence to the last one So the valid left borders are in such positions that are covered by zero bad segments Let s keep track of them in a segment tree Add on the bad subarrays Now you have to count the number of values in a segtree That s a pretty common problem As we know that no values can go below should be a minimum element on the segment So we can store a pair of minimum on segment number of minimums on segment At the end the second value is the number of zeros if the first value is zero Overall complexity 
Consider a road consisting of several rows Each row is divided into several rectangular tiles and all tiles in the same row are equal The first row contains exactly one rectangular tile Look at the picture below which shows how the tiles are arranged The road is constructed as follows the first row consists of tile then rows follow each of these rows contains tile greater than the previous row then rows follow each of these rows contains tile less than the previous row then rows follow each of these rows contains tile greater than the previous row then rows follow each of these rows contains tile less than the previous row then rows follow each of these rows contains tile greater than the previous row then rows follow each of these rows contains tile less than the previous row An example of the road with Rows are arranged from left to right You start from the only tile in the first row and want to reach the last row any tile of it From your current tile you can move to any tile in the next row which touches your current tile Calculate the number of different paths from the first row to the last row Since it can be large print it modulo ,The group of the rows where the number of rectangular tiles increases times and then decreases times can be represented as a rectangular table with diagonals where the size of the first diagonal is equal to the number of rectangular tiles before the operations are applied let their number be and the size of the last diagonal is In such a rectangular table one can move from the cell to the cells and if they exist which lie on the next diagonal next row in terms of the original problem It s a well known fact that the number of different paths from one cell to another is some binomial coefficient Let s define as the number of paths from the st row to the th tile in the th row i e row after the th group of operations Now we want to find the values of using the values of let its size be Using the fact described in the first paragraphs we know that depends on with some binomial coefficient In fact for But this solution is too slow To speed up this solution we have to notice that the given formula is a convolution of and some binomial coefficients So we can use NTT to multiply them in instead of time 
You are given a tree consisting of vertices numbered from to Initially all vertices are white You have to process queries of two different types change the color of vertex to black It is guaranteed that the first query will be of this type for the vertex find the minimum index such that the vertex with index belongs to the simple path from to some black vertex a simple path never visits any vertex more than once For each query of type print the answer to it ,After the first query make the vertex that we painted black the root of the tree and for each other vertex calculate the minimum index on the path to the root This can be done by simple DFS Then suppose we are painting some vertex black In can easily proved that for every vertex and every vertex that is on a path form to the root there exists a path from to some black vertex coming through So we have to store the minimum index among all vertices such that belongs to the path from the root to some black vertex it is a global value let s call it and the answer to every query of type is just the minimum of the value we calculated in DFS and To update quickly after painting vertex black we ascend from to the root until we arrive to some node that was visited during previous queries and we stop there because this node and all nodes on the path from it to the root were used to update in previous queries This solution works in time 
You are given a weighted tree undirected connected graph with no cycles loops or multiple edges with vertices The edge has weight Also each vertex has its own value assigned to it Let s call a path starting in vertex and ending in vertex where each edge can appear no more than twice regardless of direction a Vertices can appear in the 2 path multiple times even start and end vertices For some 2 path profit where is the number of times edge appears in That is vertices are counted once but edges are counted the number of times they appear in You are about to answer queries Each query is a pair of vertices For each query find 2 path from to with maximal profit ,Let s solve this task in several steps Step 1 Calculate for each vertex Let be maximal profit of some 2 path starting at and finishing at If vertex is a root of the tree then equivalent to where maximal profit of 2 path when we can go only in subtree of The can be calculated with next approach To calculate we can use next technique Let s manage next invariant when processing vertex all its neighbours even parent will hold as if its parent Then After that we can proceed with each child of but before moving to it we must change value since we must keep invariant true To keep it true it s enough to set Also let s memorize value as Step 2 Processing queries Let simple path be If then answer is Otherwise each edge on this simple path must be used exactly once But while travelling from to using this simple path at each vertex we can go somewhere and return to the only condition is not use edges from simple path And we can do it using precalculated values and So if we want to find max profit of 2 path with prohibited edges so we can use value Finally to process queries let s find divide it on two queries Now we can handle all queries offline travelling on tree in dfs order Let s manage some data structure on current path from current vertex to the root this DS can be based on array of depths Then when we come to vertex just add value to DS in position and erase it before exit Each query becomes a query of sum to some subsegment in DS don t forget carefully handle value in lca And before moving from to you need subtract from current value of here you can at once subtract weight of edge Don t forget to return each change in DS when it needed As we can see DS is just a BIT with sum on segment and change in position Result complexity is Fast IO are welcome 
Vasya got really tired of these credits from problem F and now wants to earn the money himself He decided to make a contest to gain a profit Vasya has problems to choose from They are numbered from to The difficulty of the th problem is Moreover the problems are given in the increasing order by their difficulties In order to add the th problem to the contest you need to pay burles to its author For each problem in the contest Vasya gets burles So the total earnings for the contest are calculated as follows if Vasya takes problem to the contest he needs to pay to its author for each problem in the contest Vasya gets burles let If Vasya takes all the tasks with indices from to to the contest he also needs to pay If then Calculate the maximum profit that Vasya can earn by taking a consecutive segment of tasks ,We can first compute all values of Since we only care about the maximum such value within our segment we can use div conquer to solve every segment In particular if we know the index of the maximum value in we know that any segment crossing this index has this value as its maximum We can thus solve all segments crossing this maximum and recurse on the left and right sides To find the best crossing segment note that each problem contributes a value of We can independently find the largest sum starting from our crossing index going left and the largest sum going right and add these two together for the best overall crossing segment Unfortunately since we can t guarantee that the maximum indices will divide our interval nicely in half this does not lead to the usual runtime of div conquer but is instead in the worst case To improve on this we can precompute partial sums of and use RMQ to find the minimum sum left of the crossing index and the maximum sum right of the crossing index This reduces the crossing computation from per index to or giving an overall runtime of Code 49036431 
You are given a tree of vertices and edges The th vertex has an initial weight Let the from vertex to vertex be the number of edges on the path from to Note that and Let the distance from to be Note that and if Analogically to usual distance let s define the of vertex as the greatest weighted distance from to any other vertex including itself or Finally let s define the of the tree as the minimum eccentricity of any vertex or You need to perform queries of the following form assign After performing each query print the radius of the current tree ,Firstly let s define the weight of path as On contrary to weighted distances and also Now let s define the diameter of a tree as path with maximum It s okay if diameter may be explicit case The useful part of such definition is next our diameter still holds most properties of the usual diameter Let s look at two of them There is a vertex on diameter path with and It s easy to prove after noting the fact that and otherwise you could choose diameter or For any vertex eccentricity In other words either or has the maximum distance from You can also prove it by contradiction It also means that The two properties above give us an easy way to calculate the radius just maintain diameter and the answer is a half of it Now let s look how the diameter changes when we change the weight If it s quite easy The only paths that change weights are the paths ending at Denote such path as and note that either or In other words there will be only three candidates for a new diameter path with path with path with The only thing you need to calculate fast enough is the two distances and And since your task is to calculate Finally how to handle decreasing s Let s get rid of them using DCP dynamic connectivity problem technique Keep track of each value each possible value for some vertex will be active on some segment of queries Since there are only queries there will be exactly such segments for all vertices in total Now all queries becomes assign on some segment of queries Note that in that case the previous value of was so you are dealing with only increasing value queries Finally to handle all range queries efficiently you build a Segment Tree on queries set all queries and then traverse your Segment Tree while maintaining the current diameter in order to calculate answers for all queries Each of queries transforms in queries to segment tree vertices and preforming each query asks you to calculate two times If you use the usual binary lifting then your complexity becomes what is okay But if you use Sparse Table on Euler tour you can take in and your complexity will be 
The campus has rooms numbered from to Also the mouse lives in the campus The mouse is not just a mouse each second mouse moves from room to the room in fact it teleports from one room to another since it doesn t visit any intermediate room Starting position of the mouse is unknown You are responsible to catch the mouse in the campus so you are guessing about minimum possible number of traps one trap in one room you need to place You are sure that if the mouse enters a trapped room it immediately gets caught And the only observation you made is ,Some notes At first there is since lets define as That means that for each there is exactly one that So if we look at this problem as the graph then it consists of cycles consider loops as cycles of length one So we need to know number of cycles in this graph At second since and and So all can be divided in groups by its And we can calculate number of cylces in each group independently Let fix some equal to All numbers such that can be represented as and Number of such equals to Moreover Here we can shift from and to and In result we need for each calculate number of cycles created by from numbers that and Lets set Next step is to find minimal such that let s name it order of or Then for each if then and so each cycle will have length equal to and number of cycles will be equal to Last step is calculate for each There is a fact that so can try to iterate over all divisors of and check by binary exponentiation It seems as but it s faster and author s version work around 2 seconds It doesn t pass but somebody can write better But we ll speed it up Let So we can independently for each find its minimal power such that We can just iterate over all and since Some words about finding its factorization differs from factorization of just by lowering degrees of primes and adding factorizations of some But we can manually find factorization of with memorization or even without it since So our steps are next factorize recursively iterate over all divisors of find and and add to the answer Result complexity is And the last note is how to multiply modulo You can use binary multiplification which will give you extra what is not critically in this task in C of course Or you can use multiplification from hashes which will work with 64 bit double since it s only 
You are given a complete undirected graph with vertices A number is assigned to each vertex and the weight of an edge between vertices and is equal to Calculate the weight of the minimum spanning tree in this graph ,We can use Boruvka s algorithm to solve this problem This algorithm usually works in initially MST is empty and then we run a number of iterations During each iteration we find connected components in the graph formed by already added edges and for each component we find the shortest edge that leads out of this component Then we add the edges we found to the MST but we should be careful to avoid adding edges that form cycles in MST The number of iterations is at most and each of iterations can be done in However in this problem we need to speed up this algorithm We can do each iteration in time using a binary trie We can store all values from in a trie When we need to find the shortest edge that connects some component with vertices outside of it we firstly remove all values contained in this component from the trie After that for each vertex in the component we can find the closest vertex outside the component in by descending the trie And then we insert the values of belonging to the component back into the trie Since for each vertex we descend the trie three times to remove it to find closest vertex and to add it back each iteration requries and the whole algorithm works in time 
You are given a directed acyclic graph a directed graph that does not contain cycles of vertices and arcs The th arc leads from the vertex to the vertex and has the weight Your task is to select an integer for each vertex and then write a number on each arcs such that You must select the numbers so that all are positive the value of the expression is the lowest possible It can be shown that for any directed acyclic graph with non negative such a way to choose numbers exists ,The key observation in this problem is that the values of should form a contiguous segment of integers For example suppose there exists a value such that there is at least one there is at least one but no We can decrease all values of that are greater than by so the answer will still be valid but the value of will decrease So the values of form a contiguous segment of integers We can always assume that this segment is since subtracting the same value from each does not change anything The other observation we need is that we can rewrite the expression we have to minimize as follows where is the signed sum of weights of all arcs incident to the vertex the weights of all arcs leading from are taken with positive sign and the weights of all arcs leading to are taken with negative sign These two observations lead us to a bitmask dynamic programming solution let be the minimum value of if we assigned the values from to the vertices from A naive way to calculate this dynamic programming is to iterate on the submask of check that choosing the integer for each vertex from that submask doesn t ruin anything for each vertex that belongs to this submask all vertices that are reachable from it should have so they should belong to but not to the submask we iterate on and update the dynamic programming value But this solution is and depending on your implementation this might be too slow It s possible to speed this up to in a way similar to how profile dp can be optimized from to we won t iterate on the submask instead we will try to add the vertices one by one and we should be able to add a vertex to the mask only if all vertices that are reachable from it already belong to the mask There is a possibility that we add two vertices connected by an arc with the same value of so for a fixed value of we should consider assigning it to vertices in topological sorting order that way if one vertex is reachable from another it will be considered later so we won t add both of those with the same value of 
Let be the length of the longest common prefix of strings and Also let be the substring of from index to index inclusive For example if then You are given a string of length and queries Each query is a pair of integer sets and Calculate for each query ,At first implement your favourite string suffix structure for comparing pair of suffixes lexicographically fast enough For example it s a Suffix Array linear LCP Sparse Table Now we can compare two suffixes and by finding and comparing with We will process queries online Let current query be a pair of arrays and We will calculate answer in two parts To calculate the first sum we can sort all suffixes in lexicographical order and maintain some information for prefixes of What information we need to maintain We need some Data Structure which will hold of suffixes from When we process some we need just a total sum of all in the DS If we should add to the DS length of th suffix And when we move from to we must recalculate some Since is sorted all we need is to set In fact this Data Structure is just a In this we will hold for each length number of suffixes with we will hold only non zero values When we should add some suffix we manually increase some value by one Setting with can be done with decreasing maximum in while its more than It can be proven that there will be operations with for one query The total sum can be maintained in some global variable which will be recalculated each time changes To calculate the second sum we can just reverse and run the same algorithm So total complexity is 
In this problem you will have to deal with a very special network The network consists of two parts part and part Each part consists of vertices th vertex of part is denoted as and th vertex of part is denoted as For each index there is a directed edge from vertex to vertex and from to respectively Capacities of these edges are given in the input Also there might be several directed edges going from part to part but never from to You have to calculate the maximum flow value from to in this network Capacities of edges connecting to might sometimes change and you also have to maintain the maximum flow value after these changes Apart from that the network is fixed there are no changes in part no changes of edges going from to and no edge insertions or deletions Take a look at the example and the notes to understand the structure of the network better ,First of all let s calculate minimum cut instead of maximum flow The value of the cut is minimum if we choose the first set of the cut as first vertices of part and first vertices of part That s because if is the minimum index such that then we don t have to add any vertices such that to because that would only increase the value of the cut Similarly if is the maximum index such that then it s optimal to add every vertex such that to Okay so we can try finding minimum cut as a function value of the cut if we choose as the union of first vertices in and first vertices in To find its minimum let s rewrite it as where is the sum of capacities of edges added to the cut in part it doesn t depend on part is the sum of capacities added to the cut from part and is the sum of capacities added to the cut by edges going from to These functions can be denoted this way if otherwise is the capacity of the edge going from to if otherwise is the capacity of the edge going from to is the sum of capacities over all edges such that and Since only the values of are not fixed we can solve this problem with the following algorithm For each find the minimum possible sum of Let s denote this as and let s denote Build a segment tree that allows to get minimum value and modify a single value over the values of When we need to change capacity of an edge we add the difference between new and old capacities to and to calculate the maximum flow we query minimum over the whole tree But how can we calculate the values of We can do it using another segment tree that allows to query minimum on segment and add some value to the segment First of all let s set and build this segment tree over values of The value of is fixed for given so it is not modified the value of is initially since when there are no vertices belonging to in the part And then we calculate the values of one by one When we increase we need to process all edges leading from to part When we process an edge leading to vertex with capacity we have to add to every value of such that since if then and this can be performed by addition on segment in the segment tree After processing each edge leading from to part we can query as the minimum value in the segment tree Time complexity of this solution is 
You are given array You need to split it into subsegments so every element is included in exactly one subsegment The weight of a subsegment is equal to The weight of a partition is a total weight of all its segments Find the partition of minimal weight ,Important note the author solution is using both linear Convex hull trick and persistent Li Chao tree As mentioned in commentaries applying the Divide and Conquer technique can help get rid of Li Chao tree More about both structures you can read in this article Let s try to write standard dp we can come up with arrays will be 0 indexed Let be the minimal weight if we splitted prefix of length in subsegments Then we can calculate it as 1 Maximums on segments are inconvenient let s try to group segments by the value of So we can find such sequence of borders where for each In other words and is the closest from the left position where Note that we can maintain this sequence with stack of maximums Ok then for each interval equation 1 transforms to Why did we use variables and Because there are two problems is needed because we iterate over and can t recalculate everything is needed because sequence is changing over time so do the But what we can already see we can maintain for each segment Convex hull with linear functions so we can take in logarithmic time Moreover we can store values in other Convex hull to take minimum over all segments in logarithmic time The problems arise when we try modificate structures while iterating Fortunately segments change not at random but according to stack of maximums So all we should handle are to merge segment on top of the stack with current segment in case when to erase segment on top of the stack along with its value to insert new segment on top of the stack along with its value To handle the third type is easy since all Convex hulls can insert elements There will be at most such operations on a single layer and we can ask value in and insert a line with To handle the second type is harder but possible since we can make Convex hull persistent and store its versions in the stack Persistent Convex hull persistent Li Chao tree There will be also operations in total and they cost us To handle the first type is trickiest part Note that all line coefficients of one convex hull are strictly lower than all line coefficients of the other So we can use linear Convex hulls to make insertions to back in amortized But to merge efficiently we should use Small to Large technique that s why we should be able also push front in and moreover still be able to ask minimum in And here comes the hack in C which can push pop front back in amortized and also have random access iterator to make binary search possible So each element of every segment will be transfered times with cost of amortized on a single layer In the end result complexity is Space complexity is 
You are given a rooted tree Let s denote as depth of node depth of the root is depth of any other node is where is a parent of The tree has the following property every node with has exactly children Maximum possible depth of a node is and We define as the number of unordered pairs of vertices in the tree such that the number of edges on the simple path between them is equal to Calculate modulo for every ,At first when we read the problem a simple solution comes to our mind take a look at the LCA Lowest Common Ancestor of that starting and ending vertices of the path and then use combinatorics to calculate the number of the paths but after trying to implement this or solve this on paper it doesn t seem to be easy at all and it may even be impossible to implement this So lets try to solve this problem in a different way For calculating the answer we count the number of times each path starts or ends at every vertex and then divide them by to get the answer for each vertex For calculating the answer to the above it is easy to see that all vertices with the same height have the same number of paths going through them so if we calculate the number of paths going through one of them and then multiply it by the number of the vertices in that height let it be it gets equal to our answer We can calculate the answer for a certain height So to do that we divide the paths into two types paths that go only into the subtree of a vertex let s call it and paths that go up let s call it For the ones that are in the subtree it is easy to see if there are at least other vertices that go down we can go all paths going down let the number of them be and the answer for this part equals to For the ones that go up we use dynamic programming and we define the number of paths that start at a vertex with height and have length and do not use the leftmost edge exiting the vertex at height To update this either we go down on one of the paths and then we go through a path of length or we go up and get a path of length starting at a vertex from height so the answer for this one equals to Now And the final complexity of the solution will be but because of the large constant of the solution the time limit is higher 
Suppose you have two strings and and their length is equal You may perform the following operation any number of times choose two different characters and and replace every occurence of in both strings with Let s denote the between strings and as the minimum number of operations required to make these strings equal For example if is and is the between them is we may replace every occurence of with so becomes and then we may replace every occurence of with so both strings become You are given two strings and For every substring of consisting of characters you have to determine the between this substring and ,Unfortunately it seems we failed to eliminate bitset solutions The approach in our model solution is the following Firstly let s try to find some naive solution for calculating the distance between two strings We may build an undirected graph where vertices represent letters and edges represent that one letter must be transformed into another Then all letters in the same component should become one letter so the answer is the number of distinct letters minus the number of components Then let s get back to original problem For every substring of we have to find which letters have to be merged to make it equal with This can be done with the help of FFT to find all positions in substrings of with character that coincide with occurences of in we may compute a convolution of two following arrays set to every position in where occurs and to every position in where occurs all other elements should be After trying these convolutions for every pair of different characters we compute the answer for every substring using DFS or any other method 
