,editorial
0,There are multiple ways to solve this problem Most interpreted languages have some function that takes the string evaluates it as code and then returns the result One of the examples is the function in Python If the language you use supports something like that you can read the input as a string and use it as the argument of such a function Suppose you use a language where this is impossible There are still many approaches to this problem The most straightforward one is to take the first and the last characters of the input string calculate their ASCII codes and then subtract the ASCII code of the character from them to get these digits as integers not as characters Then you can just add them up and print the result 
1,If then the answer is Otherwise if and is even or and is odd then the answer is Otherwise the answer is you can always make case in one move 
2,It is easy to see that for the odd elements there is no changes after applying the algorithm described in the problem statement and for the even elements there is only one change each of the even elements will be decreased by So we can iterate over all the elements of the array and print where is taking modulo Overall complexity is 
3,Firstly if the array already has an odd sum the answer is Otherwise we need to change the parity of the sum so we need to change the parity of some number We can do in only when we have at least one even number and at least one odd number Otherwise the answer is 
4,This problem has a lot of solutions You could even hard code all possible tests to solve it But this problem has solution Let the digit of be Then our character pressed each digit before exactly times And the amount of times he pressed the digit depends on the length of Let be the length of then the amount of times he pressed the digit is So the final answer is 
5,The answer is where is rounded down 
6,Notice that sum limits i 0 k 1 2 i 2 k 1 Thus we can replace the initial equation with the following 2 k 1 x n So we can iterate over all possible k in range 2 29 because 2 30 1 10 9 and check if n is divisible by 2 k 1 If it is then we can print x frac n 2 k 1 P S I know that so many participants found the formula sum limits i 0 k 1 2 i 2 k 1 using geometric progression sum but there is the other way to understand this and it is a way more intuitive for me Just take a look at the binary representation of numbers we can notice that 2 0 1 2 1 10 2 2 100 and so on Thus 2 0 1 2 0 2 1 11 2 0 2 1 2 2 111 and so on And if we add one to this number consisting of k ones then we get 2 k 
7,If we cut the sheet in width we will reduce its width by half without changing the height Therefore the width and height dimensions do not affect each other in any way Let s calculate the maximum number of sheets that we can get by cutting Let s say that initially this number is Let s cut the sheet in width Then the sheets number will become but they will be the same If we can cut the sheet again it is more profitable to cut all the sheets we have because this way we will get more new sheets and their size will still be the same So we can maintain the current number of identical sheets and as long as either the width or height is divided by divide it and multiply the number of sheets by two 
8,Note that no matter which action is chosen after this action is performed one letter is erased from the string two letters in total are erased from the string Let s denote the length of the string by If is odd then described turns can not erase all the characters from the strings because if he is deleting two letters on each turn the length will always remain odd For example if the original length of the string is then after one turn it will be equal to and after two moves it will be equal to in which case the next turn is impossible Thus if the length of the row is odd the answer is If is even it will take exactly steps to erase all characters from the string Since each action removes exactly one letter from the string the string can become empty only if there are exactly letters Let us show that this condition is sufficient that is if a string has exactly half of the letters equal to then there always exists a sequence of actions leading to an empty string Indeed if a string of length has exactly letters exactly letters and exactly letters then Then Casimir can make moves of the first type each time removing the first occurrence of and the first occurrence of and moves of the second type each time removing the first occurrence of and the first occurrence of After such moves the string will become empty Thus checking that the number of letters in the string is exactly half of its length was enough to solve the problem 
9,We can see that the only information we need is the parity of the coordinate of each chip because we can move all chips that have the same parity to one coordinate for free So if the number of chips with odd coordinate is then the answer is 
10,We just need to find the position of the in the array and then check if the sequence is going counterclockwise or clockwise from the position or correspondingly We can do this by two cycles Total complexity 
11,Suppose If it isn t true then let s rearrange our variables Then we need at least coins to make and equal So if then the answer is Otherwise the answer if if the number is divisible by This is true because after making and equal we need to distribute all remaining candies between three sisters 
12,Let are the last characters of lines and respectively And are the sizes of these strings then the answer depends only on and and is uniquely defined as the inverse of to if if since the characters are in reverse order in the alphabet Then the answer is This also covers the case Then the larger the size of the string the smaller the size of the t shirt That is the answer is if and if Then the larger the size of the string the smaller the size of the t shirt That is the answer is if and if 
13,There will be one character left in the end so we have to delete all the characters going before and after it That is delete some prefix and suffix Since we always delete some substring of length we can only delete the prefix and suffix of even length it means the answer is in the case when there is an odd position in with the character and otherwise 
14,The solution is simple let s create an integer variable initially set to that will contain the number of considered liked integers Let s iterate over all positive integers starting with Let s increase the variable only when the considered number is liked If the variable is equal to let s stop the iteration and output the last considered number Since the answer for is the count of considered numbers is at most so the solution will work on the specified limitations fast enough 
15,The string is diverse if it is a permutation of some substring of the Latin alphabet In other words the string is diverse if all letters in it are distinct we can check it using some structure like or array of used elements and if the number of letters between the letter with the maximum alphabet position and the letter with the minimum alphabet position plus one is exactly the length of the string For example the position in alphabet of letter is one the position of letter is six and so on 
16,Let s write our unique function Keep the array of the taken elements Iterate over all elements in the array and if the current element is not used then add its index to the answer and set When finished check the number of distinct values that is the size of answer array If it is less than print Otherwise print and output the first elements of the answer 
17,What if the given number cannot be represented as It means that the answer is because all actions we can do are remove one power of two remove one power of three and add one power of two and remove one power of five and add two powers of two So if the answer is not then it is If this formula isn t pretty clear for you you can just simulate the process performing actions from third to first 
18,If is divisible by just print Otherwise we need exactly moves to make zero remainder of modulo is modulo operation 
19,The simplest solution go through the problem because of which the teacher might have suspicions Now you can find the first day when Polycarp solved this problem and the last such day Between these two days all problems should be the same If this is not the case the answer is 
20,Let s solve the problem for the first candidate To win the election he needs to get at least more votes than every other candidate Therefore the first candidate needs to get at least votes If is already greater than this value then you don t need to add any votes otherwise you need to add votes So the answer for the first candidate is Similarly the answer for the second candidate is and for the third one the answer is 
21,In this problem we need to find the minimum possible such that where is the sum of all equals to where is divided by rounded up 
22,To begin with let s learn how to determine how much time must pass before the alarm to trigger If the alarm time is later than the current one then obviously minutes should pass Otherwise this value will be negative and then it should pass since a full day must pass not including the time from the alarm to the current time We just need to find the minimum number of minutes among all the alarm clocks Due to small constrains the problem can also be solved by stimulating the sleep process increase the answer by and check whether any alarm will work after this time 
23,In this problem you can implement an algorithm opposite to that given in the condition Let s maintain two pointers to the left most and right most unhandled element Then restoring the original array you put the left most unhandled item in the first position put the right most unhandled item in the second position put the left most unhandled item in the third position put the right most unhandled item in the fourth position That is in general you put the leftmost elements on all odd positions and the rightmost ones on all even positions After processing each element you either move the left pointer forward by one or the right one backward by one 
24,If then the answer is Otherwise you can remove the first floor and then the answer is 
25,Obviously the best way to buy food for every pet is to buy maximum possible food for dogs and cats then dogs and cats will not get food We will buy universal food for these dogs and cats Then the answer is if and else 
26,With each pair of jumps of kind to the right to the left the frog jumps So the answer is almost Almost because there can be one more jump to the right So if is odd then we have to add to the answer 
27,If is not divisible by then just print and stop the program Otherwise calculate denoting the required number of times to multiply It is easy to see that should be a product of zero or more s and of zero or more s i e for integers To find just use a loop to divide by while it is divisible by Similarly to find just use a loop to divide by while it is divisible by After the divisions the expected value of is If print Otherwise print the total number of the loop iterations 
28,Note that numbers of the same length are compared lexicographically That is until some index the numbers will match and then the digit in our number should be greater Let s write out the numbers until As soon as this condition is false or the line ends insert the digit We got the lexicographically maximum number which means just the maximum number 
29,The first solution take modulo and solve the problem manually then for cases and the answer is and for and the answer is Prove Let s see what can we make for numbers and We can add and in and add and in Then the difference between sums will be We can consider last four numbers this way until we have at least four numbers And then we have a case We can prove the solution for these four cases using bruteforce The second solution if is even then the answer is otherwise the answer is The formula above is just Prove if we have an integer sequence then we can obtain every number from to as the sum of some elements of this sequence How Greedily You can see how this greedy works and prove if you want yourself So what s next If is even then we can obtain the sum in and in Otherwise we can only obtain in and in or vice versa 
30,To solve the problem you may convert the string to lower case strip all duplicated characters from it and compare the result to meow string To exclude duplicate characters you can for example use the function in C 
31,Since it does not take time to place your hand over the first letter you need to calculate the sum of the distances between the keyboard keys corresponding to each pair of adjacent letters of the word that is where is the position of the keyboard key corresponding to the letter In order to calculate this sum let s just iterate through the word with the loop and find the differences between the positions of and on the keyboard To find the position of a character on the keyboard you could either use the built in strings functions such as in Python or in C or precalculate each letter s position on the keyboard into a separate array using another loop over a keyboard 
32,If the number is already even then nothing needs to be done so the answer in this case is Now let s recall the divisibility by a number is divisible by if and only if its last digit is divisible by It follows that if there are no even digits in our number then the answer is Let s take a look at our operation What is going on The first digit always changes with the digit numbered In particular when we reverse the entire number the first digit is swapped with the last Note that no other digit except for the first one at the current moment can t be the last Therefore you can do this if the first digit of a number is divisible by then we reverse the whole number The first digit will become the last and the number will become even Therefore you only need to do one operation Now what if the first digit of a number is odd In this case we can find the first even digit in the number let it be at position and reverse the prefix of length in one operation Now the first digit of our number has become even and we can use the previous case one more operation Thus we will do only operations 
33,Let s carry the current answer as the last position we re checked as and the number of occurrences as Initially the answer is is and is 0 indexed We don t need to check the position because there is the beginning of the occurrence of at this position Also is by the same reason Let s repeat the following algorithm while if where ans is the length of the answer let s add to the answer increase and by In the other case let s check if there is a prefix of starting from If it is let be its length Then we need to add the suffix of starting from till the end of increase and by If there is no prefix of starting from the we just increase The other idea is the following we have to find the period of the string Let this period will be Then the answer is repeated times and The period of the string is the minimum prefix of this string such that we can repeat this prefix infinite number of times so the prefix of this infinite string will be For example the period of the string is the period of the string is and the period of the string is The period of the string can be found using prefix function of the string or in naively 
34,Firstly let s parse both strings to four integers Just read them and then use some standard functions to transform them into integers or we can do it manually The second part is to obtain and Then let It is the answer We have to print and where is divided by rounding down and is modulo The only thing we should do more carefully is to print one leading zero before if it is less than and do the same for 
35,Obviously that both rectangles should completely touch by one of the sides Otherwise you can move them closer to each other so that the total height or total width decreases and the other dimension does not change Thus there are only two options The rectangles touch by width we get the side of the square equal to The rectangles touch by height we get the side of the square equal to Thus the minimum side of the square is equal to the minimum of these two options Then the answer is 
36,In this problem we just need to print 
37,You can iterate over all the elements of the array from left to right Count the number of problems Mishka will solve from the left end of the list and break if he cannot solve the next one Let s denote the number of problems Mishka will solve from the left end of the list by Do the same thing independently from right to left Denote the number of problems Mishka will solve from the right end of the list by Then the answer is Time complexity 
38,If then the answer is Otherwise the best way is to construct the array For we can t reach answer more than and for we can t reach the answer more than because each unit can t be used more than twice So the answer can be represented as 
39,Even if we will iterate over all possible numbers starting from and check if sum of digits of the current number is divisible by we will find the answer very fast The maximum possible number of iterations is no more than 
40,Let s note that if then must be equal to since we must change the same value to the same letter If we check this for all pairs of and and find no such contradictions then the answer is otherwise We got the solution for for one test case 
41,The process in the statement can be rephrased as multiply by will be divisible by so if is not divisible by there is no answer Otherwise and can be used 
42,If the number has an odd divisor then it has an odd prime divisor To understand this fact we can consider what happens when multiplying even and odd numbers even even even even odd even odd even even odd odd There is only one even prime number So if a number has no odd divisors then it must be a power of two To check this fact for example you can divide by as long as it is divisible If at the end we got then the power of two You can also use the following condition to check If the number is a power of two then it contains only one unit in the binary notation Then contains units in all positions except the one in which the unit in is located So their bitwise AND does not contain units 
43,Firstly we obviously need to take at least coins of value If we cannot do it the answer it Otherwise we always can obtain the required sum if 
44,Let s sort the numbers in ascending order It becomes immediately clear that it is not profitable for us to increase the numbers that are equal to the last number the maximum of the array It turns out that every time you need to take such a subset of the array in which all the numbers except the maximums And once for each operation the numbers in the subset are increased by one then how many times can the operation be performed on the array Accordingly 
45,In this problem all you need is to check for each point from to if it cannot belongs to any segment It can be done in by two nested loops or in by easy prefix sums calculation Both solutions are below 
46,Let s initialize variables and by the same value of Then we need to gather additionally the remainder of dividing by If the remainder is equal to we don t need to gather anything else because the variables and have been already set to the correct answer because and no absolute value can be less than Otherwise because and in this case but that s impossible if isn t divisible by 3 If the remainder is equal to then we need to gather additionally burle using one coin of burle so let s increase by In this case hence this value cannot be less than as it was proved above If the remainder is equal to then we need to gather additionally burles using one coin of burles so let s increase by In this case hence this value cannot be less than There are no other remainders of dividing by so these cases cover the whole solution 
47,The order of elements in doesn t matter If there is at least one correct array then we can sort it and get the answer in which Therefore we can always find a sorted array Suppose that Then We can find as 
48,In the problem you had to find the largest common prefix LCP of the first characters of the number and the string To do this we will go from the beginning and compare the characters until we find a non matching one or until the string ends 
49,We have to find the maximum number of elements with the same value it can be done by counting This number will be the answer because if there are no more than elements with the same value in the array it is obvious that we cannot use less than pockets but we also doesn t need to use more than pockets because of the other values can be also distributed using pockets Overall complexity is 
50,The problem can be solved like this firstly let s iterate over all from to If characters and are the same then we obviously need to replace one of them with the other character We can see that such replacements are enough to make the string suitable 
51,In the constraints the problem can be solved by brute force we will go through the value for the height for the first place and then select suitable values for and Since we divide the remaining blocks equally between and If it turns out that then we try to decrease by and increase by 1 If we get the right answer output the heights and stop the process We will go through the value of in order of increasing 
52,The key fact in this problem is that the answer is not very large in fact it s not greater than 91 Why is it so Every 10 times we apply function f to our current number it gets divided by 10 at least and the number of such divisions is bounded as O log n So we can just do the following store all reachable numbers somewhere and write a loop that adds current number n to reachable numbers and sets n f n we should end this loop when n already belongs to reachable numbers The most convenient way to store reachable numbers is to use any data structure from your favourite programming language that implemenets a set but in fact the constrains were so small that it was possible to store all reachable numbers in an array 
53,As we can see last digits of the resulting number will be zeros except the th So we need to change all ones to zeros if needed among last digits if the position of the digit is not and change zero to one if needed otherwise It can be done with simple cycle 
54,We will store integers which we already met in a set Let s iterate through the given array from the right to the left Let the current element is equal to So if does not contain in we add in a vector answer and add in After we considered all elements the answer sequence contains in the vector in reversed order So we should reverse the vector and simply print all its elements 
55,Firstly let s sort the initial array Then it s obvious that the best way to remove elements is from smallest to biggest And if there is at least one such that and then the answer is because we have no way to remove Otherwise the answer is 
56,There are many possible approaches in this problem I will describe one of the easiest Let s print the initial string by the following algorithm firstly init the variable Then while the encrypted string isn t empty print the first character of this string remove first characters from it and increase by one 
57,There are two cases in this problem If we try to maximize the answer we need to consider only two integers and Of course the first one is better we get rid of the existing remainder and trying to add to this number If it s too big then we can and need to take the second one this number is just the first one but decreased by The answer can be always found between these numbers Time complexity 
58,Let and Then we can construct the following answer and Because all numbers in the answer are positive we can assume that the maximum element of is So let s sort the input array consisting of four elements and just print and 
59,Note that the number and the nearest round number not exceeding have the same size consist of the same number of digits in the record Denote the size of by Then we can construct the nearest round number It will consist of one and zeros 
60,Note that the first two characters of match the first two characters of The third character of the string again matches the second character of since it is the first character in the second substring which contains the second and the third character of The fourth character matches with the third character of It is easy to notice that such a pattern continues further That is the string consists of the first character and all characters at even positions in 
61,There are many possible solutions One of them is just to print 2 3 ldots n 1 
62,To find a number that differs from the rest of the numbers in the array you need to iterate through the array maintaining two pairs of numbers x 1 c 1 and x 2 c 2 where x i is a number from the array c i is how many times the number x i occurs in the array Then to get an answer you need to find the position of the x i that occurs in the array exactly once i e c i 1 
63,If the length of the given string is odd then the answer is since adding two strings cannot do that Otherwise let be the length of the string Let s go through the first half of the string comparing whether its first and characters are equal its second and characters are equal and so on If the characters in any pair are not equal the answer is otherwise 
64,If we want to destroy the largest and smallest stone then there are only four options Destroy the stones on the left until we destroy the smallest stone Then destroy the stones on the right until we destroy the largest stone Destroy the stones on the right until we destroy the smallest stone Then destroy the stones on the left until we destroy the largest stone Destroy the stones on the left until we destroy both stones Destroy the stones on the right until we destroy both stones You need to check all four options and choose the minimum answer 
65,The answer contains such elements that Also add to the answer the last element 
66,This problem can be solved with simple simulation Let be the new position of the first friend and are new positions of the second and the third friends correspondingly For the fixed positions you can update the answer with the value And iterating over three positions can be implemented with nested loops Time complexity per test case 
67,Suppose If then the answer is because is the overall maximum among all three integers and and it appears in two pairs so it should appear at most twice among and Otherwise the answer exists and it can be and it is easy to see that this triple fits well 
68,The answer is always Let s understand why it is so Let Then let Bob take the pile with candies and Alice take the pile with candies Then because of we can see that Bob s pile always can reach size of Alice s pile and remaining candies can be divided between them fairly except one candy if is odd 
69,One of the possible answers is always a pair of endpoints of the given segments So we can add all endpoints to the array and iterate over all pairs of elements of this array and check if the current pair is suitable or not 
70,You had to to calculate the time that each elevator would need and compare them Let the time required by the first elevator be and the time required by the second one be Then the answer is if if and if 
71,The only thing you need to do is to place letters by blocks and so on The last block can contain less than letters but it is ok It is easy to see that this letters distribution is always not worse than others 
72,If Vasya has coins of burles then he can collect amounts of burls If Vasya does not have burles coins then he cannot collect the amount of burle If he has at least one coin in burl he can score odd amounts up to The following burl coins increase the maximum amount he can make If Vasya has coins for burle he can make up the amount of burles and not anymore 
73,What is the number of lanterns Vova will see from to This number is Now we have to subtract the number of lanters in range from this number This number equals to So the answer is 
74,The answer can be calculated by easy formula where is divided by rounded down and is modulo 
75,In this problem you just need to simulate the process described in the statement i e times repeat the following operation if then else and print the result 
76,Note that it is enough to consider the string where is written times since and our substring has size Then we just use the built in function to find out if our string is a substring of the string 
77,The answer is always or Why it is so Because if there is no such pair among all students that then we can take all students into one team Otherwise we can divide them into two teams by their programming skill parity 
78,The answer is only if all have the same parity i e all are odd or all are even That s because placing the block doesn t change the parity of the element and the operation changes the parity of all elements in the array 
79,We can add or subtract until the difference between and becomes less than And if it is not after all such moves we need one additional move Let is the absolute difference between and The final answer is plus one if This formula can be represented as divided by rounded up in other words 
80,f two asterisks are in the same row then it is enough to select any other row and place two asterisks in the same columns in it If two asterisks are in the same column then you can do the same If none of the above conditions are met and the asterisks are at positions x1 y1 x2 y2 then you can place two more asterisks at positions x1 y2 x2 y1 
81,For a start let s find the position of the letter in string If this position does not exist then the answer would be Suppose that this position exists and equals Let s create two pointers and Initially We will try to build string using the algorithm from the statement Suppose that we have built substring in iterations Consider the next letter of the Latin alphabet Let s look at cases find position of the letter in if it does not exist then if then make an assignment and process the next letter if then make an assignment and process the next letter otherwise string is not alphabetical and the answer is So if we have built the string in iteration then string is alphabetical and the answer is 
82,For all elements of the arrays to become equal after subtraction of units for must be satisfied In addition if there exists then the equality can be obtained only by subtracting exactly units from Since the equality must be satisfied for all the problem is reduced to checking that for all differences are equal and for the difference does not exceed 
83,How can we solve this problem Firstly let s sort the initial array but maintain the initial order of the elements in the array to restore the answer Then let s just distribute all the colors Let s color the first element in the first color the second one in the second the th element in the th color the th in the first color and so on So we color the th element in the color is just modulo operation We can see that the answer is if there is an element with frequency at least in the array by pigeonhole principle Otherwise our solution builds the correct answer So we can try to find such element in the array naively using counting sort or many other approaches Time complexity or 
84,It is easy to see that we always have to remove either minimum or maximum of the array So we can sort the array and the answer will be We also can do it without sort because two minimal and two maximal elements of the array can be found in linear time 
85,Let be the minimum price of the berPhone during days We can precalculate this array moving from right to left and carrying the minimum price we met in other words if we iterate over all from to then if otherwise Then the answer is the number of such days from to that 
86,Firstly if n is not divisible by 4 then the answer is because the parities of halves won t match Otherwise the answer is always Let s construct it as follows firstly let s create the array 2 4 6 dots n 1 3 5 dots n 1 This array is almost good except one thing the sum in the right half is exactly frac n 2 less than the sum in the left half So we can fix it easily just add frac n 2 to the last element 
87,Note that the numbers in the array are not important to us so initially we will calculate the values of Now applying a move for the number is equivalent to decreasing by and increasing by We will perform the following greedy algorithm while the array have no balanced remainders find any such that we apply the move for that is replace with and with It is easy to prove the correctness of this greedy algorithm by cyclically shifting the values and so that the first element is equal to the maximum of them 
88,This problem has several general cases x is even and a b then the answer is repeated frac x 2 times then b frac x 2 ones and a frac x 2 zeroes x is even and a le b then the answer is repeated frac x 2 times then a frac x 2 zeroes and b frac x 2 ones x is odd and a b then the answer is repeated lfloor frac x 2 rfloor times then a lfloor frac x 2 rfloor zeroes and b lfloor frac x 2 rfloor ones x is odd and a le b then the answer is repeated lfloor frac x 2 rfloor times then b lfloor frac x 2 rfloor ones and a lfloor frac x 2 rfloor zeroes I am sure that there are other more beautiful solution but for me the easiest way to solve this problem is to extract general cases and handle it Overall complexity is O a b 
89,Firstly we can notice that we always can distribute where is the modulo operation candies between kids In this case and the answer is at least And then we can add the value to the answer Why Because there is only candies remain and the maximum number of kids to whom we can give one more candy is 
90,It is obvious that if there is a pair of points and such that and then the answer is It means that if the answer is then there is some ordering of points such that and because we can only move right or up But what is this ordering it is just sorted order of points firstly by then by So we can sort all points check if this ordering is valid and traverse among all these points For each from to firstly do moves to the right then do moves to the up because this order minimizing the answer lexicographically Time complexity or 
91,If we represent letters with digits then the answer can be represented as There is no substring containing more than distinct characters and each substring of length contains exactly distinct characters because of the condition Time complexity 
92,Note that the conveyor matrix consists of cycles through each of which we can move without wasting energy Now you need to find the distance between the cycles where the start and end cells are located In one step from any cycle you can go either to the cycle that is closer to the edge of the matrix or to the cycle that is further from the edge of the matrix It turns out that it is enough to find on which cycles there are cells on the edge and take their difference modulo 
93,Count two arrays and such that contains the number of occurrences of th letter of the alphabet in the string in upper case while in lower case Let s add all existing pairs to the answer so let s add to it for each letter Subtract this minimum from and to get the number of unpaired identical letters Next we will act greedily if there is some set of at least two identical letters in the same case we can apply the operation to half of them and get new pairs Therefore for each letter we will add to the answer and decrease by that amount 
94,The answer is always a segment of the initial array The authors solution uses two pointers technique let s iterate over all left bounds of the correct contests and try to search maximum by inclusion correct contest Let s iterate over all from to and let the current left bound be Let be the maximum right bound of the correct contest starting from the position Initially Now while and let s increase Try to update the answer with the value It is obvious that all positions from to cannot be left bounds of the maximum by inclusion correct contests so let s set and go on Because each element will be processed once time complexity is 
95,The idea is as follows we will go from the end of the string and get the original string Note that if the current digit is then a letter with a two digit number has been encoded Then we take a substring of length three from the end discard and get the number of the original letter Otherwise the current number then a letter with a one digit number was encoded We easily reconstruct the original letter Next discard the already processed characters and repeat the process until the encoded string is complete 
96,Let s find the value the length of the longest common suffix of and You can easily find it in one linear loop just compare the last letters of and If they are equal then compare before the last letters of and And so on The last letters of and are two equal strings which will be the result of after optimal moves So the answer is 
97,There are many different ways to solve this problem generate all Berland words with two for loops and store them in an array then for each test case go through the array of words to find the exact word you need generate all Berland words with two for loops and store them in a dictionary like data structure in C in Python etc using words as keys and their numbers as values This allows to search for the index of the given word quickly for each test case run two for loops to iterate over the words count the number of words we skipped and stop at the word from the test case try to invent some formulas that allow counting the number of words before the given one 
98,The first observation is that we are interested only in patterns of kind All other patterns don t make sense at all So let s build a greedy approach Let s iterate over the given array from the left to the right and maintain that the prefix of the given answer is already correct If now we are at some position and and the prefix from to is already correct then which one we have to replace When we replace the left one then we cannot do better in the future but when we replace the right one then we can fix some on the suffix of the array The easiest example is If now we are at the position then we will do better if we will set 
99,Consider Note that is maximal over the entire segment from to so if there is in which gives a greater result then Note that numbers from to that have an incomplete quotient when divided by equal to do not fit this condition and are guaranteed to have a value less than And the number Has the maximum possible remainder Has the maximum possible among numbers less than So there are two candidates for the answer these are and The second candidate is suitable only if it is at least It remains only to compare the values of and select the maximum 
100,Let s take a look on the maximum element of the given array Suddenly this number is or the order doesn t matter Okay what would we do if we know and merged list of divisors of and Let s remove all divisors of and see what we got The maximum element in the remaining array is So the problem is solved 
101,After sorting we can observe that if the answer is then the area of each rectangle is Then we just need to check for each from to that and and If all conditions are satisfied for all then the answer is Otherwise the answer is 
102,It is very intuitive that the maximum price we can obtain is where is the minimum value in the array For this price we should check that we can change prices of all products to it It can be done very easily we can just check if each segment covers the point But this is not necessary because if we can change the price of the maximum to this value then we can change each price in the segment to this value So we just need to check that and if it is then print otherwise print 
103,We split all the positions in which the parity of the index does not match with the parity of the element into two arrays If there is an odd number in the even index add this index to the array Otherwise if there is an even number in the odd index add this index to the array Note that if the sizes of the and arrays are not equal then there is no answer Otherwise the array can be made by doing exactly operations by simply swapping all the elements in the and arrays 
104,Let the initial sum in the array the number of even numbers the number of odd numbers Let s see how these values change with each action In fact we can consider four main options Add an even number to all even numbers Then will increase by and the number of even and odd numbers will remain the same Add an odd number to all even numbers Then will increase by the number of even numbers will become all numbers will become odd so Add an even number to all odd numbers Then will increase by and the number of even and odd numbers will remain the same Add an odd number to all odd numbers Then will increase by the number of odd numbers will become all numbers will become even so 
105,If the sum of all the weights is not divisible by two then it is impossible to divide the candies between two people If the sum is divisible then let s count the number of candies with a weight of and Now if we can find a way to collect half the sum with some candies then these candies can be given to Alice and all the rest can be given to Bob Simple solution let s iterate through how many candies of weight we will give to Alice then the remaining weight should be filled by candies of weight If there are enough of them then we have found a way of division In fact if the sum is even and there are at least two candies with weight there can t be one candy then the answer is always we can collect the weight as close to half as possible with weight and then add weight If there are no candies with weight then you need to check whether is even since all the candies have the same weight you just need to divide them in half 
106,Let s iterate through the given string from the left to the right In a variable we will store the number of letters which were before the current letter in a row If the current letter does not equal to we should make In the other case the current letter equals to If we should increase by one In the other case we should add one to the answer because the current letter should be removed 
107,Let s do the following greedy solution it is obvious that when we buy food that costs exactly for we don t lose any burles because of rounding Let s take the maximum power of that is not greater than let it be buy food that costs and add this number to the answer and add to Apply this process until and then add to the answer Time complexity per test case 
108,Let s denote for the number of candies all friends have Note that at the end each friend must have of candy If is not completely divisible by then there is no answer How to get the answer if it exists If the th friend has more candies than then he must be chosen by Polycarp otherwise this friend will have more candies than the others If the th friend has no more than then Polycarp may not choose it Then if the answer exists it is equal to the number of 
109,We cannot make a funny permutation only when because one of the neighboring elements of must be equal to Any permutation made in this way will not satisfy the conditions The permutation will have a fixed point The permutation will have a fixed point The permutation will not have a neighbor equal to for For the remaining values of make the following observations For the only funny permutation is When permutations of the form will always be funny because all elements will have a neighbor equal to or and the permutation will have no fixed points and for will always be true 
110,At first consider the problems on candies and oranges independently Then it s pretty obvious that for candies the optimal way is to decrease all to the value we need obtain at least this value to equalize all the elements and there is no point to decrease elements further The same works for the array Then if we unite these two problems we need to take the maximum moves we need for each because we need exactly that amount of moves to decrease to and to simultaneously So the answer is 
111,Let s solve this problem greedily Let be the last position from the left covered by at least one heater Initially equals While lets repeat the following process firstly we have to find the rightmost heater in range It can be done in time because of given constrains or in using precalculated prefix values for each in range If there is no such heater then the answer is otherwise let s set increase the answer by and repeat the process if There is another one solution to this problem Assume that the initial answer equals to the total number of heaters Let s calculate an array of length where means the number of heaters covering the th element It can be done in This array will mean that we are switch all the heaters on and we know for each element the number of heaters covers this element Now if for at least holds then the answer is Otherwise let s switch useless heaters off Let s iterate over all heaters from left to right Let the current heater have position We need to check if it is useless or not Let s iterate in range and check if there is at least one element in this segment such that If there is then the current heater is not useless and we cannot switch it off Otherwise we can decrease the answer by switch this heater off decrease for all in range and continue the process 
112,Let s found two athletes with numbers and the strength of is not greater than the strength of which have the minimal modulus of the difference of their strength Obviously we cannot get an answer less than this Let s show how to get the partition with exactly this answer Sort all athletes by strength Our two athletes will stand in neighboring positions otherwise we can decrease the answer Let the first team contains all athletes who stand on positions not further than and the second team contains other athletes We got a partition in which the athlete with number has the maximal strength in the first team and the athlete with number has the minimal strength in the second team 
113,Let s try to find the position of the leftmost occurrence of iterate over all positions from to If then this is the required position of the leftmost occurrence of Then the position of rightmost occurrence is so we can print the answer Otherwise let s decrease by remove all strings which have the leftmost at the current position and proceed to the next position It is obvious that in such a way we consider all possible strings in lexicographic order 
114,Let s see how the deleted substring t should look so that after deleting it the string s turns into the string The length of the string t must be n 4 Then we can iterate over all substrings of the string s of length n 4 there are no more than five such substrings and look at the string obtained after deleting the substring That is we need to check that one of the following character sequence matches the 2 0 2 0 s 1 s 2 s 3 s 4 s 1 s 2 s 3 s n s 1 s 2 s n 1 s n s 1 s n 2 s n 1 s n s n 3 s n 2 s n 1 s n 
115,Let s find the first digit in a that becomes greater if we replace it obviously if there is no such digit then the best solution is to leave a unchanged In the optimal solution we will replace this digit and maybe some digits after this Why is it so It is impossible to make any of the previous digits greater since we found the first digit that can be replaced with a greater one Then let s analyze all digits to the right of it We should not replace any digit with a lower digit because it is better not to replace it and all digits to the right of it at all but there s nothing wrong with replacing any other digits So the segment we need to replace begins with the first digit that can become greater after replacing and includes this digit and goes to the right until the first digit that becomes less after replacing and this digit is excluded 
116,Let us add to the sum of the elements of the array and try to find a suitable permutation To do this greedily add elements until their sum is less than And at the end we will check that the sum has matched Also check that the maximal element from and that the total elements in 
117,Let s iterate over the number that we want to multiply by How can we check that we can multiply the current number so that an AP is formed Note that those numbers that we do not touch should form an AP themselves For instance let at the current operation we want somehow multiply the number Then and Note that Thus we know what is Also we know that Let s check if is divisible by If yes then we have found the answer if not then move on to the next number We do the same for and Be careful with non positive numbers integer divisions and other edge cases 
118,A number is divisible by if and only if its last two digits represent one of the following strings Let s solve for each string the following subtask what is the minimum number of characters to be deleted so that the string becomes a suffix of the number Then choosing the minimum of the answers for all subtasks we solve the whole problem Let s solve the subtask for a string where and are digits We can do it using the following algorithm let s delete the last digit of the number until it is equal to then the second to last digit of the number until it is equal to If it is not possible then this subtask has no solution i e its result will not affect the answer 
119,We will process the elements of the sequence starting from the end of the sequence Each element will be divided by until it is less than If at some point it turns out that it is impossible to obtain the desired sequence 
120,Let s leave only unique values of the given array in the array i e construct an array that is actually array without duplicate element and sort it in ascending order Then let s consider the following cases If the length of is greater than then the answer is if the length of is then there are two cases if then the answer is otherwise the answer is if the length of is then there are also two cases if is even then the answer is otherwise the answer is and if the length of is then the answer is 
121,Sure you can just implement the rotation operation and check all possible ways to rotate the matrix but it s kinda boring The model solution does the different thing If a matrix is beautiful then its minimum is in the upper left corner and its maximum is in the lower right corner and vice versa If you rotate it the element from the upper left corner goes to the upper right corner and the element from the lower right corner goes to the lower left corner so these elements are still in the opposite corners No matter how many times we rotate a beautiful matrix its minimum and maximum elements will be in the opposite corners and the opposite is true as well if you have a matrix with minimum and maximum elements in opposite corners it can be rotated in such a way that it becomes beautiful So all we need to check is that the minimum and the maximum elements are in the opposite corners There are many ways to do it in my opinion the most elegant one is to read all four elements in an array of size then the opposite corners of the matrix correspond either to positions and or to positions and in this array So we check that the sum of positions of minimum and maximum is exactly 
122,At first consider we process the only day In this case just iterate over hours and maintain the length of the current rest block i e if the element equals then increase if the element equals then reset to The maximum intermediate value of is the answer In case of multiple days consider the given sequence as a cyclic sequence Concatenate the sequence twice and solve the previous case Sure not it is no necessary to concatenate it in explicit way just use instead of and process 
123,Let be the number of elements of with the remainder modulo Then the initial answer can be represented as and we have to compose numbers with remainders and somehow optimally It can be shown that the best way to do it is the following firstly while there is at least one remainder and at least one remainder let s compose them into one After this at least one of the numbers will be zero then we have to compose remaining numbers into numbers divisible by If then the maximum remaining number of elements we can obtain is because and in the other case the maximum number of elements is because 
124,The following greedy solution works let s take the minimum element and move it to the leftmost position we can With this algorithm all forbidden operations are form the prefix of operations and so on So we can carry the position of the leftmost operation we can perform Initially it is We repeat the algorithm until Let s find the position of the minimum element among elements Let this position be If then let s increase and continue the algorithm Otherwise we need to move the element from the position to the position and then set Time complexity 
125,The only fact required to solve the problem if we start decreasing the number we are better to end decreasing it and only then decrease the other number So we can just consider two cases when we decrease first and after that and vice versa and just take the minimum product of these two results The rest is just implementation 
126,Consider a full sequence of bigrams for some word The first bigram consists of letters and of the word The second bigram consists of letters and The th bigram consists of letters and After one bigram is removed there becomes two adjacent bigrams such that one consists of letters and and the other consists of letters and Thus we can find the position of the removed bigram by looking for a pair of adjacent bigrams such that the second letter of the first one differs from the first letter of the second one If there is no such pair then the sequence of bigrams represents a valid word of length We can append it with any bigram that starts with the second letter of the last bigram to make it a valid word of length If there exists such a pair then all letters of the word can be recovered We can find the position of the removed bigram determine the letters it consisted of and insert it into the sequence After that we have a full sequence of bigrams and we can restore the word from it Overall complexity per testcase 
127,If the number consists of other primes than and then the answer is Otherwise let be the number of twos in the factorization of and be the number of threes in the factorization of If then the answer is because we can t get rid of all twos Otherwise the answer is Time complexity 
128,Let the number of the number of Let us write the required decomposition of the number Then we get that is divisible by Take equal to the remainder of divided by Then is uniquely determined from the formula above Then if the result is that because the remainder of dividing by is non negative then can be represented as the sum of a certain number of and a certain number of 
129,This problem can be solved using the next greedy approach let s iterate over all from to If go further Otherwise let s find any position such that and move the character from the position to the position If there is no such position in the answer is Upper bound on time complexity and the size of the answer of this solution is 
130,Consider the first four actions that the grasshopper will perform starting at a point with coordinate coordinate is jumping to leads to coordinate is jumping to leads to coordinate is jumping to leads to coordinate is jumping to leads to If you look closely at the next four jumps they follow the same pattern jump to the left two jumps to the right jump to the left In general making jumps with numbers the grasshopper will start from coordinate and move as Thus if were always zero the answer would be if if if if is divisible by Let s find an answer for the cases when But if is even then all steps will follow the same directions and the answer will be where is the answer for the same and starting point described above And if is odd then all steps will have opposite directions and the answer will be 
131,Firstly let be the number of odd elements in the array Note that even elements are don t matter at all because they cannot change the parity of the sum If then it is obviously impossible to split the given array into subsegments with odd sum And if then it is impossible to split the array into subsegments with odd sum also because at least one of segments will have even number of odd elements so will have odd sum In other cases the answer is always and you can print leftmost positions of odd elements and as right borders of segments it means that when you find one odd element you end one segment Because now the last segment will have odd number of odd elements so it will have odd sum also 
132,Note that every ordinary number can be represented as Therefore to count all ordinary numbers among the numbers from to it is enough to count the number of pairs such that In the given constraints it is enough to iterate over from to and from to 
133,Let s calculate the sum of the whole array and then divide all its elements into two arrays and by their parity for odd for even Sort both of them in non increasing order Then what can we see We always can delete first elements from both arrays where is the size of So let s decrease by the sum of first elements of the array and the same for the array If one the arrays has more than elements both arrays cannot have more than elements because if it is so then should be greater then let s decrease by the th element of this array because this is the maximum possible element we can remove Now is the answer for the problem 
134,After sorting the array we can maintain the last day Polycarp can train in the variable Initially it is Let s iterate over all elements of the sorted array in non decreasing order and if the current element then let s increase by one The answer will be 
135,Let us simulate the process We store a set consisting of letters that Polycarp memorizes on one day Gradually dial the set If the size of exceeds we add to the day counter and clear 
136,The maximum possible you can obtain is the sum of the largest values of the given array This is obvious because we can always separate these maximums and then extend the segments corresponding to them to the left or to the right and cover the entire array I suggest the following extract largest values of the given array and place a separator right after each of them except the rightmost one Overall complexity is 
137,Let be the number of boxes with candies modulo Firstly the number of of boxes we can obtain using two boxes with remainder modulo is Secondly if is even then we also can obtain of boxes using two boxes with remainder modulo and its number is And for any other remainder from to the number of pairs of boxes is So if we sum up all these values the answer is this sum multiplied by two because we have to print the number of boxes not pairs 
138,Let s turn the problem around we ll look for the longest suffix that will make Polycarp happy since it s the same thing Let s create an array in which we will mark the numbers already encountered Let s go along from right to left and check if does not occur to the right in this case it is marked in if it occurs to the right then removing any prefix that does not include we get an array where occurs twice so we have to delete prefix of length 
139,The solution is pretty simple it s obvious that the first element of a is the first element of the permutation p Let s take it to p remove it and its its copy from a So we just have the smaller problem and can solve it in the same way It can be implemented as go from left to right if the current element isn t used take it and mark it s used 
140,To solve the problem we can implement the encryption algorithm with a single change we have to iterate over all divisors of in increasing order Time complexity where is a divisor count function for For example 
141,In this problem it was enough to implement an analogue of standard or Here is an example of a solution based on selection sort Let s find the minimum element in the array by simply iterating over it Let s denote its index in the array by If we apply a shift to it the following happens Once again please note that all shifts are made in the left direction so shifting by to the left will put the element that was previously at index in the first place Let us perform a similar shift for the second largest element of the array putting it in second place for the third largest element of the array putting it in third place and so on More formally let s describe the th iteration as follows At the beginning of the th iteration the first elements of the array are its minimal elements already in their correct places in sorted order During the th iteration the th largest element of the array is placed in the th place in the array Since the first minimal elements are already in their places the th largest element of the array is simply the smallest element among Let s find it by iterating over these elements and denote its index in the array by Make a shift The first elements will not change and the element from the th place in the array will move to the th It is worth noting that the output format forbids shifting segments with Regarding this case we should check the equality separately If these two indexes coincide then the th element is already in its place and no shift should be done on this iteration Let us repeat this algorithm for At each iteration the new element will be shifted into its place in sorted order and each iteration performs no more than one shift operation Thus in strictly less than shifts the array will be completely sorted The time complexity is 
142,We can see that because the multiplier in the formula is the position of the number and we want to minimize the sum of such formulas the following greedy solution comes up to mind because we want to count greater values as earlier as possible let s sort the array in non increasing order saving initial indices of elements calculate the answer and print the permutation of indices in order from left to right 
143,Let be the number of occurrences of the character in the initial string the number of occurrences of the character and are the same things for remaining characters It is obvious that in every answer the number of equals the number of and the same for and The maximum theoretic answer we can obtain has length And We almost always can obtain this answer If there is at least one occurrence of each character then we can construct some kind of rectangular path moves right then moves up and the completing part But there are some corner cases when some characters are missing If then our answer is empty or if it is possible it is The same if Time complexity per test case 
144,We ll search for positive integers not larger than and add their squares or cubes to the set if they don t exceed If the maximum number Polycarp will like is so the running time will be within the time limit The answer to the problem is the length of the resulting set 
145,Firstly sort all the strings by their lengths if there are several strings of the same length their order does not matter because if the answer is then all the strings of the same length should be equal Then for each check that is a substring of If it doesn t hold for some then the answer is Otherwise the answer is and the sorted array is the correct order of strings 
146,Firstly if is odd then the answer is by obvious reasons Otherwise we can notice that the top left and the bottom right values of the tile do not matter since we can place tiles symmetrically So we only need to check that there is some tile that its top right value equals its bottom left value because this is how we get main diagonal symmetry 
147,It is easy to find the value on the cube that the cat stole it is equal All other values must be Let s try to get by taking times and adding the remainder there if it is non zero We could not get more than cubes this way because otherwise but we are guaranteed that the answer exists Now until we get the cube let s find the cube with the maximum value reduce it by and add the cube with the value of We can definitely get dice because otherwise but we are guaranteed that the answer exists It remains only to add a cube with the value of to our cubes We obtained a solution with asymptotics 
148,Let s maintain four variables and which will mean the sum of with odd on prefix even on prefix odd on suffix and even on suffix Initially and are equals to the sum of with odd in a whole array and equals to the sum of with even in a whole array Let s iterate from left to right over all elements of the array Let s consider the current element If is even then set otherwise let s set Then let s consider we give the current candy to dad Then we have to increase the answer if and Then if is even then let s set otherwise let s set 
149,If necessary change the values of and so that is always true Consider two cases 1 Let Then This means that the set is at least times larger than and we can form teams of the form where one participant will be a programmer and three will be mathematicians 2 Let Then assume that Let s substitute this value into the inequality Then we compose commands of the form Since making such a command decreases the value of by 2 The new value The condition still holds Then make commands of the form The total number of commands is That s what we wanted to get 
150,If we sort the students in order of non decreasing their skill we can see that the minimum cost of the team with the lowest skill let s call it the first team is equal to if is already sorted the cost of the second team is and so on So if we sort in non decreasing order then the answer is 
151,Each move we can choose the minimum element in the maximum element in and swap them if the minimum in is less than maximum in If we repeat this operation times we get the answer This can be done in but authors solution is 
152,There are at least two different approaches to this problem You can iterate over all substrings of of length and calculate for each of them the number of its occurrences in and try to update the result with the current substring Also you can iterate over all two grams in the alphabet and do the same as in the aforementioned solution 
153,This is a simple implementation problem Let s calculate two values for each i from 1 to n cnt i the number of occurrences of i in a and idx i any position of i in a Then let s iterate through i from 1 to n and if cnt i 1 just print idx i because if it is the only such element then we found the winner If we didn t find any such element we have to print 
154,There will be three cases in total let s consider them on two types of candies then we will eat candies in this order then we will eat a candy of the type and then we will eat in this order almost as in the case above then we will eat a candy of the type but there will still be more of them than candies of the type and we will have to eat a candy of the type again So the answer is Now we prove that it is enough to check these conditions on two maximums of the array If the third condition is true the answer is obvious Otherwise we will by turns eat candies of the two maximum types until their number is equal to the third maximum after which we will by turns eat candies of these three types and so on 
155,The simple simulation works here while there is at least one inversion such a pair of indices and that we can fix let s fix it we can fix this inversion if If there are inversions but we cannot fix any of them the answer is Otherwise the answer is There is also a solution it is obvious that we have some segments in which we can change the order of elements as we want And it is also obvious that we cannot move elements between these allowed segments So each of them is independent of each other We can just find all these segments of indices using two pointers and sort them independently Then we just need to check if the array becomes sorted Time complexity is or 
156,The person with the number looks at the person with the number so the count of people standing to the left of between and is equal to the count of people standing to the right of between and Therefore both counts are equal to hence must be a solution of the equation The only solution of the equation is Let s check that in the circle of people can occur the numbers and i e let s check that If it s false there s no solution output Since the person with the number looks at the person with the number the condition must be met Let s solve the equation for There are two solutions We can output any of such that It s easy to prove that exactly one of the solutions meets the condition 
157,We can notice that the answer is the number of zeros between the leftmost occurrence of and the rightmost occurrence of Why is it true Let s take the leftmost maximum by inclusion segment of and just shift it right We can see that using this algorithm we will do exactly described amount of moves and there is no way improve the answer 
158,The first observation is that we can always try to find the palindrome of length otherwise we can remove some characters from the middle until its length becomes The second observation is that the palindrome of length is two equal characters and some other maybe the same character between them Now there are two ways find the pair of equal non adjacent characters in or do it in for each character we only need to consider its left and right occurrences 
159,In this problem you just need to implement what is written in the problem statement For the kid the following pseudocode will calculate the answer indices of the array and its values are indexed pos p i ans 1while pos i ans 1 pos p pos 
160,The solution to this problem is just the implementation of what is written in the problem statement Let s carry the array which shows the current smartphone screen When we receive the new message from the friend with ID let s do the following sequence of moves Firstly let s try to find him on the screen If he is found just do nothing and continue Otherwise let s check if the current number of conversations is If it is so then let s remove the last conversation Now the number of conversations is less than and the current friend is not shown on the screen Let s insert him into the first position After processing all messages the answer is just the array 
161,Let s calculate the number of letters which occur exactly once in the string and letters that occur more than once and respectively If a letter occurs more than once one of its occurrences may be painted in red and another one may be painted in green We cannot paint all other occurrences because there will be two equal letters painted in one color but this is unacceptable by the statement So there are no more than occurrences of letters that occur more than once to be painted in red Let s select such occurrences and paint them We need to paint additionally the letters which occur exactly once by meeting the same conditions as we meet painting the whole string There s no way to paint these letters and not meet the first two conditions So we must select the maximal count of the letters so that we will be able to paint some set of remaining letters in green so that the number of red letters will be equal to the number of green letters This number is equal to So the final answer is equal to 
162,In this problem we can notice that when we calculate the answer for the kid we also calculate the answer for kids and so on So we can a little bit modify the pseudocode from the easy version to calculate answers faster pos p i ans 1cycle i while pos i cycle append pos ans 1 pos p pos for el in cycle res el ansAnd of course we don t need to run this while for all elements for which we already calculated the answer Total time complexity is because you ll process each element exactly once 
163,The idea of this solution is the same as in the easy version but now we need to do the same sequence of moves faster We can notice that the smartphone screen works as a queue so let store it as a queue When the new message appears we have to check if the friend with this ID is in the queue already but we need to check it somehow fast Let s use some logarithmic structure that stores the same information as the queue but in other order to find add and remove elements fast In C this structure is So let s check if the current friend is in the queue and if no let s check if the size of the queue is If it is so then let s remove the first element of the queue from it and the same element from the set also Then add the current friend to the queue and to the set After processing all messages the reversed queue the queue from tail to head is the answer to the problem Time complexity And don t forget that and other standard hashmaps can work in linear time in the worst case so you need to redefine the hash function to use them You can read more about this issue here https codeforces com blog entry 62393 
164,Since we must use exactly colors each element that occurs in the sequence may have no more than painted occurrences for each element its occurrences where is the number of all its occurrences in the sequence Let be a sequence of all elements that occur in the sequence but in the sequence they will occur only once Let s create a indexed array in which we will add indices of occurrences of in the sequence then the selected occurrences of and so on till Currently is a set of occurrences which wonderful coloring is a wonderful coloring of the whole sequence because if we want to paint an occurrence outside we can do it only by selecting an occurrence of the same element in which we will not paint so that no more than occurrences will be painted We must use exactly colors and paint for each color an equal number of occurrences hence if we want to paint all occurrences from we must remove from it the minimum number of occurrences so that the size of the array will be divided by i e remove the number of occurrences equal to the remainder of dividing the size of by We can remove any occurrences for example let s delete it from the suffix of Currently we can paint all occurrences from using the following rule the occurrence we must paint in the color with a number where takes the remainder of dividing the left operand by the right operand So all occurrences from will be painted and all colors will be used Since all occurrences of one element belong to one subsegment of and their number isn t greater than they will be painted in different colors It may be so that the array before painting will be empty In this case the wonderful coloring of doesn t contain any painted element 
165,First let s find such positions i 1 le i le n such that s i ne symbols in symmetric positions are uniquely determined If s n i 1 then s n i 1 s i If s i ne s n i 1 then at the end we will not get a palindrome in any way so the answer is Note that after such a replacement the remaining characters are split into pairs except maybe the central one If the center character is then it is necessary to put the character if a is odd or if b is odd if neither a nor b is odd then the answer is Now the remaining characters are split into pairs i e if s i then s n i 1 This allows the remaining characters and to be replaced greedily If s i and a 1 then s i s n i 1 and decrease a for 2 If s i and b 1 then s i s n i 1 and decrease b for 2 Otherwise the answer is 
166,Let the lowercase Latin letters be indexed from to There are exists at least two different solutions If exit the program Otherwise count the number of occurrences of each letter from to Let it be Now find the alphabetically smallest letter that will be in the resulting string It can be done as follows iterate over all from to and if then subtract it from otherwise will be the smallest letter that will be in the resulting string But we possibly need to remove some number of its leftmost occurrences It is obvious that letters smaller than will not appear in the resulting string Also the leftmost occurrences of letter will be removed Now let s iterate over all letters in string from left to right and construct the resulting string If the current character of let it be is smaller than then do nothing If is greater than then add it to Otherwise If then decrease by one otherwise add to The time complexity is Another solution is the following Let s carry the vector of pairs where is the th character of and is its position If we sort this vector with the standard compare function it is easy to see that the first elements of this vector will be removed from the input string Then if we will sort the last elements of this vector by its positions in the input string in increasing order we will obtain the answer The time complexity is 
167,Firstly let s extract maximum by inclusion segments of the array that consists of the numbers with the same sign For example if the array is 1 1 2 1 5 2 1 3 then these segments are 1 1 2 1 5 2 1 and 3 We can do it with any two pointers like algorithm The number of these segments is the maximum possible length of the alternating subsequence because we can take only one element from each block And as we want to maximize the sum we need to take the maximum element from each block Time complexity O n 
168,Let s sort all values in non decreasing order Then we can use two pointers to calculate for each student the maximum number of students such that This is pretty standard approach We also can use binary search to do it or we can store for each programming skill the number of students with this skill and just iterate from some skill to and sum up all numbers of students 
169,We can think that it is given a bipartite graph Boys and girls are the vertices of the graph If a boy and a girl are ready to dance together then an edge is drawn between them In this graph you need to select two edges that do not intersect at the vertices Let the number of edges included in the vertex Iterate over the first edge It will block of other edges all adjacent to vertex to vertex but the edge will be blocked twice All non blocked edges do not intersect with at the vertices So you can add to the answer 
170,It is intuitive and provable that the best strategy is to move each figure to the center cell Now with some paperwork or easy observations we can notice that we have exactly cells with the shortest distance cells with the shortest distance cells with the shortest distance and so on So we have cells with the shortest distance So the answer is It can be rewritten as so we can just calculate the sum of squares of all integers from to using loop or formula and multiply the answer by Time complexity or 
171,This is just an implementation problem Firstly let s fix it can be in range find the maximum number of boats we can obtain with this and choose the maximum among all found values To find the number of pairs let s iterate over the smallest weight in the team in range Let this weight be Then because the sum of weights is the biggest weight is And the number of pairs we can obtain with such two weights and the total weight is where is the number of occurrences of in And the additional case if is even we need to add Don t forget that there is a case so you need to assume that these values are zeros 
172,Let be the number of integers from to divisible by We can notice that because we write down only the last digit of each number divisible by then the length of the cycle of digits does not exceed In fact we can always suppose that it is because for all from to So let for all from to Then the answer is 
173,Let imagine our shelf as an infinite array Let s carry the rightmost free position from the left of our shelf let it be and initially it equals to and the leftmost free position from the right of our shelf let it be and initially it equals to Also let s carry the array of length where will be equal to the position in our imaginary array of the book with a number Let s put the first book to the position Also let s save that where is the number of the first book equals to How will change and will become and will become Now let s process queries one by one If now we have the query of type with a book with a number then let s set and set The query of type can be processed similarly Now what about queries of type The answer to this query equals to where is the absolute value of 
174,Let is the greatest common divisor of all elements of the array You can find it by Euclidean algorithm or some standard library functions Then the answer is just the number of divisors of You can find this value in 
175,Firstly about the problem description Vova really needs to i e play Exactly turns Among all possible ways to do it he need choose one where the number of turns when he this is the first type turn is Suppose the answer is Then the charge of the battery after turns will be If this value is greater than then the answer is Otherwise we need to replace some turns when Vova with turns when Vova The charge of the battery will increase by avfter one replacement We have to obtain with some replacements The number of turns to do it is equals to where is divided by rounded up If then the answer is Otherwise the answer is 
176,First let s note that we will have a transition from to only once otherwise it turns out that first the picture disappeared then it appeared and disappeared back but we can consider that a friend in the middle who answered lied to us but this is not true because even before him the picture disappeared So we need to find this transition Since we can also meet we find the index of the leftmost in case of absence we take and mark it as and the index of rightmost in case of absence we take and mark as Answer the number of indices between them inclusive because only they could lie There could not be a thief to the left of since either the friend under the index lied or the picture was not stolen before There could not be a thief to the right of since either the painting had already been stolen in the presence of s friend or it was he who lied 
177,We can transform the problem as follows Let We need to find an array so that the sum of elements in it is not greater than all elements are positive integers and the number of different elements is the maximum possible Suppose we need different elements in What can be the minimum possible sum of elements in It s easy to see that should have the following form This array contains exactly different elements these different elements are as small as possible so their sum is as small as possible and all duplicates are s So if the sum of this array is not greater than then it is possible to have the number of different elements in equal to The rest is simple We can iterate on find the maximum possible construct the difference array and then use it to construct the array itself 
178,Let s sort the array in descending order of the values of its elements Then let s create a logical array where will have the value if we already got element of the permutation we are looking for and the value otherwise We loop through the elements of the array and assign We ll divide by as long as it exceeds or as long as is If it turns out that then all the numbers that could be obtained from have already been obtained before Since each element of the array must produce a new value from to the answer cannot be constructed output Otherwise assign a value of this means that the number which is an element of the permutation we will get exactly from the original number After processing all elements of the array we can output 
179,If all the piranhas have the same size then the answer is Otherwise there are at least two different sizes of piranhas and the answer always exists Claim that the answer is such a piranha with the maximum size that one of the adjacent piranhas has the size less than a maximum Why is it true and why the answer always exists First if the piranha with the maximum size eats some other piranha it becomes the only maximum in the array and can eat all other piranhas Why is there always such a pair of piranhas Let s change our array a bit replace every maximum with and every non maximum with There is always some pair or pair in such array because we have at least two different elements 
180,Let s consider two cases If then the answer is because we can make opposite moves to the Slavik s moves and it always will reduce durability of some door so at some point we will reach the state when all doors will have durability Otherwise and we have to realize the optimal strategy for us If we have some door with durability then let s break it immediately why shouldn t we do this If we don t do it then Slavik will repair this door during his move So what Slavik will do now He will repair some door Which door he has to repair Of course the one with durability because otherwise we will break it during our next move So we can realize that doors with durability are not interesting for us because Slavik will make opposite moves to our moves And what is the answer if the number of doors with durability equals to It is 
181,Let s calculate the array of triples Triple means that the sum of the sequence without the element at position will be equal to Triples can be easily calculated in a following manner for each sequence find its sum then iterate over all its elements and subtract each of them one after another Now sort array with the standard compare function Finally the answer is if and only if there exist two adjacent elements with equal sums and different sequences it is very easy to see So if we find such a pair then the answer will be otherwise the answer will be Time complexity of the solution is 
182,In this problem we need to print the permutation without fixed points without values but some values are known in advance Let s consider the permutation as a graph We know that the permutation is the set of non intersecting cycles In this problem we are given such a graph but some edges are removed How to deal with it Firstly let s find isolated vertices in the graph Let its number be If then all is ok and we skip the current step If then let s pin this isolated vertex to any vertex to which we can pin it Otherwise and we can create the chine consisting of all isolated vertices Now and we can finally construct the remaining part of the graph We can notice that we have the same number of vertices with zero incoming and zero outcoming degrees And because we got rid of all possible loops in the graph we can match these vertices as we want Time complexity 
183,The only observation we need is that we don t need to jump left at all This only decreases our position so we have less freedom after the jump to the left Then to minimize we only need to jump between the closest cells So if we build the array where is the position of the th cell from left to right indexed then the answer is Time complexity 
184,We will act greedily we will make an array consisting of elements in which we will mark if the letter is already encountered in the string and otherwise In the variable we will store the length of the even string that can be obtained from We will go through the string by executing the following algorithm if mark if then we already have a pair of repeating characters to add to an even string add to the number and clear the array Clearing is necessary because both characters that will make up the next pair must be in the string after the current character In other words if the last character in the current pair was then the first character in the new pair can be where Then we calculate the answer as 
185,The first part calculate the sum of the whole array be careful it can be The second part let s maintain an array of size where will be equal to the number of elements in the given array equals to The third part iterate over the array let the current position be Set make If is even and then the index is otherwise it doesn t And after all make and set 
186,The following greedy solution works let s iterate over all characters of the string from left to right and if the last block of two consecutive characters in the resulting string is full just add the current character to the resulting string otherwise add this character if it is not equal to the first character of the last block And don t forget about the parity of length remove last character if the length is odd 
187,Let the number of rations of fish food be the number of rations of rabbit stew be and the number of rations of chicken stakes be so we have an array consisting of elements Let be the maximum number of full weeks cat can eat if the starting day of the trip can be any day of the week The value of is Let s subtract the value from and from and We can see that we cannot feed the cat at least one more full week So the final answer is where Now it s time for some good implementation Of course you can try to analyze all cases and handle them using ifs or something similar but I will try to suggest you a good enough way to implement the remaining part of the problem Let s create an array of length where means the type of the food cat eats during the th day of the week for fish food for rabbit stew and for chicken stake It will be Now let s iterate over the day we will start our trip Let it be For the current starting day let be the number of rations cat has eaten already initially it is zero be the current day of the trip initially it is and the array be the copy of the array Then let s do the following sequence of the operations while is greater than zero decrease by one increase by one and set take it modulo and add one After this cycle we can update the answer with the value of 
188,It is pretty intuitive that we firstly need to do all increments and only then copy numbers because otherwise we can swap the order of moves and the sum will not decrease You could notice that the answer does not exceed so we can just iterate from to and fix the number we will copy Let it be Then we need moves to obtain it and also need moves to get the enough number of copies So we can update the answer with this number of moves Time complexity per test case Actually the required number is always pretty near to so it is enough to try a few options in range to get the optimal answer This is solution 
189,Let s consider some cases If there are letters a in string then the moves can be performed endlessly If itself is equal to a then the string won t change so the answer is Otherwise the length of is least so string will be increasing in length after each move and the answer is If there are no letters a in string then the resulting string is only determined by whichever letters a we chose to replace with That s because once we replace a letter a with string we can do nothing with the new letters anymore We can actually imagine that is equal to b and the answer won t change Now it s easy to see that the answer is equal to the number of strings of length consisting only of letters a and b There are two options for each position and there are positions so the answer is Overall complexity per testcase 
190,Let s call a set of cells being filled from the topmost row to the leftmost column a E g the st layer consists of the single number the nd layer consists of the numbers and the rd layer consists of the numbers and etc The number of cells in layers forms an arithmetic progression The first layer consists of cells the th layer consists of cells The minimum number in the th layer is equal to the sum of sizes of all layers from the st to the th plus Suppose that belongs to the th layer Consider the value of Polycarp fills exactly cells on the th layer before he starts filling the cells from the right to the left i e while he goes down Therefore if the number belongs to the th row and the th column Otherwise the number belongs to the th row and the th column Consider a way to find the coordinates of a given number Let s iterate by the layer number to which given the number belongs calculating the values of and going to the next layer let s calculate the next layer parameters as follows The iteration must be stopped if the layer number is such that Using the values of and we can calculate the given number s coordinates in the described way in The total time of calculating the coodrinates for one given is where is the number of the layer to which the given belongs Let s represent the value of as hence Therefore the coordinates of one number may be calculated in At the same time as it follows from the formulas the layer number can be calculated as follows the square root of rounded up To avoid accuracy problems you can calculate the value using a loop 
191,This task is very straight forward implementation problem So we can iterate over all segments of the given array calculate their sum and if the length of the current segment is not less than k try to update the answer with the mean of this segment Overall complexity is O n 2 
192,Let be the number of the occurrences of the letter in the word minus the number of the occurrences of all other letters in total Since for each two words and the number of the occurrences of a letter in the word is the sum of the numbers of its occurrences in and the equality is true means the concatenation of and Consider a sequence of words A story consisting of words is interesting if and only if there s a letter such that it exactly means that there s a letter which occurs more times than all other in total So we are interested in searching for a letter such that exists a positive integer a maximal number of words such that Suppose we have a set of words that form an interesting story and where is the letter having more occurrences than all other letters in total Suppose we can add to it one of few words We had better add a word such that is maximal to be able to add more words in the future So the problem has the following solution for each letter of the Latin alphabet and for each word let s calculate Then let s iterate over all letters take a sequence and sort it in descending order Let s initialize an interesting story by a set of a single word corresponding to the first element of the sequence If there s no word such that then there s no non empty interesting story containing some words of the given set Otherwise let s take the next elements of the sequence sequentially until the sum of over all taken words is greater than zero Let s select a letter such that the corresponding taken set is maximal over all letters Finally we should print the set s size The solution consists of two phases the calculation of all works in where is the alphabet s size is the lengths of a string and building a maximal interesting story for each letter sorting and a greedy algorithm 
193,It s worth knowing that ways like and have the same cost That is first you need to understand the letter on the first tile and the last one conditionally the letters and Then you just need to find all such tiles on which the letters are between the letters and inclusive We go through each letter from to and for each letter we visit every tile that has a given letter but we must not forget to start exactly at tile and end at tile 
194,In this problem you can do the following thing firstly let s sort our array Let will be the answer Then you have two cases if then otherwise for 0 indexed array Then you need to calculate the number of the elements of the array that are less than or equal to Let it be Then if or then print otherwise print 
195,We should use that the letter queries are given in increasing order of room numbers We will store in a variable the number of rooms in already considered dormitories this variable should have 64 bit type and in a variable we will store the minimum number of dormitory where the room from the current letter possibly is Initially and We will iterate through the letters Let the current letter should be delivered to the room While we increase by and increase by one So we got the dormitory number where room is It only remains to print two integers the dormitory number and the room number in this dormitory 
196,Let be the result of the game if we chose as the starting position Let s look at some starting position After making a move from it we will get points and move to the position continuing the same game This means that by choosing the position we can assume that we will get a result more than if we chose the position Formally Let s calculate all the results of and store them in an array Let s start iterating through the positions from the end then being in the position we will know for all Using the formula above we can calculate in one operation It remains only to choose the maximum of all such values 
197,Let be the number of subsequences be the number of subsequences the number of subsequences and so on and is the number of completed subsequences Let s iterate over all elements of in order from left to right If the current element is then let s increase by one we staring the new subsequence Otherwise it is always better to continue some existing subsequence just because why not If the current element is then we can continue some subsequence if it is then we can continue some subsequence and the same for remaining numbers Let be the indexed position of the current element of in list Then the case is described above and in other case if then let s set and we continue some of existing subsequences The answer can be calculated as after all iterations 
198,Consider the maximum element a mx of the good array a of length k Then we can notice that the array a looks like a 1 le a 2 le dots le a mx ge dots ge a k 1 ge a k And this is pretty obvious that if the array doesn t have this structure then it isn t good you can see it yourself So we need to find the longest such suffix It s pretty easy doable with pointer initially the pointer pos is at the last element Then while pos 1 and a pos 1 ge a pos decrease pos by one If we re done with the previous step we do the same but while pos 1 and a pos 1 le a pos The answer is pos 1 
199,Intersection of some segments is If this segment has its left bound greater than its right bound then the intersection is empty Removing some segment makes the original sequence equal to That can be split up to a prefix of length and a suffix of length Intersections for them can be precalced separately and stored in some partial sum like arrays Finally you have to iterate over the position of the removed segment and calculate the intersection of prefix and suffix without this segment Overall complexity 
200,Let s iterate over the length of the first segment of the split Having fixed it we actually fixed the sum that needs to be collected on all other segments Since each element must belong to exactly one segment we can build other segments greedily If we have found a solution we will remember the length of the longest segment in it and try to update the answer We have possible lengths of the first segment for each of which we greedily built the answer for Thus the asymptotics of the solution will be 
201,Note that the order of numbers in the array does not affect anything If you swap two elements in the original array the set of elements at each step will not change in any way Let s sort the original array and denote it by We denote by the state of array after applying operations of The minimum element in is so the elements of array will be equal to and therefore the minimum of them will be Constructing an array we can notice that its elements are equal to We know that the elements of are the difference between corresponding elements of the array and so Thus the elements of the array are the differences between elements of starting with third and the minimum of which is It is not difficult to show in a similar way for example by induction that the elements of are equal to the minimum of which is So the candidates for the answer are simply differences of adjacent elements of the array Indeed if we look at it will undergo changes as follows You can notice that the minimum elements starting with after the first operation are exactly and respectively Thus to solve the problem it was sufficient to sort the array in ascending order then take the maximum of the original first element and the differences of all adjacent elements 
202,Let s use the greedy solution we will go through the digits in decreasing order If the sum of we need to dial is greater than the current digit we add the current digit to the end of the line with the answer Note that in this way we will always get an answer consisting of the minimum possible number of digits because we are going through the digits in descending order Suppose that the resulting number is not optimal Then some digit can be reduced and some digit that comes after it can be increased in order to save the sum we can not increase the digit before it as then we get a number greater than the current one Two variants are possible We want to increase the digit to but then it becomes equal to the digit following it or exceeds the value Then we can t increment that digit Otherwise in the first step we can get instead of but since we are going through the digits in decreasing order we cannot get the value of in that case Contradiction 
203,Let s go from left to right over characters of maintaining the current bracket balance for the position the balance is the number of opening brackets on the prefix till the th character minus the number of closing brackets on the same prefix If the current balance becomes less than zero then let s just take some opening bracket after the current position it obviously exists because the number of opening equals the number of closing brackets and move it to the beginning so the negative balance becomes zero again and the answer increases by one Or we can move the current closing bracket to the end of the string because it leads to the same result Time complexity 
204,It is easy to see that any garland has one of the following patterns We can hard code all all this patterns or iterate over all these permutations of letters using three nested loops or standard language functions We can calculate for each pattern the cost to obtain such pattern from the given string and choose one with the minimum cost 
205,Note that is the only case where there is no answer For other cases consider the following construction Let s say that the cell is white if is an even number otherwise we will say that the cell is black Let s arrange the cells so that all white cells are first and if the colors are equal the cells will be compared lexicographically Arrange numbers from to in ordered cells For example for the following matrix will be constructed 
206,The problem can be divided into two classic ones Count the number of pairs Count the number of pairs Let be the answer to the first problem and be the answer to the second problem Then is the answer to the original problem The new problem can be solved by binary search Iterate over the first element of the pair Then you need to count the number of elements such that If you sort the array this value can be calculated by running a single binary search 
207,What does it mean that no pair of adjacent elements should have the same color It means that either all elements on odd positions are blue and all elements on even positions are red or vice versa So we need to check these two cases Let s try to solve a case when we have to find a number such that are divisible by and are not What does it mean that divides all of the numbers It means that divides the where represents the greatest common divisor Let s calculate this using Euclidean algorithm or some built in functions in Okay now we need to check all divisors of the and find if any of them does not divide So we have to factorize and generate all of its divisors or do we In fact if divides any of the numbers then every divisor of also divides that number So the only two numbers we have to check as canditates for the answer are and 
208,The solution is that if we can do something let s do it It doesn t make sense not to act because neither adding a new row nor modifying an existing one can prevent the existing row from being changed in the future Therefore we will iterate over the actions and eagerly act Monocarp or Polycarp Let s create two pointers and in arrays and index of possible action of Monocarp and Polycarp and the current length of the file Suppose that or on current iteration Then we take the appropriate zero element and increase by one We can do that because appending a new line cannot make a new answer prefix incorrect if the previous prefix was correct Suppose that and If and then there is no answer because we can potentially do only two actions and both make the answer incorrect If one number is greater than and the other is less than or equals then we take the one that less than or equals If one of the sequences or ends then only one potential action needs to be checked at each iteration 
209,Basically what does the matrix being palindromic imply For each values in cells and are equal all zero indexed You can easily prove it by reversing the order of rows or columns and checking the overlapping cells in them Thus all cells can be split up into equivalence classes The even case is simple all classes have size The odd case has classes of sizes and Let s fill the classes one by one Obviously the order between the classes of the same size doesn t matter I claim that filling the classes in order in sizes construct the answer if any exists The key observation is that each next size is divisible by the previous one The implementation can come in lots of different forms and complexities Mine works in you can refer to it in attachment 
210,We can consider all tries independently During the th try we press first buttons so it makes on the prefix of length So the th character of the string will be pressed the number of plus times We can use sorting and some kind of binary search to find this number for each character but we also can build suffix sums to find all required numbers We can build suffix sums using the following code vector int cnt n for int i 0 i m i cnt p i for int i n 1 i 0 i cnt i 1 cnt i So as you can see the th element of will add in each position from to So we got what we need After that we can calculate the answer for each character in the following way vector int ans 26 for int i 0 i n i ans s i a cnt i 1 Time complexity or 
211,Let s see how the water can flow when it meets the pipe of type or and in the other case When the water meets the pipe of type or we cannot do anything but let it flow to the right of the current cell Otherwise if the current pipe is curved then there are two cases if the pipe on the same position but in the other row is not curved then the answer is because the water has to change the row but we cannot turn the next pipe to allow it to move to the right or to the left So the current pipe is curved and the pipe on the same position in the other row is also curved let s change the row and move to the right it is obvious that we never need to move to the left So the answer and the sequence of pipes is uniquely defined by types of pipes If after iterating over all positions we didn t meet the case of and the current row is second then the answer is 
212,This problem has a very easy idea but requires terrible implementation Firstly let s place all platforms as rightmost as we can Thus we will have the array in which the first elements are zeros and other elements are Now let s start the algorithm Firstly we need to jump to the position or less If we could jump to the position then we don t need to jump to some position to the left from But if we cannot do it let s take the leftmost platform to the right from the position and move it in such a way that its left border will be at the position Now we can jump to the position and then jump by right to reach the position Let s repeat the same algorithm and continue jumping If after some move we can jump to the position at least then we are done Time complexity but I m sure it can be implemented in or 
213,The maximum element is always added last so if it is not in the first or last position then there is no answer Let us prove that if the permutation has its maximum element in the first or last position then after actions we can get an expanded permutation Indeed the maximum element will be added last at the desired end and all the others will be added in reverse order Then if the answer exists it is sufficient to simply unfold the permutation 
214,Let s Thus It means that the sequence of partial sums is the required permutation if we do to each element The value of is unknown yet Find such that is minimum Thus Exactly this value will change to be after you add So add to each element of and check that now it is a permutation Probably you need to use to avoid possible integer overflows 
215,First of all let s analyze how can we calculate the minimum number of powers of two needed to get as the sum We can use binary representation of each bit in it which is equal to becomes a summand in the answer Firstly if the number of summands is greater than then the answer is Okay what if we don t have enough summands Every summand can be broken down into two summands equal to Let s maintain all summands greater than somewhere stack array queue multiset anything you want and pick an arbitrary summand and break it into two until we have exactly summands If then this process will terminate since we will have some summand to pick until all of them are equal to 
216,The first observation if we will take two strings of length then we can restore the initial string Why Because there are two possible options when the first string of length is a prefix and the second one is the suffix and vice versa Let s write a function which will check if the first string can be the prefix of the guessed string and the second one can be the suffix After we write this function we can run it two times depending on the order of strings of length and find any suitable answer If the first string is the prefix and the second one is the suffix then the whole string indexed where is the concatenation of strings Let s check if we have all prefixes and suffixes of this string in the input We can easy do it with two nested loops and some boolean array which can say us if some string is already used or not Firstly let s iterate over the length of the prefix or suffix and inside let s find any string from the input matching to the current prefix or suffix If we find all strings then the current string is one of the guessed and we can print the answer 
217,When Kristina writes sequences on the whiteboard she removes an element with each index exactly once Thus the first element of the permutation will be deleted only once on the first step All sequences except one will start with itTo solve the problem find a sequence such that it starts with some element all sequences other than this one begin with some element Then this permutation will describe the sequence of numbers remaining after removing the th element and the first element itself will be equal to the number The initial permutation will look like 
218,Suppose Let s try to minimize and maximize Let be the minimum divisor of greater than Then let be the minimum divisor of that isn t equal and If isn t equal and then the answer is otherwise the answer is Time complexity per query 
219,To solve the problem you can build an array as follows at Let s show that from the constructed array we can get an array equal to the original array If then If then So at If and then If then If then By the construction of the array it is not possible that and So If then If then So We get that for so and array is built correctly 
220,Accordingly as it was said in the task we put all tasks into the queue in the order of their arrival then we fix the time at the beginning as So while there is a task in the queue we proceed as follows Take the task from the queue Take as time the maximum from the current and from the arrival time of the task We subtract the current time from the time when the task was done Replace the current time with the time the task was done If there is a task in the queue go to item 
221,In fact we have some restrictions on axis and axis for example if some robot stays at the position and cannot move to the left then the answer point should have So we can take the minimum among all coordinates of robots that cannot go up and save it into maximum among all coordinates of robots that cannot go down and save it into minimum among all coordinates of robots that cannot go right and save it into and maximum among all coordinates of robots that cannot go right and save it into Initially So these restrictions are describe some rectangle possibly incorrect with or Let be the bottom left point of this rectangle and be the top right point of this rectangle In case if this rectangle have or the answer is Otherwise this rectangle describes all integer points which can be reachable all robots and you can print any of them 
222,Let s solve the problem using a linear search Let be the number of mice we are trying to save Then it is more efficient to save mice such that they are the closest ones to the hole Let be the distance from the th mouse to the hole Denote Let s prove that these mice will be saved if and only if The necessary condition Suppose we can save the mice and Since only one mouse can be moved in one second the following will happen of mice will already be saved and one mouse will have to be saved When it s been seconds then the distance from the cat to the hole will be equal to and the distance from the mouse to the hole will be equal to since all other mice are already in the hole their distances to the hole are equal to so the sum of the distances from all mice to the hole at the current time is exactly equal to the distance to the hole from one remaining mouse Since the distance from the mouse to the hole is greater than or equal to the distance from the cat to the hole But this cannot be because both the mice and the cat move only to the right and all mice met by the cat are eaten So Sufficient condition Suppose If then all the mice are already in the hole i e they are saved Suppose Let s move any mouse then the cat Suppose the cat ate at least one of the mice This mouse is definitely not the one that was moved Then the distance from it to the eaten mouse was equal to i e the distance from it to the hole was equal to the distance from the eaten mouse to the hole plus The distance from the moved mouse to the hole was at least So where is the distance from the eaten mouse to the hole is the distance from the moved mouse to the hole So but it s false Therefore none of the mice will be eaten on the first move Then the distance from the cat to the hole will be equal to the total distance from the mice to the hole will be equal to i e now we have to solve a similar problem for smaller and So will be gradually decreased to while no mouse will be eaten So if all the mice will be saved Thus to solve the problem we need to find the maximum such that the sum of the distances from the nearest mice to the hole is less than 
223,Firstly let s remove all consecutive equal elements just keep one occurrence of each such element For example the array 1 1 2 3 3 3 2 becomes 1 2 3 2 Now the answer for each a i is the number of its occurrences plus one Why is it so Because we need to remove all segments of elements between every pair of consecutive occurrences of a i The number of such segments is the number of occurrences of a i minus one There is also a segment before the first occurrence of a i and a segment after the last occurrence of a i But the first segment doesn t exist for the first element and the last segment doesn t exist for the last element So after removing consecutive elements let s calculate for each a i the number of its occurrences plus one subtract one from the value of the first element and from the value of the last element Then the answer is the minimum among these values for all a i 
224,Let be the number of even numbers in the array and be the number of odd numbers in the array Note that if the parities of and of do not equal then the answer does not exist Otherwise we consider two cases and are even numbers Then all numbers can be combined into pairs of equal parity and are odd numbers Then you need to check whether there are two numbers in the array such that the modulus of their difference is If there are two such numbers then combine them into one pair and will decrease by and become even then the solution exists as shown in the previous case 
225,Let s split a given string into blocks of consecutive zeros Then in each such block you can independently put the maximum number of people who fit in it But there are three cases to consider If the current block is not the first and not the last then there are ones at the border and this means that the first tables of the current block and the last are prohibited Therefore remove these zeroes from the string If the current block is the first then the one is at the end and you need to delete the last zeros If the current block is the last then in the beginning there is one and you need to delete the first zeros Also as a separate case you need to consider a string consisting only of zeros Then there is exactly one block from which you do not need to remove zeros Now all the tables in each block are free then in each block we can put Sum these values over all blocks 
226,If we will no compress songs the sum of the sizes will be equal Let it be Now if we will compress the th song how do will change It will decrease by This suggests that the optimal way to compress the songs is the compress it in non increasing order of Let s create the array of size where Let s sort it in non increasing order and then iterate over all from to If at the current step we print and terminate the program Otherwise we set After all we have to check again if then print otherwise print Time complexity is because of sorting 
227,In this problem we need to find and such that and Since and are positive and are also positive Hence Therefore the number can be iterated from to Since in all tests then For each you can find by the formula This is a positive number It remains to check that is an integer 
228,You should delete only such for which there is no such that is a power of For each value let s find the number of its occurrences You can use simple standard data structure Do for each element Now you can easily check that doesn t have a pair Let s iterate over all possible sums and for each find calculate If for some or then a pair exists Note that in C solutions it s better to first check that is a key in and only after it calculate This needs to be done since in C when you access a key using the square brackets operator a default mapping key value is created on the absence of the key This increases both the running time and the memory consumption 
229,Let s iterate from left to right over the digits of If the current digit is either or then we can set or correspondingly There are no better choices And if the current digit is then the optimal choise is to set and What happens after the first occurrence of Because of this choice is greater than even if all remaining digits in are So for each set and and print the answer The case without is even easier and in fact we handle it automatically 
230,First let s consider the cases when the answer exists If then the thermostat is already set up and the answer is else if then it is enough to reconfigure the thermostat in operation else if exist such temperature that and then you can configure the thermostat in operations If such exists between and we can chose one of bounds or we need to make operations if times if we cannot reconfigure through one of the boundaries as above but we can through both or If we can t get the temperature in one of these ways the answer is 
231,Since the given array consists of positive integers for each value of there can be at most one value of such that We can use binary search on the array of prefix sums of to find the correct value of given that it exists If it does exist and this is a candidate solution so we store it Alternatively we can use the two pointers trick when increases cannot decrease Be careful to use 64 bit integers to store sums Overall complexity is or 
232,For each painted cell we will determine whether it can be part of some tick of the allowed size If some of the cells cannot be a part of any tick the answer is obviously Otherwise let s match each colored cell with an arbitrary valid entirely contained in the field under consideration and of size tick containing it Let s draw all such ticks then the following holds no empty white cell of the field will be painted since only ticks that do not contradict the field in question have been considered every colored cell of the field will be covered by at least one drawn tick at least the one we matched it with Basically this process gives us a field in which the set of painted cells matches the data in the input which means that the field given in the input could have been obtained in particular in the way described above and the answer is In order to check that all painted cells are parts of some ticks let s go through all possible ticks of size and for each tick mark all the cells included in it If there is at least one unmarked painted cell in the end it can t be a part of any valid tick and the answer is To consider all possible ticks we can iterate through all their possible center cells that is all the painted cells Since smaller ticks are subsets of larger ticks with the same center cell it is sufficient to find the maximal size tick that can be constructed from that center cell So for each painted cell we aim to find the maximal possible size of a tick with its center in this very cell Let us now consider a painted cell as a possible center of some tick By the definition of a tick this cell can be a center of a tick of size if for all from to both cells and exist are not out of bounds and are painted Let s iterate through from to and stop when the described condition is no longer satisfied The largest for which the condition is still satisfied gives us the maximum possible size of a tick with its center in Now if then such a tick is valid and all the cells included in it should be marked Otherwise it could not have been drawn and none of its cells should be marked After a complete check of all possible ticks in a given field either there will be no unchecked painted cells and then the answer is or at least one painted cell is not covered by any valid checkbox and then the answer is The time complexity is 
233,Let s note that for each second of color in the traffic light we need to find the rightmost green time and then find the largest distance between color and the nearest green Also let s not forget that traffic light states are cyclical To get rid of cyclicity you can write the string twice and for each cell of color from the first half find the nearest green color thus we solved the problem with cyclicity And now we can just follow this line from right to left and maintain the index of the last occurrence of green If we encounter color then we try to update our answer where is our answer is the nearest time that green was on color current time 
234,To solve the problem we will use the dictionary Each station will be matched with a pair of integers the indices of its first and last entries in the route Then we will sequentially process queries If at least one of the stations or is missing in the dictionary the answer is Otherwise check If the index of the first entry of station in the route is strictly less than the index of the last entry of station in the route the answer is Otherwise the answer is 
235,Let s count the number of occurrences of each element in the Because the maximum possible element is it can be done without any data structures Then let s check if is greater than for some from to and if it is then the answer is because this element should occur at least twice in one of the sequences Now let s output the increasing sequence The number of elements in it is the number of elements such that Let s iterate from left to right print the suitable elements and decrease their The number of elements in the decreasing sequence is just the number of elements with non zero So let s iterate from right to left and just print suitable elements 
236,Let the number of students with the skill is and the number of different skills is Then the size of the first team can not exceed and the size of the second team can not exceed So the answer is not greater than the minimum of these two values Moreover let s take a look at the skill with a maximum value of Then there are two cases all students with this skill go to the second team then the sizes of teams are at most and correspondingly Otherwise at least one student with this skill goes to the first team and the sizes are at most and correspondingly So the answer is Time complexity 
237,First of all let s understand that the answer to the problem should not contain zeros leading zeros are useless while others increase the number but do not change the sum It is also clear that the number we found should have the minimum possible length since the longer the numbers without leading zeros the larger they are Numbers of the same length are compared lexicographically that is first by the first digit then by the second and so on This means that the digits in the number must go in sorted order the order of the digits does not affect the sum but does affect the value Let s minimize the length of the number first We need to get the specified sum in as few digits as possible So we should use as large digits as possible Then let s start with the number 9 and add the digits from 8 to 1 to the beginning of the number in turn until the sum of the digits exceeds the specified sum Obviously you can t get an answer for fewer digits Now we minimize the number itself First we must minimize the first digit The first digit is uniquely determined as the difference between the sum of the remaining digits and the required sum So you need to maximize the sum of all digits except the first one which has already been done in the previous paragraph It only remains to correct the first digit and print the answer 
238,We create a structure that stores for each point its coordinate weight and index in the input data Sort the array by increasing weight The sum of weights of the first points will be minimal so we use them to construct a system of nested segments We save the weights of the first points in the variable and remove the remaining points from the array Now sort the points in ascending order of coordinates and form a system of nested segments such that the endpoints of th segment are and for Thus the endpoints of the first segment are and the endpoints of the th segment are and For each test case we first output then pairs of numbers the indices under which the endpoints of the current segment were written in the input data 
239,There are at least two solution to the problem I ll describe both of them The first solution firstly let s notice that the point we search can have non integer coordinates but if the answer exists then there will be the answer such that its point has at most half integer coordinates So let s multiply all coordinates by two and solve the problem with integer coordinates The second thing is that for some there is only two points we need to check top point with this and bottom point with this The same for some So we can iterate over all possible values of and check if the point lies outside of both black rectangles The same with point Then do the same for points and should be in range and should be in range Time complexity is linear on size of the white rectangle The second solution is most tricky but has the better time complexity Let be the intersection of white rectangle and the first black rectangle the same but with the second black rectangle and be the intersection of and Then it is obvious that the answer exists if and doesn t cover the whole white rectangle Time complexity 
240,Let s compute the answer to the array where is the digit at the position in the number we are looking for Let be the position of the last digit in number be the position of the last digit in number Then denote and consider the cases if then the sum of was exactly then if then the sum was greater than and we need to look at the next digit of the number If there isn t one we can t get the answer we ll output Otherwise we recalculate and reduce by one if now and then Otherwise we deduce since we cannot get more than when adding two digits and the cases where have already been considered before After considering the cases reduce and by one and repeat the checks as long as or In the situation where but we will still have uncheked digits of number so we will also output Otherwise we output an array with the answer without leading zeros 
241,The only fact required to solve this problem is just to notice that the answer array is just an arithmetic progression After that we can fix the first element fix the difference construct the array check if and are in this array and if yes update the answer with This is solution There are faster solutions though Other author s solution is but I didn t want to make this problem harder so I allowed solutions It is obvious that the difference of the progression is some divisor of Let it be Let s add some elements starting from to the left and so on and stop if we reach elements or the next element is less than If we didn t find among these elements just skip this difference it is useless for us Otherwise if we have less than elements let s add and so on until we get elements And then update the answer with the maximum element of the array There is also a solution in with some greedy observations 
242,Let s replace all characters of with zeros and ones zero if the character is unavailable and one otherwise Then we have the binary string and we have to calculate the number of contiguous segments of this string consisting only of ones It can be done with two pointers approach If we are staying at the position and its value is zero just skip it Otherwise let s find the leftmost position such that and the th value is zero Then we have to add to the answer the value and set Time complexity 
243,Formally the problem asks you to remove the shortest cycle from the robot s path Because the endpoint of the path cannot be changed the number of s should be equal to the number of s and the same with and How to find the shortest cycle Let s create the associative array for C which will say for each point of the path the maximum number of operations such that if we apply first operations we will stay at this point Initially this array will contain only the point with the value Let s go over all characters of in order from left to right Let the current point be we applied first operations indexed If this point is in the array already let s try to update the answer with the value and left and right borders with values and correspondingly Then let s assign and continue If there were no updates of the answer the answer is Otherwise you can print any substring you found Time complexity per test case 
244,As you can see from the example the maximum answer doesn t exceed So we can run some precalculation before all queries which will find all less than The number is if it has no in the ternary numeral system When you read the next query you can increase until you find some precalculated Time complexity is You also can implement the solution which doesn t use any precalculations and just increase each time in each query and checks if the number is inside this loop Then time complexity will be 
245,In this problem the following greedy solution works let s maintain the last element of the increasing sequence we got and on each turn choose the minimum element greater than this last element among the leftmost and the rightmost Such turns will maximize the answer You can find details of implementation in the authors solution 
246,To solve it it should be noted that despite the way the deck with bonuses works the order in which they will be applied is not important Then when we meet the hero card we just need to add to the answer the maximum of the available bonuses Constraints allow you to sort the current array with bonus values each time and remove the maximum element 
247,Let s see the representation of in the ternary numeral system If it has no twos then the answer is Otherwise let be the maximum position of in the ternary representation Then we obviously need to replace it with and add some power of three to the right from it Let be the leftmost position of to the right from We can add and replace all digits from the position to the position with Then the resulting number will be because we replaced all twos with zeros and the minimum because in fact we added only one power of three and this power is the minimum one we could add Time complexity is per query 
248,The solution of the previous problem works for this problem also Almost works What if the leftmost element is equal the rightmost element Which one should we choose Let s analyze it If we take the leftmost element then we will take any other element from the right and vice versa So we can t meet this case more than once because after meeting it once we can take only leftmost elements or only rightmost elements The only thing we should understand is which of these two cases is better take the leftmost element or take the rightmost element To do it we can just iterate from left to right and calculate the number of elements we can take if we will take the leftmost element each time If we cannot take the current element then just stop the cycle And do the same thing for the rightmost element and take the best case 
249,To solve it it should be noted that despite the way the deck with bonuses works the order in which they will be applied is not important Then when we meet the hero card we just need to add to the answer the maximum of the available bonuses Constraints make you use structures such as a priority queue to quickly find and extract the maximum 
250,Let s look at elements and After the first step they will always move to positions and it s up to you to choose and or vice versa because all remaining for will be placed between and After the second step elements and will always be placed at positions and it s also up to you to decide the exact order because it s easy to see that you first take all for and only after that and In other words elements and are moved to positions and We can analogically prove that each pair is moved to a pair of positions you first take all elements for and place them at positions and then you move and finally you move all remaining elements from between and Step just does everything in reverse order to step It means that array is basically array but you can swap elements in pairs for And to make sorted we can try to sort each pair and check is it enough to sort the whole array or not 
251,Consider the problem in 0 indexation Define the function calc l r c which finds the minimum number of changes to make the string s l dots r Let mid frac l r 2 Then let cnt l frac r l 2 count s l dots mid c calc mid r c 1 and cnt r frac r l 2 count s mid dots r c calc l mid c 1 where count s c is the number of occurrences of the character c in s We can see that cnt l describes the second condition from the statement and cnt r describes the third one So calc l r c returns min cnt l cnt r except one case When r l 1 we need to return 1 if s l ne c and 0 otherwise This function works in O n log n each element of s belongs to exactly log n segments like segment tree You can get the answer if you run calc 0 n a 
252,What does it actually mean for an array to be sorted That means and and so on For each pair of adajacent elements let s deduce which values put them in the correct order Any value of that puts all pairs in the correct order will be the answer Consider any and and solve the inequality If then any value of works Let be smaller than If is smaller than or equal to then the inequality becomes Thus they don t change their order and any works If is greater than or equal to then the inequality becomes Thus they always change their order and none of work If is between and then the inequality becomes Thus they only remain in the same order for any integer such that In union that tells us that all values of that work for such a pair are The similar analysis can be applied to which results in the required being for such pairs Finally how to find out if some value of passes all conditions Among all conditions of form in order for some to work it should be less than or equal to even the smallest of them Similarly among all conditions of form in order for some to work it should be greater than or equal to even the largest of them Thus take the minimum over the pairs of one type Take the maximum over the pairs of another type If two resulting values are contradictory then there is no answer Otherwise any value inside the resulting range of works Overall complexity per testcase 
253,Let k be the number of operations performed by Polycarp Let s see how to check if k is the answer Let s denote by s the sum of numbers in the array a Note that after each operation s does not change Since we know that after k operations all elements must be the same and the sum of the numbers in the array does not change then each of the remaining elements must be equal to frac s n k Let s check if it is possible to perform k operations so that at the end all elements are equal to frac s n k Note that the process described in the condition is equivalent to the following process Choose a set of n k 1 indices i 1 i 2 dots i n k 1 1 i 1 i 2 dots i n k i n k 1 n 1 partitions Create a new array b of n k elements where b j sum limits t i j i j 1 1 b t For example the array a of 8 elements after 4 operations could turn into an array b a 1 a 2 a 3 a 4 a 5 a 6 a 7 a 8 In this case the set of indices is i 1 5 6 8 9 Then to check if k is the answer it is necessary to split the a array into n k subarrays in which the sum of all elements is equal to frac s n k Such a check can be implemented greedily in mathcal O n It is enough to go through the array from left to right and take an element into the current subarray until the sum in it exceeds frac s n k The resulting solution works in mathcal O n cdot sigma s or mathcal O n 2 where sigma s is the number of divisors s 
254,Suppose the given list of divisors is a list of divisors of some in other words suppose that the answer exists Then the minimum divisor multiplied by maximum divisor should be This is true because if we have a divisor we also have a divisor Let s sort all divisors and let Now we need to check if all divisors of except and are the permutation of the array check that our answer is really correct We can find all divisors of in sort them and compare with the array If arrays are equal then the answer is otherwise the answer is 
255,If we can print because each such sequence is an arithmetic progression Note that an arithmetic progression is uniquely determined by the first two terms So we should brute from to the change of the first element of the given sequence and from to the change of the second element of the given sequence Then and Also we will store the number of changed elements in the sequence Initially Now we need to iterate through the sequence from the third element to th Let current element in the position It should be equals to If then such arithmetic progression is unreachable Else if we should increase on one After we considered all elements we should update the answer with the value of if for all it was true that 
256,Let s denote for the maximum number of moves for which the numbers and can be made equal It is easy to understand that the number of moves is maximum when and each time we divided or by a prime number That is sum of exponents of prime divisors of sum of exponents of prime divisors of Let s denote by the minimum number of moves for which the numbers and can be made equal Consider a few cases If then If or then Otherwise then Then the answer is possible in the following cases and and or and 
257,Well if we replace all occurrences of the number with the number then the initial solution will be anti sudoku It is easy to see that this replacement will make exactly two copies of in every row column and block There are also other correct approaches but I found this one the most pretty 
258,It s kinda obvious that we have to choose the greatest elements of the array as the denominators in the operations suppose we haven t chosen one of them but have chosen a lesser element as a denominator if we swap them the total score won t decrease It is a bit harder to prove that the numerators of the fractions should be the next greatest elements the elements on positions from to in sorted order It can be proved as follows each fraction we will get in such a way rounds down to either or to and if we choose a lesser element as a numerator we can decrease a fraction from to but we ll increase the sum of elements that remain in the array so this is not optimal All that s left is to pair the numerators and denominators A fraction with numerator equal to denominator rounds down to any other fraction will round down to so our goal is to minimize the number of fractions having the numerator equal to the denominator It can be done by pairing the numbers into fractions in the following way assuming is sorted So the solution of the problem is the following sort the array then calculate 
259,Let s count how many characters and we have in the string and store it in the array Also let s count our goal array Firstly the array is The main idea of this problem is a pretty standard lexicographically greedy approach We go from left to right and try to place the minimum possible character at the current position in such a way that placing this character is not breaking conditions of our problem How can we apply this approach to this problem Firstly let s define a function What does the value of this function mean It means the number of replacements we need to reach from Let at the beginning of the program This value means the minimum number of replacements to obtain some balanced ternary string Let s maintain the variable which initially is and means the number of replacements we already made So we iterate over all positions from to Firstly let s decrease So the array maintains the current amount of characters on suffix of the string Now let s iterate over characters from to and try to place every character If the current character is needed then let s decrease and if the number of replacements will still be minimum possible after such replacement then let s place this character set and go to the next position This will form lexicographically minimum possible answer with minimum number of replacements There is another simpler solution from PikMike you can call him to explain it I just will add his code to the editorial 
260,This problem has a very standard solution let s take the leftmost zero place it as left as possible and solve the problem without this zero and all operations we spent But we should do it fast Let s go from left to right and carry the number of ones on the prefix If we meet let s just increase and continue the algorithm It is obvious that if we meet we need to make exactly swaps to place it before all ones If we can do it let s just add to the answer decrease by and continue Otherwise this zero will be between some of these ones and we can place it naively In this case the suffix of the string will not change If after all operations we didn t meet the case above let s add all ones to the suffix of the resulting string Time complexity 
261,Let s iterate over all characters of from left to right maintaining two arrays and where stores indices of all subsequences which end with and stores indices of all subsequences which end with If we met then the best choice is to append it to some existing subsequence which ends with If there are no such sequences we need to create new one which ends with Otherwise we need to convert one of sequences to sequence The same works with characters So when we don t need to create the new sequence we try to don t do that And values in arrays and help us to determine the number of sequence we assign to each character And also there is a cute proof of this solution from Gassa let be the difference between the number of and the number of on the prefix of of length We claim that the answer is and let s show why is it true Let s build a function on a plane with points Then we can match each between and with some subsequence 
262,To obtain a segment of cells of black color we need to paint all the white cells of the segment black Then go through all the segments of length there are only and choose such a segment among them that the number of white cells on it is minimal You can quickly find out the number of white cells in the segment by prefix sums 
263,Note the following fact if a number in a permutation was obtained from a blue number and a number in a permutation was obtained from a red number and then by decreasing the blue number and increasing the red number exactly times each we will obtain the same permutation in which the two numbers have swapped places Thus if a permutation can be obtained at all some permutation can be obtained by making all the red numbers equal to and the blue ones equal to where is the total count of red numbers Now consider separately two red numbers and such that If is produced by increasing and is produced by increasing and in the same time then and the following is also true and So we just showed that if an answer exists it also exists if greater numbers are produced by greater values from the input The same holds for the blue numbers Let us sort all elements by the key where the color of th element and blue comes before red It remains to check that for any from to we can get the number from the th element of the obtained sorted array To do this we iterate through it and check that either and so it can be reduced to or symmetrically and 
264,The first solution is some kind of a straight forward understanding the problem Let s do binary search on the answer So our problem is to find the smallest such that the suffix of the array starting from the position can be packed in boxes It is easy to see that if we can do it for some then we always can do it for And to find the answer for the fixed we have to simulate the process described in the problem statement starting from the position Okay this is solution The second solution is more interesting than the first one The approach is to reverse the initial array simulate the process from the first position of reversed array and then all the objects we can pack are in the best answer and there is no better answer at all Why it works Let s take a look on the last box in the best answer if we will go from left to right in the initial array Let objects in this box be What do we see So all these objects are fit in the last box obviously Now if we will iterate over objects from right to left these objects will fit also It means that we cannot do worse by such a transform reversing at least for the last box But what will happen if we can put some of the previous objects in this box Well it will not make worse for this box but what about next boxes previous boxes in straight notation Let objects in the penultimate box be What do we see These objects are fit in this box obviously again What will happen if we will put in the last box one or more objects of this box Then the border of objects which we will put in it will not increase because we the number of object in this box So we can see that for previous boxes this condition is also satisfied So we can solve the problem with this approach Time complexity of this solution is 
265,If Polycarp buys packages of shovels and gets exactly shovels in total then that is and are divisors of Then the problem reduces to the following you need to find the maximum divisor of the number not greater than To do this iterate over all the numbers from to inclusive and check whether is divisible by If so then and are both divisors of and you can use them to try to improve the answer 
266,Let s calculate the array where is the number of candies of the th type Let s sort it in non ascending order Obviously now we can take because this is the maximum number of candies of some type in the array Let be the last number of candies we take Initially it equals and the answer is initially the same number Then let s iterate over all values of in order from left to right If the current number is greater than or equal to the last taken number of candies then we cannot take more candies than because we iterating over values of in non ascending order so let s increase answer by and set Otherwise and we can take all candies of this type increase the answer by and set 
267,The answer to this problem is at most Let s prove it by construction Firstly if all are equal then the answer is Otherwise there are at least two different values in the array so the answer is at least If is even then the answer is always because you can color figures in the following way If is odd then consider two cases The first case is when some pair of adjacent figures have the same type Then the answer is because you can merge these two values into one and get the case of even Otherwise all pairs of adjacent figures have different types and if you consider this cyclic array as a graph cycle of length then you can notice that it isn t bipartite so you need at least colors to achieve the answer color all vertices in such a way that any two adjacent vertices have different colors And the answer looks like 
268,In this problem we first need to consider all points adjacent to at least one Christmas tree then all points at the distance two from the nearby Christmas tree and so on What it looks like Yes well known multi source bfs Let s maintain a queue of positions and the set of used positions and the distance to each vertex of course In the first step we add all positions of the Christmas tree with a zero distance as initial vertices Let the current vertex is If this is the Christmas tree then just add and to the queue if these vertices aren t added already and continue Otherwise increase the answer by and add to the array of positions of people When the length of this array reaches interrupt bfs and print the answer Don t forget about some special cases as using in Java or using in C because this can lead to the quadratic complexity Time complexity 
269,Let s write a function which will try to restore the circle if kid with number comes right after kid with number If comes right after then we can determine the number of kid who is next to kid So now we have comes right after comes right after Let s determine kid who is next to kid If we repeat this operation times then we can the answer if comes right after But it can be wrong so we have to check that our answer corresponds to the input So if we have this function we can apply it two times to determine the correct answer Just call and 
270,Let s say we remove applications with and applications with Obviously among all the applications with it was necessary to take maximum in memory so we will clear the most memory Let s split all the applications into two arrays with and and sort them Then you need to take a prefix from each array Let s iterate over which prefix we take from the first array For it we can uniquely find the second prefix we remove applications until the sum exceeds If we now increase the first prefix by taking a new application then we don t need to take any applications in the second array This means that when the first prefix is increased the second one can only decrease To solve the problem you can use the two pointer method 
271,In order to build lexicographically minimal co growing with sequence it is enough to build its elements iteratively beginning from and minimizing the th element assuming that have already been found Assign According to the statement all elements of the sequence are non negative so cannot be less than zero It turns out that is the minimal possible first element The existence of an answer with follows from the construction algorithm described below Let s use mathematical induction and construct under the assumption that all the previous elements of the sequence have already been constructed In order to satisfy the condition for the growth of the final sequence the number must contain one bits at all places but not necessarily limited to them on which there are one bits in the number Let s denote for and find out what bits can be in to satisfy this condition If in stands bit then independently from in at the same spot we can place any bit because there is no limit on the corresponding bit in If in stands bit and in then the corresponding bit in should be equal so that in the corresponding bit also equals one If in and in stands bit then in should be bit at the corresponding place for the same reasons The bit transformation described above can be given by the expression Indeed this expression gives us bit one at the fixed position if and only if at that place in stands bit and in stands bit For the full solution it remains only to apply this formula in a loop from to 
272,We can solve the problem by the following way firstly for each power of 2 let s calculate the number of coins with the value equals this degree Let s call it cnt It is obvious that we can obtain the value b j greedily because all less values of coins are divisors of all greater values of coins Now let s iterate over all powers of 2 from 30 to 0 Let s deg be the current degree We can take min lfloor frac b j 2 deg rfloor cnt deg coins with the value equals 2 deg Let it be cur Add cur to the answer and subtract 2 deg cdot cur from b j If after iterating over all powers b j still be non zero print Otherwise print the answer Overall complexity O n q log maxAi 
273,The first step is to find the word that covers the maximum length prefix If there is no such word we cannot color the string Then go through the positions inside the found prefix and find the next word which is a tweak of has the maximal length and ends not earlier than the previous found word and not later than the text If there is no such word it is impossible to color After the second word is found similarly continue looking for the next ones 
274,Use greedy approach in this problem At first match such pairs that colors are exactly the same and they are specific not indefinite After it match each indefinite colored left boot if any with any specific colored right boot Possibly some indefinite colored left boots stay unmatched Similarly match each indefinite colored right boot if any with any specific colored left boot And finally match indefinite colored left and right boots if any 
275,Let s rewrite concatenation in a more convenient form where is the number of digits in Then this number is divisible by if and only if the sum of and is either or Let s calculate arrays of remainders For each adds to That s the first term of the sum Now iterate over the second term for and for you binary search for in The number of its occurrences should be added to answer You also might have calculated some pairs iterate over them and subtract them naively Overall complexity 
276,It is obvious that if we fix the value of x then there are three cases for the pair of elements We don t need to change anything in this pair we can replace one element to fix this pair we need to replace both elements to fix this pair The first part can be calculated easily in O n k we just need to create the array of frequencies cnt where cnt x is the number of such pairs a i a n i 1 that a i a n i 1 x The second part is a bit tricky but still doable in O n k For each pair let s understand the minimum and the maximum sum we can obtain using at most one replacement For the i th pair all such sums belong to the segment min a i a n i 1 1 max a i a n i 1 k Let s make 1 on this segment using prefix sums make 1 in the left border 1 in the right border plus one and then just compute prefix sums on this array Let this array be pref Then the value pref x tells the number of such pairs that we need to replace element in this pair to make it sum equals x And the last part can be calculated as frac n 2 pref x So for the sum x the answer is pref x cnt x frac n 2 pref x cdot 2 We just need to take the minimum such value among all possible sums from 2 to 2k There is another one solution that uses scanline not depends on k and works in O n log n but it has no cool ideas to explain it here anyway the main idea is almost the same as in the solution above 
277,What is the sum of all the elements in b This is twice the sum of all the elements in a x Denote by B the sum of all the elements of b Let s iterate over which of the array elements was added as the sum of the elements a let s denote for a Then x B 2 cdot A It remains to check that the element x is present in the array b this can be done using a hash table or a binary search tree 
278,Let s solve the problem using binary search by the answer It is easy to see that if we can construct the answer for some number of copies then we also can do it for The only thing we need is to write the function which will say can we cut off copies of some array from or not Let s imagine copies of string as a matrix of size Obviously each row of this matrix should be equal to each other row Let s fill not rows but columns of this matrix For some element of we can easy notice that we can take exactly columns containing this element where is the number of such elements in So overall number of columns we can fill in this matrix will be If this value is greater than or equal to then is true otherwise it is false It is easy to construct the answer using all things we described above Overall complexity is where is the size of the alphabet 
279,Firstly let s check if the initial fits the conditions If it is print and continue Otherwise let s solve the problem greedily At first let s try to set the last digit to zero Let We need exactly moves to do that Let s add this number to and to the answer and check if the current fits the conditions If it isn t let s try to set the previous last digit to zero Let Then we need moves to do that Let s add this number to and to the answer and check if the current fits the conditions If it isn t repeat the same with the third digit and so on This cycle can do no more than iterations And we can fing the sum of digits of in at most iterations too decimal logarithm of So the total time complexity is 
280,Let s store for each letter all positions in which it appears in some data structure We need such a data structure that can add remove and find the next element greater than or equal to our element fast enough Suddenly this data structure is again in C When we meet the first type query let s just modify two elements of corresponding sets one remove one add When we meet the second type query let s iterate over all letters If the current letter is in the segment then the first element greater than or equal to in the corresponding set should exist and be less than or equal to If it is so let s increase the answer by one After iterating over all letters just print the answer Time complexity when is the size of the alphabet 
281,If all districts belong to the same gang then the answer is Otherwise the answer is always yeah as in the previous problem How to construct it Let s choose the first root as the district and connect all such districts that to the district So all disconnected districts that remain are under control of the gang Let s find any district that and just connect all remaining districts of the gang to this district This district always exists because we have at least two different gangs and it is connected to the remaining structure because its gang is not So all conditions are satisfied 
282,Let s divide the initial string into blocks of consecutive equal letters For example if we have the string then have blocks the first block is two letters the second one is three letters the third one is two letters and the last one is four letters Let s see at the current block let it has the length and consider two cases The first case is when this block has odd length Then it seems like So what is the minimum number of recolors we need to make this block correct It is Why can we always make this block correct for such number of recolors Because we can recolor all at even positions to any which differs from So our block will be look like The second case is when this block has even length Then it seems like where is the next block letter if the next block exists because the last block doesn t have the next one What is the minimum number of recolors in this case It is How can we recolor this block to make it correct Let s recolor all at even positions again to any which differs from and differs from So our block will be look like So all we have to do is to iterate over all blocks from left to right and apply the algorithm above to recolor them 
283,Let be the maximum integer such that is divisible by Our problem is to rearrange the given array in such a way that easy to see it if we look at our operations if it looks like then for each the next inequality will be satisfied And if then numbers must be placed in increasing order because of our operations So we can store an array of pairs when Then if we sort it in lexicographical order we can just print the second elements of the sorted array 
284,Let s notice that if we multiply the numbers then the power of two of the product is equal to the sum of the powers of two in each of the numbers Let s calculate the initial sum of the powers of twos in the product This can be done as follows let s take the element and divide it by as long as we can while remembering to increase our counter by the number of occurrences of a power of two Now let s move on to operations and note that choosing the index will increase the degree of occurrence of two by a fixed number that is it does not matter when to apply this operation Choosing an index will increment the counter by a number such that is divisible by but not by you can find this again by dividing by while we can Since we want to minimize the number of operations used at each moment of time we will try to use an index that increases the counter by the largest number To do this it is enough to sort the indices by this index of increase and take them greedily from the largest increase to the smallest We get the solution in 
285,For each from to find all elements of the array that are congruent to modulo and store their indices in a list Also create a vector called and let be We have to cycle from to twice For each from to if there are in list too many i e elements congruent to modulo remove the extra elements from this list and add them to If instead there are too few i e elements congruent to modulo remove the last few elements from the vector For every removed index increase by After doing so after two passes we print the total increase and the updated array It is obvious that after the first iterations every list will have size at most and after more iterations all lists will have the same sizes It can be easily proved that this algorithm produces an optimal answer The time complexity is 
286,Let s find the most frequent element in the array using the array of frequencies of course Let this element be If we will see the operations more carefully we can see that the part of these operations means if then this operation is otherwise it is Now let s consider the number of operations in the optimal answer It is obvious that we need at least operations to equalize all the elements And it is also obvious that we can always do it with such operations we have How to restore the answer There is an easy way to do it find the first occurrence of Let it be Then let s go from to and set each element to the next element element at the position to to and so on And don t forget to print right type of operation Then let s go from left to right from to and if the th element don t equal to then set it to th element using right operation 
287,Let s look at an analogy for this game If Alice takes an even number she adds points to the global result otherwise If Bob takes an odd number he adds points to the global result otherwise Alice wants to maximize the global result and Bob wants to minimize it Obviously this game is completely equivalent to the conditional game Suppose now it s Alice s move Let s look at some number in the array If this number is even then taking it will add points and giving it to Bob will add points If this number is odd then taking it will add points and giving it to Bob will add points So taking the number by points is more profitable than not taking it regardless of the parity To maximize the result Alice should always take the maximum number in the array Similar reasoning can be done for Bob In the task it was necessary to sort the array and simulate the game 
288,Let s calculate the minimum number of secret technique uses we need to kill each of the monsters Let the current monster has hp Firstly it is obvious that we can take modulo except one case If it becomes zero let s rollback it by one pair of turns Then the number of uses of the secret technique we need is Let s sort all monsters by this value and take the cheapest set of monsters prefix of the sorted array with the sum of values less than or equal to Time complexity 
289,First we sort the friends in descending order of Now for each friend we know the amount of money he lacks or vice versa which he has in excess In order to maximize the number of days it is most advantageous for friends to break into pairs It is the number of groups that matters not the number of people in the group so adding a third person to the pair won t improve the answer in any way Let s solve the problem using two pointers for the richest friend find the first friend from the end such that the sum of their values exceeds the sum of their values Then repeat this for all subsequent friends until the pointers meet If no pair could be formed or none of the friends has a value greater than then the answer is Otherwise print the number of pairs formed 
290,Suppose we must turn into some number In this case we can use the following greedy algorithm Consider the string forms and of the numbers and respectively Let s make a pointer pointing at the first character of the string and a pointer pointing at the first character of the string Let s initialize a variable in which we will store a number of selected characters Until any of the pointers points at the place that is out of the corresponding string let s do the following procedure if the characters to which the pointers point are equal we will take the character increase by and move both pointers character to the right otherwise the only action we must perform is to move character to the right The variable will contain after the whole process the length of the longest subsequence of equal to a prefix of i e the maximum number of original characters of that we will not erase We must add to the resulting string all remaining characters of to turn it into Therefore we must erase digits and add digits so the answer for this subproblem is where means the length of a string Suppose we have a set of powers of two such that it s enough to consider to get the problem s answer The problem can be solved as follows for each let s calculate the answer for the subproblem described above and select the value of as the answer What set of powers of two we can take Suppose the number consists of no more than digits The answer for each consisting of digits doesn t exceed hence we can get this value by turning the number into in move adding to the right of the number and erasing all other digits Suppose there s a number such that So it consists of no more than digits this value can be reached as follows we must not erase any digit and add digits Therefore if each number such that consists of no more than digits hence Suppose consists of more than digits Then because according to the input format The answer for the number doesn t exceed we can get this answer if we erase all from the number to turn it into Suppose there s a number such that This number can consist of no more than digits digits of plus digits hence Therefore it s enough to consider all powers of two that are less than 
291,The answer is First count two numbers which denote the degree of occurrence of and in the number respectively that is Where is not divisible by either or Now while we will increase the corresponding value For example if then as long as and at that we will increase by and multiply by times That way we can get the most round number possible by spending the least possible Now we either have or or Then in the first case we will multiply the number by as long as we can That is until Now in either case we have Then Then we multiply by times and get our desired answer In the last step we can no longer get a rounder number but just find the maximal possible number 
292,Let some vertex be responsible for a segment of leaves Then her left son is responsible for the segment and the right for the segment Note that if we do not apply the operation to this vertex then it will not be possible to move some element from the right son s segment to the left son s segment It remains to understand when we need to apply the operation to the vertex Let the maximum on the segment be the minimum on the same segment is Then if lies in the right son and in the left then we should obviously apply the operation for the reason described above In the case when lies in the left son and in the right the application of the operation will definitely not allow you to get a solution Let s continue to act in a similar way recursively from the children of the current vertex At the end we should check whether we have received a sorted permutation The above solution works for since there are levels in the tree and at each level vertexes are responsible for sheets in total You can optimize this solution to if you pre calculate the maximum and minimum for each vertex 
293,First for each size let s count the number of dolls of this size Then let s create a set in which for each doll of size we add the numbers and This will allow you to process all the segments as well as the dimensions adjacent to them We will iterate over the set in ascending order of size Let be the number of matryoshkas of the current size of the previous one considered at the beginning If the numbers do not match then you need to close if or open if segments It is enough to add only the opening of the segments to the answer 
294,First we can always get a product value equal to if we remove all elements of the array Then we need to know what maximal value of the product we can get Consequently the remaining array after removing the corresponding prefix and suffix should have no elements We can find maxima in all sections between zeros Now we are left with a set of nonzero numbers If the value of the product on the current segment is positive it makes no sense to remove any more elements Otherwise the product is negative then we must remove one negative number from the product either to the left or to the right Compare the values of the product on the prefix and suffix to the nearest negative value and remove either the suffix or the prefix respectively 
295,Firstly let s understand what the operation does It changes the element but holds the remainder modulo So we can consider all elements modulo Let be the number of elements with the value modulo be the number of elements with the value modulo and so on Let s understand where is the bottleneck of MEX Obviously we can always fill exactly full blocks so MEX is at least MEX will be among all elements such that Among all such elements MEX will be the minimum such Let it be So the final value of MEX is How to deal with queries Let s maintain the sorted set of pairs for all and change it with respect to appended values During each query let s change the set correspondingly and take the answer as the first element of this set using the formula above Time complexity There is also an easy linear solution that uses the same idea but in a different way 
296,I suppose there are some solutions without cases handling but I ll describe my own it handling approximately 5 cases Firstly let nn n frac k k 1 2 If nn 0 then the answer is already Otherwise let s construct the array a where all a i are lfloor frac nn k rfloor except rightmost nn k values they are lceil frac nn k rceil It is easy to see that the sum of this array is nn it is sorted in non decreasing order and the difference between the maximum and the minimum elements is not greater than 1 Let s add 1 to a 1 2 to a 2 and so on this is what we subtract from n at the beginning of the solution Then if nn ne k 1 or k 1 then this answer is correct Otherwise we got some array of kind 1 3 dots a k How do we fix that For k 2 or k 3 there is no answer for this case you can try to prove it or try to find answers for cases n 4 k 2 and n 8 k 3 Otherwise k 3 and we can subtract one from a 2 and add it to a k and this answer will be correct this also can be proved with some easy formulas Time complexity O k 
297,Note that if we cannot get joy then we cannot get and if we can get at least then we can get at least These facts allow us to use binary search to find the answer Now we need to understand how exactly we can recognize whether we can gain joy at least or not We can enter at most shops so we always need to take two gifts from some store which means there must be a store in which we can find two or more gifts with pleasure at least Also each friend should receive a gift which means that we should be able to buy each gift with pleasure at least It takes O nm to check that both of these conditions are met The total solution works in O nm log nm 
298,Firstly let s understand that the sum of the segment is zero if is zero in other words where is the sum of the first elements Let s iterate over elements from left to right and add all prefix sums in the set If we get the sum that is already in the set we get some segment with sum and we need to fix it somehow Let s insert some huge number before the current element in such a way that all prefix sums starting from the current element to the end will be significantly bigger than all prefix sums to the left In words of implementation we just get rid of all prefix sums to the left clear the set and continue doing the same process starting from the current element so we just cut off the prefix of the array This way is optimal because we remove all segments with sum ending at the current element using only one insertion and we need to use at least one insertion to do that Time complexity 
299,The main idea is that it is always better to remove the most expensive symbol To do this quickly we will count all the symbols and remove them from the most expensive to the cheapest counting how many times we have removed each During the output we will skip the characters the number of times that we deleted 
300,Consider n in this canonical form p 1 a 1 cdot p 2 a 2 cdot ldots cdot p k a k just find the prime factorization of n Let i be such an index that a i is the maximum among all values of a Then the answer length can not exceed a i This is because if the answer has greater length then some number doesn t have p i in its representation thus there will be problems with divisibility because we are considering primes So let s create the answer of length a i consisting of p i Then let s just multiply the last element by all other primes in their degrees So we satisfied the divisibility rule and the length of the answer is the maximum possible 
301,Let s rewrite the inequality from to This looks much simpler Let s build the array where and sort this array Now our problem is to find the number of pairs such that Let s iterate over all elements of from left to right For simplicity we consider only greater summands Because our sum must be greater than then at least one of these summands will be positive So if just skip it Now and we need to calculate the number of such that and It means that each for some will be okay Such leftmost position can be found with or binary search Then add the value to the answer and consider the next element Time complexity 
302,We will solve the problem greedily First we will try to add pairs of identical characters to palindromes As long as there are at least pairs let s add them After that it is no longer possible to add a couple of characters but you can try to add one character in the middle This can be done if there are at least characters left There is no need to paint other characters 
303,We will construct the required tree recursively Let us describe the state of tree construction by three values where is the segment of the permutation and is the current depth Then the following transitions can be described find the position of the maximum element on the segment that is the depth of the vertex is equal to if then make the transition to the state if then make the transition to the state Then in order to construct the required tree it is necessary to take as the initial state 
304,Firstly let s prove that the size of the answer is not greater than Suppose that the answer equals to Let be coordinates of the points in the answer and Let and Then because of the condition It means that Conditions must hold for a triple too Now it is easy to see that if then that is not a power of two So the size of the answer is not greater than Firstly let s check if the answer is Iterate over all middle elements of the answer and over all powers of two from to inclusively Let be the middle element of the answer and the current power of two Then if there are elements and in the array then the answer is Now check if the answer is Do the same as in the previous solution but now we have left point and right point If we did not find answer of lengths or then print any element of the array The solution above have time complexity because of we can check if the element is in the array with some data structure in 
305,There are multiple approaches to solve this problem We will use dynamic programming approach Let s calculate values of the array where is the answer for prefix of the length Obviously since for the empty string the prefix of the length the answer is For you can find in the following way Let s look in the last digit of the prefix of length It has index Either it doesn t belong to segment divisible by or it belongs If it doesn t belongs it means we can t use the last digit so If it belongs we need to find shortest that is divisible by and try to update with the value It means that we bite off the shortest divisible by suffix and reduce the problem to a previous A number is divisible by if and only if sum of its digits is divisible by So the task is to find the shortest suffix of with sum of digits divisible by If such suffix is then and have the same remainder of sum of digits modulo Let s maintain array of the length where is the length of the longest processed prefix with sum of digits equal to modulo Use if there is no such prefix It is easy to see that where is the sum of digits on the th prefix modulo So to find the maximal that substring is divisible by just check that and use where is the sum of digits on the th prefix modulo It means that to handle case that the last digit belongs to divisible by segment you should try to update with value In other words just do Sequentially calculating the values of we obtain a linear solution 
306,For the first conversation let s choose two people and with maximal values of sociability Note that after this conversation takes place we move on to a similar problem but in which and are decreased by After decreasing and by we repeat the choice of the two people with the maximum values of sociability Let us repeat such iterations while at least two people with positive sociability parameters remain Let us prove that this solution leads to the optimal answer Let s denote the sum by and consider two fundamentally different cases The maximal element is greater than or equal to the sum of all remaining elements That is there exists such that In this case note that the th person can not possibly have more than conversations because by that point all other people already reached their sociability limits and left the meeting Thus if the answer cannot be more than Note that this estimation is accurate since an example exists in which th person talks to all other people as many times as possible that is times with th person for all And the algorithm described above will just choose the th person as one of the participants of a conversation every time because for every conversation both and decrease by exactly so the inequality holds and it follows that Otherwise we can prove that the maximum number of conversations is always Obviously it is impossible to get more than this number since each conversation requires exactly two units of sociability one from two people while a larger answer would mean that which is obviously wrong Let us prove that this answer is achieved by the described algorithm Let s look at the last conversation held If there are at least two more people left in the meeting after it we can hold another conversation which means there is a more optimal answer If there are zero people left in the meeting then an estimate of of conversations has been achieved And if there is one person with a remaining sociability then an estimate of of conversations has been achieved If there is exactly one remaining person with a sociability residual then we can guarantee that this person has participated in all previous conversations Indeed let s look at the last conversation it was held between two people with the maximum parameters of the remaining sociability But the th person has at least sociability remaining so it couldn t have been the other two people with residuals of who left right after that Thus analyzing all conversations in reverse order we can prove that at any time which means that it is in fact the case considered above We have proven that the described greedy algorithm works This algorithm can be implemented by using any balanced search tree such as By storing pairs of elements in it we could for each time choose the next two people to talk to and update the sociability values The time complexity is 
307,Firstly let s generate first primes It can be done in almost naively just check all elements in range It also can be done with Eratosthenes sieve in or We also can calculate for each number in this range the maximum its divisor non equal to it if this number is not a prime And in other case we can calculate the index of this prime Using all this information we can restore the array Let s maintain a multiset a set in which multiple copies of the same element are allowed of all elements in While it is not empty let s take the maximum element from this set If it is prime we can check it using the information calculated earlier then it is some Let s find the index of this prime using calculated information remove this element and push in and continue Otherwise this element is not a prime and then it is some Let s remove it and its maximum divisor non equal to it from the multiset push in and continue 
308,Firstly let s calculate for each from to two following values and means the maximum length of the increasing sequence starting in the position and means the maximum length of the increasing sequence ending in the position Initially all values are the element itself The array can be calculated in order from right to left with the following condition if then otherwise it still remain The same with the array but we have to calculate its values in order from left to right and if then otherwise it still remain Having these arrays we can calculate the answer The initial answer if we don t remove any element is the maximum value of the array And if we remove the th element where then we can update the answer with the value if Time complexity 
309,Consider deleting characters with numbers and as well as characters with numbers and In the first case the symbol with the number remains in the second Symbols with numbers less than or more than remain in both cases Therefore the same strings will be obtained if the characters with the numbers and match Therefore we just need to count the number of and subtract this value from 
310,Let s rewrite the original equality a bit a j a i j i a j j a i i Let s replace each a i with b i a i i Then the answer is the number of pairs i j such that i j and b i b j To calculate this value you can use or sorting 
311,Firstly let s notice that for the fixed value of our problem is reduced to the following we are given numbers We need to choose such values that And among all such values we need to choose values in a way to minimize And the sum of is Of course for the fixed value the minimum sum of can be only one Let s start with It is obvious that if the maximum value in the array is the value equals for Assume that each from to has some divisor Then if we multiply by and divide each by the answer will only become better How to calculate this value of fast We can see that this value equals to And it can be proven that this value of is always optimal and we can easily determine for such Time complexity 
312,We will construct the string starting with the largest letters Note that if then the th letter of the string is maximal so we know that the th letter affect all While the string is not completely constructed we will do the following Find all such that and the th character of string is not placed Put on all these positions in the string the maximum letter not used in the string there should be a sufficient number of letters in the string Subtract from all 
313,Let s iterate over all possible values of from to It is obvious that cannot be bigger than else we can just move to Then let s iterate over all possible multiples of from to Let this number be Then we can find as the nearest number to that is divisible by we can check two nearest numbers to be sure These numbers are and Then we can update the answer with the found triple Note that the only condition you need to check is that Time complexity because of the sum of the harmonic series 
314,The first thing to notice the answer always exists For numbers answer choices as well as permutation combinations It remains only to restore the answer from this permutation We will restore by performing reverse operations On the th operation will be selectd the first elements of the array and rotate them times to the left elements with numbers and more remain in their places Where is equal to if otherwise and is the index of the number Thus for each from right to left performing a left cyclic shift operation we move the number at index As a result we move numbers times The time complexity 
315,Let s divide all characters of both strings into groups in such a way that characters in each group can be swapped with each other with So there will be following groups and so on Since these groups don t affect each other we can calculate the number of in each group and then sum it up How to determine if a group does not need any preprocess moves For a group consisting of characters there will be one such group if is odd it will contain and that s easy if the characters in this group are equal the answer is otherwise it s To determine the required number of preprocess moves for a group consising of four characters we may use the following fact this group doesn t require preprocess moves iff the characters in this group can be divided into pairs So if the group contains four equal characters or two pairs of equal characters then the answer for this group is Otherwise we may check that replacing only one character of and will be enough if so then the answer is otherwise it s Overall complexity is 
316, which can be proved by induction If the partition exists it has the form since the area of the rectangle with another partition will be greater than We will cut the rectangles in the order Denote the coordinates of the colored cell at the step as If and then there is no partition since the square at any location overlaps the colored cell Cut off the square from the right or left edge depending on the location of the colored cell that is or Suppose that it was advantageous to cut it not from the edge then it is necessary to cut the rectangles and where using the set Then will not enter the partition but so We came to a contradiction 
317,Let s find a set of leaves of a given tree From each leaf we will climb up the tree until we meet a vertex already visited Having met such a vertex start a new path from the next leaf The sequence of vertices in the found paths must be deduced in reverse order because the paths must go from bottom to top It also follows from this solution that the number of paths will always be equal to the number of leaves in the tree 
318,The solution for this problem is very simple at first if or the answer is Otherwise let s do the following thing times let be we have to greedily decrease the remaining distance but we also should remember about the number of moves which we need to perform We have to walk to possible house which is located at distance from the current house also don t forget to subtract from The proof of the fact that we can always walk to the house at distance is very simple one of the possible answers which is obtained by the algorithm above will looks like several moves of distance possibly one move of random distance less than and several moves of distance The first part of the answer can be obtained if we are stay near the leftmost or the rightmost house second and third parts always can be obtained because distances we will walk in every of such moves is less than Time complexity is 
319,Let s simulate the process of walking and maintain the current charges of the battery and the accumulator carefully choosing which to use each time we want to pass a segment Obviously if at the beginning of some segment our battery is exhausted its current charge is we must use the accumulator to continue and vice versa What if we can use both types of energy storage If we can recharge the accumulator the current segment is exposed the current charge of accumulator is lower than its initial charge let s do it because it only consumes one charge of the battery and there is no better way to spend it And if we cannot recharge the accumulator it s optimal to use it instead of the battery suppose it s not right our solution uses the accumulator during current moment of time and the battery during some moment in future but optimal solution does vice versa Then the usage of the battery in optimal solution does not grant us any additional charges so we can instead swap our decisions in these moments use the accumulator right now and the battery later and the answer won t get worse So what s left is to carefully implement the simulation keeping track of charges and choosing what to use according to aforementioned rules 
320,Consider the cases when it is impossible to form a given permutation 1 For root it is true that For any other vertex the value of will be positive since there is at least one edge of positive weight on the path to it 2 In a rooted tree there is exactly one path from the root to any vertex and it goes through its parent so it must always be true Let us start filling the array where Consider a vertex The vertex whose distance at the current time is maximal is Then is at least We assign a value to remembering to check that has already been counted After counting all values we can output the lengths of the edges 
321,For each index let s try to find which we should use in order to make th element of equal to zero If then no matter which we choose So we should just ignore this index and add to the answer if Otherwise we should choose Let s calculate the required fraction for each index and among all fractions find one that fits most indices this can be done for example by storing all fractions in a The only thing that s left to analyze is how to compare the fractions because floating point numbers may be not precise enough Let s store each fraction as a pair of integers where is the numenator and is the denominator We should normalize each fraction as follows firstly we reduce it by finding the greatest common divisor of and and then dividing both numbers by this divisor Secondly we should ensure that numenator is non negative and if numenator is zero then denominator should also be non negative this can be achieved by multiplying both numbers by 
322,Firstly we can understand that during each full cycle of from to we can fix each remainder only once Notice that when we add some then we fix the remainder and we don t need to fix elements which are already divisible by So let be the number of such elements for which the condition holds i e the number of such elements that we can fix if we add the value to them We can count this using some logarithmic data structure like in C So what s the number of full cycles It equals to the amount of most frequent element in minus one So the answer is at least And there can be one last cycle which will be incomplete So what is the remanining number of moves It equals to the maximum possible among all So if is the maximum such that then the answer is Time complexity 
323, can be arbitrarily large if and only if all numbers in the array are the same In this case we can choose any number and subtract it from all the numbers for example exactly once Suppose we fix some Let be the number of subtractions of the number from the number In this case all numbers will be equal if and only if for any two numbers and from the array Let be the minimum of Then all numbers in the array become the same if for each index we subtract from not but times Then we will never subtract from the element This means that there is always an element in the array from which we can never subtract This element is the minimum on the array Then from we will subtract exactly times Thus with the current it is possible to make all elements equal if and only if for all elements the value where is the minimum on the array is divisible by So the maximum is the greatest common divisor of all values of 
324,Since the number of days doesn t exceed let s iterate over this value from to So now we have to check somehow if the current number of days is enough to write a coursework Let the current number of days be The best way to distribute first cups of coffee for each day is to take maximums in the array Then we have to distribute second cups for each day Let s also take the next maximums in the remaining array and so on How do we can calculate such a thing easily Let s sort the array in the reversed order before iterating over all numbers of days then the following formula will work fine for the current number of days So if the value of the formula above is greater than or equal to then the current number of days is enough If there is no any suitable number of days the answer is 
325,Let be the number such that after some sequence of moves there will be at least elements in the array We can see that there is always possible candidates because all values are among all possible values of for some from to So we need to check each candidate separately and try to update the answer with it How to do this Let the current number we trying to obtain is Then let s iterate over all in any order Let be the current value of Let s divide it by while its value is greater than and carry the number of divisions we made If after all divisions then let s remember the value of in some array If after iterating over all elements of the size of is greater than or equal to then let s sort it and update the answer with the sum of smallest values of Time complexity or depends on sorting method 
326,Fairly enough solutions of both versions of the problem are pretty similar The major difference between them are the vertical bricks As you aren t required to minimize the total height you can work not with the heights themselves but with their parities instead Vertical brick now does nothing and horizontal brick changes the parity of neighbouring parts of the same parity Now imagine the following greedy solution While you have some segment of the same parities of even length fill it with horizontal bricks This operation merges this segment with one to the left and to the right If there is a single segment left then the answer is Otherwise it s The proof is left to the readers Implementing this as it is will be at best You ll need to keep the whole set of segments and the set with only even length ones But there exists more fun approach We don t even need the lengths of the segments just the parities of the lengths Then merging the even segment with something will just erase that segment and xor the length of the left and right ones Moreover you don t even need to erase the whole even segment you can do it brick by brick as this operations are now the same Let s simulate this with a stack When the new number comes push its parity to the stack If the topmost two elements of the stack have the same parity pop them both Now the answer is if at the end stack has no more than one element When I heard of this problem I actually had not that stack itself in mind but the correct bracket sequences Like let s define parity 0 as and and parity 1 as and Now the operations we perform with stack are greedily put the closing bracket if the last unclosed bracket was of the same type and put opening otherwise Then the stack will have like all the brackets which are still to be closed and you ll close them as early as you can This idea helped to both prove the correctness of algo and implement it Overall complexity 
327,In this problem we can just iterate over all possible substrings and try to remove each of them After removing the substring we can check if remains the subsequence of in linear time Let we remove the substring Let s maintain a pointer the initial value of the pointer is and iterate over all possible from to If and let s increase by one If after all iterations then let s update the answer with the length of the current substring 
328,You can just implement what is written in the problem statement and solve this problem this way Let s iterate over all starting positions of the substring from to and over all possible offsets of the string from to inclusive Then let s iterate over all position of the current substring from to and carry the variable which denotes the answer for the current starting position and the current offset And if then let s increase by After iterating over all positions let s update the answer with the value of 
329,In this problem the following greedy solution works let s find the leftmost point covered by more than segments We should fix it somehow How to do it Let s find some segment that was not removed already it covers this point and its rightmost end is maximum possible and remove this segment You can implement it in any time you want even in naively 
330,Well the main idea is described in the previous D1 problem editorial Read it firstly So now we have to improve our solution somehow How can we do it Wait What is it We iterate over all numbers of days And the number of pages Polycarp can write when we consider days instead of is strictly increases because we always can drink any cup even with the minimum value of as a first during the new day and the number of pages will increase So what is it Oh this is binary search So all we need is to replace linear search to binary search submit the written code and get AC 
331,Suppose and are even A necessary and sufficient condition of existence of the answer is that is even Let s prove the sufficient condition If the count of the horizontal dominoes is even then we can combine them and vertical dominoes to blocks of size the number of the vertical dominoes is even too if is even If and are even we can fill the table with these blocks The description of the locations of the dominoes may be printed as follows consider the table is a chessboard where a cell is a block of two dominoes Consider the leftmost topmost cell of the board is black If a cell of the board is black let s mark one of the dominoes of the block with the letter and the other one with the letter If a cell of the board is white let s mark one of the dominoes of the block with the letter and the other one with the letter There will be no situation that some two cells of the table are marked with one letter but belong to different dominoes Let s prove the necessary condition The number of cells in a column is even so the number of cells that belong to vertical dominoes is even because cells of each vertical domino may be either belong to the column or not belong at the same time So the number of cells that belong to horizontal dominoes is even Let s cross out all cells that belong to vertical dominoes and let s find the leftmost column having cells that haven t been crossed out It s the leftmost column with such cells so the pairwise cells of the non crossed out cells belong to the column to the right of the found one The number of such cells in the right column is equal to the number of found cells so it s even and the number of found horizontal dominoes is even too Let s cross out the found cells and the pairwise cells The number of non crossed out cells in the right column will be even The number of crossed out horizontal dominoes will be even too Let s repeat this procedure until all the dominoes will be crossed out In every step we have crossed out the even number of horizontal dominoes hence the total count of horizontal dominoes is even Suppose is odd hence is even In this case every column contains an odd number of cells whereas the number of cells that belong to vertical dominoes is even So the number of cells that belong to horizontal dominoes is odd Consider the leftmost column and find a cell of it that belongs to a horizontal domino it must be found because the number of such cells is odd so it isn t equal to Let s find the pairwise cell and cross out both cells Currently the two columns will have an even number of non crossed out cells Let s repeat the procedure until all columns will have even non crossed out cells We will cross out cells and dominoes So the necessary condition is that the number of horizontal dominoes is at least Let s extend the necessary condition with the following condition the value of is even Consider the table that we ve become after the previous procedure where each column has exactly one crossed out cell Let s start the procedure we ve done in the case of even both and The procedure can be started on our table because each column of the table has an even number of non crossed out cells As a result of the procedure we will cross out an even count of horizontal dominoes so the value of is even Let s build an answer if the conditions and is even are met Let s place in the topmost row horizontal dominoes and mark their cells as follows the first domino will be marked with the second one with the third one with and so on As the result the region of rows and columns will be unfilled Both values are even and the value of is even too So let s fill the region as if it s a separate table having even numbers of rows and columns As it was proved above it s possible to do The set of letters used for the region and set of the letters used for the topmost row don t have common elements so there will be no cells that are marked with one letter but belong to different dominoes The case of odd hence is even is similar to the previous one let s transpose the table it will have rows and columns swap the values of and solve the case above and transpose the table back to have rows and columns 
332,In this problem we need to write almost the same solution as in the previous one easy version but faster Observe that we calculate the value of too many times Let for all from to be the array of numbers of divisions we need to obtain from every possible from which we can We can calculate these arrays in time How Let s iterate over all and divide it by while it is positive and carry the number of divisions Then let s add to the array the number before each division Then we can see that we obtain the array from the tutorial of the previous problem for each from to Let s iterate over all possible values of and try to update the answer with the sum of smallest values of if there is at least elements in this array Time complexity or depends on sorting method 
333,Fairly enough solutions of both versions of the problem are pretty similar Read the second part of the previous tutorial first This problem can also be implemented in the strightforward manner The greedy solution now is searching for the first minimum in array and putting a brick in there If it s impossible then the answer is This can also be simulated with sets a bit more tedious but still ok and also Now back to the stack approach Here you can t go to parities of the numbers like tests and lead to different results You push the number itself However you will also need an extra condition on the stack You can t push to it the number greater than the current topmost element The only problem with this are maximums of array Obviously the resulting wall if the answer exists will be of height equal to the maximum initial height And it means that you shouldn t care about the ability to match all maximums in stack They way I suggest to take around the issue is to process separately each segment between two consecutive maximums One can easily prove the correctness of it by construction Overall complexity 
334, can be arbitrarily large if and only if at least half of the numbers in the array are the same In this case we can choose any number and subtract it from all numbers for example exactly once Let s iterate over the element it will be the minimum among the numbers that we want to make the same Let s calculate the number of numbers in the array that are equal to this element If this number is at least then the answer is Otherwise we will iterate over numbers which are strictly greater than the selected minimum and for each number we will iterate over the divisors of the number For each of the found divisors let s calculate the number of for which this divisor was found Among all such divisors for which the sum of the found number and the number of numbers equal to is greater than or equal to we will choose the maximum one The greatest found divisor will be the desired This solution works in where is the absolute value of the maximum on the array 
335,Let be such rightmost position in that the substring is the subsequence of We need values for all from to We can calculate it just iterating from right to left over all characters of and maintaining the pointer to the string as in easy version Then let s iterate over all positions from to and maintain the pointer as in the easy version which tells us the maximum length of the prefix of we can obtain using only the substring exclusively Suppose we want to remove the substring of starting from Then if then let be otherwise let be tells us the farthest rightmost character of the substring we can remove So we can update the answer with the value and go to the next position and don t forget to increase if needed 
336,In this problem you should make the same as in the previous one but faster Let s consider three offsets of string and Let s copy the current offset of the string so that it will has the length possibly without some trailing characters and save it in the string Then let s compare the string with this offset of length and build an array of length where if Then let s iterate over all possible continuous subsegments of this array and maintain the variable denoting the current answer Firstly for the current position let s add to Then if the current position is greater than or equal to indexed let s decrease by So now we have the continuous subsegment of the array of length no more than Then if the current position is greater than or equal to indexed again the current subsegment has the length then let s update the answer with Then let s do the same with two remaining offsets 
337,In this problem we need to implement the same greedy solution as in the easy version but faster Firstly let s calculate for each point the number of segments covering it We can do it using standard trick with prefix sums increase decrease and build prefix sums on the array Let s maintain the set of segments that cover the current point sorted by the right endpoint We can do this with almost the same trick append to the array the index that says us that in the point the th segment is opened And add to the the index that says us that in the point the th segment is closed Note that you need to add indexed values because and are the same thing actually We can change the array to carry the number of segments covering each point using some structure but we don t need to do it Let s maintain the variable that will say us the number of segments covering the current point that was already removed Also let s carry another one array which will say us when we need to decrease the variable So we calculated the array of arrays the array and we can solve the problem now For the point let s remove and add all segments we need using the array and add to Now we know that the set of segments is valid is also valid and we can fix the current point if needed While let s repeat the following sequence of operations take the segment with the maximum right border from the set remove it increase by one and decrease by one Note that when we remove segments from the set at the beginning of the sequence of moves for the point we don t need to remove segments that we removed by fixing some previous points and we need to pay attention to it Time complexity 
338,How can a player be checked if he can win the championship Obviously he must participate in all the games otherwise we will increase the number of tokens of the opponents So you can sort out all the people and play greedily with the weakest ones Such a check will work in linear time after sorting so we got a solution for The simplest solution to this problem is binary search for the answer We will sort all the players by the number of tokens they have Let s prove that if player can win then player can also win the numbers are dealt after sorting If the player was able to win then based on the strategy above he was able to defeat all the players on the prefix The player can also defeat all these players since he has at least as many tokens Now both players have to defeat all opponents with numbers and the number of chips both players have is equal to the sum of the first numbers in the array So if the player has a strategy then the player can use the same strategy Hence the answer to the problem is sorted suffix of the input array You can find this suffix using binary search and linear time checking Bonus this problem also has a fully linear after sorting solution 
339,Let s see which remainders modulo change into which ones If the array contains a number divisible by then it cannot be changed If there is a number that has a remainder of modulo then it can only be replaced once Thus if the array contains a number divisible by then we apply this operation to all elements of the array once and check that all its elements are equal The remaining odd balances immediately turn into even ones The even remainders change in a cycle while the array element increases by in operations Thus we will apply the operation to each element of the array until its remainder modulo becomes for example and then check that the array does not contain both remainders and modulo 
340,It is obvious that Masha will enter into agreements only with bloggers that have the most subscribers You can sort all the bloggers and greedily select the prefix Let be the minimum number of subscribers for the hired blogger Then we must hire all the bloggers who have more subscribers Let the number of bloggers who have more than subscribers the number of bloggers who have exactly subscribers Then we should select bloggers from The number of ways to do this is equal to the binomial coefficient of by You could calculate it by searching for the inverse element modulo Then you could calculate the factorials and use the equality Alternatively you can use the equation and calculate it using dynamic programming This method is better known as the Pascal triangle 
341,In this problem we have to calculate the number of positions such that if we change the type of the bracket at this position then the obtained bracket sequence will become regular Let s calculate the balance of each prefix of the bracket sequence and store it in the array Just iterate from left to right over the string and if the current bracket is opening then increase the current balance by one otherwise decrease it by one For each prefix let s also calculate whether it can be a prefix of a regular bracket sequence RBS and store it in the array The prefix of length can be the prefix of RBS if and only if the prefix of length can be the prefix of RBS and Let s calculate the same arrays for all suffixes and call they and correspondingly but now the closing bracket will increase the balance by one and the opening will decrease it by one and we consider the characters from right to left Now if we have these arrays let s iterate over all positions in the initial bracket sequence If we now at the position then let s do the following things firstly if or then skip this position Otherwise if the current bracket is opening then we have to increase the answer if and only in this case the bracket sequence will become regular And if the current bracket is closing then we have to increase the answer if 
342,Let s denote by the number of sheep in the string and by their positions in the string Note that in the optimal solution the sheep with the number will not make moves This can be proved by considering the optimal solution in which the sheep with the number makes at least one move and come to the conclusion that this solution is not optimal Consider sheep with numbers from to Then the final position of the th sheep will be and the answer will be 
343,To solve this problem let s take a look which powers of in will be affected by powers of in Firstly let s reverse numbers Let s carry the current power of let it be the current sum of powers of in from the position to the current position inclusive let it be and the answer is Initially and Let s iterate over all bits of from to Let the current bit in have the number Firstly if and then set in other words we add to the sum of powers of in the current power of If then this bit will add to the answer all the powers of in from to inclusive in other words so if it is then set And after all we can set and go on to And don t forget to take all values modulo to avoid overflow 
344,Let be the last weight of the boxer taken into the team Initially Let s sort all boxers in order of non increasing their weights and iterate over all boxers in order from left to right If the current boxer has the weight then let s try to take him with weight we can do it if If we cannot do it let s try to take him with weight And in case of fault let s try to take him with weight If we cannot take him even with weight then let s skip him And if we take him let s replace with him weight The answer is the number of boxers we took 
345,Let s analyze three cases based on the distance between two sections we are going to break break two neighboring sections and break two sections with another section between them and break two sections with more than one section between them Why exactly these cases Because the damage from the shots and the possibility to hit both sections with the same shot depends on the distance between them If there is more than one section between the two we want to break then any shot hits only one of these sections so each shot should be aimed at one of those sections and we break them independently Let s pick two sections with minimum durability and calculate the number of shots required to break them if these sections are and then the required number of shots is It actually does not matter if the distance between them is less than if it is so these sections will be analyzed in one of the other cases Okay now let s deal with two sections having exactly one section between them We can iterate on all combinations of these sections iterate on from to and pick sections and Let s analyze how can we damage them If we shoot at the section between them we deal damage to both sections if we shoot at one of those sections we deal damage to it and damage to the other section So each shot distributes damage between these two sections the way we want to distribute it and the number of shots required to break these two sections is The case when we try to break two adjacent sections is the trickiest one Let s say that these sections are and and If we target one of these sections we deal damage to it and damage to the other section Let s try to run the following algorithm shoot at the section with higher durability until both of them break It can be slow but we can see that after the first shots the durabilities of the sections become equal and each pair of shots after that deals damage to both sections So we can model the first shots subtract from and from and then we ll need shots The only case when this doesn t work is if we break both sections before we equalize their durabilities it means that and we need to do only shots 
346,Firstly we should find the minimum and maximum numbers of passengers which could be in a bus if initially it was empty Let We should iterate through the bus stops For the th bus stop we add to and update with a value of the minimum number of passengers and the maximum number of passengers If it is an invalid case and we should print because the maximum number of passengers should be less or equal to Let is a minimum possible number of passengers in the bus before the first stop and maximum possible If then in the bus initially were at least passengers Because we should make else If then else After that we should compare and If print In the other case print because each of those values is correct 
347,This is easy dynamic programming problem It is easy to understand that we don t need to go down at all otherwise your solution will be Dijkstra s algorithm not dynamic programming Let be the minimum required time to reach the floor if we not in the elevator right now and be the minimum required time to reach the floor if we in the elevator right now Initially all values are except and Transitions are pretty easy we was not in the elevator and going to the next floor using stairs we was in the elevator and going to the next floor using stairs we was not in the elevator and going to the next floor using elevator we was in the elevator and going to the next floor using elevator The answer for the th floor is Time complexity 
348,I ll consider the case when the other case is symmetric and the answer I construct is the same but shifted by to the right Consider the given field as a matrix where is the number of row and is the number of column Firstly let s build the line of length from the cell to the cell Then will decrease by and will become Then we have two black cells to the left and to the right and and black cells to the up all cells for all from to and black cells to the down all cells for all from to Let s add the required number of cells to the answer If even after adding all these cells still be greater than then the answer is maybe there will be a proof why it is so but you can read it already from other participants Otherwise the answer is and we constructed the required component 
349,This problem has an easy constructive solution We can find lower and upper bounds on the value of for the given If the given does not belong to this segment then the answer is Otherwise the answer is for any in this segment How to construct it Let s start from the chain The answer for the chain is the upper bound of and it is Then let s try to decrease the answer by in one move Let s take some leaf the vertex without children with the smallest depth that is not and try to move it up The definition of badness will be below To do this let s find such vertex that its depth is less than the depth of by and it has less than children If we found such vertex then let s make the child of and decrease the answer by one If we didn t find such vertex I claim that the vertex has the minimum possible depth it can have and we should not consider it in the future Let s mark this vertex as and continue our algorithm If at some moment we cannot find any not leaf then the answer is Otherwise the answer is Time complexity 
350,Let s sort all people by their height in descending order Now let s go through all the people and look for the position of the person in the sorted array the height of which is strictly less than ours for example by binary search Obviously only those people who are in the sorted array later than the found person can stand in front of us all of them have a height strictly less than ours Among all these people it is more profitable for us to take a person with minimum width In order to find such a person quickly we can find a person with the minimum width for each suffix of the sorted array To handle a situation where a person is lying down we need to swap the width and height and repeat the algorithm above 
351,Firstly let s run bfs on the given graph and calculate distances for all vertices In fact we don t need distances we need their parities The second part is to find all vertices with an even distance all vertices with and odd distance and print the smallest by size part Why is it always true Firstly it is obvious that at least one of these sizes will not exceed And secondly because we are checking just parities of distances it is obvious that each vertex of some parity is connected with at least one vertex of the opposite parity because it has this parity from some vertex of the opposite parity 
352,Let s solve this problem for each connected component of the given graph separately It is easy to see that the connected component is a cycle iff the degree of each its vertex equals to So the solution is to count the number of components such that every vertex in the component has degree The connected components of the graph can be easily found by simple dfs or bfs 
353,Firstly if the graph consisting of initial vertices and only directed edges contains at least one cycle then the answer is Otherwise the answer is always Let s build it Let s build the topological sort of the graph without undirected edges Then let s check for each directed edge if it s going from left to right in order of topological sort If it isn t true then there is a cycle and the answer is Otherwise let s direct each edge from left to right in order of the topological sort 
354,Let s iterate over all pairs of digits in the number Let the first digit in the pair be at position and the second at position Let s place these digits to the last two positions in the number The first greedily goes to the last position and then the second goes to the position next to that Now the number can contain a leading zero Find the leftmost non zero digit and move it to the first position Then if the current number is divisible by try to update the answer with the number of swaps It is easy to show that the number of swaps is minimal in this algorithm The only difference we can introduce is the number of times digit digit and the leftmost non zero digit swap among themselves And that is minimized You can also notice that the order of swaps doesn t matter and you can rearrange them in such a way that no leading zero appears on any step This solution has time complexity You can also solve this problem with complexity because you have to check only four options of the two last digits It is always optimal to choose both rightmost occurrences of the corresponding digits You can show that even if you are required to swap the chosen ones there will be no other pair with smaller total amount of moves 
355,Let s use the concept of dynamic programming Let s create an array indexed with size of will contain the maximal number of the elements equal to their indices if we have considered the first elements of the sequence and have elements Let s fill the array with zeroes then we will increase the elements of the array for different and Let s start the loop with parameter from to and the internal one with parameter from to Consider an element We can delete or not delete it If we delete this element the number of the elements equal to their indices will not be increased and the number of the non deleted element will not be increased too It means that the answer for may be updated with Since we are interested in a maximum answer we rewrite only if is greater than Suppose we don t delete this element We haven t deleted previously elements so will have the index and there will be non deleted elements if we consider elements so we must update If i e an element equal to its index is found let s update with Otherwise we should update it with Remember that update may be done only if we rewrite the less value with the greater value Let s build the answer as follows We need to minimize the number of deleted elements maximize the number of non deleted elements so that the number of the elements equal to their indices is at least Consider only the elements of having the first index Let s start a loop in the descending order of If is the maximum number of elements that we will not delete so the answer is If we will not find such that there s no desired sequence of moves so the answer is The algorithm works in 
356,We can t model this process directly since the maximum string length reaches look at the second example from the statements To optimize this process you can store each row as a set of the following values Number of occurrences of in the string String length The first three characters of the string are The last three characters of the string are Then to process the second type of request and combine the two strings and into the string you need New occurrences may be added at the junction of two words However if the string length is less than then you need to handle this case carefully with your hands Similarly you need to process small strings separately 
357,Let s create two arrays of length The element of the array will contain the operation number at which the vertex which is the index of the array will be deleted The array will contain the number of neighbors of a given vertex at a certain time This array must be initialized with the number of neighbors in the original tree Initially we will suppose that the gardener performs an infinite number of operations and we will simply calculate for each vertex the number of the operation on which it will be deleted Let s create a queue which will store the order of deleting vertices The queue will contain only those vertices whose neighbors except maybe one have been removed i e Let s add all leaves of the original tree to it for each of them let s store the value in the array because all original leaves will be removed during the first operation Next we will take sequentially one vertex from the queue and update the data about its neighbors Consider the neighbors Since we are deleting the current vertex we need to update of its neighbors If the neighbor s is equal to then it s already in the queue and it doesn t need to be considered right now Otherwise we will decrease the neighbor s by If it becomes equal to then the neighbor must be added to the queue The number of the operation during which the neighbor will be deleted is equal to the number of the operation during which the current vertex will be deleted plus After we calculate the numbers of operations for all vertices we need to select among them those that will not be deleted during operations with numbers Thus the answer is the number of vertices such that 
358,Firstly let s sort all students in order of non decreasing their programming skill Then let s calculate the following dynamic programming is the maximum number of students in at most non empty teams if we consider first students How to do transitions from The first transition is pretty intuitive just skip the th indexed student Then we can set The second possible transition is to take some team starting from the th student The only assumption we need to do it is the following take the maximum by number of students team starting from the th student is always optimally Why it is so If we consider the student with the maximum programming skill in the team we can take him to this team instad of forming the new team with this student because this is always not worse So the second transition is the following let be the number of students in a team if the th student is the first in it We can calculate this part in naively or in using two pointers We can set Time complexity 
359,Let be the string containing all characters of that have indices and so on i e all such positions that have the remainder modulo Suppose we choose that all turned on lamps will have remainder modulo Then we need to remove all ones at the positions that do not belong to this remainder Also considering the string we need to spend the number of moves to make this string of kind contiguous block of zeros contiguous block of ones and again contiguous block of zeros because considering the characters modulo will lead us to exactly this pattern notice that some blocks can be empty How to calculate the answer for the string in linear time Let be the number of moves we need to fix the prefix of till the th character in a way that the th character of is Let be the number of ones in on the segment Notice that we can calculate all required values in linear time using prefix sums Then we can calculate as where is the boolean value of the expression if is true and otherwise Let be the length of Then the actual answer for the string can be calculated as thus we consider the case when the obtained string doesn t contan ones at all and consider each position as the last position of some one So the actual answer can be calculated as Time complexity 
360,Note that any number in the sequence can be made up of possible digits all digits except Then let s find the first digit of the answer notice that it is just or where where the length of the number we re looking for and the maximum Note that simply corresponds to a digit in the base numeral system Why is this so Because without the first digit we can assemble any numbers with possible digits and we can put the digits except in the first place Thus in the answer the first digit will be if and if Note that once the first digit is determined the rest can be found the same way since the prefix does not affect anything 
361,The key idea is that any string of length greater than 3 can be obtained by concatenating strings of length or Then when reading the data remember all occurring substring of length and There are at most Now we will count the dynamics on the prefix if we can get the prefix of length of phone by segments of length and of the known phones Masha Then for the transition we need to look through the lengths and then take a substring of the corresponding length and find out whether such a string occurred in the phones known to Masha Then it will take or time to recalculate the dynamics depending on the implementation But it will still take more time to read the data so the final asymptotic will be or 
362,Count to the variable the number of all ones in the matrix Then consider pairs of diagonals one of which starts in cell and the other in cell for Using cyclic shifts we can assemble the main diagonal from this pair Then among all such pairs and the main diagonal find the one that contains the maximal number of ones and store this number in the variable The number of zeros on the main diagonal which should be turned into ones is equal to The number of ones to be turned into zeros because they are not on the main diagonal is calculated as The total answer is calculated as 
363,This problem supposed to be Let s represent our strings as huge numbers with base Let be and be So if we will see more precisely in the problem statement then we can see that the answer is The operation with long numbers can be done in and division long number by two also can be done in All details of implementation are in the author s solution 
364,First let s sort the array Then we will consider its elements in non decreasing order To make MEX equal to you need to increase all zeros To make MEX at least you first need to make MEX at least and then if the number is missing in the array you need to get it If there are no extra values less than then this and all subsequent MEX values cannot be obtained Otherwise you can use the maximum of the extra array values To do this you can use a data structure such as a stack If an element occurs more than once in the array put its extra occurrences on the stack 
365,Let s form the following vector we run DFS from the first vertex and push the vertex to the vector when entering this vertex Let be the position of the vertex in the vector the size of the vector in moment we call DFS from the vertex and be the position of the first vertex pushed to the vector after leaving the vertex the size of the vector in moment when we return from DFS from the vertex Then it is obvious that the subtree of the vertex lies in half interval After running such DFS we can answer the queries Let answering the th query If is greater than or equal to then answer to the th query is We need to check if the vertex lies in the subtree of the vertex The vertex is in the subtree of the vertex if and only if If the vertex is not in the subtree of the vertex then answer is Otherwise the answer is Overall complexity is 
366,Let s start with the solution and then proceed to the proof For each tree in a forest find such a vertex that the maximal distance from it to any vertex is minimal possible a center of a tree Tree may include two centers take any of them in that case Find the the tree with the maximum diameter Connect the centers of other trees with its center Overall complexity is the complexity of looking for a diameter or The center is the best vertex in a tree to connect to The diameter of merging two trees and by in and in with being the maximum shortest path from to any other vertex in being the same for in is Thus minimizing both and will produce the best result The most optimal structure is a star The center tree will be connected directly to any other tree The other trees will be connected through a single vertex among each other which leads to the answer no more than 1 worse than connecting them directly And building the answer the other way will exceed this difference as some tree will be connected to the center tree of the star through one vertex as well The previous fact implies that the center tree of the star should have the maximal diameter among all trees 
367,Let s maintain all elements of the array b in a set that allows multiple copies of equal elements for C Then let s iterate from left to right over the array a and try to minimize the current element in array c This order will minimize the resulting array by lexicographical comparing definition So for the i th element a i let s find the minimum element greater than or equal to n a i in the set because n a i will give us remainder 0 n a i 1 will give us remainder 1 and so on If there is no greater or equal element in the set then let s take the minimum element of the set and take it as a pair for a i otherwise let s take this greater or equal element and remove it from the set Time complexity O n log n 
368,We are interested in such subsegments of the array that for every value belonging to this segment all occurences of this value in the array are inside this segment Let s call such segments For example if then and are closed segments We can see that the result is some partition of the given array into several closed segments if for some value all occurences of in do not form a segment in then there exists some pair such that which contradicts the statement and if the formed segment is not a closed segment then for some indices and such that it is not true that which also contradicts the statement Okay let s try to partition the array into closed segments greedily take the first prefix of the array that is a closed segment erase it take the next prefix and so on Let be the number of closed segments we got with this procedure The key fact is that To prove it suppose we partitioned the array in some other way The intersection of two closed segments if it exists is also a closed segment so there exists at least one segment in the partition we picked greedily that can be broken into two but that contradicts the algorithm we used to construct this partition So we may merge some of segments to get a valid partition There are exactly ways to do so because for every pair of adjacent segments we may choose whether we will merge it 
369,In this problem we have directed graph consisting of vertices indices of the array and at most edges Some vertices have the value some have the value Our problem is to find for every vertex the nearest vertex having the opposite parity Let s try to solve the problem for odd numbers and then just run the same algorithm with even numbers We have multiple odd vertices and we need to find the nearest even vertex for each of these vertices This problem can be solved with the standard and simple but pretty idea Let s inverse our graph and run a multi source breadth first search from all even vertices The only difference between standard bfs and multi source bfs is that the second one have many vertices at the first step vertices having zero distance Now we can notice that because of bfs every odd vertex of our graph has the distance equal to the minimum distance to some even vertex in the initial graph This is exactly what we need Then just run the same algorithm for even numbers and print the answer Time complexity 
370,Let s iterate over the length of the beautiful necklace For each position make an edge to the position where is the remainder of dividing by What is a cyclic shift by in this construction A bead located at position will go along the edge to position Consider all the cycles of a graph constructed on You may notice that if only equal letters are found in each cycle then with a cyclic shift by the graph and the string will remain unchanged Thus in order to check whether it is possible to make a beautiful necklace of length you need to make a graph find the cycles in it and check whether it is possible to distribute the letters from the string in cycles such that each cycle have equal letters The last part of the solution can be done with simple greedy 
371,At first treat the two subtasks as completely independent problems For both solutions the array of frequences is more convinient to use so let s build it is the number of friends living in house 1 MinimumCollect the answer greedily from left to right If then proceed to otherwise add to the answer and proceed to To prove that let s maximize the number of merges of houses instead of minimizing the actual count of them It s easy to show that the final number of houses is the initial one minus the number of merges So if there are people in all consecutive houses starting from then merges is the absolute best you can do with them skipping any of the merges won t get the better answer For only of them occupied merge is the best and we can achieve that merge And a single occupied house obviously will do merges 2 MaximumAlso greedy but let s process the houses in segments of consecutive positions with positive Take a look at the sum of some segment of houses If the sum is greater than the length then you can enlarge that segment house to the left or to the right If the sum is greater by at least than you can enlarge it both directions at the same time Thus the following greedy will work Let s update the segments from left to right For each segments check the distance to the previous one if it was enlarged to the right then consider the new right border If you can enlarge the current segment and there is space on the left then enlarge it And if you still have possibility to enlarge the segment then enlarge it to the right Notice that it doesn t matter which of any pair of consecutive segments will take the spot between them as the answer changes the same The initial segments can be obtained with two pointers Overall complexity 
372,Because our graph is just a tree with an additional edge consider it as a cycle with trees hanged on cycle vertices Consider some tree hung on a vertex v on a cycle There is only one path between each pair of its vertices including the root which is a vertex v So if the tree has cnt v vertices then frac cnt v cnt v 1 2 paths are added to the answer What about paths that go out of a tree Let s assume that there are cnt v cdot n cnt v such paths yeah we counted only a half of actual paths from this component but this is fine When we consider other trees we will take into account the other half of paths This information can lead us to the conclusion that the only information we need to know about trees hanged on cycle vertices is the number of vertices in these trees So if we know cnt v for each vertex on a cycle we can just calculate the answer as sum limits v in cycle frac cnt v cnt v 1 2 cnt v cdot n cnt v So how to find values cnt v Of course there is a simple and straight forward solution just extract and mark all cycle vertices and run dfs from every vertex of a cycle but there is another approach without any graph algorithms that works very well for such kind of graphs Initially let cnt v 1 for each v from 1 to n Let s create a queue containing all leafs of the graph Let s take the leaf x get its parent p add cnt p cnt p cnt x and remove the vertex x with all edges incident to it After that if p became a leaf let s add it to the queue We can see that after processing all leafs only cycle vertices remain in the graph and cnt v is exactly the number of the vertices in a tree and we can just calculate the answer using the formula above This approach can be implemented in O n log n or in O n there is almost no difference but O n log n one can be written a bit simpler than a linear one 
373,At first let s decrease all elements by one and solve the problem in indexation The first observation is that we can solve the problem independently for each column Consider the column It consists of elements Now consider some element We don t need to replace it with some other number in only one case if we shift the column such that will coincide with the corresponding number of the required matrix Obviously there is only one cyclic shift of the column that can rid us of replacing So the idea is the following let s calculate for each cyclic shift the number of elements we don t need to replace if we use this cyclic shift Let for the th cyclic shift indexed it be Then the answer for this column can be taken as How to calculate for the element the corresponding cyclic shift Firstly if is modulo operation then there is no such cyclic shift Otherwise let If then there is such cyclic shift can be greater than or equal to because can be up to and the number of such cyclic shift is So let s increase and continue After considering all elements of this column take the answer by the formula above and go to the next column Time complexity 
374,It is easy to show that if we choose k numbers from a permutation of length n then the minimum sum of k numbers is frac k k 1 2 the maximum sum is frac k 2n 1 k 2 and any sum between them is achievable that is you can choose exactly k numbers from n so that their sum is equal to the desired one This fact allows us to implement the following greedy solution Denote for low k sum limits i 1 k i frac k k 1 2 for high n k sum limits i n k 1 n i frac k 2n 1 k 2 and for k r l 1 We will consider the numbers i n n 1 ldots 1 and determine whether to put them in the segment l r or not If k 0 high i k ge s and s i ge low k 1 then put the number i in the segment l r decrease s by i decrease k by 1 Otherwise we will not put the number i in the segment l r In the end if s 0 then we have chosen r l 1 a number with the sum of s so the remaining number can be arranged in any order If at the end s 0 then there is no way to select r l 1 a number from 1 2 ldots n with the sum of s 
375,Note that it makes no sense to use the first type of operation if it does not lead to an instant win because the opponent can return the previous state of the array with their next move So the winner is the one who has time to color their elements in blue first Let s denote as the number of elements that only the first player needs to color as the number of elements only the second player needs to color both players needs to color To win the first player needs to have time to paint elements and they have no more than moves to do it because otherwise the second player can prevent the win of the first player So the winning condition for the first player is Similarly for the second player with the only difference that they have move less because they go second which means the condition is If none of these conditions are met then neither player has a winning strategy which means they will both reduce the game to a draw 
376,Suppose it s given a string for which the answer exists Consider the last non empty value of Only letter occurs in the value and the letter is the last removed letter At the same time the value of is a suffix of so the last character of is the last removed letter Consider the second last non empty value of It contains exactly distinct letters so that one of them is the last removed letter and the other is the second last removed letter The concatenation of the second last and the last values of is a suffix of consisting only of the letters Therefore the letter which occurrence is the last of the occurrences of all letters except the last removed one is the second last removed letter Considering so other values we are proving that the order of removing the letters is the order occurrences of the letters occur in the string Suppose is the number of the step in which some letter was removed is the number of occurrences of the letter in the value of The letter occurs in exactly different values of In each of them the letter occurs exactly times So the letter occurs in exactly times Therefore using the number of the step in which the letter was removed and the number of the letter s occurrences in let s calculate the number of the letter s occurrences in the string If isn t completely divisible by there s no solution The sum of all of all letters occurring in is the length of the initial value of Since the initial value is a prefix of the possible answer is the prefix of having the length equal to the sum of all Before outputting the prefix check that you can get from the supposed value of the string the string Checking it you may use the algorithm from the statement If the resulting string is equal to the answer is correct and must be outputted otherwise there s no solution 
377,Let s see how the matrix looks like after some sequence of shoots The matrix consists of or There is at least one at position or and any not at position or must have below or right If the second condition is violated then the in the corresponding cell would continue its flight Thus it is necessary and sufficient to verify that the matrix satisfies the condition above 
378,Note that we do not need to consider the numbers we are only interested in the remainder of the division of by and we simply add the value to the answer We get an array where Let s sort it and greedily type index pairs such that This can be done with two pointers Then add the number of matching pairs to the answer counter This will be the answer to the problem 
379,This problem is almost equivalent to the following count the number of sources the vertices with indegree equal to in the given graph s condensation Thus there exist solutions with complexity However the constraints in the problem are small so solutions with complexity also pass One of these solutions is the following first let s mark all the vertices reachable from as using a simple DFS Then for each bad vertex count the number of vertices reachable from it also can be done by simple DFS Let this number be Now iterate over all bad vertices in non increasing order of For the current bad vertex if it is still not marked as run a DFS from it marking all the reachable vertices as and increase the answer by in fact we are implicitly adding the edge It can be proved that this solution gives an optimal answer 
380,Greedy idea To minimize the string we will go from left to right and maintain a variable maximal character from which we will reduce everything to a Initially it is a and we spend of operations on it Then at the next symbol we can either reduce it to a in no more than operations or reduce to a the prefix we have already passed and minimize the next character in the remaining operations 
381,To begin with we will learn how to find the optimal place for the exam that we want to move Let s imagine that it is not in the schedule in this case we have two options Put the exam at the end of the session so that there are days before it Put it in the middle of the largest break between exams let its length be so that between it and the nearest one there is because this is no worse than putting it in any part of any other break That is the answer for such an arrangement is the minimum of the larger of these options and the minimum break in schedule without the moved exam Now note that the minimum break in most variants is the same minimum in the initial schedule So in order to reduce you need to move exactly one of the two exams that form it and you need to check which of the two options is better 
382,Let s look at the answer Let s see how many commands the robot can execute Since the robot breaks goes outside the field if any command causes it to break it either leads to its total shift relative to of exactly to the left or exactly to the right or similarly of exactly up or exactly down Denote by and the sum of the maximum positive right down and maximum negative left up shifts in the corresponding direction By adding up the above constraints we get the fact that the robot will not fall off the board only if and Note that the reverse is also true if both these conditions are satisfied then starting from the point where is the maximum shift along the direction the robot will not pass any of the board s edges Thus it is sufficient to find the number of commands which when executed hold the following invariant The horizontal shift can be calculated as the difference between the number of letters and the number of letters encountered Similarly the vertical shift as the difference of the numbers of and Let s iterate over the sequence of commands maintaining relevant values of for all After executing each command if the robot goes farther in some direction than ever before we update the corresponding Either we reach the end of or we meet a command after which either becomes equal to or becomes equal to and the robot breaks so the previous command was the last one successfully executed The possible answer is where the values are calculated one command before the robot broke 
383,The maximum number of rounds Alice can win is pretty easy to calculate greedily What about the minimum number of rounds It can be shown that if we started using some combination we are better to end it before using the other one There are six possible combinations to not win the round and and and and and and We can iterate over all permutations of these combinations there are possible permutations and greedily apply them Use the first while it is possible then the second and so on and find the best answer It is also possible that the order of these combinations does not matter but we didn t prove that fact Time complexity 
384,Let s introduce the dynamics if on the prefix the answer is Then in this sequence the numbers corresponding to the sizes of the segments from the partition into subsegments will be called A number at position in the sequence if it is is either to the right or to the left of the segment If it is to the left of the segment it can only be interesting if Then If it is on the right side of the segment then if then The answer for the whole sequence is if 
385,First Consider the sum If we substitute the formula of then for every the coefficient at will be equal to so we can find the sum of all is equal to If the sum of isn t divisible by then the answer is Now let s consider the difference between two neighboring towns so If the value of we found isn t a positive integer then the answer if Otherwise we can find a single value of for every It s easy to see that these values are correct Overall complexity per testcase 
386,This is a very standard dynamic programming problem Let be the maximum number of sleeping times if Vova had a sleep times already and the number of times he goes to sleep earlier by one hour is exactly Then the value will be the answer Initially all and What about transitions Let the current state of the dynamic programming be and Then we can don t go to sleep earlier and make the first transition The sign is modulo operation and the notation is the boolean result of the expression if is true and otherwise And the second transition if we go to sleep earlier Don t forget to don t make transitions from unreachable states Time complexity 
387,Let s calculate the answer for the first permutation naively in Then let s recalculate the answer somehow and then maybe prove that it works in linear time Which summands will change when we try to recalculate the function using First of all let s notice that each pair of adjacent elements of is the segment on the permutation To calculate fast let s firstly notice that all segments that cover the element but is not their endpoint will change their length by minus one after placing at the first position because will be removed from all such segments This part can be calculated in Let s use the standard trick with prefix sums and segments Let be the array of length For each pair of adjacent elements and for all from to let s do the following sequence of moves if then there are no points that covered by this segment not being its endpoints so let s just skip this segment Otherwise let s increase the value of by one and decrease the value of by one After this let s build prefix sums on this array make for all from to And now equals to the number of segments covering the element The second part that will change is such segments that is their endpoint Let s store the array of arrays of length and will store all elements adjacent to in the array for all from to But one important thing we don t need to consider such pairs and that it broke my solution somehow so this part is important Knowing these two parts we can easily calculate using Firstly let s initialize the result as Then we need to recalculate lengths of such segments that is their endpoint Let s iterate over all elements in set remove the old segment and set add the length of the segment from to and increase by one if it means that and change their relative order and the length of the segment from to increases by one Now we can see that after iterating over all from to we make at most moves because each pair of adjacent elements in was considered at most twice Total complexity 
388,Polycarp has dominoes on each domino there are numbers it turns out there will be numbers in total We need to divide numbers each number from to into two sets so that all numbers in each set are different each set will consist of numbers It turns out that all numbers from to must occur exactly times no more and no less Let s imagine it all as a bipartite graph where there are vertices from to and dominoes are edges Since each number occurs exactly times then we have a lot of cycles In which the edges of each number must be included in different sets in other words the cycles must be of even length This can be checked in by a simple enumeration 
389,The topic of this problem is BFS Let strings be the vertices of the graph and there is a directed edge from string to string if and only if we can obtain from by removing exactly one character In this interpretation we have to find first visited vertices if we start our BFS from the initial string And then the answer will be just minus the sum of length of visited strings The last thing to mention instead of standard queue of integers we need to maintain the queue of strings and instead of array of visited vertices we have to maintain the set of visited strings Don t forget to stop BFS when you obtain exactly strings If the number of distinct subsequences is less than then the answer is 
390,In general the answer looks like some number of complete full round cycles plus some prefix the the round Check corner case that there are no complete full rounds at all just check the first round in naive way If no solution found the answer has at least one complete full cycle and some prefix If total sum in one round is not negative then a complete full cycle doesn t help and it is again the no solution case Let s find number of complete full cycles We need such number of cycles that if your multiple by total sum and add some prefix the result with negative sign because it is not a damage will be greater or equal than So to find just add with the minimal prefix partial sum and divide the result by minus total sum Now you know the number of complete full cycles just iterate over the last round in naive way to find the answer 
391,Let s make two obvious remarks If we can absorb two astronauts with then we can always first absorb an astronaut with and then an astronaut with If we can absorb some astronaut it is effective for us to do it right now Let s sort the astronauts in increasing order Now let s lock the sequence of serums we use There are only three of them serum can be the first second or third Let s absorb the astronauts in increasing order of their and if we can t then use the next serum in a locked sequence or stop This solution works for 
392,The first thing we don t need the problems we need their counts So let s calculate for each topic the number of problems with this topic and sort them in non decreasing order The counting can be done with or another one sorting The second thing the answer is not exceed very obviously So let s iterate over the number of problems in maximum by the number of problems thematic contest Now we have to calculate the maximum number of problems we can take in the set of thematic contests Let s do it greedily The number of contests in the set don t exceed Let the number of problems in the current contest be at the beginning of iteration the current contest is the maximum by the number of problems Let s take the topic with the maximum number of problems for this contest If we cannot do it stop the iteration Otherwise we can maybe continue the iteration If is even then divide it by and continue with the rest of topics otherwise stop the iteration Which topic we have to choose for the second one contest The answer is the topic with the maximum number of problems which isn t chosen already So let s carry the pointer initially it is at the end of the array of counts and decrease it when we add another one contest to our set All calculations inside the iteration are very obviously Let s notice that one iteration spends at most operations So overall complexity of the solution is The last question is why can we take the maximum by the number of problems topic each time Suppose we have two contests with numbers of problems and correspondingly Let s consider the case when Let the number of problems of the first contest topic be and the number of problems of the second contest topic be The case don t break our assumptions The only case which can break our assumptions is So if it is then we can swap these topics because and and all will be okay So this greedy approach works 
393,Let s construct a tree by the following algorithm if d ge n let s print and terminate the program Otherwise let s keep the array deg of the length n which will represent degrees of vertices The first step is to construct the diameter of the tree Let first d 1 vertices form it Let s add d edges to the answer increase degrees of vertices corresponding to this edges and if some vertex has degree greater than k print and terminate the program The second and the last step is to attach the remaining n d 1 vertices to the tree Let s call the vertex if its degree is less than k Also let s keep all vertices forming the diameter in some data structure which allows us to take the vertex with the minimum maximal distance to any other vertex and remove such vertices It can be done by for example set of pairs dist v v where dist v is a maximum distance from the vertex v to any other vertex Now let s add all vertices from starting from the vertex d 1 0 indexed to the vertex n 1 let the current vertex be u We get the vertex with the minimum maximal distance to any other vertex let it be v Now we increase the degree of vertices u and v add the edge between they and if v still be return it to the data structure otherwise remove it The same with the vertex u it is obvious that its maximal distance to any other vertex will be equals dist v 1 If at any step our data structure will be empty or the minimum maximal distance will be equals d the answer is Otherwise we can print the answer See my solution to better understanding Overall complexity O n log n or O n depends on implementation 
394,Firstly let s choose some deepest farthest from the root vertex in the query among all such vertices we can choose any It is obvious that every vertex in the query should either belong to the path from the root to or the distance to some vertex of this path should be at most one Now there are two ways write some LCA algorithms and other hard stuff which is unnecessary in this problem or write about lines of code and solve the problem Let s take every non root vertex except and replace it with its parent So what s next Now the answer is if vertex after transformation belongs to the path from root to Now we just need to check if it is true We can do this using the very standard technique firstly let s run dfs from the root and calculate for each vertex the first time we visited it and the last time we visited it We can do this using the following code void dfs int v int par 1 tin v T for auto to g v if to par continue dfs to v tout v T Initially equals zero Now we have a beautiful structure giving us so much information about the tree Consider all segments We can see that there is no pair of intersecting segments The pair of segments and is either non intersecting at all or one segment lies inside the other one The second beautiful fact is that for each vertex in the subtree of the segment lies inside the segment So we can check if one vertex is the parent of the other the vertex is the parent of the vertex if and only if and the vertex is the parent of itself How do we check if the vertex lies on the path from the root to the vertex It lies on this path if the root is the parent of it is always true and is the parent of This approach can be used for each path such a path from to that is either or Time complexity 
395,The first idea is the following it is always profitable to add the edges from the vertex to any other vertex The proof is the following if we will add two edges and then the distance to the vertex will be the distance to the vertex will be But we can add edges and and this will be better in fact you cannot obtain the less answer by adding two edges in the other way The main idea is the following Let s carry all vertices of the tree with the distance more than in the set Let the vertex with the maximum distance be What we will obtain if we will add the edge The distance to the vertex will be and the distance to the vertex where is the parent of the vertex if we will root the tree by the vertex will be So we will make reachable at most two vertices if the vertex is already reachable then it will be not counted in the answer Now what we will obtain if we will add the edge We will make reachable all the vertices adjacent to the vertex and the vertex the number of such vertices is not less than so this move won t make the answer greater instead of any other way to add the edge After adding such edge let s remove the vertex and all vertices adjacent to it from the set We need to repeat this algorithm until the set will not become empty Time complexity is I sure that there exists the solution with the dynamic programming in the linear time I will be very happy if someone will explain it to other participants 
396,Let s use technique to solve this problem How many times the value will occur in the answer It will occur times Okay now we can see that for each position we have the value The only non constant value there is So let We should pair the minimum with the maximum the second minimum with the second maximum and so on So let s sort the array and the array reverse the array and calculate the sum of values don t forget about modulo here 
397,Firstly we obviously don t need coordinates at all because we can place both platforms at Let s sort all coordinates in non decreasing order Calculate for each point two values and where is the number of points to the left from the point including that are not further than from the th point i e the number of such points that And is the number of points to the right from the point including that are not further than from the th point Both these parts can be done in using two pointers Then let s build suffix maximum array on and prefix maximum array on For just iterate over all from to and do For just iterate over all from to and do The question is what What did we do We did the following thing the answer always can be represented as two non intersecting segments of length such that at least one endpoint of each segment is some input point Now let s fix this border between segments Iterate over all from to and update the answer with So we took segment that starts at some point to the left from including and goes to the left and took some segment that starts further than including and goes to the right With this model we considered all optimal answers that can exist Time complexity 
398,Firstly we need to choose the set of people to be in the first round dance the other half is going to the second one The number of ways to do that is Then we need to set some order of people in both round dances but we don t want to forget about rotation because rotation can lead us to counting the same ways several times So the number of ways to arrange people inside one round dance is This is true because we just fixed who will be the first in the round dance and place others in every possible order So we need to multiply our initial answer by this value twice because we have two round dances And finally we have to divide our answer by because we counted ordered pairs i e we distinguish pairs of kind and but we don t have to do that So the final answer is divided by This formula can be reduced to You could also find the sequence of answers in OEIS and this can be really useful skill sometimes 
399,We can check the following solution by stress testing or maybe prove it somehow let s iterate over all possible permutations of the string Let the first character of the current permutation be the second one be and the third one be Then let s add the following two candidates to the answer the string consisting of copies of and exactly copies of then exactly copies of and exactly copies of Then the answer will be among these strings and we can check each of them naively 
400,Let s maintain two data structures a queue with positions of students in order of decreasing their programming skill and a set note that we need exactly set with positions of students not taken in any team To construct the first data structure we need to sort pairs in decreasing order of the first element and after that push second elements in order from left to right The second data structure can be constructed even easier we just need to insert all values from into it Also let s maintain an array where if the th student belongs to the first team and otherwise and the variable to determine whose turn is now initially it is While our set is not empty let s repeat the following algorithm firstly while the head the first element of the queue is not in the set pop it out This is how we determine which student will be taken now Let his position be And don t forget to pop him out too Create the additional dynamic array which will contain all students we will add to the team during this turn Let s find the iterator to the student with the position Then make the following sequence of moves times add the element the current iterator is pointing at to the array then if the current iterator is pointing at the first element break the cycle otherwise go to the iterator pointing at the previous element Then let s find the iterator to the student next to the student with position And then let s make almost the same sequence of moves times if the current iterator is pointing to the end of the set break the cycle otherwise add the element the current iterator is pointing at to the array and advance to the iterator pointing at the next element Then let s remove all values from the array from the set and for each student we delete let s set And change the variable to if it is now and to otherwise Time complexity 
401,Consider the answer by bits We know that if the th bit of the number is zero then these bits are the same for and otherwise they differ Then let s first make Note that is already equal to but is not yet So we need to dial another with matching bits we will add them to both integers greedily going from the highest bit to the lowest skipping those bits that are already one in If after this algorithm and do not satisfy the conditions then the answer is In total this solution works for You can see that in the solution above we actually just added to both numbers which could only be done with one set of bits so if the answer exists the pair 
402,If we distribute costs optimally then this pair of paths a rightarrow b and b rightarrow c can look like just a straight path that doesn t visit the same vertex twice or like three straight paths with one intersection point x The first case is basically a subcase of the second one with the intersection point a b or c So if we fix the intersection point x then these two paths a rightarrow b and b rightarrow c become four paths a rightarrow x x rightarrow b b rightarrow x and x rightarrow c We can notice that each path we denoted should be the shortest possible because if it isn t the shortest one then we used some prices that we couldn t use Let the length of the shortest path from u to v be dist u v Then it is obvious that for the fixed intersection point x we don t need to use more than dist a x dist b x dist c x smallest costs Now we want to distribute these costs between these three paths somehow We can see that the path from b to x is used twice so it is more optimally to distribute the smallest costs along this part So let pref i be the sum of the first i smallest costs just prefix sums on the sorted array p Then for the intersection point x the answer is pref dist b x pref dist a x dist b x dist c x if dist a x dist b x dist c x le m We can calculate distances from a b and c to each vertex with three runs of bfs Time complexity O m log m 
403,The first observation we cannot construct more than pairs at all due to second and third rules The second observation we always can construct an answer which will contain all pairs and get some prefix of this answer if we need less than pairs Ho do we do that Let man s costumes colors be in the following order and so on Now we have to set some colors to woman s costumes The first thing comes to mind is to use some cyclic shift of And it is the best thing we can do So let women s costumes colors be in the following order ans so on So we use each cyclic shift of in order from second to last The maximum number of pairs can be obtained when and the number of such pairs is So now we have to prove that second third and fourth rules are satisfied or write a stress test it is not so hard to do it The easiest way to prove all rules are satisfied is the following if some element in the left part has position let s consider all positions modulo then each element in the right part will have all positions expect in order you can see it from our placement Now we can see that all rules are satisfied because of such a placement 
404,Let s sort all students by their programming skills but save the initial indices to restore the answer Now we can understand that we don t need to compose the team of size greater than because in this case we can split it into more teams with fewer participants and obtain the same or even less answer Now we can do the standard dynamic programming the minimum total diversity of the division if we divided the first students in sorted order Initially all other values of are Because of the fact above we can do only three transitions indexed The answer is and we can restore it by standard carrying parent values as a parent of the state we can use for example the number of participants in the team 
405,Let s divide all segments to four classes The first class contains segments which covers both minimum and maximum values the answer of the resulting array the second class contains segments which covers only minimum value of the resulting array the third class contains segments which covers only maximum value of the resulting array and the fourth class contains segments which covers neither maximum nor minimum of the resulting array We can easy see that we cannot increase the answer if we apply segments of first and third classes What is common in this two classes Right both of them are cover maximum value So we can came up with the solution in or depends on implementation Let s iterate over position of the supposed maximum value and apply all segments which not cover it It can be done in with straight forward implementation or in using prefix sums After we apply all needed segments we can try to update the answer with the value of the obtained array 
406,In the easy version of the problem you can count how many times each number occurs the numbers themselves do not exceed n Note that we do not have very many options for which triples of numbers can be included in the answer Let s iterate over x the minimum number in the triples Then there are the following options x x 1 x 2 x x 1 x 1 x x 2 x 2 x x x 1 x x x 2 x x x In each option you need to multiply the number of ways to choose one two or three numbers from all occurrences of this number This is done using binomial coefficients Formally if cnt x is the number of occurrences of the number x then the formulas corresponding to the options in the list above are as follows cnt x cdot cnt x 1 cdot cnt x 2 cnt x cdot frac cnt x 1 cdot cnt x 1 1 2 cnt x cdot frac cnt x 2 cdot cnt x 2 1 2 frac cnt x cdot cnt x 1 2 cdot cnt x 1 frac cnt x cdot cnt x 1 2 cdot cnt x 2 frac cnt x cdot cnt x 1 cdot cnt x 2 6 If we sum these values over all x from 1 to n then we get the answer to the problem 
407,First we need to understand when it is not possible to get to some exit Let s fix a friend who is at the vertex and try to understand if he can interfere with us The paths from to and from to have a common part let it start at the vertex Then if the path from to is not more than from to it can prevent us from reaching this exit by blocking the vertex Since the path from to is common the previous condition is equivalent to the condition that the path from to is not greater than from to Note that if there is more than one such vertex then can overlap each of them simply by going as close to the root as possible Thus Vlad can win if there is such a leaf which by condition exits for which the distance to the root is less than the distance to any of the friends By running a breadth first search at the same time from each vertex with a friend we can find the shortest distance to any friend from each vertex and by running from the root the distance to the root Now let s just go through all the leaves and check if there is one among them that the distance to the root is less We can also run from the vertices with friends and from the root at the same time assigning them different colors then the color will correspond to what is closer the root or some friend this solution is attached to the tutorial There is also another solution which is a simplified version of the one we will use in E2 
408,The segment has median equals if and only if belongs to it and or where is number of elements in that strictly less than and is number of elements in that strictly greater than Here we ve used a fact that is a permutation on there is exactly one occurrence of In other words belongs and the value equals or Calculate prefix sums where the value on the prefix of the length i e on the subarray For fixed value it is easy to calculate number of such that is suitable At first check that met on Valid values are such indices that no on and or Let s maintain number of prefix sums to the left of for each value We can use just a map where is number of such indices that and is to the left of So for each that contains do where is the current value Time complexity is if a standard map is used or if classical array for is used remember about possible negative indices just use an offset 
409,Let s take a look on the upper bound of the number where is the maximum possible number of block which can be asked If we assume that each number has length then the sum of lengths will be equal to And as we know this value equals So the maximum value of is not greater than Now we can just iterate over all from to where is no more than and carry the length of the last block If this length is greater than or equal to indexed then let s decrease by this length increase the length of the last block and continue Otherwise our answer lies in the current block So then let s iterate over all from to and if the decimal length of is greater than or equal to then decrease by this length otherwise our answer lies in the current number and we just need to print indexed Time complexity per query 
410,We ll process the permutation elements one by one For the first element it doesn t matter which side of the deque we add it to the result of its addition will be the same there will be a sequence of one element equal to the first permutation element in the deque Now let s consider adding the th element of a permutation to the deque First will be considered then and so on up to Let us describe the general algorithm for choosing the side of the deque for each step Note that if the elements are now in the deque then all final permutations that can be obtained in the deque from the current state can be broken down into pairs of the form where the beginning and the end of the final permutations hidden behind are obtained by the same sequences of all the following choices and thus are equal between the first and the second Note that when the first permutation will always be lexicographically smaller than the second one and vice versa Therefore regardless of the following choices if then the second permutation will never be minimal and if then the first permutation will never be minimal This means that we can make a choice about the side of the deque to add the th element to based only on its relation to if then is added to the beginning of the deque otherwise to the end The time complexity is Alternative solutions which also fit in the time limit involved finding a lexicographically minimal increasing sequence in the reversed original permutation and could be implemented either with time complexity or with time complexity if the permutation s definition was taken into consideration 
411,Let s divide all books into four groups both Alice and Bob doesn t like these books only Alice likes these books only Bob likes these books both ALice and Bob like these books Obviously group is useless now So how to solve the problem Let s iterate over the number of books we take from group Let it be Then we obviously need to take exactly books from groups and Among all books in these three groups we have to choose the cheapest ones To calculate sum of times in each group fast enought we can sort each group independently and implement prefix sums on these arrays If is less than zero or greater than the size of or group for each possible then the answer is And don t forget that the answer can be up to Time complexity 
412,Since we are almost unlimited in the number of in the answer the following solution will works We iterate over all possible centers and try to extend rays of the current as large as possible It can be done by the simple iterating and checking in If the size of the current is non zero let s add it to the answer It is obvious that the number of in such answer will not exceed Then let s try to draw all these on the empty grid Drawing of each is also can be done in If after drawing our grid equals to the input grid the answer is and our set of is the correct answer Otherwise the answer is Time complexity 
413,Note that the actual problem is to divide the string into two subsequences that both of them are non decreasing You can note that this is true because you cannot the relative order of the elements colored in the same color but you can write down subsequences of different colors in any order you want In this problem you can write the following dynamic programming is if you can split the prefix of the string into two non decreasing sequences such that the first one ends with the character and the second one with characters are numbered from to otherwise is zero Initially only other values are zeros Transitions are very easy if the current value of dp is then we can make a transition to if and to if Then you can restore the answer by carrying parent values But there is another very interesting solution Let s go from left to right and carry two sequences and If the current character is not less than the last character of then let s append it to otherwise if this character is not less than the last character of then append it to otherwise the answer is If the answer isn t then and are required sequences The proof and other stuff will be in the editorial of the hard version Time complexity or or 
414,Let s precalculate for each number indexed the array of length where is the number of occurrences of the number on the prefix of length This can be done with easy dynamic programming just compute prefix sums Also let be and it s meaning is the number of occurrences of the number on the segment indexed Firstly let s update the answer with we can always take all occurrences of the same element as the answer Then let s iterate over all possible segments of the array Let the current segment be Consider that all occurrences of the element in the middle block belong to Then we can just take the most frequent number on this segment We also have to choose the number for the first and the last blocks It is obvious that for the number the maximum amount of such numbers we can take is So And we can update the answer with Time complexity where is the size of alphabet the maximum value of 
415,In these constraints the problem could be solved as follows Note that for strings of length and more it is enough to check that the strings and match character by character that is up to permutation since each character can be moved to the desired half and then moved to the desired side by length by applying two operations on the length is and For example there was a string and we want to shift the character to the left then we can first get the string and then the string Well we can restore the used symbols by putting them in their place That is we were able to simply swap two adjacent characters Thus with such a clipping it was possible to solve the problem by brute force for To iterate it was possible to store of strings which we can get and iterate through all the strings using 
416,Let s define as the number of leaves in the subtree of the th edge of course in terms of vertices in the subtree of the lower vertex of this edge Values of can be calculated with pretty standard and simple dfs and dynamic programming Then we can notice that our edges are independent and we can consider the initial answer sum of weights of paths as Let be the difference between the current impact of the th edge and the impact of the th edge if we divide its weight by This value means how the sum of weights decreases if we divide the weight of the th edge by Create ordered set which contains pairs Then the following greedy solution works let s take the edge with maximum and divide its weight by Then re add it into the set with new value When the sum becomes less than or equal to just stop and print the number of divisions we made The maximum number of operations can reach so the solution complexity is each operation takes time because the size of the set is 
417,This tutorial is based on the previous problem easy version tutorial At first I want to say I know that this problem and this approach can be implemented in with segment tree So we iterate over all supposed maximums in the array and trying to apply all segments not covering our current element How do we can calculate the answer for element if this element is the supposed maximum Let s divide all segments we apply into two parts the first part consists of segments such that their right endpoints is less than the current position and the second part consists of segments such that their left endpoints is greater than the current position Then let s independently calculate answers for the left and for the right parts and merge them to obtain the answer I will consider only first part of the solution first part of segments because the second part is absolutely symmetric with it Let s maintain the minimum value on prefix of the array let it be and initially it equals to maintain the array of length initially its values are and means the answer if the th element of the array will be supposed maximum and the array of length where will be the value for which we decrease the th element in other words the number of segments we apply to the th element What do we do for the current position Firstly let s update the answer for it with the value in other words set Then let s apply all segments with right endpoints equals to the current position straight forward and update the value with each new value of covered elements Just iterate over all positions of each segment ends in the current position make and set And don t forget to update the value with the value after all changes because we need to update this value with each element not covered by segments too So then let s do the same from right to left and then will mean the answer if the th element is the supposed maximum in the resulting array Then we can find any position of the maximum in the array and apply all segments which don t cover this position What is time complexity of the solution above We iterate over all elements in the array this is and apply each segment in so the final time complexity is 
418,Let s process the array elements one by one For the first element it doesn t matter which side of the deque we add it to the result of its addition will be the same there will be a sequence of one element equal to the first array element in the deque Now let s consider adding the th element of an array into the deck First will be considered then and so on up to Let us describe the general algorithm for choosing the side of the dec for each step Note that if the elements now lie in the deck then all final sequences that can be obtained in the deck from the current state can be broken down into pairs of the form where the beginning and the end of the final sequences hidden behind are obtained by the same sequences of all the following choices and respectively coincide Note that since the prefix and suffix hidden behind the dots completely coincide in the two sequences under consideration as well as the set of numbers in the central part coincides the numbers of inversions also coincide inside the prefix and inside the suffix between elements of the prefix and elements of the suffix between elements of the prefix or suffix and elements of the central part The difference between the number of inversions in the first and second sequence consists only of the difference between the number of inversions in their central part So we can determine at the stage of adding to the deque which direction of its addition is guaranteed not to lead to the optimal answer and choose the opposite one If is added to the beginning of the deque the number of inversions in the central part will increase by the number of elements in the deque strictly smaller than and if we add it to the end of the deque it will increase by the number of elements in the deque strictly larger than Let us make a choice such that the number of inversions increases by the minimum of these two values To quickly find the number of elements smaller or larger than we will store all already processed array elements in a structure that supports the element order search operation such as Besides using this structure specifically you can write any balanced binary search tree such as a Cartesian tree sort all numbers in the input array and compress them to values preserving the relation then build a segment tree on them storing in the node the number of array numbers already processed by the deque with values between and Requests to update and get an order in such structures take time and the construction takes at worst so the time complexity of the algorithm is 
419,The key idea that allows us to move from the previous version to this one is that the values of the numbers themselves are not important to us The main idea is to consider all numbers in the interval x x k Let s also as in the previous version iterate over the minimum element x in the tuple Now let s find the count of numbers cnt that lie in the interval x x k this can be done with a binary search two pointers or prefix sums using an array of occurrences Then it remains to add to the answer the number of ways to choose m 1 numbers from cnt 1 we fixed one of the numbers as the minimum You have to sum these values over all possible values of x even the same because now you are not fixing the value of the minimum element as in the previous problem but its index in the sorted array To calculate binomial coefficients quickly you can pre compute all factorial values and all frac 1 n values by modulo If you do not know how to calculate the inverse element by modulo then you could pre compute the part of Pascal s triangle in mathcal O nm 
420,Let s look at the slow solution first which will lead us to the full one Let s iterate over the number from to Given a number we want to find a from to such that is divisible by Since must be divisible by the following conclusion can be drawn must be divisible by Let s denote this number as Now our task is to check if there is a multiple of between and The problem can be solved in many ways you can simply consider the largest multiple of that does not exceed it is equal to We compare this number with and if it matches then we have found a suitable pair Now let s note that we do not need to iterate over all the values of because from the number we are only interested in and this is one of the divisors of Even though the product can be large we can still consider all divisors of this number since and themselves are up to Let s find the divisors of and separately then notice that any divisor of is where is some divisor and is some divisor Let s calculate the running time We need to factorize the numbers and into prime factors this can be done in Next you need to iterate over pairs of divisors and Recall the estimate for the number of divisors of a number https oeis org A066150 the number up to has no more than divisors Therefore we can sort through the pairs for We learned how to find the optimal for We get that for each test case we have learned to solve the problem in 
421,Let s learn how to find an answer for the subtree rooted in vertex At first it is obvious from E1 tutorial that if the nearest to vertex with a friend from this subtree is no further from it than the root of the entire tree from then the answer for the entire subtree is since a friend can come to and catch Vlad in it not allowing him to go to any leaf of this subtree Else we will find the answer leaning on its children If a solution does not exist for at least one child then it does not exist for the entire subtree because after reaching Vlad will be able to go to such child and reach any exit Otherwise the answer for is the sum of the answers of its children since we need to beat it in each subtree to win and for each subtree we have found the minimum answer 
422,Let s define a function greaterCount number of subarrays with median greater or equal than In this case the answer on the problem is greaterCount greaterCount The subarray has median greater or equal than if and only if where is the number equal or greater than elements and is the number of less than elements In other words instead of processing you can use the sequence containing or and An element if An element if Now the median of is greater or equal than if and only if Let s iterate over from left to right Maintain the current partial sum Additionally in the array let s maintain the number of partial sum for each its value It means that before increase of you should do So if is the index of the right endpoint of a subarray i e then number of suitable indices is number of such that In other words find sum of all where it is exactly number of indices with partial sum less than Each time partial sum changes on or So the value sum of all where is easy to recalculate on each change If you decrease just subtract the value If you increase before increasing just add Since indices in can be from to you can use 0 based indices using an array In this case initialize as but not as it makes to be non negative on each step This solution works in 
423,This problem idea is not very hard Now can be up to so we need to find the number of block faster Let s do binary search on it Now using some pretty formulas we can determine if the total sum of lengths of blocks from to is greater than or equal to or not And more about these formulas let s iterate over all possible length of numbers from to and carry the sum of lengths of numbers with length less than the current length We know that the number of numbers he he of length is exactly for Let s add to the total sum of lengths and increase by What does means This formula means that we have exactly blocks ending with numbers of length and we need to add sum of lengths of all numbers with length less than exactly times And what does means It is the sum sums of lengths of all numbers of length i e previously we added sum of lengths of numbers with length less than and now we add sum of sums of lengths of numbers with length When we found the number of block let s decrease by the total length of all blocks from to and continue solving the problem This part was pretty hard to understand And the easiest part when we determined the number of block we can easily determine the number from to such that our answer lies in the number Let s iterate over all lengths from to here we go again and for the current length let for And now all we need is to increase the sum of lengths by After determining decrease by sum of lengths of numbers from to and print Time complexity 
424,A little explanation this editorial will be based on the easy version editorial so I ll use some definitions from it Here we go the most beautiful problem of the contest is waiting us Well the key idea of this problem almost the same with the easy version idea Let s iterate over the number of elements in group we need to take the cheapest ones again If the number of elements we take from group is then we need to take elements from and groups But one more thing let s iterate over not from zero but from the smallest possible number which can give us any correct set of books the numeric value of the answer doesn t matter The value of can be calculated using and sizes of groups by formula or even simple loop If we can t find any suitable value of the answer is Let s call elements from group and elements from and groups we take Other elements of the whole set of books are but Let s create the set which contains all free elements and fill it beforehand So now we took some necessary elements but we need to take some free elements to complete our set Let s create the other set which contains free elements we take to the answer and maintain the variable describing the sum of elements of How do we recalculate Before the start of the first iteration our set is already filled with some elements let s update using them Update is such an operation function that tosses the elements between and It will do the following things repeatedly and stop when it cannot do anything While the size of is greater than needed so we take more than books in total let s remove the most expensive element from and add it to while the size of is less than needed so we take less than books in total let s remove the cheapest element from and add it to while the cheapest element from is cheaper than the most expensive element form let s swap them Note that during updates you need to recalculate as well So we go over all possible values updating before the first iteration and after each iteration The size of both sets changes pretty smooth if we go from to we need to remove at most one element from because we take one element from group during each iteration and we need to add at most two elements to and because we remove at most two elements from and groups during one iteration To restore the answer let s save such a value that the answer is minimum with this value let it be Then let s just run the same simulation once more from the beginning but stop when we reach Then will contain free elements we need to take to the answer describes the number of elements we need to take from group and describes which elements from and groups we need to take Of course there are some really tough technical things like case handling there is a lot of cases for example the size of can be negative at some moment and you need to carefully handle that and can be negative after some number of iterations and there are other cases because of that and so on Time complexity 
425,I am sorry that some solutions pass tests in this problem also I was supposed to increase constraints or decrease time limit The general idea of this problem is the same as in the previous problem But now we should do all what we were doing earlier faster The solution is divided by two parts The first part Let s calculate four matrices of size and will denote the distance to the nearest dot character to the top from the current position The same will denote the distance to the nearest dot character to the bottom from the current position to the left and to the right We can calculate all these matrices in using easy dynamic programming If we will iterate over all possible from to and from to we can easy see the next if the current character is dot then Otherwise if then and if then Rest two matrices can be calculated the as well as these two matrices but we should iterate over all from to and from to So this part of the solution works in After calculating all these matrices the maximum possible length of rays of the with center in position is The second part is to draw all in Let s calculate another two matrices of size and Let s iterate over all in our answer Let the center of the current is and its size is Let s increase by one and decrease by one if The same with the matrix Increase and decrease if Then let s iterate over all possible from to and from to If then set and if set How to know that the character at the position is asterisk character or dot character If either or greater than zero then the character at the position in our matrix will be the asterisk character Otherwise it is the dot character This part works also in Time complexity of the solution 
426,The solution of this problem is based on Dilworth s theorem You can read about it on Wikipedia In two words this theorem says that the minimum number of non decreasing sequences we need to cover the whole sequence equals the length of longest decreasing subsequence Let s calculate the dynamic programming the length of longest decreasing sequence that ends in the position To recalculate this dynamic let s carry the array of length where means the maximum value of for the character on the prefix we already considered So initially all are ones all values of are zeros For the position we update with and update with Okay how to restore the answer That s pretty easy The color of the th character is exactly Why it is so If becomes greater than then we surely need to use the new color for this character because we cannot append it to the end of any existing sequence Otherwise we will append it to some existing sequence with the maximum possible number and because it has the maximum number and we didn t update the value of with the number of this sequence plus one the current character is not less than the last in this sequence Time complexity or 
427,I ll take some definitions from the solution of the easy version so you can read it first if you don t understand something Let be the number of occurrences of on the segment We will try to do almost the same solution as in the easy version The only difference is how do we iterate over all segments corresponding to the second block of the required palindrome Consider some number which we want to use as the number for the first and third blocks If we take occurrences in the first block then we also take occurrences in the third block Let s take these occurrences greedily If we take elements in the first block and also in the third block then it is obviously better to take leftmost and rightmost elements correspondingly Define be the position of the th occurrence of the number indexed So if is the array of length and contains all occurrences of in order from left to right then let s iterate over its left half and fix the amount of numbers we will take in the first block and also in the third block Let it be Then the left border of the segment for the second block is and the right border is So let and and we can update the answer with It is easy to see that the total number of segments we consider is so the total time complexity is there are also solutions not depending on the size of the alphabet at least Mo s algorithm in but all of them are pretty hard to implement so I won t describe them here And I m also interested in solution so if you know it share it with us 
428,The solution of the problem hints to us that with the help of such operations it is possible to move the symbol in the right direction by using two operations Then we can show that among the symbols that we can swap with at least one other symbol we can get any permutation For example you can apply such a greedy solution we will build an answer from the boundaries of the string to the middle Since we can move the symbol by a distance of we can move it to the border and thus we can build any string Thus it is enough to check that the sets of characters that can be swapped with some other match And for the rest of the characters check that they just match 
429,Read the easy version editorial first because almost all solution is the solution to the easy version with little changes Firstly let s simulate the greedy process we used to solve the easy version problem for edges with cost and edges with cost independently But we don t stop when our sum reach something let s simulate until our sum becomes and store each intermediate result in the array for edges with cost and for edges with cost So the array contains the initial total impact of edges of cost then the impact after making one move two moves and so on The same with but for edges with cost Now let s fix how many moves on edges with cost we do Let it be and arrays and are indexed Then the sum we obtain from the cost edges is So we need to find the minimum number of moves we can do on cost edges so that This can be done using binary search or moving pointer if we iterate over in increasing order place at the end of and move it to the left while Then if we can update the answer with the value Time complexity is actually the same as in easy version of the problem 
430,Let eq i j equals true if words s i and s j are equal otherwise it will be equals false We can iterate over all pairs of words and compare they just using standard string comparator constraints are really small so we can do it naively The next step is to calculate dynamic programming dp i j which will be equal to the maximum length of coinciding segments of words which starts in positions i and j respectively In other words if dp i j equals k then s i i k 1 s j j k 1 word by word We can calculate this dynamic programming in reverse order i n 1 0 j n 1 0 and dp i j 0 if s i ne s j else if i n 1 and j n 1 then dp i j dp i 1 j 1 1 otherwise dp i j 1 Let s keep the length of the text in the variable allsum Then iterate over all starting positions of the possible abbreviation and all its possible lengths Let the current starting position will be equals i 0 indexed and its length will be equal j Then we need to calculate the number of possible replacements by its abbreviation Let it be cnt and now it equals 1 Let s iterate over all positions pos at the beginning pos i j 0 indexed If dp i pos ge j then we can replace the segment of words which starts at the position pos with its abbreviation so cnt cnt 1 and pos pos j because we cannot replace intersecting segments otherwise pos pos 1 After this we need to update the answer The length of the segment of words s i j can be calculated easily let it be seglen Also let segcnt be the number of words in the current segment of words Then we can update the answer with the value allsum seglen cnt cnt segcnt Overall complexity is O n 3 n cdot sum limits i 0 n 1 s i where s i is the length of the i th word 
431,If all digits from to are initially present in the number then the answer is Each time we will increase the number by If the last digit is less than then only it will change Otherwise all digits equal to at the end will become equal to and the previous one will increase by or a new digit equal to will be added if all digits were equal to For a operation the last digit will run through all possible values However we can get all the numbers earlier We will solve the problem using binary search sorting through the number of operations We can have 2 options whether was at the end or not Depending on this one or two subsegments of the segment a subsegment in the middle or a prefix and a suffix remained uncovered by the last digit of the number They need to be completely covered with numbers that were already in positions except for the last one these are the original numbers and in case there was at the end the number into which the transfer was made There are at most of them 
432,Let s fix the length of the first block iterate through i from 0 to n 3 Let s also try to maximize the length of the third block using the second pointer So initially the length of the first block is 1 and the maximum in the block is a 0 after that its length will be 2 and the maximum will be max a 0 a 1 and so on Let s move the left border of the third block r while a r le a 0 and the second block have at least one element After we expanded the third block consider some cases if its maximum is less than a 0 then we don t need to consider this partition we expanded the third block as much as we can but didn t find the required maximum Otherwise its maximum fits our conditions Then let s find the minimum in the second block Let it be mn If mn mx this partition is also bad If mn mx this partition is good and we can just print it Otherwise mn mx and we need to fix the second block somehow I claim that we only need to expand it by at most one element Let s see why is it true Consider we want to expand it to the right the other case just uses the same logic If we expanded our block by one element to the right and the new value in it is less than mx then this partition is bad and we can not use it this is also the reason why we are trying to maximize the length of the third block Otherwise this value is always mx because the first and the third blocks didn t have values greater than mx There are some cases in the implementation we need to consider carefully first we need to find the minimum in the second block fast enough This can be done if we store it as a multiset set with repetitions Second we can remove the only maximum in the third or the first block by expanding the second one This can be handled easily if we just store all three blocks not only the second one as multisets And the last case is that we sometimes need to move the left border of the third block to the right This happens when we expand the first block and the second block becomes empty So this happens only O n times in total Total time complexity of this solution is O n log n There is also another solution from Gassa Let us start solving by asking the following question in which segments will the maximal values end up Consider the maximum value m in the whole array If there are at least three of them a valid answer is to pick any maximum except the first and the last as the middle segment For example m 3 can be partitioned as or as where the middle segment is marked with square brackets Otherwise all m should end up in the middle segment so that maximums to the left and to the right are less For example in we have to put both threes into the middle segment Let us now calculate the minimum value v on the middle segment considering the numbers between those equal to m For example in the value v min 3 1 3 1 All numbers greater than v should also go into the middle segment and everything between them which can result in v decreasing even more We have to expand the borders of the middle segment until the minimum value is such v that there are only values not greater than v left outside Continuing with the example we see that in the middle segment should be expanded to Conversely if the maximum m was unique then v m and we didn t have to expand the middle segment at this stage For example in the current state is If the maximums to the left and to the right are exactly v we found an answer Otherwise any possible middle segment contains the middle segment that we now got So we have to expand the middle segment either to the left or to the right As a result the value v may become smaller which can cause another expansion What s left is to decide where to expand when we have a choice We would like to do it greedily Indeed consider three values the minimum on middle segment v the maximum on left segment u and the maximum on right segment w When we expand the middle segment each of them can only decrease And if we find an answer the equation u v w will be satisfied So as we make the minimum of these three values smaller we have less and less opportunities to make them equal Thus we can pick the side of expansion after which the value min u v w is larger and if these are equal pick any For example in the state we have u 3 v 4 and w 3 If we expand to the left we get where u 1 v 3 and w 3 If we expand to the right we get where u 3 v 2 and w 3 Our algorithm will pick expanding to the right however there is no valid answer in this example anyway Implementation let us precalculate the maximums on all prefixes and all suffixes of the array Then we can expand the middle segment by one element in O 1 and the total running time is linear 
433,We ll consider an arbitrary index of the array and see what changes happen to during several steps of the described algorithm Let s denote by the value of the array after steps of the algorithm and prove by induction that is the logical AND of elements of the array starting from with step to the left that is Base of induction for the element of the original array is For clarity we can also show that the statement is true for during the first step is replaced by by the definition of cyclic shift by to the right For simplicity we will omit the operation in the following formulas but will keep it in mind implicitly That is will imply Induction step let the above statement be true for let us prove it for By the definition of cyclic shift And by the induction assumption these two numbers are equal to Since the logical AND is an idempotent operation that is it does not change its result when repeatedly applied to any argument then that is equal to their logical AND is also equal to which is what we wanted to prove It follows from this formula that turns to zero after the th step if and only if and Up to the th step all elements will be equal to and so their logical AND will also be equal to As soon as appears in the sequence in question the logical AND will also become zero Thus we reduced the problem to finding the maximal block of elements equal to of the pattern Note that by shifts of the array splits into cyclic sequences of this kind each of length Let s look at these cyclic sequences independently from each other and iterate over each of them in linear time complexity to find the maximal block of consecutive elements equal to this will be the answer to the problem Remember to check that if at least one of these sequences consists entirely of elements equal to its elements will never zero out and the answer in such case is The time complexity is 
434,First note that the array stabilizes if and only if it consists of equal elements and the number the array will be consisted of is Indeed at the th step a number equal to will be written at the th position in the array This is easy to prove by induction if at the previous step the adjacent elements in the array were equal to of the numbers on adjacent segments of length in the original array then their greatest common divisor will be the greatest common divisor of the union of these two segments GCD is an idempotent operation Thus the algorithm will stop in no more than steps since after steps all numbers will be equal exactly to If we divide all the numbers by before starting the algorithm then the number of steps won t change but the array will stabilize at the number Since the numbers in the array after the th step will be exactly equal to of all segments of length of the original array it follows that the number of steps after which all values become the same is exactly equal to the length of the maximum segment of the original array on which There are several ways to find the length of such a segment For example you can use range GCD query and binary search The following method is based on the factorization of numbers in other words on their decomposition into prime factors Factorization in this problem could be done using both the sieve of Eratosthenes or factoring each number independently in After all the numbers have been factorized iterate over each and each prime in its factorization In linear time we can go left and right from finding the maximum segment of numbers that contain the same factor Then we can update the answer with the length of this segment and move onto the next prime in the factorization of or go to if all primes have already been iterated through Note that if a segment of numbers divisible by contains indices from to then we iterate through it times In order to avoid reiteration on each segment we remove from the factorizations of all numbers on the segment after considering only one The resulting solution works in where the maximum number of different primes in factoriztion of Considering that so the solution fits into the time limit 
435,Use BFS to precalculate an array the array of the shortest path lengths from the Capital The condition to minimize sum of distances in each tree is equal to the fact that each tree is a shortest path tree Let s think about them as about oriented outgoing from the Capital trees Moving along edges of such trees you always move by shortest paths An edge can be included into such a tree if and only if since original edges are bidirectional you should consider each of them twice as and as Let s focus only on edges for which Call them red edges To build a tree for each city except the Capital you should choose exactly one red edge finishing in this city That s why the number of suitable trees is a product of numbers of incoming edges over all vertices cities But we need to find only of such trees Let s start from some such tree and rebuild it on each step As initial tree you can choose the first incoming red edge into each vertex except the City Actually we will do exactly increment operation for number in a mixed radix notation To rebuild a tree iterate over vertices and if the current used red edge is not the last for the vertex use the next and stop algorithm Otherwise the last red edge is used use the first red edge for this vertex and go to the next vertex and continue with the next vertex Compare this algorithm with simple increment operation for long number 
436,Firstly let s precalculate arrays The array is the array of parents if we run dfs from the vertex So is the vertex that is the previous one before on the directed path This part can be precalculated in time and we need it just for convenience Initially all values beauties of the edges are zeros Let s consider queries in order of non decreasing For the current query let s consider the whole path and update the value for each on this path in the following way After processing all queries let s replace all values with This part works also in time And the last part of the solution is to check if the data we constructed isn t contradictory We can iterate over all paths and find the minimum value on this path We have to sure if it equals If it isn t true for at least one query then the answer is Otherwise we can print the resulting tree Time complexity but it can be done in at least I hope someone can explain this solution because I am too lazy to do it now 
437,At first let s calculate the matrix of size Let will denote the maximum length of the prefix of which equals to the suffix of the prefix of of length with the additional character if and otherwise In other words is denote which maximum length of the prefix of we can reach if now we have the prefix of of length and want to add the character if and otherwise and only one possible move is to remove characters from the beginning of this prefix with an additional character This matrix can be easily calculated in without any dynamic programming It can be also calculated in using prefix function and dynamic programming Now let s calculate the following dynamic programming It means that now we have gained characters of the regular bracket sequence the balance of this sequence is the last characters of the gained prefix is the prefix of of length and equals to if we obtain the full string at least once and otherwise The stored value of the is the number of ways to reach this state Initially all other values equal The following recurrence works try to add to the current prefix character if the current balance is less than then we will move to the state is the length of and is operation if at least one is true then the result is true Let s add to the number of ways to reach the destination state the number of ways to reach the current state The same with the character Try to add to the current prefix character if the current balance is greater than then we will move to the state Also add to the number of ways to reach the destination state the number of ways to reach the current state After calculating this dynamic programming the answer is Time complexity is 
438,If the answer exists you can hang the tree by some vertex such that the distances and can be expressed through the sums of distances to vertices and Then from the system of equations we express the required values of distances to vertices and construct a suitable tree If the distance to a vertex is then that vertex is the root There cannot be two roots nor can there be negative distances If none of the vertices of is the root then make vertex the root Next we build the required tree add the required number of unique vertices on the path from the root to vertices Note also that if the sum of distances is greater than or equal to then we cannot build the tree either The remaining vertices can be simply joined to the root 
439,It is obvious that we can solve the problem separately for each favorite number because each player has only one favorite number and if the player gets a card not having his favorite number his joy will not change Let be the maximum possible total joy of players with the same favorite number it doesn t matter which one and cards containing their favorite number if the cards are distributed among the players optimally Note that and At the beginning all entries of the table are zeroes The transition in this dynamic programming depends on how many cards the th player will receive which is between and In other words the dynamic programming transition will look like for int i 0 i k i dp x 1 y i max dp x 1 y i dp x y h i where is the joy of the player if he receives exactly cards containing his favorite number Note that After filling the table the answer can be calculated very easily where is the number of players with favorite number and is the number of cards containing the number Time complexity is 
440,Let be the answer for our problem if the last element of our subsequence equals to Then we have an easy solution let s store as a C or Java Initially for each Then let s iterate over all in order of input and try to update with a Then the maximum element of will be our answer Let it be Then let s find any such that Let it be Then for restoring the answer we need to iterate over all elements of our array in reverse order and if the current element then push to the array of positions of our subsequence and make 
441,Notice the following once you apply the recolor operation to some cell you can never recolor it again That happens because you can t recolor its neighbors too as each of them has at least one neighbor of the same color this cell itself In particular that implies that applying a recolor operation always decreases the possible number of operations that can be made currently It doesn t always decrease them by from to operations can become unavailable but it always decreases That gives us an order of copies Just sort them in the decreasing order of the number of recolor operations that can be made currently If the numbers are the same the copies must be equal so their order doesn t matter The only thing remains is to apply the operations Turns out their order doesn t matter at all Consider all different cells for a pair of adjacent pictures It s never possible that there are two different cells that are adjacent to each other Thus no operation can interfere with another one Just print all positions of different cells in any order you want and make a copy Overall complexity 
442,Firstly let s solve the easier version of the problem Assume we are given a permutation not an array Notice that the given operation applied to some segment of the permutation cannot change the parity of number of inversions the number of inversions is the number of such pairs of indices that and So if the number of inversions in the given permutation is odd then we can t sort this permutation we can t obtain zero inversions But if the number of inversions is even then we can always sort the permutation with the following greedy algorithm let s find the minimum element and move it to the first position If its position is then we can apply the operation to the segment and our element will move by two positions to the left So after all our element is either at the first or at the second position If it s at the second position let s just apply two additional operations to the segment Then let s just cut off the first element and solve the problem without it At the end we have only two numbers that can be not sorted and we can check all three possibilities and choose one which is suitable for us it s always exists because the number of inversions is even How do we solve the problem if we are given the array not the permutation First of all we can prove that if the array contains at least two equal elements we can always sort it we will prove it by construction Let s just renumerate the elements of the given array in a way to obtian the permutation with the even number of inversions Thus if then let s find such a permutation that We can find this permutation easily if we sort the array of pairs in increasing order But there can be one problem this permutation can have odd number of inversions Then we need to find two consecutive pairs with the same first values and swap these two elements in the permutation Because in fact these two numbers are equal in the array and have consecutive values in the permutation we guaranteed change the parity of number of inversions Then we can apply our algorithm for permutations and solve the problem for the array If we failed then the answer is Otherwise the number of operations always does not exceed because this sort works like a bubble sort so our answer is suitable Time complexity 
443,Observation the product of odd numbers is odd so the condition for the length of is automatically completed Denote by the number of ones in binary representation of Let s enumerate the letters of the Latin alphabet from to Observation for each word it is enough to know the set of letters included in it and the evenness of their numbers There are only letters in the alphabet so it is convenient to store the word characteristic as a pair of masks The bit with the number in will be responsible for the availability of the letter in The bit with the number in will be responsible for the evenness of the number of letters in Observation strings creates if and only if Let s fix the number the index of the letter that will not be in Let s throw out all the words with the letter now we can look at the words in turn and look for a pair of them among those already considered It is easy to see that the condition follows from the condition if one letter is banned To count the number of pairs that include our word we need to count the number of words with the characteristic We can do this by bin searching through a sorted array of or using standard data structures We got the solution for 
444,Firstly consider the field in indexation Suppose that the cell has some fixed height Let it be Then we can determine what should be the height of the cell as In fact it does not matter which way we choose we actually need only the number of moves to reach the cell and the height of the cell Then when the height of the cell is fixed we can solve the problem with the following dynamic programming is the minimum number of operations we need to reach the cell from the cell Initially all values except Then can be calculated as But one more thing if then this value of is incorrect and we cannot use it We also can t update from the incorrect values The answer for the problem with the fixed height of the cell is only when is correct and This part can be calculated in But if we iterate over all possible heights our solution obvious will get time limit exceeded verdict Now we can notice one important fact in the optimal answer the height of some cell remains unchanged Let this cell be Then we can restore the height of the cell as and run our quadratic dynamic programming to find the answer for this height Time complexity 
445,I ve seen a lot of data structures solutions for this problem but author s solution doesn t use them and works in Firstly let s change our matrix to a string because it will be easier to work with a string than with a matrix The order of characters will be from top to bottom from left to right i e the outer cycle by columns and the inner by rows Then let s calculate the number of icons on the desktop the number of in Then the answer will be obviously the number of dots on the prefix of of size Now let s deal with queries It can be shown that one query changes our answer by no more than Let be the position of the cell that is being changed in zero indexed Then if there are two cases If is then we have one more icon on our prefix so the answer decreases by one because we filled one empty space in the good desktop Otherwise it increases by one because this icon is outside our prefix Then let s change the corresponding character by the opposite After that we should move our right border accordingly to the new number of icons Note that this border is exclusive If becomes then we will increase the variable But before that if is then there should be an icon and it is not here yet so the answer increases Otherwise our border will decrease Then if is then the answer decreases because there was a place for an icon and now it is not needed anymore Time complexity 
446,The first and crucial observation is that we don t need all the cards that we get during each turn In fact since the total cost is limited to we may leave three best cards of cost one best card of cost and one best card of cost and all other cards may be discarded So the problem is reduced we get only cards each turn The problem may be solved with dynamic programming is the maximum damage we may deal if we played turns and the last card we played had remainder modulo Processing each turn may be done with auxiliary dp the maximum damage we can deal during the turn if we play cards and denotes whether some card there will be only one such card obviously deals double damage To calculate this auxiliary dp we may do almost anything since we are limited to cards during each turn It is possible to calculate it in a fast way using some casework but it is easier for example to try all possible permutations of cards and play some prefix of a fixed permutation By combining these two techniques we get a solution 
447,First of all we don t like the fact that importance values can be integers up to it is kinda hard to work with them Let s rephrase the problem The highest bit set to in the importance value denotes the maximum in the subtree rooted at the auxiliary lamp for the wire So we sort the wires according to the maximums in their subtrees To break ties we could consider the second maximum then the third maximum but that s not convenient We can use something much easier suppose there are two vertices with the same maximum in their subtrees these vertices belong to the path from the root to the maximum in their subtrees and the one which is closer to the root has the greater importance value So to get the order described in the problem statement we could sort the vertices according to the maximum in their subtrees and use depth as the tie breaker What does this imply All vertices of some prefix are ancestors of vertex so some prefix denotes the path from the root to excluding itself Then there are some values describing the path from some already visited vertex to if was not met before then to and so on How can we use this information to restore the original tree is the root obviously Then the sequence can be separated into several subsegments each representing a vertical path in the tree and each vertex is the parent of the next vertex in the sequence if they belong to the same subsegment How can we separate these vertices into subsegments and how to find the parents for vertices which did not appear in the sequence at all Suppose some vertex appears several times in our sequence The first time it appeared in the sequence it was in the middle of some vertical path so the previous vertex is its parent and every time this vertex appears again it means that we start a new path and that s how decomposition into paths is done Determining the parents of vertices that did not appear in the sequence is a bit harder but can also be done Let s recall that our sequence is decomposed into paths from root to from some visited vertex to from some visited vertex to and so on so each time the path changes it means that we have found the maximum vertex among unvisited ones So we should keep track of the maximum vertex that was not introduced in the sequence while we split it into paths and each time a path breaks it means that we found the vertex we were keeping track of Overall this solution can be implemented in 
448,Since the array a does not decrease if we want to get the position x at some point it is best to get it as early as possible because if we get it earlier we will earn no less money Therefore the solution looks like this rise to some position and earn money on it for a laptop Let s go through the number of the position and use simple formulas to calculate the number of days it takes to raise to this position and the number of days it takes to buy a laptop From all the options choose the minimum one 
449,Really low constraints choosing some permutation Surely this will be some dp on subsets At first let s get rid of For each two rows calculate the minimum difference between the elements of the same columns let s call this for some rows This will be used to put row right after row Let s also calculate the minimum difference between the elements of the column of row and column of row This will be used to put row as the last row and row as the first one Now let s think of choosing the permutation as choosing the traversal of the following graph Vertices are rows and the weights of edges between the vertices are stored in However you can t straight up do minimum weight Hamiltonian cycle search as the edge between the first vertex and the last one should be of weight from and not Let s fix some starting vertex and find minimum weight Hamiltonian paths from it to all vertices Finally update the answer with That will lead to approach minimum weight Hamiltonian path is a well known problem solved by That s completely fine and it s the most intended solution However there exist another solution that would have worked better if the edge weight were a bit smaller Let s do binary search each time checking if the answer is greater or equal to The check is simple enough Now the graph is binary edge exists if its weight is greater or equal to thus you should check for existence of Hamiltonian path not for the minimum weight one That can be done in leading to solution The key idea of that dp is storing the vertices where the path of the current mask could have ended as a mask itself Then it becomes with transitions Overall complexity or 
450,Let s calculate the value of how many times the number occurs in the array We will iterate over the value of and look for the minimum number of moves necessary for each number to appear in the array either times or times Note that if there is no such number that then such a value of will not give the minimum answer because we have removed unnecessary elements Then for a specific the answer is calculated as follows Since the number of candidates for the value of is no more than this method works in Then there are two ways to optimize our solution you can consider only unique values of there are no more than and get a solution in you can sort the values and use prefix sums this solution works for or for if you use counting sort 
451,The necessary condition to make strings equal is that the number of occurrences of each character should be the same in both strings Let s show that if some character appears more than once we always can make strings equal How Let s sort the first string by swapping adjacent characters and it does not matter what do we do in the second string Then let s sort the second string also by swapping adjacent characters but choose the pair of adjacent equal characters in the first string it always exists because the first string is already sorted Otherwise all characters in both strings are distinct and they lengths are at most Then the answer is if the parity of the number of inversions the number inversions in the array is the number of such pairs of indices that but are the same It can be proven in the following way every swap of two adjacent elements changes the parity of the number of inversions Time complexity 
452,We divide each number from the multiset by as long as it is divisible without a remainder Because if we can get a new number from the multiset we can also increase it to the original number by multiplication by Now notice that it does not make sense to use the first operation multiplication by because we get an even number and only odd numbers remain in the multiset Then we take the largest number from and if it is in we remove this number from both multisets Otherwise we use the second operation if the number is greater than If it is equal to then it is impossible to equalize the multisets and 
453,If any set of two vertices may be taken so the answer is modulo Suppose Consider three vertices such that If this equality is true there s a vertex that belongs to all three paths otherwise either one of the vertices belongs to the path between two others or there is more than one simple path i e path having distinct edges between any of the vertices so the graph isn t a tree Hence the following equalities are true Then hence Suppose Let s select vertices that is a correct desired set of four vertices for the triple of paths let s select a common vertex and for the triple Because is the same vertex as The same procedure we can do for all other pairs of triples of vertices The situation will not be another if we add a new vertex in the set if the set will still meet the problem s conditions So if a vertex exists such that all vertices of the set are equidistant from it Note that for each set only one such exists Let s iterate over all vertices taking them as and hang the tree by The set of vertices equidistant from meets the problem s condition if and only if the vertices of the set are placed in different subtrees of vertices adjacent to in other words the paths from them to must intersect only in Let s calculate the number of desired sets for a given and a layer of equidistant vertices Let be the number of vertices adjacent to and it s the number of subtrees too Let s create an array indexed of size so that the th element will contain the number of the vertices of the layer in the th subtree For the layer of vertices adjacent to this array will be filled with For the other layers we can update the array as follows let s mark and vertices adjacent to as used then for every vertex of the current layer let s decrease by if is the index of the subtree of the vertex then let s increase by the number of the vertices adjacent to the current one but not used Then let s mark the vertices as used After the iteration the array will correspond to the new layer Using the array let s calculate the number of the desired sets of vertices using the concept of dynamic programming Let s create an array indexed of size will contain a number of found sets of vertices if only subtrees have been considered Let s fill the array with except Let s start a loop with parameter from to and the internal one with parameter from to In every step we can either take a vertex from th subtree or take nothing If we take a vertex from the subtree it s possible only if then we have ways to select vertices considering subtrees so that the last vertex belongs to the th subtree This value we must add to that must contain all ways to select vertices from subtrees If we ignore the subtree the number of ways to select vertices from subtrees ignoring the th subtree is It must be added to the number of ways to select vertices from subtrees The answer for the current and the current layer of equidistant vertices is The answer for the whole tree is the sum of the answers for all and for all layers of equidistant vertices Remember that all arithmetical operations must be done modulo The number of possible central vertices is For every central vertex and every layer we perform two actions recalculate the array and calculate the number of the corresponding sets using the concept of dynamic programming The recalculation of works in it s just BFS starting from so for every central vertex it works in O n The dynamic programming for the current and the current layer works in for the current and all layers in The summary time corresponding to the current is The total algorithm work time is The sum of all is a total number of the adjacent vertices to all vertices it s just a double number of edges So the total work time is 
454,What if the given graph will contain a cycle of odd length It will mean that some two consecutive edges of this cycle will be oriented in the same way and will form a path of length two What if there is no cycles of odd length in this graph Then it is bipartite Let s color it and see what we got We got some vertices in the left part some vertices in the right part and all edges connecting vertices from different parts Let s orient all edges such that them will go from the left part to the right part That s it 
455,For each digit we will count how many times it has changed The number of changes for the first digit the lowest is calculated using the formula The number of changes for the second digit is calculated by the formula That is it is equivalent to the number of first digit changes for numbers from to To calculate the number of changes for the remaining digits you need to apply similar reasoning with dividing the numbers by 
456,Note a few things There are exactly vertices in the flower since from each of the vertices of the main cycle comes another cycle of size in the flower all vertices have degree except for the vertices of the main cycle whose degrees are it follows that in flower edges The listed properties do not take into account only the connectivity of the graph and the sizes of our cycles To check connectivity we run a bfs or dfs from any vertex and check that all vertices have been visited To check the cycle lengths we cut out the edges of the main one and make sure that the graph has fell apart into components of size 
457,The main observation is that you don t need more than smallest by weight edges among all edges with the maximum weights you can choose any Maybe there will be a proof later but now I ask other participant to write it So you sort the initial edges and after that you can construct a graph consisting of no more than vertices and no more than edges You just can build the new graph consisting only on these vertices and edges and run Floyd Warshall algorithm to find the matrix of shortest paths Then sort all shorted distances and print the th element of this sorted array Time complexity I know that there are other approaches that can solve this problem with greater but to make this problem easily this solution is enough 
458,Note that the remainder of dividing a number by is equal to the remainder of dividing its sum of digits by This is easy to check because the number of digits is representable as a polynomial and gives a remainder of when divided by for any Let s count an array of prefix sums of digits for the string Now knowing we can pre calculate for each remainder modulo all possible Also for each query we can easily find the remainder of dividing by using all the same prefix sums Let s iterate over the remainder of the number when dividing by Knowing it we can easily find the remainder of the number when divided by as modulo Now using each pair of remainers let s try to update the answer then the minimum index from the pre calculated array will act as and the next largest will act as if such exist then the minimum indexes from the pre calculated array will act as and This solution works for or for 
459,For each game we want to seat people at tables of them will be big and will sit at them and will be small Each round people will sit at the big tables Let s put people with numbers at large tables in the first round for convenience we index from zero and the rest for small ones in the second round we will seat people at large tables with numbers and so on We cycle through the players from to in blocks of Since no one person can be ahead of any other by 2 or more large tables 
460,Suppose we have found all the edges of the graph explicitly sorted them and start running Kruskal on the sorted list of edges Each time we add some edge to MST it is either a special edge given in the input or an edge which was generated with cost whichever costs less Let s try to analyze how can we find the cheapest edge of each type that connects two components For special edges we may just maintain the number of special edges we already added or skipped and when choosing a new edge we skip some more possibly zero special edges that don t connect anything until we find an edge that connects something And for the other type of edges we may find two components having minimum numbers on the vertices in those components as small as possible and just connect the minimum vertex in the first component with the minimum vertex in the second component We may simulate this by maintaining a data structure for example a multiset where for each component we will store the vertex having minimum in this component and pick two minimums from this set We also have to be able to check if two vertices are connected this can be done with DSU and merge two components But this solution can be made easier Every time we add a non special edge one of the ends of this edge is the vertex with minimum So we may just find this vertex generate all edges connecting this vertex to all other vertices merge this set of edges with the set of special edges and run any MST algorithm on the resulting set of edges If there are multiple minimums in the array then we may pick any of them because in Kruskal algorithm it doesn t matter which of the edges with equal costs we try to add first 
461,This problem is just all about the implementation Firstly let s sort the initial values and compress them to pairs where is the number of elements The first observation is pretty standard and easy some equal elements will remain unchanged So let s iterate over all elements in some order and suppose that all elements will remain unchanged Firstly we need elements which we should obtain by some moves The second observation is that we first need to take elements from one end only less or only greater and only then from the other if needed Consider the case when we first take less elements The other case is almost symmetric Let be the number of less than which we need to increase to If then skip the following step Otherwise let be the number of elements less than or equal to be the sum of all elements less than or equal to and be the previous value the maximum value less than Then we need to increase all elements less than or equal to at least to the value It costs moves And then we need moves to increase elements to And let be the number of elements greater than which we need to decrease to if we increased elements already If then skip the following step Otherwise let be the number of elements greater than or equal to be the sum of all elements greater than or equal to and be the next value the minimum value greater than Then we need to decrease all elements greater than or equal to at least to the value It costs moves And then we need moves to decrease elements to So we can update the answer with the sum of values described above and proceed to the next value Arrays are just simple prefix and suffix sums which can be calculated in using very standard and easy dynamic programming Don t forget about the overflow Total time complexity because of sorting 
462,Let s realize what we need to construct the with heights from l to r We can represent it as l l 1 dots r 1 r r 1 dots l 1 As we can see we need one occurrence of l and r and two occurrences of all other heights from l 1 to r 1 How can we find the using this information We can find the segment of neighboring heights with at least two occurrences using the array of frequencies cnt sorted array of unique heights b and two pointers technique For the current left border l we should increase r initially it is l 1 and it is an excluded border while b r b r 1 1 and cnt b r ge 2 Then for the current left and right borders we can try to extend the segment to the left if b l b l 1 1 and to the right if b r 1 b r 1 and try to update the answer with the the current segment and go to the next segment There may be some corner cases like n 1 or all cnt are 1 but you can avoid them if you will implement the solution carefully There are almost no corner cases in my solution you can see details of implementation in authors code Time complexity O n log n or O n depends on sorting method 
463,Let s solve this problem using dynamic programming on a tree Suppose the tree is rooted and the root of the tree is Also let s increase to find the subset in which any pair of vertices had distance or greater instead of or greater Let be the maximum total weight of the subset in the subtree of if the vertex with the minimum depth we took has depth Then the answer is Firstly let s calculate this dynamic programming for all children of Then we are ready to calculate all for all from to Let the current depth be then there are two cases if then Otherwise let s iterate over all children of and let be such child of that the vertex with the minimum depth we took is in the subtree of Then After we calculated all values of for the vertex we can notice that this is not what we wanted The current value of means the maximum total weight of the subset in the subtree of if the vertex with the minimum depth we took has depth To fix this let s push to for all depths from to Time complexity but it can be easily optimized to using some prefix and suffix maximums You can ask why this is but not because we iterating over all vertices then over all possible depths and then over children of the vertex and again over children of the vertex But in fact this is because if we change the order of multiplication we can see that we are iterating over pairs parent child then over children and possible depths and the number of such pairs is so the complexity is 
464,This problem is about the rerooting technique Firstly let s calculate the answer for some fixed root How can we do this Let be the maximum possible difference between the number of white and black vertices in some subtree of yes the subtree of the rooted tree i e and all its direct and indirect children that the vertex We can calculate this dynamic programming by simple dfs for the vertex it will look like this Okay we can store the answer for the root somewhere What s next Let s try to change the root from the vertex to some adjacent to it vertex Which states of dynamic programming will change Only and Firstly we need to remove the child from the subtree of the vertex Then we need to attach the vertex and make it a child of the vertex Then we need to run this process recursively from store the answer reroot the tree and so on and when it ends we need to rollback our changes Now is the root again and we can try the next child of as the root Time complexity 
465,Firstly we should sort all programmers in non decreasing order of their skills Also we need to store initially numbers of the programmers we can user array of pairs skill and initial number of the programmer We will iterate through the programmers from the left to the right The current programmer can be a mentor of all programmers to the left of him after sort and with who he are not in a quarrel Let the number of programmers to the left is Subtract from the number of already considered programmers who skill equals to the skill of the current programmer it can be done for example with help of Also lets brute all programmers with who the current programmer in a quarrel we can initially save for each programmer the vector of programmers with who he in a quarell by analogy with the stoe of graphs and if the skill of the current programmer more than the skill of a programmers with which he in a quarrel we should decrease on one because this programmer is to the left of the current after sort and has been counted in We should store by a number of the current programmer the value as answer for him 
466,Let s learn how to count the number of subsegments where for a fixed value of Let s understand on which subsegments has such a value We understand that the numbers should be in this subsegment the number should not and then does not matter Let be the index of the left most occurrence of the numbers and the right most occurrence Also let be the index of the number If then there is no subsegment with the given otherwise let s think about how many numbers can be in a subsegment It is stated that if the length of a segment is then on it otherwise it is not true Indeed if the length of a segment is then simply by the definition of the median it will be among the first numbers On the other hand if the length of the segment becomes longer then according to the same definition of the median it will no longer be among the first numbers which are equal to It turns out that we need to count the number of subsegments of length that contain the subsegment inside themselves but not This of course can be done with large formulas and the like but one more useful fact can be noticed If we iterate over in ascending order and at the same time maintain and then let s see what happens with a fixed and a position of for convenience let s assume that since the second case is similar In fact you can simply iterate over the left border of our segment from to and then use a simpler formula to calculate the number of good subsegments with such fixed values Why can this left boundary be iterated for each if correspondingly if it were then we would iterate over the right boundary Let s remember that after this step becomes equal to That is if we iterate over an element then we move the corresponding border And we can only move it times 
467,Let s understand when two points and coincide Let Then they are coincide when Otherwise these two points will never coincide and the distance between them will only increase So we need to consider only the initial positions of points Let s sort all points by and consider them one by one from left to right Let the th point be the rightmost in the pair of points that we want to add to the answer We need to find the number of points such that and and the sum of for such points as well We can do this using two BITs Fenwick trees if we compress coordinates all values and do some kind of scanline by values Let the number of such points be and the sum of coordinates of such points be Then we can increase the answer by and add our current point to the Fenwick trees add to the position in the first tree and to the position in the second tree When we want to find the number of required points and the sum of its coordinates we just need to find the sum on the prefix two times in Fenwick trees Note that you can use any online logarithmic data structure you like in this solution such as treap and segment tree There is also another solution that uses pbds Let s do the same thing but there is one problem Such data structure does not have sum on prefix function so we have to replace it somehow To do this let s calculate only part when we go from left to right Then let s clear our structure go among all points again but from right to left and calculate the same thing but with the opposite sign find the number of points such that and When we go from right to left we need to decrease the answer by It is some kind of contribution to the sum technique Time complexity 
468,The first and the most straight forward approach is to construct MST with any suitable algorithm build LCA with the maximum edge on a path with binary lifting technique and then we have to increase the answer for each edge such that equals to the maximum edge on a path between and in MST The second and the most pretty and easy to implement solution is the improved Kruskal algorithm Let s do Kruskal algorithm on the given edges Sort them and let s consider all edges of the same weight at once They can be divided into two classes The first class contains edges which connect nothing and the second class contains edges which can connect something Let the number of edges of current weight be edges of the current weight of the first class be and edges with of current weight of the second class be Okay we can just skip the first class because it will never increase the answer How to calculate useless edges of the second class Let s try to merge all components connected with edges of the second class Suppose we make merges Then we have to increase weights of all remaining edges by one So we add to the answer the value and go to the next weight Why is this right This is right because if the edge of the second class cannot connect anything because of the previously considered edges then the maximum on a path between endpoints of this edge equals to this edge weight So we have to increase the weight of this edge by one If we didn t do it we would be able to replace the edge connects these components with our edge And it is obvious that this edge is totally useless with the weight increased by one Time complexity is because of edges sorting 
469,Let s go through the segments times in non decreasing coordinates of the left end and then in non increasing coordinates of the right end To walk a second time just multiply the coordinates of the left and right borders by and then swap them and walk from left to right Going through the segments in non decreasing coordinates of the left end you need to find for each segment a segment that starts not to the right of the current one and ends as far to the right as possible If the coordinate of its right end is not less than the coordinate of the left end of the current segment then it intersects with it otherwise the distance between them is equal to the distance between the coordinate of the left end of the current segment and the maximum coordinate of the right end of the segment starting to the left of ours Note that it is enough for us to store no more than segments for each color we will store the maximum right coordinate of the segment of this color which has already been considered If we store the colors with the largest right coordinates then one of them is definitely not equal to the current one When considering a segment we add it to the list and if the size of the list becomes then we leave of optimal elements 
470, should be area of the outer rectangle It means that its sides are divisors of The same holds for the inner rectangle Let s assume that red color forms a rectangle we ll try it and then swap with and solve the same problem again Write down all the divisors of up to these are the possible smaller sides of the inner rectangle Divisors of up to are possible smaller sides of the outer rectangle Let s put inner rectangle to the left bottom corner of the outer rectangle and choose smaller sides of both of them as bottom and top ones Iterate over the divisors of for each of them choose the greatest divisor of smaller or equal to it and check that Update the answer with if it holds You can use both binary search or two pointers both get AC pretty easily The number of divisors of can usually be estimated as Overall complexity 
471,If the first column is empty we can always cover it with a vertical tile if the next column is also empty then we will have to put either two vertical or two horizontal tiles but they are obtained from each other by rotating if the next column contains at least one blocked cell then we have no other options but to cover the column with a vertical board If the first column is fully blocked then we can just skip it Remove such columns from the beginning reducing the problem Now the first column contains one empty and one blocked cell Obviously in place of an empty cell we will have to place a horizontal tile If this did not work then the tiling does not exist Otherwise there are two cases if the next column is empty it will turn into a column with one occupied cell Then we continue to put horizontal tiles if the next column contains one blocked cell then it becomes fully blocked and we return to the first step It turns out the following greedy algorithm we sort all columns with at least one cell blocked there are no more than such columns by number Now if we see a column with one occupied cell then the next one must also be with one occupied cell we skipped the empty columns but this cell must have a different color in the chess coloring so that we can tile the space between them with horizontal boards This check is easy to do after sorting the columns 
472,There are several more or less complicated combinatorial solutions to this problem but I will describe a dynamic programming one which I think is way easier to understand and to implement Suppose we have fixed the positions of and that compose the subsequence let these positions be and How many strings contain the required subsequence on these positions Obviously if some of these characters is already not a question mark and does not match the expected character on that position the number of strings containing the subsequence on that position is Otherwise since we have fixed three characters all question marks on other positions can be anything we want so the number of such strings is where is the number of question marks on positions other than and It allows us to write an solution by iterating on and and for every such triple calculating the number of strings containing the required subsequence on those positions But that s too slow Let s notice that for every such subsequence the number of strings containing it is where is the number of positions from that contain a question mark So for each integer from to let s calculate the number of subsequences matching that contain exactly question marks and that will allow us to solve the problem faster How can we calculate the required number of subsequences for every In my opinion the simplest way is dynamic programming let be the number of subsequences of that end up in position match first characters of and contain question marks The transitions in this dynamic programming are quadratic since we have to iterate on the next previous position from the subsequence but can be sped up to linear if we rewrite as the number of subsequences of that end up in position match first characters of and contain question marks Each transition is either to take the current character or to skip it so they can be modeled in and overall this dynamic programming solution works in 
473,Any experienced contestant can easily guess that the problem can be solved with dynamic programming Coordinates are not really large so you can precalculate the array where is a boolean value if there exists some segment of rain to cover the segment between positions and and otherwise This can be done in with the most straightforward algorithm You can also precalculate another array where is the index of the umbrella of minimal weight at position or if there is no such umbrella Now let be the minimal total fatigue you can take if you are holding umbrella number on the end of the walk up to position If then you hold no umbrella Initially all the values are and is You can either hold your umbrella drop it or pick up the best one lying there and drop the current one if any when going from some position to So here are the transitions for these cases if if if The answer is equal to If it is then there is no answer So you have states and all the transitions are Overall complexity There is also a solution in with Convex Hull Trick using Li Chao tree You can probably even achieve with some coordinate compression Obviously this wasn t required for the problem as the constraints are small enough 
474,The number is divisible by the number if and only if modulo To solve this problem let s use the concept of dynamic programming There will be four states the number of considered digits of the number the number of such considered digits that we have colored red the remainder from dividing the red number by and the black one by The value corresponding to the state will be described by three parameters the possibility of a situation described by the states the color of the last digit and the parent state Let s assume that the number that contains digits is equal to Initially let s mark the state in which digits are considered of which are red digits and both remainders are equal to as possible Next let s iterate over all states in the following order first by the number of considered digits then by the number of considered red digits then by the remainder of the division by and by From the current state if it is possible i e the corresponding mark is set you can make two transitions to new states At the first transition we paint the last digit in red at the second one in black We need also to store the current state in the new states as the previous one A solution exists if and only if some state in which exactly digits are considered of which at least and at most red digits and the remainders are equal to is marked as possible Let s find such a state Using the stored information about the color of the last digit and the previous state we can restore the colors of all digits of the number 
475,This is mostly implementation problem We can notice that all leaves are indistinguishable for us So if we have some vertex with at least k leaves attached to it we can choose it remove these leaves from the tree and continue the algorithm The rest is just an implementation let s maintain for each vertex v the list of all leaves which are connected to it leaves v and the set of vertices which is sorted by the size of leaves v So let s take any vertex which Is connected with at least k leaves we can just take the vertex with the maximum value in the set and remove any k leaves attached to it If it has zero leaves after the current move let s mark is as a leaf and append it to the list of the corresponding vertex you also need to remove edges from the graph fast to find the required vertex so you may need to maintain the graph as the list of sets And don t forget about the case k 1 because it may be special for your solution so you could handle it in a special way Time complexity O n log n 
476,Let s fix the first element and then try to restore permutation using this information One interesting fact if such permutation exists with this first element then it can be restored uniquely Let s remove the first element from all segments containing it we can use some logarithmic data structure for it Then we just have a smaller problem but with one important condition there is a segment consisting of one element again if such permutation exists So if the number of segments of length 1 is zero or more than one by some reason then there is no answer for this first element Otherwise let s place this segment a single element in second place remove it from all segments containing it and just solve a smaller problem again If we succeed with restoring the permutation then we need to check if this permutation really satisfies the given input segments see the first test case of the example to understand why this case appears Let s just iterate over all i from 2 to n and then over all j from i 1 to 1 If the segment a j a j 1 dots a i is in the list remove it and go to the next i If we can t find the segment for some i then this permutation is wrong Time complexity O n 3 log n or less maybe 
477,There are two main approaches to this problem Let s analyze how the binary representation of changes after the operation If there are no zeroes at the end of it appending just reverses the binary representation if there are any trailing zeroes we remove them and reverse the binary representation If we append we just reverse the binary representation and add at the beginning No matter which action we choose on the first step the resulting binary representation will have at its beginning and at its end so no bits can be removed from it no zero from the resulting binary representation can become leading It means that every number we can obtain from will have the following form several ones maybe none then then several ones again maybe none where is one of the following four strings the binary representation of after appending in the first operation the binary representation of after appending in the first operation one of the aforementioned representations but reversed We can check that meets one of these four templates but since we only considered the case when we apply at least one operation we also have to verify if Run something like implicit BFS or DFS to generate all possible values you can obtain pruning when the length of the binary representation we get becomes too large say greater than Why does this work fast As we have shown in our first approach the numbers we can get from have a very specific form and if we limit their lengths to we will consider only about different numbers Note that if you try this approach you have to store the obtained numbers in some associative data structure I use a set of strings in my solution 
478,Let s start moving from an arbitrary cell of the table for example from Movement from each cell is specified by the direction given in that cell so you can run a loop with a stopping condition exit from the board border or get to the already visited cell Create a separate array how many commands the robot will execute starting the movement from the cell we will also use it to check whether the cell has already been visited or not not visited if is not yet positive Finishing the movement from let s consider two cases Either we have gone beyond the boundary of the array then we can say for sure that for the th cell from the end of the sequence the answer is Or we came to the already visited cell let it be the th from the end in our path Then at the end of the path there is a cycle of length starting the movement at any cell of this cycle the robot will walk exactly steps until it arrives at the already visited cell Thus for distance will be equal to and for all others it will be as in the first case Let us run the same algorithm from the next cell which we have not yet considered There will be three cases of robot stopping the execution of the commands the first two repeat those already considered above and the third case is that the robot will come to the cell already visited on some of the previous iterations of our algorithm In this case we know that starting from the robot will make exactly steps so for the th cell from the end on the current path will hold The first two cases are handled completely in the same way as described above Each of the cases is eventually reduced to another iteration over the cells visited in the current path Let s visit all the cells in reverse and mark all values of Such algorithm is enough to repeat until each cell is processed after which for each cell of the table its will be known and we ll only have to choose the maximal value of among all 
479,First of all I want to say about solution You can extract cycles in the graph do some dynamic programming on trees use some hard formulas and so on but it is a way harder to implement than the other solution that only has an additional log so I ll describe the one which is easier to understand and much easier to implement Firstly consider the problem from the other side What is this grid It is a functional graph such a directed graph that each its vertex has exactly one outgoing edge This graph seems like a set of cycles and ordered trees going into these cycles How can it help us Let s notice that if two robots meet after some move then they ll go together infinitely from this moment It means that if we try to make at least moves from each possible cell we will obtain some equivalence classes it means that if endpoints of two cells coincide after moves then you cannot place robots in both cells at once So if we could calculate such endpoints then we can take for each possible endpoint the robot starting from the black cell if such exists and otherwise the robot starting from the white cell if such exists How can we calculate such endpoints Let s number all cells from to where the number of the cell is Let the next cell after is i e if you make a move from you go to Also let s create the two dimensional array where means the number of the cell in which you will be if you start in the cell number and make moves What is the upper bound of It is exactly Well we need to calculate this matrix somehow It is obvious that if the number of the cell is and the number of the next cell is then Then let s iterate over all degrees from to and for each vertex set The logic behind this expresion is very simple if we want to jump times from and we have all values for calculated then let s just jump times from and times from the obtained vertex This technique is called binary lifting Now we can jump from every cell times in time just iterate over all degrees from to and if has the th bit on just jump from the current vertex times set The rest of solution is described above Time complexity 
480,To begin with let s understand why the string will return to its original form In fact the graph that the permutation sets consists of simple cycles and it turns out that after a certain number of operations each character will return to its place Consider each cycle as a string that is cyclically shifted every turn It may seem that the answer is the smallest common multiple of the cycle lengths but to become equal to the initial string it is not necessary to go through the entire cycle The constraints allow us to calculate the length of the minimum suitable shift in where is the length of the cycle so just iterate over the desired shift Note that after operations the cycle will return to its original form and this will happen again after operations The answer will be of all since each cycle individually comes to its original form after the number of operations is a multiple of its 
481,First of all since we are going to buy exactly shovels we may discard most expensive shovels from the input and set and solve the problem which requires us to buy all the shovels Also let s add an offer which allows us to buy shovel and get cheapest of them for free to simulate that we can buy shovels without using offers Now we claim that if we sort all the shovels by their costs it s optimal to divide the array of costs into some consecutive subarrays and buy each subarray using some offer Why should the sets of shovels for all purchases be consecutive subarrays Suppose it s not so let s pick two purchases such that they are mixed in the array of costs i e there exists at least one shovel bought in the first purchase such that there exists a shovel cheaper than it and a shovel more expensive than it both bought in the second purchase If shovel is for free then we may swap shovels and otherwise we may swap shovels and and the answer won t become worse So we can do it until all purchases correspond to subsegments in the array of costs Then it s easy to see that we can make purchases in such a way that we always buy some amount of cheapest shovels And now the problem can be solved by knapsack like dynamic programming let be the minimum cost to buy exactly cheapest shovels is and for each offer we can update by the value of where is the sum of costs of all shovels in the sorted order from shovel on position to shovel on position inclusive these sums can be calculated in using partial sums method 
482,Consider all strings that differ from the first one in no more than one position this is either the first string or the first string with one character changed We will go through all such strings and see if they can be the answer To do this go through all the strings and calculate the number of positions where they differ 
483,I m almost sure this problem can be solved faster and with greater constraints but this version is fine for the last problem Consider both strings indexed and let s do the dynamic programming It means the maximum number of occurrences of if we considered first characters of did moves and the number of characters is The answer to the problem is Initially all states are and is What about transitions There are essentially three types of them don t change the current character change the current character to and change the current character to Let s create three additional variables to make our life easier if that were true is if and otherwise is if and otherwise and is if and otherwise Now let s make and describe our transitions Don t change the th character The expression is just ternary if statement if is true return otherwise return So the number of characters increases if equals and the answer increases if the th character equals because we added all occurrences that end in the th character Change the th character to possible only when The number of characters always increases and the answer increases if equals by the same reason as in the previous transition Change the th character to possible only when The number of characters increases only if and the answer always increases Note that we always increase the number of moves in the second and the third transitions even when equals or because this case is handled in the first transition so we don t care Time complexity There are also some greedy approaches which work in with pretty small constant and can be optimized even further 
484,As we know from the problem statement Polycarp believes that a set of k segments is good if there is a segment l i r i 1 leq i leq k from the set such that it intersects every segment from the set the intersection must be a Let s iterate over this segment which intersects all the others and construct a good set of the remaining segments maximum in terms of inclusion It is easy to understand that this set will include all segments that intersect with ours We must delete all other segments Two segments l 1 r 1 and l 2 r 2 intersect if max l 1 l 2 le min r 1 r 2 Then if the segment that we iterate over has coordinates L R then we must remove all such segments l r for which r L or R l is satisfied that is the segment ends earlier than ours begins or vice versa Note that these two conditions cannot be fulfilled simultaneously since l le r and if both conditions are satisfied then r L le R l This means that we can count the number of segments suitable for these conditions independently Each of these conditions is easy to handle Let s create two arrays all the left boundaries of the segments and all the right boundaries of the segments Let s sort both arrays Now we can count the required quantities using the binary search or prefix sums but in this case we need to use the coordinate compression technique Taking at least the number of deleted segments among all the options we will get the answer to the problem 
485,There is some obvious dynamic programming solution that someone can describe in the comments but I will describe another one that in my opinion much easier to implement Firstly let s find some diameter of the tree Let and be the endpoints of this diameter and first two vertices of the answer You can prove yourself why it is always good to take the diameter and why any diameter can be taken in the answer Then there are two cases the length of the diameter is or the length of the diameter is less than In the first case you can take any other vertex as the third vertex of the answer it will not affect the answer anyway Otherwise we can run multi source bfs from all vertices of the diameter and take the farthest vertex as the third vertex of the answer It is always true because we can take any diameter and the farthest vertex will increase the answer as much as possible Time complexity 
486,Let s store for each vertex the minimum distance from it to the nearest one let s call it We will also store the global answer which for obvious reasons does not increase we will call it Let s now color the vertex let s set and run a depth first search from it This DFS will visit the vertices with Let us consider the vertex and its neighbour If we can relax through let s do it and start from Otherwise has a closer neighbour let s try to update the answer through it Also do not forget to update the answer via from all vertices that we visited The correctness of the algorithm is obvious let s evaluate its time complexity It is easy to notice that after the first operations We enter only the vertices from which firstly does not exceed and secondly was relaxed by the parent that is decreased by at least So we allowed ourselves a complete tree bypassing for the first operations and then amortized performed no more than operations The final asymptotics will be 
487,I know about some solutions that are trying to iterate over almost all possible triples but I have a better and more interesting one Possibly it was already mentioned in comments but I need to explain it Let s solve the problem greedily Let s sort the initial array The first number we would like to choose is the maximum element Then we need to pop out some maximum elements that are divisors of the maximum Then there are two cases the array becomes empty or we have some maximum number that does not divide the chosen number Let s take it and repeat the same procedure again but now we have to find the number that does not divide neither the first taken number nor the second taken number So we have at most three numbers after this procedure Let s update the answer with their sum This solution is almost correct Almost What have we forgotten Let s imagine that the maximum element is divisible by and and there are three following numbers in the array maximum divided by by and by Then their sum is greater than the maximum and may be greater than the answer we have because So if these conditions are satisfied let s update the answer with the sum of these three numbers It can be shown that this is the only possible triple that can break our solution The triple does not match because the maximum divided by divides the maximum divided by The triple is bad for the same reason And the triple has sum less than the maximum element 
488,Firstly let s calculate the answer let it be for some fixed vertex Let this vertex be the vertex Just run simple and calculate the result using the formula from the problem statement Also let s calculate the sum of values let the sum in the subtree of the vertex be in each subtree of the given tree if its root is the vertex It can be easily done with simple dynamic programming And now the magic part let s apply the technique which is called at least we called it so Let s maintain the correct values in subtrees at each step of our algorithm How will values and the answer change if we will go through the edge The following sequence of changes will change all values correctly Firstly it can be seen that will decrease by because the distance to each vertex in this subtree will decrease by one then will decrease by because we change the root of the tree we need this step to maintain the correct values then will increase by because the distance to each vertex in this subtree will increase by one and then will increase by because we change the root of the tree we need this step to maintain the correct values So we can recalculate all the values we need if we go through the edge So now we can write another one to try to update the answer for each vertex as a root as the chosen vertex 
489,Firstly notice that the length of the answer cannot exceed copies of Now we can do some kind of simple dynamic programming Let be the minimum possible length of the prefix of the regular bracket sequence if we are processed first characters of the first sequence first characters of the second sequence and the current balance is Each dimension of this dp should have a size nearby The base of this dp is all other values Transitions are very easy if we want to place the opening bracket then we increase if the th character of exists and equals the same with the second sequence and the balance increases by one and the length of the answer increases by one If we want to place the closing bracket then we increase if the th character of exists and equals the same with the second sequence and the balance decreases by one and the length of the answer increases by one Don t forget to maintain parents in this dp to restore the actual answer The last problem that can be unresolved is how to write this dp The easiest way is bfs because every single transition increases our answer by one Then we can restore answer from the state You can write it recursively but I don t sure this will look good And you also can write it just with nested loops if you are careful enough Time complexity If you know the faster solution please share it 
490,Because if we write down all characters of in order of both permutations and this string will be sorted it is obvious that these two strings are equal Let s try the maximum possible number of distinct characters and then replace extra characters with How to find the maximum number of distinct characters Let s iterate over all values of and in order from left to right If we staying at the position now let s add to the set the value and to the set the value And when these sets become equal the first time let s say that the block of positions such that values are in the set right now have the same letter and then clear both sets We can see that this segment of positions is the minimum by inclusion set that can contain equal letters We don t need to compare sets naively and clear them naively you can see implementation details in author s solution If the number of such segments is less than then the answer is otherwise the answer is and we can fill the string with letters in order of these segments if the segment is then all characters of with indices has the same letter the first segment has the letter the second one has the letter and so on all segments after th has the letter Time complexity 
491,It is clear that the order of operations does not affect the final result also it makes no sense to apply the same operation more than once by the property of the operation Let s construct a sequence of operations that will reduce the matrix to the matrix if the answer exists Let s try iterate over will we use the operation horizontal Now by the each element of the first line we can understand whether it is necessary to apply the operation vertical if Let s apply all necessary operations vertical It remains clear whether it is necessary to apply the operation horizontal for Let s look at each element of the first column by it you can understand whether it is necessary to apply the operation horizontal if 
492,Note that it is always advantageous for us to complete the task that has an earlier deadline first Only then will we proceed to the next task Then we can solve each problem independently for each exam Then it remains to score percent on the task on the available options This is a typical knapsack problem with an answer recovery 
493,To begin with we will hang the tree by the vertex In fact we want to go from the root to the top of going off this path to do things and coming back At one vertex of the path it is advantageous to get off it in all the necessary directions and follow it further So we will go once for each edge leading to and times for each edge leading to some of the cases but not leading to Let s match each vertex with an edge to its ancestor If the edge of a vertex leads to then is in the subtree of this vertex similarly with vertices with cases It is necessary for each vertex to determine whether there is a vertex in its subtree and whether there is a vertex from the array this can be done using a depth first search then we will calculate the answer according to the rules described above 
494,Firstly I know that this problem has very pretty linear solution and its author can describe it if he wants I ll describe my own solution without any data structures but Let be the total cost to connect all rooms from to to the Internet indexed Initially all other values are Let s iterate over all from to and make some transitions After all the answer will be The first transition is the easier update with just connect the current room directly To do other transitions let s carry two sets and and one array of vectors of length Set carries all values Initially it carries Set carries the minimum cost to cover some suffix of rooms that also covers the room Array of vectors helps us to carry the set efficiently First of all if then let s remove from Then let s remove all values of from Then if is not empty let s update with the minimum value of Then if then let be the minimum value of plus Update with and insert into Also let s add into if And after we make all we need with the current add the value to the set Time complexity It can be optimized to solution with some advanced data structures as a queue with minimums 
495,This is a typical problem on the technique The number of moves we will made equals So if would be small enough 25 is the upper bound I think then we can just run recursive backtracking in or in to iterate over all binary masks of lengths containing exactly ones and check each path described by such mask in this mask is the move to the bottom and is the move to the right if its is But it is too slow So let s split this mask of bits into two parts the left part will consist of bits and the right part will consist of bits Note that each left mask and each right mask too uniquely describes the endpoint of the path and the path itself Let s carry associative arrays where for the endpoint and will denote the number of paths which end in the cell having Let s run recursive backtracking which will iterate over paths starting from the cell and move to the right or to the bottom and maintain of the path If we made moves and we are currently in the cell with right now set and return from the function Otherwise try to move to the bottom or to the right changing as needed Let s run another recursive backtracking which will iterate over paths starting from the cell and move to the left or to the top and maintain of the path except the last cell The same if we made moves and we are currently in the cell with right now let s add to the answer obvious that way we complement our from the right part of the path with the suitable from the left part of the path Otherwise try to move to the left or to the top changing as needed So this is the technique at least the way I code it Overall complexity is 
496,The main idea is that we don t need more than border points on each level So if we consider than the point is less than point when or and then let s distribute all the points by their levels using or something like it sort points on each level by the comparator above and remain the first one and the last one on each level Also let s add the fictive level with the point It is always true to remain at most points and can be easily proved but this fact is very intuitive I think Now let s do dynamic programming on the points means that now we are at the level and stay in the first point if or in the last point if and we are already visit all the points on the level The value of this dynamic programming is the minimum possible total distance to reach this state Initially other values are equal to Let s calculate this dynamic programming in order of increasing levels Let be the first key point at the level and be the last key point at the level Now if we are at the level and the previous level is these transitions are sufficient to calculate states of dynamic programming on the current level There means the distance between points and Let last level we have be After calculating this dynamic programming the answer is 
497,Firstly let s compress the given borders of segments just renumerate them in such a way that the maximum value is the minimum possible and the relative order of integers doesn t change Pretty standard approach Now let s do recursive dynamic programming This state stores the answer for the segment not necessarily input segment How about transitions Firstly if there is a segment covering the whole segment why don t just take it It doesn t change anything for us The first transition is just skip the current left border and try to take the additional answer from the state The second transition is the following let s iterate over all possible segments starting at we can store all right borders of such segments in some array Let the current segment be If just skip it if then we can t take this segment into the answer because it s out of and if then we can t take it because we considered it already Then we can take two additional answers from and from Don t forger about some corner cases like when or and something like that You can get the answer if you run the calculation from the whole segment What is the time complexity of this solution We obviously have states And the number of transitions is also pretty easy to calculate Let s fix some right border For this right border we consider segments in total Summing up we get transitions So the time complexity is P S I am sorry about pretty tight ML yeah I saw Geothermal got some memory issues because of using map I really wanted to make it 512MB but just forgot to do that 
498,First of all I wanted to offer you one little challenge I found a solution that I can t break and I don t sure if it can be broken and I will be so happy if anyone will give me countertest which will break it You can see its code below Let s notice that we can reduce our problem to the following find two substrings of the given string that letters in them do not intersect and the total length of these substrings is the maximum possible Why can we make such a reduction It is so because our answer consists of at most two non intersecting parts one fixed substring and at most one substring that we appended to the first one We can always append any other substring to the first one by one reverse operation just look at some examples to understand it Let s iterate over all possible substrings of length at most AL where AL is the size of the alphabet which contain distinct letters We can do it in O n AL Let the current substring containing distinct letters be s i j Let s create the bitmask corresponding to this substring the bit pos is 1 if the pos th letter of the alphabet is presented in the substring and 0 otherwise letters are Store all these masks somewhere Notice that our current problem can be reduced to the following we have the set of masks and we need to find a pair of masks that they do not intersect and their total number of ones in them is the maximum possible This reduction is less obvious than the previous one but you also can understand it considering some examples So how to solve this problem We can do it with easy bitmasks dynamic programming Let dp mask be the maximum number of ones in some mask that is presented in the given string and it is the submask of mask How to calculate this dynamic programming First of all all values dp mask for all masks presented in the string are equal to the number of ones in corresponding masks Let s iterate over all masks from 0 to 2 AL 1 Let the current mask be mask Then let s try to update the answer for this mask with the answer for one of its submasks It is obvious that because of dynamic programming we need to remove at most one bit from our mask to cover all possible submasks that can update our answer So let s iterate over all bits in mask let the current bit be pos If this bit is zero then just skip it Otherwise update dp mask max dp mask dp mask hat 2 pos where hat is the operation After calculating this dynamic programming we can finally calculate the answer Let s iterate over all masks presented in the string let the current mask be mask We can update the answer with the number of ones in mask plus dp mask hat 2 AL 1 mask hat 2 AL 1 is the completion of mask Total complexity O n AL AL 2 AL 
499,This is pretty standard dynamic programming problem Let be the maximum possible sum we can obtain if we are at the element right now we took elements in the row and our current remainder is Initially all states are except Transitions are standard because this is a knapsack problem we either take the element if or don t take it If the element is not the last element of the row then transitions look like that we don t take the current element we take the current element this transition is only possible if The transitions from the last element of the row are almost the same but the next element is and the new value of is always zero The answer is 
500,Firstly let s divide all projects into two sets all projects giving us non negative rating changes let this set be and all projects giving up negative rating changes let this set be Firstly let s take all projects from the set How do we do that Let s sort them by in non decreasing order because each project we take cannot make our rating less and we need to consider them in order of their requirements If we can take the current project set and go further otherwise print and terminate the program Okay what do we do with the projects that has negative Firstly let s set This means the tighter requirement of this project obviously Then let s sort all projects in order of in non increasing order and go from left to right and take all of them If we cannot take at least one project the answer is Otherwise the answer is 
501,Let s iterate over all possible answers Obviously this value is always in the range The first day when Ivan can order all microtransactions he wants will be the answer How to check if the current day is enough to order everything Ivan wants If we had several sale days for some type of microtransaction of course we can use only such days that are not greater than the fixed last day let s use the last one it is always not worse than some of the previous days Then let s iterate over all days from to and do the following firstly let s increase our balance by one burle Then let s try to order all microtransactions for which the current day is the last sale day and pay one burle per copy If we are out of money at some moment then just say that we should order all microtransactions that remain in this sale day during the last day for two burles per copy It is true because it does not matter which types will remain because this day is the last sale day for all of these types So after all we had some remaining microtransactions that we cannot buy during sales and the current balance And the current day is good if the number of such microtransactions multiplied by two is not greater than the remaining balance 
502,Suppose the number contains digits The desired number isn t greater than the number consisting of digits This number is beautiful whereas any beautiful number is at the same time beautiful so contains at most digits At the same time so contains at least digits Therefore the desired number contains exactly digits Suppose There are exactly beautiful numbers containing exactly digits To get the answer fast it s possible to consider all these numbers Suppose If is already beautiful let s output it Otherwise let s initialize the answer by the value as if Let s iterate two digits and such that Let s search for the answer by considering the strings consisting only of digits and Let s iterate a prefix of starting from the empty one so that the prefix will be the prefix of This prefix must contain only the digits and Consider the leftmost digit that doesn t belong to the prefix Let s try to increase it If the digit is less than a possible answer is a number such that it has the considered prefix and all other digits are equal to Let s update the answer by this number i e if the found number is less than the best previously found answer let s set the answer to the found number If the considered digit is at least and is less than let s update the answer by the number such that it has the considered prefix the digit follows the prefix and all other digits are equal to 
503,Let s solve the problem using dynamic programming Let be the maximum total beauty of pictures if Vova is at the th picture now the number of remaining reposts is and Vova reposted the th picture Initially and all other values of are Let s learn to do some transitions to calculate this dynamic programming What is the way to do it Let s iterate over the position of the previously reposted picture and try to update using previously calculated values Obviously this position can be from to So let s iterate over the position let it be and if we need one more repost to repost the th picture is not then try to update pictures are indexed So where can we find the answer The answer is If this value is then the answer is Overall complexity is 
504,Note the fact that if the number of minus signs is greater than the number of plus signs by at least then there is sure to be a pair of standing next to minus signs according to the Dirichlet principle When we apply the operation of replacing two adjacent minus signs with a plus sign the balance the difference of plus signs and minus signs increases by Then we need to find the number of subsections such that the balance on them is a multiple of and non positive then we can apply the operations until the balance is The balance value on the segment equals the balance value on the right boundary minus the balance value on the left boundary i e we can find by prefix sums 
505,We can take vertex with the maximum degree and all its neighbours To implement it just run from vertex with the maximum degree See the authors solution for better understanding 
506,Let s root the tree by some vertex The edge where is the parent of is now nice if and only if the subtree of contains either all red vertices of the tree and no blue vertices or all blue vertices of the tree and no red vertices That s because removing that edge splits the tree into the subtree of and the component of every other vertex Thus the task is to calculate the number of red and blue vertices in each subtree with dfs and check a couple of conditions Overall complexity 
507,To view the main idea of the problem read the editorial of easy version The only difference is that for non negative we don t need to print if we cannot take the project we just need to skip it because we cannot take it at all And for negative we need to write the knapsack dynamic programming to take the maximum possible number of projects we need to consider them in order of their sorting Dynamic programming is pretty easy means that we consider projects and our current rating is and the value of dp is the maximum number of negative projects we can take If the current project is the th negative project in order of sorting we can do two transitions and if then we can make the transition And then we just need to find the maximum value among all values of dp and add the number of positive projects we take to find the answer 
508,Let s replace each number with the number of unique numbers less than For example the array will be replaced by Note that the values of the numbers themselves were not important to us only the order between them was important Let s sort such an array Let s see what maximum length of the segment from the array is already sorted it forms a subsequence This segment can be left in place and all other numbers can be moved either to the beginning or to the end That is the task came down to finding the maximum sorted subsequence in the array This problem can be solved with the help of simple dynamic programming Let be the maximum length of a subsequence ending in position To calculate it we will find the closest past position which also has the value and the position with value lower numbers cannot be used since must stand between them Any of these positions can be extended so we take the maximum out of them and add 1 It is necessary to separately consider the first numbers in the subsequence and the last since the first should include their suffix and the last should have their prefix 
509,The main idea of this problem is the same as in the easy version The only thing we should replace is the search method Replacing linear search with binary search leads to reducing time complexity from to And it is obvious that we can apply binary search here because if we can order all microtransactions during some day then we can order all of them during day even using the answer for days and doing nothing during day 
510,Suppose the number contains digits and its decimal representation is The desired number isn t greater than the number consisting of digits This number is beautiful whereas any beautiful number is at the same time beautiful so contains at most digits At the same time so contains at least digits Therefore the desired number contains exactly digits Since we search for the minimum we need to minimize first of all the first digit only then the second digit etc Therefore we need to find a prefix of the decimal representation of such that is a prefix of the decimal representation of Let s do it greedily Let s find the maximum prefix of such that contains no more than distinct numbers Suppose the prefix has the length If then is already beautiful let s output it Otherwise let s increase the prefix like a number by e g if and then we increase by the resulting prefix is All other digits let s set to zeroes e g if and then will be turned into The answer for the old is the answer for the new To get the answer for the new let s start the described procedure once again preparing the new Let s find the maximum prefix of such that contains no more than distinct numbers It s possible to do using a in which for each digit the key the number of its occurrences in the prefix is stored For an empty prefix the is empty If we increase the prefix length by we need to check that contains no more than keys and add a new key with the value or increase the value of an existing key If the length of the found prefix is equal to the length of the whole decimal representation the given number is already beautiful so the answer is Otherwise the found prefix may not be a prefix of the desired number Let s change the digits of the decimal representation of to turn it into the desired number Let s start the following procedure suppose we consider a prefix with the length equal to First let s find out is it possible to increase the first element out of the prefix i e We need to do it because if we consider the length then the prefix with the length cannot be unchanged so the element must be changed whereas it cannot be decreased because in this case we will get the number which is less than If we can increase the element so that the prefix with the length has at most distinct digits the only thing that is remained to do is to fill the remaining digits somehow greedily and output the result If we cannot increase the element let s decrease the length of the considered prefix by updating the let s decrease the value corresponding to the key by then if it s equal to we remove the key from the Consider how and under what conditions we can change and the following digits If it s impossible Suppose the considered prefix contains less than distinct digits the number of the keys in the is less than In this case we can replace the digit with the value so the prefix with the length will not contain more than distinct elements because the prefix with the length doesn t contain more than distinct elements If the prefix with the length still contains less than distinct numbers let s replace the remaining digits etc with Otherwise we can replace them with the minimum digit that occurs in the prefix with the length it may be Suppose the considered prefix contains exactly distinct digits So let s find the minimum digit that occurs in the prefix with the length and is greater than If such digit exists let s replace with it and all following digits with the minimum digit that occurs in the prefix with the length Otherwise the element cannot be increased The converted by the procedure is the answer 
511,Let s use dynamic programming described in the previous tutorial to solve this problem too But its complexity is so we have to improve some part of the solution Let s see how we do transitions in this dp for What can we do to optimize it is the constant and we have to take the maximum value among You will say segment tree I say no Not a segment tree Not a sparse table Not a cartesian tree or some other logarithmic data structures If you want to spend a lot of time to fit such solution in time and memory limits okay it is your choice I prefer the queue with supporting the maximum on it The last part of this tutorial will be a small guide about how to write and use the queue with supporting the maximum on it The first part of understanding this data structure is the stack with the maximum How do we support the stack with the maximum on it That s pretty easy let s maintain the stack of pairs when the first value of pair is the value in the stack and the second one is the maximum on the stack if this element will be the topmost Then when we push some value in it the first element of pair will be and the second one will be if is our stack and is the topmost element When we pop the element we don t need any special hacks to do it Just pop it And the maximum on the stack is always Okay the second part of understanding this data structure is the queue on two stacks Let s maintain two stacks and and try to implement the queue using it We will push elements only to and pop elements only from Then how to maintain the queue using such stacks The push is pretty easy just push it in The main problem is pop If is not empty then we have to pop it from But what do we do if is empty No problems let s just transfer elements of to pop from push to in order from top to bottom And don t forget to pop the element after this transfer Okay if we will join these two data structures we can see that we obtain exactly what we want Just two stacks with maximums That s pretty easy to understand and implement it The last part of the initial solution is pretty easy just apply this data structure in fact data structures to do transitions in our dynamic programming The implementation of this structure can be found in the authors solution Total complexity of the solution is 
512,Now we need to quickly find for a given balance value on the prefix the number of matching left boundaries The boundary is suitable if the balance on the boundary is comparable modulo to the current balance and the current balance is less than the balance on the boundary since we need the balance on the segment to be non positive That is we need to be able to find a number of numbers for each value of the balance that is not less than ours This can be done either by data structure or notice that the balance takes only different values then you can find the number of numbers not less on the prefix for 
513,Let s the same sum of blocks in the answer Obviously can be represented as a sum of some adjacent elements of i e for some and Iterate over all possible blocks in and for each sum store all the blocks You can use map int vector pair int int to store blocks grouped by a sum You can do it with the following code map int vector pair int int segs for int r 0 r n r int sum 0 for int l r l 0 l sum a l segs sum push back l r Note that blocks are sorted by the right end in each group After it you can independently try each group there are of them and find the maximal disjoint set of blocks of a group You can do it greedily each time taking into the answer segment with the smallest right end Since in each group they are ordered by the right end you can find the required maximal disjoint block set with one pass Let s assume is the current group of blocks they are ordered by the right end then the following code constructs the maximal disjoint set int cur 0 int r 1 vector pair int int now for auto seg pp if seg first r cur now push back seg r seg second Choose the maximum among maximal disjoint sets for the groups 
514,Firstly let s remove the vertex from the graph Then let s calculate the number of connected components Let it be The answer is if and only if or is greater than the number of edges incident to the first vertex Otherwise let s construct the answer Firstly let s add into the new graph spanning trees of components in the initial graph without vertex Then let s add into the new graph edges from vertex one edge to each component Then let s add into the new graph any remaining edges from vertex The last thing we need is to construct a spanning tree of a new graph such that all edges incident to the vertex are in this spanning tree and other edges doesn t matter How to do it Let s run from the vertex in a new graph 
515,Okay this solution is really complicated and I would like to hear nicer approaches from you in comments if you have any However I still feel like it s ok to have this problem in a contest specifically as a harder version of F1 Let s start with the following thing Root the tree by some vertex For each color take all vertices of this color and paint their lowest common ancestor the same color as them The purpose of that will come clear later Why can we do this The case with lca some vertex of that color is trivial Now take a look at the edges from lca to its subtrees At least two of them contain a vertex of that color You can t cut the edges to these subtrees because this will make vertices of the same color belong to different components Thus lca will always be in the same component as these vertices If lca is already painted the other color then the answer is 0 That s because lca once again make vertices of the same color belong to different components Now everything will be calculated in a single dfs Let return one of the following values if there is no colored vertex in the subtree of if there exists some color such that vertex has vertices of color in its subtree and vertex has ancestors of color not necesserily direct parent otherwise I claim that if there are multiple suitable colors for some vertex then the answer is 0 Let s take a look at any two of them and call them colors and For both colors take a path from arbitrary vertex of that color in subtree to arbitrary vertex of that color that is ancestor of You can t cut any edge on these paths because that will divide the vertices of the same color Now either path for color contains vertex of color or path for color contains vertex of color That vertex is the upper end of the corresponding path That means that component of one color includes the vertex of the other color which is impossible Moreover that s the last specific check for the answer being 0 The step with lca helped us to move to the ancestor instead of any vertex in the upper subtree of I truly believe that you can avoid lca in this solution however that will make both implementation and proof harder Now let s do the number of ways to cut some edges in the subtree of so that 0 the component with vertex has no colored vertices in it 1 has some colored vertices Generally the color itself for 1 doesn t matter If for some child of returned color then it must be color in that component otherwise the color doesn t matter For all vertices of each color presented in the subtree of are contained within the subtree of The transitions will be of form do we cut the edge from to or not for all children of That is the most tedious part so I m sorry if I mess up something the way I did with my author solution DHere from now I ll ignore the children that returned if I say all children I will mean all non zero returning children as they add nothing to the answer If there are no children then the vertices with will have and the other vertices will have Basically there are two main cases I would recommend to follow the code in attachment while reading this tbh and all children dfs returned Then for each edge to the child you can either cut it if there are colored vertices take or don t cut it if it has no colored vertices take So For to have some color you ll need to push that color from exactly one of the children You can t choose two subtrees because they are guaranteed to have different colors in them otherwise they wouldn t return So To calculate that fast enough you ll need to precalculate prefix and suffix products of or but some children returned the same value Then you are required to make the part of component with vertices of color That means that for that case For children who returned you don t cut their edge take For the other children you can either cut it if there are colored vertices take or don t cut it if it has no colored vertices take Thus The answer will be stored in after that Overall complexity but I m sure this can be rewritten in such a manner that it becomes 
516,Let s see how the desired matrix looks like Since each row should have exactly ones and each column should have exactly ones the number of ones in all rows should be equal to the number of ones in all columns Thus the desired matrix exists iff or Let s show how to construct the desired matrix if it exists Let s find any number such that where is the remainder of dividing by In the first row of the desired matrix we put the ones at the positions and in the th row we put the ones as in the row but cyclically shifted by to the right 
517,Let s find how much meat and fish a taster can eat at most Note that a taster can eat no more than of fish from the th dish since he can t eat more than or more than there is at all Similarly he can eat no more than of meat Let s sum the obtained values over all and denote the resulting sums by and the maximum total amount of fish and meat that can be eaten Let s denote by the value that is the without module If the taster eats as much fish as possible he will eat of fish and of meat and change the by Similarly if he eats the maximum amount of meat the will change by Note that the taster can achieve any between and of the same oddity as both of these numbers To do this just take the way of eating the maximum fish and substitute eating a gram of fish for a gram of meat several times Thus the final can be found as over all between and with same oddity To do this just check the boundaries of the resulting segment if they have the same sign then it s the boundary with the smallest absolute value otherwise we can take one of the numbers present in said set depending on the parity of All that remains is to find how much of what type to eat from each dish Having obtained the answer in the previous paragraph the final balance we can reconstruct how much fish and how much meat the taster has to eat to achieve it The expected amount of fish to be eaten can be found as Note that the taster must eat of fish from the th dish since if meat then at least of fish is guaranteed to be eaten Let s break down into the sum of how much total fish will have to be eaten anyway and the remaining value Let s go through all the dishes and collect the first summand as just the sum of over all and the second summand with greedy algorithm each time giving the taster as much fish beyond what he must eat anyway until the sum of such additions reaches And knowing for each dish how much fish will be eaten from it the amount of meat eaten can be calculated by subtracting the fish eaten from 
518,First of all to maximize the number of candies in the gift we can use the following greedy algorithm let s iterate on the number of candies of some type we take from to backwards For fixed let s try to find any suitable type of candies A type is suitable if there are at least candies of this type in the box If there exists at least one such type that wasn t used previously let s pick any such type and take exactly candies of this type and decrease It does not matter which type we pick if we only want to maximize the number of candies we take Okay let s now modify this solution to maximize the number of candies having We initially could pick any type that has at least candies but now we should choose a type depending on the number of candies with in this type For example if we have two types having and candies with respectively and we want to pick candies from one type and candies from another type and and it s better to pick candies of the first type and candies of the second type In this case we have candies with in the other case it s And if and then So when we want to pick a type of candies such that we will take exactly candies of this type it s optimal to choose a type that wasn t used yet contains at least candies and has maximum possible number of candies with This best type can be maintained with a multiset or a set of pairs 
519,Consider a substring Let s call square brackets located in odd positions in the substring brackets and square brackets located in even positions brackets Let be the number of odd brackets be the number of even brackets be the number of all square brackets Let s prove that the string can be turned into a correct bracket sequence for burles if and only if Let s prove the necessary condition Suppose the initial substring has been turned into a correct bracket sequence Since we have paid burles there s no bracket which form has been changed Therefore for the new sequence is the same as for the initial sequence the similar situation happens with Let s say that two square brackets form a pair if the left one is an opening bracket and the right one is a closing bracket and the substring between them is a correct bracket sequence A pair can be formed only by one odd bracket and one even bracket because between them is placed an even number of brackets since it s a correct bracket sequence so the difference between their indices is odd In a correct bracket sequence each square bracket has a pairwise bracket Therefore a correct bracket sequence contains pairs of brackets so Let s prove the sufficient condition Suppose the initial substring contains equal numbers of odd and even brackets Let s prove by induction that the substring may be turned into a correct bracket sequence for burles Suppose So the initial substring contains only round brackets Let s make the first brackets opening and the other brackets closing The resulting sequence is a correct bracket sequence whereas we haven t changed the form of any bracket so the cost is equal to A correct bracket sequence has two important properties after deleting its substring being a correct bracket sequence the resulting string is a correct bracket sequence after inserting at any place any correct bracket sequence the resulting string is a correct bracket sequence These properties can be applied to an incorrect bracket sequence too after deleting a substring being a correct bracket subsequence from an incorrect bracket sequence or inserting a correct bracket sequence into an incorrect one the resulting sequence is an incorrect bracket sequence Consider a substring such that Suppose we have proved before that each substring having decreased by can be turned into a correct bracket sequence for burles Let s find two square brackets such that one of them is odd and another one is even and there are no square brackets between them There s an even number of round brackets between them that can be turned into a correct bracket sequence for burles Let s make the left found bracket opening and the right one closing Then the substring starting at the left found bracket and ending at the right found bracket is a correct bracket sequence Let s remove it from The resulting string contains odd brackets and even brackets so by the assumption of induction it can be turned into a correct bracket sequence for burles Let s do it and then insert the removed string into its place Since we insert a correct bracket sequence into a correct bracket sequence the resulting string is a correct bracket sequence Actually the operations of inserting and removing are not allowed they have been used for clarity the string can be turned into a correct bracket sequence without these operations as follows let s turn the substring we have removed into a correct bracket sequence as it was described above then change the other brackets of the string the same way as it was done with the string that was the result after removing The resulting string is a correct bracket sequence Therefore the illegal operations of inserting and removing are not necessary all other operations cost burles so the substring can be turned into a correct bracket sequence for burles Therefore to turn a substring into a correct bracket sequence we need to get a sequence such that Suppose initiallly Let s pay burles to replace odd brackets with round brackets If let s replace even brackets with round brackets Anyway we must pay burles We cannot pay less than this value because for a correct bracket sequence But there s no need to pay more than this value because if we turn the initial substring into a sequence with we can turn it into a correct bracket sequence for free Therfore the answer for a given question is Since we must answer the queries fast let s use a concept of prefix sums If the given string contains brackets let s create arrays and with the length will contain the number of odd brackets on the prefix of the string with the length the same value for even brackets Let s initialize and then iterate from to Let s initialize and If the th bracket is round then the current values are correct Otherwise let s find out what bracket is it If is odd the bracket is odd so we must increase by If is even the bracket is even so we must increase by To get the answer for a current and let s calculate and is a number of odd brackets that belong to the prefix with the length but not to the prefix with the length so Similarly The remaining thing is to output 
520,Firstly we can determine that the answer is if some number has not two occurrences Otherwise the answer exists and we actually don t need to prove it because we can check it later Let s find for each number i from 1 to n indices of columns in which it appears c 1 i and c 2 i Consider some number i If c 1 i c 2 i then let s just skip it we can t change anything by swapping values in this column Otherwise let r 1 i be the number of row of the number i in the column c 1 i and r 2 i is the number of row of the number i in the column c 2 i If r 1 i r 2 i then it s obvious that at exactly one of these two columns should be swapped The same if r 1 i ne r 2 i then it s obvious that we either swap both of them or don t swap both of them Let s build a graph consisting of n vertices when the vertex v determines the state of the v th column If r 1 i r 2 i then let s add edge of color 1 between vertices c 1 i and c 2 i Otherwise let s add the edge of color 0 between these vertices So we have the graph consisting of several connected components and some strange edges Let s color it If the edge v to has the color 1 then the color of the vertex to should be different from the color of the vertex v The same if the edge v to has the color 0 then the color of the vertex to should be the same as the color of the vertex v This makes sense because edges with color 1 mean that exactly one of the columns connected by this edge should be swapped and vice versa So after we colored the graph we can ensure that conditions for each edge are satisfied If it isn t so the answer is but this case can t actually appear Otherwise we need to decide for each component independently what is the color 0 and the color 1 means for it The color 0 can mean that the column having this color isn t swapped and the color 1 means that the column having this color is swapped in this case and vice versa We can choose greedily the minimum number of swaps for each component and print the answer Time complexity O n 
521,In the set we will keep the indices that start the trains That is if the array the real speeds of the carriages then we will store in the network such values that As well as the value of Thus the size of the set is the answer to the problem Consider now the operation to reduce the speed of the carriage find such maximal index in the set if the value then we should add the value to the set since it will start a new train Then we should remove all subsequent indexes from the set such that Thus for all operations we will add no more than elements to the array and remove in total no more than elements from the set We obtain the asymptotic 
522,Note that in any shortest path we cannot return to the previous vertex Since if the current vertex the previous The current distance the shortest distance to vertex the shortest distance to vertex Then if we return to the vertex the shortest distance from it to is If we add to the current distance we get Thus we get a path at least longer than the shortest one Thus our answer consists of only simple paths If the answer consists only of simple paths then we will simply add vertices to the queue when traversing bfs twice on the first visit and on the next visit when the distance to the vertex is equal to the shortest And we will also count the number of ways to get to that vertex Then we can output the answer as soon as we get to the vertex the second time for processing After that we can terminate the loop The asymptotic will be since we only need bfs 
523,First find all occurrences of in as substrings This can be done using the prefix function To find the minimum number of times we need to cut substrings consider all indexes of occurrences Having considered the index of the occurrence we cut out the rightmost occurrence that intersects with it After that we find the leftmost occurrence that does not intersect with the cut one If it doesn t we end the loop The number of optimal sequences of moves will be calculated using dynamic programming For each occurrence we can count how many ways we can cut out all occurrences of in the suffix starting with this occurrence in the minimum number of moves Considering the occurrence we find the leftmost occurrence that does not intersect with it and then iterate over the occurrences with which we can remove it 
524,After parsing the statement you can understand that Monocarp plays cyclically in one cycle he chooses some order of opponents and play with them in that order Then repeats again and again until he gains desired rating at some moment So firstly let s prove that in one cycle it s optimal to play against opponents in Suppose you play with opponents in some order and there is a position where if you swap and you won t lose anything and may even gain extra wins It means that the total gain after playing one cycle in increasing order in greater or equal than playing in any other order In other words we can sort array and play against them cyclically in that order Monocarp s list of games will look like several full cycles and some prefix The problem is that there can be many cycles and we need to skip them in a fast way How one cycle looks Monocarp starts with some wins first games and then loses all other games games where The maximum rating he gains is and the resulting rating after all games is We can already find several conditions of leaving a cycle if then Monocarp gets what he wants and stops otherwise if or he will never gain the desired rating since in the next cycle the number of wins since his starting rating Otherwise if and he will start one more cycle with rating and will gain the desired rating eventually So how to find the number of games he will win for a starting rating Let s calculate two values for a given sorted skill array for each let s calculate the minimum rating Monocarp need to win opponent and all opponent before and the rating he ll get after winning the th opponent We can calculate these values in one iteration we ll use indexation then for each if then and otherwise and Now knowing values it s easy to find the number of wins for a starting rating is equal to minimum such that don t forget indexation Or the first position in array with value strictly greater than We can search it with standard function since array is sorted Okay we found the number of wins for the current Let s just calculate how many cycles Monocarp will make with exactly wins There are only two conditions that should be met in order to break this cycle either Monocarp reaches rating it can be written as inequality or the number of wins increases starting rating becomes greater or equal than i e From the first inequality we get minimum and from the second one As a result we can claim that Monocarp will repeat the current cycle exactly times and either finish in the next turn or the number of wins will change So we can skip these equal cycles we can increase answer by and current rating by Since we skip equal cycles then at each step we either finish with success or or the number of wins increases Since is bounded by we will make no more than skips and total complexity is because of initial sorting and calls of 
525,In this problem we can use a binary search for the answer If we can make sets then we can make sets So we need to come up with the following test whether we can make sets knowing the parameters Let otherwise we will swap them If the answer is Otherwise let s say we want to make sets of the first kind Then we get a system of inequalities Let s express from here We need to check whether these four equations have an intersection in integers If there is then the division into gifts exists 
526,The first observation if we have an answer where the first row is inverted we can inverse all rows and columns then the matrix will remain the same and the first row is not inverted in the new answer So we can suppose that the first row is never inverted Note that this will be true only for slow solution The second observation if we consider a sorted matrix its first row either consists only of s or has at least one and then all other rows consist only of s This observation can be extended to the following one user wrote a comment about it and I pinned the link to it above which can improve time complexity of the solution a lot in the sorted matrix either the first row consists only of s or the last row consists only of s the corner case is n 1 but for n 1 we can obtain both answers So what should we do with these observations I will explain a slow solution a faster solution can be obtained by mirroring one of cases of this one Let s iterate over the number of s in the first row Let it be cnt Then the first cnt elements of the first string should be s and all others should be s We can do it by inverting the columns with elements among first cnt elements of the first row and columns with elements among remaining elements So it s case handling time The first case when cnt m is pretty easy We have to check if all rows from 2 to n that they consist only of s or only of s and if some row consists of s then we should invert it If it is true then we found the answer Otherwise the first row consists only of s So we have to find the transitional row the row with some s on the prefix and s on the suffix or vice versa If the number of such rows among all rows from 2 to n is greater than 1 then this configuration is bad If the number of such rows is 1 then let idx be the index of this row Then we should inverse all rows above it consisting only of s and all rows consisting only of s below it And we have to check if the current row is really transitional We know that its sum is neither 0 nor m so there is at least one and at least in it If the first element is then let s inverse it Then we just should check if this row is sorted and if it is then we found the answer And the last case is if there are no transitional rows in the matrix Then we should invert all rows from 2 to n consisting only of s or only of s it does not matter So we have a solution with time complexity O n 3 Each number of s in the first row is processed in O n 2 and there are O n such numbers But we can see that if we apply the last case when the number of is m to the first row and then do the same but with the last row consisting of m we can get a solution in O n 2 
527,To begin with let s learn how to find possible sets of friends for the vertex whom he can give a ride in the form of masks Let s use a breadth first search every time we find the shortest path to the vertex with the previous vertex we will add the masks of the vertex to the masks of the vertex updating them with friends living in Now according to the resulting sets you need to get the best combination of them We will find it using the knapsack problem we will use masks as weights and the total weight will be the bitwise of the selected set 
528,One possible solution involves the method of dynamic programming As a state of DP we will use the number of already placed segments and the distance from the end of the last segment to the current left boundary of the coverage and in the DP we will store the minimal possible distance from the end of the last segment to the current right boundary of the coverage We can prove that the answer never exceeds where is the maximal length of the segments To do this let us define a region of length specifically the segment If the end of the last segment has a coordinate we put the next segment to the left otherwise we put it to the right With this algorithm none of the end endpoints of the segments will go beyond the marked boundaries because to do so the segment must be placed from the coordinate of one sign beyond the boundary of the opposite sign and thus must have a length greater than which contradicts how we defined Using this fact we will consider the DP for and as the minimum distance between the end of the th segment and the right boundary of the axis coverage of the first segments when the distance to the left boundary of the coverage equals to The end of the th segment here is the beginning of the first one that is the point The base of DP is since when no segments are placed the coverage boundaries and the current point are all coincident Next we consider the forward dynamic programming relaxation for every there are two cases to consider the case of the next segment being placed to the left and the case of it being placed to the right value below refers to the distance to the right boundary of the coverage and is an alias for If a segment of length is placed to the left side then the new distance to the left boundary will be equal to and distance to the right boundary will always be which gives us the relaxation formula If a segment of length is placed to the right side then the new distance to the right boundary will be equal to and distance to the left boundary will always be which gives us the relaxation formula The values in array can be calculated in ascending order by Then the answer for the problem can be found as the minimum sum of and in the last row of that is The time complexity is 
529,I ve heard about some very easy solutions with time complexity where is the maximum value of but I will describe my solution with time complexity where is the maximum number of divisors of A very good upper bound approximation of the number of divisors of is so my solution works in Firstly let s talk about the idea The main idea is the following for each number from to we want to find two minimum numbers in the array which are divisible by this number Then we can find the answer among all such divisors that have at least two multiples in the array Let s write a function which will try to add the number to all its divisors The easiest way to do it is iterate over all divisors in time and add it somehow But it is too slow Let s improve it somehow How can we skip numbers that aren t divisors of Let s build an Eratosthenes sieve I highly recommended one with time complexity because the sieve with time complexity is about twice slower on such constraints which will maintain the minimum divisor for each number from to the linear sieve builds this array automatically in its implementation Then we can factorize the number in and iterate over all its divisors using simple recursive function And the last thing I should notice this solution can give TLE and require some constant optimizations I recommended to use pair of integers or arrays of size two for each divisor and to add numbers using a few statements 
530,We need to minimize the result of the bitwise operation so for convenience we represent the answer as a mask Firstly let s assume that this mask is composed entirely of ones Let s go from the most significant bit to the least significant one and try to reduce the answer To understand whether it is possible to remove the th bit remove it and check if the graph in which all the weights are submasks of the current answer is connected for this you can use depth first search or a disjoint sets union If the graph is connected then the bit can obviously be thrown out and if not it cannot and must be returned 
531,Find the distances to all vertices and construct a new graph that has only edges that goes from a vertex with a smaller distance to a vertex with a larger distance Such a graph cannot contain cycles Next you need to run a dynamic programming similar to finding bridges in an undirected graph First we write the minimum distance from each vertex to the capital using no more than one edge This distance is either equal to the distance from the capital to the vertex itself or the distance to the vertex connected to us by one of the remote edges We can t go through more than one remote edge The real answer for a vertex is the minimum of such values in all vertices reachable from in the new graph Since the new graph is acyclic we can calculate the answer using dynamic programming and a depth first search started from the capital 
532,Let s denote for the sum of all the elements of the array and for the array of its prefix sums If the drive runs for seconds the sum is This formula immediately shows that if and then the disk will run indefinitely Otherwise the answer exists The disk cannot make less than full spins otherwise the required amount simply will not be achived The disk can t make more spins either because when it reaches the position of the maximum prefix sum will already be achived So we know how to determine the number of full spins of the disk Let s make these spins Now we have a new problem given find the first position in the array such that This problem can be solved using binary search If is not sorted into the array that is there is such that then can simply be thrown out of the array the answer will never be reached on it 
533,Note that all are positive which means that the amount on the prefix only increases This allows us to use binary search to find the answer for the vertex It remains only to learn how to quickly find the sum of on the path prefix Let s run a depth first search and store the prefix sums of the current path in stack going to the vertex add the sum to the end of the path and delete it when exiting 
534,Let s carry the value that means the answer for the current set of edges Initially it is Let s sort all edges by their weight and all queries by their weight also both in non decreasing order Let s merge components of the tree using disjoint set union We need to carry sizes of components also it is easy if we use Then let s iterate over all queries in order of non decreasing their weights If the current query has weight then let s merge all components connected by edges with weight When we merge two components with sizes and the answer changes like that The value equals to It is so because we subtract all old paths corresponding to these components and add all new paths in the obtained component So the answer for the current query will be after all required merges Time complexity 
535,If in the current day there is no exam we should prepare for an exam for which questions already given for which we prepare less than needed and which will be before other remaining exams For this we will use array where equals to the number of days which we already prepared for exam Initially array consists of zeroes Let s iterate through the days Suppose exam is in the current day If we did not have time to prepare for it and we should print In the other case in this day we will pass the exam In the other case let iterate through all exams and choose exam for which we need still to prepare i e for which already given the questions and which will be before other remaining exams If there is no such exam we should relax in this day else in this day we should prepare for exam Also we should increase by one 
536,Formally the problem is to paint tree edges in minimal number of colors in such a way the the number of improper vertices doesn t exceed A vertex is improper if it has at least two incident edges of the same color It is easy to show that colors is always enough to paint a tree in such a way that all the vertices are proper where is the maximum vertex degree Actually it is always the truth do any bipartite graph Indeed if number of colors is less than the maximum degree such vertices will have at least two edges of the same color Dirichlet s principle If equals the maximum degree you can use just depth first search tree traversal to paint edges in different colors In this problem you can have up to improper vertices so just choose such minimal that number of vertices of degree greater than is at most In an alternative solution you can use a binary search to find such but it makes the implementation harder and the solution becomes slower by factor After it paint edges with colors each time choosing the next color skip color if it equals with the color of the traversal incoming edge 
537,If we would naively solve the problem we would just try to replace each edge s cost with zero and run Dijkstra algorithm times to get the cheapest paths But this is too slow Let s try to replace each edge s cost with zero anyway but use some precalculations to improve the speed of the solution Let s firstly run Dijkstra times to calculate all cheapest pairwise paths Then let s fix which edge we remove There are three cases for the path this edge was not on the cheapest path before removing and is not on the cheapest path after removing Then the cost of this path is The second case is when this edge was not on the cheapest path before removing but it is on the cheapest path after removing Then the cost of this path is So we are just going from to using the cheapest path then going through the zero edge and then going from to using the cheapest path also or vice versa from to and from to And the third case is when this edge was already on the cheapest path between and but this case is essentially the same as the second one So if we fix the edge then the answer for this edge is Taking the minimum over all edges we will get the answer The precalculating part works in and the second part works in 
538,Let s solve the problem in reverse Imagine we have already removed some edges so that the conditions hold When is some set of vertices considered Since the graph is acyclic we can topologically sort the vertices in the set The vertices are reachable from each other so there exists a path from the th vertex in the set to the st vertex Thus there exists a path that goes through all chosen vertices However we can make this conclusion even stronger In the optimal answer not just the path goes from the th vertex to the st one but a single edge That can be shown by contradiction Let there be some vertices and that are adjacent in the chosen set There exists a path between them but not a single edge We want to show that this set is not optimal and can be made larger The vertices on that path don t belong to the set If they did they would be between and in the set because of the topological order We can add them to the set Every vertex that can reach can reach them too and every vertex that can be reached from can be reached from them Thus it will still be a set Now every vertex from to has an edge between them and the size of the set is larger Thus we showed that the maximum set in the answer is always some path in the graph So the task is to choose some path then remove some edges so that this path still exists and the conditions hold Note that if the conditions hold for some set of remaining edges then we can remove any edge from it and the conditions will still be met Thus we can only leave this path Let s look closer into the conditions What they actually tell is the following If a vertex has incoming edges then remove at least one of them The same for the outgoing edges Since we are looking for a path it s enough to leave one outgoing edge for all vertices except the last one and leave one incoming edge for all vertices except the first one In order to achieve that every vertex except the last one should have at least two outgoing edges and every vertex except the first one should have at least two incoming edges We can see that this condition is not only necessary but sufficient as well Just remove the outgoing edges which don t go to the next vertex and the incoming edges which don t go from the previous vertex Now we can wrap this up into the dynamic programming Initialize the answer with since you can always remove all edges and get a set with one vertex Then let be the longest path such that it starts in vertex all vertices in it have at least two incoming edges and all vertices except maybe the final one have at least two outgoing edges Initialize the for the vertices that can be the final in the path have at least two incoming edges with Then update for all that can be internal vertices have at least two outgoing and two incoming edges with for all outgoing edges Finally update the answer from the vertices that can be the first one in the path For each vertex that has at least two outgoing edges take the value of for all outgoing edges Overall complexity 
539,First let s check the array for correctness that is that it has no repeating elements Then let s look at the following ideas each number must be paired with another permutation element with by the definition of array Then since we want a lexicographically minimal permutation it is always more advantageous to put element before for the permutation to be lexicographically minimal the smallest possible numbers must be placed at the beginning Consequently the largest numbers must be placed at the end Let s proceed as follows Let s select the set of numbers that are not included in the array For an element find the maximum number of the set such that and put that number in front of the element moving from the end of the array to its beginning each element will be matched with such an element If at some point can not be matched array is not composed correctly and the answer to the query Otherwise print and the resulting permutation 
540,Note first that we can solve the two subtasks independently if we consider the coloring as on a chessboard since at any move of the robot the parity of does not change Now replace the moves with moves respectively This can be done because we simply shifted the rows by some value with the Robot walking on the same cells it walked on in the original board Let s look at the even numbered gray cells Then we ll go through the columns from left to right keeping the minimum by size set of cells the Robot should be in Then the transition to the next column will be as follows Go through the cells from bottom to top which contain the candy For each cell find the closest cell of our set find the Robot that is above the current cell Then we change the square from the set to the current square If there is no robot for the square in the array then we need to increase the answer by and add the robot to our current square you can think of it as adding the robot to the very top square in the column and getting all the candies that were above In the picture the red circles indicate the cells where we will put the robot as needed The pink cells mean that this cell is contained in the set The final asymptotic depends on the implementation you can use a set as data structure or you can use a vector with two pointers and respectively 
541,Note that n le d n le 10 7 10 7 is the maximum value of c in the problem so it is enough for every n 1 10 7 to calculate the value of d n To calculate the value of d n you can use the sieve of Eratosthenes and get the solution for mathcal O 10 7 log 10 7 Also you can use the linear sieve of Eratosthenes to find the minimum divisor for each n 1 10 7 and use the multiplicativity of the function d n d a cdot b d a cdot d b if gcd a b 1 
542,For convenience we will calculate the prefix sums on the array we will also enter the array containing the indexes of all pancakes and calculate the prefix sums on it Let s use dynamic programming Let s define as the required number of operations to correctly lay out the th prefix with the final and Then you can go to from the previous number must be greater and the sum is fixed To it will be necessary to add a certain number of actions necessary to get let s call it all the terrible prefix sums are needed to count it Since depends only on and we only need to choose the minimum the choice can be optimized by suffix minima As a result the solution works for that s how many states need to be processed 
543,Let s calculate for each number how many times it occurs in the array Let s denote this number as Let s use the dynamic programming method Let be equal to the maximum number of numbers not greater than such that for each pair of them one of the conditions above is satisfied More formally if then there exists numbers from the array such that for all one of the conditions above is satisfied Then to calculate you can use the following formula Note that to calculate you need to go through the list of divisors of For this we use the sieve of Eratosthenes 
544,Note that if one subtree is a mirror image of another then they are isomorphic that is equal without taking into account the vertex numbers To check the subtrees for isomorphism we use Now we just have to learn how to check trees for symmetry To do this let s calculate how many children of each type our vertex has let s denote the hash of its subtree by the vertex type In order for the vertex subtree to be symmetric each child must have a pair of the same type except perhaps one which must also be symmetric We can calculate the symmetry of the subtrees while counting their hash to simplify this task 
545,There is no point in using two transitions between portals because if you want to go from portal A to portal B and then from portal C to portal D then you can immediately go from portal A to portal D for less Then there are two possible paths First do not use portals Here it is enough to find the shortest path between two points The second use a single transition Let s choose a portal from which we should teleport Obviously this is a portal with a minimum distance to it and the cost of the transition Similarly the portal in which we should teleport is selected 
546,Let s calculate the shortest paths to the finish along the vertices containing bonuses We will try to reach the finish line with the chip that is closest to it and mark it If there is none we lose Other chips will give her extra moves Find all connected components from vertices containing bonuses Then for each component we find all the tokens that are not selected located at the vertex of this component and at the vertices adjacent to at least one vertex of this component Consider the size of the connectivity component If it is equal to then the chip located in the neighboring vertex gives an additional move Otherwise the chip located at the top of the component or at the neighboring vertex as well as the selected chip will be able to move indefinitely in turn which gives us a victory Otherwise you need to count the number of extra moves and compare it with the shortest distance to the finish line 
547,Suppose we have fixed the value of so we can trade an item with price for an item with price if We can see that it s never optimal to trade an item with higher price for an item with lower price and we could just simulate the trading process as follows try to find an item owned by Polycarp and a more expensive item owned by the other character which can be traded repeat until we cannot find any suitable pair Unfortunately it is too slow Instead let s try to analyze for a given value of how to verify that an item of price can be traded for an item of price maybe not right away but with intermediate trades You can build a graph of vertices representing items where two vertices representing items with prices and are connected by an edge if and only if Then the edges of the graph represent possible trades and the paths in the graph represent sequences of trades So one item can be traded for another item possibly with intermediate trades if the vertices representing the items belong to the same component For a fixed value of we can build this graph find all of its components calculate the number of Monocarp s items in each component and add this number of most expensive vertices from the component to the answer There are two problems though The first one is that the graph may have up to edges But if we sort all items according to their prices we are only interested in edges between vertices which represent adjacent items in sorted order so the size of the graph is decreased to Another problem is that there are multiple queries for different values of To handle it we can sort the values of in ascending order and go in sorted order while maintaining the graph for the current value of A data structure like DSU or a method like small to large merging can be helpful to update the components as they merge The last trick to quickly recalculate the number of items Monocarp has in a component and the sum of most expensive several items you can build two prefix sum arrays one over the array storing the costs of the items and another one over the array which stores values or depending on who owns the respective item the items should still be considered in sorted order Since each component is a segment of costs of items prefix sums allow us to calculate the required values in By the way knowing that each component is a segment we can get rid of the graph and the structure that stores it altogether and just maintain a set of segments of items representing the components 
548,I know about greedy solutions and other approaches but I ll describe my solution This is dynamic programming I ll consider all positions indexed Let be the minimal element in the decreasing sequence if the last element th was in the increasing sequence and be the maximum element in the increasing sequence if the last element th was in the decreasing sequence Initially all are and all are except two values and What about transitions Let s consider four cases The previous element was in the increasing sequence and we want to add the current element to the increasing sequence We can do if the previous element was in the increasing sequence and we want to add the current element to the decreasing sequence We can do if the previous element was in the decreasing sequence and we want to add the current element to the decreasing sequence We can do if the previous element was in the decreasing sequence and we want to add the current element to the increasing sequence We can do if The logic behind these transitions is kinda hard but understandable If and then the answer is Otherwise we can restore any possible answer using parents in the dynamic programming 
549,Our first task is to separate mines into components We will store in the hashmap at the coordinate all the coordinates where there is a mine Let s do the same with the hashmap Thus going through the available arrays in and we connect adjacent elements into one component if also with As a result we have components where if you detonate one mine in the s component then all the mines belonging to this component will also explode Further we find a mine with a minimum timer in each component Finding the minimum for each component we store it conditionally in the array Now we know at what minimum time some component will explode if it is left unaffected To answer it remains to find in the sorted array such a minimum index that is min And the general asymptotic behavior is 
550,If the answer is then we can choose a subset of the tree vertices forming a simple path and containing all the vertices of our set Let s choose the minimum possible path its ends vertices from the set The constraints allow us to answer the query in hang the tree by one of the ends and check if it is true that there is only one selected vertex that does not have any selected ones in the subtree if there is one such vertex then it is the second end To make it easier to search for one of the ends we will hang the tree by any vertex before the queries calculate their depths and take the deepest of the set 
551,Let s use the dynamic programming Let be the number of paths on the prefix of blocks of the same color To make transitions in such dynamics for the position we will iterate over the position in which the block started Denote as the number of the same elements as and between them then such a transition creates combinations This solution works in complexity 
552,Recall that the path in the rooted tree ascends from one end to the least common ancestor of the ends and descends to the other end possibly by 0 Then our set is divided into two simple ways To check this you only need to count We will first calculate the depths as for solving an easy version of the problem We will go along the vertices according to the non growth of the depths if of the deepest vertex and the current one is equal to the current one then it is the ancestor of the deepest one we will mark it Next we will find the deepest unmarked vertex and do the same if there is no such vertex then the whole path goes down and the answer is If there are unmarked vertices then there are vertices outside of those two ascents and the answer is Now we need to check that the two ascents do not intersect or intersect only at the of ends for this we just make sure that is not deeper than the shallowest vertex of the set 
553,To solve the hard version let s modify the simple version solution Note that the parameter can be discarded since we only need paths of maximum length on each prefix Now as we denote a pair of the number of maximum paths and the number of blocks in them For the position we will find the position closest to the left from which we can start a block and so we will find out what is the maximum for We will update until the maximum of the position being sorted is suitable for us 
554,Note that dishes can become equal if and only if they have equal values of that is how much fish and meat remain in them in total after tasting Let s calculate this value for each dish and group all the dishes with equal calculated values The minimum amount of fish that can remain in the th dish is in case where the maximum possible mass of fish is eaten Similarly the maximum amount of fish that can remain is in case where the maximum possible mass of meat is eaten Consider one of the groups in which there are all the dishes with equal values We sill assign each dish a corresponding segment on the coordinate line between and This segment specifies all possible values of the remaining mass of fish in the dish any value on it is achievable by replacing eating some mass of fish with the same mass of meat And since is common the same amount of remaining fish will imply the same amount of remaining meat thus equality Let us solve the problem for each group independently Within a group the problem is reduced to choosing as few points as possible that cover all the segments described in the last paragraph that is that there should be a point inside each segment Each selected point will correspond to the resulting dish and it being inside a segment will mean that such a resulting dish can be obtained from the corresponding starting one Such a problem is solved as follows we choose a segment with the minimal right end because it must contain at least one chosen point we ll greedily choose it equal to its right end there s no point in choosing a point to the left from it since it will not cover more segments than the right end of the segment in question we ll mark all segments containing this point as covered and repeat the algorithm for the next unprocessed segment with the minimal right end For this algorithm it is sufficient to sort the segments by their right ends within each group and iterate through the segments greedily selecting points in the manner described above The set of points obtained at the end will be the answer and its size and the information about the point selected within each segment should be printed in the output If for a dish a point is chosen inside its corresponding segment then there should be exactly of fish left in it that is you should output the numbers and in the answer 
555,If we did not delete the strings then the median would be equal to the binary notation of After deleting strings the median cannot change numerically by more than Let s start with the median and each time decrease it by one if there are fewer not deleted smaller numbers than not deleted large numbers Similarly you need to increase the median by one otherwise The algorithm stops when the result is the median of the current set All these steps will run at most times 
556,Let s compute an array of integers answers to all possible second type queries with Now if we have to perform any second type query we can split it into at most queries with and at most queries with Let s also compute an array of integers reverse permutation If then To perform any first type query we should recompute and We can swap and in the array and and in the array No more than elements will be changed in the array These are elements with indexes elements and elements We can recompute and then assign and times Similarly for Time complexity 
557,Firstly let s calculate the following auxiliary matrix means the maximum position that is less than or equal to and the character in order from to and so on It can be calculated naively or with some easy dynamic programming initially all are and then for each from to all values are equal to except which is After calculating this matrix we can solve the problem by the following dynamic programming let be the number of subsequences of length that ends exactly in the position Initially all values are zeros except for each from to How do we perform transitionss Let s iterate over all lengths from to then let s iterate over all positions from to in a nested loop and for the current state we can calculate it as If then we don t need to add this state of the dynamic programming to the current state Don t forget to take the minimum with after each transition This transition means that we take all subsequences that end with each possible character of the alphabet and try to add the current character to each of them You can understand that there are no overlapping subsequences in this dynamic programming After that let s iterate over all possible lengths from to and calculate the number of subsequences of the current length It equals to The same if then we don t need to add this state of the dynamic programming to Don t forget to take the minimum with If then let s add to the answer and break the cycle Otherwise let s add to the answer and decrease by If after all iterations is greater than zero then let s try to add the empty string to the answer we didn t take it into account earlier Increase the answer by and decrease by one If after this is still greater than zero then the answer is otherwise the answer is the calculated sum Time complexity 
558,You need to implement what is written in the statement You can either use an if statement for each of the characters or you can iterate through the string check if the current character equals 
559,For this problem you just need to implement what it asks you To be able to implement it you need to know about the if statement 
560,We need to check if the sum of the first three digits is equal to the sum of the last three digits This is doable by scanning the input as a string then comparing the sum of the first three characters with the sum of the last three characters using the if statement and the addition operation 
561,We can re word the problem to count the number of numbers from that are larger than A possible way to do this is by keeping a variable that gets incremented every time we checked using the if statement whether a number is larger than The complexity is 
562,Here are two ways to implement what s given in the problem Take input as an array a 1 a 2 a 3 and sort it Output the middle element Write two if statements The first if a b text and a c text or a b text and a c output a Else if b a text and b c text or b a text and b c output b Else output c 
563,You need to implement what is given in the statement for example you can use an if statement to output if and otherwise 
564,Here are two solutions Iterate through the string character by character If then otherwise if or then or If the statement is false for any the answer is Otherwise it is Replace all with since they are the same anyway Then just check if the two strings are equal In either case the complexity is per testcase 
565,You only need to write an if statement and check if any of these are true 
566,You should implement what is written in the statement Here are three ways to do it Check that the first character is or check that the second character is or and check the third character is or Make an array storing all acceptable strings there are only and loop and see if any of the strings match the input Use some built in function like in C to make the string all lowercase and check if is equal to The complexity is per test case 
567,Note that the size of the array doesn t change parity since it always decreases by Let s count the number of distinct elements call it If is the same parity as the length of the array then we can make sure all of these distinct elements stay in the array by removing two elements at a time Otherwise isn t the same parity as Then is the same parity as and we can make sure distinct elements stay in the array by removing two elements at a time So the answer is if and have the same parity and otherwise For example has So and have the same parity and we can get all distinct numbers by removing Time complexity or depending on the implementation 
568,To solve the problem we need to find the character with the highest alphabetical order in our string since Atilla will need at least that alphabet size and won t need more To do this iterate through the string and find the character with the highest alphabetical order Output the maximum alphabetical order found The solution can be done in 
569,Here are two solutions Iterate through the string character by character If then otherwise if or then or If the statement is false for any the answer is Otherwise it is Replace all with since they are the same anyway Then just check if the two strings are equal In either case the complexity is per testcase 
570,Because we can only eat candies from boxes The only way to make all boxes have the same quantity of candies in them would be to make all candies contain a number of candies equal to the minimum quantity of candies a box initially has So we should find this minimum number let s denote it as and then for each box there should be eaten candies So the answer would be the sum of over all s 
571,We can keep track of our current point as we iterate over the string if then decrement set if then increment set if then increment set if then decrement set Initially set If is ever true then we should output otherwise we output The time complexity is 
572,Let be the total number of candies with all bags with an even number of candies and the total of all bags with an odd number of candies If then the answer is because at the end Mihai who takes only even numbers of candies will have less candies than Bianca Otherwise if the answer is The construction is to simply put all even bags first and then all odd bags since all even bags come before all odd bags and at any point in time Mihai will have more candies than Bianca The time complexity is 
573,Let s keep an array of booleans denoting whether or not some team has solved the th problem already Now we can iterate through the string from left to right and keep a running total If is true the th problem has already been solved increase by otherwise increase by and set to true The time complexity is Bonus the answer is always Can you see why 
574,If there are two elements with the same value then the answer is because neither of these values is less than the other Otherwise the answer is since we can just sort the array The time complexity is or depending on the implementation 
575,Consider two cases when we choose all odd numbers and all even numbers In both cases let s try to maximize the maximum So if we choose odd numbers let s try to take ones and the remainder But we need to sure that is greater than zero and odd And in case of even numbers let s try to take twos and the remainder We also need to check that the remainder is greater than zero and even If none of these cases is true print 
576,Approach 1 Sort the array using an efficient sorting algorithm For every element check if the next two in the array are equal to it If you find such an element output it Time complexity is Approach 2 Notice that elements have an upper bound of you can use an auxiliary array to store the count of each value Go through each value and see if its count is bigger than or equal to Time complexity is 
577,Make a copy of the array s call it t Sort t in non decreasing order so that t 1 is the maximum strength and t 2 the second maximum strength Then for everyone but the best person they should compare with the best person who has strength t 1 So for all i such that s i neq t 1 we should output s i t 1 Otherwise output s i t 2 the second highest strength which is the next best person 
578,We will perform each move in reverse from the final sequence of the cypher move it increases the th digit by After applying the up move on it becomes move denoted by it decreases the th digit by After applying the down move on it becomes Now we just need to implement the two types of moves The time complexity is per test case 
579,Let s solve a harder problem given a string and a binary string can we make into using the find and replace operations We can simply iterate through each character of and see the bit it has turned to in that is for each Keep track of each change and see if there is some letter that needs to be turned into both and If there is some letter it is impossible since each operation requires changing all occurrences of a letter into the same bit Otherwise it is possible and we can directly change each letter into the bit it needs to be See the implementation for a better understanding Now for this problem since there are only two alternating binary strings of length and we can simply check both Actually we only have to check one do you see why The time complexity is 
580,Suppose the answer is just th positive integer which we should shift right by some number Each multiplier of shifts our answer by The number of such multipliers is where is divided by rounded down So the final answer is th positive integer with the required number of skipped integers multipliers of You can also use a binary search to solve this problem 
581,Firstly given any pair of strings of length we should be able to tell the difference between them It s enough to find the sum of absolute differences between each character from the same position Now we should go through all possible pairs and pick the minimum value over all of them using the function we use to calculate the difference 
582,Note is that after doing two operations of the same type they are cancelled out in terms of parity since we would change the parity of all elements once then change it back again So we know that we will do each operation exactly or time It is possible to check all possible cases just by simulating or we can notice that all elements on all indices of the same parity have the same parity and if they do we can always find an answer by doing just a single type of operation a single time in case the array doesn t already contain all elements of the same parity The time complexity is 
583,Let s perform the process in reverse we will remove the first and last character of the string if these two characters are different We should do this as long as possible since we need to find the shortest initial string So the algorithm is straightfoward keep track of the left and right characters and if they are different remove both Otherwise output the length of the current string or output if the string became empty There are a few ways to implement this For example you can keep two pointers one at the beginning of the string and one at the end say and and check if If it s true then we increment and decrement Otherwise we output We stop when Alternatively you can use deque to simulate the operations directly The time complexity is 
584,Note that if a stripe is painted last then the entire stripe appears in the final picture because no other stripe is covering it Since rows are only painted red and columns are only painted blue we can just check if any row contains 8 s If there is such a row then red was painted last otherwise blue was painted last 
585,There are many ways to solve the problem One way is to look for the following pattern There can only be one such pattern if there is one bishop and it s not on the edge of the board We can iterate through all cells and see if we can match this pattern and if we can we output the centre cell You can also look at the positions of the two diagonals and intersect them but it requires more implementation Time complexity per testcase 
586,You need to implement what is written in the statement To quickly check if a word is written by another guy you should store some or Python dictionary and increment every time you see a new string in the input Then you should iterate through each guy find the number of times their word appears and update their score The complexity is per testcase 
587,This is just an implementation problem and it can be solved in time but we didn t ask for such solutions so you could solve it in or maybe even in I ll describe solution anyway Firstly we need to maintain several variables initially the number of moves passed the position of the leftmost remaining candy initially the position of the rightmost remaining candy initially the sum of candies eaten by Alice initially the sum of candied eaten by Bob initially the sum of candies eaten by Alice during her last move initially and the sum of candies eaten by Bob during his last move initially So let s just simulate the following process while if the number of moves is even then now is Alice s move and we need to maintain the sum of candies Alice eats during this move How to calculate it While and let s eat the leftmost candy so variables will change like this After all let s add to replace with assign and increase by If the number of moves is odd then the process is the same but from the Bob s side I ll also add a simply implemented solution written by Gassa below 
588,One possible solution is to represent a range of equal element as a single element with that value Construct this array and loop through it and check how many element satisfy the conditions or and or If exactly one index satisfies these conditions print YES and othewise NO Complexity 
589,First note that parts of the picture separated by are independent That is any stamps used on one part doesn t have any impact on the other since a character means no stamp has been placed on that cell So let s split the string by s for example with method in Python and consider the resulting strings containing only and Call one of these parts In the final stamp we place on we must have placed so it should have both the characters and Therefore if the string has only or only the answer is Otherwise the answer is Let s show it As we have just shown we must have next to for the string to be possible Consider the way to make The final stamp can be For the rest of the cells we can make them one by one as below so now we have made the prefix of the string before the final stamp Similarly Now we have made the prefix and the suffix by stamping one character at a time actually we stamp two characters but then cover it up with another stamp Finally we can put the final stamp to make the whole string This method easily generalizes to any string We can find the final stamp and then make the prefix and suffix one by one The solution runs in 
590,Note that the array has at most distinct elements since For each value store the largest index it is in Then we can brute force all pairs of values and find the coprime pair with largest sum of indices The time complexity is per testcase 
591,Let s check all splitting points for all We denote a splitting point as the last index of the first string we take and all the remaining characters will go to the second string We need to keep a dynamic count of the number of distinct characters in both strings the first string and the second string We can do this using two frequency arrays and adding one to the distinct count of either string or when the frequency of a character is greater than zero 
592,Use some data structure that allows you to answer queries of the form does the string appear in the array For example in C you can use a while in Python you can use a dictionary Afterwards for each string brute force all strings and such that There are at most such strings because has length at most Then check if both and appear in the array using your data structure The time complexity is per test case where is the maximum length of an input string 
593,For each person let s calculate how much the value will change if they turn around For example in the line if the th person turns around then the value of the line will change by respectively For instance if the second person turns around they see people before and person after so the value of the line changes by if they turn around Now note that if a person turns around it doesn t affect anyone else s value So the solution is a greedy one let s sort the array of values in increasing order Afterwards we should go from the left to the right and see if the value will increase if this person turns around if it does we should add it to the current total and continue The time complexity of this solution is per testcase 
594,Note that for each question the resulting array is So the sum of the elements of the new array after each question is We can compute and in time by precomputing the sum of all prefixes and suffixes or alternatively by using the prefix sums technique So we can find the sum each time in per question and just check if it s odd or not The time complexity is 
595,Note that Victor looks at the clock forever but there are only at most different times the clock can show because there are different minutes in a day So we only have to check the first times Victor sees and count the palindromes you can check a few more just to be safe but they will repeat anyways Now we just have to implementing adding minutes to a clock There are several ways to do this One of the slower ways might be writing functions converting a number of minutes into a time for a clock or you can just compute all palindrome times in terms of minutes and that way you don t have to convert from clock time to number of minutes The complexity is per test case since you only have to check a constant number of times 
596,The solution is to check the sum over all diagonals for each cell For a cell we can iterate over all elements in all its diagonals This will be in total elements The complexity will be solutions involving precomputation are also possible but aren t needed 
597,One solution is to go through all given strings generate all strings that differ in exactly one position and count the number of times these strings occur in the array A possible way to count them is by using either the map dictionary data structure or even simpler a frequency array Depending on the implementation you may need to divide the answer by because of overcounting pairs The solution runs in or depending on the implementation 
598,Note that the remaining array is a subarray of the original array There are many ways to approach the problem Here is one solution which the main solution uses Compute prefix sums on the array so we can find out the value of quickly Let s iterate through the left endpoint from to Afterwards we can binary search on the smallest value of such that since this sum is strictly increasing The time complexity is 
599,Let s find out how to count the number of binary inversions without flips This is the number of 1 s that appear before a 0 To do this iterate through the array and keep a running total k of the number of 1 s seen so far When we see a 0 increase the total inversion count by k since this 0 makes k inversions one for each of the 1 s before it Now let s see how to maximize the inversions Consider the flip 0 to 1 We claim that it is best to always flip the earliest 0 in the array It s never optimal to flip a later 0 since we have strictly fewer 0 s after it to form inversions Similarly we should flip the latest 1 in the array Now recalculate the answer for these two choices for flipping and pick the maximum The complexity is mathcal O n 
600,Consider the 2D array with for all Increase by if there is an rectangle in the input Now for each query we need to find the sum of all in a rectangle with lower left corner at and upper right corner at This is the standard problem that can be solved with 2D prefix sums The time complexity is per testcase 
601,Let s solve the problem with just one query Greedily we should pick the candies with the most sugar first since there is no benefit to picking a candy with less sugar So the solution is as follows sort the candies in descending order and then find the prefix whose sum is This is per query which is too slow for us To speed it up notice that we just need to find a prefix sum at least So if we compute the prefix sums of the reverse sorted array we need to find the first element that is at least Since all elements of are positive the array of prefix sums is increasing Therefore you can binary search the first element This solves the problem in per query Total time complexity 
602,Let s rotate the grid by and and mark all cells that map to each other under these rotations For example for and grids mirror grid must have the following patterns the same letters denoting equal values In general we can rotate the grid by and and see which cells need to have equal values by seeing the positions which each cell maps to Now to solve the problem we consider each equal value each of the letters in the above figures independently and consider the minimum number of moves to make them all or all The answer is the total across all values See the implementation for better understanding The time complexity is per testcase 
603,We can notice that by performing any number of operations the parity of the count of negative numbers won t ever change Thus if the number of negative numbers is initially even we can make it equal to by performing some operations So for an even count of negative numbers the answer is the sum of the absolute values of all numbers since we can make all of them positive And if the count of negative numbers is odd we must have one negative number at the end We will choose the one smallest by absolute value and keep the rest positive for simplicity we consider as a negative number 
604,Let s compute the prefix sums of the array let Rephrasing the problem for each question containing an integer we need to find the largest such that are all at most and then output In other words Let s make the prefix maximums of the array let Then we need to find the largest such that which is doable using binary search since the array is non decreasing Once we find the index we simply need to output The time complexity is per testcase 
605,The intended solution for this problem uses time and memory Firstly let s calculate for each from to where is the number of occurrences of in This part can be done in Then let s iterate over all segments of of length at least maintaining the sum of the current segment We can notice that we don t need sums greater than because all elements do not exceed So if the current sum does not exceed then add to the answer and set to prevent counting the same elements several times This part can be done in 
606,Since we only care about the last digit of the sum we can ignore all numbers other than the last digits of the elements of For example we can consider to be the same as Now note that if a number appears more than times in the array we can ignore all copies that occur more than times since our sum only involves three numbers For example we can consider to be the same as Using these observations note that there are only digits and each digit can occur at most times So we can always reduce the array to one of length Since is very small we can brute force all triples which runs quickly enough Time complexity 
607,Consider case separately and print the sting of zeros or ones correspondingly Now our string has at least one pair or Let s form the pattern of length So all substrings with the sum are satisfied Now let s insert zeros before the first zero in this way we satisfy the substrings with the sum And then just insert ones before the first one in this way we satisfy the substrings with the sum 
608,We can see that there are at most states the ball can be in because there are cells and states of direction We can simulate the bouncing process keeping count of the bounces until we arrive at the finish cell when we can output the answer or we arrive at a previously visited state and end up in a loop then we can output 1 Bonus Can you prove there are at most states for any given starting position 
609,We can solve the problem with a two pointers technique Let be the left pointer initially at and be the right pointer initially at Let s store Alice and Bob s current totals as and Let s iterate from the left to the right For each we should do the following Increase by Alice eats the th candy Move leftwards until Bob s total is at least Alice s total and update every time we move If the two pointers have crossed then both Alice and Bob took the same candy which is not possible So we should exit and output the current answer Otherwise if after this step we should update the current answer to be the value that is equal to Alice and Bob Both and move at most times in total so the solution runs in 
610,The problem is mainly a tricky implementation problem Let s denote the of an L shape as the square in the middle the one that is side adjacent to two other squares Every elbow is part of exactly one L shape and every L shape has exactly one elbow Iterate through the grid and count the number of side adjacent neighbors they have If there is a cell with more than 2 or if there is a cell with exactly two neighbors on opposite sides then the answer is Otherwise if there are exactly 2 neighbors this cell is an elbow Mark all three cells of this L shape with a unique number say mark the first one you find with the second with and so on If you ever remark a cell that already has a number then two elbows are adjacent and you can output After all elbows are marked check if all shaded cells have a number If some don t then they are not part of an L shape so you can output Finally we should check that L shapes don t share edge or corner Just check for each number if it is only diagonally adjacent to other numbers equal to it or unshaded cells If it is diagonally adjacent to other unequal numbers then the answer is because two L shapes share an edge or corner then Otherwise the answer is There are many other solutions all of which are various ways to check the conditions The complexity is per testcase 
611,Let s call a value if it appears at least times For example if and then good values are So we need to find the longest subarray of this array in which all values are consecutive For example the subarray is the answer because all values are good and the length of the array is longest There are many ways to do this For example we can see when the difference between two elements is more than and then break the array into parts based on that For instance You can also iterate from left to right and keep track of the size of the current array Time complexity 
612,Let s fix k and find the maximum number of coins we can get Here we can do a greedy solution at every step we should always take the most rewarding quest Intuitively it makes sense since doing more rewarding quests earlier allows us to do them again later If no quests are available we do nothing To implement this sort the quests in decreasing order and 0 index them On day i we should do quest i bmod k provided that this value is less than n This is because after every k days we cycle back to the first quest Thus we solved the problem for a fixed k in mathcal O d with mathcal O n log n precomputation to sort the array Now to solve the problem we can binary search on the answer since if some k works then all smaller k work The minimum value of k is 0 and the maximum value is n for larger k we won t be able to do the same quest multiple times anyways so it s useless to consider them If we find that k always goes towards the smaller end of our binary search and k 0 still fails we output If we find that k always goes towards the larger end of our binary search and k n still fails we output Otherwise just output k The overall time complexity is mathcal O n log n d log n It is not hard to improve the solution to mathcal O n log n Originally I proposed the problem this way but we ended up removing this part of the problem because the implementation of this solution was tricky enough 
613,Let denote the sum of the digits of The key observation is the following after the operation is applied to index thrice it won t change after any further operations The proof is provided at the bottom of the editorial So we only need to update if it s been updated at most times so far otherwise we can ignore it This allows us to do the following solution store the current active indices that is indices that have been updated times in a sorted list for example in C Then search for the smallest active index at least since the list is sorted we can do it in Afterwards update that index replace with remove it if it s no longer active and binary search for the next largest active index in the sorted list until we pass just output Although it looks like we take time for each update we actually only ever update each element of the array at most times so we will do no more than binary searches Therefore the time complexity is amortized To show this note that initially The maximum possible value of the sum of the digits of is achieved when So Now considering the numbers from to the one with maximum sum of digits is with Hence Finally considering the numbers from to the one with maximum sum of digits is so That is after three operations becomes a single digit Any further operations and it won t change any more 
614,First of all let s think about how we should rearrange the two strings in such a way that if that is ever possible It s always optimal to arrange s characters increasingly in lexicographic order and s characters decreasingly Since initially both and contain a character the first time receives any other letter than the answer will always be because that character will always be lexicographically larger than s first character which should be In the other case we know that doesn t have any other characters than so we can compare the string with multiple characters and we know that will be smaller if and only if it s only formed of s and has a smaller size than 
615,Call a pair if it satisfies the condition Let s split the inequality into three parts Note that if for any then it can t be an element of a good pair because it fails the first and third conditions So we can throw out all elements of the array satisfying For the remaining elements the first and third inequalities are already satisfied so we only have to count the number of pairs with Let s iterate through the array from the left to the right and make a list storing all that appear before Then for each count the number of less than by binary searching on the number of elements in the list less than Afterwards add to the end of the list Since we iterate from left to right the list will always remain sorted we insert the indices of elements which are increasing from left to right so the binary search will always work The time complexity is 
616,Note that is the same as since we can divide by This means that we only need to check whether for each pair of adjacent elements Let s consider as an example Note that and so if you multiply the first element by the second by and the third by the array is sorted So let s make a new array where if and otherwise Then we know that the whole chain of inequalities holds true if all values in a subarray of length in have all their values equal to For example if Say Then works since is sorted We can write this as and This is equivalent to since and since So the problem is equivalent to counting the number of subarrays of length in whose elements are all equal to There are many ways to do this For example you can compute prefix sums and then find the sum of all subarrays of length and count the number whose sum is The model solution uses a sliding window and updates the number of ones in the current subarray as we move from left to right Time complexity is 
617,There are a lot of solutions to this problem Here I will describe one of them First we observe that having the XOR of even indexed numbers and odd indexed numbers equal is equivalent to having the XOR of all the elements equal to 0 Let s note with the XOR of all odd indexed numbers and the xor of all even indexed numbers Notice that the XOR of all the array equals if and only if a b So how do we generate such an array with XOR of all elements Our first instinct might be to arbitrarily generate the first numbers then set the last element as the XOR of the first ensuring that the total XOR is However we might have problems with the condition that all elements must be distinct Let s arbitrarily set the first so that they don t have the highest bit set and then the th number can be just The last number can be the XOR of the first XOR the th number you will be sure that the last number has not occurred in the first elements because they don t have the highest bit set while the last number must have the highest bit set But how do we know that the th number and the th number will not be equal This occurs only if the total XOR of the first numbers equals To fix this we can just choose a different arbitrary number in one of the spots For example my solution checks if the XOR of the numbers is If it is not great We can use the simple solution without any changes However if the XOR is I use the numbers in their place These two sequences have different XORs so it ensures that one of them always works 
618,Note that the columns don t affect each other so we can solve for each column by itself For each column go from the bottom to the top and keep track of the row of the last obstacle seen call it Note that initially since we treat the floor as the th row of obstacles Whenever we see a new obstacle we should update Now if we ever see a stone we should move it to row since it will be one row above the last obstacle seen it will fall on top of it Afterwards we should also decrease by because if any future stones fall on top of it they will land on the row above this stone This solution works in We also accepted slower solutions that run in that simulate each stone falling 
619,We will prove it is always optimal to use good keys for a prefix then only use bad keys Consider we have used a bad key then a good key by doing this we obtain coins If we switch and use a good key first the a bad key then we obtain this number is clearly bigger so we will never encounter a bad key before a good key in an optimal solution thus we will use a prefix of good keys then move on to using bad keys For every possible prefix of good keys we will calculate the coins we get at the end We do this by maintaining a variable with the prefix sum where we use the good keys and then calculate what we will get from the chests where we use bad keys Notice that because we halve all the chests when we use a bad key we only need to verify the next chests all chests after it will go to coins Final complexity 
620,Note that in this context denotes We can make the observation that only the first elements matter since after placing them optimally we can be sure all bits that could be set in the prefix OR would have already been set So we can brute force the optimal choice times we choose to add an element if it provides the largest new prefix OR value among all unused elements and then just add the rest of the unused elements 
621,Let s ignore the teleporting and decide how to find the answer Note that we don t need to ever go over an edge more than once since going over an edge twice cancels out since for all In other words the only possible value of equals the of the edges on the unique path from to We can find it through a BFS from continuing to keep track of s as we move to each adjacent node and ing it by the weight of the corresponding edge as we travel across it Now let s include the teleport It means that we travel from then teleport to and go from for some nodes and Also we cannot pass on the path from Again note that the value of is fixed on each of the paths from and since there is a unique path between them Let be the of the first path and be the of the second Then we need So we need to find if there are two nodes such that the s from and to those nodes are the same To do this we can do our BFS from before but instead run one BFS from and another from and check if any two values are the same Make sure not to include nodes past while we look for on our BFS from The time complexity is 
622,If then there is no answer You can do some handwork to be sure Otherwise the answer exists and there is one simple way to construct it firstly let s put all odd integers into the answer in decreasing order then put and all other even numbers in increasing order To test that it always works you can run some kind of checker locally you can check all tests very fast in less than one second this may be very helpful sometimes 
623,Let s run a dynamic programming from the leaves to the root For each vertex store the values of the number of balanced subtrees as well as the number of white and black vertices in it Then from a vertex we can count the total number of white vertices in its subtree as well as the black vertices in its subtree and update our total if they are equal Remember to include the color of the vertex itself in these counts The answer is the answer at the root Therefore the problem is solved in time 
624,Firstly let s note that it doesn t matter in what order we add the elements to the array since if we can add an element in any position if it s possible to get the said elements of the array then we can obtain them in any order Now let s note that it s always optimal to obtain the needed elements in sorted order since we only use smaller values in order to obtain the current one so we will consider the array as sorted If the first element of the array isn t then we immediately know such an array doesn t exist Otherwise we can use dynamic programming for finding out if the remaining elements are obtainable Let s denote a boolean array which tells us whether sum is obtainable Initially since the first element is guaranteed to be We will go in increasing order of and if we calculated an element to be obtainable in the past we update all obtainable values with the new value We do this in by going through all sums and updating is true if it already was true or if was true and we add to that sum the new value The total time complexity of this solution is 
625,It s easy to see that it s optimal to only move right or to use a portal once we are at it We can notice that when we teleport back the problem is independent of the previous choices We still are at point and have some portals left Thus we can just find out the individual cost of each portal sort portals by individual costs and take them from smallest to largest by cost as long as we can The cost of portal is since we pay to use it and need moves to get to it 
626,Let s prove that for an array that was created by using a number of operations with a sum of elements we can add into any number Suppose that it is true that in the array with some length we introduce a number Then after introducing we can create using the initial elements of the array any number and using the element and some subset of the initial elements we can create any number and because we proved that for the new array of length we can still create any number between and Since it is true for the initial array we can use induction and this fact to prove it is true for all arrays So we just need to verify if our array satisfies this condition We should sort the array and check for each if 
627,Please also refer to the tutorial for the easy version If we are not at the first taken portal the problem is still independent for each portal but this time the cost of a portal is since we can come to a portal either from point or point So we again sort the portals by their costs But this time we need to make sure that the first taken portal is taken from point so we will iterate over all portals and check the maximum amount of portals we can take if we use it as the first one We can check this using prefix sums over the minimum cost array and binary searching checking if the amount of considered portals taken doesn t exceed the number of coins we initially have we also have to deal with the case when the portal we are considering is included both times as the initial portal and in the minimum cost prefix 
628,There are several solutions Here is one If we fix the value of then let s make a new array as follows if and otherwise Then the total amount of money earned will just be so we only need to maximize In other words we need to find the maximum sum of a subarray This is a standard problem that can be solved using segment tree Note that we need to iterate over all values of of which there are possibilities So we have to update elements of the segment tree times and query once for each which means overall the solution runs in 
629,The optimal strategy is to greedily take the highest bit we have enough operations to set in every array element To do this we maintain a count for each bit with the number of elements that have it set already The cost to set the th bit will be We go from the highest bit to the lowest If we have enough operations left we set the bit subtract its cost from the operations and move to the next lower bit If we don t have enough operations we move on to the next lower bit and don t modify the operations We stop once we processed bit The time complexity is 
630,Let s look at two wires from and If there can never be any intersection If there has to be an intersection If it is possible that there is an intersection or not depending on how we arrange the wires on the bottom terminal In the last case if there are multiple wires that go to the same segment we can make all pairs of them cross by arranging the points in which they hit this segment from right to left For example if then we can make all pairs of segments cross as shown Since we want to maximize the number of intersections we just need to count the number of pairs such that You can brute force all pairs in 
631,Read the solution of the easy version We want to count the number of pairs such that and This is a standard problem and we can do this we can use a segment tree or BIT for example Insert the from to and then for each count the number of using a BIT It is also related to the problem of counting inversions so you can solve it using a modification of merge sort Either way the solution is 
632,If the answer is we can t get so we can move by to the right and by to the left If or the answer is obviously Otherwise the answer is always We can t get the answer less than this value because we need at least moves to get to the point greater than or equal to and we can always get this answer by the recurrence 
633,It s obvious that we don t need elements that are larger than If the sum of the remaining elements is greater than or equal to 2048 then the answer is and otherwise It s true because for getting a integer that wasn t in the multiset initially we first need to get integer 
634,Let s look at the first and the last characters of Note that if where then is always equal to It can be proved for example by induction if consists of equal characters then if has a structure like or then Otherwise there is at least one character in the middle that equal to and So we can split string in and Both these string has by induction so our string also has As a result if then the answer is and we print the string untouched Otherwise we replace either or and get the desired string It also can be proved that if then 
635,There are two key observations First a regular bracket sequence always starts with an opening bracket and ends with a closing one Thus the first letter of corresponds to an opening bracket and the last letter corresponds to a closing bracket If they are the same then the answer is Second a regular bracket sequence has exactly opening and closing brackets Thus we can check if the counts of the remaining letter and the first letter of the string or the remaining letter and the last letter of the string make it in total If neither of them do then the answer is If both do then that means that there are occurrences of the remaining letter so it doesn t matter what bracket it is assigned to Finally after the assignment is complete check if the resulting string is a regular bracket sequence For that you have to check if on any prefix the number of opening brackets is greater or equal to the number of closing brackets And also if the total number of opening and closing brackets is the same Overall complexity per testcase 
636,Let s handle some cases Firstly if then Polycarp wakes up rested enough immediately so is the answer Otherwise what does Polycarp do He sets alarm to go off in minutes and falls asleep in minutes Thus he spends minutes sleeping Notice that if is non positive then Polycarp always resets his alarm without sleeping So for that case the answer is Finally if Polycarp resets his alarm times then he ends up with minutes of sleep in total and ends up spending minutes of time We know that should be greater or equal to and should be the smallest possible Thus the smallest possible integer is equal to And the answer is Overall complexity per testcase 
637,If for some hero no other hero is weaker than then the th hero cannot win any fights and is not a possible winner Otherwise the hero is a possible winner he may fight the weakest hero times and be declared the winner So the solution to the problem is calculating the number of minimum elements in the array since all other elements denote possible winners of the tournament 
638,Let s look at our arrays and Note that for any position such that we can always fix it by swapping positions from to In that case contribution from all won t change contribution of pair will decrease and contribution from all won t change again since we swapped all of them It means that we already can use the following algorithm while exists such that just swap all from to This solution works for per test that should be enough But we can optimize our approach by realizing that we can instead of searching each time just go from to and fix pairs one by one if then swap with next if then swap with and so on In such way solution works in 
639,The triangle with side is degenerate if So we have to maximize the length of the longest side and minimize the total length of other sides Thus if then we answer if otherwise the answer is 
640,Any non empty balanced string contains at least one letter and at least one letter That implies that there s an adjacent to a somewhere in that string Both strings and are balanced Thus any balanced string contains a balanced substring of length So the solution is to check all pairs of adjacent letters If there exists a pair of different ones print it Overall complexity per testcase 
641,There are many different ways to solve this problem The easiest one in my opinion is to iterate on the number of jokers the winner has let it be and the number of jokers the runner up has let it be Then the following conditions should be met the winner doesn t have less jokers than the runner up the number of jokers in the winner s hand does not exceed the number of cards in his hand the number of jokers for these two players does not exceed the total number of jokers it is possible to redistribute remaining jokers among other players so that they have at most jokers Iterating on and then checking these constraints gives us a solution It is possible to get a constant time solution using some greedy assumptions and math the first player should get as many jokers as possible while the remaining jokers should be evenly distributed among other players 
642,There is a property of arithmetic mean and the equality holds when Obviously we can always gain maximum arithmetic mean equal to by taking single maximum element from Considering the property above we need to take only maximum elements in our subsegment that s why we need to find the longest subsegment consisting only of maximum elements 
643,Let s decode the number digit by digit starting from the leftmost When you meet in the string increase the value of the current digit For print current digit and proceed to the next one Don t forget to print the last digit when the string is over Overall complexity 
644,Let s read the book greedily On th day Luba will read for seconds Subtract value for each day from until becomes less or equal to zero That will be the day Luba finishes the book Overall complexity 
645,If a key malfunctions each sequence of presses of this key gives a string with even number of characters So if there is a substring consisting of odd number of equal characters such that it cannot be extended to the left or to the right without adding other characters then it could not be produced by presses of button if was malfunctioning The only thing that s left is to find all maximal by inclusion substrings consisting of the same character 
646,Consider the time interval when Simion will be on the road strictly between cities Let s iterate over the oncoming buses Let be the time interval when the oncoming bus will be strictly between two cities If the intersection of that intervals is not empty than Simion will count that bus 
647,You need additional sticks to get torches sticks for units of coal and also sticks required to craft torches and you get sticks per one trade To buy this number of sticks you need trades And also you need additional trades to turn some sticks into coals And the final answer is 
648,This task is about pure implementation Maintain the number of current spectator and check if he doesn t win With knowledge of current winner and current spectator you can easily get the third player by formula just the sum of all numbers without the known ones Overall complexity 
649,Firstly let s sort our array pay the attention that there are elements in this array not Then for 0 indexed array answer will be equal to where is an absolute value of difference between and 
650,Let s sort the input array in non decreasing order Now we should take the first players to the first team and the last players to the second team That will guarantee that every member of the first team has greater or equal rating than every member of the second team Now the only thing left is to check if all ratings in the first teams differ from all the ratings in the second team if some are equal then in sorted order 
651,Since it is better to do exactly chores in time And since we need to minimize total time we need to spend it s better to speed up the longest chores So the answer is 
652,Note that we should insert some number between any adjacent not co prime elements On other hand we always can insert the number 
653,At first let s remove all coinciding entries of both lists The most convinient way is to use map hashmap but it s not the only option Now divide entries into categories by their length You can notice that it takes exactly one second to remove an entry in each category to make it equal to an entry of the opposing list Thus the answer is Overall complexity or 
654,Note that 2 coins with denomination k can be replaced with k coins with denomination 2 So if the answer exists then there is also such a set of coins where there is no more than one coin with denomination k Therefore it is enough to iterate through the number of coins with denomination k from 0 to 1 and check that the remaining number is non negative and even i e it can be represented as some number of coins with denomination 2 
655,Let s prove that the color with the maximum value of is one of the possible answers Let the color have the maximum value of if there are several such colors choose any of them Let s keep taking the balls of two different colors out of the bag without touching the balls of color for as long as possible After such operations two cases exist In one case only balls of color are left then everything is fine In other case there are balls of color and some color let be the remaining number of balls of this color Since initially was one of the maximums However the number of remaining balls is odd which means and Therefore we can keep taking the balls of colors and until only balls of color are left 
656,Notice that you need to check just two numbers the closest one less or equal to and the closest one greater than Distances to them are and respectively Now you should multiply the first result by the second result by and compare the products Overall complexity 
657,Note that solutions in Java with BigInteger class or input function in Python2 will fail in this problem The reason is the next standard objects stores numbers not in decimal system and need a lot of time to convert numbers from decimal system Actually they are working in where is the legth of the number To solve this problem you should simply read the numbers to strings and add leading zeroes to the shorter one until the numbers will be of the same length After that you should simply compare them alphabetically 
658,At first glance it seems like a graph problem And indeed this problem can be solved by explicitly building a graph considering cells as the vertices and checking that there is a safe path from start to finish via DFS BFS DSU any other graph algorithm or data structure you know But there s a much simpler solution Since there are only two rows in a matrix it s possible to move from any cell in the column to any cell in column if they are both safe of course It means that as long as there is at least one safe cell in each column it is possible to reach any column of the matrix and the cell as well It s easy to see that if this condition is not met there exists a column with two unsafe cells and this also means that this column and columns to the right of it are unreachable So the problem is reduced to checking if there is a column without any unsafe cells To implement this you can read both rows of the matrix as strings let these strings be and and check that there is a position such that both and are equal to 
659,First the condition about being able to construct a rectangle is the same as having two pairs of sticks of equal length Let s fix the stick that we are going to break into two parts Now there are two cases The remaining two sticks can be the same In that case you can break the chosen stick into equal parts to make the second equal pair of sticks Note however that the stick should have an even length because otherwise the length of the resulting parts won t be integer The remaining two sticks can be different In that case the chosen stick should have the length equal to their total length because the only way to make two pairs of equal sticks is to produce the same two sticks as the remaining ones Overall complexity per testcase 
660,First note that is always less than or equal to If there were at least rooks on the board at least two of them would share a row or a column by pigeonhole principle If then there is always at least one free row and at least one free column You can move any rook into that row or column Otherwise all rows and columns are taken so any move will make two rooks share a row or a column which is prohibited Thus if then it s Otherwise it s Overall complexity per testcase Alternatively you could check every rook and every possible move Overall complexity per testcase 
661,Let and be number of free points that we invest in the strength and intelligence respectively It s obvious that since we must spend all free points From the other side we must make Now we can expess and put it in the inequality Since must be non negative we can get We can use or write the correct ceiling function that works with negative numerator or use one hack and magic and get with usual integer division Let s denote this value as Since all integer values from are good for us so the number of pairs is equal to P S Let me explain how to prove that is equal to P P S Interesting fact the formula above works for all positive and thats why it works in our case even though can be negative 
662,The statement literally asks for the longest subsequence which looks like Let s find out how many zeroes will be in this sequence and then take all ones which come after the last zero On each step take the next zero from the beginning of the sequence and count ones after it Update answer with the maximum value You can precalc number of ones on suffix with partial sums but it was not necessary in this task Overall complexity naively or with partial sums 
663,The line we draw must go through a triangle s vertex otherwise two sides of the triangle are split and one of the resulting parts becomes a quadrilateral So we need to check if it is possible to make a horizontal or vertical cut through a vertex A horizontal cut is possible if all y coordinates are different we can draw it through a vertex with the median y coordinate a vertical cut is possible if all x coordinates are different we can draw it through a vertex with the median x coordinate So all we need to check is the following pair of conditions all x i are different all y i are different 
664,At first let s note that if is integer and and are non negative then So instead of looking at we can consider It s easier since the function is more common function and it can be proven that it s concave upward It means that this function has a unique minimum and moreover we can calculate it has minimum value in and Since the ceiling function is monotonically increasing so we can assume that for all So we can just iterate from to and check the unequation The total complexity is equal to There is a simple optimization because of the monotone ceiling we can prove that we need to check only and 
665,In this problem all we need is to maintain the variable which will represent the number of names written on the current page Initially this number equals zero The answer for the th day equals This value represents the number of full pages we will write during the th day After the answering we need to set where operation is taking modulo 
666,Solution is just some implementation simulate algorithm given in the legend maintaining maximum over all on prefix and breaking when the maximum becomes smaller than index of the next page 
667,Let s iterate over all characters of the string from left to right excluding last character Suppose is a position of the current element of the string If increase answer by and increase by else just increase by 
668,It is enough to print for each query where is divided by rounded down 
669,Since we just want to make two numbers such that the first number is smaller than the second our best bet is to use only the first digit for the first number and the rest of the digits for the second number Note that since the numbers can have up to 300 digits we shouldn t actually evaluate the second number Instead since the digits only include 1 through 9 we can handle that case by checking the number of digits Code 49002957 
670,Let be the number of students with diplomas and students with certificates is always So the total number of winners is It should not exceed so the maximum value for will be hit in where is Overall complexity 
671,First of all we don t need to use any digits other than and If we use any other digit it consists of or more segments so it can be replaced by two s and the number will become greater For the same reason we don t need to use more than one if we have two we can replace them with three s Obviously it is always optimal to place before So our number is either a sequence of s or a and a sequence of s We should use only if is odd because if is even it will decrease the number of digits in the result 
672,There is a solution in but in fact a solution that checks all points with coordinate from to and coordinate from to is fast enough There s no need to check any other points since implies that point is on one of the shortest paths between and 
673,A lot of different solutions can be written in this problem The model solution relies on the fact that every th integer is divisible by and it means that there is always a way to change the last digit of or leave it unchanged so that the result is divisible by So if is already divisible by we just print it otherwise we change its last digit using some formulas or iteration on its value from to 
674,Notice that the string of two distinct letter is already diverse That implies that the answer is if and only if all the letters in the string are the same Otherwise you can check all pairs of adjacent letters in Overall complexity 
675,Since all planks have length at least 1 so we can take any n 2 planks as steps So all we need is to maximize the length of base planks We can take the first and second maximum as base then the answer is minimum among second maximum 1 and n 2 
676,We can prove that if we have white cells on the board then we can place any white dominoes as long as The proof is the following if let s place one domino at position otherwise let s place domino at position Then we can solve the placement of dominoes in cells in the first row and cells of the second row recursively or analogically and At the end either all dominoes are placed or and If or then since then or we successfully placed all dominoes If and then we possibly need to place one domino more and we can place it vertically We can prove that we can place any dominoes as long as in the same manner As a result all we need to check is that and 
677,At first notice that if there exists a value for the second shop then the value divisible by also exists For any you can round it up to the nearest multiple of That won t change the price for the second shop and only increase the price for the first shop You can also guess that if there exists a value for the first shop then the value with modulo also exists exactly donut on top of some number of full boxes Following the same logic the second shop needs an entire new box and the first shop needs only an extra donut So let s take a look at the smallest values of two kinds this value is valid for the second shop if one box is cheaper than donuts in the first shop Otherwise no matter how many boxes will you take they will never be cheaper than the corresponding number of donuts this value is valid for the first shop if one donut is cheaper than one box in the second shop Apply the same idea otherwise no value for the first shop is valid Overall complexity per testcase 
678,The necessary and sufficient condition is the following for each color the key should appear before the door Necessary is easy to show if there is a key after a door this door can t be opened Sufficient can be shown the following way If there are no closed doors left the knight has reached the princess Otherwise consider the first door the knight encounters He has a key for this door so he opens it We remove both the key and the door from the string and proceed to the case with one less door Overall complexity 
679,Note that for every shots we deal a total of units of damage Since we want to kill all the monsters with a shot which index is divisible by let s denote the number of shots as In this case a total of units of damage must be dealt hence if the result of the division is not an integer then there is no answer Since each monster will receive at least units of damage with shots the health of each monster must be at least If the two conditions described above are met then the remaining shots can always be distributed in the desired way 
680,Let s look at a group of it s easy to see that each such a group is equal to the same number Now let s look at how these groups are distributed on the circle If there are no then all are just equal to each other It s okay If there is exactly one then from one side all of them are still in one group so they should be equal but from the other side one pair should have different values It s contradiction If there are more than one then all numbers are divided in several groups with different values It s okay As a result array exists as long as the number of isn t 
681,Let s consider a very special case of equal distances What if all distances were equal to It implies that if some letter appears exactly twice both occurrences are placed right next to each other That construction can be achieved if you sort the string for example first right down all letters a then all letters b and so on If a letter appears multiple times all its occurrences will be next to each other just as we wanted Overall complexity or per testcase 
682,Let s find the first and the last position of characters denote them as and respectively Since the can t delete characters all characters between and will remain So we have to delete all characters between and 
683,This is a technical problem You should do exactly what is written in problem statement 
684,There are many ways to solve this problem The most naive one iterating through all numbers from to in each test case and checking if they are extremely round fails since it is but you can optimize it by noticing that extremely round numbers are rare So for example we can iterate through all numbers from to once remember which ones are extremely round store them into an array and while answering the test case only check the numbers from the array we have created There is also a solution in per test case with a formula try to invent it yourself 
685,It is easier to determine the case when the players with the maximum skills will not meet in the finals It means that they met in the semifinals and in the other semifinals both players are weaker It s easy to check this case with the following formula or 
686,In this problem you should simply check the conditions from the problem statement 
687,Print and Firstly the smallest value of you can have is and if any greater value fits then fits as well Secondly the absolute difference between and increases when you increase thus lessening the possibility of both numbers fitting into the range Overall complexity 
688,The maximum sum we can construct with elements is so we need at least elements to construct the sum equal to Let s show how to express with exactly elements Let By taking we achieve a sum of using elements is not less than and not greater than since and Thus we can just add to our array and the sum becomes exactly So the solution is to find the minimum such that 
689,It s always optimal to divide by whenever it s possible since dividing by equivalent to decreasing by The only problem is that it s too slow to just subtract from each time since in the worst case we can make operations Consider case and But if we d look closer then we can just replace times of subtract with one subtraction of And to make is divisible by we should make subtractions 
690,It is easy to see that the area of the plot is the sum of areas of all triangles in this plot Each move increases area by one We cannot obtain the answer less than but we always can obtain such an answer 
691,Let s consider three cases in this case the caterpillar will get the apple on the same day so the answer is The first condition is false and in this case the caterpillar will never get the apple because it can t do that on the first day and after each night it will be lower than one day before If the first two conditions are false easy to see that the answer equals to 
692,Let s keep the variable which will represent the number of games Maxim buy Initially Assume that arrays and are 0 indexed Then let s iterate over all and if and make So will be the answer after this cycle 
693,Let the maximum card among all cards be If only one player has a card of value of then he she can win by playing it on the first turn or on the second turn the opponent won t be able to respond with any of their cards Otherwise if both players have a card with value the player who plays this card earlier wins the game So in this case the winner is the player who makes the first turn 
694,The first spell looks pretty weak compared to the second spell Feels like you almost always replace one with another Let s show that you can totally avoid casting the spell of the first type twice or more on one monster Let the two first spell casts be and for some monsters and You can replace them by a cast of the second spell on and a cast of the first spell on That would deal even more damage to and the same amount to and The number of casts doesn t change Thus it only makes sense to use the first spell on monsters with health Calculate the number of them kill the full pairs of them with the first spell and use the second spell on the remaining monsters Overall complexity per testcase 
695,In this problem we just need to find maximum divisor of that belongs to array Let s call it Then we need to print 
696,Note that there are only a few configuration classes and Let s discuss each of them If all bulbs are of the same color then it is impossible to turn all the bulbs on because after you switch one light bulb it is impossible to turn the others on If there is a color with bulbs then it is impossible to turn all the bulbs on in operations which means there is a bulb that turns on turns off and then turns on again i e the answer is at least operations And there is a sequence of exactly operations such an example was shown in the problem notes For configurations like and it is enough to turn on the color bulbs not in a row i e in order for the first case and for the second one So the answer for such configurations is If all the bulbs are of different colors then nothing prevents you from turning them all on in operations 
697,Consider the process from the end The last buyer will always buy a half of an apple and get a half for free so the last string always is halfplus After that each buyer increases the number of apples twice and also maybe by one So we simply have the binary presentation of the number of apples from the end To calculate the answer we should simply restore that value from the end and also calculate the total money grandma should have 
698,If there is no grass on the field the answer is If the whole field is filled with grass the answer is because there always will be one cell that we can t clear with one move Otherwise the answer is This is because if the cell is empty we can just choose other row than and other column than and clear three other cells in one move 
699,Let s denote the number of sections in the th radiator as Let s prove that in the optimal answer Proof by contradiction suppose we have and in the answer let s move from to and check The answer is not optimal contradiction Finally there is the only way to take with And it s to take elements with value and elements with 
700,There are lots of different approaches to this problem For example you could just iterate on the values of and from to and check if 
701,There are some solutions based on case analysis but in my opinion the most elegant one is the following Let s pick a color with the maximum possible number of pixels and repaint all other pixels into it We will try to pick all pixels of some other color and repaint them in one operation and we can ignore the constraint that we can repaint no more than pixels since we will never need to repaint or pixels in one operation So the number of operations is just the number of colors other than the one we chosen or just where is the number of different colors in the image To calculate this we can use a set or an array of size where we mark which colors are present 
702,Let s consider some cases If at least one of or are then all cells are isolated A knight can t move one in a perpendicular direction If at least one of or are at least then the knight always has at least one move No matter where you place it it can move two cells along the greater of the dimensions and move one in a perpendicular direction because it s at least Three cases are left and For all of these cases the middle cell is isolated That cell is Since it doesn t matter which cell you print in the first two cases you can always print Overall complexity per testcase Alternatively you can check every possible cell Iterate over a cell and check all eight possible knight moves from it If none are inside the board the cell is isolated Overall complexity per testcase 
703,Let s decrease by one Now let s determine the block with the th number To do that let s at first subtract from then subtract then subtract and so on until we got negative The number of subtractions will be the number of the block and the position in the block will be the last nonnegative number we will get 
704,Firstly let s find out when the answer is infinite Obviously any point of intersection is produced by at least a pair of consecutive figures Take a look at every possible pair and you ll see that only square inscribed in triangle and vice verse produce infinite number of points in intersection The other cases are finite From now we assume that initial sequence has no 2 and 3 next to each other Basically it s all triangles and squares separated by circles If the task was to count all pairs of intersecting figures the solution will be the following Square next to circle gives 4 points triangle next to circle gives 3 points Unfortunately the task asked for distinct points Notice that there is a single subsegment which can produce coinciding points square circle triangle So you have to find each triplet 3 1 2 and subtract their count from the sum Overall complexity 
705,Note that the answer does not exceed because the chip can be moved as follows Obviously in this case both operation are valid It remains to check the cases when the answer is or The answer is only if the destination point is and the answer is if is integer 
706,We should find minimal so Easy to see that To learn more about floor ceil functions I reccomend the book of authors Graham Knuth Patashnik Concrete Mathematics There is a chapter there about that functions and their properties 
707,Let s denote as the sum of array From one side since should be divisible by then we can say From other side since all are positive then It s quite obvious that the smaller the smaller maximum so we need to find the smallest that Then Now we now that and we need to represent it as with maximum minimized It s easy to prove by contradiction that maximum Moreover we can always construct such array that its sum is equal to and the maximum element is equal to As a result the answer is where 
708,There are many approaches to this problem You can for example factorize store all multipliers in a list and while size of this list is greater than take any two elements of this list and replace them with their product If the initial size of this list is less than then answer is 
709,Easy to see that there are only three cases in this problem If the king is in the corner of the board the answer is If the king is on the border of the board but not in a corner then the answer is Otherwise the answer is 
710,Suppose we have chosen and as the answer and is not a divisor of Since belongs to we could have chosen and instead So if the answer exists there also exists an answer where is a divisor of If then there is no pair such that and Otherwise and is the answer 
711,Let s use the fact that initially the level has plays and clears Call the differences before the previous stats and the current ones and The stats are given in chronological order so neither the number of plays nor the number of clears should decrease i e and Finally should be greater or equal to It s easy to show that if players pass the level successfully and players just try the level then such deltas are achieved So in implementation it s enough to check these three conditions between the consecutive pieces of data including the initial Overall complexity 
712,Iterate over indices from to and check if at least one of given local extremum conditions holds Overall complexity 
713,First let s say that appending the number with zeros is the same as multiplying it by The given numbers are so large that they can t fit into any reasonable integer type Even if you use a language with unlimited length integers python for example or store the numbers in strings you should still face the time limit issue So let s learn to shrink the numbers a bit Note that the result of the comparison of two numbers doesn t change if you divide both numbers by the same positive number So we can keep dividing both numbers by until one of them is not divisible anymore Let s also ignore the trailing zeros in and and leave them as is If the first number is appended with zeros and the second numbers is appended with zeros we can subtract from both values effectively dividing both numbers by This way one of the numbers becomes short enough to fit into an integer type because it has and is only up to The other number might still be large enough However if it s really large we can instantly say that it s larger than another one Say if its is at least This number it at least and the other number is at most Otherwise we can calculate this number as well and compare the values normally Overall complexity per testcase 
714,Notice that the next lucky year always looks like first digit of the current 1 10 number of digits of the current 1 It holds also for numbers starting with 9 it will be 10 10 number of digits 1 The answer is the difference between the next lucky year and current year 
715,If we put the maximum in the array on the first position then for every element starting from the third one the sum of elements before it will be greater than it since that sum is greater than the maximum value in the array So the only element that can make our array ugly is the second element We need to make sure that it is not equal to the first element Let s put the maximum element on the first position the minimum element on the second position and then fill the rest of the array arbitrarily The only case when it fails is when the maximum element is equal to the minimum element and it s easy to see that if the maximum is equal to the minimum then the first element of the array will be equal to the second element no matter what and the array cannot become beautiful So the solution is to check if the maximum is different from the minimum and if it is so put them on the first two positions and the order of remaining elements does not matter Note that the given array is sorted so the minimum is the first element the maximum is the last element 
716,Note that if then exists such that and obviously a customer who wants to buy cans won t buy more than he wants That s why and we can rephrase our task as finding such that The longer the segment is the better and the maximum we can take is As a result we need to check that 
717,Let s construct matrix from top to bottom from left to right At current step we consider position Look at contents of cells and If number of zeroes in them doesn t exceed then let s fill those cells with ones and decrease by this number If isn t equal to in the end of algorithm then there is no answer Overall complexity 
718,By the definition of lexicographical comparing we can see that if we can remove one character we always have to do it Besides we have to remove the character from the leftmost position such that and or from the position if there is no such 
719,If then the answer is equal to Otherwise answer will be equal to where is the count of the zeroes in the given string i e the answer is the binary string of length in which the first character is one and the other characters are zeroes 
720,Firstly since we are interested in minimum possible size of the array we don t need any elements other than minimums and maximums So the array has at most distinct elements Now there are many possible solutions The simplest one is to iterate on the number of minimums let this be and maximums let this be If the number of minimums is equal to the number of maximums then the array should have all elements as both its minimums and maximums so its length should be otherwise it should be We can iterate on all possible pairs and find the best result over all of them A solution in is possible if you see that you only have to consider and as the number of minimums maximums or check if the segments and intersect in 
721,This task can be done by one array traversal Maintain current minimum value position of the last occurrence of current minumum distance between two occurrences of Now for each if then do For do In the end will be the global minimum of array and will keep the closest its occurrences Overall complexity 
722,At first let s notice that if there exists such triple and that then and Thus we can sort all numbers and check only adjacent ones There are exactly of such pairs The only thing left is to find minimal distance of all pairs and count pairs with that distance Overall complexity 
723,Let r le g le b if it is not the case do some swaps If b r g 1 then at least two blue lamps will be adjacent so there is no solution Otherwise the answer can be easily constucted Place all blue lamps in a row Then place red lamps one between the first and the second blue lamp one between the second and the third and so on Then place all green lamps one between the b 1 th blue lamp and the b th one between the blue lamps with numbers b 2 and b 1 and so on Since r g ge b 1 there is at least one non blue lamp between each pair of blue lamps If g b we didn t place all green lamps we can place the remaining one before all other lamps the same with r b So if we swap l g and b in such a way that r le g le b we only have to check that b le r g 1 
724,There are many possible solutions to this problem The simplest one is to notice that using several flats of size and one flat of some size possibly also possibly not we can get any equal to or The only numbers that don t belong to these lists are and and it s easy to see that there is no answer for that numbers So the solution is to try all possible sizes of one flat and if the remaining number of windows is non negative and divisible by then take the required number of three room flats 
725,If some string can t be transformed to palindrom then it has some pair of positions with different letters on them as no such pair affects any other pair Thus you need to check each pair for from to and verify that the distance between the corresponding letters is either or Overall complexity 
726,If you have at least units of energy then the answer is because you can just walk to the end Otherwise the answer is because you can just sit on the first bench and then just go Time complexity 
727,There are two possible solutions for the problem The first solution is basically brute force Each password can be obtained from an integer from to If the number is from to then it s already a password of length Otherwise you have to prepend it with enough zeros so that it becomes length Then you have to check if the password is valid First check if it consists of exactly two different digits make a set of all its characters set char in case of C for example and check its size Then check if the first digit of the password appears exactly twice It would mean that the other digits appears exactly twice as well Finally check if neither of the found digits are forbidden The second solution is based on combinatorics First choose the two digits that will appear in the password Since digits are prohibited the remaining are allowed Second choose the positions that will be taken by the first one The answer is the product of these two values 
728,Note that the speed of cooking 1 slice of pizza is the same for all sizes 1 slice of pizza for 2 5 minutes If n is odd then we will increase it by 1 since the pizza is cooked only with an even number of pieces Now the value of n is always even If n 6 then for such n the answer is equal to the answer for n 6 so we can say that n max n 6 While n ge 12 we can order a small pizza Eventually the value of n will be equal to 6 8 or 10 This means that for any n there will be a set of pizzas with exactly n slices Then the answer is n 2 5 in the solution it is better to use the formula n 2 5 
729,During the first stage every player with an even index competes against a player with an odd index so in each match during the first stage the player whose index is smaller wins The pairs are formed in such a way that in each pair the player with an odd index has smaller index so all players with even indices get eliminated and all players with odd indices advance to the next stage All of the remaining matches are between players with odd indices so the winner of each match is the player with the larger index So the overall winner of the tournament is the player with the greatest odd index which is Note in some languages for example C standard power functions work with floating point numbers instead of integers so they will produce the answer as a floating point number which may lead to wrong formatting of the output and or calculation errors You might have to implement your own power function that works with integers or compute using a loop 
730,Since you need liters of essence to be exactly of potion then we can write an equality or and for some integer Since we need to minimize and then we should maximize but both and should be divisible by In other words taking as Greatest Common Divisor of and is optimal As a result 
731,Let s denote the difference between and as Then if has a prime divisor we can subtract from times The only positive integer that doesn t have any prime divisors is So the answer is if and only if 
732,You can check if the given is by removing all the trailing zeros and checking if resulting string is a palindrome 
733,Without loss of generality let s say otherwise we can swap them Note that you can t use more than packets at least one red bean in each packet so can t exceed at most blue beans in each packet So if then asnwer is Otherwise we can form exactly packets 
734,There are two solutions to this problem casework and greedy The greedy solution goes as follows the number of opening brackets in an RBS should be exactly and if there is a closing bracket before an opening bracket it s optimal to swap them if possible So we should replace the first question marks with opening brackets other question marks with closing brackets and if the answer exists this method will find it All that s left is to check that the resulting sequence is an RBS The casework solution goes as follows first of all each RBS should have an even length so if is odd there is no answer Furthermore an RBS always begins with an opening bracket and always ends with a closing bracket so if the first character is a closing bracket or the last character is an opening bracket there is no answer Since there is at most one opening bracket and at most one closing bracket in the original sequence these three constraints are enough if the opening bracket is before the closing bracket then they balance out and all other characters can be replaced in such a way that they form an RBS of length If the opening bracket is after the closing bracket then the first and the last characters are question marks since the first character is not a closing bracket and the last one is not an opening bracket We should replace the first character with an opening bracket the last character with a closing bracket so we get four characters two opening and two closing brackets which balance themselves out All other question marks can be replaced in such a way that they form an RBS of length So all we have to check is that is even the first character is not a closing bracket and the last character is not an opening bracket 
735,For bracket sequence to be regular it should have equal number of opening and closing brackets So if then it s impossible to construct any regular bracket sequence is completely irrelevant to us since inserting or removing a substring doesn t change the status of the string we get Almost the same applies to but we should have at least one substring before it So if but there is no solution In all other cases it is possible to order all strings as follows all strings then all strings then all strings then all strings 
736,There are many ways to solve this problem The model solution does the following thing start with the sequence merge the first characters into one sequence to get merge the first characters into one sequence to get and so on 
737,After some simulation of the given algorithm in your head on paper or on a computer we can realize that exactly all odd numbers are erased So all even numbers remain and the answer is 
738,Let s note that since all are positive any It means that we can t make the first and second minimums lower than they already are suppose the first and second minimums are and if we choose any other element to replace we can t make it less than and if we choose to replace or we will only make them bigger As a result it means that we can choose for each element either not to change it or make it equal to So to be able to make all elements we need just check that either or maximum We can do it for example by sorting our array in increasing order and checking that either or 
739,If the answer is then we always can reverse a substring of length So we need to check only pairs of adjacent characters in If there is no such pair of characters for all from to then the answer is Why is it so Consider the substring we have to reverse It is obvious that otherwise it is pointless to reverse this substring Then consider two cases then by transitivity and then we can go to a smaller substring otherwise and it means that we can take the substring 
740,Notice that the answer depends only on the number of the reviewers of the third type who upvote the movie Optimally we would want every single reviewer of the third type to upvote We can achieve it with the following construction send all reviewers of the first type to the first server all reviewers of the second type to the second server and all reviewers of the third type to the first server Since there are no downvotes on the first server all reviewers of the third type will upvote Thus the answer is the total number of reviewers of the first and the third type Overall complexity per testcase 
741,Let s presume that x ge y Then there are two cases in the problem If a a le b then we have to x y times perform the first operation So the answer is x y cdot a If a a b then we have to y times perform the second operation and pass the remaining distance by performing the first operation So the answer is y cdot b x y cdot a 
742,Obviously you can always obtain the optimal answer without using west or south moves So the shortest path consists of east moves and north moves Let s estimate the lower bound of the answer Take a look at these constructions and let question mark be any command different from the used one That s the tightest you can put east or north moves in So the answer is at least For you can put them just as in the construction and fill the rest of question marks with a stay in place move case works differently though You can do it only in moves by taking alternating moves Overall complexity per testcase 
743,There are three constraints on the number of emeralds the number of emeralds can t be greater than the number of emeralds can t be greater than the number of emeralds can t be greater than So the answer is 
744,The general idea of the solution is to check that string contains some substring which is a permutation of The constraints were so low you could do it with any algorithm even per test case could pass The most straightforward way was to iterate over the substring of sort it and check if it s equal to sorted That s Next you could notice than only substrings of length matter and shave another off the complexity to get After that you might remember that the size of the alphabet is pretty low And one string is a permutation of another one if the amounts of letters a letters b and so on in them are equal So you can precalculate array where is equal to the amount of the th letter of the alphabet in Calculating this array for substrings will be each so that makes it Then notice how easy it is to recalculate the letter counts going from some substring to Just subtract from the amount of the th letter and add to the amount of the th letter Comparing two array every time will still lead to though The final optimization is to maintain the boolean array such that means that is equal to the current value of of the substring You are updating just two values of on each step thus only two values of might change You want all the values to be so keep the number of values in that array and say if that number is equal to That finally makes the solution per test case 
745,Note that there are exactly eggs with only a sticker and analogically exactly with only a toy So we need to buy more than eggs or exactly 
746,Let s analyze which values can the function have It can be proven that the value of is equal to where is the number of zero digits at the end of the number because is the same number as except for the fact that it doesn t have any trailing zeroes Okay now let s analyze when we reach the new value of is the first value of such that is the first value of such that is the first value of such that and so on We have to calculate the maximum number that has the form and is not greater than and the answer is exactly It can be done with a mathematical solution but the most simple way to do it is read as a string instead and calculate its length 
747,Every character in strings and has at least one character adjacent to it that is the same So if there is an isolated character in our string a character that has no neighbors equal to it we cannot build it It s easy to see that in the other case we can build the string we can split it into blocks of consecutive equal characters and since there are no isolated characters each block will have at least characters so it can be formed from strings of length and or consisting of equal characters So the problem is reduced to checking if each character has a neighbor equal to it 
748,We just need to make sure our string of characters matches each of the substrings in at least one spot The easiest way to do this is to take every other character from Code 90908018 Another fun solution we can generate random strings and check them until we find one that matches everything This works because the probability of failing to match any particular substring is so as gets bigger the probability of failing gets extremely low Code 90999219 
749,First of all notice that the sum of the first odd integers is If then the answer obviously And if then the answer is also is modulo operation Otherwise the answer is always and it seems like this where It is obviously greater than because and it is obviously odd because the parity of and is the same 
750,To solve this problem we just need to find the first occurrence of the digit let s denote it as Now if then answer is otherwise 
751,Here you can simply model the process Or you can note that after each match some player drops out In total players will drop out So the first answer is Obviously the second answer is 
752,The answer will be equal to where is the number of squares that will appear in the th column 
753,Maintain the amount of capital letters taken by going from left to right make it zero when you meet space Overall complexity 
754,Notice that we can keep solved tasks and then submit all at once So the solution goes down to this you should find the first moment of time that the site works at that moment and Also it s convinient that the intervals are already sorted in increasing order Let s sum up all elements of array and write it to some variable The answer is obtained this way if the sum lies in the current interval then the answer is the sum Otherwise there are two cases If there exists some interval that then the answer is In other case the answer is 1 
755,Let s fix the number a of strings of length p and the number b of strings of length q If a p b q n we can build the answer by splitting the string s to a parts of the length p and b parts of the length q in order from left to right If we can t find any good pair a b then the answer doesn t exist Of course this problem can be solved in linear time but the constraints are small so you don t need linear solution Complexity O n2 
756,In this task you just can iterate over the numbers of hamburgers and chicken burgers you want to assemble check that you have enough ingredients and update the answer If you want to sell hamburgers and chicken burgers then you need beef patties chicken cutlets and buns 
757,Note that we never have a choice in what door should we open First we open the door with the same number as the key in our hand Then the door with the same number as the key behind the first opened door Finally the door with the same number as the key behind the second opened door If any of the first and second opened doors didn t have a key behind it then it s impossible Otherwise we open every door Let be the keys behind the corresponding doors Then we should check if is not zero and is not zero Overall complexity per testcase 
758,A solution in iterate on check that there exists an element lower than to the left of it and check that there exists an element lower than to the right of it Can be optimized to with prefix suffix minima A solution in note that if there is some answer we can find an index such that and if there is no such triple the array descends to some point and ascends after that so there is no answer So we only have to check consecutive triples 
759,Firstly let s approach this problem as if the steps were and Then the answer is if and It s easy to see that if the answer to this problem is then the answer to the original one is also Let s return to the original problem and take a look at some sequence of steps It ends in some point Define as and as The parity of is the same as the parity of It is like this because every type of move changes parity of both and So the answer is if and Overall complexity 
760,The answer is if and only if is divisible by because if you number all vertices of the initial polygon from to clockwise then you need to take every vertex divisible by and this number obviously should be integer and there is no other way to construct the other polygon 
761,To solve the problem you need to understand two facts The answer can t be greater than If current distance between rivaling student if less then we always can increment this distance by one swap In means that answer is equal to 
762,Note that it does not make sense to move several blocks first from the left tower to the right and then from the right to the left since this is similar to canceling the last actions Using the fact described above and small restrictions on the input data one of the possible solutions is the following choose which tower will be the one where we take blocks from try both options iterate over the number of operations and then check that both towers are beautiful after that number of operations There is a faster solution move all the blocks to the left tower and then check that there is no more than one pair of adjacent blocks of the same color If there are no such pairs then we can divide the tower into two in an arbitrary way and if there is exactly one pair then we need to make a cut exactly between two blocks of the same color Otherwise there will always be a pair of adjacent blocks of the same color in one of the towers 
763,It s easy to see that the FB string repeats every characters after processing every numbers we will get the same remainders modulo and as numbers ago and when we process consecutive numbers we get characters So This means that if we want to find a substring no longer than characters in the FB string we don t need to consider more than first characters of the FB string the substring of length starting with the th character ends with the th character and we don t need to consider substrings starting on positions greater than So the solution is to generate at least first characters of the FB string and then check if the substring occurs in the generated string using a standard function like 
764,Let s sort the array in nonincreasing order Now the answer is some of the first flash drives Let s iterate over array from left to right until the moment when we will have the sum at least m The number of elements we took is the answer to the problem Complexity O nlogn 
765,It is easy to understand that the optimal answer is achieved in one of three cases Vasya is trying to visit page without visiting pages and Vasya first goes to the page and then to the page Vasya first goes to the page and then to the page In the first case Vasya can go directly to the page from the page if is divided by In the second case Vasya can get to page through page if is divided by The required number of actions will be equal to Similarly in the third case Vasya can go to the page through the page if is divided by The required number of actions will be equal to If none of the three options described above is appropriate then there is no answer 
766,Number of chocolate bars Vasya can buy without offer is Number of bundles with bars Then number of additional bars In result total number of bars is 
767,There are just a few general cases in the task to consider If the password is already valid nothing has to be changed just print Try to change exactly one character iterate over all positions in and all three options for character any digit any lowercase or uppercase Latin letter After the replacement the string is checked for the validity and printed if it turned out to be valid We weren t able to replace a substring of length 0 or 1 then the answer is at least 2 We can obtain it in a following manner replace the first two characters to if the third character is an uppercase Latin letter to if the third character is a lowercase Latin letter and to if the third character is a digit 
768,The answer is the maximal value among the following values to cover all water beds within some segment to cover water beds before the first tap to cover all water beds after the last tap 
769,Multiplying by power of is shift left binary operation you probably should know it Reverse and for the simplicity and look at leftmost in let s denote its position as If you move it to in then you make the lexicographically bigger than the reverse of So you should move it to in too You can choose any with position Let be the minimum position of in such that You must move to otherwise the in still be present in and it will be not optimal So the solution is next reverse and find find print 
770,If there is at least one character and at least one character then current player can always make a move After the move the number of character decreases by one and the number of character decreases by one too So the number of moves is always where is the number of characters in string and is the number of characters in string So if is odd then Alice wins otherwise Bob wins 
771,Assume that Let s denote the minimum number of operations required to make and equal as There are two restrictions on At first because if then will be greater than after applying all operations Secondly integers and must have the same parity because if they have different parity then and will have different parity after applying all operations It turns out that we always can make integers and equal after applying operations It s true because we have to add to and the rest to And we can get any integer from to as a sum of subset of set 
772,There is one important observation Thus you can obtain at least pair by choosing as the minimum number in the sequence and as anything else for any positive Overall complexity per testcase 
773,No cases No any special thoughts Just greedy The solution consists of six steps Remove the prefix of the string until the position of leftmost character If there is no such character print Remove the prefix of the string until the position of leftmost character If there is no such character print Reverse the string Remove the prefix of the string until the position of leftmost character If there is no such character print Remove the prefix of the string until the position of leftmost character If there is no such character print Print the number of characters in the remaining string plus four 
774,Let s calculate the prefix sums for all numbers and store it in array and for numbers with letter B and store it in array Now we can find the sum of all numbers in any segment in time and the sum of numbers with letter B Let s iterate over prefix or suffix to flip and calculate the sum in that case by formulas for prefixes and for suffixes 
775,So the first idea that is coming into mind is prefix sums Let s define two values and The value means the amount of fall damage when we are going to the right from the column to the column and means the amount of fall damage when we are going to the left from the column to the column Then let s build prefix sums on these two arrays Now let be the sum of all on a prefix i e and be the sum of all on a prefix Then if in a query the answer is otherwise if the answer is Time complexity 
776,Let s consider one of the possible solutions Let s put the first element in the th permutation equal to and sort all the other elements in descending order Thus we get permutations of the form In such a construction for all and hence 
777,Note that or Since there is no upper bound for the values of the case where for all always exists It remains to check if there are other ways To do this it is enough to check whether there is such a position that the change to doesn t result in a negative value of The reason for is that for no matter the plus or minus we choose the array doesn t change If you could change at least one sign to minus that would be another answer 
778,If the value of is even then at least regardless of the value of Therefore we can put all the even values before the odd ones it does not matter in what order Now it remains to arrange the odd values In fact their order is not important because for odd and This means that each pair will be considered exactly time regardless of the order of the odd elements 
779,Notice that your final position is determined by the number of moves to the left you make Let there be exactly moves to the left that leaves us with moves to the right However let s interpret this the other way You have pairs of moves right left to insert somewhere inside the sequence of moves to the right Easy to see that all the positions from to will always be visited And the extra pairs can also increase the score by visiting some positions for some from to Notice that it s always optimal to choose exactly the same for all the pairs right left And that should be such that is maximum possible You can implement this idea in a straightforward manner iterate over and calculate the sum of values from to and the maximum value of over from to That will lead to a solution per testcase You can optimize it to with prefix sums or with some clever order to iterate over It s also possible to iterate over the final position and restore the number of left moves required to achieve it Overall complexity or per testcase 
780,What s the reason behind authors specifically asking for templates that have less or equal asterisks than letters Well without that the problem would be kind of trivial A template is matched by every string so it would always work Hmm let s try to make something similar to that template then We basically have to find some part of that occurs in both strings that we can use letters on to get some freedom to use asterisks There are some easy cases If the first letters of both strings are the same then the template can be that letter followed by an asterisk There s a symmetrical case for the last letter By studying the examples you can also notice the final case a common substring of both strings of length at least two surrounded by two asterisks Moreover since we only use two asterisks we can find a substring of length exactly two which always exists if a longer common substring exists Turns out that s it If a template exists one of these three kinds also exists This is not that hard to show If the first two kinds don t work then you have to use asterisks on both sides of the template In order for the template with asterisks on both sides to work there have to be adjacent letters in it at least once otherwise it s like and there are more asterisks than letters And since at least one such substring exists we can just remove everything other than this substring and the asterisks on the sides Overall complexity per testcase 
781,To get the sum for th week you need to take sum of th week subtract first element of th week from it and add up last element of th week All common elements will remain Thus by moving right week by week calculate sum of all weeks and divide it by Overall complexity 
782,Let be the number of zeroes and the number of ones on prefix of length also let The interesting property of is that the substring is balanced iff That leads to a solution for each value of maintain the minimum where this is obtained let it be called and for each index in the string update answer with 
783,A greedy strategy always works take largest barrels choose one barrel among them and pour all water from those barrels to the chosen barrel That way we make the minimum amount equal to it s quite obvious that we can t do anything better here and the maximum amount as large as possible so the difference between them will be as large as possible 
784,Let s notice that there are only beautiful numbers less than Generate them all and select the greatest one which is also divisor of Overall complexity 
785,Consider some corner of the picture If it s colored black then it contributes to counts to both of the adjacent sides Otherwise it contributes to none All the remaining cells can contribute only to the side they are on There are of such cells on each side So let s try all options of coloring the corners After fixing the colors of the corners we can calculate the number of cells that have to be colored on each side That is calculated by taking the initial requirement and subtracting the adjacent colored corners from it If any of the numbers is below or above then that corner coloring doesn t work Otherwise you can always color the cells in some way Overall complexity per testcase 
786,Since we know that every disliked song should have lower rating than every liked song we actually know which new ratings should belong to disliked songs and which should belong to the liked ones The disliked songs take ratings from to the number of zeros in The liked songs take ratings from the number of zeros in plus to Thus we have two independent tasks to solve Let the disliked songs have ratings Their new ratings should be We can show that if we sort the array then will be the lowest possible The general way to prove it is to show that if the order has any inversions we can always fix the leftmost of them swap two adjacent values and the cost doesn t increase So the solution can be to sort triples and restore from the order of in these Overall complexity per testcase 
787,Let be the value of the variable after steps Note that should be less than for to be not equal to It means that does not exceed It turns out that for there is always a permutation such that is equal to The only thing left is to find out how to build such a permutation There are many suitable permutations let s consider one of the possible options For an even a suitable permutation is You can see that in such a permutation changes as follows For an odd there is a similar permutation where changes as follows 
788,Let s make several observations At first note that the lengths of the strings doesn t change At second note that if the string has even length then being palindromic is the same as having even number of zeroes and even number of ones But if the string has odd length then it always is palindromic So the question is how to fix bad strings with even length but with odd number of zeroes and ones If we have at least one string with odd length then you can trade between bad string and odd string either zero to one or one to zero fixing the bad string Otherwise you can fix two bad strings swapping appropriate characters In result we can either make all strings palindromic or all strings except one in case of absence of odd strings and having odd number of bad strings 
789,Let s see how strings with periods k 1 and k 2 look There are two types of strings with a period equal to 1 and And there are two types of strings with a period equal to 2 and It s easy to see if t consists only of s s then the string itself is an answer since it has period equal to 1 Otherwise it s also quite obvious that any string t is a subsequence of of 2 t length 
790,There are several different ways to solve this problem In my opinion the two easiest solutions are notice that in the sorted string there is a prefix of zeroes and a suffix of ones It means that we can iterate on the prefix from which we remove all ones and remove all zeroes from the suffix we obtain If we try to remove two adjacent characters then we cannot use this prefix if there is a substring before the substring in our string then from both of the substrings at least one character remains so if the first occurrence of is earlier than the last occurrence of there is no answer Otherwise the answer always exists 
791,Notice that it never makes sense to move blocks between the towers such that neither of them is tower 1 as that can only decrease the heights Moreover it never makes sense to move blocks away from the tower 1 Thus all operations will be moving blocks from some towers to tower 1 At the start which towers can move at least one block to tower 1 Well only such i that a i a 1 What happens after you move a block Tower 1 becomes higher some tower becomes lower Thus the set of towers that can share a block can t become larger Let s order the towers by the number of blocks in them At the start the towers that can share a block are at the end on some suffix in this order After one move is made the towers get reordered and the suffix can only shrink Ok but if that suffix shrinks what s the first tower that will become too low The leftmost one that was available before So regardless of what the move is the first tower that might become unavailable is the leftmost available tower Thus let s attempt using it until it s not too late The algorithm then is the following Find the lowest tower that can move the block to tower 1 move a block repeat When there are no more towers higher than tower 1 the process stops However the constraints don t allow us to do exactly that We ll have to make at most 10 9 moves per testcase Ok let s move the blocks in bulk every time Since the lowest available tower will remain the lowest until you can t use it anymore make all the moves from it at the same time If the current number of blocks in tower 1 is x and the current number of blocks in that tower is y lceil frac y x 2 rceil blocks can be moved You can also avoid maintaining the available towers by just iterating over the towers in the increasing order of their height Overall complexity O n log n per testcase 
792,Let s sort array in non ascending order In this case for each pair of indexes the condition holds 
793,If and then the answer is If and or and then answer is or respectively And in the other case when and the answer is 
794,Consider the final cell after original path It has some distance to and to That means the path included at least and in corresponding directions Let s remove just these minimal numbers of moves Finally the answer will be where are distances from the final cell of the original path to Overall complexity 
795,The easiest way to solve to problem is probably to see the resemblense of a shuffle operation to an std rotate function So you can obtain the final deck by applying cyclic shifts of the deck by then and so on Since the shifts are cyclic it doesn t matter if you shift by or by or by for any non negative The result will be the same Thus you can calculate the sum of rotations you apply and subtract until it becomes less than That is taking it modulo Finally after rotating a sequence by some the th element of it indexed becomes the first one Thus you just want to print the th element of Overall complexity per testcase 
796,If is even then each hour A and B are on the spots with different parity so they will never meet Otherwise let s look closely what happens At the start A in and B in But since we can form a cycle from spots then it means that and in reality are neighbors After that A and B starting from neighboring positions just go in opposite directions and meet each other in the opposite spot after exactly steps After meeting B jumps over A making extra step and the situation become practically the same A and B are neighbors and move in the opposite direction In other words each steps B makes one extra step so the answer if both and spots are indexed is 
797,One can notice or actually derive using some maths that the answer is the sum of products of nested for loops iterations for every add command Let s learn to simulate that in linear complexity Maintain the stack of multipliers on for push the top of stack multiplied by to the stack on end pop the last value on add add the top of the stack to the answer The problem however is the values are really large Notice that once you add the value greater or equal to to the answer it immediately becomes OVERFLOW Thus let s push not the real multiplier to the stack but min multiplier That way the maximum value you can achieve is about which fits into the 64 bit integer Overall complexity 
798,Since the chess players of the first type should not lose a single game each game between two chess players of the first type should end in a draw so that none of them gets defeated And a game between a chess player of the first type and the second type should end either with a victory of the first or a draw Therefore for convenience we will say that all games with a chess player of the first type end in a draw Now there are only games between chess players of the second type left If there are only or such players then there is no answer Otherwise we can choose the following method the th chess player of the second type wins against the th chess player of the second type and the last one wins against the first all remaining games are drawn 
799,Let s start with a simple assumption For some fixed values the values of that the answers exist for make up a range So there s the smallest possible number of adjacent equal pairs one can construct and the largest one everything in between exists as well The largest number is simple put all A s then all B s then all C s So this value is The smallest number is trickier Let s instead investigate when it s equal to WLOG assume Imagine the following construction There are letters C which separate blocks of letters A and B There are if you consider the ones to the sides of all letters C but we want the smallest value so we shouldn t consider them such blocks thus it s possible that each block contains no more than one letter A and no more than one letter B So letters A and B will never produce adjacent pairs If there are empty blocks then there are adjacent letters C So the condition to still have no empty blocks is to have at least letters A and B in total If then any extra letter C can only be put adjacent to another letter C thus producing an extra pair at least one extra pair but since we are examining the lower bound we can always do exactly one That means that the lower bound is Now for the proof of the fact that every value in between is also achievable Since we have a construction for let s try modifying it Let s reduce the test to the following way While decrease the count of the letter that appears the most by and decrease by Now build the string for with the reduced values After that put the letters back placing them next to the last occurrence of the same letter there is at least one occurrence of each letter the proof is trivial That increases by and the count of this letter by Thus we ll return to the initial test Overall complexity per testcase 
800,We can see that the answer is if and only if there are no more than two gaps of length between the given points If there is no gap the answer is obviously If there is only one gap of length we can just move the left or the right part of the set to this gap When there are two gaps we can move the part before the first gap to the right and the part after the second gap to the left Of course if there is a gap of length at least or multiple gaps with the total length we can t move the points from the left and the right part to satisfy the middle gap Time complexity 
801,The task was just about implementing algorithm described in statement This is one of many possible ways of doing this Firstly you should notice that doing iterations in th step is equal to doing iterations based numbering That is less than Now fill array of length with ones and create pointer to current leader Then on th step move pointer to the right from cell proceed to till you encounter ones When finished write to this cell and move pointer to next cell which contains Overall complexity 
802,First let s determine if it s possible to reach the end at all If the laser s field doesn t span until any wall then it s surely possible just stick to the wall yourself If it touches at most one wall it s still possible If it s the bottom wall or the left wall then take the path close to the top and the right wall Vice versa if it s the top wall or the right wall then take the path close to the bottom and the left wall What if both of these paths are locked That means that the laser touches at least two walls at the same time the top one and the left one or the bottom one and the right one Turns out it s completely impossible to reach the end in either of these two cases Just draw a picture and see for yourself Thus we can always take at least one of the path sticking to the walls The distance from the start to the end is and both of these paths are exactly this long So the answer is always either or To check if the laser touches a wall with its field you can either use a formula or check every cell adjacent to a wall Overall complexity or per testcase 
803,Note that whichever order you choose the total time will always contain all initial health in other words any answer will contain as its part So the lower the sum of you will add to the answer the better Look at some monster If you kill it while it has both left and right neighbor it will add to the answer If it is the first or the last in the row it will add just And if it is the last monster it will add There can be only one last monster so any other will add at least to the answer And for any chosen last monster you can find the order that gives exactly for all other monsters For example you can firstly kill monsters then and finally moster In other words if the last monster is the th one the total answer will be equal to Since we need to minimize answer we can choose monster with maximum So the answer is 
804,There are several cases in this problem If then let s swap them Let be the modulo operator Firstly if then let s decrease and by one Otherwise if let s decrease by one and by two Now if then the answer is otherwise the answer is You can get more clear description of these cases if you will draw some cases on the paper 
805,The key observation is that the digital root of an integer is the single digit number such that You can prove this by noticing that for all Once we observe this finding the th number is very simple see the code 48993705 
806,Firstly you should find the minimum value in each row and after that you should find the maximum value over that minimums It s corresponding to the strategy of Jack and Emma 
807,When using th coupon the bar we get for free should have at least bars not cheaper than it So if we consider sorted in non decreasing order then we cannot get discount greater than On the other hand we can always get such a discount if we pick most expensive bars to buy using the th coupon 
808,Let s divide the solution into two parts firstly check the closest zero to the left and then the closest zero to the right After that we can take minimum of these numbers Initialize distance with infinity Iterate over array from left to right If value in current position is then set distance to otherwise increase distance by On each step write value of distance to the answer array Do the same thing but going from right to left This will find closest zero to the right Now you should write minimum of current value of distance and value that s already in answer array Finally you should retrieve the answer from distances Overall complexity 
809,Notice that once the number becomes even it never stops being even as subtracting doesn t change parity Thus the task is to find the smallest divisor subtract it and print Overall complexity 
810,It is obvious that we always can use only two emotes with maximum Let their values be and We have to solve the problem by some formula The best way to use emotes use the emote with the value times then use the emotion with the value then again use the emote with value times and so on So the has length and we can use the emote with the value the remaining number of times So the answer is where is the first maximum of is the second maximum of is divided by rounded down and is modulo 
811,It is enough to consider two possible arrays and It is not difficult to notice that in these arrays the condition is met that among two neighboring elements one divides the other It remains to show that at least one of these two arrays satisfies the condition Let s consider the sum of elements at odd positions and the sum of elements at even positions Since at least one of the values of and does not exceed because otherwise their sum will be strictly greater than Without losing generality assume that Note that for the second variant of the array the condition holds so 
812,This one is a pure implementation task Just check every possible line of length If the current one contains crosses and empty cell then the answer is 
813,There are lots of ways to check correctness For example you can keep boolean array with already used colors check stripes naively and mark the color used if the stripe has single color If all the colors are used in the end then the answer is Overall complexity 
814,Let s understand how players should act Vasya needs to delete the first digit that is not equal to because the first digit of telephone number should be and the first digit not equal to is preventing it Petya needs to delete the first digit equal to for the same reasons So all that we need to do is delete first digits not equal to if they exist and first digits equal to again if they exist It s enough to stop when there is either no s left or no non s because the latter moves won t change the result of the game anyway Finally if first digit of resulting string is then Vasya wins otherwise Petya Overall complexity 
815,The easiest way to force some gcd to be of some fixed length is to use the divisibility rules for or if the number produced by the last digits is divisible by then is also divisible by same goes for and One of the possible constructions is the following let and Since and are pairwise prime gcd is Overall complexity per testcase 
816,Note that so you can make any value equal to by multiplying it by two times since So the answer for each value is at most Now let s note that there is always an optimal answer that consists of at first add one times then multiply by two times and is the minimum answer In other words let s just iterate over all and and check that The answer is minimum among them To prove that it s optimal to add at first and only then to multiply note that it s not optimal to add more than once after muptiplying can be replaced by So there is at most one between two but it s not optimal to make even one since we need to make divisible by and break divisibility There are many other approaches to this task except this one for example since you can write bfs to find the shortest paths from to all 
817,A string is good when either its first character is or the last is Strings of type are not good as their first and last characters will never change and they will eventually come to the form So the answer is the minimum number of characters from the beginning of the string which must be removed so that the first symbol becomes or minimum number of characters from the end of the string which must be removed so that the last symbol becomes 
818,Let s simply iterate over all the values from to and add to the answer the number of segments of the current value To count the number of segments we should iterate over all the digits of the number and add to the answer the number of segments of the current digit These values can be calculated by the image from the problem statement and stored in some array in code 
819,Since there are only five days we can iterate over the two of them that will be the answer Now we have fixed a pair of days and and want to check if it can be the answer All students can be divided into four groups marked neither of days and marked only day marked only day and marked both days Obviously if the first group is non empty days and can t be the answer Let s call the number of students who only marked day and the number of students who only marked day If either of or exceed then days and can t be the answer as well Otherwise we can always choose students from the ones who marked both days and send them to day The rest of the students can go to day 
820,You are given the permutation f Let s build another permutation p in the following way pfi i So the permutation p defines the number of sector by the number of fragment The permutation p is called inverse permutation to f and denoted f 1 Now the answer to problem is Complexity O n 
821,First of all let s delete all segments that do not cover the point because they increase the value of the function at points other than If there are no segments left then the answer is Otherwise all segments cover the point And it remains to check whether the point is the only point which is covered by all segments Note that it does not make sense to delete any of the remaining segments because if there are several points with maximum value of then deleting segments can only increase their number To check the number of points with the maximum value of you can iterate over from to and calculate because of the small number of segments in the problem A faster way is to check the size of the intersection of all segments The left boundary of the intersection is and the right boundary is if then the point is ideal otherwise it is not 
822,Let s denote a prefix of length as We can note that each where and is a concatenation Then balance of prefix of length is equal to Now there two cases is equal to or not If then if exist such that then for each and answer is Otherwise for each such there will no more than one possible since there are zero or one solution to the equation The solution exists if and only if and So just precalc and for each check the equation 
823,Suppose we decided to increase some by How does it affect all inflation coefficients Let s the th inflation coefficient be We now that If then doesn t change If then it s denominator increases by and decreases If then it s numerator increases and increases as well But if we increase instead of then all decreased will decrease as well and also will decrease Finally if we increase then all decrease and there is no that increases so it s always optimal to increase only Now we need to calculate what is minimum we should add to There are two ways we can either binary search this value knowing that is always enough Then we just need to check that all that is equivalent to checking that Or we can note that each and we need to make or that or Since we should fulfill all conditions then we should take as maximum over all fractions Since is just a prefix sum we can check condition for each in It total the time complexity is either or per test case 
824,The only answer is when no segment can be moved one cell either to the left or to the right So there should be exactly one cell between two consecutive segments and the first and the last segments should touch the borders Thus total count of cells needed is Overall complexity 
825,At first let s jump with while is still greater than the current position Now we finished in some position Note that otherwise we wouldn t make the last step If then we are lucky to finish right in point Otherwise let s look at what happens if we replace one with Basically we ll finish in And since then We know that so if then we can choose the corresponding and replace with and get straight to the point But if then we need one extra operation To calculate fast we can note we need at least since and then we can increase while 
826,Firstly let s learn how to split persons in pairs as if there are no single kayaks Let there be people with weights and Obviously the lowest instability you can achieve is Swapping any two elements will only make the result greater This greedy strategy can be used to distribute all the seats Now you need to check every pair of persons to seat in single kayaks and calculate total instability for the rest The answer will be the minimun instabily over all pairs Overall complexity 
827,Notice the following fact it s never optimal to fire a missile at such a position that there are monsters to the right of it That suggests the next solution sort the positions leave only the unique ones and process to shoot at the rightmost alive monster until every monster is dead Position of some monster after shots are made is the original position minus because the monster could only be pushed to the left Overall complexity 
828,Let s denote a cell as if is even otherwise the cell is It s easy to see that if a knight is occupying a black cell then all cells attacked by it are white and vice versa Using this fact we can construct a solution where every pair of knights that attack each other have different colors put black knights into black cells and white knights into white cells so every pair of knights that can possibly form a duel actually form it 
829,Naive solution would be just simulate the tranversal and break when steps are made Obviously this won t fit into time limit Then we can decompose the path to some parts which can be calculated separately Walk from the top left to the bottom left corner Walk from second column to th on even rows Walk from th column to second on odd rows If then it s the first part Otherwise you can use the fact that rows are of the same length will tell you the row and will get you the number of steps Lara have made along this row Overall complexity 
830,Let s iterate over all from to and if is equal to then add to the some variable and replace with Then answer will be equal to where can be easily calculated with prefix sums for each 
831,The only case when the answer is is when all letters of the string are equal Why is it so Because if we have at least two different letters we can place the first one at the first position of the string and the second one at the last position of the string Then it is clearly that the obtained string is We can implement this solution by the following way sort and if the first letter equals to the last one then the answer is otherwise the answer is 
832,Let s construct the answer letter by letter How to get enough letters a for the name Surely the taken letters will be the first a the second a up to th a in string where is the amount of letters a in the name It s never profitable to skip the letter you need Do the same for all letters presented in the name The answer will the maximum position of these last taken letters How to obtain the th letter fast Well just precalculate the list of positions for each letter and take the needed one from it Overall complexity 
833,At first let s insert and in array so all possible positions for inserting will always belong to At second let be value to insert and It can be proven that it s always optimal to move to or to So for each we need to check only and To check it fast enough we need to know total time of lamp is lit for each prefix and precalculate for each total time of lamp is lit if starting from light is on lights is off Result complexity is 
834,Let s fix the number of leg length increases we do Let the final length be k Notice that for all i from 1 to k there is some time when the length is exactly i Thus we can perform jumps of form x y rightarrow x i y or x y rightarrow x y i What s the jumping strategy then Obviously we can solve the problem independently for a and b Consider a We would love to just make jumps of length k as that s the maximum possible length Unfortunately that only works when a is divisible by k Otherwise we are left with some remainder which is smaller than k But we have already figured out how to jump to any value from 1 to k So that only adds another jump You can say that the total number of jumps is lceil frac a k rceil Same for b Finally for a fixed k the answer is lceil frac a k rceil lceil frac b k rceil k 1 The constraints tell us that we are not allowed to iterate over all k from 1 to max a b It feels like huge k will never be optimal but let s try to base our intuition on something Try to limit the options by studying the formula Let s simplify Assume a b and also get rid of the ceil Not like that changes the formula a lot Now it becomes 2 frac a k k 1 We can see that when we increase k 2 frac a k becomes smaller and k 1 becomes larger However we care more about how fast they become smaller and larger You can just guess or write down the derivative explicitly and figure out that the first term shrinks faster than the second term grows until around sqrt a cdot c for some constant c apparently c sqrt 2 Thus their sum decreases until then then increases Thus you can search for the best k around sqrt a or sqrt b or sqrt max a b It doesn t really matter since for implementation you can basically try all k until around 10 5 which is safely enough 
835,Let s iterate over all 6 digit numbers Now we will calculate number of positions in which digit of current ticket differs from digit of input ticket and call it Then answer will be minimal value over all lucky tickets 
836, cannot be transformed into any other number can be transformed into or and can be transformed only into It means that if then only is reachable and if or then should be less than Otherwise we can make as large as we want so if any is reachable 
837,Minimal product is obtained by multiplying three smallest elements of the array Let s iterate over the middle element of these three and calc sum of all options Firstly let s precalc two arrays of pairs and is minimum and number of its occurrences on the prefix of array up to index inclusive is minimum and number of its occurrences on the suffix of array up to index inclusive It can be done with two traversals over the array Let s also store set of three elements which give minimal product of the array Consider every index from to inclusive 0 indexed If set is equal to the stored set of three minimums then add to the answer number of ways to choose pair that is Overall complexity 
838,Constraints tell us that we can avoid making any weird assumptions for any greedy solutions You can easily count the answer for some fixed amount of tasks completed Just sort all left subtasks but the longest to solve in each uncompleted task and take the easiest till the time is over Now you can iterate from to tasks completed and take maximum over all options Overall complexity 
839,The first step is to notice that beauty doesn t exceed because the minimum difference between two elements is at least and the maximum difference does not exceed the difference between the maximum element and the minimum element At first finding a matrix with maximum beauty seems to be a quite difficult task So let s try to find an array of elements of maximum beauty In this case it is not difficult to come up with an array of the form In such an array there are all possible differences from to So we found an array with the maximum possible beauty It remains to find a way to convert the array to the matrix i e to find such a sequence of matrix cells that each two adjacent cells in it are side adjacent One of the ways is the following traverse the first row of the matrix from left to right go down to the second row traverse it from right to left go down to the third row traverse it from left to right and so on Thus we constructed a matrix with the maximum possible beauty 
840,Let be the length of the substring deleted at the th step Then the number of points will be equal to or The sum of all is equal to because in the end we deleted the entire string so the final formula has the form Obviously for you should delete the characters one by one so that Now and you have to delete the string in the minimum number of operations Let the string consist of blocks of zeros and ones then is the minimum number of operations for which the entire string can be deleted As long as the number of blocks is more than we will delete the second block the number of blocks will decrease by after each such operation the block that we delete will disappear and the first and third blocks will merge into one 
841,It can be proved that the optimal answer equals to a number of bacteria which can t be eaten by any other bacteria So for each bacteria you need to check existence of any bacteria satisfying condition There plenty of ways to check this condition One of them is to sort array and for each find minimal with or with two pointers technique Or you can use the fact that and build solution around it Result complexity is 
842,In fact to carry out only one reform is always enough And it s easy to prove if you make only one reform it s always optimal to take the maximum such that the average of maximums in the array is at least i e sum greater or equal to So the solution is next sort array and find the suffix with maximum length such that the sum on the suffix is at least To prove the fact about one reform we can prove another fact after each reform the sum of maximums doesn t increase for each We ll prove it in two steps The first step Let s look at some reform and form an array from the chosen elements in in descending order After the reform we ll get array where all Let s just skip the proof and say it s obvious enough that for any The second step Let fix and divide array on two parts maximums as and other elements as And let s make the same division of the array after performing the reform on and So we need to prove that Suppose elements were chosen in the reform of them were in and now in If then we can think like maximum elements from elements in were replaced by the average and other were replaced by elements from Since and any element from is greater or equal to any element from then we proved that when If then let s look at and The has chosen elements and has so and we can prove that practically in the same way as before Obviously if and then Q E D The last step is easy let s prove that the only reform is enough The answer after several reforms is clearly equal to maximums which are at least But it means that the sum of maximums is at least therefore the sum of maximums in the initial array is at least So we can make them all at least by only one reform 
843,Let s notice that described swaps allows us to place any character to any position of the string relative order of and obviously cannot be changed Let s remove all characters from the string and keep their count in some variable Now more profitable move is to place all the 1 characters right before the first character of and if there is no character in then place they after the end of the string 
844,Let s think how a reduction changes the length of There are two cases If two adjacent letters sum up to or greater then the length doesn t change Otherwise the length decreases by one Obviously if there exists a reduction that doesn t change the length then it s better to use it Which among such reduction should you choose Well notice that such a reduction always makes the number strictly smaller easy to see with some case analysis Thus the logical conclusion is to leave the longest possible prefix of untouched So the rightmost such reduction will change the number as little as possible If all reductions decrease the length then a similar argument can be applied The sum will be a single digit but a digit that is greater than or equal to the left one of the adjacent pair If it was just greater it s easy to see that the leftmost such reduction will make the number the largest possible The equal case adds more case analysis on top of the proof but the conclusion remains the same the leftmost reduction is the best one As an implementation note since all the reductions are of the same type the leftmost reduction always includes the first and the second digits Overall complexity per testcase 
845,Let s try to estimate the maximum possible answer Best case you will be able to remove either all zeros or all ones from the entire string Whichever has the least occurrences can be the answer If the amounts of zeros and ones in the string are different this bound is actually easy to reach just choose the substring that is the entire string If the amounts are the same the bound is impossible to reach Choosing the entire string will do nothing and asking a smaller substring will decrease the answer The smallest we can decrease the answer by is If you choose the substring that is the string without the last character you will decrease one of the amounts by one That will make the amounts different and the bound will be reached Overall complexity per testcase 
846,There are two conditions that should be met according to the statement On the one hand we should repair the whole highway so we must spend at least days to do it On the other hand at least half of it should have high quality pavement or at least units should be laid at good days How to calculate the minimum number of days name it as for the second condition to meet Note that the first days can be represented as several maybe zero blocks of days where exactly days in each block are good and some remaining days The because will not be minimum otherwise There are plenty of ways to calculate One of them is the following Firstly let s calculate the number of cycles we need Now if we just add it since it s exactly the or But if we added to last block and should subtract it or The answer is 
847,Let s collect the prefix sums of the initial array How do they change if you swap two values in the array Let s swap values on positions and Prefix sums from to aren t changed Prefix sums from to are increased by note that if then these sums become smaller Finally prefix sums from to aren t changed as well Thus swapping two values will only increase some prefix sums but never decrease any of them That helps us see that the array such that all values on the unlocked positions are sorted in a non increasing order is the most optimal one Overall complexity per testcase 
848,The key observation is that the number is divisible by if and only if its last two digits forms a number divisible by So to calculate the answer at first we should count the substrings of length one Now let s consider pairs of consecutive digits If they forms a two digit number that is divisible by we should increase the answer by the index of the right one 
849,Notice that rows can be solved completely separately of each other Each tile takes either one or two squares but it s always in the same row So let s take a look at a single row There are sequences of dot characters separated by some asterisks Once again each of these sequences can be solved independently of the others Thus we have these empty strips of empty squares which when solved can be summed up into the whole answer There are two cases depending on if a is cheaper than two tiles If it is then we want to use of many tiles as possible So given we can place tiles and cover the rest squares with tiles If it isn t cheaper then we want to cover everything with tiles and never use ones So all should be The easier way to implement this might be the following Let s update the price of the tile with the minimum of and This way the first algorithm will produce exactly the same result of the second one in the case when a tile isn t cheaper than two ones Overall complexity per testcase 
850,Why does the problem ask us only to check if we can do less than operations instead of just asking the minimum amount That must be making the problem easier so let s focus our attention on that What if it was instead of Well then the problem would be trivial You can type the word letter by letter and be done in operations So we only have to save one operation In order to save at least one operation we have to use the copy operation and copy more than one character in that Let s take a closer look at any of the copy operations we do Basically it has to be a substring that has at least two non intersection occurrences in the string Thus if the string has any substring that has length at least two that appears at least twice in the string we can copy it and the answer will be That s still not enough to solve the problem we d have to check all substrings which is Let s think further Imagine we found a substring that works Let it have length Notice how you can remove its last character obtaining a substring of length and it will still occure in the same set of positions possibly even more occurrences will be found Remove characters until the substring has length Thus if any appropriate substring exists an appropriate substring of length also exists Finally we can check if there exists a substring of length that appears at least twice in the string so that the occurrences are at least apart That can be done with a set hashset or a map hashmap Some implementations might require careful handling of the substrings of kind and similar Overall complexity or per testcase 
851,Let s see the following fact if we will decrease from all numbers written in cells with an odd sum of coordinates and write out the numbers obtained on the board from left to right from top to bottom the sequence will looks like for even for odd there is only one number at the end of the sequence but in general it does not matter Let s try to find out the answer for some query Let 1 indexed There is the position of our cell in order of the written sequence The first approximation of the answer is But now we are remember that we decreased from all numbers written in cells with an odd sum of coordinates So if is even then the answer is otherwise the answer is Note that you should be careful with integer overflow in C Java or similar languages 64 bit datatype is quite enough Time complexity 
852,Let s assume Then the answer is if two following conditions holds because after each operation the value does not change 
853,The answer to this problem can be constructed this way Sum up all positive numbers Find maximum of negative odd numbers Find minimum of positive odd numbers If sum was even then subtract Overall complexity 
854,The function of the total distance is monotonic between any pair of adjacent points from the input so the answer is always in some of the given points We can use that observation to solve the problem by calculating the total distance for each point from the input and finding the optimal point The other solution uses the observation that the answer is always is the middle point by index in the sorted list of the given points The last fact is also can be easily proven 
855,Ideally we would want the fixedness values to be That would make a chain of length However it s impossible to have fixedness of after one swap The first swap always makes a permutation with fixedness Okay how about then That turns out to always be achievable For example swap elements and then elements and then and and so on Overall complexity per testcase 
856,Let s show by construction that there can be no ambiguity in values of of the children who were leaders at least once except for probably the last leader If then on this step the value of taken was exactly Otherwise went over and in circle ended up to the left or in the same position So for this case should be Obviously counting cannot go over two or more times as this will result in We only need to check if all the numbers are unique and fill the unvisited children with remaining values to form the permutation Overall complexity 
857,To solve the problem it is enough to consider several cases if the array is already sorted the answer is if or then you can sort the array in one operation by selecting the subarray or if and you can perform the sequence of operations and and sort the array on each of them you can t do it faster since you can t move both to position and to position in only operations otherwise the array can be sorted in operations 
858,The subsegment as well as the whole permutation will always be a permutation so the value is at least Let s try to find a way to generate a permutation of elements with value equal to Every permutation must contain the number Let s try to construct the answer in such a way that if a subsegment contains the number then it also contains the number if it is so it can only be a permutation if it contains all numbers If we begin our permutation with the numbers and we will reach our goal the only subsegment which does not contain but contains is and the only subsegment which contains and also a permutation is the whole permutation itself So any permutation that begins with can be the answer 
859,Let s notice that for a fixed value of the answer the cost of permutation does not exceed because only numbers from to can have a pair It turns out that it is always possible to construct a permutation with the cost of exactly It is enough to consider the number chains of the form where It is not difficult to understand that each number is included in exactly one such chain Therefore if we append the chains one after another then in such a permutation the answer will be equal to because all numbers will have a pair except the last element in the chain The number of chains is equal to which means the cost of the permutation is equal to By choosing the permutation will have the maximum possible cost 
860,Suppose we have a disk that is smaller than both of its neighbours Then it s impossible to collect all the disks on the same pillar eventually we will put this disk on the same pillar with one of its neighbours and then we can t put the other neighbouring disk on the same pillar since it is greater than the middle disk Okay and what if there is no disk that is strictly smaller than both of its neighbours Let k be the index of the largest disk a k 1 a k that implies a k 2 a k 1 and so on a k 1 a k a k 2 a k 1 and so on It means that the array a is sorted in ascending until the index k and after that it is sorted in descending order If this condition is met then we can collect all the disks on the pillar k one by one starting with the disk having radius n 1 and ending with the disk having radius 1 So the only thing that we need to check is the following condition array a is sorted in ascending order until a k n and then it is sorted in descending order 
861,Suppose the answer is What s the maximum number of chips we can place Firstly the allowed points to place chips are such that We can group them by coordinate for there is only one for possible are for possible are in segment and so on For possible are in The negative s are the same Let s calculate the maximum number of chips we can place at each row for it s for there are three s but since we can t place chips at the neighboring s we can place at most chips for we have places but can place only chips for we have places but can occupy only points In total for we can place at most chips Analogically for we can place at most chips In total we can place at most chips with cost at most Note that can actually be reached since the distance between chips on the different rows is greater than So to solve our task it s enough to find minimum such that that can be done with Binary Search Or we can calculate Note that can lose precision since is cast to before taking the square root for example transforms to when converted to So you should either cast to that consists of bits in some C compilers or check value as a possible answer 
862,Simulate the process without adding the new entry For this you can just maintain an array th value of which is true if the th prince is married and false otherwise Now observe that there are two possible outcomes Every daughter is married the answer is optimal There is a daughter who isn t married That means that there is a free prince as well Marry them to each other because doing that won t affect any other marriages and add a new one to the answer Overall complexity 
863,First of all there is an answer with exactly items bought Suppose items worth were purchased Then by removing from this set the sum of the cheapest items in the set will change by which means the answer will not decrease The second fact that is necessary to solve the problem of the most expensive items should be chosen Otherwise one can remove the minimum price item from the set and add an item with a higher price it can always be found which means the answer will not decrease Using these two facts it is enough to sort the array and use prefix sums 
864,Suppose the initial sum of is equal to If we perform the operation the new sum will be equal to We want the sum not to decrease or If we will get If we ll get analogically In other words array you need if sorted will have and so on And one of the variants and obviously an optimal one is just As a result since we just need to check if then we found an answer otherwise there is no counterexample 
865,Let s sort all numbers in a Now let s iterate over elements of b and for element bj find the index of lowest number that is greater than bj We can do that using binary search That index will be the answer for value bj Complexity O nlogn 
866,Denote as the sum of first elements of and as the sum of first elements of These values can be calculated in with prefix sums The first solution is to use dynamic programming Let be the maximum value of if we placed the first elements of and the first elements of Transitions can be performed in we either place an element from then we go to and update it with or place an element from then we go to and update it with The answer is stored in and this solution works in The second solution observe that the sum of several first elements of is the sum of several first elements of and several first elements of So each prefix sum of and the answer itself is not greater than It s easy to show how to obtain exactly this answer let be the value of such that is maximized and be the value of such that is maximized Let s place the first elements of then the first elements of so the current sum is exactly and place all of the remaining elements in any possible order So the answer is This solution works in 
867,Numbers with the difference of are always relatively prime That s the only thing I should mention for this editorial Overall complexity 
868,We need to make our string alternating i e When we reverse substring we change no more than two pairs and Moreover one pair should be a consecutive pair and other So we can find lower bound to our answer as maximum between number of pairs of and number of pairs of And we can always reach this lower bound by pairing with or with left right border of Another way to count the answer is next suppose we want to make string then let s transform to For example if we will get We claim that after this transformation we will have equal number of and so the answer is the number of consecutive pairs of the same character divided by two The answer is the minimum between answers for and 
869,Let s assume that the rows are numbered from to from top to bottom and columns are numbered from to from left to right If there is no robot in the cell initially we have to perform several moves up and or left If the first row with at least one robot is the th row then we can make at most steps up and we should do at least steps up since otherwise there will me no robot in the upper row Similarly if the first column with at least one robot is the th column then we can make at most steps to the left and we should do at least steps to the left since otherwise there will me no robot in the leftmost column Now there are two possible solutions both starting with finding and we afterwards either simulate moves up and moves to the left and check that everything is fine or just check that there is a robot in the cell since only this robot can end up in 
870,First iterate on the number of swords we will personally take Then we should greedily take as many war axes as we can until we run out of money At this point our follower needs to take as many items as possible They can do this by greedily taking whichever of swords or war axes are cheaper until they run out followed by taking the more expensive of the two Code 90918673 
871,In this problem you should simply find the symmetric letters by picture and also observe that the pairs and is the symmteric reflections 
872,In this problem you should simply do what was written in the problem statement There are no tricks 
873,Let s take a look at a naive approach for each query you iterate over positions and check if Okay this is obviously Now we notice that there are only positions for to start from we can calculate if there is an occurrence of starting in this position beforehand in Thus we transition to solution Finally we calculate a partial sum array over this occurrence check array and answer each query in Overall complexity 
874,In this problem you should simply do what was written in the problem statement There are no tricks 
875,Let s consider how the set of possible indices where the can be changes Initially only one index is correct After performing an operation such that or this set does not change But after performing an operation such that we should insert the elements into this set if they are not present Now consider how the set changes If segments and do not share any indices there are no changes but if they do the set turns into So the set of reachable indices is always a segment of numbers and to process an operation we should check whether the segment from operation intersects with the segment of indices we have and if it is true unite them 
876,There are many different constructions that give the correct answer if it exists In my opinion one of the most elegant is the following one should always be present in the left half and should be present in the right half but the exact order of elements in each half doesn t matter So it will never be wrong to put in the first position and in the second position As for the remaining elements we want elements of the left half to be as big as possible since they shouldn t be less than and elements of the right half as small as possible since they shouldn t be greater than Let s put the elements excluding and on positions respectively so the elements in the left half are as big as possible and the elements in the right half are as small as possible After constructing a permutation according to these rules we should check if it meets the constraints and print it if it does 
877,It is quite obvious that we can t choose any submatrix that contains at least one zero in The contrary is also true if a submatrix of consists of only ones then there s no reason not to choose it suppose there is an answer that does not choose it then choosing this submatrix won t affect it So we may perform an operation on every submatrix of such that the corresponding submatrix in is filled with s and check if our answer is correct 
878,First let Eve tell the jokes of the first type they will never do any harm At the same time let her tell the jokes of the fourth time at the very end they will not do any good Types two and three are kind of opposites of each other If you tell jokes of each of them one after another then the moods of both spectators don t change Let s use that to our advantage Tell the jokes of these types in pairs until one of them runs out There s a little corner case here though If there were no jokes of the first type then you can t use a single pair because of the spectators leaves after one joke Finally try to tell the remaining jokes of the same type before the fourth type So the construction looks like with and possibly swapped with each other Let s recover the answer from that construction After the first type both moods are After the alternating jokes the moods are still the same After that one of the spectators will have his her mood only decreasing until the end Once it reaches the show ends Thus Eve can tell jokes if Otherwise it s always Overall complexity 
879,We should notice that if some string is a multiple of string then is a multiple of This fact leads us to the conclusion that should be a common multiple of and Since we want to minimize the length of the string then its length is So we have to check that copies of the string equal to copies of the string If such strings are equal print them otherwise there is no solution 
880,Let s consider as a substring of string from position to position is not included Let s iterate over all lenghts of the copied prefix from to 0 inclusive and then if then answer will be and iterating over smaller lenghts is not necessary 
881,The following greedy strategy works during each turn delete the largest possible substring consisting of characters So we have to find all blocks of characters sort them according to their length and model which blocks are taken by Alice and which by Bob Why does the greedy strategy work It s never optimal to delete some part of the block of ones because we either have to spend an additional turn to delete the remaining part or allow our opponent to take it which is never good Why don t we need to delete zeroes If we delete a whole block of zeroes our opponent can take the newly formed block of s during their turn and it is obviously worse than taking a part of that block And deleting some part of a block of zeroes doesn t do anything our opponent will never delete the remaining part because it s suboptimal 
882,Firstly let s calculate the length of the prefix of equal letters let it be and the length of the suffix of equal letters let it be It can be done with two cycles with breaks It is obvious that this prefix and suffix wouldn t overlap Then let s consider two cases the first one is when and the second one is when In the first case we can only remain either prefix or suffix of consisting only of equal letters Then the answer is because we can remain from to letters on the prefix from to on the suffix or empty string In the second case we can remain from to letters on the prefix and from to letters on the suffix But now because we can combine these ways so the answer is And the bonus this case is not belong to the given problem if all letters in the string are equal then then answer is because we can choose any substring of of length at least and any substring of length 
883,Let s maintain an array of size where will be equal to the number of switches that are connected to the th lamp Then answer will be if and only if there exists some switch such that for each lamp that is connected to this switch Otherwise the answer will be 
884,Let s store the last moment when somebody gets a tea in the variable Then if for the th student then he will not get a tea Otherwise he will get it during second And if he gets a tea then will be replaced with the answer for this student 
885,There are multiple solutions involving advanced methods such as binary search or two pointers but I ll try to describe a simpler one The main idea of my solution is that the answer should look like one character of type a block of characters of type and one character of type If we find all blocks of consecutive equal characters in our string each candidate for the answer can be obtained by expanding a block to the left and to the right by exactly one character So the total length of all candidates is and we can check them all Why does the answer look like If the first character of the substring appears somewhere else in it it can be deleted The same applies for the last character So the first and the last characters should be different and should not appear anywhere else within the string Since there are only three types of characters the answer always looks like 
886,Let s denote cnti the number of books of i th genre The answer to problem is equals to In first sum we are calculating the number of good pairs while in second we are subtracting the number of bad pairs from the number of all pairs Complexity O n m2 or O n m 
887,Note that whichever path you choose the total cost will be the same If you know that the cost is the same then it s not hard to calculate it It s equal to So the task is to check is equal to or not The constant cost may be proved by induction on for cost is For a fixed there are only two last steps you can make either from with cost the total cost is or from with cost the total cost is So whichever path you choose the total cost is the same 
888,Notice that for has no more than powers which give numbers no greater than So let s store all possible sums of all powers of and Now the answer to the query can be obtained in linear time by checking difference between neighbouring unlucky years in sorted order Don t forget that you should handle multiplying of such big numbers very carefully For example instead of writingwhile num 1e18 num num xorwhile num x 1e18 num num xyou should writewhile num 1e18 x num num xto avoid getting overflow errors of 64 bit type Integer division will work fine in that case because will never exceed if doesn t exceed Overall complexity 
889,A simple greedy solution works simulate the process until the Modcrab is dead and make Vova drink a potion if his current health is less than and monster s current health is greater than because in this case Vova can t finish the Modcrab in one strike but the Modcrab can win if Vova doesn t heal In any other situation Vova must attack Since all parameters are up to the number of phases won t exceed 
890,Two calendars are same if and only if they have the same number of days and starts with the same day of a week So we should simply iterate over years and maintain the day of a week of January 1st for example Easy to see that the day of a week increases by one each year except of the leap years when it increases by two 
891,In this problem we can simply increase times the current time by one minute after each increasing we should check the hours and the minutes for overflow Another solution is to use the next formulas as the answer 
892,Since nephew emptying the box he s chosen and wants to make all other box equal then it means that at least the of all array should be divisible by and the number of blocks in each other box should be at least ceiling function On the other side since nephew chooses not you then he can choose a box which is a maximum and since he makes empty the only box then the final number in each other block should be at least In total the resulting number of blocks in each of other boxes should be at least and we need to add at least elements to the initial array We can always reach this lower bound if we will put each block in the box with the current minimum number of blocks 
893,The area of a triangle is equal to its base multiplied by its height divided by Let the two points that have to be on the same side of a rectangle form its base To maximize it let s choose such two points that are the most apart from each other the first and the last in the list Then the height will be determined by the distance from that side to the remaining point Since there are points on all sides the points on the opposite side are the furthest Thus the height is always one of or depending on whether we picked the horizontal or the vertical side So we have to check four options to pick the side and choose the best answer among them 
894,Let s fix number of plates to have pieces of the first cake plates left for the other cake Obviously the most optimal way to distribute pieces to plates will lead to the minimum of pieces on a plate Now try every possible and take maximum of Overall complexity 
895,Firstly let s notice the next property if two axis aligned rectangles don t intersect then we can draw a vertical or horizontal line between them In other words either max x 1 x 2 le min x 3 x 4 or max x 3 x 4 le min x 1 x 2 if x 1 and x 2 are coordinates of the one rectangle and x 3 and x 4 of the other one analogically for y coordinates Now suppose you want to move the first table by dx dy Note that if in result they will be divided by vertical line then we can set dy 0 they still will be divided but the total distance will decrease Analogically if divided by horizontal line we can set dx 0 In other words it s always optimal to move the table either horizontally or vertically Let s look at the case of horizontal move at first we need to check that both tables can fit in the room or their total width w x 2 x 1 le W If yes then we calculate the movement distance dx as follows if we move the table right then there should be at least w to the left of it or w le x 1 dx Leftrightarrow dx ge w x 1 Since we want to minimize dx then we take dx max 0 w x 1 If we want to move the table left then there should be at least w to the right or x 2 dx le W w Leftrightarrow dx ge x 2 W w minimizing dx means taking dx max 0 x 2 W w So the result is min max 0 w x 1 max 0 x 2 W w The vertical case can be handled in the same manner if h y 2 y 1 le H then the result is min max 0 h y 1 max 0 y 2 H h The answer is the minimum among all possible variants or 1 if both cases are impossible 
896,To be honest the solution to this problem is easier to code than to prove Let s follow the next strategy Write down all the letters of the string which have odd positions in alphabet and even positions in alphabet Sort both of these lists in non decreasing order The answer is either concatenation of the lists odd even or even odd or Now for the proof part Let s establish that we don t care about equal letters and leave just a single copy of each letter of the string Let s check some cases There is just a single letter That s trivial There are two letters of the same parity There is no incorrect arrangement for this There are two letters of different parity If they differ by one then no answer exists Otherwise any arrangement works There are three letters and they are consecutive in alphabet No answer exists There are other types of three letters Then the one of the different parity can put on the side e g and As the difference between at least one of these letters and that one isn t 1 that arrangement will be ok Finally there are at least 4 letters It means that the difference between either the smallest odd and the largest even or between the smallest even and the largest odd isn t 1 The only thing you need to do is to implement the check function the most straightforward way possible and check both arrangements Overall complexity 
897,Let s look at the contribution of each choice to the total number of wins we can look at total instead of average since average is equal to total divided by For example let s look at the first choice in we compare with in with in with and so on In the result we compare with all once So to maximize the total sum we need to choose that beats the maximum number of or in other words let s find the most frequent character in and choose that beats it Okay we found the optimal But if we look at the contribution of any other we can note that we compare any with all once So we can choose all equal to which is equal to the choice that beats the most frequent choice in 
898,Let be the current number of computers with the update already installed initially it is Then in hour we can increase by From here we can see that the value of will double for the first few hours and then when it becomes greater than it will begin to increase by exactly The process when the number of computers doubles can be modeled using a loop because the number of doublings does not exceed And after that we have to increase the answer by to take the number of additions of into account Note that computing should be done without using fractional data types to calculate in integers you should divide by using integer division this will work provided that both and are non negative and If you use real numbers this may cause precision issues 
899,Let s maintain the pointer to the topmost non deleted book and whether each book whether is removed from the stack or not Initially all books are in a stack and is 0 if we store the array 0 indexed We will process the array in the order If the current book is removed from the stack then the answer for it is zero Otherwise we will increment the pointer until the equality is satisfied while marking all the intermediate books in the array After that the answer for the book will be the number of marked books in the array including itself Since the pointer shifts times at total we get a solution with an complexity 
900,Vasya can decrease number of isolated vertices up to using one edge and pairing them So minimum number of isolated vertices is To calculate maximum number of isolated vertices let s keep number of non isolated vertices knowing that each pair connected by edge i e size of clique Let we have size of clique and edges remained unassigned at current step If then answer is Otherwise we need to increase clique with one vertex Maximum number of edges we can add to connect this vertex is So subtract it from and increase by one Repeat this step while greater than zero Answer is One corner case is next if then answer is not 
901,If sum limits i 1 n a i le s then answer is Otherwise let s find we minimum index x such that sum limits i 1 x a i s It s useless to skip a part i x because Vasya just has not time to recite previous part it s change nothing So he has to skip a part i le x And among such parts it s beneficial to skip part with maximum value of a i 
902,Let be the maximal segment of gold cups that begins in the cup Let be the maximum segment of gold cups that ends in the cup Also let the total number of gold cups be Note that it makes no sense to change the cups of the same color Then let s consider the silver cup which will change with the gold cup let its number be Then if then we will update the answer with the value and otherwise with the value This will not work if all the cups are golden In this case the answer is 
903,The answer can be calculated very easy by Euclid algorithm which is described in the problem statement but all subtractions will be replaced by taking by modulo 
904,Strategy is quite easy we go from to and if we take this variant we set otherwise we set Note that all are in range so there won t be any overflow underflow It s also not hard to prove that this strategy maximizes the sum By contradiction suppose the optimal answer has some index where but Let s find first position where and swap operations between and As a result all from were increased while remained the same i e there is no violation of the rules and the total sum increased contradiction 
905,Let s consider each cell as a center of a cross and take the fastest one to paint Calculating each time naively will take overall which is too slow Notice how the answer for some cell can be represented as if is white else where is the number of white cells in row and is the same for column The first two terms can be precalculated beforehand Overall complexity per query 
906,All you need to know to solve this task is the minimal number of steps to move from any digit to any digit for fixed and let s denote it as Shortest path BFS Floyd Of course you can use it but you can think a little harder and save nerves and time Since order of choosing operations and doesn t matter for transferring from to so only number of s and s are matter Let s denote them as and Since adding any fixed value times are meaningless so Now you can for each for each for each iterate over all possible and Digit you d move to is equal to Just relax value of by Now you can for each and calculate the answer by iterating over string by summing number of inserted values is less by one than number of steps But it will work only in C since the language is fast and basic operations are executed in less than 0 5 second But the model solution is written in Kotlin How is it The string can be long but there are only different neighbouring digits so you can just one time precalculate the number of such that and And calculate the answer not by iterating over but by multiplying by The result complexity is where But will pass on fast languages like C P S There are no real problem with I O both Python and Kotlin read one string up to in less than 0 5 seconds 
907,Easy to see that we can sort any array Let be the number of even positions in We can assign to those positions maximal elements and distribute other elements to odd positions Obviously the resulting array is sorted 
908,Lets divide all dealing blows into two parts the last blow and others blows The last hit should be with maximum value of The others blows should be with the maximum value of So lets denote as and as Then if the we can beat Zmei Gorynich with one blow Otherwise if then we cannot defeat Zmei Gorynich Otherwise if and the answer is 
909,Notice that there are only possible patterns in this game You can used in a following way Simulate games till one of the patterns get repeated Games between this pair of occurences will get you the same total outcome no matter when they are played Let the distance between the games with the same pattern is and index of these games are and zero indexed Total score of some interval is Then the answer will be 
910,Since you can only push boxes you can t bring boxes from negative positions to positive ones and vice versa Thus negative boxes special positions and positive boxes special positions are two separate tasks You can solve them independently with the same algorithm and add up the answers So we will only consider the positive boxes special positions case Notice that it never makes sense to move left Thus the only thing that determines the answer is the maximum position to the right you reach For a naive algorithm we could iterate over that position push all boxes that we have encountered on our way ahead of us and calculate the number of boxes that are on special positions That works in where is maximum coordinate To improve that solution we can notice that the positions that are the most optimal are actually the ones such that the first box is pushed to some special position Consider the case the first box isn t on a special position and there is a special position somewhere to the right of it There are two types of boxes the ones that are in the pile you would push if you move right and the remaining suffix What happens if you move one step to the right The number of boxes from the suffix on special positions doesn t change The number of boxes from the pile on special positions doesn t decrease This number changes depending on if there is a special position immediately to the right of the pile and underneath the first box Since we considered the case where there is no special position underneath the first box the number can t decrease So we managed to improve the solution to Still slow Let s now learn to maintain the answer while moving the boxes Precalculate the number of boxes from the th to the last one that are already on special positions That can be done with two pointers Now iterate over the special position under the first box in the increasing order Maintain the size of the pile and the number of special positions under the pile The first value is just the index of the first box not in a pile The second value is easier to obtain if you keep the index of the first special position after the pile or if there are none Also achievable with two pointers The answer is the number of special positions under the pile plus the suffix answer for the boxes after the pile Take the maximum of all options The constraints are pretty free so you could replace two pointers with binary searches if you wanted to Overall complexity per testcase 
911,This is the solution that doesn t involve masks Let s reverse the process and try to get all zeroes from the array since all we can start from maximum The key idea since then there should be no more than one position such that and we should decrease it by Now we can decrease by and repeat the same process If at any step there are at least two or as result we won t get array filled with then there is no way to build the array 
912,It is obvious that we can always take as But we don t know which value of we can take Let be for all from to The value of should be divisor of value of The maximum possible divisor of each is greatest common divisor And then it is obvious that the value of should be the divisor of So we have to find divisor of among all values If there is no such value then the answer is Time complexity 
913,Judging by constraints you can guess that the greedy approach is the right one Firstly let s transition from maximizing the arithmetic mean to the sum it s the same thing generally Secondly notice that each is being added to each element regardless of the chosen position Finally take a look at a function total sum obtained by applying change with to position and notice that it is non strictly convex Its maximum or minimum values can always be found in one of these positions method of rounding doesn t matter and Thus the solution will look like this for positive you apply the change to position and for non positive to position The impact of the change can be calculated with the formula of the sum of arithmetic progression Also you should either do all of your calculations in long double 10 byte type or maintain sum in long long you can estimate it with so it fits and divide it by in the end then double will work Overall complexity 
914,Let s carefully look at the coefficients with which the elements of the array will be included in the answer If pair of adjacent elements a i and a i 1 belong to different subarrays then element a i will be included in the answer with coefficient 1 and element a i 1 with coefficient 1 So they add value a i a i 1 to the answer If element belongs to subarray with length 1 then it will be included in the sum with coefficient 0 because it will be included with coefficient 1 and 1 simultaneously Elements at positions 1 and n will be included with coefficients 1 and 1 respectively So initially our answer is a n a 1 All we have to do is consider n 1 values a 1 a 2 a 2 a 3 dots a n 1 a n and add up the k 1 minimal ones to the answer 
915,First check that the counts of all letters are the same in both strings Then consider the following restatement of the moves The letters in the string are stationary Letters and however move around the string The move of the first type moves a letter to the right The move of the second type moves a letter to the left Notice that letters and can never swap with each other Thus if you remove all letters from both strings the remaining strings should be the same Again since letters and can never swap with each other you can deduce where each of these letters should end up after the swaps The first letter a in should be on the position of the first letter in and so on After that we recall that s can only move to the right and s can only move to the left Thus we check that the th occurrence of in is to the left or equal to the th occurrences of in and vice versa for s Finally we can see that this is a sufficient condition Easy to show by construction you can just fix the positions one after another left to right Overall complexity per testcase 
916,Find all segments of asterisks in the string Let there be of them and the number of asterisks in them be That tells us that the th segment of asterisks can be replaced with at most letters b Notice that we can compare two strings lexicographically using just the number of letters b that replace each of segments of asterisks Let that sequence for some string be and that sequence for some string be Then if and only if That is there exists such position that The proof is trivial So we can actually look at the sequence as some kind of number in a mixed base The lowest digit can be of one of values from to The second lowest one of And so on Then comparison of two strings is the same as comparison of these two mixed base numbers Thus the task is to convert number to this mixed base Turns out it s not that hard In base for example the lowest digit can be determined as the remainder of the number of dividing by Here it will be the remainder of dividing by After that divide and floor the number and proceed to the next digit After steps are done the digits of that mixed base number tell exactly how many letters b should replace each segment of asterisks Overall complexity per testcase to recover the string to print it 
917,First of all let s find out how to calculate This can be done greedily let s iterate from the higher denominations to the lower ones the number of banknotes of th type is equal to the value of here changes to reflect that we have already taken some banknotes that is we subtract from each time which is the same as taking modulo We can see that after we process the th type of banknotes the condition holds which means that the number of banknotes of th type does not exceed except in the case of Now we can find the minimum number such that Let be the number of banknotes that still remains to take initially equal to because we want to be at least Let s iterate from the lower denominations to the highest ones the number of banknotes of th type we take should be equal to the minimum of how many we need to take and how many we are allowed to take so as not to break the minimality of the function 
918,There is no solution if the given required distance is too big Let s think what is the maximum possible distance for the given string Or the more useful thing how to construct a string to maximize the distance We can treat each letter separately and replace it with the most distant letter For example we should replace c with z and we should replace y with a To be more precise for first 13 letters of the alphabet the most distant letter is z and for other letters it is a 
919,There are two important observations to make The first one is that you can calculate the answers for each university independently of each other and sum them up to obtain the true answer The second one is that if there are students in an university then that university can only contribute to answers for from to So if we learn to calculate the contribution of the th university for some fixed in then we will be able to iterate over all possible for each university and get the solution in where is the number of students in the th university To achieve it you have to gather the sum of the maximum number of students that can form full teams of size That must be the highest number less than or equal to that is divisible by so Sort the students of each university precalculate partial sums and now you are free to add the prefix sum of that number of students to the answer for Overall complexity per testcase 
920,Let s transit from counting strawberry and blueberry jam jars separately to their difference Let be equal to Then eating one strawberry jar decreases by and eating one blueberry jar increases by The goal is to make equal to Let there be some initial difference Let s eat first jars from the left and first jars from the right Difference of the jars on the left is on the right it s So the goal becomes to find such and that Rewrite that as Now for each unique value of save the smallest to reach that value in a map Finally iterate over the and find the minimum answer Overall complexity 
921,Let s notice that one swap can affect at most two cycles of this permutation Moreover you can join two cycles into one with the length equal to the sums of lengths of initial ones The function we are going to maximize is where and are the lengths of the cycles we are joining together Now its easily seen that the maximum is achived when joining two cycles with the greatest product of lengths Finally they are the two longest cycles in permutation Overall complexity 
922,Note that means either or whereas means both and We can greedily solve this by starting out our string with all 1 s then marking and as 0 whenever we are forced to because Then we can simply check whether all of the conditions are valid to confirm Code 90915688 
923,There are many different approaches to this problem dynamic programming binary search greedy two pointers anything you want The model solution uses an approach based on binary search so I ll describe it First of all why does binary search work Let s say that the number of s is If the cost of deletion is then we have deleted at most characters and have left at most characters Let s increase the number of characters we delete from the prefix of the string until the number of deleted s becomes if it s always possible So if we consider the segment of values the fact that we can get cost implies that we can get cost so we can use binary search on segment to find the minimum achievable cost Now how to check if we can obtain the cost of deletion equal to One possible way to do this is to form an array where is the position of the th character in the string and find the minimum value of in this array the string that should remain has to contain at least characters and the minimum value of is the minimum possible length of such string Then we can find the number of s in this string and check if it is greater than or not 
924,You can always show that the answer is equal to the amount of boxes of the size appearing the most in array Result can be easily obtained by constructive algorithm take these most appearing boxes put smaller boxes in decreasing order of their size into free ones there always be space and put resulting boxes into the larger ones in increasing order Overall complexity 
925,Consider the first character of the string If it is then we can remove the first two characters of the string and continue because the prefix of length will be either a palindrome or a regular bracket sequence If the first character of the string is then this is a bad case Of course the regular bracket sequence can t start with so this prefix should be a palindrome And what is the shortest palindrome we can get with the first character It is the closing bracket then some possibly zero amount of opening brackets and another one closing bracket We can see that we can t find a palindrome shorter than this one because we have to find a pair for the first character So if the first character of the string is then we just remove anything until the next character inclusive To not remove any characters explicitly we can just use pointers instead And the last thing is to carefully handle cases when we can t do any operations 
926,Let be the mirror reflection of the string For example Let string be good if it does not have a prefix which have more closing brackets than opening ones For example are good and are not The balance of the string is the difference between number of opening and closing brackets in For example 1 0 Let be the number of good strings with a balance The answer to the problem is 
927,Since we are only allowed to push the same button times in a row let s do a two pointer sweep to find all segments of consisting of just one button Within each segment we ll sort and take the highest values See the code for details on the two pointer sweep 48994498 
928,Let s set sections from left to right Note that for the th section all valid heights heights for which it s possible to choose heights for all sections meeting all rules and finishing with the height of equal to form a segment It s not hard to prove by induction For the first section the valid segment is The step of induction if the valid segment for is then valid s for is the segment since for each you can find at least one in which don t break the first rule If for any the correct segment is empty or if we can t fulfill the third rule then there is no answer otherwise at least one answer is always exist As a result to solve the problem you should just maintain the segment of valid using the formula above while iterating Complexity is 
929,The main idea in the problem is not how to solve it but how to code it neatly I ve come up with the following way Let s store three variables where is the robot now what direction does it move or and how much time is left until it stops moving The processing of the commands looks becomes pretty easy If there is no time left to move then the command is executed and we tell the robot the direction and the time left for the current command Then there are two cases either the robot stops before the next command or after it However they can be processed simultaneously Let be the minimum of the time left before the robot stops moving and the time before the next command We sure know that before the next command the robot will visit exactly the segment of positions between the current position and the current position plus direction multiplied by If the destination for the current command is in this segment then that command is successful After the command is processed subtract from the time left and increase the position by direction multiplied by Overall complexity per testcase 
930,The example tests suggest that there is only one possible distribution with a draw Let s find out why it is so We will use a process similar to induction recursion to distribute the cards between the two players so that the game ends in a draw suppose Alex receives the card Then he wins since he can play it immediately So for the game to result in a draw Boris must receive the card suppose Boris receives the card Then he wins since he also has the card he can use it to answer any first move of Alex and then win the game by playing So for the game to result in a draw Alex must receive the card suppose Boris receives the card Then he wins since he also has the card if Alex plays the card Boris responds with and then plays if Alex plays some other card Boris responds with and the plays So for the game to result in a draw Alex must receive the card and so on In fact if Alex receives the card and Boris receives the card Alex must play the card or something equivalent to it on the first move and Boris must respond with the card so we can consider the game without these two cards with the roles swapped So if we consider the distribution of cards as a string with characters and where denotes the card belonging to Alex and denotes the card belonging to Boris and the th character of the string represents the card the only possible distribution for the draw is But there s more to this string representation of the distribution of cards the first character that is different from this pattern denotes the winner if the first different character is in the draw distribution and in the distribution we consider the winner is Boris otherwise the winner is Alex This may lead us to the following ways to count the number of possible distributions which win lose for Alex we can use dynamic programming of the form where is the number of characters we used is the number of characters we used and is or depending on whether our string coincides with the draw string differs from it in a way that Alex wins or differs from it in a way that Boris wins the actual value of must be the number of ways to reach this state of dynamic programming The answer then is stored in the states of the form or we can use combinatorics let s iterate on the length of the prefix that is common in the draw string and in the string representing the distribution of cards and then count the number of ways to distribute the remaining characters with a binomial coefficient To calculate the binomial coefficients we can use one of the following methods Pascal s triangle precalculating factorials and modular inverses to then or calculating factorials with big integers in Java or Python 
931,This is a pretty obvious binary search problem If we get banned after messages we also get banned after and so on messages and vice versa if we don t get banned after messages we also don t get banned after and so on messages For simplicity let s split the problem into two parts when we check if we re getting banned after messages let s handle cases and separately Recall that the sum of the arithmetic progression consisting of integers is Let it be The first case is pretty simple the number of emotes we send with messages when is which is So we only need to check if The second case is a bit harder but still can be done using arithmetic progression formulas Firstly we send all messages for the number of such messages is Then we need to add messages This number equals to i e we send all messages from to and subtract messages from to from this amount The final condition is Time complexity per test case 
932,There are a lot of solutions for the problem Let s start with the easiest one Sort the dishes in the non decreasing order of their optimal time I claim that there is an optimal answer such that the times for each dish go in the increasing order That s not too hard to prove something along the lines of if there are two dishes and such that and then is always greater than So we can use dynamic programming to solve the task Let be the minimum total unpleasant value if dishes are processed and the current minute is For the transitions you can either put out the current dish at the current minute or wait one more minute Notice that you ll never need more time than minutes the actual constraint is even smaller just consider the case with all dishes times equal to So that dp works in The other possible solution is matching Let s build the following graph The left partition is vertices corresponding to dishes The right partition is vertices corresponding to minutes as we saw in previous solution is always enough Now add the edges between all dishes and all minutes with the cost of their absolute different Finally find the minimum cost maximum matching That can be done with MCMF or Hungarian algorithm Both should pass pretty easily There s also a solution in involving the slope trick 
933,Since is odd exactly pieces of the board will have upper left corner colored black and exactly white Let s check every option to choose two pieces of the board so their upper left corners will be painted white when we assemble the board calculate the number of board cells that have to be recolored and find the minimum of this value among all possible choices 
934,We cannot utilize the explosion of the last monster we kill So the naive approach is to iterate on the monster we kill the last break the circle between this monster and the next one and then shoot the first monster in the broken circle until it s dead then the second one and so on Let s calculate the number of bullets we will fire this way If the circle is broken after the monster then the first monster gets bullets the second one and so on all monsters except the first one get exactly bullets So we should choose an index such that is minimum possible since this is the number of bullets we have to spend additionally since we cannot utilize the explosion of the th monster After breaking the circle between the monsters and you may use a formula to calculate the required number of bullets or just model the shooting 
935,There are quite a few approaches to the problem I ll describe the two of them which I actually implemented First approach combinatoric one Problems of the form count the number of beautiful numbers from to usually require counting the numbers on and or not inclusively and and subtracting one from another Let s try this thing here counting not inclusively Let s fix some prefix of the upper border number We want to calculate the amount of numbers having the same prefix but being smaller in the next digit If we count it for all prefixes including the empty one we will get the answer And that is pretty easy Let the prefix include non zero digits the length of the suffix be and the digit after the chosen prefix is If is zero then there the result is obviously zero Otherwise we can either put or any of the non zero digits Then the formula is We choose positions from the suffix to put non zero digits in them any digit from to and fill the rest with zeros Overall complexity Second approach precalc one This is a bit easier to implement Actually there are just about 700000 valid numbers you can generate them all put them into the array in sorted order and binary search for the given queries Overall complexity 
936,First observe that each of the players has only m options for their path which column to go down in Let s consider a Bob s response to a strategy chosen by Alice The easiest way to approach that is to look at the picture of the Alice s path The path clearly separates the field into two independent pieces suffix of the first row and the prefix of the second row Bob can t grab the coins from both of them at once However he can grab either of them fully So the optimal path for him will be one of these two options You can precalculate some prefix sums and become able to get the Bob s score given the Alice s path Alice has m possibly paths so you can iterate over them and choose the minimum answer However prefix sums are not required since you can quickly recalculate both needed sums while iterating over the Alice s column to go down in Overall complexity O m per testcase 
937,Suppose we build the string from left to right and when we place the i th character we ensure that all substrings are valid What do we need to know in order to calculate the number of different characters in the string ending with the i th character Suppose the character s i is Let s try going to the left of it The string from i to i will have the same characters but if there is at least one character before the i th position the string s 1 s 2 s 3 dots s i will have two different characters What about the strings in the middle The string s j s j 1 dots s i will contain different characters if and only if there is at least one in j i since s i is so we are actually interested in the position of the last character before i The same logic applies if the character s i is we are only interested in the position of the last before i and it is enough to check if all substrings ending with the i th character are violated What if when we choose the i th character we violate some substring that doesn t end in the i th position Well you could also check that or you could just ignore it Actually it doesn t matter if this happens because it means that the substring that is violated ends in some position k i and we will check it when placing the k th character So the solution can be formulated with the following dynamic programming let dp i j be the number of ways to choose the first i characters of the string so that the last character different from s i was s j or j 0 if there was no such character and all the constraints on the substrings ending no later than position i are satisfied The transitions are simple you either place the same character as the last one going from dp i j to dp i 1 j or a different character going from dp i j to dp i 1 i and when you place a character you check all the constraints on the substrings ending with the i th position Note that the state dp 1 0 is actually represented by two strings and This solution works in O n 3 although O n 4 or O n 2 implementations are also possible 
938,This problem with small coordinates can be solved using partial sums and some easy counting Let s carry an array where will be equal to the number of segments that cover the point with coordinate How to calculate in For each segment let s add to and to Now build on this array prefix sums and notice that equals the number of segments that cover the point with coordinate Then will be equal to All the answers can be calculated in in total So the total complexity of this solution is But in our problem it is too slow to build an entire array So what should we do It is obvious that if any coordinate is not equals some or some then So we do not need carry all the positions explicitly Let s carry all and in some logarithmic data structure or let s use the coordinate compression method The coordinate compression method allows us to transform the set of big sparse objects to the set of small compressed objects maintaining the relative order In our problems let s make the following things push all and in vector sort this vector keep only unique values and then use the position of elements in vector instead of original value any position can be found in by binary search or standard methods as in C So the first part of the solution works in Answer can be calculated using almost the same approach as in solution to this problem with small coordinates But now we know that between two adjacent elements and there is exactly points with answer equals to So if we will iterate over all pairs of the adjacent elements and and add to the we will calculate all the answers in So the total complexity of the solution is 
939,At first notice that if only programmers are taken then the same or even better answer can be achieved if strongest programmers are taken Now let s sort the programmers in a non increasing order and choose some assignment into the teams For each team only the rightmost taken programmer of that team matters the sorted sequence implies that the rightmost is the weakest Take a look at the team with the strongest weakest member If the number of programmers in it is less than the position of the weakest member then you can safely rearrange the programmers before him in such a way that none of parameters of later teams change and the weakest member in the first one only becomes stronger After that you can get rid of the first team as it takes exactly the prefix of all the programmers and proceed to fix the later teams Thus we can see that there is an optimal solution such that each team is a segment and all the teams together take some prefix of the programmers So we can finally run a greedy solution that takes programmers from left to right and increases the answer if the conditions for the latest team hold Overall complexity 
940,First of all instead of the mathematic mean let s consider the sum of elements If the mathematic mean is then the sum of elements of the array is Let s denote the sum of elements in the original array as Note is always an integer If we remove two elements from the array the resulting sum of elements should become So the sum of the elements we remove should be exactly If is not an integer the answer is to check that you can simply compare with Otherwise we have to find the number of pairs such that and This is a well known problem To solve it you can calculate the number of occurrences of each element and store it in some associative data structure for example in C Let be the number of occurrences of element Then you should iterate on the element you want to remove and check how many elements match it that is how many elements give exactly if you add to them The number of these elements is just Let s sum up all these values for every element in the array Unfortunately this sum is not the answer yet We need to take care of two things if for some index then matches itself so you have to subtract the number of such elements from the answer every pair of elements is counted twice the first time when we consider the first element of the pair and the second time when we consider the second element of the pair So don t forget to divide the answer by 
941,First why can you always make the arrays similar Applying a digital logarithm to any number will eventually make it equal to Thus you can at least make all numbers into s in both arrays Then notice the most improtant thing applying the digital logarithm to a number greater than always makes this number smaller Thus if a number appears in only one of the arrays you will have to do one of the followings two things decrease some greater number to make it equal to this one decrease this number What if there is no greater number at all This is the case for the largest number in both arrays altogether If it appears in only one of the arrays you must always decrease If it appears in both though why decrease it further Worst case you will decrease it in one array then you ll have to decrease it in the other array as well This is never more optimal than just matching one occurrence in both arrays to each other and removing them from the arrays So the proposed solution is the following Consider the largest element in each array If they are equal remove both If not apply digital logarithm to the larger of them Continue until the arrays are empty What s the estimated complexity of this algorithm Each number in the first array will be considered at most the number of times you can decrease it with a digital logarithm operation plus one That is at most a number greater than always becomes a single digit and a single digit always becomes Same goes for the second array So the complexity is basically linear To implement it efficiently you will have to use some data structure that provides three operations peek at the maximum remove the maximum insert a new element The perfect one is a heap priority queue in C Overall complexity per testcase 
942,Let s declare a function which takes number as a string and erases minimal number of digits in substring from nd to last character to obtain beautiful number Note that if the answer for given string exists then this function will erase no more than digits If the number is divisible by then sum of its digits is also divisible by So here are the only options for the function Sum of digits is already equal to modulo Thus you don t have to erase any digits There exists such a digit that equals sum modulo Then you just have to erase this digit All of the digits are neither divisible by nor equal to sum modulo So two of such digits will sum up to number which equals sum modulo Let positions of non zero numbers be Then you can easily see that its enough to check only three function outputs on substrings We imply that all digits to the left of the taken non zero digit are erased As we can erase no more than digits these options will cover all the cases If there exists no answer for any of substrings than you need to check if the number contains it will be answer in that case If there is no then answer is Otherwise the answer is the function output of maximal length Overall complexity 
943,Let s prove that division possible if and only if union of all segments has two and more segments If the union have at least two segments then we can choose one of them and put all segments it contains in one group and other segments to another group On the other hand if we can divide all segments in two groups in such way that there are no pair from different group which intersects then union of segments from the first group doesn t intersect union of segments from another and union of unions consists of several non intersecting components How can it help If union of segments consits of several segments then exists such that for any segment either or and both parts are non empty Moreover equals to one of It leads us straight to one of possible solutions sort all segments by in increasing order and for each we should check that suffix minimum If we ve found such then all prefix goes to one group and suffix to another 
944,Firstly note that if we want to buy as many packs as possible then it s optimal to buy the cheapest packs In other words if we sort all packs we ll always buy a prefix of array Next note that each day we buy some number of packs so instead of iterating through the days we can iterate through the number of packs and for each calculate the number of days we ll buy exactly packs Since the prices increasing and at day the price is then exists last day such that as days we could buy packs and at days we can t And we can find as maximum possible integer solution to inequation or We can calculate all using prefix sums in linear time As a result we buy packs in days in total packs in days in total packs in days in total and so on The resulting complexity is because of sort 
945,At first let s prove that the shortest dominated subarray has pattern like with and dominated by value Otherwise we can decrease its length by erasing an element from one of its ends which isn t equal to and it d still be dominated Now we should go over all pairs of the same numbers and check its subarrays Or not Let s look closely at the pattern if and all are pairwise distinct then the pattern is dominated subarray itself Otherwise we can find in our pattern other shorter pattern and either the found pattern is dominated or it has the pattern inside it and so on What does it mean It means that the answer is just the shortest pattern we can find And all we need to find is the shortest subarray with the same first and last elements or just distance between two consecutive occurrences of each number We can do it by iterating over current position and keeping track of the last occurrence of each number in some array Then the current distance is The total complexity is 
946,Imagine that all elements of are distinct This way sorting in increasing order will fix the order of If turns out sorted in a non decreasing order then the answer exists Otherwise it doesn t To obtain the sequence of swaps you can sort with any comparison based sorting algorithm you want even bubble sort will not exceed the allowed number of swaps What changes if has repeated elements Distinct elements are still ordered among themselves but now there are also blocks of equal elements For each block look into the corresponding values in Obviously these have to be sorted in a non decreasing order Rearrange them as they should be In fact this is exactly the same as sorting the sequence of pairs with a default comparator first by then by Since we fixed the wanted order we can proceed with the same steps we made in a distinct case Overall complexity or per testcase 
947,First observation closest points to any point form a contiguous subsegment so Second observation for any contiguous subsegment all points this subsegment closest to also form a contiguous segment And because of the nature of value of is minimal in borders and So all we need is to check all and But what is a value of It s such point that but So it s just in the middle of segment Note that and so it s enough to check only s In result all we need is to find minimal possible value and resulting 
948,This is an implementation problem You should do exactly what is written in the problem statement On my mind the simplest way is to find the position of the first not zero digit and the position of the dot The difference between that positions is the value of if the value is positive you should also decrease it by one 
949,There is a criterion when the given network becomes fault tolerant the network becomes fault tolerant if and only if each of corner computers let s name them and is connected to the other row From the one side if WLOG is not connected to other row then if is broken loses connection to the other network since is connected only with From the other side suppose WLOG is broken then the row is falling in at most two parts and But since both and are connected to row and is still connected then the resulting network is still connected Now the question is how to connect all corner computers Because sometimes it s optimal not to connect corners directly One of the approaches is described below Let s look at Essentially there are three ways to connect it to row to or where is with minimum possible The same applies to So let s just iterate over all these variants For each of these variants if we didn t cover then we should also add one more connection between and if we didn t cover then we should also add one more connection between and As a result we choose the best variant 
950,Let s precompute for each value its position in permutation It s easy to do in linear time Consider some foe pair we may assume Let s store for each value the leftmost position such that is a foe pair Denote that value as Now let s iterate over the array from right to left and maintain the position of the maximal correct interval with the left end in the current position To maintain the value we should simply take the minimum with the value And finally we should increment the answer by the value 
951,Imagine the same task but without the first term in sum As the sum of the array is fixed the best second segment should be the one with the greatest sum This can be solved in with partial sums When recalcing the best segment to end at position you should take minimal prefix sum from to inclusive from the whole sum you want to subtract the lowest number Now let s just iterate over all possible ends of the first segment and solve the task above on the array without this segment Oveall complexity 
952,If the answer exists then each element of string matches with some element of string Thereby string must be a subsequence of string Let equal to the number of occurrences of the letter in the string Then for any letter condition must be hold So the answer to the query is if following conditions hold string is subsequence of string for any Latin latter 
953,Note that is a fairly large number of operations Therefore we can first collect all the chips in one cell and then go around the entire board Let s calculate the required number of operations First let s collect all the chips in the cell To do this let s do operations so that all the chips are in the first row then do operations After such operations wherever the chip is initially located it will end up in the cell After that we need to go around the entire board Let s do it in such a way that the rows with odd numbers are be bypassed from left to right and the even ones from right to left We also need operations to move from one row to the next one In total we got operations which is completely suitable for us 
954,This task was designed as a simple dynamic programming problem but it also can be solved greedily The dp solution is following when we have already built some prefix of the pipeline all we need to know is the length of the prefix the height of the pipeline s endpoint or So we can calculate the following dynamic programming is the minimal answer for prefix of length with pipeline at height Transitions are quite straightforward if then we can either leave the pipeline on the same level or change it If then we have to stay on the height Look at the source code for the formal transitions The answer is The greedy solution is based on the following fact let s look at some subsegment consisting of s It s always optimal either to leave this subsegment on height or raise it to height We can calculate the amount we have to pay in both cases and choose the optimal one 
955,Let s analyze when the string is good Suppose it is The cyclic shifts of this string are and We get the following constraints for a good string If the string has odd length then all characters should be equal to each other otherwise all characters on odd positions should be equal and all characters on even positions should be equal Now since there are only different types of characters we can brute force all possible combinations of the first and the second character of the string we want to obtain there are only of them and for each combination greedily construct the longest possible subsequence of beginning with those characters in 
956,We use zero indexing in this solution We also use half closed interval so subarray is Let s precalculate the array where so if sum of first elements of Then subarray is good if so Thus we have to group all prefix by value for from to And if the have prefix with same value of then we have to add to the answer 
957,Why is there a constraint of each column having at least one black cell Does the problem change a lot if there were white columns Well if such a column was inbetween some black cells then the answer would be If it was on the side of the grid you could remove it and proceed to solve without it So that doesn t really change the problem other than removing some casework Let s try to fix a start Find a column that has only one black cell in it If there are no such columns the answer is immediately Otherwise the path will always go through it in known directions to the left and to the right if both of them exist Let s solve the problem separately for the left part of the path and for the right one find a path that starts to the left of it and covers everything to the left and the same for the right part Consider the right part If the next column also has one black cell then we can determine where to go uniquely If this cell is on the opposite row then the answer is Otherwise go there and proceed further Let it have two black cells now Find the entire two black row rectangle of maximum size that starts there If there s nothing after it you can easily traverse it any way you like Otherwise you have to traverse it in such a way that you end up in its last column then go to the right from there Turns out there s only one way to achieve that Go up down to another row go right up down to another row right and so on Now you just have to check if you end up in the correct row Thus you can simulate the path to the left and to the right and check if you never get stuck Overall comlexity per testcase 
958,Let s call the segment good if it contains no more than zeroes Note if segment is good than the segment is also good So we can use the method of two pointers the first pointer is and the second is Let s iterate over from the left to the right and move while we can to do that we should simply maintain the number of zeroes in the current segment 
959,Consider the naive solution Iterate over Then iterate over the segment that will have the maximum sum Let its length be Since is non negative it s always optimal to increase the elements inside the segment So if then the sum of the segment increases by Otherwise only the elements inside the segment will affect the sum thus it will increase by That can be written as Notice that we only care about two parameters for each segment Its length and its sum Moreover if there are several segments with the same length we only care about the one with the greatest sum Thus the idea of the solution is the following For each length find the segment of this length with the greatest sum Then calculate in by iterating over the length of the segment Overall complexity per testcase 
960,At first suppose that if not swap them Let s look at the case where We can be sure that there will be a situation where the th plank is painted in blue and plank is painted in red It s true because it s equivalent to the solution of equation And all we need to check that interval contains less than red planks Or in formulas The situation with is almost the same if we look only at positions which are divisible by in other words we can just divide on and on and check the same condition 
961,Easy to see that we can paint with both colours only tiles with the numbers multiple of Obviously that tiles should be painted with more expensive colour So the answer equals to 
962,Note that if there are at least two members with the maximum value of then any permutation is nice Now let s consider the case when there is only one maximum Let s find out when the permutation is nice Let be the index of the jury member with the maximum number of tasks Then during the th discussion round they will be the only one who will tell their task because the other members of the jury have already told all their tasks So during the th discussion round there should be a jury member who tells a task after the th jury member Let be the number of elements in the array equal to Then if at least one of these jury members goes after the jury member in the permutation then the permutation is nice Using this we will count the number of bad permutations Let s fix the elements in the permutation that are not equal to or there are of them then the number of ways is It remains to place elements so that the maximum is in the last position among them there are such ways The total number of bad permutations is So the answer is 
963,At first notice that the final answer is minimum over answers for each character The answer for one character can be obtained like this Write down lengths of segments between two consecutive occurrences of this character from the first occurrence to the start of the string and from the last to the end of the string Take maximum of these values Answer will be this maximum 1 Overall complexity 
964,First of all let s understand how to solve the problem without upgrades To do this it is enough to compare two numbers and the number of attacks that the character needs to kill the monster and the number of attacks that the monster needs to kill the character respectively So if the first number is not greater than the second number then the character wins Note that the number of coins is not very large which means we can iterate over the number of coins that we will spend on weapon upgrades and the remaining coins will be spent on armor upgrades After that we can use the formula described above to check whether the character will win The complexity of the solution is 
965,At first sort all in non decreasing order Let be first position that if Then each barrel should have at least one stave from segment So if answer is Otherwise for each from to let s take no more than smallest staves from this segment in the th barrel but in such way that there are at least staves left for next barrels 
966,Denote s the sum of elements in array If s is divisible by n then the balanced array consists of n elements In this case the difference between maximal and minimal elements is 0 Easy to see that in any other case the answer is greater than 0 On the other hand the array consists of numbers and numbers is balanced with the difference equals to 1 Let s denote this balanced array b To get array b let s sort array a in nonincreasing order and match element ai to element bi Now we should increase some elements and decrease others In one operation we can increase some element and decrease another so the answer is Complexity O nlogn 
967,Suppose we ve built the graph and chosen any simple cycle Due to the nature of the graph any simple cycle right part is part of one of the chains So let s for each chain calculate the longest simple path with its right part on this chain and denote it as Obviously Now let s look at chain If we go along the cycle in both ways we will step to vertices and of the previous chain If then we closed cycle and it s the only possible cycle so Otherwise we can either go from and and meet each other closing the cycle with part of the th chain between th and th vertices this part has edges and our cycle will have length But if we decide to go in different ways then we will meet the first and the last vertices of the th chain After that we ll go to the th and the th vertices of th chain and will make almost the same choice But instead of recurrently solving the same problem we can note that in fact we took a cycle that ends at the th chain erased the part between vertices and and merged it with our th chain part so the length of this merged cycle will be equal to Since we maximize we just choose what part or is longer and take it As a result we can iterate from left to right calculate all and print the maximum among them 
968,The solution can be got from the second sample testcase Easy to see that if we place all odd numbers in the center in form of rhombus we will get a magic square 
969,Note that if we can reach the destination in days so we can reach it in days since we can stay in the destination point by moving to the opposite to the wind direction So we can binary search the answer To check the possibility to reach the destination point in days we should at first look at the position the wind moves ship to Now we can calculate where we can go since each day we can move in one of four directions or not move at all we can reach any point with Manhattan distance So we need to check that To calculate we can note that there were full cycles and extra days So it can be calculated with time using prefix sums Finally about borders of binary search to reach the destination point we need to move closer at least by one it terms of Manhattan distance from the full cycle of the wind So if answer exists then it doesn t exceed 
970,Let s iterate over height of slice in decreasing order All we need to know is a number of towers with height more than name it and sum of its heights Current slice on height is good if Let s greedily decrease value while slice on is good keeping correct values and When we found minimal good slice we can perform it increasing answer by one and changing tower heights just by setting new value to equal to Finish algorithm when becomes equal to minimal height of towers and make final slice 
971,Let s denote cntc the number of occurences of symbol c Let s consider odd values cntc Palindrome can not contain more than one symbol c with odd cntc Let s denote symbols with odd cntc as a1 a2 ak in alphabetical order Let s replace any one of symbols ak with symbol a1 ak 1 with a2 and so on until the middle of a Now we have no more than one odd symbol If we have some let s place it in the middle of the answer First half of answer will contain occurences of symbol c in alphabetical order The second half will contain the same symbols in reverse order For example for string s aabcd at first we will replace d by Unable to parse markup type CF TEX abcba Compexity O n 
972,Let s figure out criteria for the bad triple It s not hard to prove that the triple is bad iff point lies inside the bounding box of points and In other words if and Now looking at points and we can see that the bad situation may arise only if so we can check only ordered triples Looking closely at inequality we can note that there are two situations where forms a bad triple when either or In other words subarray is bad if and only if it contains either non decreasing subsequence of length or non increasing subsequence of length The final observation is that any sequence of length at least contains either non decreasing or non increasing subsequence of length It s not hard to prove it either brute forcing all possible variants of relative orders on paper or searching remembering the theorem that says it As a result you need to check only subarrays of length at most whichever the way you want The complexity is 
973,Let s denote the points that have greater coordinates in their matched pairs as points and the points that have smaller coordinates as points Suppose we have an point that has smaller coordinate than some point Then we can swap them and the answer won t become worse Also if some point has smaller coordinate than some point that doesn t belong to any pair or some point has greater coordinate than some point that doesn t belong to any pair we can swap them too So if the answer is we choose leftmost points as points and rightmost ones as points For a fixed value of it s easy to see that we should match the leftmost point with the leftmost point the second point with the second point and so on in order to maximize the minimum distance in a pair This fact allows us to check whether it is possible to construct at least pairs and we can use binary search to compute the answer to the problem 
974,You can notice that moves of kind and are changing value to and Thus you can determine by checking adjacent nodes in the path The answer is if there are one or zero distinct values of differences not counting difference of You can also set to arbitrary big value it doesn t really matter until you can fit all values will work just fine Finally knowing and simulate the process and check that all moves are valid Overall complexity 
975,Notice that GCD of the resulting sequence is always a divisor of Now let s iterate over all divisors up to Current divisor is One of the ways to retrieve resulting sequence is to take their sum is The last number is You should check if is the sum of arithmetic progression its equal to Don t forget that you should consider and if you check divisors up to Take maximum of possible divisors or output if there were no such divisors Overall complexity 
976,Every beautiful set can be represented as a sequence of its elements in sorted order Let these elements for some set be also let When the set is beautiful every is an integer greater than It s easy to see that if and belong to the whole set belongs to Since in order to maximize we need to choose and as small as possible So why don t we choose and every This will allow us to calculate the maximum possible size of a beautiful set let be this maximum possible size Okay what about counting those sets The claims and that every are no longer true by default However there are some constraints on Firstly every If we had some value of we could replace it with two values of and the size of the set would increase Secondly there is at most one If there are two values we could replace them with three and the size of the set would increase as well So the sequence contains at most one value and the rest of the values are We will divide the sets we want to count into two categories the ones with all and the ones with one value To count the sets in the first category we simply need to count the number of different minimum values in those sets Those minimum values have to be such that multiplying them by wouldn t make them greater than so these are all integers from the segment For every such integer there exists exactly one set of the first category To count the sets in the second category we do a similar thing The minimum value in the set should be from the segment but for every integer from this segment there are different sets of the second category since there are ways to choose which is equal to 
977,To solve this problem we need to use some math and solve the equation on the paper If then and transforms to or Then where So if then or if there is no answer Since values are small calculating answer in was enough all we need to do is just output answer with sufficient number of digits after the decimal point 
978,If the array is already sorted then the answer is Otherwise there is a last operation after which the permutation takes the form Which means that the elements and are selected as the last operation because they are at the first and last positions after the operation Now we know that the last operation is and it doesn t matter where exactly these numbers are in the permutation i e we can assume that the answer has increased by and consider only the numbers 1 Similarly for the remaining permutation there are two options either it is sorted and then the answer is or there is a last operation and the numbers and are used in it And so on until the remaining permutation is sorted or empty It remains to find out how to quickly check whether the numbers in the segment are sorted they go in the correct order in the initial permutation Note that this segment corresponds to values of elements not to positions in the permutation If this segment is sorted for some then the answer does not exceed There are several ways to check let s consider one of them Note that if the segment is sorted for some value then it will be sorted for large values as well So we can start with the maximum value of which is equal to and decrease it until the segment remains sorted Now for each we need only two checks that and where is the position of the element in the permutation Thus we got the solution in linear time Another way is to run binary search on since if the numbers in appear in the permutation in sorted order the same holds for This approach yields a solution in 
979,For the start let s note that for each Otherwise there is no way to get from Firstly let s calculate for each Since all then is always greater or equal than you get it from So the minimum would come from lowest that still Since is sorted we can find such with in Let s prove that we can build such that transforms to we found earlier Let s just make for for and It s easy to see that all are non negative so such is valid Now let s calculate Suppose we transform to for some It s not hard to prove that the proving array may be constructed in the similar way for for and In order to build such array you need for each In other words if there is some position such that and you can t choose such that It means that we can iterate in descending order and just keep track of leftmost with Then is equal to or if there are no such The resulting complexity is because of the first part But it can be optimized to if we use two pointers instead of 
980,On every step you should maintain minimal alphabetic letter in current string this can be done by keeping array of 26 cells with number of times each letter appear in string nd updating it on every step Let s call string a stack and use its terms Now you extract letters from one by one Put the letter to the top of the stack Pop letters from the top of stack and push them to answer while they are less or equal than any letter left in string After string becomes empty push all the letters from stack to answer The answer will be lexicographically minimal It is obvious if we consider the case when current top of stack is strictly greater than any character from the remaining string or there is a character in that is strictly less than current top If current top is equal to some character then appending answer with the letter from top won t make answer worse Overall complexity where is the length of the alpabet in our case 
981,Let s consider two sequences of digits and there is the first even digit in is the second even digit and so on and is the first odd digit in is the second odd digit and so on Since you can t swap digits of same parity the sequence of even digits of never changed Sequence of odd digits of also never changed So the first digit in the answer will be equal to or to And since we have to minimize the answer we have to chose the as the first digit in answer and them delete it from the corresponding sequence in this way sequence turn into or sequence turn into Second third and followings digits need to choose in the same way 
982,Suppose we decided to make exactly turns or in other words our path will consist of exactly segments Since we should finish at point and vertical and horizontal segments alternates then it means that and From the other side we should minimize But it means that we can minimize and independently How to minimize if we know that and It s easy to prove that it s optimal to assign all except minimum and assign to this minimum the remaining part In other words to calculate the optimal path consisting of segments we need to know the sum of on odd and even positions among and also minimum among odd and even positions Then we can drive out the answer as a quite easy formula Finally we should iterate over all from to and find the minimum answer among all variants It s easy to recalculate sums and minimums when we make transition form to Complexity is 
983,If is odd then we can solve the problem without any ties each team should win exactly matches and lose the same number of matches Finding which matches each team wins and which matches each team loses can be done with some graph algorithms like Eulerian cycles or circulations or with a simple construction place all teams in a circle in any order and let the th team win against the next teams after it in the circle and lose to all other teams Unfortunately if is even we need to use some ties since the total sum of scores over all teams is exactly when there are no ties and this number is not divisible by when is even Each tie reduces the total sum by and the minimum number of ties to make divisible by is since So if we find an answer with exactly ties it is optimal And it s easy to find one once again place all teams in a circle in any order make the th team win against next teams in the circle lose against previous teams in the circle and tie with the opposite team in the circle 
984,Let s work with the formula a bit Let then the formula becomes Considering thus is strictly increasing and has its minimum at So the solution will be to sort the list extract the pairs of sticks of equal length and check only neighbouring pairs in sorted order for the answer Overall complexity 
985,Let s present the following greedy approach The numbers will be restored in pairs and so on Thus we can have some limits on the values of the current pair satisfying the criteria about sort Initially and they are updated with Let be minimal possible in the answer Take and That way was chosen in such a way that both and are within the restrictions and is also minimal possible If was any greater than we would move both limit up and limit down leaving less freedom for later choices Overall complexity Funnily enough I coded some naive solution just to test main correct and with restriction of on numbers it passed all tests in 300 ms at max After I saw that I guessed why it worked in but it looked fun nonetheless 
986,Alice wants to choose such a segment that is maximum possible There is a well known problem where you have to find a segment with maximum That problem is solved with Kadane algorithm Let s learn how to reduce our problem to that one Notice that the values in the array are unusually small Let s iterate over the maximum value on segment Let be the current value If we make all such that equal to then it will never be optimal to take them in a segment Find the maximum sum subarray in that modified array and update the answer with its Notice that you can ignore the fact if there is a value exactly equal to on the maximum sum segment If there isn t then you ll update the answer with a smaller value than the actual one Let the actual maximum on the maximum sum segment be some You can see that for any value between and the maximum sum segment will always be that chosen one Thus when you reach you ll update the answer with the correct value Overall complexity 
987,Consider the problem with There is a single monster with some health that appears at some second In order to kill it we have to wind up our spell until it has damage So we have to use it from second to second Look at it as a segment on a timeline Actually to avoid handling zero length segments let s instead say that a segment covers the time from non inclusive to inclusive producing a half interval This way the total mana cost will be where is the length of the half interval Now There are two time segments If they don t intersect segments and don t intersect since they are half intervals then it s always better to wind up the spell for the monsters separately instead of saving the damage However if they intersect then we don t have the choice other than to save the damage from the earlier one to the later one Otherwise there won t be enough time to wind up the spell What that means in a mathematic sense The answer is the union of two half intervals If they don t intersect they are left as is Otherwise they become one half interval that covers them both Now add the third monster into the construction The same argument applies While there exists a pair of intersecting half intervals keep uniting them The union of all half intervals can be found in but the constraints allowed slower approaches as well 
988,If then our friend always needs one skip point because he always has to kill the first boss Let s just remove this boss from our consideration and increase the answer if needed What about other skip points Firstly let s understand that we can always do our moves in such a way that the first hard boss will always be killed by us except the first one So if it s our friend turn now and there is only one easy boss before the hard our friend just kills this easy boss If there are two easy bosses he kills both If there are three friend kills the first we kill the second and he kills the third And so on So we can always assume that each segment of hard bosses starts with our move We can kill each such segment greedily we kill two bosses and our friend kills one If there are less than three bosses in the segment we just kill remaining and proceed So if the length of the current segment of hard bosses is then we need skip points Summing up these values over all segments we get the answer and don t forget that the first boss should be handled separately Segments of ones can be extracted using two pointers There are also dynamic programming solution but I found this one more clever 
989,Obviously sorting the tasks by difficulty will always produce the most optimal order of solving In that case ability to solve some task will mean ability to solve any task from to Now let s maintain the upper limit of difficulty of problem Makes is able to solve Right after solving some problem it will be Initially it s just Transition from to will then look like this If the upper limit it greater or equal to then we solve this problem and update the upper limit Otherwise we will need some problems from other judges As our goal is to maximize the upper limit the most optimal task to solve is the hardest possible So you should solve task with the difficulty of upper limit and update the limit itself Keep doing it until upper limit becomes grater or equal to You will require no more then tasks from the other judges By algorithm it s easy to see that by solving task with difficulty we update upper limit with the value This function produces such a estimate Overall complexity 
990,At first it s optimal to take candidates with maximal levels for a fixed subject At second if we fix number of participants in each subject for some delegation then it s always optimal to choose all subjects with positive sum of levels It leads us to a following solution Let s divide all candidates by it s and sort each group in non increasing order In result we can just iterate over all prefix sums for each group and update global answer of current length with current sum if it has a positive value 
991,Let s sort segments firstly by their left border in increasing order and in case of equal by their right border in decreasing order If there is any valid pair then the inner segment will always go after the outer one Now you can go from left to right keep the maximum right border of processed segments and compare it to the current segment Overall complexity 
992,The first intention after reading the problem is to reformulate it in graph theory terms Let people be vertices edge between two vertices and exists if and have some group in common Basically if person starts distributing the news everyone in his connectivity component recieves it Thus the task is to calculate the number of vertices of each vertex component As of now the graph can have up to edges consider the case where everyone is in the same group Let s reduce the number of edges without changing connectivity components For each group you know for sure that people in it are in the same component Let s connect not just every pair of vertices in it but every pair of neighbouring ones in each group It s easy to see that they are still in the same component This graph will have edges which is a much smaller number You can use dfs or dsu to find the components and their sizes Overall complexity 
993,At first let s look at sequence Let s prove that the number of inversions in is the same regardless of what are the only condition is that should be distinct Let s group all elements by their value there will be or elements in each group Then we can take any two groups with values and and calculate the number of inversions between elements in these groups It s easy to note that construction will always be like or and regardless of or in both cases there will be exactly two inversions between groups equal to and to or one inversion in the second case So the total number of inversion will be equal to Now we can split sequences and into two parts Let then the first part is elements from segment and the second is from Note that the second parts both in and are exactly the sequence described above The total number of inversions is equal to the sum of inversions in the first part in the second part and the inversions with elements from both parts Note that in the first and the third components are equal to and the second component is constant so in we must also have inversions in the first part and inversion between parts It means that must start from But since the number of inversions in the second part is constant we can set the remaining elements the way we want And since we want to build lexicographically maximum we should make the second part as In the end optimal is The permutation to make such is equal to 
994,This problem can be solved differently For example you can use some data structures or sqrt decomposition technique But it is not required We expected the following simple solution from the participants Let s preprocess the following values the position of the first element to the left from the th element such that Now to answer to the query we should check if then we have the answer Otherwise we should check the position 
995,Note that if Bob has increased some element then Alice can t remove it on the next stages Obviously it is more profitable for Bob to prohibit the smallest element of the array Using this fact we can iterate over the value of and then simulate the game process To simulate the game we can maintain the set of elements that Alice can remove On the th stage Alice removes the maximum element such that if there are no such elements then Alice lost Bob always removes the minimum element of the set Thus the complexity of the solution is for each test case There is another possible solution we can notice that if Alice wins Bob will prohibit the elements on positions of the sorted array So Alice has to delete the next elements So if the segment of the sorted array can be deleted by Alice during the game phases she wins with this value of 
996,It s easy to see that we can t get the result less than because if we merge two positive numbers and at least one of them is or greater the new number is always greater than So we can t get rid of all numbers greater than To always achieve we can use a greedy algorithm always merge two maximum numbers During the first step we merge and get then we merge and get then we merge and get and it s easy to see that the last operation is merging and so the result is 
997,The answer is when in string there is a character that is not in string Otherwise let s precalculate the following array minimum index from to such that if there is no such index then Now we can solve this problem by simple greed Presume that now and last taken symbol in is Then there are two options if then if then and is equal to initially 
998,Let be the number of painters that are painting the th section Let s fix the first painter denote his index as we won t take and decrease the numbers of array in the range which he paints Then we may new array such that is equal to if and only if and otherwise This array corresponds to segments that are painted by only one painter After that we build prefix sum array on array This should be done in Now for each remaining painter we can count the number of sections that are painted only by him For painter it will be equal to Let s denote it as Finally find an painter with the minimum value of denote it as The answer if we choose painter as one of two that won t be hired will be equal to where is the number of elements greater than in the array after removing the painter And of course we should do the same for all painters 
999,Let s group the cells by their distance from the starting point the group consists of a single cell the group consists of the cells and and so on In total there are groups Let s analyze the groups and There are two cases if or then we are looking at the starting cell and the ending cell and their contents should be equal otherwise suppose two cells and belong to the same group We can easily prove that the contents of these two cells should be equal for example by analyzing two paths that go through cell and coincide after this cell but one goes to from and another from and using induction we can prove that the contents of all cells in a group should be equal And since the paths should be palindromic the contents of the group should be equal to the contents of the group So in each pair of groups we should calculate the number of s and s and choose which of them to change Note that if is even the central group has no pair so it should not be modified 
1000,Let s solve the problem greedily Let s make the first segment by adding elements until the segment will be good After that let s make the second segment in the same way and so on If we couldn t make any good segment then the answer is Otherwise let s add all uncovered elements at the end to the last segment Easy to prove that our construction is optimal consider the first two segments of the optimal answer obviously we can extend the second segment until the first segment will be equal to the first segment in our construction 
1001,The problem can be solved using a greedy algorithm We will maintain the current layout of the keyboard with letters that have already been encountered in the string and the current position on the layout If the next letter of the string is already on the layout it must be adjacent to the current one otherwise there is no answer If there was no such letter yet we can add it to the adjacent free position if both of them is occupied then there is no answer At the end you have to add letters that were not in the string 
1002,Notice that if then you can equalize them to the min and re qualify the rest into students without specialization That won t change the answer Now analyze the possible team formations 1 of each kind 2 coders and 1 mathematician or 1 coder and 2 mathematicians Each of these squads have 1 coder and 1 mathematician so you can only choose the type of the third member The students without specialization can only be used in the first kind of teams so let s use them first After that you might have been left with a nonzero count of coders and mathematicians These are equal however so can be added to the answer This solves each query in You can also run a binary search and solve each query in 
1003,Let s construct the answer digit by digit starting from the leftmost Obviously we are asked to build lexicographically maximal answer so in this order we should choose the greatest digit on each step Precalc number of digits in number Iterate over all possible digits starting from the greatest For each digit check if it s possible to put it in this position For this you construct minimal suffix greedily put the lowest digit and compare the resulting number with number If it became less or equal then proceed to the next digit Overall complexity where is digits from to 
1004,Let s find an answer for a little different version of the game Let s say that is the final score if the first player has stamina and the second has stamina The first player can either hit the ball or How to calculate Obviously and Otherwise the first player can either hit the ball then the player spent stamina and now it s to the second player to decide hit or lose So basically we moved to the state and the answer in this case is where or lose the play then the player doesn t spend any stamina but the opponent serve the ball He serves the ball spend stamina and return to the state where the first player decides hit or lose Formally the answer in this case is Looking at and one of transitions we can guess that and prove it by induction is either or but and and is better than so The final step is to note that since Alice starts the first play and serve ball the answer is 
1005,If we fix a song with minimum beauty in the answer then we need to take the remaining songs or less among those having beauty greater than or equal to the beauty of the fixed song and the longer they are the better So we will iterate on the songs in the order of decreasing their beauty and for the current song we will maintain longest songs having greater or similar beauty This can be done using some standard containers in or in 
1006,Let s replace all with and all with After that let s create a preffix sum array Also lets create array such that is equal minimum index such that if there is no such index Let s consider the first iteration of loop If then process ends and Otherwise the condition fulfilled then the value of will be equal to So the value of is equal to after first iteration Now let s consider the second iteration of loop If then process ends and Otherwise the condition fulfilled then the value of will be equal to So the value of is equal to after second iteration In this way we can calculate the value of after the process ends 
1007,Let s find out the total damage for a fixed value of Since the effect of the poison from the th attack deals damage seconds for and seconds for then the total damage is We can see that the higher the value of the greater the total sum So we can do a binary search on and find the minimum value when the sum is greater than or equal to 
1008,At first let prove that all possible angles in the regular gon equal to where To prove it we can build circumscribed circle around gon Then the circle will be divided on equal arcs with lengths Any possible angle in the gon is a inscribed angle in the circle and equal to half of central angle Any central angle in turn equals to sum of some consecitive arcs In result any angle equal to The maximal possible angle is reached from three consecutive vertices and equal by properties of regular polygons to So we need to find minimal integer such that where is integer and Its equivalent to find minimal integer solution of Let then we can divide both parts on In result Since then must divide Analogically must divide Then solution is next and We are finding the minimal solution so is almost always except cases where here we must take since we have restricition on The picture for the futher visibility 
1009,Let s prove that if is then is too Since the sum of digits of let s call it is not greater than then and if then So if is then is This observation allows us to use binary search to find the minimum number let s call it And if then all numbers in the segment are and not greater than so the quantity of these numbers is the answer to the problem 
1010,There are many different approaches to this problem but I think the model solution has the most elegant one First of all let s construct an RBS from the given string it always exists so it is always possible By calculating the number of opening brackets closing brackets and questions in the given string we can compute the number of question marks that should be replaced with opening brackets it is easy since exactly half of the characters in each RBS are opening brackets Then let s form the RBS greedily replace the first several question marks with opening brackets and all remaining ones with closed brackets Okay then what about finding a second RBS Recall that a bracket sequence is an RBS when for each of its positions the number of closing brackets before it is not greater than the number of opening brackets before it and these two values should be equal at the end of the sequence but it is less important now Consider the segment between the last question mark replaced with an opening bracket and the first question mark replaced by the closing bracket If we try to change the order of characters corresponding to question marks the balance on this segment will decrease at least by since at least one opening bracket to the left of it will become a closing bracket Is there a way to affect only this segment and change the balance on it only by Yes just swap the endpoints of this segment i e the last opening bracket that was a question mark and the first closing bracket that was also a question mark If it yields an RBS then the answer is Otherwise the answer is since any other permutation of characters that were replacing question marks will also decrease the balance on this segment by at least 
1011,If we forget about bracket kinds the string s should be RBS otherwise the answer doesn t exist If the answer exists each opening bracket matches to exactly one closing bracket and vice verse Easy to see that if two matching brackets have the same kind we don t need to replace them In other case we can change the kind of the closing bracket to the kind of the opening So we can build some answer Obviously the answer is minimal because the problems for some pair of matching pairs are independent and can be solved separately The only technical problem is to find the matching pairs To do that we should store the stack of opening brackets Let s iterate from left to right in s and if the bracket is opening we would simply add it to the stack Now if the bracket is closing there are three cases 1 the stack is empty 2 at the top of the stack is the opening bracket with the same kind as the current closing 3 the kind of the opening bracket differs from the kind of the closing bracket In the first case answer doesn t exist in the second case we should simply remove the opening bracket from the stack and in the third case we should remove the opening bracket from the stack and increase the answer by one Complexity O n 
1012,Notice that the robots that start at even coordinates can never collide with the robots that start at odd coordinates You can see that if a robot starts at an even coordinate it ll be at an even coordinate on an even second and at an odd coordinate on an odd second Thus we ll solve the even and the odd cases separately Sort the robots by their starting coordinate Apparently that step was an inconvenience for some of you There is a common trick that can help you to implement that Create a separate array of integer indices and sort them with a comparator that looks up the value by indices provided to tell the order This gives you the order of elements and doesn t require you to modify the original data in any way Consider the task without reflections of the wall Take a look at the first robot If it goes to the left then nothing ever happens to it Otherwise remember that it goes to the right Look at the next one If it goes to the left then it can collide with the first one if that went to the right Otherwise remember that it also goes to the right Now for the third one If this one goes to the left who does it collide with Obviously the rightmost alive robot that goes to the right So the idea is to keep a stack of the alive robots If a robot goes to the left then check if the stack is empty If it isn t then the top of the stack robot is the one who will collide with it Pop it from the stack since it explodes If a robot goes to the right simply push it to the stack The time of the collision is just the distance between the robots divided by If there are robots left in the stack after every robot is processed then they all go to the right together so they never collide What changes when the reflections are introduced Almost nothing actually Well now if the stack is empty and a robot goes to the left then it behaves as a one going to the right You can reflect the part of the way from its start to the wall Just say that instead of starting at some going to the left it starts at going to the right Since there s no one alive to the left of him initially that will change nothing That should be used for computing the collision time However the final robots in the stack also act differently First the top of the stack robots reflects off the wall and collides with the second on the stack one Then the third and the fourth and so on So you can pop them in pairs until or are left The coordinate reflection trick can be used here as well Imagine that the top of the stack starts at and goes to the left instead of starting in going to the right For the same reason it changes nothing Overall complexity 
1013,Let s first consider the possible paths across the grid that visit all cells You can immediately think of two of them The first one is go right to the wall turn into the other row and return Let s call it a hook The second one is go down go right go up go right and so on Let s call it a snake Turns out these two are basically the two extremes of all paths You can start with a snake and turn into a hook when you wish You can see that once you move right twice in a row you can only continue with a hook And as long as you didn t move right twice you are just doing a snake Let s fix some path across the grid What will its minimum time be Calculate it iteratively If you want to enter the next cell and it s still locked wait until it isn t So there are some seconds of waiting possibly zero before each cell However why not instead do the following Let s calculate the sum of waiting time required and wait for that amount of seconds before starting to move All cells will be visited at the same time as before or even later Thus they will surely be unlocked if they were in the original plan So the goal is to calculate the minimum amount of time required to wait in the start then add the movement time to it Once again the path is fixed Let the th cell of the path be If you start after waiting for seconds then you reach the th cell at time is indexed Thus the th cell should have If all cells satisfy this condition then the path can be done after waiting for seconds at the start Let s rewrite it into So the condition tells us that should be greater or equal than this value for all cells In other words should be greater or equal than the maximum of the values over all cells Study the formula Imagine we have some path with a known length and want to append a cell to it That s pretty simple Just update the maximum with the value with the corresponding cell and increase the length What if we wanted to prepend a cell to it Turns out it s not that hard as well Every cell in the path gets its value increased by From the formula you can see that this actually decreases the value of each cell by So the maximum decreases by as well The only thing left is to update the maximum with the value of the new first cell Well and increase the length again Finally let s learn how to choose the best path We can iterate over the length of the snake part The hook part is determined uniquely It s easy to maintain the maximum on the snake Just append the new cell to the path How to glue up the hook part to that Well actually realize that the formula allows us to glue up two paths into one Let path have length and maximum and path have length and maximum To make path start after path we just decrease its maximum by The resulting path has length and maximum Let s look closer into what the hooks look like They start in some column traverse all the way right then left up to the same column If the snake part took both cells in its last column then that s it Otherwise the hook has to take the final cell in the last column column If we manage to precalculate something for hooks that start in some column and end in column then we will be able to use that Appending the final cell is not a hard task since we know its index in the path Let be the waiting time required for a hook that starts in cell and ends in a cell as if the path started with the hook cell is the first one can be calculated from Prepend it with a cell and append it with a cell The only thing left is to find the best answer I found the most convenient to start with a snake of length only cell and progress it two steps at the time update the answer progress the snake to the other cell of the current column update the answer progress the snake into the next column Overall complexity per testcase 
1014,In this problem you are given an undirected graph with weighted vertices And the problem is to calculate the sum of minimum values in every connected component To do this we just need to run or several times 
1015,Let s process the boxes from left to right Consider the first box If it has a lid then you can just add the number of magazines in it to the answer and forget about this box To be exact proceed to solve the problem with the first box removed If it doesn t have a lid then look at the next box If it doesn t have a lid too then this box can never be covered Remove it and proceed further If the next box has a lid then look at the next one Again if it doesn t have a lid then these two first boxes are solved independently of everything else You can cover exactly one of them Choose the bigger one and remove them both To propagate the argument let s derive a pattern First there s a box without a lid Then some number of boxes with lids in a row Then a box without a lid again Among the first box and the box with lids you can choose exactly one to not be covered However that can be any one of them The best box to be left uncovered is the one with the smallest number of magazines in it Thus the solution is the following As long as the first box has a lid keep removing the first box and adding it to the answer Then as long as there are boxes left take the first box and the largest number of consecutive boxes with lids after it that number might be zero On that segment find the minimum value and the sum Add the sum minus the minimum to the answer remove the entire segment The removals can be done explicitly with a queue or just a reversed vector or implicitly with maintaining a pointer to the first non removed box Overall complexity 
1016,The statement should instantly scream binary search at you Clearly if you can assign the workers in such a way that the tasks are completed by time you can complete them all by or more as well How to check if the tasks can be completed by some time What that means is that all workers have hours to work on some tasks If all tasks took hours to complete then each of them could complete of them Thus together they would be able to complete tasks How to incorporate the hour tasks into that Well we can redistribute the tasks in such a way that each worker first completes the tasks they are proficient in then some other tasks if they have more time So the general idea is the following Let each worker complete hour tasks where is the number of tasks the th worker is proficient in Then remember how many hour tasks they can complete which is Finally remember how many tasks that they are proficient in they didn t have time to complete which is If the sum of the number of incomplete tasks doesn t exceed the sum of the number of tasks they have time to complete then everything can be completed in time Worst case it can take up to hours to complete everything if you assign all tasks to a single worker and they are not proficient in any of them Overall complexity per testcase 
1017,If the ball of color x is present in the first list on position i then it takes i cdot t 1 seconds to find it The same for the second list if color x is on position j it takes j cdot t 2 seconds to find it So for each position we have a coefficient which will be multiplied by the number of times it is requested and the total search time is the sum of these products for all positions There is a classical problem of the form you are given two arrays a i and b i both of length m consisting of non negative integers permute the elements of a in such a way that sum limits i 1 m a i cdot b i is the minimum possible To solve this problem you have to pair the maximum element of a with the minimum element of b the second maximum of a with the second minimum element of b and so on We can reduce our problem to this one For each of 2n positions in the lists there is a coefficient you have to assign the boxes from 1 to n to the positions so that the sum of r i multiplied by the coefficients for the positions is the minimum possible This looks similar but there are 2n positions and only n boxes To resolve this issue we can try a lot of different approaches I believe the easiest one is the following initially both lists are empty and when want to add an element to one of these two lists we choose the list such that the coefficient for the new position which is s i cdot 1 cnt i where cnt i is the number of elements we already added to the i th list is smaller If for both lists adding a new element has the same coefficient it doesn t matter which one we choose This greedy approach works because every time we add an element to the list next time we ll add another one into the same list the coefficient for that element will be greater So the problem can be solved in O n log n first we sort the boxes by the number of times they are requested in non ascending order and then we put them into the two lists greedily every time choosing the list such that the coefficient for the next element is smaller 
1018,First we can prove that the optimal way to perform operations is first decrease the minimum value several maybe zero times then take several maybe zero maximums and make them equal to the minimum value The proof consists of several steps Prove that first we make decreases only then sets if some is done after some then if there were no modification of then you can just move earlier Otherwise there were and you can replace with We demonstrated how to move decrease operations before set operations Prove that it s optimal to decrease only one element instead of decreasing by and by where we can decrease by and replace all with It s optimal to decrease the minimum element it follows from proof of previous step If we make set operations it s optimal to set minimum value to maximum elements should be obvious To use the strategy we ll firstly sort array in non decreasing order In this case we ll decrease by and perform set to elements The question is how to minimize value of Note that since setting the same position multiple times has no sense Let s iterate over all possible values of and determine the minimum needed The resulting array will consists of Let s say that and all can be precomputed beforehand Then the sum of array will become and we need or since we need minimum possible Using the formula above we can for each calculate minimum required But to be accurate value may be negative and usually in programming languages integer division for negative returns instead of There is an alternative solution note that if then Note that if then resulting value of is in and there are at most possible value for So you can iterate over all possible and for each calculate minimum required either with binary search or two pointers 
1019,There are two ways to solve this problem greedy approach and dynamic programming The first apprroach Considerr some segment of consecutive equal characters Let be the length of that segment Easy to see that we should change at least characters in the segment to remove all the pairs of equal consecutive letters On the other hand we can simply change the second the fourth etc symbols to letter that is not equal to the letters before and after the segment 
1020,It is enough to consider two cases whether we will increase the strength of the hero who will kill the dragon or not If you do not increase the hero s strength then you have to choose such that Obviously among such you have to choose with the minimum value because the strength of defending heroes is equal to It remains to increase the total strength of the remaining heroes to So the required number of coins is equal to If you increase the hero s strength then you have to choose the maximum value of which is less than In this case the required number of coins is to increase the strength of the hero who will kill the dragon plus to increase the strength of the defending heroes To find the heroes with strength as close to as possible you can use binary search don t forget to sort the heroes beforehand 
1021,Coordinates don t exceed so it s possible to use sweep line method to solve the problem Let s calculate value separately for each side I will show the algorithm for left side and all the others will be done similarly Let be the number of sofas which has smaller of their coordinates less than or equal to To count that let s firstly increment by one for all sofas and then proceed from left to right and do Now will represent number of sofas to the left of the current one but the sofa itself can also be counted You need to decrement the result by one if The same is for top value but with coordinates insted of For the right and bottom values you should calculate and Then take and The only thing left is to compare values of each sofa with given ones and find the suitable sofa Overall complexity 
1022,At first let s precalculate array pos such that pos a i i Now presume that we have to calculate answer for b i Then there are two cases let s denote lst max limits 1 le j i pos b j initially lst 1 if pos b i lst then we have to spend 1 2 cdot pos b i i 1 seconds on it second on the gift b i pos b i i 1 seconds on removing gifts above and pos b i i 1 seconds on pushing these gifts if pos b i lst then we can reorder gifts by previous actions such that gift b i be on the top of stack So we spend only second on it 
1023,You are given the input data in compressed format let s decompress it in binary string where the th character is if the th platform is hidden and otherwise For example the third query is Let s look how our string changes if we had then after pulling the lever it becomes and if we had then we d get The underlined index is the platform we are currently on So it looks like we are standing on and move it to the left until it clashes with the next one So we can determine that we should look only at subsegments on s Now we can note that the good string should have all subsegments of ones with even length except two cases the subsegment that starts from should have odd length and subsegment which ends in can have any length Now we can say that the answer is equal to number of subsegments which doesn t match the pattern of the good string since we can fix each subsegment with one crystal And we can prove that it s optimal since the only way to fix two subsegments with one crystal is to merge them but it does not help Finally we can understand that we have no need in decompressing the input and can determine subsegments of ones straightforwardly 
1024,Let s notice that this task can be solved independently for each column total result will be the sum of results for columns The ones you should remove will always be the top ones in column It makes no profit to erase some one while there are still ones on top of it score won t become higher Go from the top of the column to the bottom and recalculate the score after removing every one Take the first position of the maximal score and update global answer with it Overall complexity can be achieved with partial sums 
1025,The problem can be solved by the next greedy algorithm At first we need to store the last character of the alphabet we haven t obtained for example in variable initially it will be equal to Then we will just iterate over all characters of the string from left to right and if the current character of the string is not greater than we just replace it to and increase by 1 If in any moment will be greater than we got the answer And if after iterating over the string will be not greater than the answer is 1 
1026,There are many ways to solve this problem I will describe the following recursive solution if let s compose an array where every segment ending with the th element is positive and every other segment is negative This array can be where is the th element of the array note that when doesn t belong to the array so it consists of only negative numbers but if solve the same problem with and recursively get an array of length with positive subarrays and append to it to make all segments ending with the last element positive 
1027,Take a look at some pair such that and initial It means that all the swaps from to should be allowed Then it s easy to notice that it s enough to check only and as any other pair can be deducted from this You can precalc for each and prefix sums over the string of allowed swaps to check it in no time Overall complexity 
1028,At first let s pour minimal amount of tea in each cup that is If it requires more tea than available then it s Now let s sort cups in non increasing order by volume and start filling up them until we run out of tea in the teapot It s easy to see that everyone will be satisfied that way If sequence of is non increasing then sequence of is also non increasing So we can t make someone unsatisfied by filling the cup with maximal possible volume And finally get the right order of cups back and print the answer Overall complexity 
1029,Consider how each sort of tea affects the tasters The th sort makes testers for some drink to their limit and the th taster drink the remaining tea Sometimes there is no such th taster but we ll explore the general case Let s add the remaining tea straight to the th taster answer And for each taster from to we ll add into the value denoting how many times they drank at their limit If we have these calculated we can obtain the answer by adding and In order to find we can use prefix sums Build over the sequence Now you want to find the largest such that Rewrite it as You can do this with a binary search In particular with an upper bound call The amount of the remaining tea can also be calculated from prefix sums To add on a range you can use a technique called delta encoding Add to Subtract from After everything is added propagate this values via a prefix sum This way if both and happened non strictly to the left or strictly to the right of it doesn t affect at all the segment either closes before or opens after Otherwise it adds exactly to Overall complexity per testcase 
1030,Let s enumerate all the connected components store their sizes and for each empty cell store the number of it s component It can be done with a single dfs Now the answer for some impassable cell is equal to one plus the sizes of all different adjacent connected components Adjacent means the components of cells adjacent to the current impassable cell in general case each unpassable cell has four adjacent cells 
1031,At first lets precalc the array The value of if equal the maximum position in range such that After that lets iterate over the right boundary of substring and high bit position denote it as and respectively Note that if then So we iterate over such pair that and Lets look at value If then we have to increase the length of substring without increasing the value of So we need to check if there exists a position such that and This position exists if the condition is met is equal to 1 
1032,Let s sort all the strings by comparator and concatenate them Let s prove that it s the optimal answer Let that operator be transitive so if Consider an optimal answer with two strings in reverse order by that operator Because of the transitivity of operator we can assume that pair of strings are neighbouring But then we can swap them and get the better answer Let s prove the transitivity of operator Consider the strings as the base numbers Then the relation equivalent to The last is simply the relation between real numbers So we proved the transitivity of the relation 
1033,If you check some games then you will notice that the most optimal strategy for Bob is always like this Climb up for some steps possibly zero Go to the lowest vertex from it Stay in this vertex till the end Thus let s precalc the depth the distance from the root of the lowest vertex of each subtree using dfs distance from Alice s starting node and from Bob s starting node to the vertex again dfs bfs Now iterate over all vertices and check if Bob can reach this vertex earlier than Alice If he can then update the answer with the lowest vertex that can be reached from this one The answer is doubled depth of the obtained lowest reachable vertex That is the time which will take Alice to get there Overall complexity 
1034,There are pretty few cases to have One of is equal to At least two of are equal to All equal It s easy to notice that having minimum of equal to produce the only case greater numbers will always miss some seconds Let s consider minimum of let it cover all odd seconds Now you should cover all even seconds and and are the only possible solutions Overall complexity 
1035,Let s consider the following sequence It s sequence of length sorted in non descending order where each element of each sequence is an integer between and We can find the number of such sequences by simple combinatorics it s combination with repetitions So the answer is 
1036,Notice that it s never optimal to erase a subsequence of length greater than because every RBS of length above contains an RBS of length inside and removing it won t break the regular property of the outside one So the task can be solved for the round and the square brackets independently the answer will be the sum of both Let s solve the version for brackets and In general you just want to remove consecutive substring until there is no more left in the string That can be done by processing the string from left and right and maintaining a stack of current brackets If the top bracket in it is and the current bracket is then you can increment the answer and remove that bracket from the stack Otherwise you push the current bracket to the stack Overall complexity per testcase 
1037,If you can place two rectangles in some way without rotations then it s always possible to move one of them to the top left corner and stick the other either to the bottom of the first and push it all the way to the left or to the right of it and push it all the way to the top Now let s try all possible reorderings and rotations for every pair of seals If there is at least one correct reordering then update the answer Overall complexity 
1038,Let s process all the segments on the line from left to right For each segment we should push events and into some array Sort this array of pair in increasing order usual less comparator for pairs Then we iterate over its elements and maintain the current amount of open segments we passed their left border and didn t pass their right border When we meet the event of the first type we increment the value of the second type decrement If in some moment then the answer is Overall complexity 
1039,Let s find a simple condition when the string is not beautiful A string is not beautiful if there are two characters or two characters at an odd distance or and at an even distance because in this case the string cannot be made unstable Iterate over the right border of the substring Let be the maximum index such that the substring is not beautiful or if the substring is beautiful Then we have to add to the answer since any substring of a beautiful string is also beautiful Denote as the last occurrence of or at the position of parity Let is the parity of then i e find the nearest character that breaks a beautiful substring at an odd distance or at an even distance The case for is similar If then we can choose what this character will be Obviously we need to choose the option with the smaller value of 
1040,Let s consider array such that Then subarray is sorted in non decreasing order if and only if all elements are greater or equal to zero So if we have fact then all elements must be greater or equal to zero Let s create the following array if there is such a fact that and otherwise After that we create the following array and for all other indexes This array satisfies all facts such that So all we have to do is check that all remaining facts are satisfied 
1041,Write down all the numbers which appear exactly once let there be of them If is even put the first of them into the first multiset and put the other into the second multiset All the other numbers which appear more than once also go into the first multiset The only nice numbers will be the initial thus the answer is valid If is odd and there is no number to appear more than twice then the answer is as all the numbers to appear exactly twice don t change the difference of the amounts of the nice numbers at all If there is a number to appear more than twice let it be then let s firstly add of the numbers to appear exactly once to the first multiset add others of them to the second multiset Then the first occurrence of goes to the second multiset and all the other numbers go to the first multiset It s easy to notice that multisets will contain equal number of the nice numbers after all the partitioning 
1042,Denote If then the answer is 1 since the robot will not have the time to reach cell in steps Also if and have different parity then the answer is also 1 as in one move the robot changes the parity of the sum of its coordinates In all other cases the answer exists Let s use binary search to solve this problem Consider all segments of length For a fixed length of the segment let s iterate over the position of the beginning of the segment At the same time we will maintain the cell that the robot will stop at if it execute all commands except commands with indices We denote this position as We also calculate the distances from the cell to the cell the value If there is at least one position of the beginning of the segment for which then we can change the segment of length so that the robot comes to the cell otherwise it can t 
1043,A route visiting each cell exactly once can always be denoted as follows several possibly zero first columns of the glade are visited in a zigzag pattern then Vasya goes to the right until the end of the glade makes one step up or down and goes left until he visits all remaining cells There are such routes To calculate the weight of collected mushrooms quickly we will precompute three arrays for the first row of the glade and will be used to compute the weight of mushrooms collected when Vasya moves to the right until the last column of the glade when Vasya moves to the left from the last column and to handle the growth of mushrooms Also we have to compute the same arrays for the second row of the glade Let s iterate on the number of columns Vasya will pass in a zigzag pattern and maintain the weight of mushrooms he will collect while doing so Then we have to add the weight of the mushrooms Vasya will gather while moving to the right and then while moving to the left The first can be handled by arrays and the second by arrays and 
1044,The first observation we need to solve this problem the required height is either or where is the maximum initial height of some tree We don t need heights greater than because for example if the height is we can remove some moves and get the answer for the height The same thing applies to all heights greater than Why do we even need the height In some cases like the answer for the height is better than the answer for the height in this particular case it is vs Now we have two ways to solve the problem either use some gross formulas or just write a binary search on the answer I won t consider the solution with formulas but we have one so let s assume we use binary search Let the current answer be Then let be the number of operations we can do and be the number of operations we can do We can use operations greedily and then just check if the number of operations is sufficient to grow up the remaining heights Time complexity per test case 
1045,Let s look at one fixed color When we search a card of such color we take the card with minimum index and after we place it on the top of the deck it remains the one with minimum index It means that for each color we take and move the same card one card for each color In other words we need to keep track of only cards where is the number of colors As a result if is the position of a card of color then we can simulate a query in the following way for each color such that we increase by one since the card will move down and then set Complexity is But if we look closely we may note that we don t even need array We can almost manually find the first card of color and move it to the first position either by series of swaps or for example using function present in C and it will work fast Why Let s look at one color For the first time it will cost operations to search the corresponding card and move it to the position But after that at any moment of time the position of the card won t exceed since all cards before are pairwise different due to the nature of queries So all next moves the color costs only time As a result the complexity of such almost naive solution is 
1046,It s quite easy to see that ab x bmod a bmod b x bmod a bmod b What does it mean The property given in the statement holds for x if and only if it holds for x bmod ab It allows us to answer each testcase in O ab q as follows for each number from 0 to ab 1 we may check the given property before processing the queries and build an array of prefix sums on it to efficiently count the number of integers satisfying the property from the segment 0 y where y ab Then each query l r can be divided into two prefix queries 0 l 1 and 0 r To answer a prefix query 0 p in O 1 we can calculate the number of full segments of length ab inside this prefix that is lfloor frac p ab rfloor and the length of the last segment of numbers that don t belong into a full segment that is p bmod ab To handle full segments we multiply the number of integers satisfying the property on one segment by the number of such segments and to handle the last part of segment we use prefix sums 
1047,Suppose at the end you won matches what can be your final place Look at each opponent with indexed Since the th opponent indexed won games against the other opponents even if they win against you they ll gain wins in total and can t affect your place since your place is decided by only opponents who won strictly more matches than you From the other side let s look at each opponent with indexed Even if they lose to you they still have wins you have only so all of them have strictly more wins than you As a result there is only one opponent whose match against you can affect your final place if you won against them your place will be otherwise your place will be Now let s compare your possible places if you win games with places for winning only games wins gives you places or while winning leads you to places or that objectively worse In other words it s always optimal to win as many matches as possible How to win the most number of games It s to choose the easiest opponents Let s sort array and find the maximum prefix with So we found maximum number of games we can win The last is to check can we get place or only If contains among smallest values then we ll take place Otherwise let s try to insert in this set i e let s erase the biggest among them and insert If the sum is still lower or equal to it s success and we get place Otherwise our place is The total complexity is because of sorting 
1048,The problem asks us to maintain the bounding box while inserting the character of one of types between every adjacent characters in Of course we can do it but do we really to do it in such way Let s think a little Inserting W or S doesn t affect the width of the bounding box and A or D doesn t affect the height So they are absolutely independent And we can divide our WASD string on WS string and AD string Moreover inserting W or S in WS string and A or D in AD string is almost same thing so we don t even need to write different code for different string How to handle only WS string Let s replace W as and S as and suppose that we started in position Then the position where we go after commands is just prefix sum of first elements Then the length of the bounding box is maximum position minimum position 1 The maximum minimum position is a maximum minimum element in array of prefix sums What the inserted value do It add to suffix of Let s choose for example The can t decrease the maximum but can increase the minimum so we need to place it somewhere before all minimums in or before the first minimum But if we place it before any of maximum elements then we will increase it and prevent decreasing the length of bounding box So we need to place somewhere after all maximums on or after the last maximum And here goes the solution find position of the first minimum in and position of the last maximum If then we can insert and decrease the length of bounding box but since we insert command that move robot we can t achieve bounding box of length What to do with Just multiply by and now we can insert instead of in absolutely same manner What to do with AD string Denote A as and D as and everything is absolutely the same 
1049,It s not hard to come up with a solution if you just imagine how gon looks when is even The solution is to rotate gon in such way that several its sides are parallel to sides of the square And the answer is equal to the distance from center to any side multiplied by two or 
1050,At first lets place gon in such way that the lowest side of gon is horizontal Now we can without loss of generality think that the square has horizontal and vertical sides and we just rotate gon around its center If we rotate the gon at angle then it will move on itself Moreover after rotating at angle we ll get left and right sides vertical and the following rotation is meaningless since it s the same as if we just swap and coordinates So we don t we to rotate more than Also we can see that while rotating the difference between max and min decreasing while the distance between max and min increasing The answer is obviously the maximum among these differences So for example we can just ternary search the optimal answer Or we can note that the behavior of differences is symmetrical just swap and coordinates so the answer is in the middle angle i e we just need to rotate gon at angle Finally observing several right triangles we can come up with quite an easy answer 
1051,Let s divide all valid pairs into three categories the ones containing only edges on the path the ones containing only edges and the ones containing both types of edges To calculate the number of pairs containing only edges we may build a forest on the vertices of the original graph and edges and choose all pairs of vertices belonging to the same connected components of this forest we can find all connected components with DSU or any graph traversal algorithm The same can be done for the pairs containing only edges If a path from to is valid and contains both types of edges then there exists a vertex such that the simple path from to goes only through edges and the simple path from to goes only through edges So let s iterate on this vertex and choose some other vertex from its component in graph as and some other vertex from its component in graph as and add the number of ways to choose them to the answer 
1052,Let s determine for each cell whether it s winning or losing position we can do it since the game is symmetric and doesn t depend on a player The th cell is obviously losing the st and nd ones is both winning since we can move to the th cell and put our opponent in the losing position here comes criterion the position is winning if and only if there is a move to the losing position If is large enough then the th rd th th are losing So here comes divisibility by If then this move doesn t change anything since if then so it s not the move to the losing position so doesn t become the winning one Otherwise if then the th positions becomes winning but the th cell is losing all moves are to th th or st cells and all of them are winning The th and th cells are winning and so on In the end we came up with cycle of length where position divisible by except are losing All we need to do is small case work 
1053,When we fix a set of soldiers we can determine a set of traps that may affect our squad these are the traps with danger level greater than the lowest agility value So we can use binary search on minimum possible agility of a soldier that we can choose How should we actually bring our soldiers to the boss Each trap that can affect our squad can be actually treated as a segment such that our squad cannot move to until we move to and disarm this trap We should walk through such segments for three times the first time we walk forwards without our squad to disarm the trap the second time we walk backwards to return to our squad and the third time we walk forwards with our squad So the total time we have to spend can be calculated as where is the number of unit segments belonging to at least one trap segment and it can be calculated with event processing algorithms or with segment union Time complexity is or but it is possible to write a solution in without binary search 
1054,Instead of counting the number of good substrings let s count the number of bad substrings then number of good substrings is equal to Let s call a character in string is bad if there is no such palindrome that Any character in substring is good It can be proven as follows If or then belong to a palindrome of length If and then belong to a palindrome So only characters and can be bad But at the same time character is bad if there is no character such that and It is true because substring is palindrome index is minimum index such that So there are only patterns of bad strings All that remains is to count the number of substrings of this kind 
1055,The constraits are set in such a way that naive solution won t pass unmark every edge one by one and check if graph of marked edges doesn t contain cycles with dfs bfs Thus we should somehow limit the number of edges to check Let s take arbitrary cycle in graph Do dfs store the vertex you used to travel to any other vertex and restore edges with this data if cycle is met With this algo length of cycle will not exceed Then do the naive algo but check only edges from this cycle Overall complexity 
1056,Let s iterate on the number of indices such that Obviously How to count the number of permutations with fixed First of all we need to choose the indices that have the property there are ways to do this Secondly we need to construct a permutation for chosen indices such that for every chosen index permutations with this property are called and the number of derangements of fixed size can be calculated using exhaustive search since So the answer is where is the number of derangements of size 
1057,If the circles don t intersect than the answer is 0 We can check that case with only integer calculations simply by comparing the square of distance between centers with square of the sum of radiuses If one of the circles is fully in other then the answer is the square of the smaller one We can check this case also with only integer calculations simply by comparing the square of distance between centers with square of the difference of radiuses So now let s consider the general case The answer will be equal to the sum of two circular segments Let s consider the triangle with apexes in centers if circles and in some intersecting point of the circles In that triangle we know all three sides so we can compute the angle of the circular segment So we can compute the square of circular sector And the only thing that we should do now is to subtract the square of triangle with apexes in the center of circle and in the intersecting points of circles We can do that by computing the half of absolute value of cross product So we have the following formulas where d is the distance between centers of the circles And also we should do the same thing with second circle by replacing of indices 1 ftrightarrow2 Complexity O 1 
1058,Let s say that the starting position of people are in sorted order and ending positions of people are also in sorted order It s always optimal to match these starting and ending positions in sorted order the leftmost starting position is matched with the leftmost ending the second starting position is matched with the second ending and so on To prove it suppose that position is matched with position is matched with and If both persons go to the left or to the right it means that either or so nothing changes if we swap the matched positions If instead the person that goes from to goes to the right and the person that goes from to goes to the left the segment belongs to both paths and swapping the matched pairs removes this segment from both paths and decreases the total time So if the order of starting positions is sorted and the order of ending positions is sorted these positions should be matched exactly in those order Using this fact we can implement the following dynamic programming let be the minimum time if we considered first positions and picked of them as the ending ones Transitions are the following we either take the current position as the ending one if it s not a starting one match it with the th starting position and go to or we skip the current position and go to It works in since it has up to states and just up to transitions from each state 
1059,Suppose we want to move an element from the prefix to the suffix if we need to move an element from the suffix to the prefix we can just reverse the array and do the same thing Suppose the resulting prefix will contain elements Then we need to check that the prefix with elements contains an element such that the sum of this prefix without this element is equal to the half of the sum of the whole array and then we can move this element to the suffix To check all the prefixes we can scan the array from left to right while maintaining the set of elements on the prefix and the sum of these elements 
1060,Let s denote as just a suffix sum And let be the position where starts the th subarray obviously and Then we can make an interesting transformation So our task is equivalent to choosing sum of all array and different suffix sums And we want to maximize their total sum That s why we can just greedily take maximum suffix sums along with sum of all array 
1061,Note that the answer n is always possible for example we can set d i frac prod f j f i then p 1 dots p n prod f j and max p i min p i 0 If the answer is less than n then there is at least one gun id we won t change It means that all other guns firepower should be around p id i e p i p id le k So we can look at segment p id k p id k and for each gun i find what values d i we should set to get into this segment After that we can rephrase our task into the next one we should choose segment l l k subset p id k p id k such that each gun occurs in l l k at least once and the number of corresponding d i that are equal to d i is maximum possible It can be solved with two pointers technique Note that there are at most three interesting values d i we should consider v 1 left lfloor frac p id f i right rfloor v 2 v 1 1 and v 3 d i For each value v j such that v j cdot f i in p id k p id k we can add an event i c j in position v j f i where c j is 1 if v j d i or 0 otherwise Now with two pointers technique we can iterate over all subsegments of length k 1 of segment p id k p id k To get the desired answer we should maintain the number of unique i from events that are present in the subsegment and the sum s of c j from that events Since there is only one c j 1 for each gun i then the sum s of c j we have is equal exactly to the number of guns we change Then we take the maximum mx over sums s of all subsegments where all guns occur and the answer for a fixed p id is n mx Let s iterate over all fixed id and take the minimum from all n mx that will be the answer for the initial task Checking answer for a fixed id involves creating 3 n events and two pointers over segment p id k p id k so it takes O n k time and O n k space So the total complexity is O n 2 n k time and O n k space 
1062,The first intuitive guess one s probably made is multiplying the segment of maximum sum for positive That thing is correct Unfortunately there is no similar strategy for non positive simple greedy won t work there Thus dynamic programming is our new friend Let s introduce the following state where is the length of the currently processed prefix is the state of maximum sum segment is not reached it ll appear later is open current elements are added to it is passed the segment appeared earlier and is the state of segment multiplied by with the same values This will store the maximum segment sum we can achieve The only base state is the prefix of length is processed and both segments are not open yet The rest of values in are There are two main transitions At any moment we can change the state of each segment to the next one without moving to the next position From state not reached we can go to state opened and from state we can go to state passed Note that this easily covers the case where optimal segment is empty We can also move to the next position updating the value of with correspondance to the current states of segments The answer will be stored in the state where all the array is processed and both segments are closed Overall complexity 
1063,Let s denote a way to distribute numbers as a Let s also call the paintings that meet the constraints paintings and all other paintings are bad We can solve the problem for each connected component of the graph independently and multiply the answers Let s analyze a painting of some connected component If some vertex has an odd number written on it then we should write even numbers on all adjacent vertices and vice versa So in fact we need to check if the component is bipartite and if it is divide it into two parts The number of good paintings is where is the size of the first part and is the size of the second part because we write s into all vertices of one part and s or s into all vertices of another part 
1064,Let s code the following process Go one circle across the booths calculate the total cost of sweets bought and the number of sweets bought Now you can decrease you money down to and add to answer It represents that you went maximum number of such circles The later circles will have smaller cost Let s continue this process until becomes smaller than the minimum priced sweet The number of operations made is Let be the amount of money before some operation be the total cost of sweets bought on that operation and is actually smaller than that s how modulo works and smaller than that s also how modulo works And these inequalities imply that That leads to about steps to reach the minimal price Overall complexity 
1065,The first thing we need to do is to find the occurrences of in the sequence these are the monsters that have to remain Since both spells Fireball and Berserk affect consecutive monsters we should treat each subsegment of monsters we have to delete separately Consider a segment with monsters we have to delete such that the last monster before it has power the first monster after the segment has power and the strongest monster on the segment has power If then we have to use Berserk at least times Let s make the strongest monster on segment kill some other monster If then the strongest monster should also be killed by one of the monsters bounding the segment so if and there is no solution Okay now the number of monsters is divisible by If it is more profitable to use Fireball we use the required number of Fireballs to kill all of them Otherwise we have to kill the maximum possible number of monsters with Berserk and finish the remaining ones with Fireball If or then one of the monsters just outside the segment can kill all the monsters inside the segment otherwise the strongest monster should kill adjacent monsters until exactly remain and those monsters are finished with a single Fireball Now we know what we need to consider when processing a single segment all that s left is to sum the minimum required mana over all such segments Since the total length of these segments is at most and we can process each segment in linear time we have a solution with complexity 
1066,Let be nested depth of RBS There is an interesting fact that From the other side we can always reach equation using some approaches Let s look at prefix of length of string Let be number of opening bracket in the prefix number of closing brackets Then we can define balance of the th prefix of as The author s approach is next Let s define of pair of brackets matched in natural way as where is position of opening bracket of this pair Then we will color in red all pairs with even level and in blue with odd level Proof of It can be shown that and exists such that After any coloring of we can define number of opening closing red blue brackets of th prefix of as and respectively Since and then Finally 
1067,The problem is about counting the number of some combinatoric objects Thus dynamic programming is always the answer Let be the number of bicolorings of the first columns such that components are already created and can t be modified and the colors of the th column are determined by its first bit is the color of the lower cell and its second bit the color of the upper cell Component can be modified if the cell from the th column belongs to it The initial states are for each and for any other state You should iterate over the possible for the next column and recalculate the number of components You can easily show that the current number of components and the last column is actually enough to get the new number of components In my code I have some function to determine the added number of components while transitioning from to These are just the couple of cases to handle carefully Then all the transitions are However the last column won t contain the answer as it is the number of components will be incorrect Let s add some dummy column equal to for each This will add all the real component to the total number So the answer is the sum of over all Overall complexity where is the number of rows 2 for this problem 
1068,Note that the price of operations is much greater than the difference between them Therefore first of all we have to minimize the number of operations and then maximize the number of operations of the first type Swapping two elements if at least one of them will be deleted later is not optimal Therefore first let s delete some elements of the string and then sort the remaining elements using swaps The number of swaps for sorting is equal to the number of inversions i e the number of pairs such that and From here we can notice that if the number of inversions is greater than then there is an element that produces at least inversions So it is more profitable for us to remove it to minimize the number of operations From the above we get that the number of operations of the first type is at most If all operations are only of the second type then we need to find a subsequence of the maximum length of the form To do this we can iterate over the number of zeros that we include in the final string and then add the number of ones from the remaining suffix of the string that goes after the fixed number of zeros If there is an operation of the first type then it is enough to iterate over the pair that creates the inversion to the left of it take all zeros and to the right of it take all ones you can notice that in fact it is enough to iterate over only a pair of neighboring elements of the string 
1069,Let s consider the process backwards we will store the number of balls of each color in a multiset and then merge some of them If is odd then we can always pick three groups of balls with minimal sizes and replace them by one group adding the size of this group to the penalty Repeat until you have only one group If is even then we need to add an auxiliary group of size Then becomes odd so we can use the above algorithm to solve this case Why does it work This algorithm is exactly the same as the algorithm of building a Huffman code with the alphabet of size And it can easily be seen that these problems are similar by separating a group of balls into three groups we add a new character to the codes of the colours present in that group and our goal is to obtain a prefix code 
1070,Let s firstly consider tree with only distinct values in its nodes Then value will be reached if and only if all the jumps to the left children on the path from the root were done from the vertices with values greater than the current one and all the jumps to the right children on the path from the root were done from the vertices with values less than the current one Thus let s run dfs from the root and maintain maximal transition to the left child on current path and minimal transition to the right child on current path If the value of current node is greater than left bound and less than right bound then it will be found Now let s return to the original problem Notice that transitions and comparations won t change Store every found value in set and just calculate how many values of vertices isn t present there Overall complexity 
1071,There are many different approaches We will describe a pretty optimal one Let s solve the problem recursively Let s say we need to process segment If we don t need to do anything Otherwise Let s find the minimum such that The chosen is convenient because it allows making equal to in two divisions and it s the minimum number of divisions to get rid of Now we can firstly make all equal to in one step by division on and then make equal to with two divisions on As a result we ve spent operations and can solve our task recursively for In total we will spend and since the segments are like There will be at most segments and operations are enough for 
1072,Let s calculate dynamic programming the number of ways to achieve in moves From the state you can make a transition to the states where and is divisible by Let s try to estimate the maximum number of moves because it seems that there can t be very many of them For moves the minimum distance by which a chip can be moved is or From here one can see that the maximum number of transitions does not exceed maximum at So it remains to make transitions in dynamic programming faster than from a single state for a fast enough solution Let s use the fact that Let s iterate over the value of and maintain the sum of dynamic programming values with smaller indices for each remainder modulo in a separate array The final complexity of such a solution is It remains to solve the memory problem because with the existing limits it is impossible to save the entire matrix of size However this is easy to solve if you notice that only the previous layer is used for transitions in dp i e it is enough to store to calculate 
1073,Let s build some rectangles and take a look at the resulting pairings For example consider only red green rectangles Let the rectangles be Sort them in a non decreasing order of I claim that in the most optimal set are also sorted in a non decreasing order It s easy to prove with some induction Moreover if there are some green or red sticks that are not taken and that are longer than the smallest taken corresponding sticks then it s always optimal to take those instead These facts helps us to conclude that from each set only some suffix of the largest sticks are taken And they also give us the idea of the solution sort the sticks in each set and pick the largest from any of the two sets into a pair until no pairs can be taken However the greedy approach of take from any two of the three sets is incorrect We need to choose these two sets smartly Let store the maximum total area that can be obtained by taking largest red sticks largest green sticks and largest blue sticks Each transition chooses a pair of colors and takes the next pairs in both of them The answer is the maximum value in all the Overall complexity 
1074,Let s run dfs on the graph and color all back edges is back edge if there is a path from to by edges from dfs tree in black and all other edges in white It can be proven that any cycle will have at least one white edge and at least black edge Moreover each back edge connected with at least one cycle path from to and back edge So the coloring we got is exactly the answer How to prove that any cycle have at least one edge of both colors Let s look only at edges from dfs trees We can always renumerate vertices in such way that index of parent is bigger than the index of any its child We can process and assign with minimal free number after we processed all its children Now we can note that for any white edge not only tree edge condition holds because of properties of dfs forward edges are obvious cross edge becomes cross because dfs at first processed vertex and after that so And for each back edge it s true that Since any cycle have both and situations profit 
1075,After some tinkering with the given condition we notice that an compression is possible iff divides and the matrix is divisible into matrices such that each matrix is either all 1 or all 0 We can loop over all such and check the condition in time per but this is potentially too slow To speed this up we can precompute rectangle sums for every rectangle containing the upper left corner which enables us to compute the sum of any rectangle in This improves our time complexity to Since really this means our solution is Code 49028814 
1076,First of all there will be exactly distinct elements in our array Let s choose them there are ways to do that After that there should be exactly one element that appears twice There are elements to choose from but are all of them eligible If we duplicate the maximum element there will be no way to meet the fourth condition So we should multiply the current answer by not And finally some elements will appear earlier than the maximum in our array and some later The duplicated element will appear on both sides but all other elements should appear either to the left or to the right so there are ways to choose their positions Thus the answer is Note that you have to precompute all factorials and use their inverse elements to calculate Note that there is a tricky case when some binpow implementations go into infinite loop trying to compute so you may have to handle it specifically 
1077,We will calculate the answer by subtracting the number of arrays which have only one removal sequence from the total number of arrays The latter is very simple it s just How do we calculate the number of unambiguous arrays We can always delete the st element of an array so is a removal sequence for each array So we have to calculate the number of arrays which have no other removal sequences How do we check if the array has no removal sequences other than If at any time it s possible to remove some element other than the st from the array it creates another removal sequence since we can always complete that sequence Let s analyze the constraints on each element of the array can be any integer from to should be divisible by otherwise we can remove it on the first step should be divisible by otherwise we can remove it on the first step and by otherwise we can remove it on the second step should be divisible by and but not necessarily by since an element which is divisible by already has a common divisor with And so on using induction we can show that the th element should be divisible by where are all of the primes in Obviously the number of such elements is So we can easily calculate the number of possible elements for each index of the array and that allows us to count all unambiguous arrays 
1078,The following greedy solution works Firstly deposite money only on days with Secondly every time the balance is negative to the day with refill it to maximal possible value such that it won t go over later Days with can only lead to invalid state by going over card limit We can only add money to the balance Adding zero money in those days won t make invalid states if all were valid previously Finally if it s possible to get valid state in every day then it s possible to get it by refilling the same day the check happens For example you can make balance in those days Then you will never have negative balance there Though it s not the most optimal way Let be some value you deposite in some day with to pass all conditions till the next day with I state that function of number of game s moves dependancy on is monotonious Let s check it for some fixed Define minimum balance you will get on any suffix from now as Obviously taking will make it If it goes negative then you will need an extra move to finish the game Thus taking maximal will lead to the lowest score possible And last but not least realization part What will be the maximum possible value to deposite Actually it s such a value that optimal game after this will lead to maximum balance of in some day Thus you want to check what will be the maximum balance if you add zero money and take as Obviously if it s negative then output Naively this still works on per day and lead to overall Notice that by depositing you increase maximums on each suffix for now by So you can calculate it as you will do nothing and add sum of your s to get actual value You store prefix sum of up to in Then take maximum on suffix for every is the maxumum for from to I hope I made it clear enough DOverall comlpexity 
1079,Let s take a look at a final coloring Each cell has some color There exist cells such that there were no operation in their row and their column They are left white and they don t affect the answer All other cells are colored in one of colors For each cell there is a query that has been the last one to color this cell it covered row column or both of them So all cells that have the same query as the last one will have the same color Since the color for each query is chosen independently the number of colorings will be to the power of the number of queries that have at least one cell belong to them How to determine if a query has at least one cell This is true unless one of these things happen afterwards both its row and its column are recolored all rows are recolored all columns are recolored So the solution is to process the queries backwards Maintain the set of colored rows and colored columns For each query check the conditions If none hold multiply the answer by Overall complexity or per testcase 
1080,We prove that the answer always always exists by constructing it Graph for is a single vertex Graph for is a clique of vertices Graph for some is obtained from the graph by adding vertices initially connected to nothing and vertices connected to all previously mentioned ones The vertices connected to nothing got degrees the vertices from the previous step increased their degrees by and finally there appeared vertices of degree The number is vertices is as needed 
1081,One of the key observations to this problem is that after the first operations the first elements of the array are fixed and cannot be changed afterwards Also after the th operation the elements on positions from to are the same as they were before applying the operations This allows us to write the following dynamic programming the number of different prefixes our array can have if we have performed operations the th element is and the th element is The elements after are the same as in the original array and the elements before won t be changed anymore so we are interested only in these two elements Let s analyze the transitions in this dynamic programming We apply the operation to the elements and If we add to then we subtract it from so we transition into state Otherwise we transition into state The element we leave behind is either or and if these two transitions give us different prefixes But if we need to make only one of these transitions because adding or subtracting actually makes no difference Okay now we ve got a solution with dynamic programming in where is up to and is up to This is too slow But we can notice that the value of actually does not affect our transitions at all we can just discard it so our dynamic programming becomes which easily fits into TL Small implementation note elements can become negative and in order to store dynamic programming with negative states in an array we need to do something about that I don t recommend using maps neither ordered nor unordered you either get an extra log factor or make your solution susceptible to hacking Instead let s say that the value of where can be a negative number will be stored as in the array where is some constant which is greater than the maximum possible for example in this problem That way all array indices will be non negative Solution complexity 
1082,Consider every cyclic shift of the array Suppose that now the array starts from the position the first element is and the last element is Assume that before the position our dog reached her minimum possible position and now the minimum position will not change So our problem is to fill all zeros in the array in such a way that the maximum prefix sum of is the maximum possible and the total sum of is zero For simplicity consider the array which is the th cyclic shift of i e the first element is the second element is and so on Let s iterate from left to right and maintain the current sum of the array Let this variable be Now when we meet we should replace it with the maximum possible value we can because in such a way we will increase the maximum number of prefix sums Let be the number of zeros in starting from the position This value can be calculated in advance in for every cyclic shift using suffix sums Then the segment of positions we can have at the end is and we want to place the maximum possible value in in such a way that this remaining segment with addition of our current element will cover This maximum value equals If becomes less than then this cyclic shift is invalid and we should skip it Otherwise let s add to and proceed If there are no values then we placed anything correctly Now can just simulate the movements of our dog to find the answer for the current cyclic shift But there are cases when do not contain zeros so these cases should be handled somehow I just checked that after simulation we returned to If we returned to we can update the answer as the difference between the maximum and the minimum positions plus one If there is no valid cyclic shift then the answer is Time complexity 
1083,We can solve the problem recursively from the root to the leaves Let s maintain a list of leaf indices for the current subtree If the list size is equal to then we can stop our recursion Otherwise we have to find the value of the root of the current subtree and split all leaves between child nodes The root value is the maximum value of among all pairs belonging to a subtree since the current root has at least child nodes there is a pair of leaves for which the current root is the least common ancestor If the value of the least common ancestor of the leaves and is less than the value of the current root then and belong to the same child of the root Using this fact we can split all the leaves between the child nodes and then restore the subtrees for them recursively 
1084,Let s notice that you should never say that you didn t notice signs no speed limit and overtake is allowed Also if you drive with speed you don t want to remove signs speed limit with number greater or equal to Thus greedy solution will work Process all the events in chronological order We should maintain stack of signs speed limit and amount of signs no overtake allowed If we meet sign speed limit we push its limit to stack sign no overtake allowed increase no speed limit clear stack overtake is allowed assign to zero After every event we should check if our speed is fine While value of sign on the top of the stack is less than current speed pop it and increase answer If we overtake someone we add to answer and assign to zero Overall complexity 
1085,Denote string as We will solve this problem with dynamic programming Denote the minimum possible ambiguity if we considered first letters of statement and got prefix having length as a subsequence of the string If th letter of the statement is not equal to then we don t have to change it Otherwise we either change the letter or let it stay as it is and the length of the prefix we found so far increases 
1086,Let s understand how many good vertices we may get if only edges remain This value is not greater than since an edge an add only one good vertex and for we have a good vertex with index This is an upper bound let s try to find a solution getting exactly good vertices or if all vertices of the graph will be good Let s run Dijkstra s algorithm from vertex and stop it as soon as we know the shortest paths to vertices including vertex The answer should contain the edges belonging to the shortest path tree built on these vertices 
1087,Let s define then it should be obvious that we need at least coins to buy a bag of chips of cost Now it s not hard to prove that coins is always enough to buy a bag of chips of any cost Proof if we ll take coins of value coin and coin if we ll take coins and two coins if we ll take coins one coin and two coins So the question is how to decide is coins enough The solution is to note that there is no need to take more than coins and more than coins so we can just brute force the number of coins we ll take and the number of coins we ll take Then the number of coins and we can check is it possible to pay exactly using at most and coins respectively There exists casework solution as well but it s quite tricky so brute force is preferable The main problem for case work is the case since there are two different ways to take coins either coins and coin or coins and two coins In the first way you can t gather exactly and in the second one you can gather neither nor 
1088,Firstly let s learn the structure of good array with maximum Suppose then In other words we can group by and pairs will appear only inside each group It s easy to prove that if the group has size then it s optimal to split it in half one with and other with Then the number of pairs inside the group will be equal to It s also not hard to prove that in this case it s optimal to place all elements inside one group In other words it s optimal to make a half of all elements as and the other half as for some integer Then To achieve maximum the excellent array should also have this structure Let For a fixed if is even then we should choose exactly positions to set as but if is odd we can choose either or positions Let s analyze what happens with different Obviously While both and are in the segment for any In this case we can choose any as so there are exactly ways for even and ways for odd When then for where there is only one choice to set Analogically for where there is only choice to set What remains is elements without restrictions so there are ways to choose for even or ways for odd Note that it s convenient to say that if or so we don t need extra checks Lastly note that we can process all with one formula and there are only of with non zero number of ways to choose so we can iterate over all such straightforwardly The total complexity is because of precomputation of factorials and inverse factorials to calculate 
1089,Let s use bfs to calculate the smallest distances to all vertices from the vertex and from the vertex These will be and for all is the the current smallest distance between and What you need is to iterate over all pairs and check if the edge between them doesn t exist and neither nor is smaller than Overall complexity 
1090,If then the answer is because the just can divide all boxes to size and then fill the bag Otherwise the answer is If the answer is let s calculate the minimum number of divisions Let s consider all boxes from small to large Presume that now we consider boxes of size Then there are three cases if in binary representation of the th bit is equal to then we don t need boxes of size and we can merge it into boxes of size if in binary representation of the th bit is equal to and we have at most one box of size then we have to put it box in the bag and then merge the remaining boxes of size into boxes of size if in binary representation of the th bit is equal to and we have not boxes of size then we have to divide the large box into box of size let s presume that it s box of size After that we just continue this algorithm with box of size 
1091,Let s try to solve for one of the given permutations Let it be some How to make the answer for it at least Well we have to find another permutation such that How about at least Well the same Push to the right side of the equation Now think What does it actually mean for some permutation to be multiplied by It stays the same So the first elements of will be equal to the first elements of Thus you have to find a permumtation such that its inverse has the longest common prefix with This can be done in multiple ways For example you can store all inverses in a trie and traverse it with until you reach a dead end Or simply push all prefixes of each inverse into a set and iterate over Alternatively you can just sort inverses and do lower bound for in this list the permutation with longest common prefix will be either the result or the one before it Overall complexity per testcase 
1092,Imagine you are fighting the th monster and you fixed the type of units and their amount What s the win condition Rewrite it as Notice how we only care about for both the units and the monster but not about and on their own Let s call and the power of the squad and the monster You can see that for each cost we can only leave one unit type of that price that has the largest value of Let s call it Now let s learn to determine the maximum power we can obtain for cost exactly We can iterate over the cost of one unit and the count of units in the squad Since should not exceed that will take Propagate to be the maximum power for cost exactly We have the knowledge about cost exactly but we actually want no more than Calculate prefix maximums over that will be the maximum power we can obtain with no more than coins For each monster we just have to find the smallest such that Since the array is monotone we can use binary search Overall complexity 
1093,If Nura can buy k gadgets in x days then she can do that in x 1 days So the function of answer is monotonic So we can find the minimal day with binary search Denote lf 0 the left bound of binary search and rg n 1 the right one We will maintain the invariant that in left bound we can t buy k gadgets and in right bound we can do that Denote function f d equals to 1 if we can buy k gadgets in d days and 0 otherwise As usual in binary search we will choose If f d 1 then we should move the right bound rg d and the left bound lf d in other case If binary search found the value lf n 1 then the answer is 1 otherwise the answer is lf Before binary search we can create two arrays of gadgets which are selling for dollars and pounds and sort them Easy to see that we should buy gadgets for dollars on day i d when dollar costs as small as possible and j d when pounds costs as small as possible Let now we want to buy x gadgets for dollars and k x gadgets for pounds Of course we will buy the least cheap of them we already sort the arrays for that Let s iterate over x from 0 to k and maintain the sum of gadgets for dollars s1 and the sum of gadgets for pounds s2 For x 0 we can calculate the sums in O k For other x s we can recalculate the sums in O 1 time from the sums for x 1 by adding gadget for dollars and removing gadget for pounds Complexity O klogn 
1094,I know there exists solution and author of the problem promises to tell it to you here he explained it I d love to tell easier to code and about the same time to work solution At first notice that it is only enough to check the paths such that all vertices on it is divisible by some prime Let s for each calculate the path of the maximum length to pass through it That means that one part of this path goes down to one child of it and another part goes down to another child For each vertex we will store the lengths of maximum paths through vertices with values divisible by each prime in That is memory To recalc the answer we will store all values of children nodes sort them and update the answer with two pointers technique Don t forget about the case of Overall complexity 
1095,Let s prove that if then Let be the original graph and the complement of the graph Let s look at each pair of vertices If and belong to different components of the graph then there is an edge between them in the graph Otherwise and belong to the same component of the graph but since has more than one component there is vertex in other component of and there are edges and in That s why there is a connected path for any pair of vertices and the graph is connected Similarly the case is proved So if then the answer is NO Otherwise Consider the case where if we can swap and and output complement of the constructed graph To have components in the graph it is enough to connect the vertex with the vertex the vertex with the vertex the vertex with the vertex A particular cases are the tests and There is no suitable graph for them 
1096,There are several ways to solve this problem The model solution does it as follows Restore the characters of from left to right The first character is restored by query For each of the next characters let s ask if this character is new by querying and comparing the result with the number of different characters on the segment If it s new ask to obtain the th character there will be at most such queries Otherwise we can find the previous occurrence of the th character with binary search Let be the number of different characters from position to position If we want to find the previous occurrence of the th character we need to find the last index such that Since the value does not decrease when we increase we can find the last such that with binary search Unfortunately the number of queries of type will be too large if we just use binary search over the whole segment To decrease the number of queries we can use the fact that the value of we are interested in is the last occurrence of some character we already met there are at most such values and binary search among them will need only iterations 
1097,First of all we will calculate the sum of maximum and minimum values on all segments separatedly Then the answer is the difference between the sum of maximum values and minimum values How can we calculate the sum of minimum values for example For each element we will try to find the number of segments where it is the So we will calculate two arrays means that is the maximum index such that and and means that is the minimum index such that and So actually and represent the borders of the largest segment where is the and we need to exclude those borders While knowing these values we can calculate the number of subsegments where is the How can we calculate for example the array We will use a stack where we will store some indices in the array in such a way that if we change all indices to the values in the array they will be in sorted order the maximum element will be at the top of the stack and the minimum at the bottom Let s calculate from the minimum index to the maximum When we calculate we remove all elements such that from the stack since the stack is sorted all these elements will be at the top of the stack and when we encounter the first element such that it is guaranteed that all elements below it don t need to be deleted Then if there s any element on top of the stack it becomes the value of then we push into the stack Since every element will be added and deleted not more than one time the complexity of this algorithm is linear We can apply the same technique to calculate the values of and the sum of maximums 
1098,Firstly let s look at some point Let s find closest to it vertical and horizontal lines We will name the closest vertical lines from left and right as and and and as closest horizontal lines So and we can also note that either or Now let s note that if for some other point either or then to reach from we must go reach either or or or so the shortest distance will be strictly greater than the Manhattan distance If neither nor then we can show that it s always possible to find the shortest path equal to the Manhattan distance As a result for each point we should find the number of points such that and or The exception here is when lies on the same line as so we should not count such points We can note that since either or there is no such point that and simultaneously so we can calculate the pairs by and coordinates independently Let s focus on coordinates to calculate for coordinates we can just swap all coordinates Let s sort all points by coordinate To get rid of the case when points and lies on the same vertical street we can group them by coordinate and process by group since we sorted by groups are just segments There are no problems with the case when points lie on the same horizontal street since then and there are no other with If we store for each horizontal line the number of point inside the interval then when we need for point calculate the number of points with and we can just ask for value assigned to because and are consecutive elements in the array So we go through each group two times first collecting answer then updating values in appropriate s Note that we can calculate and with binary search using built in functions The resulting complexity is 
1099,Let s look at the permutation as at a graph with vertices and edges It s not hard to prove that the graph consists of several cycles self loops are also considered as cycles So the sequence is just a walking on the corresponding cycle Let s consider one cycle In permutation we have But since or so and in general case Now walking with step we can note that the initial cycle split up on cycles of length Looking at the definition of infinite path we can understand that all we need to do is to check that at least one of cycles have all vertices of the same color We can check it in time for the cycle and fixed The final observation is next for and such that the produced cycles will have the same sets of vertices and differ only in the order of walking so we can check only one representative for each i e we can take only such which divide We can handle each cycle of separately So using the approximation that the number of divisors of is we get time complexity 
1100,Observe the cost of inserting a single element Notice that inserting any value between the minimum of the sequence and the maximum of the sequence is free Why is this true The argument is similar to the algorithm of finding some such that for a continous function if you know some such that and such that As a more general idea it s free to insert some value into a segment such that and WLOG assume Let s find the position that is free If then you can insert between and since it s free Otherwise you can choose an arbitrary position will be either between and or between and or both of them Descend into the one that holds to continue the search Since the lenght decreases at some point you will reach the segment of length How does that help Well you can insert somewhere then insert somewhere The rest of insertions will be free Now it s an algorithmic problem First consider all options to insert both and between the same pair of elements Next assume you insert somewhere before Iterate from left to right maintaning the lowest price to insert Try to insert at the current position and into the cheapest position before it Then update the lowest price for inserting After you finish reverse the sequence and solve the problem again that will be the same as inserting before Overall complexity per testcase 
1101,Permutaion with one swap is called transposition Any permutation can be expressed as the composition product of transpositions Simpler you can get any permutation from any other one of the same length by doing some number of swaps The sign of the permutation is the number of transpositions needed to get it from the identity permutation Luckily not really this is pure math check out all proofs at wiki e g the sign can also tell us the parity of inversion count Now you can start with computing parity of inversion count of the original permutation naively check all pairs of indices Finally you can decompose queries into swaps any method will be ok Like you can swap and then and and so on this is swaps Then parity of inversion count of the resulting permutation will change if you applied odd number of swaps Overall complexity 
1102,The problem can be solved using closed formula it s need to calculate the sum of geometric progression The formula can be calculated using binary exponentiation I ll describe more complicated solution but it s more general If we have a set of variables and at each step all variables are recalculating from each other using linear function we can use binary matrix exponentiation There is only one variable in our problem The new variable is calculating using formula Consider the matrix and the vector Let s multiply and Easy to see that we will get the vector So to make iterations we should multiply and times We can do that using binary matrix exponentiation because matrix multiplication is associative As an exercise try to write down the matrix for the Fibonacci numbers and calculate the th Fibonacci number in time The matrix and the vector is under the spoiler 
1103,There are two key observations to this problem after each pair of moves the directions go back to the original ones after each move we can immediately go back and combining these observations we can derive that if we go from city to some other city we can always go back One of the solutions we can write using these observations is to build an undirected graph on vertices Each vertex represents a pair where is the city we are currently staying in and is the number of moves we made modulo Since each move is to a neighboring city each vertex is unreachable from and vice versa And since we can always go back and each pair of steps doesn t change the directions this graph is actually an undirected one So we can find the connected components of this graph using DFS BFS DSU and for each city print the size of the component the vertex belongs to Another solution is to find the leftmost and the rightmost city reachable from each city For example finding the leftmost reachable city can be done with the following dynamic programming let be the leftmost city reachable from Then if we can t go left from if we can make only one step to the left from and if we can make two steps we can take the answer from the city The same approach can be used to calculate the rightmost reachable city 
1104,What do we do when the array loses elements only from the left or from the right and the constraints obviously imply some quadratic solution Well apply dynamic programming of course The classic what is the outcome if only the letters from positions to non inclusive are left is the answer is the base case the draw both strings are empty Let mean that Alice wins be a draw and mean that Bob wins How to recalculate it Let s consider a move of both players at the same time From some state first Alice goes then Bob The new state becomes Alice picked some letter Bob picked some letter What s that pick exactly So they both got a letter prepended it to their own string Then continued the game on a smaller string and prepended even more letters to the string Thus if we want to calculate from we say that we letters and Now it s easy If is not a draw then the new letters change nothing the result is still the same Otherwise the result of the game is the same as the comparison of letters and How to perform both moves at once First we iterate over the Alice s move whether she picks from or from After that we iterate over the Bob s move whether he picks from or from Since we want to be the best outcome for Alice we do the following For any Alice move we choose the worse of the Bob moves the maximum of Among the Alice s moves we choose the better one the minimum one Overall complexity per testcase 
1105,This problem is given because on the Codeforces pages we often see questions like What is the method of the two pointers This problem is a typical problem that can be solved using two pointers technique Let s find for each left end the maximal right end that is a good segment Note if is a good segment then is also a good segment So the search of the maximal right end for we can start from the maximal right end for The only thing that we should do is to maintain in the array for each number the number of it s occurrences in the current segment and the number of different numbers in We should move the right end until the segment became bad and then move the left end Each of the ends will be moved exactly times 
1106,Let be the number of occurences of the number in the given array easy to see that we can ignore the numbers greater than Let s iterate over and and increase the value in the position in some array by the value So the value equals the number of numbers in the given array which divide Let s find the minimal with the maximum value Easy to see that the answer to the problem is the numbers which divide Let s calculate the complexity of the solution The number of the pairs we can bound with the value 
1107,Suppose It means that is also divisible by or is divisible by And backward if then is also divisible by or is divisible by Since is divisible by and is divisible by so In other words we proved that Now knowing the equivalence above we can understand that we are looking for the smallest such that In other words we are searching such that is divisible by some where is some divisor of The problem is that there are a handful of divisors for some But we can note that we can consider only divisors of if and is composite then there is some prime thus It s easy to prove that there are no more than prime divisors of some Now the question is how to find all these prime divisors Note that if you know only one prime divisor for each value from to then you can find all prime divisors for all in The prime divisors are next and so on until The final step is to calculate a prime divisor for each value from to where or We can do it by slight modifications of Sieve of Eratosthenes at the step where you have some prime and want to throw out all values set for each plus set As a result we firstly calculate Sieve in and secondly calculate answer for each pair in Note that the input and output is large so you should you tricks to speed up your input and output 
1108,Firstly notice that there is no difference between space and hyphen you can replace them with the same character if you want Let s run binary search on answer Fix width and greedily construct ad wrap word only if you don t option to continue on the same line Then check if number of lines doesn t exceed Overall complexity 
1109,Let s reformulate the solution to the form of dynamic programming the number of ways to split the gems so that the total amount of space taken is Then there are obvious transitions of either splitting the last gem or not And that can be easily rewritten in such a way that matrix exponentiation becomes the solution Overall complexity 
1110,Denote the answer to the problem Note that or what is the same where equals to one if is a magic number otherwise equals to zero Let s solve the problem for the segment Here is described the standard technique for this kind of problems sometimes it is called dynamic programming by digits It can be realized in a two ways The first way is to iterate over the length of the common prefix with number Next digit should be less than corresponding digit in and other digits can be arbitrary Below is the description of the second approach Let be the number of magic prefixes of length with remainder modulo If than the prefix should be less than the corresponding prefix in and if than the prefix should be equal to the prefix of it can not be greater Let s do forward dynamic programming Let s iterate over digit in position We should check that if the position is even than should be equal to otherwise it cannot be equal to Also we should check for should be not greater than corresponding digit in Now let s see what will be the next state Of course By Horner scheme Easy to see that To update the next state we should increase it Of course all calculations should be done modulo 
1111,Let s notice that in optimal answer all boards will be increased by no more than two It is true because if it is beneficial to increase the length of some board by three or more denote its length as then increasing to the length or is cheaper and one of these boards is not equal to any of its adjacent boards Noticing this we can write a solution based on dynamic programming Let s is minimum amount of money for making fence great moreover the last board with index we increase by Then value can be calculated as follows 
1112,Let s calculate the minimum number of operations to get the number from To do this it is enough to use BFS or dynamic programming Edges in the graph transitions in dynamic programming have the form for all Now the problem itself can be reduced to a knapsack problem there are items th item weighs and costs you have to find a set of items with the total weight of no more than of the maximum cost This is a standard problem that can be solved in but it is too slow although some participants passed all the tests with such a solution However we can notice that the values of should not grow too fast namely the maximum value of for does not exceed This means that the maximum possible weight is no more than and we can limit to this number i e make 
1113,Sort the weights now choosing and will split the array into three consecutive segments Consider a naive solution to the problem You can iterate over the length of the first segment and the second segment The third segment will include everyone remaining Now you have to check if there exist some and that produce such segment can be equal to the first element of the second segment since only all elements of the first segment are smaller than it Similarly can be equal to the first element of the third segment However if the last element of some segment is equal to the first element of the next segment no or can split the array like that Otherwise you can split an array like that So you can iterate over the lengths check the correctness and choose the best answer Now let s optimize it using the condition about powers of two First iterate over the size of the middle division which is a power of two Then over the length of the first segment which can be not a power of two Check if the first segment is valid So we fixed the length of the first segment and some value which is greater or equal than the length of the second segment That value isn t necessarily equal to the length of the second segment because the produced segment might be invalid So there is a greedy idea that the second segment should be as long as possible under the constraint that it doesn t exceed the fixed value The intuition is the following Consider the longest possible valid segment Now take the last element away from it We will have to invite one more participant to the middle division And that element will also get added to the third segment increasing its length So potentially you can only increase the required number of participants to invite This can be implemented in the following fashion For each position precalculate the closest possible segment border from the left Iterate over the size of the middle division as a power of two Iterate over the length of the first segment Find the closest border to the left of Get the lengths of the second and the third segments Find the closest powers of two to each length and update the answer Overall complexity per testcase 
1114,We will build the answer greedily from the highest significant bit to the lowest one Let s analyze how to check if the answer can have the highest bit equal to It means that every value in should have its highest bit equal to so for every exactly one of the numbers should have this bit equal to For both of the given arrays we can calculate how many elements have which value of this bit and then the number of elements with in this bit in the array should be equal to the number of elements with in the array and the same for elements with in and elements with in If these values are equal it means that the elements of and can be matched in such a way that in every pair the XOR of them has in this bit If it is so then the highest bit of the answer is otherwise it is Okay then let s proceed to the next bit Should we just do the same to check if this bit can be equal to in the answer Unfortunately that s not enough Let s look at the case We can get the value in the th bit or in the st bit but not in both So for the next bit we need to make sure that not only we can get in the result but we can also do this without transforming some of the s to s in the higher bits If it is impossible it doesn t matter if we can get in the current bit since it will be suboptimal so we have to use an ordering that gets in this bit In general case it means that we have to solve the following subproblem check if we can obtain in several bits of the answer let these bits be to are the bits that we have already checked is the new bit we are trying to check Let be the number that has in every bit and in every other bit The elements should be matched in such a way that If we group all numbers from and from according to the value of or then for every group of elements from there is a corresponding group in such that we can match the elements from the first group with the elements from the second group So if for every such group its size in is equal to the size of the corresponding group in then we can set all bits from to simultaneously Some implementation notes if the number of bits we need to check is big the number of groups can become too large to handle all of them since it is So to store the number of elements in each group we should use some associative data structure like for example in C If you use a map splitting elements into groups will be done in so in total you will get complexity of where is the maximum possible value in the input 
1115,Let s construct the graph the following manner Take all the vertices with and build a bamboo out of them Surely all but the end ones will have degree the diameter now is the number of vertices minus 1 One can show that building the graph any other way won t make the diameter greater How should we distribute the other vertices Two of them can be used to increase diameter And all the others won t matter they can be paired with any of the vertices with degrees to spare If no loops are added then the diameter won t change the path that was the longest won t become any shorter All those facts imply that the graph should be a tree and the sum of should be at least Overall complexity 
1116,There are greedy and dynamic programming solutions We will describe dynamic programming solution The main task is to choose some segment that is the answer to the problem while choosing positions to increase by To do this we can use dynamic programming where is the number of positions that have already been considered from to is the number of elements that have already been increased by from to is the flag showing the current state whether we are before the chosen segment inside the segment or after the segment Transitions in such dynamic programming are quite simple we have a choice either to increase by then the value of the th element is or not to increase then the value of the th element is we can also change the state of the flag note that you can only switch from the current state to the subsequent ones i e for example you cannot switch from the state the segment has already ended to the state inside the segment If the current state of the flag is inside the segment then or depending on the selected transition should be added to the dynamic programming value itself So we got a solution in 
1117,The naive approach is to iterate over and reverse the subsegment of the array and calculate the answer But this solution is too slow and works in Instead we can iterate over the center of the reversed segment and its length If the current segment is and we want to go to then the answer for the subsegment will increase by It remains to add the answer for and but without reversion this is easy to do if you pre calculate the prefix sums of the values 
1118,Firstly we can notice that the reverse of of odd length subarray does nothing because it doesn t change parities of indices of affected elements Secondly we can consider the reverse of the subarray of length as reverses of subarrays of length i e it doesn t matter for us how exactly the subarray will be reversed we can only consider changing parities Now there are two ways the first one is smart and the second one is dynamic programming Consider the first way Calculate the initial sum of elements on even positions Then let s create two arrays and There is for all from to and is for all from to Elements of the first array deonte the profit if we reverse the subarray tarting from the even position and elemnts of the second array denote the profit if we reverse the subarray starting from the odd position Now we need to find the subarray with the maximum sum in both arrays this will maximize overall profit and add this value to to get the answer This problem can be solved easily consider the sum of the subarray as the difference of two prefix sums To maximize it consider all right borders and minimize the value Iterate over all positions of the array maintaining the current prefix sum and the minimum prefix sum we meet Update then update and then update the answer with the value And the second way is author s solution and it is dynamic programming This idea can be transformed to solve such problems in which you need to apply some function to some small number of subsegments of course under some constraints on functions State of our dynamic programming is where and denotes the answer on the prefix of length if we didn t start reversing the subarray denotes the answer if we started reversing the subarray but didn t end it and denotes the answer if we ended reversing the subarray Transitions are pretty easy The value is just a ternary if statement If is true then return otherwise return The answer is Time complexity with both approaches is 
1119,First of all if is even then there is no solution since the number of calls is always odd one call in the beginning and each call makes either or recursive calls Then if is odd let s try to start with a sorted permutation and try to unsort it Let s make a function that will do it When we unsort a segment we can either keep it sorted if we already made enough calls or make it non sorted and then call and if we need more calls When we make a segment non sorted it s better to keep its both halves sorted an easy way to handle this is to swap two middle element It s easy to see that the number of calls is equal to the number of calls to sort the resulting permutation so we can use this approach to try getting exactly calls 
1120,Let s understand what MEX correct sequences look like It turns out there are only two types and For example the sequences and the empty sequence are MEX correct sequences of the first type and and of the second one Let s calculate the dynamic programming the number of MEX correct subsequences of the first type on the prefix of length with equal to and similarly the number of MEX correct subsequences of the second type on the prefix of length with equal to Let s look at the transitions in these dps and show that there are no other MEX correct sequences at the same time Let the current state be and we are trying to add an element equal to if then such an element cannot be added if then the value of will not change and the sequence is still of the first type which means we have a transition to if then the value of will increase by but it will still be of the first type which means we have a transition to if then the value of will not change but the sequence will become of the second type which means we have a transition to if then such an element cannot be added Let the current state be and we are trying to add an element equal to if then such an element cannot be added if then the value of will not change and the sequence is still of the second type which means we have a transition to if then such an element cannot be added because will increase by which means the absolute difference between and is greater than if then the value of will not change and the sequence is still of the second type which means we have a transition to if then such an element cannot be added Thus we considered all possible transitions adding a new element to the already MEX correct sequences and made sure that there are only two types While the solution itself works in time because each element has possible transitions in the dps it uses memory which does not allow us to write that solution as is However note that and similarly for differ in only a few positions in those that the element allowed us to make which means we can store only one dimensional arrays and Thus the final complexity of the solution is 
1121,Consider all possible strings of length on the alphabet of size there are of them Let be the number of occurrences of the th of them in the string The cost of the string by definition is Now let s suppose there are two strings and such that Then if we somehow reduce the number of occurrences of the string by and increase the number of occurrences of the string by the cost will decrease So in the optimal answer all the strings of length should appear the same number of times and if it s impossible the difference in the number of appearances should not be greater than Let s suppose that then our goal is to build a string where each string of length on the alphabet of characters appears exactly once The construction of this string can be modeled using Eulerian cycles build a directed graph with vertices where each vertex represents a character each arc represents a string of length and for every pair of vertices there is an arc from to it s possible that Then by finding the Eulerian cycle in this graph it always exists since the graph is strongly connected and for each vertex its in degree is equal to its out degree we find a string of length such that all its substrings are different so each string of length appears there once as a substring Okay what about the cases and Since the string we build for the case represents a cycle we can make it cyclical and repeat the required number of times then cut last several characters if it s too big For example if then the string for is it s not the only one but we can use it We can expand this string to by repeating the last characters and delete the last character so its length is By the way in this problem you don t have to implement the algorithm that finds Eulerian cycles The graph where we want to find the Eulerian cycle has a very special structure and there are many different constructive ways to find the cycle in it But if you can t use them you always can rely on the straightforward solution that explicitly searches for the Eulerian cycle 
1122,Due to the nature of BFS the visiting order consists of several segments first goes root has depth then all vertices with depth then all vertices with depth and so on Since any vertex of depth is a child of vertex of depth then it s optimal to make the number of vertices with depth as many as possible then make the number of vertices with depth as many as possible and so on Since children of a vertex are viewed in ascending order and form a segment in visiting order then an arbitrary segment of visiting order can be children of the same vertex iff elements in the segments are in ascending order These two observations lead us to a greedy strategy then let s find the maximum that segment is in ascending order they will be the children of and the only vertices of depth Next search the maximum such that segment is in ascending order they will be the children of and so on It s easy to see that this strategy maximizes the number of vertices of each depth level so minimize the height of the tree 
1123,We will use binary search to solve the problem Suppose we want to know if the answer is not less than Each array can be represented by a bit mask where the th bit is if the th element of the array is not less than or if the th element is less than If we want to verify that the answer is not less than we have to choose two arrays such that bitwise OR of their masks is Checking all pairs of arrays is too slow Instead we can treat the arrays represented by the same masks as equal so we will have no more than distinct arrays and we can iterate over pairs Overall the solution works in 
1124,The solution of the problem can be found clearly in constructive way An example for 1 2 1 3 1 4 1 5 2 3 2 4 2 5 3 4 3 5 4 5 1 where brackets mean that we call here some recursive function Since on each level of recursion we have only elements and there levels then the generation of the certificate is quite easy if on the currect level of recursion we can skip the whole part let s just skip it Otherwise let s build this part Anyway the built part of the cycle will have only length so the whole algorithm has complexity The answer is lexicographically minimum by the construction since on each level of recursion there is no way to build lexicographically smaller sequence 
1125,You can use straightforward way and calculate answer with l r dp with But there is a easier claim it s optimal to split gon with diagonals coming from so answer is Proof let s look at the triange which contains edge Let s name it If we can delete this triangle and go to gon Otherwise Let s look at triangle It always exists and Finally if we change pair of triangles to answer will decrease since and that s why Note that triangle changes to and so repeating this step will eventually lead us to situation As a result we can morph any triangulation into one mentioned above and its weight won t increase 
1126,At first let s sort broken pixels in non descending order by times they appear Obviously if the first broken pixels make monitor broken pixel won t fix it Thus binary search on answer will work Let s search for the first moment in time when the monitor becomes broken The function to check if in some moment monitor is broken looks the following way As we want to check if there is a submatrix of size which consists only of broken pixels let s precalc the array of partial sums is the number of broken pixels on submatrix from to is calculated as if is broken pixel otherwise Sum on submatrix of size then looks like Check all possible and from to and find out if there exists submatrix with sum equal to Overall complexity 
1127,Mouse jumps on a cycle at some point no matter the starting vertex thus it s always the most profitable to set traps on cycles The structure of the graph implies that there are no intersecting cycles Moreover mouse will visit each vertex of the cycle so it s enough to set exactly one trap on each cycle The only thing left is to find the cheapest vertex of each cycle This can be done by a simple dfs Overall complexity 
1128,Let s maintain the current availability of colors and the amounts of cars of each color Firstly color is never available When car of some color goes you check if the number of cars of color past before this one isn t smaller than the number of cars of color Only after that increment the amount by one If it was less then set its availability to false If car of color goes then simply increment its amount In the end iterate over all colors and check if it s both available and has higher or equal amount than the amount of cars of color Okay why this works As all the amounts cannot decrease color will become not available at some moment when car of color goes And this will be encountered either when the new car of color goes or in the end of the sequence Amount of cars of color doesn t update between this periods And if there was point when there became more cars of color than of color then this inequality will hold until the next moment we will check Overall complexity 
1129,Let s estimate the smallest possible achievable answer Let the number of the arrays of size greater than or equal to i be g i The answer is maximum lceil frac g i c i rceil over all i from 1 to k You can prove that you can t fit g i arrays in less than lceil frac g i c i rceil testcases with the pigeonhole principle Let that be called ans Ok let s now construct the solution for that estimate Sort arrays in the increasing or decreasing order and assign the i th array 0 indexed in that order to the i mod ans testcase It s easy to see that for any i the number of arrays of size greater than or equal to i is always restricted by lceil frac g i c i rceil Overall complexity O n log n k or O n k if you care enough to do counting sort 
1130,First solution write some data structure that would simulate the operations as they are given for example a segment tree or a Fenwick tree Probably will require optimization since the limits are strict Second solution notice that we have to find only one number belonging to the multiset For example let s find the minimum element We can do it with binary search as follows let s write a function that for a given element tells the number of elements not greater than in the resulting multiset To implement it use the fact that all elements are indistinguishable and all elements are indistinguishable too so the multiset can be maintained with just two counters Okay how does this function help The minimum in the resulting multiset is the minimum such that this function returns non zero for it and since the function is monotonous we can find the answer with binary search 
1131,Firstly we can find answers for all points that are adjacent to at least one point not from the set The distance for such points is obviously and this is the smallest possible answer we can get On the next iteration we can set answers for all points that are adjacent to points with found answers because they don t have neighbors not from the set the distance for them is at least It doesn t matter which point we will take so if the point is adjacent to some point that have the answer we can set the answer for the point as the answer for the point We can repeat this process until we find answers for all points In terms of the code this can be done by breadth first search BFS In other words we set answers for the points that have the distance and then push these answers to all adjacent points from the set in order of the increasing distance until we find all the answers Time complexity 
1132,This problem is a standard two dimensional problem that can be solved with one dimensional data structure In the same way a lot of other problems can be solved for example the of finding the maximal weighted chain of points so that both coordinates of each point are greater than the coordinates of the predecessing point Rewrite the problem formally for each we should count the number of indices so that the following conditions are hold and Let s sort all segments by the left ends from right to left and maintain some data structure Fenwick tree will be the best choice with the right ends of the processed segments To calculate the answer for the current segment we should simple take the prefix sum for the right end of the current segment So the condition is hold by sorting and iterating over the segments from the right to the left the first dimension of the problem The condition is hold by taking the prefix sum in data structure the second dimension 
1133,It s known that the diagonals of a parallelogram split each other in the middle Let s iterate over the pairs of points and consider the middle of the segment Let s calculate the value for each middle is the number of segments with the middle Easy to see that the answer is 
1134,Let s suppose that all permutation are good We counted the permutations giving the sequences where the first elements are sorted we denote the number of such permutations as and the permutations giving the sequences where the second elements are sorted we denote the number of such permutations as Then the answer is right No because we subtracted the number of sequences where first and second elements are sorted simultaneously we denote this number as twice So the answer is How can we calculate the value of It s easy to understand that the elements having equal can be arranged in any order So where is the number of elements equal to among can be calculated the same way How can we calculate the value of First of all there is a case where it is impossible to arrange the elements of the sequence so that the first elements and the second elements are sorted To check that we may sort the given sequence comparing two elements by and if are equal by If the sequence of second elements in the resulting sequence is not sorted then Otherwise equal elements of the given sequence can be arranged in any order So where are the elements that appear in the given sequence of pairs at least once 
1135,Let s build the answer with the sum equal to zero Let be even Let s place odd numbers in the first half of the array the number in the positions and the number in the positions and and so on Similarly let s place even numbers in the second half the number in the position and the number in the positions and and so on We can place the number in the leftover positions We can build the answer for odd in a similar way Easy to see that our construction will give zero sum 
1136,If the number of points is less than then the answer is obviously Else let s fix first points Check if there is a solution if st and nd points lie on the same line Just erase all points which lie on this line and check the remaining points if they belong to one line If we didn t find the answer let s check points and in the same way If its failed again then line which contains point can t contain points and so points and must lie on one line If we didn t succeed again then there is no way to do it so the answer is Checking that points and belong to the same line can be done by calculating 2d version of cross product It equals to if vectors and are collinear 
1137,Let s prove that in the set minimum elements will be from pairs where we ll take minimums and analogically maximums will be from pairs where we ll take maximums By contradiction let s look at two pairs and where we will take maximum from and minimum from and if we swap elements and and get pair the result won t change but now minimum from pair will be less than maximum from So we can always make pairs in such a way that the chosen minimum from any pair will be less than the chosen maximum from any other pair Let s make set as all elements which are not in In the same way we can prove that minimums of are from pairs where we took maximums and maximums are from pairs where we took minimums Let s say and are sorted Now we ve proven that for a fixed we should pair with and with It s not hard to prove that it s optimal to pair and in the same way For a fixed we can just check that constructed pairs are valid But what happens if we move from to If for all was valid then for all pairs will be valid as well And on contrary if at least one pair wasn t valid then for the pair won t be valid as well Due to monotony we can find the maximum valid just checking only pairs and in the same way we can find maximum minimum such that all pairs are valid That s why all valid s form a segment and we need to find its borders We can find a maximum maximum with either binary search or with two pointers and print the length of the segment Time complexity is either or 
1138,In this editorial represents the number of vertex we are currently in Let be the maximum integer number such that is divisible by or the number of zeroes at the end of the binary representation of It is easy to prove that if then is a leaf if then both children of are leaves and so on Even more the difference between and any of his children is exactly So to traverse to the left child we have to subtract from if is not a leaf and to traverse to the right child we add to How can we process traversions up Let be the number of the parent node has exactly zeroes at the end of its binary representation so to traverse from to we need to either add or subtract from And to traverse from to we also have to either subtract or add to One of these operations will lead us to the number divisible by and not divisible by and we need to choose this operation Time complexity is 
1139,We have for each we can rewrite this as follows or From here we can see that for each there is a segment of values that can be assigned to So we have to match each number from to with one of these segments To solve this problem we can iterate from to Let the current number be then it can be paired with a segment without a pair such that and the right bound is minimum among all such segments because it will be the first to end among these segments To do this it is enough to maintain a set with open segments that have not yet been assigned a pair and choose from it a segment with the minimum right bound Before running this method you can sort the segments by their left border so they can be easily added to this set when we go from to we will need to insert all segments that begin with that s why it s convenient to have them sorted by their left border beforehand 
1140,Denote as the number of teams that can be winners in the th game The answer to the problem is If the th game is played between the winners of games and then if if if So we can calculate all values of for the initial string Note that the result of no more than other games depends on the result of any game So if we change it will change no more than values of and we can recalculate all of them For convenience you can renumerate the games so that the playoff looks like a segment tree i e the final has the number the semifinals have numbers and etc 
1141,Firstly let s prove that the order of characters in s is interchangeable Suppose we have a tournament of four teams with skills a b c and d such that a b c d and this tournament has the form 01 or 10 It s easy to see that a and d cannot be winners since a will be eliminated in the round with type 1 and d will be eliminated in the round with type 0 However it s easy to show that both with s 10 and with s 01 b and c can be winners Using this argument to matches that go during phases i and i 1 a group of two matches during phase i and a match during phase i 1 between the winners of those matches can be considered a tournament with n 2 we can show that swapping s i and s i 1 does not affect the possible winners of the tournament So suppose all phases of type 1 happen before phases of type 0 there are x phases of type 1 and y phases of type 0 x y n 2 x y 2 y teams will be eliminated in the first part phases of type 1 and the team with the lowest skill that wasn t eliminated in the first half will win the second half It s easy to see that the teams with skills 1 2 x 1 cannot pass through the first part of the tournament since to pass the first part a team has to be the strongest in its subtree of size 2 x Furthermore since the minimum of 2 y teams passing through the first half wins the winner should have skill not greater than 2 x y 2 y 1 the winner should have lower skill than at least 2 y 1 teams so teams with skills higher than 2 x y 2 y 1 cannot win Okay now all possible winners belong to the segment 2 x 2 n 2 y 1 Let s show that any integer from this segment can be winning Suppose k in 2 x 2 n 2 y 1 let s construct the tournament in such a way that only team with skill k and 2 y 1 teams with the highest skill pass through the first part of the tournament obviously then team k wins There are 2 y independent tournaments of size 2 x in the first part let s assign teams with skills from 1 to 2 x 1 and also the team k to one of those tournaments for all other 2 y 1 tournaments let s assign the teams in such a way that exactly one team from the 2 y 1 highest ones competes in each of them It s easy to see that the team k will win its tournament and every team from the 2 y 1 highest ones will win its tournament as well so the second half will contain only teams with skills k and 2 n 2 y 2 2 n and obviously k will be the winner of this tournament So the answer to the problem is the segment of integers 2 x 2 n 2 y 1 
1142,Let s consider the following string If digit occurs times in it then string have subsequences Let s increase the number of digits in this string while condition holds is the number of digits in this string The length of this string will not exceed because The value will not exceed as well All we have to do is increase the number of subsequences in the current string by So if we add digits after the first two digits we increase the number of subsequences by The string will look like this where sequence consists of exactly digits and sequence consists of exactly digits 
1143,The first observation we need is that we can choose two prefixes of as the substrings used in forming the results This can be proved easily suppose we chose a substring which does not contain the leftmost character of if we expand it to the left the answer won t become worse So it is optimal to choose two prefixes of as the substrings Furthermore one of these prefixes must be itself if the leftmost index of is the length of the answer won t exceed but the only way to have a in the th bit of the answer is to choose a prefix of where the th character from the right is and there is only one such prefix of which is itself So now we can solve the problem in try to combine all prefixes of with itself and choose the one that yields the best answer To speed this up we need to somehow cut down on the number of prefixes of we check Let s look at the first block of s in The next character after this block is since we take as one of the substring in order to get instead of in the corresponding position of the answer we need to choose a prefix which has in that position This represents one of the s from the first block of s since only one of them can shift to that position So we need to check only the prefixes such that by using them we shift some character from the first block to the position of the first after this block Since the tests are random the expected length of the first block of s is furthermore even the probabiliy that its length is or bigger is about so the expected number of prefixes we need to check is also Thus the expected runtime of our solution is 
1144,We can process the cases of zero or one swap in time Consider the case with two swaps Note we can assume that two swaps will lead to move two elements from to and vice versa in other case it is similar to the case with one swap Let s iterate over all the pairs of the values in and store them in some data structure in C we can user map Now let s iterate over all the pairs and find in out data structure the value closest to the value and update the answer by the value Required sum we can find using binary search by data structure map in C has lower bound function 
1145,The value of always changes by thus the set of values of is always some contiguous segment The length of such segment can be determined by just its minimum and maximum values So we have to solve two separate tasks for each query find the minimum and the maximum value gets assigned to I ll describe only the minimum one This task however can as well be split into two parts minimum value on a prefix before and on a suffix after The prefix is easy it doesn t get changed by a query so it can be precalculated beforehand Minimum value on a prefix of length is minimum of a minimum value on a prefix of length and the current value The suffix minimum is not that trivial First in order to precalculate the minimum value on a suffix of length we have to learn to prepend an instruction to the suffix of length Consider the graph of values of over time What happens to it if the initial value of is not but for example It just gets shifted by upwards That move is actually the same as prepending a instruction So the minimum value for a suffix of length is a minimum of a minimum value for a suffix of length increased by the current instruction and the start of the graph So now we have a minimum value on a suffix after However it can t be taken into the answer as it is because it considers the graph for the suffix to be starting from And that s not the case The graph for the suffix starts from the value the prefix ends on So we can shift the answer for the suffix by the value of after the prefix The overall minimum value is just the minimum on a prefix and on a suffix then Overall complexity per testcase 
1146,Let s solve the problem greedily But not from the beginning because if we solve it from the beginning we can t be sure what option is more optimal for the next elements e g for the second element it is not clear if we need to add to it starting our segment from the first position or add to it starting our segment from the second position So let s solve the problem from right to left then anything becomes clearer Actually let s operate with the array and decrease its elements instead of using some other array Let s carry some variables and the array of length along with the answer The variable means the value we need to subtract from the current element from currently existing progressions is the number of currently existing progressions and means the number of progressions that will end at the position i e will not add anything from the position and further to the left When we consider the element firstly let s fix decrease it by Then let s fix decrease it by Then let s decrease by and if it becomes less than or equal to zero just proceed Otherwise the number by which we can decrease the th element with one progression equals to zero indexed Then the number of progressions we need to satisfy this element is Let s add this number to the answer increase by increase by and if then we need to end these progressions somewhere so let s add to Time complexity 
1147,We have to find the number of triples such that equations and are satisfied Let s subtract one equation from another and get that So we know that and after substituting we get that We can see that there is only one correct value of and for every odd value of greater than So we can iterate over the value of and check that the corresponding value of doesn t exceed This solution works in because but you can also solve it in 
1148,The crucial observation is that when the positions of towers are fixed the way to set their signal powers is unique if it exists That s because the first tower should have its signal power exactly equal to the required to cover all towns before it the second tower should have signal power exactly equal to the required to cover all towns before it that weren t covered by the first one and so on So let s count the number of ways to cover all towns and then divide it by Covering all towns can be expressed as splitting into the sum of several positive odd integers It can be calculated with dynamic programming with prefix sums but we can also prove that the number of ways to split is exactly the th integer in the Fibonacci sequence as follows this proof uses mathematical induction for it s quite obvious for and let s iterate on the length of the last segment We have to sum and so on until we get for and let s iterate on the length of the last segment and add to result since we can cover everything with a single segment So this is and so on So the answer to the problem is The last thing we have to consider is that we have to print a fraction modulo Since is a prime using Fermat little theorem we can calculate as Exponentiation must be done with some fast algorithm for example binary exponentiation Note it s common in problems requiring to calculate something modulo some prime number to have problems with overflow in intermediate calculations or some other issues when we forget to take the result of some expression modulo I recommend using either special addition multiplication exponentiation functions that always take the result modulo an example how to write and use them can be viewed in the model solution or a special modular integer data structure with overloaded operators that you have to implement by yourself 
1149,Imagine you fixed some cut and then colored one row red Which rows can now be colored red or blue so that the condition on the left matrix is satisfied If the row has at least one number greater or equal than the numbers in the red row then the row must be red Otherwise it can be either red or blue However imagine a weaker condition Let s look only at the first cell in each row Sort the rows by the first cell in them Similarly if a row is colored red all the rows that are further in the sorted order should also be red because they already have a greater or equal number in them It implies that after you sort the rows the only possible colorings are color some prefix of the rows in blue and the remaining suffix in red So there are possible colorings and possible cuts If we learn to check if they are perfect in we can get the solution in Turns out the condition all numbers in the submatrix should be greater than all numbers in the other submatrix is the same as the minimum in the first submatrix should be greater than the maximum in the second submatrix Thus you can first precalculate prefix and suffix minimums and maximums and check a coloring and a cut in Overall complexity per testcase 
1150,Even though is up to straightforward solution will work You iterate for from to in the outer loop from to in the inner loop and check each time When edges are found you break from both loops Here is why this work fast enough The total number of pairs with is where is Euler s totient function We also want to substract a single pair And this sum grows so fast that after about iteratons will be greater than for any The only thing left is to check that is big enough to build a connected graph and small enough to fit all possible edges for given the formula above Overall complexity 
1151,One of the possible approaches to this problem is to try multiplying only by the largest digit in it Unfortunately this doesn t work quite well since it gives WA on one of the examples That example is too big to consider but a smaller version of it can prove that this is an incorrect solution let If we multiply by we get and there s no way to obtain a number with digits using the next action But if we multiply by we get which can then be multiplied by to obtain a digit number So considering only the largest digit is not enough This implies that we somehow need to consider the options that are not optimal locally but optimal globally i e choose a lower digit right now to obtain a higher digit in the future Let s try to estimate the number of possible integers that can be obtained using these operations to see if we can consider all possible options The key observation is that each integer we obtain will have the form since only one digit primes can be added to the factorization Since we consider only numbers less than is not greater than is not greater than is not greater than and is not greater than and the number of reachable integers is about million note that this is a very generous bound since not all combinations of yield an integer less than and not all such integers can be reached with the operations This allows us to use BFS or dynamic programming to calculate the answer 
1152,Start with the following Let s look at the input format and consider what the operation actually does to it Since it only changes the parent of some vertex it modifies only one value in it Moreover it just assigns it to Thus the goal is to assign at most values of parents to to minimize the resulting height of the tree In particular that implies that we can freely rearrange the operations since the assignments don t depend on each other One more conclusion Imagine we have already built some answer One by one we moved some subtrees to be children of the root It could happen that we first moved some subtree of a vertex and then applied the operation to an edge inside the subtree of Let s show that it s always possible to rearrange the operations in the answer to avoid that Just apply the operations in order of decreasing the depth of the vertex If we knew what height we want to get we could have been making sure that cut subtree has height at most since it gets increased by when glueing it to the root then pretending that that subtree doesn t exist anymore Moreover it s always required to cut subtrees with height at most If you cut a higher subtree then the answer can t be smaller than since we rearranged the operation to not touch that subtree anymore Well let s fix that height if we wanted that Let s try the solve the opposite problem How many operations will it require to make the tree height at most Obviously the values for this problem are non increasing the greater we allow the height to be the less operations it will require Thus we will be able to apply binary search to it to find the smallest height we can achieve with at most operations Now we want to be choosing the subtrees of height at most repeatedly and cutting them off until the height of the tree becomes at most Let s think greedily If the height of the tree is not at most yet then there exists a vertex with the depth greater than Let s look at the deepest of them That leaf has to be cut in some subtree Otherwise the tree won t become any less higher What subtree is the best for it What options do we have That vertex itself and all its parents up until above It s always optimal to cut the highest of them the st parent since it will remove at least all the vertices of any other cut and some other vertices along with them It s also always possible to remove the st parent since it will always have height exactly The vertex we are looking at is the deepest in the entire tree there are no deeper vertices in the subtree of the st parent Thus the strategy is to keep cutting the st parent of the deepest vertex until the tree becomes at most height Now about the implementation details First we can process the vertices from the deepest upwards in their order in the original tree The operation only removes some vertices but doesn t change the depth of the remaining ones For example you can do a bfs from the root to find the order Now the st parent Let s find it for each vertex before starting the process Run a dfs and maintain the stack of the ascendants When going down the child append it to the stack What exiting pop from the stack Now you can just look at the st element from the top of the stack To be able to do that simulate the stack with a vector C or a list Python Finally we would have to determine if the current vertex in the order is removed or not For that we could maintain a boolean array for the removed vertices Once you apply the operation run the dfs from the removed vertex and mark all the newly removed descendants of it in If you don t go into already marked vertices there will be no more than calls of the dfs The number of cut vertices is the answer for the fixed height Overall complexity per testcase 
1153,What if there were no blocked cells Then the movement is easy From cell we can go to cells or Thus we can visit all cells that have the same remainder modulo over both dimensions The answer would be if and Let s choose the following path from start to finish Let be less or equal to If that isn t the case swap the cells First move up until the row is the same then move to the side until the column is the same What stops us from doing the same on a grid with blocked cells The first part of the part can remain the same we can always move up from the cell Only cells below the start cell can be blocked The second part is trickier If there is a column with too many blocked cells between the start and the finish column then we won t be able to pass through it Let s adjust the path for that Move up as high as possible to the highest cell with the same remainder modulo in this column Then move to the finish column and go down to the finish cell If there still exists a column with too many blocked cells then the answer is No matter what we do we won t be able to go around that column Otherwise the answer is Thus the solution is to check for remainders then find the largest number of blocked cells between the query columns and compare it to the highest row with the same remainder modulo as the start or the finish You can use any RMQ data structure you want Overall complexity with sparse table for RMQ for example 
1154,Let s use dynamic programming to solve this task Obviously the of the number is determined by minimum of powers of and in the number Let be the maximal power of in the number and be the maximal power of Let be the maximum amount of twos we can collect by checking first numbers taking of them with total power of five equal to It is usually called the knapsack problem There are two types of transitions You can either take current element or skip it The answer will be maximum of for every Also keeping this many states can cause ML the first dimension should be stored in two layers and recalced on the fly Overall complexity 
1155,Let be equal minimum amount of money to obtain the median salary at least We ll solve this problem by binary search by Suppose the have to calculate the minimum amount of money for obtaining median salary at least Let s divide all salaries into three groups In order to the median salary be at least there must be at least salaries greater than or equal to Let s denote the number of such salaries as Note that salaries of the first group can t increment the value of so it s beneficial for us to pay the minimum salary for this group Salaries if second group always increment the value of so it s also beneficial for us to pay the minimum salary The salaries from the third group are more interesting For each salary in this group we can pay and increment or we can pay and don t increase The value of should be increased by So if the size of the third group is less than than we can t obtain the median salary Otherwise we can define how many salaries we can take with value and chose the minimal ones 
1156,The Euclidean algorithm is based on the next fact if then So if then So we can declare that we are looking at different integers with so all forms a segment So we need to find the number of such that Let s denote then and So or Since so we also can represent and therefore Since then or we need to calaculate the number of such that Since so we can consider and this is the definition of Euler s totient function which is the answer Euler s totient function can be calculated using factorization of Then 
1157,Let s consider the optimal answer to always look like will be the leftmost position of a pillar with maximum height We will heavily use the fact that all integers from to appear in this sequence to the right of If you are able to construct any answer it is easy to rearrange it to this pattern select the leftmost maximum sort in non decreasing order and in non increasing order Sorted sequence will also be valid Let a pyramid of height be such a valid castle that it occupies exactly consecutive spots and Exactly sand packs are required to build it At first let s solve the problem without even touching the fence This won t always give the minimal answer but it ll help us further Given some you can build the pyramid of height and get sand packs left over This can fit in exactly pillars you can place any pillar of height next to some pillar of the same height That way we see that This function is non increasing let s show that for any from to is non positive Now we can show that it is always optimal to push the initial pyramid to the left as far as possible probably removing some pillars on positions less than That way the leftmost pillar will have height The total number of sand packs required to build it is This pattern will also include all the integers from to and will have the minimal width you can achieve Monotonicity of this function can be proven in the similar manner Finally the answer can be calculated using the following algorithm Find the maximum such that where Solve the equation or just do the binary search Output the width of resulting truncated pyramid plus the minimal number of additional pillars it will take to distribute leftover sand packs You should also take into consideration the upper bound on to avoid multiplying huge numbers It s about so bit integer type will be enough for all the calculations Overall complexity or 
1158,First of all how to deal with the fractions modulo 998244353 According to Fermat s little theorem x phi m equiv 1 mod m if x is coprime with m So the inverse element for the denominator y is y phi 998244353 1 y 998244351 taken modulo 998244353 A cool property of fractions taken modulo 998244353 or any other number such that denominator is coprime with it is that if we want to add two fractions together and calculate the result modulo some number we can convert these fractions beforehand and then just add them as integer numbers The same works with subtracting multiplying dividing and exponentiating fractions Okay now for the solution itself We know that there are at most 10 6 possible pairs of x y we can iterate on these pairs calculate the probability that the fixed pair is included in the robot s decision that probability is frac 1 x cdot k x and calculate the probability that x y extends to a valid triple it is equal to frac cnt y z where cnt y is the number of kids who want item y Multiplying these two probabilities we get the probability that x y is chosen produces a valid decision since these events are independent and we sum up these values over all possible pairs x y 
1159,Note that in the beautiful string s i neq s i 1 because it is a palindrome of length 2 and s i neq s i 2 because it is a palindrome of length 3 This means s i s i 3 i e a beautiful string has the form up to the permutation of the letters and For each permutation of the letters and we will construct a string t of the form of length n Let s define an array a of length n as follows a i 0 if s i t i i e the character at the i th position does not need to be changed and a i 1 otherwise Let s build an array pr of prefix sums of the array a Now you can process a query of the number of positions that need to be replaced for the current line t in O 1 
1160,At first note that of segments and can be calculated as If it s negative then segments don t intersect otherwise it s exactly length of intersection Now we have two major cases do segments and already intersect or not If segments intersect then we already have as the total intersection Note that making both segments equal to in each pair are always optimal since in each step we will increase the total intersection by After making all segments equal to we can increase total intersection by only in two steps we need to extend both segments in one pair In result we can find not a hard formula to calculate the minimum number of steps we already have of the total intersection then we can increase it by at most using one step per increase and then to any number using two steps per increase In the case of non intersecting and we should at first invest some number of steps in each pair to make them intersect So let s iterate over the number of segments to invest We should make steps to make segments touch Now segments touch so we can use almost the same formulas for them as in the previous case The total complexity is per test case 
1161,The main idea of the solution is to find a linear number of intersections of segments Intersections can be found with sweep line approach We will maintain a set for the endpoints open segments When we add a segment we find all segments which intersect with it that is all segments that end earlier than it Obviously if the number of intersections are greater than then the answer is So as soon as we find intersections we stop our algorithm After that it is necessary to check the connectivity of the resulting graph You can use DFS or DSU to do this 
1162,The main fact that allows us to solve this problem is that the value of always increases after swaps and since the resulting sequence should be sorted the indices of elements we swap with also increase This observation is actually enough for us to implement a dynamic programming solution of the form dp i j is the minimum number of actions we have to perform to reach the following situation the last integer we swapped with was and the current value of is Depending on your implementation it works either in or in But there exists a much simpler to code greedy solution scan the array from left to right until it is sorted and find the first element such that we can apply the operation to it and apply that operation to it Implementing it in or even in is easy but proving it is a bit harder The key fact that is required to prove it is that if we can apply an operation to some position but don t do it and instead apply this operation to some position to the right of that one the elements on these two positions are no longer sorted if we can apply the operation to some position then but if we apply the operation to position instead then after it Since we can t go backward the resulting array cannot be sorted by any means that s why we can t skip elements in this greedy solution 
1163,We could iterate on the substrings we want to shuffle and try to count the number of ways to reorder their characters but unfortunately there s no easy way to take care of the fact that shuffling different substrings may yield the same result Instead we will iterate on the first and the last character that are changed Let these characters be and First of all let s check that they can belong to the same substring we can shuffle it is the case if the string contains at least characters and the substring from the th character to the th character contains at most characters Then after we ve fixed the first and the last characters that are changed we have to calculate the number of ways to shuffle the characters between them including them so that both of these characters are changed Let s calculate and the number of characters and respectively in the substring Then we need to modify these two values for example if the th character is then since it is the first changed character it should become so we need to put there and decrease by one The same for the th character Let and be the values of and after we take care of the fact that the th and the th character are fixed The remaining characters can be in any order so the number of ways to arrang them is We can add up these values for all pairs such that we can shuffle a substring containing these two characters We won t be counting any string twice because we ensure that is the first changed character and is the last changed character Don t forget to add to the answer the string we didn t count is the original one This solution works in but the problem is solvable in 
1164,Consider the subset that is the answer to the problem Let be the arbitrary three elements from and let no more than one of them is equal to By the pigeonhole principle two of three elements from have the same parity So we have two integers with even sum and only one of them is equal to so their sum is also greater than So the subset is not simple In this way consists of only two numbers greater than one with a prime sum or consists of some number of ones and also maybe other value so that is a prime We can simply process the first case in time The second case can be processed in linear time Also we should choose the best answer from that two To check the value of order for primality in time we can use the simple or the linear Eratosthenes sieve 
1165,The easiest part of the solution is to notice that if the charger of power works then the charger of power also works Thus binary search is applicable to the problem is really small and only one laptop can be charged during some minute It implies that check function can work in something polynomial on by searching for the right laptop to charge during every minute I claim that the greedy algorithm works Find the laptop that gets his charge below zero the first Charge it for one minute as early as possible Repeat until you either don t have time to charge the laptop check returns false or the contest is over check returns true Why greedy works Well check any case where check returns false If some laptop runs out of power then all the minutes up to the current one are used to charge something Moreover you can free no minute of these as by doing greedy we charged all laptops as late as possible Freeing some minute will lead to other laptop dying earlier One way to implement this is the following Keep a heap of events pop its head add to it if the time is greater than the number of charges already made and push it back to heap That will simulate the entire process in Unfortunately this may be too slow on some implementations Let s try the following linear approach Maintain not the heap but such an array that th its cell contains all indices of all the laptops to run out of charge on the beginning of minute Keep an iterator to the first non empty position Pop a single index out of this vector charge it and push it to the new position You ll still make steps and on each step you ll make instant operations That will make it for this simulation I m not really sure how to build the maximal answer case however I can estimate the upper bound of binary search You can set in such a way that it charges every laptop in one minute so that it won t run out of power until the end of the contest Choose the smallest the greatest the greatest and you ll end up with total usage Thus will always be enough Overall complexity or if you are skillful enough to squeeze it D 
1166,Suppose the string consists of characters and each character is different from the adjacent ones so the string looks like or It s easy to see that we can t make more than operations each operation deletes at least two characters except for the case when the string consists of only one character And there is an easy way to perform exactly operations always choose the last character and delete it Okay what about the case when some adjacent characters in the string are equal It s never optimal to delete a character that s different from both adjacent characters since the second part of each operation always deletes the left block of equal characters this action merges two blocks so they will be deleted in one second part of the operation which decreases the total number of operations So we should always delete a character from a block with at least two equal characters From which of the blocks if there are more than one It s easy to see that we should choose a character from the leftmost such block since that block is the earliest to be deleted and if we want to make the same action later we might be unable to do it So the solution is greedy during each action we have to find the leftmost block consisting of at least equal characters and delete a character from it or the last character of the string if there are no such blocks Since the length of the string is up to and the number of operations is up to we should do it efficiently for example by storing the eligible blocks in some data structure 
1167,Let s reformulate this problem in next form we can sort only subarray of length 2 swap two consecutive elements and if It is simular tasks because we can sort any array by sorting subbarray of length 2 for example bubble sort does exactly that Now lets look at elements and If then we will solve this task for arrays and Otherwise lets look at minimum position such that if there is no such position then answer to the problem is We can move element to the beginning of array only if all elements greater then In other words any index such that must be greater then And if this condition holds then we just delete element and solve task for arrays and But instead of deleting this element we will change information about minimum index such that This index will be the minimum index such that and For do this we will maintain stacks such that for any element of stack condition holds and moreover all elements in stacks are sorted in ascending order the top element of stack is minimal For example if then For finding minimum element on top of stacks we can use some data structure for example segment tree 
1168,Notice that the order of letters doesn t matter at all depends only on amount of each letter Let be the possibility that string will occur in at least times after replacing all signs and after some swaps If is true then is also true That leads to binary search over the answer Let be the amount of letters in and the amount of letters in is the number of signs is true if If some letter appears in less times than needed then replace some signs with it Answer can be restored greedily by replacing signs with the letters needed Overall complexity where is the size of the alphabet 
1169,Consider a graph with vertices whose edges is the pairs from the input It s possible to swap any two values with the positions in some connected component in that graph So we can sort the values from any component in decreasing order Easy to see that after sorting the values of each component we will get the lexicographically maximal permutation 
1170,Eliminate the obvious corner case when we don t have enough water Now we don t consider it in editorial Let s fix some set of tanks and let be the total amount of water in the set If and have the same remainders modulo then we can transfer all water from to one tank transfer all water from to another tank and then using some number of operations transfer required amount of water from to or from to So we have a solution when we have some set of tanks such that What if we don t have such set In this case it is impossible to solve the problem since we cannot obtain a tank with water such that and obviously we cannot obtain a tank with exactly water To find this set we may use some sort of knapsack dynamic programming 
1171,Let s represent as and as where and By definition so we can represent as Now we can rewrite the equation from the statement as follows Since the left hand side is divisible by the right hand side should also be divisible So we can iterate over as divisors of If the right hand side of is not divisible by then we can skip such let s denote as If has some prime divisor then exactly one of and should be divisible by because and have no common divisors So there are pairs of and for current value of We can precalculate the minimum prime divisor for each number up to the maximum value of that you may need in using Eratosthenes sieve Now we can solve the problem in for each testcase but that s not fast enough To speed up this approach we can precalculate the number of prime divisors for each number up to Let s denote as the minimum prime divisor of and as the number of prime divisors of Then plus if Now to solve the problem we only need to iterate over the divisors of so the time complexity is per testcase 
1172,Consider the bruteforce solution You start with a build that contains the most powerful item for each slot In one move you swap an item in some slot for the one that is the previous one by power If a build is not banned update the answer with its total power banned builds can be stored in a set maybe hashset if you hash carefully enough Notice that if you reach some unbanned build in this bruteforce it never makes sense to go further The answer is already updated with this one and all the lower ones have smaller power If you code that bruteforce in a smart way or just add memorization you won t visit any build twice How many states will you visit though Since you can only proceed if you are standing in a banned build you will check around builds You can code it like that and get accepted However there s another way that s easier to code in my opinion The optimal answer can be one of only two types Either it contains the last item of each slot Or it s some banned build with one item swapped with the previous one It s easy to see from the solution above So you can check the first type then iterate over the banned build and try swapping each slot in it checking if the resulting build is banned or not Overall complexity or 
1173,Let s create two events for each segment li is the time of the segment opening and ri is the time of the segment closing Let s sort all events by time if the times are equal let s sort them with priority to opening events In C it can be done with sorting by standard comparator of vector pair int int events where each element of events is the pair with event time and event type 1 for opening and 1 for closing Let s iterate over events and maintain the balance To do that we should simply decrease the balance by the value of the event type Now if the balance value equals to k and before updating it was k 1 then we are in the left end of some segment from the answer If the balance equals to k 1 and before updating it was k then we are in the right end of the segment from the answer Let s simply add segment left right to the answer So now we have disjoint set of segments contains all satisfied points in order from left to right Obviously it s the answer to the problem Complexity O nlogn 
1174,There are a lot of different solutions for the problem Most of them have the similar structure The first part is to find the shortest distance between the states and where and are the coordinates of the square and is the current piece This can be done with 0 1 bfs Floyd or Dijkstra Just represent the triple as a single integer by transforming it to and do everything on that graph The second part is to write some dp to go from th square with piece to th square with piece The value of this is a pair moves replacements It is easy to see that you can always choose the minimum of two such pairs while updating Overall complexity may vary We believe is achievable However the particular solution I coded works in 
1175,The problem can be solved in the following dynamic programming manner Let be the smallest number of hours Ivan can spend in university in the first days while having lessons skipped To calculate it we can store minimal number of hours Ivan is required to spend in the th day so that he attends lessons Then we can iterate over all lengths from to and update with Precalc works in and dp can be processed in 
1176,There are many different ways to solve this problem but in my opinion the easiest one is to count all possible triples and subtract the number of bad triples The first part is easy the number of ways to choose elements out of is just The second part is a bit tricky What does it mean that the conditions in the statements are not fulfilled There is a pair of problems with equal difficulty and there is a pair of problems with the same topic Since all problems in the input are different it means that every bad triple has the following form i e there exists a problem such that it shares the difficulty with one of the other two problems and the topic with the remaining problem of the triple This observation allows us to calculate the number of bad triples as follows we will iterate on the central problem the one that shares the topic with the second problem and the difficulty with the third problem If we pick as the central problem we need to choose the other two Counting ways to choose the other problems is easy if we precalculate the number of problems for each topic difficulty let be the number of problems with topic and be the number of problems with difficulty then if we pick the problem as the central one there are ways to choose a problem that shares the topic with it and ways to choose a problem that has the same difficulty so we have to subtract from the answer for every problem 
1177,First let s understand that if we choose some subset of points then it does not matter to which point we move it inside the segment because the minimum number of moves will always be the same and it is equal to Okay we need to split all points into two subsets and collect all points of the first subset in some point inside it and the same with the second subset What can we notice If we sort the points it s always optimal to choose these subsets as segments I e if the maximum point of the first subset is the minimum point of the second subset is and we can swap them and decrease answers for both subsets So we need to cover all the points with two segments with the minimum total length What is this length It is is the maximum distance between two consecutive points i e So we can solve the problem in without queries But how to deal with queries Let s maintain the set which contains all points and the multiset set with repetitions that maintains all gaps between two adjacent points So the answer is maximum in the set of points minus minimum in the set of points minus maximum in the multiset of lengths How do we recalculate these sets between queries If some point is removed let s find the maximum point less than let it be and the minimum point greater than let it be in the current set of points Both these points can be found in a logarithmic time Then we need to remove with from the multiset and add to the multiset and of course remove from the set If some point is added then we need to remove from the multiset and add with to the multiset and add to the set So we can process every query in time and the total time complexity is 
1178,Let s ignore the constraint on the number of red blue vertices for a moment What is the maximum possible weight of a coloring From any triple we can have any two edges connect vertices of different colors So the maximum possible weight of a coloring not necessarily a valid one is the sum of all edge weights except for the minimum weight in each triple Let s show that it is always possible to choose a valid coloring to achieve this weight In each triple we should make sure that the two maximum edges connect vertices with different colors to do this we can color the vertex incident to both of these edges in one color and the two other vertices will be painted in the other color So for each triple of vertices there will be either one red vertex and two blue ones or two red ones and one blue Let s suppose the first triples have one red vertex and two blue vertices each and the other triples have one blue vertex and two red vertices each That way we obtain a valid coloring with maximum possible weight Okay now let s try to find out how do we calculate the number of valid colorings with the maximum possible weight Each triple of vertices will be either red two red vertices one blue or blue the other way around Since exactly half of the vertices should be red then exactly half of the triples should be red so the number of ways to choose a color for all triples is After choosing the color of each triple let s choose how we actually color them The triples are independent so for each triple we can introduce the coefficient which is the number of ways to color it so that its weight is maximized and the triple has some specific type either red or blue doesn t matter since these are symmetric Choosing the vertex which will be different from its neighbors is equivalent to choosing the edge which will not be included in the weight of the coloring this is the edge which is not incident to the chosen vertex So is equal to the number of ways to choose that vertex in the th triple so that the weight is maximized i e the weight of the edge not incident to the chosen vertex should be minimized Thus is just the number of minimum edge weights in the th triple The formula for the final answer is 
1179,I wanted to give this problem a lot of time ago I thought it is very standard problem but I underestimated its difficulty Let s write down the equation describing the problem So we have linear Diofant equation with two variables The solution has the form where the last equation can be solved by extended Euclid algorithm and is any integral number The variable should satisfy two conditions and The values and are fixed so we can get the segment of possible values for the values The length of the segment is the answer for the problem 
1180,Firstly for the fast factorization of given let s use Sieve of Eratosthenes let s for each value calculate its minimum prime divisor in the same manner as the sieve do Now we can factorize each in time by separating its prime divisors one by one using precalculated array Suppose we have a factorization If then any divisor of is divisible by so do the sum of divisors Obviously the answer is Otherwise we can divide all prime divisors into two non empty groups and and take and Any division is valid proof is below so for example we can take and Let s prove that if and then Let s look at any We can assume that and without loss of generality But it means that then In other words there are no prime divisor of which divides so the Time complexity is for the sieve and finding answers 
1181,Let s solve this problem with dynamic programming Let be the maximum answer if one melody finishes in note number and another melody in note number and are indexed if one of them is then the melody is empty How shall we update First of all we will update from previous values only if If then obviously answer is and if then we take the answer for Secondly to avoid intersections we will update only using values of where and Why Because if we update from some and then it can lead to some intersection we can t guarantee we didn t use in the first melody How can we make fast updates We will count from to Then while counting for some specific we will maintain two arrays the maximum value of encountered so far where the maximum value of encountered so far where So when we need to count it will be the maximum of four values if we add a note which is congruent modulo with the last one if we add a note which is less by than the last note if we add a note which is greater by than the last note if we just start a melody These values can be calculated in 
1182,Let s prove that next greedy solution works each step we will find prefixes of minimal length of arrays such that its sums are equal and we will cut them forming next block If we will get valid partition in result so it is an optimal solution otherwise there is no solution Since length of prefix proportional to its sum so prefixes are minimal since its sums are minimal Let s prove this algorithm let optimal solution have alternative partition Since our solution cuts minimal possible prefixes so at some step optimal solution cuts prefix with greater sum and greater length But this prefixes in optimal solutions contain smaller prefixes found by greedy solution so it can be divided on two parts contradiction So we can keep prefixes and increase one which have smaller sum Result complexity is 
1183,If then there is no suitable matrix The operation means xor Otherwise we can always construct a suitable matrix by the following method the first element of the first line will be equal to The second element of the first line is the third element is the last one is The first element of the second line will be the first element of the third line is the first element of the last line is The rest of the elements will be zero It is not difficult to verify that the matrix obtained satisfies all the restrictions 
1184,This problem has a GCD based solution Firstly lets try to solve it naively Always suppose that If this is not true let s swap and Firstly if let s do Okay now let s subtract from until again and repeat this algorithm till or If after some step we get or we are done and the answer is If or and we didn t get then the answer is Okay we can see that we always subtract the minimum possible from and trying to maintain this condition It can be proven that this algorithm yields all possible integers that are obtainable by any sequence of the operations from the problem statement either in or in Now we have to speed up this solution somehow Obviously most operations are redundant for us in this particular problem The first thing is that we can skip all operations till becomes greater than The number of such operations is And the second thing is that we can skip all operations till we get in The number of such operations is For simplicity this part can be also written as This doesn t affect the time complexity much but the formula for the final number of operations we can skip will be simpler This number equals in fact we take the minimum between two values written above because we don t want to skip any of these two cases So we can transform the pair to the pair and continue this algorithm There are also simpler approaches using the same idea but in a cooler way Time complexity per test case 
1185,One can guess from the constraits that complexity of the algorithm should be either or And there is a solution with the second one Let s try to solve the reversed problem answer what position will some number be at after all the queries Check the impact of some query on position Let the query be on some segment If is outside this segment then you can skip it Otherwise reverse will swap and shift will swap and if then it will be instead of This task can be translated to the given one just by reversing the query list Overall complexity Obviously you can also solve it with Cartesian tree online in 
1186,At first lets precalc array is equal to maximum hero power whose endurance is greater than or equal to Now let s notice that every day it s profitable for as to kill as many monster as possible Remains to understand how to calculate it Suppose that we already killed monsters If then answer is because we can t kill the th monster Otherwise we can kill at least monsters All we have to do it increase the value until conditions holds After calculating the value we just move to the next day with killed monsters 
1187,The problem is solved by the dynamic programming Let be the answer for the prefix of the array starting at it contains the indices If then Otherwise let s go over the position with which the next good array begins Then we need to select positions among positions which will be elements of the array The number of ways to choose an unordered set of items from of different objects is calculated using the formula Thus the dynamics is as follows The basis of dynamics is the value 
1188,At first let s solve this problem when m 1 and k 0 it is the problem of finding subarray with maximum sum For each position from 1 to n we want to know the value of maxl i max limits 1 le j le i 1 sum j i where sum l r sum limits k l k le r a k and sum x 1 x 0 We will calculate it the following way maxl i will be the maximum of two values 0 because we can take segments of length 0 a i maxl i 1 The maximum sum of some subarray is equal to max limits 1 le i le n maxl i So now we can calculate the values of best i max limits 0 le len i len cdot m ge 0 sum i len cdot m 1 i len k the same way best i is the maximum of two values 0 sum i m 1 i k best i m After calculating all values best i we can easily solve this problem At first let s iterate over the elements best i When we fix some element best i lets iterate over the value len 1 2 dots m and update the answer with value best i sum i len i 1 k 
1189,Alice wants to choose such a segment that is maximum possible There is a well known problem where you have to find a segment with maximum That problem is solved with Kadane algorithm Let s learn how to reduce our problem to that one Notice that the values in the array are unusually small Let s iterate over the maximum value on segment Let be the current value If we make all such that equal to then it will never be optimal to take them in a segment Find the maximum sum subarray in that modified array and update the answer with its Notice that you can ignore the fact if there is a value exactly equal to on the maximum sum segment If there isn t then you ll update the answer with a smaller value than the actual one Let the actual maximum on the maximum sum segment be some You can see that for any value between and the maximum sum segment will always be that chosen one Thus when you reach you ll update the answer with the correct value Overall complexity 
1190,We can rethink this as counting the number of equal pairs where To do this we loop over from right to left and make sure we have all pairs where counted in a map Then we simply iterate over and add up the number of occurrences of each in the map For implementation details note that we don t actually want to use a map and make our code slower We can just use an array of size and convert the pair to the number since the are in the range As a bonus even if the were larger than we could just compress them down to and repeat the solution above Code 91019003 
1191,Let s denote as the number of substrings of having length exactly so The first and crucial observation is that if then the answer always exists Each of substrings forbids one of the strings from being the answer a string is forbidden if every each character differs from the corresponding character in one of the substrings we can forbid at most strings from being the answer and the number of possible candidates for the answer is This observation leads us to a more strong fact that actually allows us to find a solution we can set the first characters in the answer to all the remaining characters are enough to find the answer There are at most possible combinations of the last characters and this number is not greater than Let s iterate on each substring of of length and check which combination it forbids by inverting the last characters of the substring After that find the minimum unforbidden combination Note that there may be a case when a substring doesn t actually forbid any combination if there are zeroes in the first characters of the substring it is to the answer no matter which combination we choose This can be checked by precalculating the closest position of zero to the left right of each index The whole solution works in per test case the hardest part is inverting the suffix of each substring we are interested in 
1192,At first if there should be both routes and then there are both arcs and i e there should exist at least one pair that both arcs and are present in the graph Now if is odd and we have at least one pair then we can simply create sequence This sequence is a palindrome so obviously both routes generate the same string If is even or we can note that in the sequence there is a middle arc and it should have the same character as arc since it s a middle arc in reverse route i e there should exist at least one pair that both arcs and are present in the graph and have the same label Now if we have at least one such pair then routes and generate the same one letter strings Since each arc is a part of at most one pair we can just maintain two sets with pairs one for pairs with different labels and the other one for pairs with equal labels If is odd we check that at least one of the sets is not empty If is even we check that the second set is not empty 
1193,Imagine we bought some subset of colors How to check if there exists a path from 1 to n Well we could write an easy dp However it s not immediately obvious where to proceed from that You can t really implement buying colors inside the dp because you should somehow know if you bought the current color before and that s not really viable without storing a lot of information Let s find another approach Let s try to deduce when the subset is bad the path doesn t exist Trivial cases c 1 or c n aren t bought Now if there are two consecutive platforms such that their colors aren t bought the path doesn t exist Otherwise if there are no such platforms you can show that the path always exists In particular that implies that among all pairs of consecutive platforms at least one color of the pair have to be bought If the colors of the pair are the same then it s just that this color have to be bought The next step is probably hard to get without prior experience Notice how the condition is similar to a well known graph problem called vertex cover That problem is about finding a set of vertices in an undirected graph such that all graph edges have at least one of their endpoints in the set In particular our problem would be to find a vertex cover of minimum cost That problem is known to be NP hard thus the constraints We can t solve it in polynomial time but we ll attempt to it faster than the naive approach in O 2 m cdot m 2 Let s start with this approach anyway We can iterate over a mask of taken vertices and check if that mask is ok In order to do that we iterate over edges and check if at least vertex is taken for each of them Again having a bit of prior experience one could tell from the constraints that the intended solution involves meet in the middle technique Let s iterate over the mask of taken vertices among vertices from 1 to frac m 2 Then over the mask of taken vertices from frac m 2 1 to m The conditions on edges split them into three groups the edges that are completely in mathit mask 1 the edges that are completely in mathit mask 2 and the edges that have one endpoint in mathit mask 1 and another endpoint in mathit mask 2 First two types are easy to check but how to force the third type to be all good Consider the vertices that are not taken into mathit mask 1 All edges that have them as one of the endpoints will turn out bad if we don t take their other endpoints into mathit mask 2 That gives us a minimal set of constraints for each mathit mask 1 a mask mathit con that includes all vertices from the second half that have edges to at least one of non taken vertex in mathit mask 1 Then mathit mask 2 is good if it has mathit con as its submask Thus we would want to update the answer with the mathit mask 1 of the minimum cost such that its mathit con is a submask of mathit mask 2 Finally let mathit dp mathit mask store the minimum cost of some mathit mask 1 such that its mathit con is a submask of mathit mask Initialize the mathit dp with the exact mathit con for each mathit mask 1 Then push the values of mathit dp up by adding any new non taken bit to each mask When iterating over mathit mask 2 check if it s good for edges of the second kind and update the answer with mathit dp mathit mask 2 Overall complexity O 2 m 2 cdot m 2 
1194,Let s solve the problem using dynamic programming the maximal probability of Ivans victory if the siths from the already fought and the th sith left alive To calculate that DP we should iterate over the next sith he will fight against the th sith 
1195,Easy to see that the answer is equal to the answer over all sons of the root plus one Now let s solve the problem independently for each son of the root Let be the array of the depths of all leaves in the subtree of the vertex Let s sort Statement 1 it s profitable to lift the leaves in order of their appearing in Statement 2 denote the time of appearing the th leaf in the vertex let s consider the leaves and then Statement 3 where is the depth of the th leaf in the subtree of the vertex The last statement gives us the solution for the problem we should simply iterate over from left to right and recalculate the array by formula from the third statement All statements can be easily proved and it s recommended to do by yourself to understand better the idea of the solution 
1196,Let s calculate the following dynamic programming the number of ways to choose the initial health if there are heroes still alive and they already received damage Let s iterate over the number of heroes that will survive after the next round Then we have to make a transition to the state where the minimum of the maximum allowed health and plus the damage done in this round It remains to understand with what coefficient we should make this transition in dynamic programming This coefficient is equal to the number of ways to choose which of the living heroes will die in this round multiplied by the number of ways to choose health for these heroes because their health is greater than so that they are still alive at the moment but not more than so that they are guaranteed to die in this round Of course we don t make any transitions from the states where since they represent the fights that have already finished The answer is the sum of all for every 
1197,Every time we process a plan let s count only the first warriors of some type When will the warrior on position be counted Of course he has to be present in the plan so But also he has to be among first warriors of his type in this plan Let s denote a function is the position of previous warrior of the same type before warrior that is the greatest such that and If there s no any then if It is easy to prove that the warrior will be among first warriors in some plan iff and So we can make a new array Then we build a segment tree on this array The node of the segment tree will store all values of from the segment corresponding to this node in sorted order Then to get answer to the plan we have to count the number of elements on segment that are less than Complexity is or if you use fractional cascading technique 
1198,There are two possible solutions in time First of them answers each query using simple iteration changes to for each query until becomes greater than as stated in the problem But it is too slow Second solution precalculates answers for each and if then else But this uses memory and can be done in time Now we can notice that if then second solution will use only time and memory and if then first solution will do not more than operations on each query So we can combine these two solutions Time complexity 
1199,Let s look at the answer by construction each element in the final answer was the result of replace series of elements on the corresponding segment So all we need to find is the minimal by size partition of the array on segments where each segment can be transformed in one element by series of replaces We can calculate it using standard prefix dynamic programming or is the size of such minimal partition of a prefix of length The transitions are standard let s check all segments and if it can be replaced by one element let s relax Now we need to check for all segments of can it be replaced by one element Let s calculate another using the following fact if there is a way to replace all segment as one element so the segment either has the length or it can be divided into two parts where the prefix can be replaced by one element the suffix also can be replaced by one element and these elements are equal It s exactly the transitions we need to check to calculate The resulting complexity is 
1200,Let be the indicator function equal to if the th point is controlled by any city and otherwise Then the expected number of controlled points can be written as by linearity of expected value The expected value of the indicator function is equal to the probability of this function equal to In other words for each point we need to calculate the probability of this point being controlled by any city Let s instead calculate the probability of point not being controlled by any city Suppose the distance between point and some city is equal to If we build a Monument in city at step zero indexed then the point will be controlled by city But building the Monument at any step greater or equal than is fine Let s for each turn calculate the number of cities that you can build Monument in starting this turn as Our task is to calculate the number of permutations that are consistent with array At first turn we can choose one of cities at second turn we have choices at third step choices and so on Using this idea it s not hard to calculate the number of good permutations and then the initial probablity The expected value 
1201,Let s consider naive solution make three loops to fix amounts of people to get dimplomas of each degree take the best Obviously sorting the scores will regroup optimal blocks for each degree in such a way that they come in segments of initial array We tried to make these solutions fail but underestimated the abilities of contestants to optimize this kind of stuff and couple of such made it to the end of contest To be honest we just need to get rid of the last loop Let be the difference between and is sorted Then let be the position of the last diploma of second degree and be the amounts of diplomas of the first ans the second degrees Thus the best position to put the separator between the third degree and no diploma is the postion with the maximum number in array over segment This are the borders of possible amount of the dimplomas of the third degree Maximum over segment can be implemented with segment tree sparse table or even naive square matrix with precalc time and memory Overall complexity 
1202,The sign is used for the binary operation for bitwise exclusive or Let be the xor of the first elements on the prefix of Then the interval is beautiful if Let s iterate over from to and consider the values as the binary strings On each iteration we should increase the answer by the value the number of numbers so To do that we can use the trie data structure Let s store in the trie all the values for Besides the structure of the trie we should also store in each vertex the number of leaves in the subtree of that vertex it can be easily done during adding of each binary string To calculate the value let s go down by the trie from the root Let s accumulate the value equals to the xor of the prefix of the value with the already passed in the trie path Let the current bit in be equal to and be the depth of the current vertex in the trie If the number then we can increase by the number of leaves in vertex because all the leaves in the subtree of tha vertex correspond to the values that for sure gives After that we should go down in the subtree Otherwise if then we should simply go down to the subtree and recalculate the value 
1203,The main idea is to read and process each row of the matrix separately To do this we will use DSU data structure The answer will be equal to the difference between the number of 1 s and the number of operations in DSU When processing the row we will keep the DSU for the previous row When processing a certain index in the row we will try to merge it with the element to the left of it and with the element to the top that s all we have to check here You also have to handle the fact that we cannot store the whole DSU since the number of components can be up to and it s impossible to store all required information for them So each time we process a row we have to renumerate all components in this row to ensure that every time we are operating with indices of components not greater than 
1204,I think there are some ways to solve this problem with casework but let s try to come up with an intuitive and easy to implement approach It s always possible to move closer to some black vertex no matter in which vertex you are currently and which black vertex was used in the previous operation However sometimes if you try to move along an edge you immediately get forced back Let s analyze when we can move without being forced back We can move along the edge so that our next action is not moving back if either is black there is no next action or if we remove the edge between and the number of black vertices in s component is at least we can use one of them to go from to and another one to continue our path Note that the cases and may be different sometimes it will be possible to move in one direction and impossible to move in the opposite direction Let s treat this possible move as an arc in a directed graph We can find all such arcs if we can answer the queries of the type count black vertices in a subtree of some vertex and this can be done by rooting the tree and calculating this information for each subtree with DFS Now if there is a way from some vertex to some black vertex along these arcs the answer for the vertex is How can we find all such vertices Let s transpose the graph change the direction of each arc to opposite now we need to find all vertices reachable from black ones which is easily done with multisource BFS or DFS The complexity of this solution is 
1205,Take a look at the condition for a good subset The major implication it makes is that every point even non integer of the segment 1 m should be covered by at least one segment If some point isn t then there is no way to jump across the gap it produces At the same time this condition is enough to have a path since for every half integer point 0 5 1 5 and so on there exists a segment that covers it So you can take that segment to go from 1 to 2 then from 2 to 3 and so on Thus we are asked to select a subset of segments that covers the entire segment 1 m in its union The main prerequisite to the following solution is knowing the way to maintain the union of segments For now I can tell you that there is a data structure that allows you to add a segment remove a segment and query the length of the current union Let s continue with making some observations on the cost function If you fix the minimum and the maximum value you are free to select all segments that have their value in between That allows us to transition from selecting a subset of segment to an interval if you sort the segments by their weight If you fix only minimum then the required maximum should be as small as possible However if some value suffices as a maximum then any value greater than it also suffices since it only adds extra segments to the subset This makes the function on the maximum monotonous So the binary search applicable You could iterate over the minimum and binary search the maximum However it s not too clear how to make a check function You would need to find a union of some interval of segments quickly I don t really know a way to do that so let s try something different Instead let s forget about binary search and try to reach a two pointers solution Let f x be the smallest possible maximum given the fixed minimum is x We want f x 1 to be greater than or equal than f x for two pointers to be applicable That condition indeed holds Imagine if f x 1 is smaller than f x So there exists some optimal subset for x 1 Add all segments with weight x to that subset That brings the minimum to x However it doesn t change the maximum so f x is at least equal to f x 1 what contradicts the assumption Finally the solution comes up to the following Iterate over the minimum value x while maintaining f x When going from x to x 1 keep increasing the value of f until the union of the segments is exactly m Going from x to x 1 and increasing the value of f is actually removing some segments and adding some segments to the data structure The data structure that helps us with that is a segment tree The i th leaf of the tree holds the number of segments that cover the interval i i 1 Add remove segment makes it add subtract on a range The union is full if the there are no intervals that are covered by zero segments Thus let s store the minimum of the subtree in every intermediate node If the minimum on the tree is above zero then the current subset is good Instead of applying two pointers on the values of the segments let s apply them on the sorted segments themselves That makes moving the pointer exactly one update to the segtree Overall complexity O n log n n log m 
1206,In order to block any path from the top row to the bottom row you have to build a path from the left side to the right side consisting of Since two consecutive cacti in a path cannot be placed side by side they should be placed diagonally i e should be followed by on the path So we can rephrase the task as a shortest path problem The edge weight is if cactus is already in the cell that corresponds to the end of the edge and otherwise Don t forget that some cells can t contain a cactus thus be part of a path because of the cacti initially placed The shortest path can be found using Dijkstra s or 0 1 BFS algorithm 
1207,Let the month the days in them and the days of the week be numbered based Translate the th day of the th month to the index of that day in a year that would be Thus the corresponding day of the week is So we can rewrite the condition for a pair as That s also Continue with So should be divisible by is fixed and some prime divisors of might have appeared in it already If we remove them from then should just be divisible by the resulting number So we can divide by and obtain that Now we should just count the number of pairs such that is divisible by We know that the difference should be from to So we can fix the difference and add the number of pairs for that difference That would be for a difference Finally the answer is Use the formula for the sum of arithmetic progression to solve that in Overall complexity per testcase 
1208,Let s use two pointers Firstly you need to learn to factorize any number in no more than We don t actually need any of their prime divisors except for those that are presented in So let s factorize in After that check for the maximum power of each useful prime will work in for each number Now notice that if some segment has its product divisible by then all segments for will also have products divisible by Now we have to find the smallest for each out there That s where two pointers kick in Let s maintain the current product of the segment in factorized form only useful primes as in normal form its enormous The power of some prime in this form is the sum of powers of this prime in all the numbers in the segment We firstly move the left border of the segment one step to the right and then keep moving the right border to the right until power of at least one prime number in the product is smaller than in It means that it is not divisible by Moving the left border means subtracting all the powers of useful primes of number from the product and moving the right border is adding all the powers of useful primes of The first time we reach such a segment we add to answer consider indexed Overall complexity where is up to 
1209,Let s try to analyze how many times we traverse each edge in the style of Contribution to the Sum technique For each edge the number of times it is traversed must be even since for every chip that goes from the part of the graph 1 i to the part i 1 n there should be a chip that goes in the opposite direction the number of chips on vertices 1 n should be unchanged For each vertex at least one incident edge should be traversed at least twice otherwise the chip from this vertex cannot be moved to any other vertex We would also like to traverse the edges as rarely as possible Is it possible to find an answer where if we traverse any edge we traverse it only twice It turns out it is possible Let s split the graph into several parts by removing the edges we don t traverse If we don t break the constraint that each vertex has at least one incident edge which is traversed by some chip then each part of the graph will contain at least two vertices And in each part we can make sure that each edge is traversed only twice as follows let the part represent the segment l r of vertices if we move the chip r to the vertex l the chip l to the vertex l 1 the chip l 1 to the vertex l 2 the chip r 1 to the vertex r then every edge in that part will be traversed exactly twice So we have shown that if we pick a subset of edges which we traverse that meets the constraint on each vertex having an incident traversed edge then it is enough to traverse each chosen edge only twice Now the problem becomes the following choose a subset of edges in such a way that every vertex has at least one incident chosen edge minimize the total weight of this subset and print the integer which is double that total weight Since the structure of the graph is specific we can run dynamic programming of the form dp i f the minimum total weight of the subset if we considered the first i edges and f is 0 if we haven t taken the last edge or 1 if we have Obviously this dynamic programming works in O n which is too slow because we have to process queries We will employ a classical technique of storing the dynamic programming in segment tree build a segment tree on n 1 leaves in every vertex of the segment tree we store a 2 times 2 matrix d if the segment represented by the node of the segment tree is l r then the value of d f 1 f 2 is the minimum total weight of the subset of edges between l and r such that among every pair of adjacent edges at least one is chosen f 1 and f 2 represent the status of the first last edge on the segment respectively And when some element changes we need to recalculate only O log n nodes of the segment tree so this solution works in O n log n q log n albeit with a very big constant factor Implementation note don t use dynamic size arrays like in C to store the values in the matrices it might slow your solution very seriously Instead use static size arrays 
1210,First let s try to calculate the number of merging sequences just for some fixed pair of strings and Imagine we build a merge letter by letter So far letters are in the merge already For the th letter we can pick a letter from either string or string put a or a into the merging sequence respectively What constraints our choice Easy to see that it s only the th letter of the merge So we can come up with the following dynamic programming is the number of merging sequences such that characters from are taken characters from are taken and the last character of the merge is can be either just a letter a dimension of size or an indicator of a string the last character was taken from for string and from string Since we know how many characters are taken from each string we can easily decide the last taken character from that indicator For each transition we can just take a character from either of the strings The sum of over all will be the total number of merging sequences Now for the substrings Recall the following definition of a substring is a substring of if you can remove some characters from the beginning of possibly none or all and some characters from the end of possibly none or all to get the string What if we incorporated that definition into our dynamic programming Let be the number of merging sequences that end exactly before the th character of exactly before the th character of and the last character is still How to remove some characters from the beginning That actually is the same as attempting to start the merge from every state of dp So if we are currently in some state then we can act as if we have just taken the th character of or the th character of as the first character of the merge How to remove some characters from the end Since is the number of merging sequences that end exactly there why not just sum up all the values of dynamic programming into the answer We will count the sequences that end in all possible positions of both strings That is almost the answer to the task The only issue we have is that we forgot the condition that asks us to get a non empty substring from each string Well there are multiple ways to resolve the issue We can remove bad sequences afterwards their count is the number of chaotic substrings of multiplied by all possible empty substrings of there are of them plus the same thing for and These can be counted with two pointers Alternatively we can add an extra dimension or two to the dp to indicate if we have ever taken a character from and from So we get with and being binary flags that tell if a character from and from was ever taken That way we can only push the states with both flags set to true to the answer Overall complexity 
1211,The main solution is dynamic programming let for every possible dish be the minimum cost to assemble a prefix of a dinner ending with the dish here can be a dish of any type first course second course drink or dessert Then the answer to the problem is the minimum value among all desserts The number of transitions in this dynamic programming is too big since for example when transitioning from first courses to second courses we need to check options To speed this up we need some sort of data structure built over the values of for all first courses that allows to recalculate for a second course quickly There are two main approaches to this build any version of RMQ over the values of dynamic programming for the first courses Then when we want to calculate the answer for some second course sort all types of first courses which don t go well with it and make several RMQ queries to find the minimum value over all non forbidden first courses store all values of in a data structure that supports adding an element deleting an element and finding the minimum element this DS should allow duplicate elements as well When we want to calculate the answer for some second course remove all values of corresponding to the first courses that don t go well with it from the data structure query the minimum in it and insert the removed elements back The same approach can be used to advance from second courses to drinks and from drinks to desserts you can even use the same code in a for loop with iterations so the resulting solution is actually short and simple 
1212,Since then the transformation graph is a tree Let s solve the problem recursively Suppose that material is a leaf in the tree there is no such that Then if we don t have enough material we have to transform some of material into Let s transform the amount required to set current amount of material to if we don t have the required amount of material then this amount will temporarily be negative And if we have more material than we need to conduct the experiment then we will transform it to The same algorithm can be applied to any non root node but we first need to do this for all its children This algorithm is optimal because each time we take the minimum possible amount from the parent After this the root will be the only node such that is not necessarily equal to current amount of material Since we solved the problem for all other materials and did it optimally now the answer is YES iff current amount of material is not less than This must be implemented carefully Since the total amount of materials never increases then if some material s current amount is less than for example then the answer is already NO Also overflows in multiplication must be avoided to do this we can firstly check if the result of multiplication is not too big by multiplying values as real numbers 
1213,Let s use binary trie to store all personalities of warriors that is just use the trie data structure on binary representations of all For each subtree of this trie you have to maintain the number of s currently present in this subtree when inserting a value of we increase the sizes of subtrees on the path from the node with to the root by and when removing we decrease the sizes of subtrees on this path by How can it help us with answering the events of third type We will descend the trie When descending we will try to find the number in the structure When we go to some subtree we determine whether we add the quantity of numbers in the subtree we are not going into by checking if the current bit in is equal to if so then for all numbers from this subtree their bitwise xor with the current commander s personality is less than The answer to the event is the sum of sizes of all subtrees we added while descending into the trie 
1214,Why did the author choose the width of the hallway to be only Well in that case you can show that the robot will never move to the left while cleaning That is not true on width already When does the robot break Let the robot currently be in the cell indexed and the next column with a dirty cell be possibly The robot breaks only if both and are dirty That helps us to do a dynamic programming solution Since we can only care about next columns we would want to have some the largest number of dirty cells we can leave to the robot if we processed the first columns of the hallway and are currently standing in the th row of the th column Maybe with some additional states of the current or the next columns We want the dp to maintain the invariant that everything to the left of the th column is cleaned in such a way the robot can reach the cell We can choose when to fix the th column either maintain it being correct prior to entering the state or handling it in the transition to the next one I chose the former option There probably exists a million different dps that work I ll describe the one I did Let be the largest number of dirty cells that we can leave to the robot if we fixed which of the dirty cells in the first columns inclusive are cleaned by hand the robot reaches the cell from the left is true if the cell in the opposite row of the th column is dirty The transitions handle what to do with the dirty cells in the st column and where the robot goes based on that In particular there are the following transitions if is true then we have to clean the cell and the robot will move into otherwise the robot breaks from having two options if is false then let s say that the robot doesn t break immediately but moves into the next column in a unique way it moves horizontally first then possibly vertically we can leave the next column as is and the robot will move into if the cell is clean or if it s dirty if is false then we can clean the cell and the robot will move into Since we maintained the invariant that the th column is valid we can update the answer from all four states in the last column Overall complexity 
1215,Notice that we can reorder the operations in any way we want without affecting the result So let s do all of the first type operations before the second type operations Then it s clear that the number of second type operations we ll need is the number of nonzero elements left over after the first type operations So we just want to choose first type operations to minimize the number of first type operations plus the number of nonzero elements left after we re done Let s say we have an array where is the minimum value if there is a tie you can pick any tied index I only have a messy proof for this at the moment but it turns out we only need to consider two options either take all second type operations or use first type operations on the entire array and then recursively solve and separately This leads to a simple solution 90999997 Note that by using RMQ we can improve this to or even The idea is very similar to the solution to problem G here 
1216,If we want to divide all balls from some box into sets with sizes and and there are balls in this box then either or So the solution will be like that Iterate over the possible sizes of sets from to or to some constant in our solution it s and check if we can divide all balls into sets with sizes and Then iterate over the number of sets calculate the sizes of sets if we want to divide the first box exactly into sets and try to divide balls from all other boxes into sets of these sizes If we want to divide balls from the same box into sets then the sizes will be and but if then we also have to check if sizes can be and If we fix sizes and and we want to check whether we can divide a box with balls into sets with these sizes and to get the minimum possible number of such sets then the best option will be to take sets If then such division is possible If not then it s impossible to divide balls into sets of and balls Time complexity of this solution is 
1217,Let s start by choosing a vertex naively Iterate over all vertices and try each of them Root the tree by and observe what the conditions become for each is just the depth of each vertex Well then the only case when the connected subgraph of vertices of the same color has all values of distinct is when they form a vertical path in the tree So the problem becomes the following Split the tree into some vertical paths in such a way that the shortest path is as long as possible Let s try greedy I guess Start the paths from the leaves and propagate them up Consider some vertex with at least two children All children have some paths leading up to them We d love to continue them all with but we can t do that We can only continue one path and cut the rest Pretty easy to see that the path to continue is the shortest path available It s at least as optimal as any other path Do that from the lowest vertices up and you got yourself a working greedy Also don t forget to stop all paths in root since you can t continue any of them further up Let s make this greedy more formal Every time we update the answer is with a path that is the shortest in every vertex lower than the current one not the shortest in the current one So we want to propagate the shortest child up and update the answer with the remaining children Updating the answer means just taking the minimum of values Thus we can actually ignore all children except the second shortest in each vertex Just don t forget to treat the root properly Now we can actually solve the problem in for a fixed You can just find two minimums in each vertex Well now that we can solve the problem for a single root let s try rerooting to solve for all of them There are solutions in but I found the solution in the neatest The constraints are low enough to allow it For each vertex maintain a multiset of lengths of vertical paths from its children I chose to store nothing in the leaves that only makes the implementation cleaner In order to update the vertex from its child you can take the minimum element in the child s set and add to it If it s empty the child is a leaf return Additionally store a multiset of the second minimums of all vertices that have at least two children In order to update the answer with the current root find the minimum of that multiset and the shortest path from the root To achieve you will probably have to either store prefix and suffix second minimums over children of each vertex or store three shortest paths in it It is kind of messy but it should still perform better Overall complexity or per testcase 
1218,Let s call a point if its color does not match the color of any other point If a point is not isolated then it has the same color as the points with minimum distance to it and only these points should have this color Let s build a directed graph where the arc means that the point is one of the closest to the point i e If there is a path from the vertex to the vertex it means that if the vertex is not isolated the vertex should have the same color as vertex Suppose the set of vertices reachable from including itself is Finding is easy just run DFS from the vertex Let s analyze two cases there exists a pair of vertices such that and there is no arc from to for every pair of vertices such that and there is an arc Why do we need to analyze these two cases In the first case the vertex be isolated because painting it and some other vertex into the same color means that every vertex from will have this color and it will break the condition in the statement In the second case the vertex may be isolated or it may have the same color as all vertices in and if it is isolated then the whole set should consist of isolated vertices Let s find all such set of vertices that meet the second case Each vertex will belong to at most one of these sets if it doesn t belong to any it must be isolated otherwise either the whole its set consists of isolated vertices or the whole set has the same color So for each set we either use color or colors This allows us to implement a knapsack like dynamic programming let be the number of ways to paint first sets into colors such that the colors are not ordered After running this dynamic programming we can get the answer by simple combinatorics iterate on the number of colors we use in these sets in total multiply the dynamic programming for it by the ordered number of ways to choose these colors from and then by the number of ways to choose the colors for points that must be isolated This dynamic programming can even be implemented a bit easier if we treat every vertex that must be isolated as a set of size and this is the way it s written in the model solution 
1219,For best understanding we replace the matrix with and with the matrix with black and white cells At first let s consider matrix if there are two adjacent horizontal cell with same color for example cells and are black Then the cells and must have the opposite color white the cells and must have the same color black and so on So two adjacent horizontal cells generate the of width two Reciprocally two adjacent vertical cells generate the of width two And if simultaneously there are and then the answer is because they contradict each other If there are two cells of same color in the same row with even number of cells between them for example and with four cells between them then there is the because there are always two adjacent cells with same color between them The same is correct for Now let s consider how the matrix look if there are the It look like a chess board of size but colors of some verticals are inverted The same is correct if there are the How we can quickly understand that there are two cells of same color in the same row with even number of cells between them For this mentally color the matrix in a checkerboard pattern And then one of this cells has the same color witch cells in chessboard and the other has the opposite color witch cells in chessboard For calculating the answer we have maintain to the following values The color of each colored cell The row and columns containing the cells of same color with even number of cells between them And the number of row and columns containing at least one colored cell for calculating the number of beautiful matrix 
1220,There are different solutions to this problem involving combinatorics and or dynamic programming but in my opinion it s a bit easier to look at the problem from the perspective of probability theory Let s suppose a coloring is already chosen Then it can be covered with dominoes greedily red and blue cells are independent from each other and for example red cells can be analyzed as a set of strips of them of different length Let s say that we cover each strip from left to right so in each strip the first domino covers the cells and the second domino the cells and and so on Let s calculate the value of the coloring that is the expected value of the coloring if it is chosen randomly Let it be then the answer is By linearity of expectation can be calculated as where is the set of all places we can use for a domino and is the probability that there is a domino in place in our domino covering which we construct greedily Each domino covers two adjacent cells so we can iterate on pairs of adjacent cells and for each pair find the probability that this pair is covered Let s suppose that we want to cover the cells and with a domino Then both of these cells should be red the length of the red strip before these cells should be even otherwise the cell will be paired with the cell The only thing we need to know in order to calculate the probability of these two conditions being true is the number of white cells before the cell which can be easily maintained Knowing the number of white cells before we can either use dynamic programming to calculate the required probability or do the math on several easy examples and try to notice the pattern if there are white cells before the current one the probability of that pair being covered with a domino let s call it is both these cells should be red if there is white cell before the current one the probability of that pair being covered with a domino let s call it is the cells and should be red but the cell before them should not be red is either the chosen two cells are red and the cell before them is not red or all four cells are red is and so on So knowing the number of white cells before and we easily calculate the probability of this pair being covered by a domino By summing up the probabilities over all pairs of adjacent white cells don t forget the vertical ones we get the average or expected value of the coloring All that s left is to multiply it by 
1221,Let be the set of unvisited vertices To store it we will use some data structure that allows us to do the following insert some value into the set delete from the set find the smallest integer from the set such that For example from allows us to do all these operations fastly Also we can use this structure to store the adjacency lists We will use a modified version of depth first search When we are entering a vertex with we erase it from the set of unvisited vertices The trick is that in we will iterate over the set of unvisited vertices using its function And we will make not more than iterations overall because when we skip an unvisited vertex that means there is no edge from this vertex to the vertex we are currently traversing in so there will be no more than skips and each iteration we don t skip decreases the number of unvisited vertices 
1222,Presume that we want to calculate the number of blocks of length Let s divide this blocks into two types blocks which first element is a first element of integer or blocks which last element is a last element of integer for example blocks and in integer other blocks At first let s calculate the number of blocks of first type We can choose positions of this block at the start of end of the integer Now we can choose digit for this block After that we can chose digits of adjacent block if these blocks contain the same digit then we length of blocks which we want calculate greater than so we have only variations of digit in adjacent block Finally the can chose the remaining digit ways So the total number of block of first type is Now let s calculate the number of blocks of second type We can choose positions of this block all position except the start and end of integer Now we can choose 10 digit for this block After that we can chose digits of adjacent block for block to the left and for block to the right Finally the can chose the remaining digit ways So the total number of block of second type is That s almost all We have one corner case If then we number of blocks is always 
1223,Let s iterate over the lower horizontal segment Denote its coordinates as and where We call vertical segment good if followings conditions holds Now let s use the scanline method At first for each good vertical segment we increment the value of element in position in some data structure for example Fenwick Tree Next we will process two types of queries in order of increasing their y coordinate horizontal segments with coordinates upper point of some vertical segment with coordinates And if two events of different types have the same y coordinate then the event of first type must be processed first For event of first type we need to find sum on range in our data structure Let s denote this sum as Then we need to add to the answer because we have vertical segments which intersect with both fixed horizontal segments and we can choose two of them in so many ways For event of second type we just need decrement the value of element in position in our data structure 
1224,Fill the array with ones Now we should take every prime divisor of and distribute maximum power of this prime to appear in of it into some cells of the array It is pretty well known problem it s equal to Take product of this values for every prime This will be the answer if there were no negative numbers But we should also multiply it by number of ways to select even number of position to put unary minuses like you can fill in position anyhow and the final one will be determined by parity of current count To process many queries you should factorize numbers in by precalcing the smallest prime divisor of every number up to with sieve of Eratosthenes get in by precalcing factorials and inverse factorials and get in binary exponentiation Overall complexity 
1225,I won t tell all the small geometric details just cover some major points The problem asks you the following thing Sum up the total number of points covered by each segment and for each unique point subtract the number of segments covering it minus one Let s reformulate it For each segment add the number of points covered by it and subtract the number of points covered by it and by some already processed segment The first part is easy Segment covers exactly points with integer coordinates The proof left to the reader as an exercise The second part can be done in the following manner Intersect the segment with all segments insert all the points of intersection into set and take its size You can consider only integer points of intersection and use no floating point numbers in your program Overall complexity 
1226,One way to think about this problem is in game theory terms Imagine a following game Two players alternate moves The first players chooses a direction The second player chooses a different direction and moves a robot there The game ends when the robot reaches the lab and the first player wins Otherwise it s a draw What s the outcome of the game if both players play optimally as in the first player tries to win the second player tries to draw Does it sound easier Well it sure does if you ever dealt with solving games on arbitrary graphs You can skim through this article if that s unfamiliar to you The state of the game is a pair If a direction is not chosen denote it with it s the first player s move Otherwise it s the second player s move You can even implement it as is Or you can adjust a part of this algorithm for this particular problem Initially all the states are drawing only the state is winning What we basically need is a way to determine if a state is winning or not From game theory we can tell that the state is winning if there s a transition from it to a losing state The state is losing if all the transitions from it lead to winning states So is winning if any of are losing Promote that one step further The state is winning if there exists such a direction that all neighbouring free cells except in this direction are winning states Rephrase it The state is winning if it has at least one winning state neighbour and no more than one non winning state neighbour Let s store the number of non winning neighbouring states for each cell Initially it s the number of neighbouring free cells If some state becomes marked as winning decrease the value for each of its neighbours by If some state s value reaches or after this operation mark it as winning Since what this does is basically a traversal of a grid this can be done with a DFS BFS starting from the lab Overall complexity per testcase 
1227,Let s at first sort all matryoshkas by increasing its inner volume in i Then each nested subset will appear as subsequence in its canonical order Now we ll write the DP with d i x y the minimum extra space x and number of such subsequences y among all nested subsets where the i th doll is Why minimal not maximal for example It s just easier transitions and easier proof There are two main cases If there isn t j such that out i le in j then we can t put the i th doll inside any other So d i in i 1 Otherwise we must put the i th doll inside other doll otherwise the subset won t be a big enough If we put the i th doll inside the j th doll then we extra space of such subset is equal to d j first out i in i Since we minimize the extra space then d i first min limits out i le in j d j first out i in i min limits out i le in j d j first out i in i Since we sorted all matryoshkas so there is a position pos such that forall j ge pos out i le in j and d i first min limits j pos n d j first out i in i The d i second is just a sum from all minimums As you can see we can store d i in Segment Tree with minimum number of minimums Why in the second transition we will build only subsets It s because not big enough subsets are not optimal in terms of minimality of extra space The result complexity is O n log n 
1228,Let s assume that we don t have any zeroes in our array We ll deal with them later The key observation is that the number of sequences in the decomposition is not more than To prove this we can use the fact that each element will be appended to the first subsequence in the decomposition so if the second third subsequence in the decomposition ends with the number or all such numbers can be appended to that subsequence thus they won t create any new subsequences So if we consider the combination of the last elements in the subsequences of the decomposition there are only such combinations even less in practice Okay now let s try to use the fact that the number of such combinations is small There are many ways to abuse it but in my opinion the most straightforward one and also a bit slow but fast enough to easily pass the time limit is to run the following dynamic programming where is the index of the element we are processing and is the vector representing the combination of last elements of subsequences in the decomposition But it s not clear what do we store in this dynamic programming The model solution stores i e we will consider the number of subsequences added while processing the elements So our dynamic programming automatically sums up the answers for all possible right borders of the segment we decompose Transitions in this dynamic programming is easy we need to see how does the element alter the state of decomposition let it change it to take the value of and if the element forms a new subsequence let s account for it by increasing by because this increase will affect different right endpoints of the segment we decompose And now it s easy to see how to add zeroes to our solution We can just assume they don t change the state of decomposition they simply add a new subsequence which won t take any other elements So in our transitions processing means that but the size of decomposition increases To actually get the answer to the problem we need to consider all possible starting points of the segment so we sum up where is the empty vector for all 
1229,Since a sequence of swaps denotes some permutation let s try to restore the permutation that was used to transform into and then get by applying inverse permutation If was or less then we could get just by asking one query send a string where no character occurs twice and the resulting positions of characters uniquely determine the permutation Unfortunately may be greater than but we can ask more than one query The main idea is the following for each index we may choose a triple of characters so all triples are distinct There are different triples and that s greater than so each index can be uniquely determined Then after we choose a triple for each index ask three queries as follows in the first query the th character of the string is the first character in the triple representing index in the second query we use the second characters from all triples and in the third query the third characters Let and be the strings we sent and and be the strings we received as answers The permutation maps index to index if and only if and because if some other index is mapped to then at least one of the aforementioned equalities is false since all triples of characters are distinct Using this fact we may recover the permutation 
1230,Let s consider some subsequence with the length the empty subsequences we will count separately by adding the valye at the end and count the number of sequences that contains it We should do that accurately to not count the same sequence multiple times Let be the fixed subsequence In the original sequence before the element can be some other elements but none of them can be equal to because we want to count the subsequence exactly one time So we have variants for each of the elements before Similarly between elements and can be other elements and we have choices for each of them And so on After the element can be some elements suppose there are such elements with no additional constraints so we have choices for each of them We fixed the number of elements at the end so we should distribute numbers between numbers before between and ldots between and Easy to see that we have choices to do that it s simply binomial coefficient with allowed repititions The number of sequences equals to So the answer is Easy to transform the last sum to the sum Note the last inner sum can be calculating using the formula for parallel summing So the answer equals to Also we can get the closed formula for the last sum to get logarithmic solution but it is not required in the problem 
1231,Let s define the semantics of moving along the graph On each step the current number is either multiplied by some prime or divided by it I claim that the all shortest paths from to always go through Moreover the vertex numbers on the path first only decrease until and only increase after it Let s watch what happens to the divisors list on these paths At first all the divisors of that are not divisors of are removed from the list Now we reach gcd and we start adding the divisors of that are missing from the list The length of the path is this total number of changes to the list That shows us that these paths are the shortest by definition If we ever take a turn off that path we either will add some divisor that we will need to remove later or remove some divisor that we will need to add later That makes the length of the path not optimal Now let s learn to calculate the number of paths The parts before gcd and after it will be calculated separately the answer is the product of answers for both parts How many paths are there to gcd Well let s divide by that will give us the primes that should be removed from You can remove them in any order because the length of the path is always the same That is just the number of their permutations with repetitions you might also know that formula as multinomial coefficient The number of paths from to is calculated the same way To find the primes in you can factorize beforehand and only iterate over the primes of Overall complexity 
1232,Firstly let s factorize Since we can factorize and separately and then unite divisors For example use can get canonical representations of and to get canonical representation of and then use it to generate all divisors of Let s estimate the number of divisors It s convenient for our purposes to estimate it as More precisely there are at most divisors for search Highly Composite Numbers for more info How to calculate the answer for each divisor There are two ways for each we are searching for the minimum that and Since is fixed the minimum means the maximum So let s find instead In other words for each we need to find the maximum such that divides and We can do it efficiently with on divisors Let be the maximum that is a divisor of and If then obviously Otherwise we know that we are searching Let say that are the prime divisors of the initial number Since is a divisor of and then exists some among the set of prime divisors such that is a divisor of as well So instead of brute search it s enough to take a value In other words if we can calculate Ok now we know value for each divisor Since we found the maximum the last step is to calculate the desired and if we found the answer otherwise it means that is not presented table and The total complexity is per test where is the number of divisors of and is the number of prime divisor of Note that complexity is quite high so you should write it at least a little accurate for example store in an array not map and search position of with There is also a way to get rid of extra factor if you iterate through is a smart way faster easier unproven Let s generate a list of all divisors of as in the increasing order For some divisor we are searching the minimum that is a divisor of and It means that So let s just find the first position such that with and start iterating from onward searching the first that is a divisor of The found would be the minimum we need It looks like in average we will find the correct quite fast or we ll break when 
1233,Let s look at string Since we should get it using no more than two subsequences then where is the first subsequence and is the second one In the general case can be empty Let iterate all possible lengths of so we can check the existence of solution for each pair and If we d fix and we need to check the following is it true that contains and as subsequences and these subsequences don t intersect Initially we can invent the following dp let be if the prefix of of length contains prefixes of and of length and as non intersecting subsequences The transitions are straingforward if we can either skip indexed and update If indexed then we can update and if then we can update But this dp has complexity in general case But we can transform it in the next way instead of the boolean value we will make as a value of dp In other words we will maintain as minimal appropriate prefix But the problem now is to define transitions Let s note the next fact suppose we have and we d like to add next character to which is equal to The idea is next it s always optimal to choose the first occurrence of in It can be proved by contradiction if the first occurrence is free then it s better to take it or if the first occurrence will be occupied by then this will be handled by the other state with The logic for increasing is analogical In result we need to precalculate array with the next occurrence of character in suffix of one time before choosing and and use it each time to acquire complexity The total complexity if for each test case 
1234,First get rid of the corner cases If the string doesn t contain either of the letters the answer is The general solution to the problem is to consider every single way to modify the path then find the union of them Well every single path is too much let s learn to reduce the number of different sequences of modifications that we have to consider The main observation is that all cells that the robot can visit are enclosed in the space formed by the following two paths the first R is duplicated the maximum number of times then the last D is duplicated the maximum number of times the first D is duplicated the maximum number of times then the last R is duplicated the maximum number of times You can realize that by drawing the visited cells for some large test To show that more formally you can consider the visited cells row by row Let s show that for every two different visited cells in the same row all cells in between them can also be visited In general case we want to show that we can take the prefix of the path to the left one of these cells and duplicate any R on it to reach the right cell The suffixes of the paths will remain the same as in the initial path If there exists an R on the prefix then we are good Otherwise the reason that it doesn t exist is that we duplicated D too many times Reduce that and there will be R immediately after reaching the cell or earlier We should also show that the number of R s on the path to the left cell won t reach the maximum allowed amount until reaching the right cell Use the fact that the number of D s on both prefixes of the paths is the same The other non obvious part is that you can t reach cells outside this space However that can also be shown by analyzing each row independently Finally about the way to calculate the area of this space The main idea is to calculate the total number of cells outside this area and subtract it from Notice that non visited cells form two separate parts the one above the first path and the one to the left of the second path These are pretty similar to each other Moreover you can calculate them with a same function If we replace all D s in the string with R and vice versa then these parts swap places So we can calculate the upper part swap them and calculate it again I think the algorithm is best described with a picture Consider test for example First there are some rows that only have one cell visited Then the first R in the string appears Since we duplicate it the maximum amount of times it produces a long row of visited cells The remaining part of the part becomes the outline of the area Note that the row that marks the end of the string always ends at the last column Thus only at most first rows matter To be exact the amount of rows that matter is equal to the number of letters D in the string For each letter D let s calculate the number of non visited cells in a row it goes down to I found the most convenient way is to go over the string backwards We start from the row corresponding to the number of letters D in the string It has zero non visited cells We can maintain the number of non visited cells in the current row If we encounter an R in the string we add to this number If we encounter a D we add the number to the answer We have to stop after the first R in the string The later well earlier since we are going backwards part corresponds to the prefix of letters D the starting column on the picture Each of these rows have visited cell so non visited So we can easily calculate this part as well Overall complexity per testcase 
1235,First of all let s find a solution in We will use the lineriality of expectation the answer for some shield is equal to where is the probability that the monster will deal damage if we use the th shield Let s see how to calculate Consider a monster such that To deal damage he should be preceded by at least other monsters having We can write a complicated formula with binomial coefficients to calculate the probability of this happening and then simplify it but a much easier solution is to consider the order of these strong monsters Suppose there are of them then there are strong monsters that will deal damage Since all orderings are equiprobable the probability that our fixed monster will deal damage is since it is the probability that it will take one of the last places in the order Okay what about weak monsters It turns out that we can use the same approach to deal damage a weak monster should be preceded by at least strong monsters Consider the relative order of strong monsters and that weak monster we are analyzing There are positions where the weak monster will deal damage so the probability of weak monster dealing damage is Okay we got a solution in How to make it faster Whenever we consider a shield all monsters are split into two types strong and weak and we may sort the monsters beforehand so the number of strong monsters and their total strength can be found with binary search Since the probabilities for all strong monsters are the same we can multiply their total strength by the probability that one fixed strong monster will deal damage we already described how to calculate it The same applies for the weak monsters so the total complexity is 
1236,Note that each unit of damage dealt by explosions save us from using one more basic spell In other words the more the damage from explosions the better So the answer will be equal to Note that in order to kill all remaining monsters with the last spell the array should have the following structure there is a monster we cast the spell onto it and is strictly increasing in and strictly decreasing in ignoring prefix and suffix of s Let s focus on the left part of array segment since solving the right part is exactly the same Maximizing the total damage is equivalent to maximizing the sum of right before the final spell Note that we can use the straight greedy strategy to kill the chosen monster we should use Explosion spell of power exactly it s not optimal to make it either more or less powerful After that monster will create an explosion of power If we must decrease it to exactly to continue the chain of explosions of maximum total damage If we also decrease it to exactly and so on The general formula is This series will stop either if or or there are no monsters left or we met the monster with The two first cases are easy to check in constant time so let s look at the last case Suppose that monster position is equal to then or That monster is interesting to us because after death it creates an explosion of damage that already doesn t depend on and next calculation is practically the same task what chain of explosion we can have if we start from That idea drives us to dp let be the maximum damage of chaining explosion we can deal if we start from and move to the left For simplicity let s include into that total damage Calculating is next let s find the first such that If there are no such or if that is too far from i e we will set Now we know that on interval the damage dealt is the arithmetic progression for it s for it s for it s In total And if such exists and not too far away we increase by as well The last question is finding for each the closest such that Note that if we define we need just need to find last and that s quite standard task that can be solved with stack Let s iterate over and maintain a stack of previous When we need to find for the current let s just look at the top of the stack if we found we wanted otherwise just pop it and check the new top again and so on until either we find or stack becomes empty that would mean that there are no After processing the th element push on top of the stack Why it works Consider some The element on top of the stack is firstly it s but we are talking about general case If we found what we want Otherwise but it also means that previous elements that was popped on previous iteration was greater than So is bigger than as well and there were no need to even consider them i e popping them out earlier doesn t break anything Since each element is pushed in the stack once and popped out once then the complexity is for all for to or amortized The answer for the chosen position then is where is dp we discussed above is the same dp but on reversed array and because we included into both and Both and are calculated in so the total comlpexity is 
1237,We can use binary search to find the answer When binary searching to check whether the whole city will be lightened up after minutes we can use sweep line technique to find the smallest coordinate of the cell that is not lightened by centers of ignition and the smallest coordinate too Suppose that and are these coordinates then we can place the last center of ignition at coordinates Then we can use sweep line again to check whether the city is fully ignited 
1238,Let s discuss two approaches to this problem Firstly let s think that we choose not four destination points but four lines on which sides of the square lie It s two vertical lines with coordinates and and two horizontal lines and of course is to note that either both and coincide with some s and coincide with one of or both and coincide with some s and coincide with one Since we know the side of the square from or and one point It s easy to construct other points of the square and find the minimum total distance by iterating all permutations This approach needs around operations and work around one second if written accurately is more clever and faster Let s assign a role for each point which vertex of the final square this will be left bottom left top right bottom or right top There will be such assignments For simplicity let s say that the left bottom vertex is left top is right bottom is and right top is If we rewrite our total distance formulas we can note that instead of summing the distance between points we can sum the distance from lines to the points which should lie on it In other words we can calculate the answer as Let s look at the left side If then the total distance is always and has it s optimal segment of values Analogically also has it s optimal segment of values Since we can choose as any value in its segment and as any value in its segment then the possible distance the side of the square also forms a segment of possible values let s name it as and can be calculated with pretty easy formula On the other hand we can do the same with horizontal sides and compute the segment of optimal side length in the same manner Now if and intersects then we can choose such side length that lies in both and and optimal for both vertical sides and horizontal sides Otherwise without loss of generality and if we choose we need to pay extra fee since we out of it means that the chosen is greater than optimal so we need to choose for example outside And we need to pay for each step outside of this segment In other words the answer for a fixed permutation is 
1239,At any time we have three possible choices wait and shoot the first laser the second laser and both lasers Sometimes it makes sense to wait to both because you can deal more damage than you would do by shooting both lasers separately The first claim greedy won t work Maybe there is a sufficiently smart greedy we weren t able to come up with it The second claim bruteforce won t work The funny thing is that it actually worked on the constraints up to but again we couldn t code any sufficiently fast one for Thus let s try some dynamic programming Since all the times are huge we d want to avoid having them as the states What is small however is the durability of the enemy ship and the number of shots we have to make to destroy it Ideally we d like to have some the smallest time to deal damage to the enemy ship This way would be the answer Sadly it s not immediately clear how to get rid of reload times completely There might be states with different times until the charge with the same damage dealt and we don t know which of those we want to keep Thus let s make the dp state more complicated Let be the smallest time it takes to deal damage if the last shot was from both lasers at the same time This way we know the reload times of both lasers they are full and as moment has both lasers zero charged as if after a shot What are the transitions Well now we have to shoot each laser multiple times then wait until both are charged and shoot both Both lasers can now be considered independent of each other Let the time between the previous double shot and the next one be some value During this time it never made sense to wait until shooting each laser So we waited shot the first laser waited another shot again until we couldn t shoot anymore since the laser wouldn t recharge in time before the double shot Same for the second laser Notice that if both and then you could just decrease by and shoot each laser the same number of times Thus only that are multiples of either or are optimal Thus we can iterate over all possible waiting times Just iterate over and for all from to Having a fixed calculate the number of shots of each laser calculate the damage go into the corresponding dp state It could also happen that the last shot before destroying the ship wasn t a double one However it still follows the same ideas It means that each laser was shooting non stop until the ship was destroyed Thus the destruction time is still a multiple of either of the reload times Overall complexity 
1240,Consider some value of When is it included in the answer When Monocarp spends a lower or an equal amount of blocks of attempts than Polycarp for killing every boss Formally for all from to Let s reverse this condition is not in the answer if there exists such from to that So there exists at least one value between and Let s call it Now it s I set the and signs arbitrarily just so that it shows that such a value exists You can t put both or both because that will accept values or at least values respectively Would be cool if we could multiply everything by and it still worked Is it completely impossible though Take a look at What it says is that there exists a multiple of between and A multiple of is a number that s the last in each block of attempts the block of value that are rounded up the same Turns out this is what we are looking for already Right after the multiple of the new block starts Thus we are wrong we our signs It should be is in the block after so it requires more blocks of attempts So for to not be included in the answer there should exist at least one such that there exists a multiple of in the half interval That is pretty easy to implement For each calculate the number of half intervals that cover I think this is called delta encoding Iterate over all half intervals and make two updates for each one increment by on position and decrement by on position Then make a prefix sum over these updates Now the value in the th position tells you the number of half intervals that cover To check a particular value of iterate over all multiples of and check that none are covered by half intervals It s known that the total number of multiples over all numbers from to is Overall complexity per testcase 
1241,At first let s transform input to a more convenient form We consider only such subsegments that consist of the symbols and which cannot be expanded to the right or left For example for we consider segments of length and Let s divide all such segments into four groups by their length In such a division each segment belongs to exactly one type Suppose that the Bob takes the first turn If there is a segment of second type then Bob wins because he always have a spare turn that Alice cannot make If there is a segment of fourth type then the Bob also wins because he can make the segment of second type by taking turn in this segment of four type If there are no segments of second and four types then victory depends on the parity of the number of segments of the third type But it is true if the Bob takes first turn If Alice takes first turn then she doesn t want after her move there are segments of the second and fourth types So if initially there is a segment of second type then Alice loses because she can t take turns into segment of second type If there are two or more segments of four type then Alice also loses because after her turn at least one such segments remains If there are only one segment of four type then Alice have to take turn into this segment Since the length of this segment doesn t exceed we can iterate over all possible Alice moves After Alice s move segment of fourth type can be divided into no more than two new segments let s denote their types as and If at least one of these segments of second or fourth type then it s bad turn for Alice Otherwise Alice win if remaining number of segment of third type is even note that or also can be the third type And finally if initially there are only segments of first or third type then victory depends on the parity of the number of segments of the third type 
1242,This problem has a simple solution described by participants in the comments My solution is a little harder Let s solve it using dynamic programming Let be the smallest amount of time needed to get letters a Let s consider transitions the transition for adding one letter a can be simply done Let s process transitions for multiplying by two and subtraction by one simultaneously let s decrease the number times by one right after getting it Easy to see that such updates never include each other so we can store them in queue by adding the new update at the tail of the queue and taking the best update from the head The solution is hard to describe but it is very simple in the code so please check it to understand the idea 
1243,Note that for each vertex So if we consider a path from some vertex to the closer you are to the cheaper the cost In other words it s always optimal to choose the highest vertex on the path with Suppose we can find such vertex for a given How many times we will repeat this search operation If we need to buy tons and has tons then it s optimal to buy tons in After we buy tons either becomes or becomes Since for each vertex can become equal to zero at most once and since after is zero we stop buying then there will be searches in total The next question is how to find efficiently for a given Consider the path from to some vertex Since we prefer to buy from higher vertices all empty vertices on this path will form some prefix of it possibly empty prefix So we can make some sort of binary search to find the first non empty vertex But instead of binary search we will use binary lifting technique If we know for each which vertex on the path from to on distance from then we can efficiently jump up the path Let s firstly jump at distance if then we jump too high let s not jump But if then we can safely jump or Now we know that we don t need a second jump so we try jump and so on In other words using binary lifting we can find the highest vertex with in steps Also we can calculate array for vertex right after we add vertex to the tree since and The resulting complexity is 
1244,Let s rephrase the fifth condition Each edge should connect two vertices with the numbers of different parity either to or to So the graph should actually be bipartite and the first partition should have only the odd numbers or and the second partition should have only the even numbers only Notice how and are completely interchangeable in the sense that if you have exactly vertices which should be assigned odd numbers then you can assign whichever of them to and the rest to you want So you can guess that the first step is to check if the given graph is bipartite If it isn t then the answer doesn t exist It can be done with a single dfs Actually the algorithm for that extracts the exact partitions which comes pretty handy If the graph was a single connected component then the problem would be easy Just check if either the first partition or the second one has size and assigned its vertices color If neither of them are of size then the answer obviously doesn t exist However the issue is that there might be multiple connected components and for each of them you can choose the partition to assign to independently Still each of the connected components should be bipartite for the answer to exist This can be done with a knapsack like dp Let the th connected component have partitions of sizes Then the state can be is true if connected components are processed and it s possible to assign to exactly vertices of these components As for transitions for the th component you can either take the partition with vertices or with vertices Thus if is true then both of and are also true If is false then there is no answer Otherwise you can always restore the answer through the dp The easiest way is probably to store not true false in but three values for false for the case the state is reached by taking the first partition of the th component and for the second partition Also you should store not only the sizes of the partitions but the vertices in each of them as well This way you can recover the answer by backtracking from the final state Overall complexity 
1245,Let be a number of occurrences of number in subsegment The given task is equivalent to choosing and value such that is maximum possible But with some transformations so we need to maximize Key observation is the next if we fix some value then we can shrink each segment between consecutive occurrences of in one element with weight equal to Then we need just to find subsegment with maximal sum the standard task which can be solved in Finally total complexity is 
1246,Let s consider each kilometer of the journey separatedly and calculate the expected value of its difficulty and then use linearity of expectation to obtain the answer The difficulty of each kilometer depends on the rest site right before it or if there were no rest sites on the distance from Moscow to this kilometer So when considering the difficulty of th kilometer one indexed we may obtain a formula The denominator of the last summand is because it represents the situation where the last rest was in Moscow and its probability is exactly We can actually rewrite this as follows thus calculating all that we need in linear time 
1247,At first time limit was not that tight for the problem We didn t want any sqrt bitset or straight up solution to pass and it s close to none to pass Jury solution works faster than twice the time limit so we decided 6 seconds is alright The task is purely about implementation You renumerate numbers in permutations so that the queries are and then have the structure to make update in point and sum on rectangle Renumeration in my case was making the first permutation into identity one and changing the numbers in second appropriately You can choose the structure you want I ll tell about the one I use when the queries are offline For online the common technique is having BITs each with treap in it ordered set template from pbds is usually enough For offline you can precalculate the values to fall into each BIT beforehand and do BIT on these values inside Preprocess all the update and get queries adding into all the BITs will fall into Then sort them and leave only unique occurrences Overall complexity 
1248,You can notice that every coloring can be encoded by the two binary strings of length You firstly generate one string to put as a first row and then use the second string to mark if you put the first string as it is or inverting each color That way you can also guess that the area of maximum rectangle of a single color you will get in you coloring is the product of maximum lengths of segments of a single color in both of the strings Let s consider the following dynamic programming solution is the number of binary strings of length such the current last segment of a single color has length and the maximum segment of a single color has length The transitions are color the new tile the same as the previous one color the new tile the opposite from the previous one The starting state is Let s sum the values of this dp to an array the number of binary strings of length such that the maximum segment of a single color in them has length You can also do another dp to calculate this not in but in using some partial sums in it Finally you iterate over the first side of the resulting rectangle the maximum length of segment of a single color in a first binary string and multiply the number of ways to get it by the total number of ways to get the second side of the resulting rectangle so that the area doesn t Overall complexity or 
1249,Let s solve this problem by subset dynamic programming Let s denote as the number of adjacent characters and in such that or Let s be some intermediate result further it will be explained what kind of intermediate result if we already added letters corresponding to subset to the keyboard and we don t care about the order of these letters Now let s consider how to recalculate values of this dynamic programming using some Let s iterate over a new letter on keyboard and we know the position of this letter on the keyboard it s equal to the number of elements in After adding this new letter we want to calculate what it added to the Let consider some letter and calculate how much time will be spent on moving and There are two cases If letter is already on current keyboard then we should add to answer and otherwise where is the position of character on the keyboard But we don t know the position of the letter Let s fix it as follows We will add the contribution of some letter when it will be added to the keyboard So when we added letter we should add the value So the total complexity is 
1250,Let s consider the optimal answer Suppose we take items of weight Let be the least common multiple of all weights that is Then we may represent as where Let s do the following trick we will take items of weight and all the remaining items of this weight can be merged into some items of weight Then we can write a brute force solution that picks less than items of each weight transforms the remaining ones into items of weight as much as possible and when we fix the whole subset adds maximum possible number of items of weight to the answer This works in something like operations which is too much How can we speed it up Rewrite it using dynamic programming When we have fixed the number of items we take from first sets the only two things that matter now are the current total weight of taken items and the number of items of weight we can use and it s obvious that the more items of weight we can use the better So let s write the following dynamic programming solution maximum number of items of weight we can have if we processed first types of items and current total weight is Note that the second dimension should have size 
1251,WLOG assume all queries ask to move from a lower layer to a higher layer The first thing to notice in the problem is that it is always optimal to never go down a layer You have an optimal path that is going down some layers and then returning to the same layer So it leaves a layer in some its cell and returns to it in some other cell or the same one The best distance it can achieve is the Manhattan distance between these two cells However we can also achieve the Manhattan distance by just going along this layer and the answer will be at least as optimal If the query asks about the cells of the same layer just answer with the Manhattan distance Otherwise we can describe the path as follows go from the first cell to some door on its layer enter the door and go to another door on the next layer so on until the layer of the second cell where you go from a door to the second cell Thus we could potentially write the shortest distance from the start to the th door of the th layer Initialize both doors of the first layer take the best answer from the both doors of the last layer That would be per query which is too slow Let s optimize it with some precalculations In particular we want to know the shortest distance between one door of some layer and one door of another layer We can use the technique similar to binary lifting Calculate the distance between a pair of doors on layers which are apart for all up to Let be the distance from door of layer to door of layer can be initialized straightforwardly Then to calculate we can use the values for and for some intermediate door on layer To obtain the answer use jumps to reach the layer one before the last one Then iterate over the last door Alternatively you could pack this dynamic programming into a segment tree use divide and conquer on queries or do square root decomposition Overall complexity 
1252,This is pretty typical problem on greedy construction you are asked to build lexicographically maximal string In the majority of cases it s done like this Imagine you ve built some prefix of length with all numbers equal to the prefix of length of the original string You are also sure there exists some suffix for it that will give proper beautiful number Now you have two options you either put if possible and proceed to the same task of longer prefix or you put the smaller number and fill the entire suffix with the maximum possible beautiful number you can obtain Now you should learn how to check if any valid suffix exists It means at least the smallest possible beautiful number with current prefix is smaller than It s built like this Let be the number of digits which currently have odd number of occurences You put all zeroes but the last digits and then output these odd occurence number digits in increasing order The first part can be checked with partial sums on the number of zeroes on segment in the original string and the second part has its length not greater than and can be checked naively Overall complexity 
1253,The name of this problem is anagram for Small to large There is a reason for that The author solution for this problem uses the classic technique for computing sets in tree The simple solution is the following let s find for each vertex v the map int int the number of occurences for each colour set pair int int pairs the number of occurences and the colour and the number sum the sum of most frequent colours in subtree of v To find that firstly we should find the same thing for all childs of v and then merge them to one These solution is correct but too slow it works in O n2logn time Let s improve that solution every time when we want to merge two map s a and b let s merge the smaller one to larger simply by iterating over all elements of the smaller one this is the Small to large Let s consider some vertex v every time when vertex v will be moved from one map to another the size of the new map will be at least two times larger So each vertex can be moved not over than logn times Each moving can be done in O logn time If we accumulate that values by all vertices then we get the complexity O nlog2n I saw the solutions that differs from author s but this technique can be used in a lot of other problems 
1254,First let s solve the problem without blocked positions Let s look at the array Obviously if strictly increases then does not decrease and vice versa Now we have to find the maximum number of positions in the array that can be left unchanged And you can always choose an integer that will not break the non decreasing array for the rest of positions This problem can be solved in by analogy with the largest increasing subsequence but now you can take equal elements Now you can realize that the segments between two blocked positions do not depend on each other and the initial problem can be solved as the problem described above All that remains is to check that all blocked positions do not break the strict array increment 
1255,Note that there are only two ways to fix the result of the operation of taking an absolute value in the expression or Since the value of is small enough that we can iterate over all options and choose the one for which the sum is maximum For each student let s fix with which sign their total points will contribute to the answer then will contribute with the opposite sign Now for the question we can calculate the coefficient with which will contribute to the answer It remains to choose such a permutation that the sum is the maximum possible From here we can see that if for some and then must holds otherwise we can swap and and the answer will increase This means that we can sort all questions in ascending order by the value in the array and assign the value in the array to the th question in ascending order For some of options the permutations we found may be illegal because it can happen that we consider the case that some evaluates as but in the best permutation we found for that option it evaluates as We can just ignore it because this will never be the case with the option giving the highest possible surprise value if this thing happened for some option to choose the signs of then if we flip the signs for the students such that the conditions on them are not met in the optimal permutation we ll get a combination of signs that yields a higher surprise value 
1256,Let s consider the naive solution in or Iterate over all subsets of original set calculate sums and take maximum of them modulo Now we can use meet in the middle technique to optimize it to Preprocess the first elements naively and push sums modulo to some array After this process the second half with following algorithm Take sum of the set and find the greatest total sum of current and some sum in the array As any sum of two numbers less than can go no greater than we can consider just two values the greatest number in array and the greatest number less than in the array This can be found by binary search over sorted array Overall complexity 
1257,First of all let s try to find a simple way to evaluate the difficulty of a given set of towers I claim that the difficulty is equal to the number of pairs of discs that belong to different towers during each operation we can merge at most one such pair if we move discs to the tower with disk on top of it only the pair can be affected we can always take the first several discs belonging to the same tower and move them to the tower containing disc thus merging exactly one pair in exactly one operation After that there are two main approaches LCA and small to large merging The model solution uses LCA so I ll describe it For each pair we have to find the first moment these discs belong to the same tower To do so let s build a rooted tree on vertices The vertices to will be the leaves of the tree and will represent the original towers The vertex will represent the tower created during the th query and will have two children the vertices representing the towers we merge during the th query The vertex is the root Now if some vertex is an ancestor of vertex it means that the tower represented by vertex contains all the discs from the tower represented by vertex So to find the first tower containing two discs and we have to find the lowest common ancestor of the vertices representing the towers and The easiest way to do it is to implement something like binary lifting which allows us to solve the problem in 
1258,First of all let s rewrite the answer using expectation linearity The expected number of students who read their respective messages is equal to where is a random value which is if the th student reads the message and if the th student doesn t do it Let s analyze the expected value of Suppose Monocarp pins the messages There are three cases if then the th student won t read the message so if and then the th student will definitely read the message so if and then If we iterate on the number of messages we pin we can calculate the sum of for each message considering that we pin it sort all of the messages and pick best of them So we have a solution working in The only thing we need to improve this solution sufficiently is the fact that we don t have to consider the case Since every is not greater than the sum of for a message in the case is the same as this sum of in the case but multiplied by the coefficient and we pick best values their sum multiplied by is not greater than the sum of best values The same holds for and greater 
1259,So I have two slightly different approaches to the problem There is a straightforward no brain one and a bit smarter one The minimum place is the same in both solutions For the th friend it s just if he never moves and otherwise Obtaining the maximum place is trickier For the first approach take a look what happens with some friend after he gets moved to the first position Or what s more useful what happens after he gets moved to the first position and before he gets moved again afterwards or the queries end Notice how every other friend is to the right of him initially Thus if anyone sends a message then the position of the friend increases by one However if that friend moves again nothing changes That should remind of a well known problem already You are just required to count the number of distinct values on some segments The constraints allow you to do whatever you want segtree with vectors in nodes Mo persistent segtree I hope ML is not too tight for that Unfortunately for each friend we have missed the part before his first move In that case for each you need to count the number of distinct values greater than as only friends with greater index will matter Luckily you can do it in a single BIT Let th its value be set to zero if the friend hasn t sent messages and one otherwise Let s process messages from left to right If the friend sends a message for the first time then update the BIT with in his index and update his answer with the suffix sum of values greater than his index Finally there are also friends who haven t sent messages at all As we have built the BIT already the only thing left is to iterate over these friends and update the answers for them with a suffix sum Overall complexity The attached solutions are and The second solution requires a small observation to be made Notice that for each friend you can only check his position right before his moves and at the end of the messages That works because the position can decrease only by his move so it s either increases or stays the same between the moves So let s learn to simulate the process quickly The process we are given requires us to move someone to the first position and then shift some friends Let s not shift And let s also reverse the list it s more convenient to append instead of prepending So initially the list is and the message moves a friend to the end of the list Allocate positions in a BIT for example Initially the first positions are taken the rest are free mark them with ones and zeroes respectively For each friend his position in this BIT is known initially they are because we reversed the list On the th message sent count the number of taken positions to the right of set in update and set in And don t forget to update each friend s maximum after all the messages are sent that is the number of taken positions to the right of his final one as well Overall complexity 
1260,This problem is usually called Topological labelling Though it s pretty common problem we decided that it might be educational to some of participants Let s set labels in descending order starting from label to label Look at first step Vertex with label should have out degree equal to zero Among all such vertices we should put the label on the one that has the largest index Ok but why will this produce the lexicographically smallest labelling We can prove this by contradiction Let this vertex be labeled Change it to and renumerate vertices with label to labels Labelling will come lexicographically smaller than it was this leads to contradiction So the algorithm comes as following On step we find vertices with out degree equal to zero select the one with the largest index set its label to and remove this vertex and all edges connected to it from the graph Current minimal out degree can be maintained with set for example Overall complexity 
1261,Let s take a look at a naive approach at first That approach is greedy Let s find such an interval which starts to the left or at and ends as much to the right as possible Set to its right border Continue until either no interval can be found or is reached The proof basically goes like this Let there be some smaller set of intervals which cover the query these can be sorted by left border obviously their left borders are pairwise distinct Compare that set to the greedy one take a look at the first position where best set s interval has his less than the greedy set s You can see that choosing interval greedily will still allow to have the rest of best set intervals making the greedy choice optimal Let s implement it in For each position from to you can precalculate the index of such an interval that it starts to the left or at this position and ends as much to the right as possible To do this sort all intervals by their left border then iterate over positions while maintaining the maximum right border achieved by intervals starting to the left or at the current position The query is now straightforward Now there are two main ways to optimize it You can do it binary lifting style for each interval or position precalculate the index of the interval taken last after taking intervals greedily and use this data to answer queries in You can also do it path compression style Let s process the queries in the increasing order of their right borders Now do greedy algorithm but for each interval you use remember the index of the last reached interval Now the part with answering queries is in total because each interval will be jumped from no more than once Overall complexity 
1262,Let s consider a problem where you can subtract the weight of any edge not only the maximum one that belong to the current path and similarly add the weight of any edge not only the minimum one that belong to the current path To solve that problem we can build a new graph where the node can be represented as the following triple node from the initial graph flag that some edge has been subtracted flag that some edge has been added Now we can run Dijkstra s algorithm to find the length of the shortest paths in such a graph We can notice that on the shortest path the maximum weight edge was subtracted and the minimum weight edge was added Let s assume that this is not the case and an edge of non maximum weight was subtracted from the path then we can reduce the length of the path by choosing an edge of maximum weight But this is not possible because we considered the shortest path Similarly it is proved that the added edge was of minimal weight Using this fact it is not difficult to notice that by solving the modified problem we have solved the original one 
1263,This problem was prepared by dalex Let s build any MST with any fast algorithm for example with Kruskal s algorithm For all edges in MST the answer is the weight of the MST Let s consider any other edge x y There is exactly one path between x and y in the MST Let s remove mostly heavy edge on this path and add edge x y Resulting tree is the MST contaning edge x y this can be proven by Tarjan criterion Let s fix some root in the MST for example the vertex 1 To find the most heavy edge on the path from x to y we can firstly find the heaviest edge on the path from x to l lca x y and then on the path from y to l where l is the lowest common ancestor of vertices x and y To find l we can use binary lifting method During calculation of l we also can maintain the weight of the heaviest edge Of course this problem also can be solved with difficult data structures for example with Heavy light decomposition method or with Linkcut trees Complexity O mlogn It s very strange but I can t find any articles with Tarjan criterion on English although there are articles on Russian so here it is Some spanning tree is minimal if and only if the weight of any other edge x y not from spanning tree is not less than the weight of the heaviest edge on the path from x to y in spanning tree 
1264,We claim that the array is stable if and only if all elements are divisible by its minimum The proof of this fact will be at the end of the editorial To calculate the number of stable arrays now we need to iterate on the minimum in the array and choose the remaining elements so that they are multiples of it If the minimum is then the resulting elements should be divisible by There are such numbers between and and we have to choose elements out of since is already chosen The number of ways to do it can be calculated by precomputing factorials modulo since it is a binomial coefficient On the one hand since if all elements in the array are divisible by some element nothing depends on the order of these elements On the other hand suppose there exists an element such that it is not divisible by Let s take and two following reorders of the array and For the first array we get which is non zero and for the second array so the result is zero 
1265,Firstly I want to say a few words about the difficulty of this problem Till the last moment we didn t know easy to prove and easy to write solutions so we decided that this is a good problem E But now we realized it is a lot easier than we expected Now let s talk about the solution At the beginning let s remove redundant columns from the beginning and from the end i e columns without chips and change the value correspondingly Now let be if is and otherwise This array needed to make the implementation easier Let s calculate the dynamic programming where is the index of the last processed column and is the number of the row where our chip is standing This seems a bit suspicious why we can calculate such a dynamic programming so let s explain some things about it It can be shown that in the optimal answer there will be some column where the last move happens And if the number of this column is then all chips to the left of will move only to the right and all chips to the right of will move only to the left Actually we can always consider that is the last column Consider paths of two chips that will survive till the last move The first chip is to the left of and will move only to the right and the second one is to the right of and will move only to the left Then we can replicate the path of the second chip in the reverse order using the first chip So the second chip can stay still until the last move In the optimal answer it is always better to have exactly one chip in the current column because moving two chips to the right is always worse than just eat one of them and move the remaining one Initial states of are except the values of the first column For the first column and The answer will be Okay how to make transitions from For all from to let s consider four cases here we need one move to go to the next column and probably one more move to delete the figure in the second row in the column So the transition seems like same as the previous transition because the cost of this transition is always the distance between these cells is we just go firstly to the right and then down to ensure that we eat the figure in the first row So the transition is same as the previous transition Time complexity 
1266,Consider the naive approach to the problem Cut off the columns directly and count the connected components There are two main solutions to this problem either DFS or BFS or DSU I personally found the DSU method easier to adjust to the full problem So to count connected components with DSU you should do the following Initialize the structure without edges every free cell is its own connected component Then add edges one by one Each edge connects two cells either vertically or horizontally When an edge connects different components they merge and the number of components decreases by one Thus the number of components on a range of columns is the number of free cells on it minus the number of meaningful edges on it the ones that will merge components if the algorithm is performed only on these columns the spanning forest edges Let s try to adjust this algorithm to the full problem It would be great if we could just calculate the spanning forest of the entire matrix and then print the number of free cells minus the number of its edges on the segment Unfortunately it s not as easy as that For components that lie fully in the segment it works However if a component is split by a border of a segment it can both stay connected or fall apart If we determine its outcome we can fix the answer There are probably a lot of ways to adjust for that but I ll tell you the one I found the neatest to code Let s add the edges into DSU in the following order Go column by column left to right First add all vertical edges in any order then all horizontal edges to the previous column in any order If you start this algorithm at the first column you will be able to answer all queries with Since the algorithm adds columns iteratively the spanning forest it s building is correct after every column So the answer for each query is indeed the number of cells minus the number of edges on the range Let s investigate the difference between starting at the first column and an arbitrary column Look at the column If it contains or free cells or that are adjacent then the cells are always in the same component regardless of what has been before column If there are no free cells nothing to the left matters too This tells us that the spanning forest that the first algorithm has built is correct for any queries that start in this The only non trivial case is when only rows and of the th column contain a free cell Then we can t tell if the algorithm is correct or not because these two cells can be in the same component already or not Let s call this a column Imagine you started processing from the leftmost column of the query left to right to the rightmost column Our previous observations tell us that once we encounter a column that is not a the algorithm onwards will be correct Until then we only have some columns to deal with We can add the part from the first non column onwards to the answer the number of cells minus the number of edges And then handle the prefix with some easy casework if the leftmost column is not then add nothing if all columns in the query are then the answer is if the first non column is then add nothing since the s get merged into the component of this column if the first non column is or then add components since neither row nor row is merged anywhere otherwise add component The number of free cells and edges on a segment can be precalculated with some prefix sums The closest non column can also be precalculated with a linear algorithm Overall complexity 
1267,Let s calculate cycle n the number of permutations of length n which have a maximum at the position 1 and consist of exactly one cycle Each good permutation can be divided into such blocks so we ll need this value later It is easy to notice that cycle n n 2 Let s calculate the following dynamic programming dp i the number of good permutations consisting of elements i n To calculate dp i let s iterate over j the maximum element of the first block it determines the length of this block j i 1 dp i sum j i n dp j 1 cdot cycle j i 1 Now let s use the standard method of lexicographic recovery We will iterate over which element to put next it immediately determines the size of the new block and all the elements in it If the number of permutations starting with such block is at least k then you need to restore this block entirely and reduce the task to the one without this block Otherwise you need to subtract the number of permutations starting on such block from k and proceed to the next option for the block We will also use lexicographic recovery to restore the block You must carefully maintain the current block so that it consists of exactly one cycle To do this you can use DSU or explicitly check for a cycle 
1268,Let s run dfs on the tree and write out the vertices in order of their visisiting by dfs that permutation is called Euler walk Easy to see that subtree of any vertex is a subsegment of that permutation Note that the number of different colours is so we can store the set of colours just as mask of binary bits in bit type long long in C long in Java Let s build the segment tree over the permutation which supports two operations paint subsegment by some colour and find the mask of colours of some segment 
1269,At first the problem sounds like some sort of matching However it seems like you first want to match each point with either of its moves and then some pairs of points to each other That doesn t sound viable but since the matchings are often connected with graphs the graph idea might come handy Let s first consider a pair of matched points What does it actually mean that there exists a line through their new coordinates and It s the same as the angles of a line through the new coordinates of and and a line through the new coordinates of and are the same Angles are the same means that their tangents are the same and vice versa since we only consider the first quadrant of the plane So we can conclude that or of the first point should be equal to any of these of the second point Now consider the following graph Various values of tangents of the lines are the nodes Each point produces an edge between their and What are the matched pairs of points in this graph It s such a pair of edges that they share at least one endpoint Building a graph is the slowest part of the solution since you have to use some data structure or at least a sort and a binary search is possible with some sort of hashmap but should be perfectly fine as well So we reduced the problem to a more well known one given an arbitrary undirected graph find the maximum number of pairs of edges such that each pair shares at least one endpoint and each edge is included in no more than one pair The upper bound on the answer is the following Let be the number of edges in the th connected component Best case we can make pairs from it Let s come up with an algorithm to achieve this bound Consider a dfs tree of a component It s known that a dfs tree of an undirected graph contains no cross edges So if we direct all the edges of a dfs tree downwards convert all back edges to forward edges each edge will connect some vertex to its descendant Imagine we came up with a dfs such that matches all the edges that have their upper node in the subtree of to each other except one edge in case there is an odd number of them will solve the task exactly then How should that dfs work exactly What if there were no forward edges at all That case is easy since all edges are tree edges We ll try to maintain an invariant that the only unmatched edge is an edge that has as one of its endpoints If is a leaf then there s nothing to match Otherwise we go into some child If it can t match all its edges then match its remaining edge to an edge If it can then remember that we have an edge unmatched so far Go into another child Same match our edge with its edge if it has one unmatched However if turned out to get unmatched and turned out to be unmatched then you can match them to each other This way you will be left with at most one unmatched edge after you process all the children and that edge has its endpoint at Add the forward edges back Did anything change Look at the forward edge that has its upper vertex the lowest We can see that it points to a vertex that has its subtree fully matches So why don t we treat this forward edge the same as an edge to a leaf Forget that has some subtree of its own and just believe that you can t match the edge so far Proceed the same as the easy case Since we mark exactly which edges you pair up with which it s trivial to retrieve the answer Overall complexity 
1270,At first array contains a palindromic subarray of length is equivalent to array contains a palindromic subarray of length So we need to calculate number of arrays without palindromes of length It s equivalent to finding arrays where for all appropriate Note that and have same parity so all odd and all even positions in array are independent and answer is the product of the number of ways to choose numbers for odd positions and the number of ways to choose numbers for even positions In terms of same parity our condition morphs to and we need to calculate all ways to replace s in such way that all pairs of consecutive elements are different To calculate it let s look at sequences of consecutive s They will look like with s where and are positive case where is empty can be considered as case with empty is solved the same way In the end we need to find a way to calculate the number of those sequences There are only two fundamental types of sequences same value from both ends and Exact values of and don t really matter Let s find a way to calculate both values name them and for consecutive s in time Base values Let s try to choose value of in the middle of sequence if then we can split sequence in two sequences of length and and If then just iterate over value of last then and Resulting complexity is 
1271,Let s write down the indices of the pattern that the th string matches If is not among these then the answer is Otherwise all the patterns except should go in the resulting ordering after Consider that as a graph Let s add an edge from to each of the matches If you add the edges for all the strings then the topological ordering of the graph will give you the valid result If the graph has any cycles in it you can t topsort it then there is no answer To find all the patterns we can use the fact that is rather small Consider all the binary masks of length Each mask can correspond to a set of positions in the string that are replaced with wildcards Now if there is a pattern that is exactly equal to the string with the fixed set of positions replaced by wildcards then that pattern is a match To search for an exact match you can either store all patterns in a map beforehand or in a sorted array or build a trie of them The second version is faster by a factor of but both solutions should pass easily Overall complexity or 
1272,At first you need to sort the sequence Then if there exists some answer there also exists an answer such that every box in it contains some segment of pencils Now it s pretty standard dp approach Let be if it s possible to distribute the first pencils into boxes correctly otherwise initially Now you can come up with straightforward implementation Let s iterate over every and set to if for some and Now we should optimize it a bit Notice that the second and the third conditions actually form some segment of indices You need to check if there is at least one value on this segment This can be maintained with two pointers set BIT segment tree Anything you can code to get update in point and sum max on segment queries Overall complexity 
1273, All elements in the left set smaller than all elements in the right set means that there is such value that all elements from the first set less than and all elements from the second set are more or equal to So let s make a sweep line on from to while trying to maintain all answers for each prefix Let s maintain for each the total cost to make sets good if we split the permutation on sets and in such way that after transformations all elements in the first set less than It s easy to see that the total cost is equal to sum of weights where and and where and So what will happen if we increase by Let s define the position of as For each we don t need to move to the second set anymore so we should make On the other hand for each we need to move from the second set to the first one now so we should make The answer will be equal to the It means that we should handle two operations add some value on the segment and ask minimum on the segment So we can store all in pretty standart Segment Tree with add on segment and minimum on segment while iterating over So the total complexity is 
1274,Let s store current intervals with non working days in set sorted by the right border When new query comes you search for the first interval to have its right border greater or equal than the currect left border and update all intervals to intersect the query either fully delete or insert back its part which doesn t intersect query Finally if then insert the query into current set Updates on the number of working days can be done while deleting segments on the fly Overall complexity 
1275,If we want to place n rooks on an n times n chessboard so all empty cells are under attack then either each row or each column should contain at least one rook Let s suppose that each row contains at least one rook and multiply the answer by 2 in the end How to ensure that there are exactly k pairs of rooks attacking each other Since each row contains exactly one rook only the rooks in the same column attack each other moreover if there are x rooks in a non empty column they create x 1 pairs So our goal is to distribute n rooks to n k columns so that each column contains at least one rook How to calculate the number of ways to distribute the rooks into c columns One of the options is to choose the columns we use the number of ways to do this is n choose c and then use inclusion exclusion to ensure that we are counting only the ways where each column contains at least one rook The formula we will get is something like sum limits i 0 c 1 i c choose i c i n we want to fix the number of columns that will not contain rooks that is i which are these columns that is c choose i and how many are there ways to distribute the rooks among remaining columns that is c i n Are we done Almost We wanted to multiply the answer by 2 to count the ways where each column contains at least one rook but we should not do it if k 0 because in this case each placement of the rooks has exactly one rook in each row and exactly one rook in each column 
1276,The prerequisites for each lecture form a rooted tree so let s forget about the legend and learn how to find such an order of vertices of a tree that all conditions work Let s introduce some algorithm that produces an ordering of vertices for every possible case If any valid ordering exists it should produce a valid one So we will only have to check if the resulting ordering is fine and output it if it is If there were no special pairs the task would be perfectly solvable with an algorithm of topological sorting Thus let s come up with a way to modify the graph so that topsort could still be a solution We know that the vertices that are in the special pairs should follow each other in the ordering Look at these special pairs as edges as well Let s first imagine they are undirected These edges connect some vertices in the tree into components Each component should be a segment of vertices in a valid answer So how about we compress them into one vertex first each find some answer for a compressed version and decompress them back Let each of these connected components be a vertex in the new graph Two components are connected by an edge if there is a edge in the tree between vertices of the corresponding components Topsort in this graph will tell us the order the components should go However we should also find the order the vertices should go inside each component Let s topsort the graph of all directed special pairs and sort the vertices in that order in every component We can sort the entire graph instead of sorting each component separately because the components are totally independent Finally write down the answer iterate over the compressed vertices of the first new graph in the order of its topsort for each one write down all the actual vertices inside it in the order of the topsort of the second new graph Check if each vertex has its parent earlier than itself in the answer If all the graphs were topologically sortable and that holds then the answer exists and we found it Otherwise the answer doesn t exist Overall complexity O n log n 
1277,There are exactly games in the tournament each game has only two possible outcomes So it s possible to bruteforce all possible ways the tournament could go if is not large In fact this solution is fast enough when so if we somehow can handle the case we will have a working solution To handle let s divide the teams into two groups teams from to and teams from to There will be exactly matches in each group and the winners of these two groups will play in the finals The number of possible ways the games in a group can go is just so let s try to bruteforce all possible results in each group and somehow merge them into the results of the whole tournament The main idea is to rewrite as where and find all possible values for and and choose a pair of values that yields exactly the given value of We will handle two separate cases the winner of the first group wins the whole tournament or the winner of the second group wins the whole tournament Suppose we are handling the first case the second is symmetrical By choosing the results of matches in the first group we determine the places of the teams from the first group the winner of the first group gets place the team eliminated in the last match of the first group gets place and so on It means that by choosing one of the possible results in the first group we can calculate Let s bruteforce these combinations of results in the first group and store them in some data structure that allows to check whether some value of is achievable in the model solution it s a which maps reachable values of to combinations of results that yield these values Then by choosing the results of matches in the second group we can calculate so the remaining part of the solution is to bruteforce all possible results in the second group calculate for them and check that such that can be achieved by choosing the results in the first group Don t forget to also handle the case when the team which wins in the first group loses in the finals it is almost the same but the winner in the first group gets place and the winner in the second group gets place The technique I ve described here instead of bruteforcing all possible variants split the thing we try to bruteforce into two parts bruteforce them separatedly and then try to merge the parts is called and can be used to solve a large variety of problems 
1278,Let s find the smallest wallet to fit all bills One its side is the maximum side of any bill Now we orient the bills in such a way that their longer side is put against this side of the wallet The second side of the wallet is the maximum of the other sides More formally for set of bills for each the minimum wallet is The minimum wallet fits all sufficient wallets So the solution is maintaining the maximum of all and and checking if and Choose your i o functions wisely Overall complexity 
1279,Let s start with learning how to place lamps of fixed power to cover the segment with the minimal number of them The following greedy strategy works find the rightmost non blocked position that is covered by lamps and place lamp there until either everything is covered or rightmost free position is to the left of the last placed lamp Initially you only consider to be covered Function the minimal number of post lamps to cover segment is clearly monotonous thus you want to update states as early as possible Okay now you iterate over all and update the answer with the results multiplied by cost Now why will this work fast You obviously precalculate the rightmost free position for each prefix segment If there are any free positions to the right of last placed lamp then the rightmost of them will always be the rightmost for the entire prefix segment Finally any two consecutive iterations of the algorithm will either move you by positions or return This can be easily proven by contradiction Overall complexity as you do about steps for each and that is a common series sum 
1280,What s the issue with calculating the prefix function on the string and then appending the string with an extra recalculations Calculating prefix function is linear anyway Well it s linear but it s also amortized So while it will make operations for a string in total it can take up to on every particular letter These particular letters can appear in string making the algorithm work in Let s analyze the classic way to calculate the prefix function To append a character to the string and calculate the new value of the prefix function you have to do the following take the longest proper prefix of a string before appending the letter which is also a suffix if the letter right after it is the same as the new one then the new value is length of it plus one if it s empty then the new value is otherwise take its longest proper prefix and return to step Basically from having the value of the prefix function of the string and the new letter you can determine the new value of the prefix function If was always equal to then you would only want to try all options for the next letter after a string That should remind you of a structure known as prefix function automaton Its states are the values of the prefix function and the transitions are appending a letter to a string with a certain value of the prefix function So you can append a letter in if you have an automaton built on the string However you can t just append more letters after one you don t have the automaton built this far You can follow two paths The first one is to jump with a regular way of calculating the prefix function until you reach the state of the automaton which exists The second one is to continue building the automaton onto the string calculating the prefix function along the way Appending a layer to the automaton takes non amortized After you calculated everything you needed pop the states back to the original Overall complexity or 
1281,In terms of preorder strings the operation swap two children of some vertex means swap two substrings of equal length in some specific location This operation can be inverted by applying it an additional time so for every positive integer all of the strings of length are split into equivalence classes in such a way that two strings from the same class can be transformed into each other and two strings from different classes cannot For each vertex the set of its possible preorder strings is one of these classes Let s calculate the answer for the problem recursively let be the number of preorder strings for the vertex For a leaf the number of its preorder strings is For a vertex with children and one of the two holds if the equivalence class for vertex is different from the equivalence class for vertex then we have to pick a string from the class of vertex pick a string from the class of vertex and choose the order in which we take them So if the equivalence class for is the same as the equivalence class for then swapping and doesn t do anything so we pick a string from the equivalence class of and then a string from the equivalence class of So The only thing we don t know is how to determine if two vertices represent the same equivalence class The model solution uses hashing for this but there s a much simpler method for each vertex let be the lexicographically smallest string that can be a preorder string of If a vertex has children and then and we can calculate these strings recursively since the total length is each of characters will be present in strings 
1282,Edge biconnected component in an undirected graph is a maximal by inclusion set of vertices so that there are two edge disjoint paths between any pair of vertices Consider the graph with biconnected components as vertices Easy to see that it s a tree if it contains some cycle then the whole cycle is a biconnected component All edges are destroying when we passing over them so we can t returnto the same vertex in the tree after leaving it by some edge Consider the biconncted components that contains the vertices and Let s denote them and Statement the answer is YES if and only if on the path in the tree from the vertex to the vertex there are an edge with an artifact or there are a biconnected component that contains some edge with an artifact Easy to see that the statement is true if there are such edge then we can pass over it in the tree on the path from to or we can pass over it in biconnected component The converse also easy to check Here is one of the ways to find edge biconnected components Let s orient all edges to direction that depth first search passed it for the first time Let s find in new directed graph strongly connected components Statement the strongly connected components in the new graph coincide with the biconnected components in old undirected graph Also you can notice that the edges in tree is the bridges of the graph bridges in terms of graph theory So you can simply find the edges in the graph 
1283,Lets find the maximum number such that all values form the non descending order array It can be done the following way Let values form the non descending order array Then values will form the non descending order array if the first occurrence of in array is after the last occurrence of In similar manner we can find the minimum number such that all values form the non descending order array Now let s find out how to get the minimum number such that all values form the non descending order array if we fixed the value We denote this value for some fixed value as Firstly conditions and should hold Secondly there should be no such a pair that conditions and hold Since the condition is satisfied it means that must be greater than where is the last occurrence of in array In this way the answer is 
1284,Let s start by learning how to answer a query all red pepper and black pepper options are available Let s iterate over all options to put the peppers and choose the maximum of them First let s use the red pepper for all dishes Now we want to select some of them to use black pepper instead of red pepper Which ones do we choose When we switch from the red pepper to the black pepper the total tastiness changes by for the th dish They are completely independent of each other so we want to choose largest of these values Let be the sequence of values of in a non increasing order Thus black peppers will yield the result of We can answer a query by looking for a maximum in the sequence Now consider an arbitrary query Let be all options for the amount of available black peppers for the query Naively we could iterate over all of them and choose the maximum one However notice an interesting thing about the sequence of the answers By definition it is non strictly convex In particular one idea that can be extracted from this is the following Find the position of an arbitrary maximum in this sequence Then everything to the left of is is non increasing Everything to the right of it is non increasing Thus for a query it s enough to consider only two options the one closest to the maximum from the left and from the right Now we only have to learn how to get these options fast enough For a query we want to solve what s called a diophantine equation An arbitrary solution can be obtained by using extended Euclid algorithm Let it be some Then we would want to check the answer for black peppers The amount of solutions to the equation is either infinite or zero If it s infinite all solutions will be of the form for any integer Remember that not all the solutions will be in a range Finally find the two solutions that are the closest to the maximum check that they are in the range and print the best answer of them Overall complexity 
1285,Let s solve the problem from the end Let s maintain the array what number will become if we apply to it all the already considered queries of type If the current query is of the first type then we simply add to the resulting array If the current query is of the second type then we have to change the value of Since all occurrences of must be replaced with it is enough to assign Since we process each query in the final complexity is There is also an alternative solution Let s process queries in the direct order Let s store all its positions in an array for each number Then for the first query it is enough to put the index in the corresponding array of positions And for a query of the second type we have to move all the positions of the number into an array of positions of the number The naive implementation is obviously too slow but we can use the small to large method then the complexity of the solution will be 
1286,Let s calculate the answer for a fixed point If you project with respect of each segment of the fence to the line containing light source you can see that the answer is the length of intersection of fence projection with segment of the trajectory light source Key idea is the fact that the length of each fence segment is multiplied by the same coefficient On the other hand fence segments whose projections lie inside form a subsegment in the array of segments so its total length can be obtained with partial sums And at most two fence segment are included in the answer partially their positions can be calculated with lower bound if you project points and on axis So now you can answer the query with time and quite small hidden constant and resulting complexity is 
1287,This problem can be solved using dynamic programming is if Roma could play first games with balance is and for each such that and we update if if if and all three states if If either of and is then we can restore the sequence Time and memory complexity is As an exercise you can think about linear solution 
1288,Let s calculate the answer as the sum of suitable numbers in range minus the sum of suitable numbers in range Now our problem is to calculate the sum of suitable numbers in range The main approach for problem is digit DP Let s calculate two dynamic programmings and means that now we are at the th digit of the number at the digit corresponding to where is the decimal length of a number is a binary mask describing digits we already use and equals if the current prefix of number we trying to obtain is the same as the prefix of number otherwise equals So what means It means the count of numbers in general not numbers but their prefixes in range of length without leading zeroes corresponding to this state So what the point of this DP Its point is helping us to calculate the main DP which means the sum of numbers in general not numbers but their prefixes in range of length without leading zeroes corresponding to this state How do we calculate the answer Firstly let be the length of Let be the function calculating the sum of numbers from to containing at most different digits How to calculate it Let be the sum of numbers from to containing at most different digits and having length exactly Then seems to be pretty easy for each length from to add to the answer And the last step is to add to the answer How to calculate dynamic programmings Initially all states are zeroes excluding which is Firstly let s calculate After calculating it we can calculate in almost the same way Let s iterate over all possible lengths and over all possible masks Let the current state is Then let s iterate over next digit we will place in this number and place it If then otherwise The transition is pretty easy There is the bitwise operation For transitions are almost the same expect the restrictions on digit we place and the state we update If we now at the position with mask and then the current digit of is Then let s iterate over next digit if otherwise The transition is also easy After calculating the previous DP we can calculate All the process is the same as in the previous dynamic programming expect the value we will add in transitions In the previous DP this value was equal in the current DP this value equals to Don t forget to calculate it modulo So after calculating all the values of DPs what is the answer for It is for all masks with at most bits I m pretty sure that there is another way to avoid leading zeroes in calculating these DPs but this one is very straight forward and simple 
1289,There are lots of different solutions for this problem We can iterate on the number of elements we will take in this editorial element is a souvenir with weight When fixing the number of elements let it be we want to know the best possible answer for the weight while taking into account only elements and elements To answer these queries we can precalculate the values triples where is the best possible answer for the weight and and is the number of elements and elements we are taking to get this answer Of course and we can update and using value of After precalculating for each possible we can iterate on the number of elements There are also several binary ternary search solutions 
1290,Let s take a look at any operation You can notice that each letter can only go from position to indexed Then doing some operation twice is the same as doing that operation zero times Now consider some set of operations sorted in increasing order Actually they do the following altogether Replace segment with the reversed segment and vice versa Then replace segment with the reversed segment and vice versa And continue until you reach the first pair Segment might also be included in the answer when the parity is right Moreover every subset of segments is achievable So for each segment you can either swap it or not Let s translate it to math language Let be the number of such pairs of strings and that Why is there such an order You want to consider only unique strings thus you need to pick exactly one of equal strings from each component Let it be the smallest one Then for each segment of the set you have pairs to choose from where is the length of that segment And that part of the formula is However the part covered by zero segments is left There are possible strings up there is actually a number of all pairs of strings of length plus the number of all pairs of equal strings of length divided by Overall complexity 
1291,Consider a naive solution using Kruskal s algorithm for finding MST Given some you arrange the edges in the increasing order of and process them one by one Look closely at the arrangements At the edges are sorted by How does the arrangement change when increases Well some edges swap places Consider a pair of edges with different weights and Edge will go before edge in the arrangement as long as is closer to than So for all up to edge goes before edge And for all from onwards edge goes before edge This tells us that every pair of edge with different weights will swap exactly once So there will be at most swaps Which is at most different arrangements Each of them corresponds to some range of s We can extract the ranges of s for all arrangements and calculate MST at the start of each range We can also find the arrangement that corresponds to some from a query with a binary search However only knowing the weight of the MST at the start of the range is not enough The weights of edges change later in the range and we can t predict how Some edges have their weight increasing some decreasing First let s add more ranges We want each edge to behave the same way on the entire range either increase all the way or decrease all the way If we also add for all into the MST calculation this will hold Second let s store another value for each range the number of edges that have their weight increasing on it With that we can easily recalculate the change in the cost of the spanning tree The TL should be free enough for you to sort the edges for each MST calculation resulting in solution You can also optimize the first part to 
1292,Let s fix the maximum element on segment and iterate on either the elements to the left of it or to the right of it and if the current maximum is and the element we found is check whether the element can form a special subsegment with that is is the maximum value on the segment between and That obviously works in yes Well not exactly If we can precompute the borders of the segment where is the maximum element this can be done with some logarithmic data structure or just by processing the array with a stack forwards and backwards and always choose to iterate on the smaller part of the segment it s Why is it so Every element will be processed no more than times because if we process it in a segment of size the smaller part of it contains no more than elements which we will process later and the smaller part of this segment contains no more than elements and so on Checking whether the element belongs to the segment we are interested in can be done in if we precompute inverse permutation for 
1293,Consider some permutation q Let s build by it the oriented graph with edges i qi Easy to see and easy to prove that this graph is the set of disjoint cycles Now let s see what would be with that graph when the permutation will be multiplied by itself all the cycles of odd length would remain so only the order of vertices will change they will be alternated but the cycles of even length will be split to the two cycles of the same length So to get the square root from the permutation we should simply alternate in reverse order all cycles of the odd length and group all the cycles of the same even length to pairs and merge cycles in each pair If it s impossible to group all even cycles to pairs then the answer doesn t exist Complexity O n 
1294,Let s denote as some stack sortable array which contains all integers from to inclusive We can see that if the first element of is then where by we mean concatenation of arrays It s easy to prove this fact if the first element is then we have to store it in the stack until we have processed all elements less than so in no element that is greater than can precede any element less than This way we can represent the prefix we are given For example if and prefix is then we can rewrite the permutation we have to obtain as So the unknown suffix is a contatenation of some stack sortable arrays It s easy to see that if an array is sorted in non increasing order then it is stack sortable So we can replace each block with an array If during rewriting the given prefix we obtain some impossible situation for example when and given prefix is we have and can t be the beginning of then answer is 
1295,The solution consist of two main parts calculate the initial number of staircases and recalculate the number of staircases on query The constraints were pretty loose so we ll do the first part in and the second part in per query However it s worth mentioning that faster is possible The first part can surely be done in and can probably be done in The second part can be done in per query It s important to notice is that the only staircase that satisfy the requirements for both types is the staircase that consists of a single cell Thus staircases of both types can be calculated almost separately Let s define base staircases as the staircases that can t be prolonged further in any direction There are of them on the grid If a staircase consists of at least two cells it s a part of exactly one staircase At the same time every segment of a staircase is a valid staircase by itself Thus the main idea of calculating the initial answer is the following Isolate each staircase and determine its length possibly in Add the number of segments of length at least to the answer Add extra one cell staircases afterwards If you draw the staircases on the grid you can easily determine their starting cell The staircases that start by going one cell to the right start from the first row The staircases that start by going one cell to the bottom start from the first column Notice that both types can start from cell The updates can be handled the following way The answer always changes by the number of staircases that pass through cell if you ignore its state If the cell becomes free then these staircases are added to the answer Otherwise they are subtracted from it That can be calculated for two cases as well Go first down then right as far as possible Let it be steps Go first left then up as far as possible Let it be steps Then staircases are added to the answer Then change the order of steps in both directions to calculate the other type of staircases Beware of one cell staircases again To achieve for precalc you can calculate the length of each staircase with a formula To achieve per query you can first enumerate cells in each staircase separately then maintain the set of segments of adjacent free cells in it 
1296,Let the weight of the edge between the vertex to the vertex be Suppose there exists a pair of vertices and with indices greater than such that or Then if we choose the spanning tree with all vertices connected to it won t be an MST we can remove either the edge or the edge add the edge instead and the cost of the spanning tree will decrease So we should have for every pair It can be shown that this condition is not only necessary but sufficient as well if for every pair the condition holds the MST can t have the weight less than We can prove this by induction suppose that for simplicity in the spanning tree there should be at least one edge incident to vertex and its weight is at least there should be at least two edges incident to vertices and and their weights are at least there should be at least edges incident to vertices from to and their weights are at least Okay now let s show how to calculate the number of such graphs We can run the following dynamic programming let be the number of graphs where we have already connected vertices to the vertex and the maximum weight we have used is We start with and for each transition from we will iterate on the number of vertices we connect to the vertex with edges with weight let the number of those vertices be choose them with a binomial coefficient and also choose the weights for the edges that connect one of the chosen vertices with one of the vertices already connected to since for each of those edges we know that their weights should be in so we need to multiply the value in transition by where is the number of such edges Implementing this dynamic programming can be done in or both are sufficient 
1297,First of all let s find the resulting position for each character of the string It s easy to see that we don t need to swap equal adjacent characters it changes nothing so the first character in the original string is the first character in the resulting string the second character in the original string is the second character in the resulting string and so on Now let s build a permutation of elements where is the resulting position of the element that was on position in the original string For example for the string this permutation will be In one operation we may swap two elements in this permutation and our goal is to sort it since each character of the string has its own required position and when for every the condition holds each character is on the position it should be The required number of swaps of adjacent elements to sort a permutation is exactly the number of inversions in it since each swap changes the number of inversions by and this number can be calculated using many different techniques for example mergesort tree or Fenwick tree 
1298,Notice that if there are substrings of length for each letter then there are also substrings of length Thus the function on the answer is monotonous so the binary search is applicable Let s have some answer fixed by binary search We have to place blocks of letters of length somewhere in a string If we fix an order these blocks go into the string then the greedy algorithm for placing them works Put each block after the previous one but as far to the left as possible the correctness can be proven by showing that picking not the furthest to the left position can t be more optimal If there exists such an order that all blocks fit then the answer is greater than or equal to The common transition is to move from iterating over permutations to dynamic programming over submasks Let be the smallest prefix of the string such that all blocks of letters from the mask fit into this prefix The transitions are the same pick a new block and place it as early after that prefix as possible So far the solution works pretty slow since for each of masks we have to find the earliest possible position for a block Let s use some precalculations to perform the transitions in Notice that the transition doesn t depend on a mask only on a length of the previous prefix Thus for every prefix and every letter we can save the closest position for a block Let be the closest position for a prefix of length and the th letter is at least equal to However if the block can be placed at the th position then it should be updated That can happen if the closest occurrence of any letter except is not smaller than Thus we can also maintain the closest occurrence of every letter With some smart iterations we can do the precalculations in The dynamic programming works in then Overall complexity 
1299,There are many ways to solve this problem including precalculating all answers but the model solution is based on the following In most cases It is not true only when the last digit of is and if we know the number of digits at the end of we can easily derive the formula for And since there will be at most one number with last digit equal to in Let s iterate on the last digit of and the number of digits before it Suppose the fixed has no other digits other than the last one and several digits before it Let s calculate Here goes the trick If we prepend with several digits such that the last of them is not and the sum of those digits is then So we can easily derive the value of we need and construct the smallest number with sum of digits equal to don t forget that the last digit should not be 
1300,Instead of counting the edges belonging to the maximum matching it is easier to count the vertices So we will calculate the total number of vertices saturated by the maximum matching over all possible tuples and then divide the answer by Furthermore it s easier to calculate the number of unsaturated vertices than the number of saturated vertices so we can subtract it from the total number of vertices in all graphs we consider and obtain the answer Let s analyze how to calculate the total number of unsaturated vertices Each graph is a subgraph of the given graph so it is still bipartite and the degree of each vertex is still not greater than A bipartite graph where the degree of each vertex is at most can be represented as a set of cycles and paths and the maximum matching over each of these cycles paths can be considered independently Each cycle has an even number of vertices since otherwise the graph would not be bipartite so we can saturate all vertices on a cycle with the matching For a path the number of unsaturated vertices depends on its length if the number of vertices in a path is even we can match all vertices on it otherwise one vertex will be unsaturated So the problem reduces to counting paths with odd number of vertices in all possible graphs Every path with an odd number of vertices has a center the vertex which is exactly in the middle of the path Let s iterate on the center of the path and its length and calculate the number of times this path occurs in all graphs we consider Suppose the center of the path is the vertex and the number of vertices in it is Then for this path to exist two conditions must hold every vertex such that the distance from to is not greater than should be present in the graph every vertex such that the distance from to is should be excluded from the graph It means that for each of the two parts of the graph there are several vertices that should be present in the graph and zero or two vertices that should be excluded from the graph It s easy to see that among the vertices we have to include we are only interested in the minimum one and the maximum one all vertices between them will be included as well if these two are included So we need to implement some kind of function that allows us to calculate the number of segments that cover the minimum and the maximum vertex we need and don t cover any of the vertices that we have to exclude this can be easily done in Note that the segments should be considered independently for both parts of the graph Overall for each vertex we have to consider at most different lengths of odd paths with the center in this vertex The minimum maximum indices of vertices in both parts we have to include in the graph can be maintained while we increase the length of the path so the whole solution works in 
1301,Unfortunately my solution for this problem had overflow bug It was fixed on contest Even so I hope you enjoyed the problem because I think it s very interesting Let s transform the sum Note that the last sum can be accumulated to only value because for all the values will be equal to Note in the last sum either or Let s carefully accumulate both cases The first sum can be simply calculated by iterating over all We will accumulate the second sum independently for all different values Firstly we should determine for which values we will have the value Easy to see that for the values from the interval Also we can note that the sum of the second factors in with fixed first factor can be calculaed in constant time it s simply a sum of arithmetic progression So we have solution with complexity 
1302,We are given the definition of the balanced multiset but let s instead fix the criteria to determine if the multiset is unbalanced Take an empty multiset and start adding numbers to it until it becomes unbalanced Empty set to the set of one number is trivial Now for the second number If there is some position such that both numbers have non zero digits in it then the multiset becomes unbalanced let these be non zero digits and then can be neither nor After that let s prove that you can never make an unbalanced multiset balanced again by adding numbers to it Let there be such multisets and such is unbalanced is balanced and Take a look at the lowest position which has non zero digits in several numbers from The sum of these digits should be equal to at least one of them modulo to satisfy the condition of balance That can only mean their sum is greater or equal to thus is make a carry to the next position The sum of digits on the next position plus carry should also be equal to some digit of them thus pushing some other carry value to the next one And so on until the carry makes it to the position greater than any position in any of the numbers But the carry is non zero and there is no number with any non zero digit in this position That makes our assumption incorrect After all it implies that any unbalanced multiset of size greater than two has an unbalanced multiset of size two The problem now got reduced to find a pair of numbers and such that there is at least one position such that both and have non zero digits on it and is minimal possible That can be easily maintained in a segment tree Let a node corresponding to the interval keep the best answer on an interval the sum of such a pair and an array the smallest number on an interval which has a non zero digit at position or if none exists The update is easy Iterate over the digits of a new number and update the values in the array in the corresponding nodes The merge is done the following way push the best answers from children to the parent and then iterate over the positions and try to combine the smallest numbers at each one from the left child and the right child Idea wise this is the same as storing a segtree and calculating the answer by each position separately However these approaches differ by a huge constant factor performance wise The former one accesses the memory in a much more cache friendly way You might want to take that as a general advice on implementing multiple segtrees Overall complexity 
1303,Let s carefully analyze the operation denoted in the query Since the length of the array is always divisible by every element will be swapped with some other element The elements can be split into two groups the ones whose positions increase by and the ones whose positions decrease by Let s find some trait of the elements which will allow us to distinguish the elements of one group from the elements of the other group The first elements will be shifted to the right the next elements will be shifted to the left the next elements will be shifted to the right etc If we look at the binary representations of integers then we can see that the first elements have in the th bit the next elements have in the th bit the next elements have in the th bit and so on So if we consider the positions of elements as indexed then the operation can be described as follows Let the position of the element be If the th bit in is gets increased by otherwise gets decreased by What does it look like Actually it is just where denotes XOR So each query can be represented as swap with for some integer The combination of two queries can also be represented with a single query in fact the state of the array can be denoted as the XOR of all from the previous queries Now let s try to solve the following problem for every calculate the maximum sum of subsegment if every element is swapped with To solve this problem we can use a segment tree First of all we need to understand how to solve the problem of finding the maximum sum on subsegment using a segment tree To do this we should store the following four values in each vertex of the segment tree the sum of elements on the segment denoted by the vertex the maximum sum of elements on the prefix of the segment denoted by the vertex the maximum sum of elements on the suffix of the segment denoted by the vertex the answer on the segment If some vertex of the segment tree has two children these values for it can be easily calculated using the values from the children So we can glue two segments represented by the vertices together creating a new vertex representing the concatenation of these segments Okay but how do we apply XOR to this For every vertex of the segment tree let s create several versions the th version of the vertex represents the segment corresponding to this vertex if we apply swapping query with to it For a vertex representing the segment of length we can use the following relation to get all its versions here we denote as the th version of and and as the children of if then else The function here denotes the glueing together of two vertices we described above Now let s try to analyze how many versions of each vertex we need For the root we will need all versions For its children we need only versions For the children of the children of the root we need only versions and so on so overall the total number of versions is only and each version can be constructed in so the solution works in 
1304,If we don t have two distinct strings then we just have to swap any pair of characters in any of the given strings and print it Otherwise we have to find two indices and such that Then let s store all positions such that in array If the number of those positions will exceed 4 then the answer will be 1 Otherwise we need to iterate over all positions in array try to swap with any other character of and check that current string can be the answer We also should try the same thing with string It is clear how we can check string to be the answer Let s iterate over all strings and for each string count the number of positions such that Let s call it If for any given string is not equal to 0 or 2 then string can t be the answer Otherwise if for any given string is equal to 0 and all characters in string are distinct then can t be the answer If there is no string that satisfies all aforementioned conditions then the answer will be 1 
1305,For each vertex we will build the following structure for its children the segment for the second child is nested in the segment for the first child the nested for the third child is nested in the segment for the second child and so on and the children of different vertices do not intersect at all Let s solve the problem recursively for each of the children create a set of segments with endpoints from to where is the size of the subtree After that combine them To do this you can use small to large technique and change the coordinates of the segments or use the necessary offset in the function call for the next child After that it remains to cross children s segments with the segment of the vertex itself To do this you can move the right ends of all segments of the children by to the right and add a segment that starts before the first one and ends immediately after the last one 
1306,Of course there is no need to press home more than once and no need to press end at all because suppose we did something on suffix then pressed home did something on prefix and then pressed end and continue doing something on suffix Then we can merge these two sequences of moves on suffix and press home after we did anything we wanted on suffix and the answer will not get worse Now let s iterate over the position at which we will press home in range from to In other words we iterate over the position till which we press only left and backspace to fix the suffix So now we have the string and we want to get some suffix of from this string but we actually don t know which suffix of we want So let s iterate over the length of this suffix in a range from to Now we have the string and the string and we have to check if we can obtain this suffix of from this suffix of This part can be precalculated in greedily we just can store for each suffix of the rightmost position in in which this suffix is obtainable If we can obtain the current suffix then we obviously can say the number of moves to do that it is and actually do not depend on the suffix length because if we meet the character we need we just press left and move to the next character otherwise we press backspace and move to the next character deleting the one we don t need After that we press home and now we have to check if we can obtain from This part can also be precalculated greedily in like the part with rightmost positions for suffixes But the minimum number of moves required to obtain the prefix is tricky Actually if we consider these prefixes from right to left we want to match as many characters from the beginning as possible In other words if we reverse and we want to find their longest common prefix and this will be the number of characters we don t want to touch at all and if it is the longest common prefix it means that the next character is bad and we want to remove it anyway so the length of LCP of these two reversed prefixes is the only thing affecting the number of moves on the prefix This part can be precalculated in with simple dynamic programming using memory or with z function in time and memory we just need to build a z function on a string where is the concatenation of strings and is the reverse operation The required value of the z function for the fixed values and will be in the position And the answer for the prefix will be this is the number of extra characters on the prefix we have to delete plus plus because we have to press home But there is a corner case If the prefix is empty then we don t need to do all of this and the answer for prefix will be Complexity time and memory 
1307,Suppose we want to divide first problems of the contest between the first contestant and the second contestant the first contestant will get first problems and the second contestant will get problems in the middle and then give all the remaining problems to the third contestant We are going to iterate on from to and for each possible find the best value of Okay Now suppose we fixed and and now we want to calculate the number of problems that should be redistributed Let s denote as the number of problems among first ones given to the th contestant as the number of problems among last ones given to the th contestant and as the number of problems in the middle given to the th contestant Obviously the answer for fixed and is but we don t like this expression because we don t know how to minimize it for fixed We know that for fixed the values of and are constant Using that we may arrive at the fact that minimizing is the same as minimizing for fixed and now we have a way to quickly find best possible for fixed 
1308,An straightforward dp solution is to calculate number of states at the end of the game in which no one has scored more than goals where is the number of total goals to be scored and is the number players in the game Fix the score of Hasan in the game and by using this dp the rest is easy also described below But as long as the time needed to calculate is this solution won t fit in the constraints With a little help from combinatorics we can calculate the value of mentioned dp function without using recursions Define by inclusion exclusion principle it can be easily seen that the value of equals to the above And the complexity of calculation for is with a preprocess for calculating binomial coefficients This formula is a well known modification of Star and Bars problem but with the upper limit on terms Now we can calculate the answer firstly fix Hasan s score and number of top scorers then use to calculate each state By using modulus arithmetic the answer can be reported in the requested form Overall complexity 
1309,Let then it is the standard problem which can be solved by FFT Fast Fourier Transform The solution is the following consider the polynomial which the th coefficient equals to one if and only if there is the number in the given array Let s multiply that polynomial by itself and find for which the coefficient in square not equals to Those values will be in the answer Easy to modificate the solution for the arbitrary We should simply calculate the th degree of the polynomial The complexity will be where is the maximal sum We can improve that solution Instead of calculating the th degree of the polynomial we can calculate the th degree of the DFT of the polynomial The only problem is the large values of the th degrees We can t use FFT with complex numbers because of the precision problems But we can do that with NTT Number theoretic transform But that solution also has a problem It can happen that some coefficients became equals to zero modulo but actually they are not equal to zero To get round that problem we can choose two three random modules and get the complexity The main author solution has the complexity FFT with complex numbers the second solution has the same complexity but uses NTT and the third solution has the improved complexity but it was already hacked by halyavin 
1310,If our friend is the strongest boxer he wins without any bribing Otherwise we have to bribe the strongest boxer and he can defeat some other boxers directly or indirectly Suppose we chose the boxers he will defeat then there is another strongest boxer If our friend is the strongest now we don t need to bribe anyone otherwise we will bribe the strongest remaining boxer again and he can defeat other boxers and so on The only thing that s unclear is which boxers should be defeated by the ones we bribe We may use dynamic programming to bribe them is the minimum cost to bribe boxers so that all boxers among strongest ones are either bribed or defeated by some bribed boxer For each value of we know the maximum amount of boxers that are defeated by bribed boxers so the transitions in this dynamic programming are the following if we can t defeat the next boxer for free our bribed boxers have already defeated as many opponents as they could we have to bribe him otherwise we either bribe him or consider him defeated by some other boxer Overall complexity is 
1311,I should notice that there is much simpler idea and solution for this problem without rerooting technique but I will try to explain rerooting as the main solution of this problem it can be applied in many problems and this is just very simple example What if the root of the tree is fixed Then we can notice that the answer for a subtree can be calculated as where is the set of children of the vertex The answer on the problem for the fixed root will be How can we calculate all possible values of for each root from to fast enough We can apply rerooting When we change the root of tree from the vertex to the vertex we can notice that only four values will change and Firstly we need to cut the subtree of from the tree rooted at Let s subtract and from then let s change the size of the subtree of subtract from it Now we have the tree without the subtree of Then we need to append as a child of Add to and add and to Now we have as a root of the tree and can update the answer with When we changes the root of the tree back from to we just need to rollback all changes we made So overall idea is the following calculate sizes of subtrees for some fixed root calculate dynamic programming for this root run dfs which will reroot the tree with any possible vertex and update the answer with the value of dynamic programming for each possible root The code of function that reroots the tree seems like this void dfs int v int p 1 ans max ans dp v for auto to g v if to p continue dp v dp to dp v siz to siz v siz to siz to siz v dp to siz v dp to dp v dfs to v dp to dp v dp to siz v siz to siz v siz v siz to dp v siz to dp v dp to 
1312,At first it doesn t matter if some season has more than episodes so we can set Let s maintain next invariant when we proceed th season we will have only seasons containing the episodes with indices Then the number of pairs is just number of seasons with index One of the ways to maintain this invariant is the following for each number of episodes store a list with indices of seasons with exactly episodes Then after proceeding of th season just erase all seasons with exactly episodes Maintaining seasons and counting them can be done by BIT with zeros and ones Finally notice that we counted each pair twice and also counted the pairs so we must subtract the number of pairs where and divide the result by two 
1313,Firstly let s compress the moments of time Note that storing only and isn t enough consider pairs and you also should take Now moments of time are up to For every moment calculate the number of segments to cover it make and for each segment and take prefix sums over this array Then let be the number of moments of time covered by only one segment on some prefix up to th moment And finally if for some segment from the input is then you can safely delete this segment Overall complexity 
1314,At first let s reverse arrays and Now array is sorted in descending order Now let s find minimum index such that If there is no such index or if then the answer is because minimum on any prefix of array will never be equal to Otherwise let s find the minimum index such that If there is no such index or if then the answer is Also let s find the minimum index such that it can t be greater than The first subarray starts in position and ends in any position because if it ends in position or further then the minimum in the first subarray is greater than So there are ways to split subarrays and A similar approach can be used to calculate the number of ways to split the second and third subarrays and so on After all you have to check that minimum in the last subarray is equal to otherwise the answer is 
1315,Consider some participant s segment and one of the author s segment How does the length of intersection change when you move from left to right It first increases until the centers of both segments coincide that s the easiest to notice on the segments of the same length and then decreases The increase is totally symmetrical to the decrease With that idea you can conclude that the author s segment whose center is the closest to the center of participant s segment has the larger intersection length Let s sort the participants segments by their center You can see that the first author will be optimal for the prefix of the segments and the second author for the remaining suffix So you can just iterate over the length of the prefix and update the answer with all options Overall complexity 
1316,Consider a naive solution Iterate over all pairs and apply all operations The complexity is The constraints obviously imply that it s too much What can we cut from it Well surely will still remain there Both of and also should So we can probably only hope to turn this into Let s try that Notice that no matter what operations are applied never changes You can also peek at the examples and see that the patterns are suspiciously diagonal shaped in the matrix Let s try to solve the problem by fixing and calculating the answer for all values of I will call the fixed variable Consider case where and Here all can fit into both and so we can avoid caring about one restriction on the operations We ll think what to do with large volumes later If there are no operations the answer for each initial is for all from to Now consider an operation for some For nothing changes Actually for all the result of the operation is the same as for Hmm but if the result is the same it will remain the same until the end Same from the other side The answers for and also get merged together To me it kind of looks like a primitive form of DSU on these volume states you merge some prefix of the answers together and merge some suffix of the answers together If the state was merged to either or then it s easy to calculate the actual answer for that state What happens to the remaining states Well since they weren t merged anywhere the operation for them was applied fully if was requested all was poured How to deal with multiple operations then I propose the following idea When applying an operation we only want to know which of the previously non merged states become merged Basically we can squish all previous operations into one just sum up the signed amounts of water Since they all were applied fully to the non merged states it s completely valid After the squish check for the new merges You can actually study the structure of the answers and see that they go like that for some values of and such that It isn t that important but it makes the code easier You can basically calculate the length of the merged prefix the length of the merged suffix then calculate the answer at the end of the prefix in and restore all answers from it We neglected larger values of earlier time to return to them Another kind of limit to each operation is added when extra water doesn t fit in another tank Well it doesn t change that much It only makes more prefix suffix merges To come up with the exact formulas I followed these points Something merges on an operation when any of these holds not enough water in the first tank not enough space in the second tank not enough water in the second tank not enough space in the first tank Replace all with and you get the constraints for prefix and suffix merges Overall complexity 
1317,Let s solve this problem for fixed set of spells For example we have a fireball spells with powers and lighting spells with powers We reach the maximum total damage if we can double all spells with maximum damage It s possibly iff the set of largest by power spell let s denote this set as contains at least one fireball spell Otherwise if set contains only lightning spells the maximum damage reach when we double largest spells in set and one largest spell not from set if such spell exist Now how do you solve the original problem when spells are added and removed All we have to do it maintain the set of largest by power spells where is current number of lightning spells and change this set by adding or removing one spell Also you have to maintain the sum of spells power in set this set and the number of fireball spells in this set You can do it by in or on 
1318,To solve this problem we can use a data structure which allows to add some value on segment and get a value from some point Fenwick tree segment tree or anything you are familliar with Let s run DFS from the root while maintaining current depth When entering a vertex on depth let s consider all queries having and for each such query add on segment Then for current vertex the answer is the value in point When leaving vertex we need to rollback everything we have done for all queries having subtract on segment 
1319,Let s use dynamic programming to solve the problem Let be the number of correct partitions for the long integer It s easy to see that if we have two big integers without leading zeroes we know the lengths of these integers and these lengths are not equal then we can determine which integer is greater in We will calculate the answers in the following order Suppose we want to calculate Let be the minimum position such that the number meets the following condition Let be the maximum position such that the number meets the following condition Initially let s consider will be less if will be less if To determine which of the numbers and is greater let s calculate z function for the string where is any character that doesn t occur in and After calculating z function we can easily find the first non equal character in and and this character will determine which number is greater To compare and we can act the same All that s left is to set to the sum of values from to This can be done by maintaining suffix sums There is a corner case which applies when If then because we cannot afford any leading zeroes Otherwise 
1320,We set up a DP on start index end index number of consecutive digits matching our start index In other words the current string we are solving is the substring from start index to end index plus some number of additional digits all equal to S start added as a prefix to our substring We then have two choices from any given state Cash in on our consecutive digits at the start and recurse on Pick an index such that S start S i and collapse everything between those two indices in order to merge them together for an even larger prefix This results in a score of and we can loop over all to take the maximum The runtime is with a very good constant factor Code 49036191 Does anybody have 
1321,One important fact is that when we subtract from new will be divisible by old And of course is always divisible by Let s factorize Consider the moment when changes If we denote old value of by the new value of will be divisible by some where is a prime divisor of Let s check all prime divisors of and for each of these divisors find the number of times we need to subtract from to get divisible by that is just don t forget that also has to be divisible by Among all prime divisors of pick one with the minimum required number of operations let this number of operations be add to answer subtract from and repeat the process 
1322,The following greedy strategy work Let s turn all the taps at full power If total temperature is greater than then we would like to decrease power on some taps with higher temperature We want to decrease as low power as possible so we should prioritize taps with the highest temperature Sort all taps by temperature and find the total power on suffix you should decrease to have equal temperatures This can be done with binary search The same works for smaller initial temperature Overall complexity 
1323,It s quite obvious that we can place bosses only on the bridges of the given graph if an edge is not a bridge then removing it doesn t make the graph disconnected so there still exists a path between any pair of vertices And if we fix two vertices and and then find some simple path between them then we will place the bosses on all bridges belonging to this path since the set of bridges would stay the same no matter which simple path between and we choose If we find bridges in the given graph and compress all 2 edge connected components two vertices belong to the same 2 edge connected component iff there exists a path between these vertices such that there are no bridges on this path into single vertices we will obtain a special tree called bridge tree Every edge of a bridge tree corresponds to a bridge in the original graph and vice versa Since we want to find the path with maximum possible number of bridges we only need to find the diameter of the bridge tree and this will be the answer to the problem 
1324,At first let s prove that in optimal solution all spells of 1 st type are assigned to single creature By contradiction let s optimal answer contains indices where and If using spells of 1 st type is meaningless Otherwise if in general case then Contradiction So we can check for each creature maximal damage with its health multiplied At second if we sort all creatures in order by decreasing using spells on first creatures gives best answer So calculating answer for chosen creature invokes 2 cases if chosen creature is belong to first creatures then subtract from its contribution calculate new value and add it to otherwise we need one spell of second type which is optimal to take from th creature so along with replacing old value of chosen one we need to replace in contribution of th creature Result complexity is 
1325,To begin with we note that there are no restrictions on the values that can be written on the vertices so we can use numbers of the form for the th replacement Then if we replaced the value of a vertex then no path passing through this vertex has weight Let s root the tree at the vertex number We can use a greedy approach consider some vertex such that it is the LCA for two vertices and the path between which has XOR equal to Among such vertices pick one with the maximum distance from the root We need to change at least one vertex on the path It turns out that changing the vertex is always no worse than changing any other vertex on this path because all the remaining bad paths that pass through the vertex also pass through the vertex that s why we have chosen the deepest LCA This means that in order to solve the problem it is necessary to quickly find the deepest LCA of some bad path For the convenience of solving the problem let s denote the XOR on the path as where is XOR on the path from the root to the vertex For all vertices let s maintain a set of values such that belongs to the subtree of Let s use the small to large method to obtain such sets Also during the union of sets we can check if there is a bad path in this subtree i e if two values in the sets we merge have the same XOR as the value written on the current vertex because that s when the XOR on path is If such a path exists then we have to change the value of the vertex and mark that the vertices of this subtree cannot be the ends of a bad path anymore that means we just clear the set instead of pulling it up the tree This solution works in 
1326,Let be the number of xor sequences of length with the last element equal to Let be equal to one if contains the number of ones in binary presentation that is multiple of three Otherwise let be equal to zero Consider a vectors and a matrix Easy to see that So Let s use the associative property of matrix multiplication at first let s calculate with binary matrix exponentiation and then multiply it to the vector 
1327,Let s look at any occurrence of arbitrary pair There is exactly one special split position where the ends and starts So instead of counting occurrences for each pair we can iterate over the position of split and count the number of pairs This transformation is convenient since any which ends in split position can be paired with any which starts here So all we need is to calculate for each suffix the number of strings which starts here and for each prefix the number of strings which ends here But calculating the prefixes can be transformed to calculating suffixes by reversing both and all Now we need for each position calculate the number of strings which occur from It can be done by Aho Corasick Suffix Array Suffix Automaton Suffix Tree but do we really need them since constrains are pretty low The answer is NO We can use sqrt heuristic Let s divide all in two groups short and long The is short if There are no more than long strings and for each such string we can find all its occurrences with z function or prefix function It will cost as What to do with short strings Let s add them to trie The trie will have vertices but only depth So we can for each move down through the trie while counting the occurrences using only substring It will cost us So if we choose we can acquire complexity using only basic string structures 
1328,Let s precalculate the values the maximal number of letters z to the left to the right and to the left down from the position It s easy to do in time Let s fix some cell Consider the value It s the maximum size of the square with upper right ceil in But the number of z patterns can be less than Consider some cell diagonally down left from on the distance no more than The cells and forms z pattern if Let s maintain some data structure for each antidiagonal it can be described by formula that can increment in a point and take the sum on a segment Fenwick tree will be the best choice for that Let s iterate over columns from the right to the left and process the events we have some cell for which In that case we should increment the position in the tree number by one Now we should iterate over the cells in the current column and add to the answer the value of the sum on the segment from to in the tree number 
1329,Denote the number of voters with as Also denote i e is equal to number of voters with Let s group all voters by value We ll consider all these group in decreasing value of Assume that now we consider group with Then there are two cases if then all these voters will vote for you for free is equal to the number of votes bought in previous steps if then we have to buy additional votes Moreover the value of this bought voter must be greater than or equal to Since these voters indistinguishable we have to buy cheapest voter with a minimal value of So all we have to do it maintain values not yet bought voters in some data structure for example in 
1330,I think it s easier to approach this problem using combinatorics instead of probability theory methods so we ll calculate the answer as the sum of values of over all ways to choose the index on each iteration of the loop If a number is chosen on the iteration of the loop then it is reduced to the maximum number divisible by that doesn t exceed the initial value So if a number is divisible by all integers from to i e divisible by it won t be changed in the operation Furthermore if then the value of this element won t become less than It means that we can interpret each number as where and The part with will always be added to the variable when this element is chosen so let s add to the answer which is the contribution of over all ways to choose the indices in the operations and work with instead of Now all elements of the array are less than We can use this constraint by writing the following dynamic programming to solve the problem is the number of appearances of the integer in the array over all ways to choose the indices for the first iterations For is just the number of occurrences of each integer in the array The transitions from are the following ones if this element is chosen in the operation then it becomes and we transition to the state otherwise the element is unchanged and we transition to the state multiplying the current value by which is the number of ways to choose some other element in the operation How can we use this dynamic programming to get the answer On the th iteration the number of times we choose the integer is exactly and the number of ways to use the integers in the next operations is so we add to the answer for every such state This solution runs in time which may be too slow if not implemented carefully Fortunately we have an easy way to optimize it use instead of which divides by in the worst case scenario for our solution We can do this because even if an integer is changed on the th operation we are not interested in this change since this is the last operation 
1331,This problem can be solved with mincost maxflow approach Let s construct a following network Construct a vertex for every number from to For each of these vertices add directed edges from the source to this vertex the capacity of each edge will be and the costs will be so pushing flow from the source to the vertex will cost exactly Also construct a vertex for every index of the array For each number make add a directed edge with capacity and cost to every position in the array such that this number can be put into this position and for every index make a directed edge from the vertex constructed for this index to the sink with capacity and cost Minimum cost maximum flow in this network will construct a suitable array with minimum cost so the answer to the problem is minimum cost of maximum flow in the network 
1332,We will solve the problem for each bit separately and then multiply the results Obviously if the position is covered by a segment with the value then we have no choice and we must put there For segments with the value there must be at least one position that they cover and its value is So we can write the following dynamic programming the number of arrays such that the last was exactly at the position and all segments to the left of it contain at least one zero It remains to determine which states we can update from The only restriction we have is that there should not be any segment with the value such that and Since in this case this segment will not contain any zero values For each position we may precalculate the rightmost position where some segment ending before begins and while calculating we should sum up only the values starting from position This can be done with prefix sums 
1333,This problem has two different solutions a mincost maxflow approach and a greedy one We will tell you about the latter First of all let Then find all pairs of indices such that let the number of these pairs be It s obvious that we have to replace at least one letter in each of these pairs For each of these pairs let s replace the letter with lower with something Let s analyze the letters we are going to replace Let be the number of occurences of letter that we have to replace There are two cases There is no letter such that Then we can replace these letters without involving anything else and get an antipalindromic string with minimal possible cost There is a letter such that It s obvious that there is at most one such letter Let s replace some occurences of with other letters that are to be replaced Then we will still have some occurences of that need to be replaced Let s take one letter from each pair such that both of letters in a pair are not equal to Among these possibilities choose the required number of letters with minimum values of Then we can replace remaining occurences of with these letters 
1334,The first observation if all the ants are indistinguishable we can consider that there are no collisions and all the ants are passing one through another So we can easily determine the final positions of all the ants but we can t say which ant will be in which position The second observation the relative order of the ants will be the same all the time So to solve the problem we should only find the position of one ant after seconds Let s solve that problem in the following way Consider the positions of all the ants after time units Easy to see that by the first observation all the positions of the ants will left the same but the order will be different we will have some cyclic shift of the ants If we find that cyclic shift we can apply it times After that we will have only time units So the problem now is to model the process for the one ant with and time units Note that in that time interval the fixed ant will have no more than two collisions with each other ant So if we model the process with ignoring all collisions except the ones that include the fixed ant we will have no more than collisions Let s model that process with two queues for the ants going to the left and to the right Each time we should take the first ant in the queue with opposite direction process the collision and add that ant to the end of the other queue Hint you will have a problem when the fixed ant can be in two different positions at the end but it s easy to fix with doing the same with the next ant 
1335,Among two armor sets one with the greater index is always better The same can be said about two different weapons So it is always optimal to use and obtain the best possible weapon or armor This observation allows us to model this problem with dynamic programming or shortest paths let be the minimum time in which Monocarp can obtain the armor and the weapon and in each transition we either get the best weapon we can or the best armor we can Similarly we can build a graph where the vertices represent these pairs and the edges represent getting the best possible weapon armor and find the shortest path from to using BFS Unfortunately it is But we can modify the BFS in the following fashion let s analyze each layer of BFS a layer is a set of vertices with the same distance from the origin In each layer there might be some redundant vertices if two vertices and belong to the same layer and then the vertex is redundant If we filter each layer removing all redundant vertices from it and continuing BFS only from non redundant ones the solution will be fast enough To prove it let s analyze the constraints on the answer Suppose The answer can be bounded as since we can reach the pair in steps using something similar to Fibonacci sequence building and then go from to in steps And the number of non redundant states on each layer is not greater than because of two states with the same weapon or the same armor set at least one is redundant So if we don t continue BFS from redundant vertices it will visit at most vertices There might be another logarithm in the asymptotic complexity of the solution if you use something like a set to store all combinations that synergize well but this implementation is still fast enough 
1336,This problem seems like a version of Nim with some forbidden moves so let s try to apply Sprague Grundy theory to it First of all we may treat each castle as a separate game compute its Grundy value and then XOR them to determine who is the winner of the game When analyzing the state of a castle we have to know two things the number of remaining soldiers in it and the type of the last attack performed on it So the state of the game can be treated as a pair We can compute Grundy values for each state in a straightforward way but the constraints are too large to do it Instead we should try to search for a period five consecutive rows by row we mean a vector of Grundy values for the same number of remaining soldiers but different types of last attacks of Grundy values determine all of the values after them so as soon as we get the same five rows of Grundy values that we already met we can determine the period There are values stored in these five rows so the period can be up to but that s a really generous upper bound Some intuition can help us to prove something like or as an upper bound but it is better to check all cases with brute force and find out that the period is at most After we ve found the period of Grundy values it s easy to get them in for any castle To count the number of winning moves for the first player we can compute the XOR sum of all castles and for each castle check what happens if we make some type of attack on it if the XOR sum becomes then this move is winning 
1337,The main idea of this problem is to use a technique similar to contribution to the sum We will model the value of as the number of tuples where each element is an index of a bag from which we have taken an odd ball Let be the number of ways to take balls from bags so that all elements from tuple are indices of bags with odd balls then the answer to the problem can be calculated as the sum of over all possible tuples First of all let s obtain a solution in per test case We need to answer the following questions while designing a solution to the problem How do we calculate for a given tuple How do we group tuples and iterate through them The first question is not that difficult Every element from the tuple should be an index of a bag from which we have taken an odd ball so for every bag appearing in the tuple we can take only a ball with odd number but for every bag not appearing in the tuple we can choose any ball So if the number of elements in a tuple is then for the tuple can be calculated as This actually gives as a hint for the answer to the second question since depends on the number of distinct elements in the tuple let s try to group the tuples according to the number of distinct elements in them So the answer will be calculated as where is the number of tuples with exactly different elements How do we calculate First of all if then is obviously Otherwise we can use the following recurrence let be the number of tuples of elements with distinct ones then if and for a tuple with one element there are ways to choose it if and if and there is only one distinct element and it was already chosen if and we either add an element which did not belong to the tuple and there are ways to choose it or we add an already existing element and there are ways to choose it Obviously this recurrence can be calculated in with dynamic programming so we get a solution in per test case How do we speed this up Let s change the way we calculate Instead of considering tuples with values from to we will consider only tuples where values are from to and the first appearance of a value is only after the first appearance of the value So these tuples actually represent a way to split a set of integers into several subsets so they are the Stirling numbers of the second kind and we can calculate them in with dynamic programming outside of processing the test cases How do we calculate using these values If we use distinct integers as the elements of the tuple there are ways to choose the first one ways to choose the second one etc so where is the Stirling number of the second kind for the parameters and We can maintain the values of and while iterating on from to and that gives us a way to solve the problem in per test case Overall complexity for precalculation and per test case 
1338,First of all since the second operation changes all occurrences of some number to other number and vice versa then by using it we can convert an array into another array if there exists a bijection between elements in the first array and elements in the second array It can also be shown that so we can consider that if we want to transform an array into another array then we first apply the function then the function Another relation that helps us is that it means that every time we apply the function we can easily rollback the changes Considering that we have already shown that a sequence of transformations can be reordered so that we apply only after we ve made all operations with the function let s try to rollback the second part of transformations i e for each array find some which can be obtained by using the function Since applying the second operation several times is equal to applying some bijective function to the array we can treat each array as a partition of the set into several subsets So if we are not allowed to perform the first operation the answer to the problem is equal to where is the number of ways to partition a set of objects into non empty sets these are known as There are many ways to calculate Stirling numbers of the second kind but in this problem we will have to use some FFT related approach which allows getting all Stirling numbers for some value of in time For example you can use the following relation If we substitute and we can see that the sequence of Stirling numbers for some fixed is just the convolution of sequences and For simplicity in the following formulas let s denote We now know that this value can be calculated in Okay now back to the original problem Unfortunately we didn t take the operation into account Let s analyze it The result of function consists of several blocks of equal elements and it s easy to see that the lengths of these blocks except for maybe the last one should be divisible by The opposite is also true if the lengths of all blocks except maybe for the last one are divisible by some integer then the array can be produced as for some array What does it mean If the greatest common divisor of the lengths of the blocks except for the last one is not the array that we consider can be obtained by applying the function to some other array Otherwise it cannot be obtained in such a way Now inclusion exclusion principle comes to the rescue Let s define as the number of arrays that we consider which have the lengths of all their blocks except maybe for the last one divisible by It s easy to see that we can compress every consecutive elements into one Then using inclusion exclusion principle we can see that the answer is where is the Mobius function Using this formula we can calculate the answer in This inclusion exclusion principle handles the arrays according to the GCD of the blocks that they consist of except for the last one But what if the array consists only of one block These arrays can be counted wrongly so we should exclude them i e use instead of just and count the arrays consisting of the same element if we need any of them in the answer separately Depending on the way you implement this or or both may be a corner case 
1339,The key is to use divide and conquer We need a recursive function f left right that runs f left mid and f mid 1 right where and also considers all intervals going through We will eventually need a convex hull of lines linear functions and let s see how to achieve it For variables we will try to write the score of interval as a linear function It would be good to get something close to where and depend on and depends on only For each we should find a linear function where should fit the equation Now we have a set of linear functions representing all possible left endpoints For each right endpoint we should find and to fit equation again With value of we can iterate over functions to find the one maximizing value of And still for fixed we should add to get the maximum possible score of interval ending in 
1340,At the beginning to make things simpler we should add a query hint with and then sort queries by Sorted queries hints divide interval into disjoint intervals For each interval we know how many elements should be there Let s build a graph and find a max flow there The answer is YES only if the flow is The first group contains vertices representing possible remainders The second group contains vertices representing intervals Each vertex from should be connected with the source by an edge with capacity Each vertex from should be connected with the sink by an edge with capacity equal to the size of the interval Between each vertex from and from should be an edge with capacity equal to the number of numbers in the interval giving remainder when divided by You can also use see that it s similar to finding matching In fact we can use the Hall s marriage theorem For each of sets of vertices from sets of remainders iterate over intervals and count how many numbers we can take from with remainders from the fixed set of remainders 
1341,There are two approaches to this problem Most of the participants of the round got AC by implementing dynamic programming with data structures such as segment tree but I will describe another solution which is much easier to code Let s consider a graph where each vertex represents a segment and two vertices are connected by an edge if the corresponding segments compose a bad pair Since each bad pair is formed by two segments of different colors the graph is bipartite The problem asks us to find the maximum independent set and in bipartite graphs the size of the independent set is equal to where is the number of vertices and is the size of the maximum matching The only thing that s left is finding the maximum matching Let s use event processing approach to do it for each segment create two events the segment begins and the segment ends While processing the events maintain the currently existing segments in two sets grouped by their colors and sorted by the time they end When a segment ends let s try to match it with some segment of the opposite color and it s quite obvious that we should choose a segment with the minimum to form a pair Overall this solution runs in 
1342,To begin with let s understand that an array is bipartite if and only if there is no decreasing subsequence of length in the array Now we can write dynamic programming is there an array of length such that is the maximum last element of a decreasing subsequence of length and is the maximum last element of a subsequence of length Note that Let s consider all possible transitions from the state if we are trying to put the number on the th position where if then the new state will be if then the new state will be if then such a transition is not valid because a decreasing subsequence of length is formed in the array With a naive implementation such dynamic programming works in We can note that for fixed values of and and it is enough for us to store only the minimum available value of So we can write dynamic programming which is defined similarly to the above but now instead of being Boolean stores the minimum value of or infinity if the state is not valid We have speeded up our solution to but it is still too slow To speed up the solution even more we have to look at the transitions in dynamics and notice that for a fixed either or is always equal to So we can rewrite our dynamic programming in the following form Here the flag says which of the numbers and is equal to and the flag is responsible for the sign of and the minimum value of or is stored in the value itself depending on Thus we got a solution with a linear running time In fact this solution can be simplified if we see the following relation the number we use on position is not less than and not greater than This allows us to get rid of one of the states in our dynamic programming altogether so we get an easier solution This optimization wasn t required to get AC but the code becomes shorter 
1343,If the edges were only added and not deleted it would be a common problem that is solved with disjoint set union All you need to do in that problem is implement a DSU which maintains not only the leader in the class of some vertex but also the distance to this leader Then if we try to connect two vertices that have the same leader in DSU and the sum of distances to this leader is even then we get a cycle with odd length and graph is no longer bipartite But in this problem we need to somehow process removing edges from the graph In the algorithm I will describe below we will need to somehow remove the last added edge from DSU or even some number of last added edges How can we process that Each time we change some variable in DSU we can store an address of this variable and its previous value somewhere for example in a stack Then to remove last added edge we rollback these changes we rewrite the previous values of the variables we changed by adding the last edge Now we can add a new edge and remove last added edge All these operations cost because path compression doesn t work in intended time if we have to rollback Let s actually start solving the problem For convinience we change all information to queries like edge exists from query number till query number It s obvious that there are no more than such queries Let s use divide and conquer technique to make a function that answers whether the graph is bipartite or not after every query from some segment of queries First of all we add to DSU all the edges that are present in the whole segment and not added yet then we solve it recursively for and then we remove edges from DSU using the rollback technique described above When we arrive to some segment then after adding the edges present in this segment we can answer if the graph is bipartite after query Remember to get rid of the edges that are already added and the edges that are not present at all in the segment when you make a recursive call Of course to solve the whole problem we need to call our function from segment Time complexity is because every edge will be added only in calls of the function 
1344,The constraints tell us that the solution should be linear or pretty close to it Well in particular that implies that the solution almost certainly isn t dynamic programming since we have both and to care about Thus we ll think about something greedy When we know the number of move the game will last we can tell how many steps each chip should make Well since the more moves the game last the more steps each ship makes the answer is a monotonic function Let s apply binary search and think if we can check if each chip can make some known number of steps A common idea in the problems where you have to do something greedily on a tree is to root the tree arbitrarily and process everything bottom up Consider the bottommost chip If it can move its number of moves downwards it s always optimal to do that Since it s the bottommost chip it can only make things worse for chips above it And any of them can t pass through the initial vertex of this chip anyway If it can t it has to move to its parent vertex Let s move it there and deal with this chip later when it becomes the bottommost again If it can t move to its parent it can t move at all Thus the game can t last for this many steps Since we only apply either the move which is guaranteed to not interrupt any other moves or the move which is forced the greedy strategy is correct As for implementation details it s not too tricky Basically for each vertex we should maintain these values if this vertex has been visited the number of steps the chip in this vertex still has to make if any chip is in this vertex the longest path downwards from this vertex via non visited vertices The second value can be initialized beforehand and pushed to the parent when needed The rest of them are easily maintained with a single dfs Overall complexity per testcase 
1345,Let s solve the problem by dynamic programming Let be the probability of winning if the last taken card has number on it and the number of taken cards is We win immediately next turn if we take card with number on it The probability of this is where is number of cards with Also we can win if we take a greater card next turn We take a card with number with probability with number with probability and so on The probability of winning in this case will be and respectively So the probability of winning for is Therefore all we need is to maintain the sum while calculating our dynamic programming 
1346,The most tricky part of the problem is how to check if some set of cards allows us to build a deck with the required power not taking the levels of cards into account Suppose we have not more than one card with magic number if there are multiple cards with this magic number then we obviously can use only one of these Then two cards may conflict only if one of them has an odd magic number and another has an even magic number otherwise their sum is even and not less than so it s not a prime number This allows us to solve this problem as follows Construct a bipartite graph each vertex represents a card and two vertices are connected by an edge if the corresponding pair of cards can t be put in a deck Then we have to find the maximum weight of independent set in this graph This can be solved using maximum flow algorithm construct a network where source is connected with every odd vertex a vertex that represents a card with an odd magic number by an edge with capacity equal to the power of this card then connect every odd vertex to all even vertices that are conflicting with this vertex by edges with infinite capacities and then connect every even vertex to the sink by an edge with capacity equal to the power of the card all edges have to be directed Then the maximum power of the deck is equal to where is the sum of all powers and is the minimum cut value between the source and the sink which is equal to the maximum flow This allows us to check if we can build a deck of required power using only some set of cards for example only cards with level less than or equal to some 
1347,1278F CardsFirst of all I would like to thank Errichto for his awesome lecture on expected value part 1 part 2 This problem was invented after I learned the concept of estimating the square of expected value from that lecture and the editorial uses some ideas that were introduced there Okay now for the editorial itself We call a number as good if and the th shuffle of the deck resulted in a joker on top from our problem is the number of such good numbers We can represent as the number of pairs such that every element of the pair is a good number as the number of triples and so on is the number of tuples such that each element of a tuple is a good number So we can rewrite the expected value of as the expected number of such tuples or the sum of over all tuples where is the probability that consists of good numbers How to calculate the probability that is a good tuple Since all shuffles of the deck result in a joker with probability should be equal to but that is true only if all elements in are unique How to deal with tuples with repeating elements Since all occurences of the same element are either good or bad with probability of being good the correct formula for is where is the number of distinct elements in the tuple Okay then for each we have to calculate the number of tuples with exactly distinct elements To do that we use dynamic programming let be the number of tuples with exactly distinct elements Each transition in this dynamic programming solution models adding an element to the tuple if we want to compute the transitions leading from we either add a new element to the tuple there are ways to choose it and we enter the state or we add an already existing element there are ways to choose it and we enter the state Overall complexity is or depending on your implementation 
1348,Let s use a trie to store the given words Now let s imagine a procedure that checks if some string of length can be represented as a concatenation of some of these words If the words were prefix independent no word was a prefix of another word that task would be solvable with a greedy algorithm We could iterate over a string and maintain the current vertex of the trie we are in Append a current letter If there is no such transition in a trie it can t be represented If the vertex we go to is a terminal jump to the root of the trie Otherwise just go to that vertex However since the words aren t prefix independent we have a terminal on a path to other terminals Thus we can t immediately decide if we should jump to the root or just go Let s handle this with dynamic programming can we put letters in such a way that the vertex of a trie we are in is Is building a chainword letter by letter that different from this process Apparently it isn t Consider how many ways are there to put letters in a string so that the first hint is in a vertex and the second hint is in a vertex For the transition we can try all letters to put and jump to the corresponding vertices That obviously is too slow The intuition tells us that this dp should be calculated with some kind of matrix exponentiation since That dp can be rewritten as a matrix pretty easily However its size is up to the maximum number of vertices in a trie squared Some say that there is a way to compute the th power of such a huge matrix fast enough with Berlekamp Massey but I unfortunately am not familiar with it Thus we ll have to reduce the size of our matrix First notice that the only reachable states are such that the word that is written on a path from the root to is a suffix of a word that is written on a path from the root to or vice versa Look at it the other way if we build a trie on the reversed words then one of the vertices will be an ancestor of another one Now it s easy to estimate the number of states as the sum of depths of all vertices However since we look at ordered pairs of we should more or less double that amount That should be states at max This can probably pass with an optimal enough implementation We can do better though Let s merge the states and into one state The intuition is basically that you can swap the hints at will That makes the pairs unordered now there are up to pairs That surely will work fast enough The way to generate all the possible states is the following run a dfs bfs starting from that makes all valid transition and record all the states that can be visited While preparing the tests I only managed to get up to states and I would really love to hear an approach to either prove a tighter bound or to generate a test closer to the bound of 
1349,Firstly let s try to find some naive solution for this problem Let s iterate on the subset of locks Alice puts on the chests After choosing the subset of locks how to check whether Bob can gain positive profit We can iterate on the subset of keys he can buy as well but in fact this problem has a polynomial solution Construct a flow network as follows each chest and each key represents a vertex there are arcs from the source to the vertices representing the chests each having capacity arcs from the vertices representing the keys to the sink each having capacity and for each chosen lock an arc from the respective chest vertex to the respective key vertex with infinite capacity If we find the minimum cut from the source to the sink then Bob s profit is The reasoning behind this solution is the following one if Bob takes all the chests and all the keys belonging to the first part of the cut his profit is equal to the total cost of all chests he has taken minus the total cost of all keys he has taken minus infinity if he takes a chest he can t open And the value of the cut is equal to the total cost of chests he doesn t take plus the total cost of keys he takes plus infinity if he can t open some chest he takes since the arc from this chest vertex to one of the key vertices belongs to the cut So Bob s profit is and by minimizing the cut value we maximize his profit A minimum cut can be easily found using any maxflow algorithm Unfortunately even iterating through all subsets of locks is too slow To improve this solution we should look at the minimum cut and its usage a bit more in detail Notice that Bob can always take no keys and open no chests to get a profit of zero so Alice s goal is to ensure that it is the best Bob s option If Bob takes no chests and no keys it means that the cut divides the network into two parts the source and all other vertices And in terms of flows it means that the maximum flow in this network I highlighted it because it is the key idea of the solution Here the constraints on and come in handy We can use a dynamic programming with the flow over all arcs going from the source as one of the states One of the ways to implement it is to have as the state where through are the values of the flow going from the arcs from the source is the current vertex in the left part we consider is the current vertex in the right part we consider and is the flow we already pushed through the arc connecting vertex of the right part to the sink and the value we store for this state is the minimum cost Alice has pay to reach this state There are two basic types of transitions in this dynamic programming we either skip the arc from to or pick it and transfer some flow through it and no matter what we ve chosen we move to the next vertex of the left part or to and increase by if we are already considering the th vertex of the left part The constraints were loose enough to implement this dp basically in any form there was no need to compress the states into single integers for example which was what the most participants of the round did 
1350,Notice that the square covers the point if and only if Using this fact let s reformulate the problem the following way we have to find the segment such that the sum of the segments fully covered by it is maximal Let s build a segment tree the th of its leaves stores the sum of the segments covered by the segment Initially it s built for some such that it is to the right of all segments Other nodes store the maximum in them Now let s iterate over the values of in descending order Let there be some segment starting in with the cost All the answers for won t change because they don t cover that new segment And the values on the suffix from the position will increase by The only thing left is to learn how to handle the subtraction of the length of the side That term is and the thing we are looking for is Rewrite it in form and you ll see that you can just subtract from the value of the th leaf of the segment tree at the beginning to get the correct result Surely you ll need to add that after you ask the maximum of all the segtree to obtain the answer You ll probably need to compress the coordinates leave only such positions that there is at least one or Implicit segtree might work but neither ML nor TL are not friendly to it Also be careful with the case with all points being negative 
1351,Firstly let s call a path from to if is a leaf is a vertex of degree at least the number of their neighbors is at least and there are no other vertices of degree at least on this path expect the vertex The first step of the solution is to remove all the paths from to but we should not remove the vertex and remember for each vertex the sum of two maximum lengths of paths which end in the vertex Let this value for the vertex be For example if for some vertex there are good paths with end in it of lengths and correspondingly then will be Okay it is easy to see that the maximum intersection of two paths in the answer will be equal to the length of the diameter of the obtained tree But we can not take diameter of this tree and call it the answer because of the second constraint we need to find some diameter from to such that the sum is maximum possible How do we do that There is such an awesome and well known fact that the center of a tree belongs to all diameters of this tree Let s root the tree by the center of a tree if the length of the diameter is odd the center of a tree is an edge then let s root the tree by any end of this edge it does not matter There is one case when the length of the diameter is but it is pretty trivial to handle it Now our problem is to find two neighbors of the root of the new tree such that in their subtrees are vertices which form some diameter of this tree and the sum of values of these vertices is maximum possible Let s calculate the vertex with the maximum distance from a root and with the maximum possible for equals distances by simple for each neighbor of a root It can be done in and the last part is to find two maximums of this list it also can be done in or depends on implementation 
1352,Constraints lead us to some kind of dp solution is it usually called dp on broken profile Let will be the minimum price to get to th column and th row with selected is the previous cells inclusive from if then its exactly current column and two previous ones Transitions for submatrices and are straighforward just update mask with new ones and add to current value If the first cell of these is empty or is set in this position then you can go to or and if for free Finally you can go to with the price of Initial value can be in the first cells of the matrix The answer will be stored in some valid of However you can add extra empty columns and take the answer right from it will be of the same price Overall complexity 
1353,We will solve the problem by dynamic programming Let be the answer for substring Then we have two cases The first letter of the substring is deleted separately from the rest then The first letter of the substring is deleted alongside with some other letter both letters must be equal then 
1354,Let s set the root as Define as the lowest common ancestor of vertices and as the depth of vertex Obviously The answer we want to calculate is where represent all possible colorings of the tree We can enumerate the color For a fixed color we need to calculate Let Also denote as a predicate which is true iff Now our problem is how to maintain this formula while enumerating the color can be easily maintained For we can add to all vertices in path to for each existing vertex and when new vertex is added just calculate the sum of vertices on path from to minus the contribution of vertex because there are vertices in the path to and multiply it Similar operation can be used to handle the situation when some vertex disappears All of this can be done with HLD Overall it s 
1355,Suppose there is only one strip and we want to count the number of ways to paint it We can do it with some dynamic programming let dp i r 1 r 2 r 3 be the number of ways to paint first i cells of the strip so that r 1 denotes the result of the game if it starts in the last cell r 1 0 if the player that makes a turn from this state loses or r 1 1 if he wins r 2 the result if the game starts in the second to last and so on Then if we paint the next cell we can easily determine the result of the game starting in it using the values of r i and the set of possible moves if there is a value r i 0 such that we can move the chip i cells backwards from the cell we just painted then that cell is a winning one if the game starts in it the first player wins otherwise it is a losing one This dynamic programming works too slow since the strip can be very long but we can skip long uncolored segments converting the transitions of this dp into matrix vector multiplication each possible combination of values of r 1 r 2 r 3 can be encoded as a number from 0 to 7 and we may construct a 8 times 8 transition matrix T T i j will be equal to the number of ways to color one cell so that the previous values of r 1 r 2 r 3 have code i and the next values have code j To model painting k consecutive uncolored segments we may compute T k with fast exponentiation method Now we can solve the problem for one strip What changes if we try to apply the same method to solve the problem with many strips Unfortunately we can t analyze each cell as winning or losing now we need more information When solving a problem related to a combination of acyclic games we may use Sprague Grundy theory you can read about it here https cp algorithms com game theory sprague grundy nim html Instead of marking each cell as winning or losing we can analyze the Grundy value of each cell When considering a strip we should count the number of ways to color it so that its Grundy is exactly x we should do it for every possible value of x which can help us to solve the initial problem with the following dynamic programming z i j is the number of ways to color i first strips so that the Grundy value of their combination is exactly j The only thing that s left to consider is how do we count the number of ways to color a single strip so that its Grundy value is fixed We can to it by modifying the method described in the first paragraph let dp i r 1 r 2 r 3 be the number of ways to paint i first cells so that the Grundy value of the last cell is r 1 the value of the previous to last cell is r 2 and so on Since we have only 3 possible moves the Grundy values are limited to 3 and each possible combination of values of r 1 r 2 r 3 can be encoded as a number from 0 to 63 The transition matrix T that allows us to skip long uncolored segments will be a 64 times 64 one so if we will just exponentiate it every time we want to skip a segment we ll get TL but we can optimize it by precalculating T T 2 T 4 T 2 30 and using matrix vector multiplication instead of matrix matrix multiplication every time we skip an uncolored segment 
1356,Let s consider the sweep line approach by the value of the variable x the vertex i is active from the moment l i to the moment r i And we have to find vertices that are reachable in the graph of active vertices from the vertex 1 So we rephrased the problem as follows there are vertices that are active at some moments and we want to get some information about connectivity during each moment of time This is a standard offline dynamic connectivity problem which can be solved with a divide and conquer approach described here Now we are able to find the connectivity component of the 1 th vertex for each value of x It remains to understand how to combine answers for all values of x fast enough Let s try to visualize the components as vertices of a directed graph We assign a vertex to each component and when two components merge we add two directed edges from the new vertex to the vertices corresponding to the components and now we can use the reachability information in this graph Each vertex of the original graph corresponds to one of the sinks in this graph and sinks that correspond to the vertices of some component are reachable from the vertex corresponding to that component To restore all the vertex indices later we will mark all components containing the vertex 1 while we run our dynamic connectivity approach Then the vertex v of the original graph is included in the answer if the vertex representing the component containing only the vertex v is reachable from any of the marked vertices Now all you need to do is run DFS or BFS from all the marked vertices in the component graph 
1357,We can use dynamic programming to solve this problem but we need to choose the states we maintain very carefully One of the approaches might be the number of ways to connect the vertices between and to vertices or if and are already connected so there is no possibility to connect any vertex between and to some vertex outside What values should we access if we for example try to connect th vertex to some vertex To get everything connected we then have to connect vertices from interval to these two and vertices from to or and connections to from the second interval are difficult to handle We need to somehow get rid of them and the solution is to And vice versa if we connect something to then we choose the index of vertex to be connected with directly But that s not all we have to handle Suppose we have four vertices and is already connected to One of the possibilities to finish it is to connect to and to but if we process current dynamic programming as it is we will count it twice if we choose to connect to firstly or if we connect to To get rid of this problem we will use a flag that will denote whether we can connect anything to vertex and if we choose to pick the first connection from then we don t connect anything to So the solution is the number of ways to connect the vertices from interval to and and denotes if we can connect anything to How to calculate it If then there is nothing left to connect Otherwise set If then iterate on vertex we connect to and add Iterate on vertex we connect to and add The answer is if vertices are indexed Vertex is actually vertex so don t forget to update the matrix for it 
1358,Let s consider the following function minimum index such that there is a substring of string of length consisting of only characters and or and If this function has asymptotic then we can solve problem for Now let s precalculate two array and is equal the maximum integer such that substring consist only characters and is equal the maximum integer such that substring consist only characters and Also let s precalculate the arrays and of size contain all positions such that substring consist only characters and and or contain all positions such that substring consist only characters and and or After that let s solve problem for some Suppose that now we already processed first elements of If or then we increase the answer and change Otherwise we have to find the minimum element denote this element as in or such that If there is no such element then we found the final answer Otherwise let s increase answer and change and continue this algorithm 
1359,This problem can be solved using inclusion exclusion Let be the number of subsequences such that all elements of the subsequence are divisible by We can calculate which is the number of elements divisible by by factorizing all elements of the sequence and generating their divisors and Then we can apply the inclusion exclusion principle and get the resulting formula where is the M bius function 
1360,Let s count the number of pairs with multiple less than To get the number of not less pairs we should sumply subtract from the number of less pairs Let be the number of values in equal to and be the number of pairs from with the multiple equal to To calculate the values from we can use something like Eratosthenes sieve let s iterate over the first multiplier and the multiple of it and increment by the value After calculating the array we should calculate the array of its partial sums and find the number of less pairs in time 
1361,Each state of the string can be denoted as the set of characters we deleted from it and each such set can be represented as a bit binary mask where th bit is equal to if th character of the alphabet is already deleted and otherwise Let s call a mask if the string formed by this mask is not crisp Let s also say that a pair of characters forbids mask if is a pair of characters that should not be adjacent but they are adjacent in the string formed by mask If we somehow find all bad masks then the solution would be writing simple bitmask dp to find the best mask that is not bad and reachable from the initial mask the one having all bits set to So let s focus on finding all bad masks Obviously if some pair of characters forbids a mask then it s bad and vice versa Let s pick some pair of characters and find all masks forbidden by it we will do the same for every pair of characters that cannot be adjacent Let s check every occurence of in the initial string For each occurence we will find the closest occurence of to the right of it If there s no any or if there s another between them let s ignore the occurence of we have chosen and move to the next one Otherwise let s find all characters that occur at least once between the fixed occurences of and If all those characters are deleted then these occurences of and will be adjacent so pair forbids any mask that has bits representing and set to bits representing every character occuring in between to and all other bits to any values Let s mark all these masks as forbidden as follows we will write a recursive function that marks mask and every its submask that has bits and set to as forbidden This function should check if is not forbidden if not then mark it as forbidden iterate on the bit we may remove from and call recursively but only if is set to in mask and if and If we implement it in such a way then for each pair it will take operations to mark all masks forbidden by this pair of characters so overall complexity will be or depending on your implementation 
1362,Let s use as usual linearity of an expected value where is an indicator function and equal to iff Adilbek will be able to solve the th crossword How to calculate If then is always On the other hand if is always Otherwise we need to calculate the needed probability To calculate we can iterate over the number of crosswords among first ones which will require extra time Obviously if then we don t have enough time to solve the th crossword also Let s denote There are ways to choose crosswords with extra time among all variants So the final formula is following The only problem is the efficiency But we can find out several interesting properties At first The other one since then And this exactly the efficient way to transform to by multiplying and adding one coefficient we can transform the prefix sum of the th row to the prefix sum of the row And to reduce the length of the prefix sum we can just subtract unnecessary coefficients In result the total complexity is maybe with extra factor because of modular arithmetic 
1363,Let s suppose our graph is split into two graphs and the first graph contains the edges we delete before the mode shift the second graph contains the edges we delete after the mode shift It s quite obvious that the graph has an eulerian path The structure of is a bit harder to analyze but we can prove that it is always a star graph a vertex and some other vertices connected directly to it and the center of the star coincides with the last vertex in the eulerian path in To prove that is a star graph we can consider the second part of the path after the mode shift backward the last edge we traversed was deleted and the previous to last move could have been only along that edge The third last and the fourth last moves should have been along another edge connecting some vertex to the center of the star and so on Okay how do we find a way to split the graph into and Iterate on the center of the star let it be For the graph to contain an eulerian path it should have at most vertices with an odd degree Let s construct in such a way that we minimize the number of odd vertices in for each edge incident to we either move it to or in such a way that the resulting degree of the other vertex is even All other edges belong to If there is an eulerian path in that ends in we are done Otherwise we should iterate on some edge adjacent to and change its status in order to check if can have an eulerian path after that We can t flip two edges because flipping two edges increases the number of odd vertices in at least by if it is already or greater the eulerian path won t exist and if it s then flipping two edges creates two odd vertices none of which is so eulerian path can t end in After flipping each edge we try to find an eulerian path in once again and flip the edge back After checking the vertex as the center of the star we return all adjacent edges to and move to the next vertex The whole algorithm requires checking for the existence of the eulerian path times so it should work in or depending on the implementation Fun fact initially I wanted to give a harder version of a problem with that would require some sort of dynamic connectivity to check for an eulerian path fast but when I started coding it I realized that implementation there was a bit painful so I ve decided to drop the constraints to allow quadratic solutions 
1364,Let s use dynamic programming to solve this problem We will start with a single biconnected component consisting of vertex and connect other vertices to it So the state of our dynamic programming will be a of vertices that are in the same biconnected component with How can we extend a biconnected component in such a way that some other vertices are added into it but it is still biconnected We will add a path possibly cyclic that starts in some vertex belonging to the goes through some vertices and ends in some vertex belonging to the possibly If for every triple we precalculate some path that starts in goes through vertices from and ends in and does not contain neither nor then we can solve the problem in there will be states for every state we will iterate on two vertices and belonging to the and the number of possible pairs of non intersecting masks and is The only thing that s left is precalculating the paths for triples That can be done with auxiliary dynamic programming which will denote whether such a path exists For every edge of the original graph is true and we can go from to some state where will contain all vertices from and vertex and we should ensure that there is an edge in the graph and the didn t contain vertex earlier We should also somehow be able to restore the paths from this dp and we also should be careful not to choose the same edge twice for example if we start a path by edge we should not use the same edge to return to both these things can be done for example by storing next to last vertex in the path 
1365,The task is obviously solved by dynamic programming so our first reaction should be to start looking for meaningful states for it Obviously one of the states is the vertex which subtree we are processing We can choose the root for the tree arbitrarily let it be vertex What can be the other helpful state Consider the method to find the diameter of the subtree of vertex The diameter can be one of the following paths either the longest path that is completely in some subtree of or the concatenation of the longest paths that start in vertex and end in different subtrees The diameter is the longest path Thus the diameter being less than or equal to means that all paths should have length less than or equal to If we can guarantee that no path that is completely in some subtree of have length greater than then we will only have to worry about not concatenating long paths from different subtrees Phrase it the other way around if we never concatenate the paths from the different subtrees in such a way that their total length is greater than then no diameter will be greater than Thus we can attempt to have the number of ways to cut some edges in the subtree of in such a way that there is no path of length greater than and the longest path starting at vertex has length Now for the transitions For the simplicity let vertex have exactly two children It s not too hard to merge their s Iterate over the length of the first child the length of the second child If then you can concatenate their longest paths and the longest path for will be of length You can also cut either of the edges from to the first child or to the second child The approach is good however it s not clear how to make it work on a larger number of children Also the complexity sounds pretty bad Instead of merging children to each other let s merge each child to the of one by one can store the current maximum length over all processed children When processing a new child you can choose to cut or not to cut the edge to it So you can iterate over the current longest path from and the longest path from that child So far the only way to estimate the complexity is to say that each child has to merge its dp to the parent in thus making the algorithm That s obviously too slow The trick that makes the solution fast is to iterate not to but to the height of the subtree of and the subtree of a child Surely that is allowed since the path just can t grow longer than that value Consider the even worse option not the height but the size of the subtree It s easy to see that the size is always greater or equal than the height Interpret the merge the following way enumerate the vertices inside all the subtrees of the processed children and the vertices inside the subtree of the new child Iterating up to the size of the subtree is the same number of moves as going over the vertices in it The merge will go over all the pairs of vertices such that the first vertex of the pair is in the first set and the second vertex is in the second set Thus each pair of vertices of the tree will be processed exactly once in lca of these vertices There are such pairs thus such s work in Overall complexity 
1366,For the purpose of solving the task let s choose some root in the tree and introduce another operation to the tree add to all vertices that are in the subtree of the given vertex and on the distance from For example if it s itself or if then it s all children of Let s be the parent of vertex and so on So how to perform this operation Instead of adding to all vertices in the subtree we can add only to the vertex And when we need to get the answer for some vertex we will get it from Of course since there are different s we ll create different arrays for each possible So the answer for the vertex will be equal to Now let s discuss how to use the introduced operation to perform the given one We can make the given operation using ours in the following way Let s find using any standard algorithm binary lifting for example Let s split all affected vertices in three groups subtrees of path inclusive exclusive subtrees of path and subtrees of path Note that in such way all affected vertices belong to at least one group Let s look at group of path The lowest vertices are on distance from the next level are on distance from the next level are on distance from and so on The last level we ll consider in this group is the vertices in the subtree of the on distance from it In such a way all we need to do is add to all on the path from The group of the path is handled in the same way What s left It s vertices in subtree of on distances in subtree of on distances in subtree of on distances in subtree of on distance Note that vertices in subtree of on distance are included in vertices in subtree of on distance Analogically vertices on distance from are included in vertices on distance from Moreover vertices on distance from are included in from that are included in from and so on In other words all we need to proccess are vertices in subtree of on distances and in subtree of on distances and in subtree of on distances and In total it s at most operations add to some vertex As a result all we need to do is add on path from to some ancestor of add in some vertex can be done as operation on path ask value in some vertex We can do all of these operations in using Fenwick tree BIT on s and s we can get from binary lifting So the first statement operation will work in time and the second one also in In total complexity is time and space P S the second operation can be further optimized to but it s not really necessary 
1367,Several observations Generally we have two types of operations divide and either or If then in one division we ll get element so we can just keep track of the total possible number of these operations as If then if we decide to split whole to s then we get elements but in operations i e in one division we ll get elements So it s preferably to fully split than Also the less the more profitable each division As a result let s act greedy let s say we need more elements Let s iterate over in the increasing order If then let s fully split in in operations decrease increase a counter of operations and increase accordingly If then the situation becomes complicated We can either don t touch and try to use preserved operations with small if or split in two s Now we spent one operation and get two If then we don t need one of and can split further only one If then it s optimal to fully split one of and proceed further with only one and recalculated and In both cases we can solve optimal splitting of recursively in the same manner as Since in each step we lower then we need to check only cases per each query Note that we can treat situation in packs for several with equal so the first part also works in The resulting complexity is per query 
1368,In this problem we can use small to large merging trick also known as DSU on tree when building a depth array for a vertex we firstly build depth arrays recursively for its children then pull them upwards and merge them with small to large technique In different blogs on this technique it was mentioned that this will require operations with structures we use to maintain depth arrays overall However in this problem we may prove a better estimate it will require operations That s because the size of depth array if considering only non zero elements for a vertex is equal to the height of its subtree not to the number of vertices in it To prove that the number of operations is one can use the intuitive fact that when we merge two depth arrays all elements of the smaller array are destroyed in the process so if the size of smaller array is then we require operations to destroy elements The main problem is that we sometimes need to pull our depth arrays upwards thus inserting a to the beginning of the array Standard arrays don t support this operation so we need to either use something like and the complexity will be or keep the depth arrays in reversed order and handle them using and then complexity will be 
1369,The solution to this problem uses cyclic decomposition of permutations A cyclic decomposition of a permutation is formulated as follows you treat a permutation as a directed graph on vertices where each vertex has an outgoing arc This graph consists of several cycles and the properties of this graph can be helpful when solving permutation based problems First of all how does the cyclic decomposition of a sorted permutation look Every vertex belongs to its own cycle formed by a self loop going from that vertex to itself We will try to bring the cyclic decompositions of the given permutations to this form What does an operation with integer do to the cyclic decomposition of the permutation If is in its own separate cycle the operation does nothing so we swap an element with itself Otherwise let s suppose that is the element before in the same cycle and is the element after in the same cycle Note that this can be the same element When we apply an operation on we swap with so after the operation and So leaves the cycle and forms its separate cycle and becomes the next vertex in the cycle after So using the operation we exclude the vertex from the cycle Suppose we want to sort one permutation Then each cycle having length must be broken down for a cycle of length we need to exclude vertices from it to break it down The vertex we don t touch can be any vertex from the cycle and all other vertices from the cycle will be extracted using one operation directed at them It s easy to see now that if we want to sort a permutation we don t need to apply the same operation twice and the order of operations does not matter Okay then what about sorting two permutations in parallel Let s change the problem a bit instead of calculating the minimum number of operations we will try to maximize the number of integers such that we don t perform operations with them So an integer can be left untouched if it is the only untouched vertex in its cycles in both permutations Can you see where this is going Suppose we want to leave the vertex untouched It means that in its cycles in both permutations every other vertex has to be extracted with an operation So if two cycles from different permutations have a vertex in common we can leave this vertex untouched as long as there are no other vertices left untouched in both of these cycles Let s build a bipartite graph where each vertex in the left part represents a cycle in the first permutation and each vertex in the right part represents a cycle in the second permutation We will treat each integer as an edge between two respective vertices in the bipartite graph If the edge corresponding to is used is left untouched we cannot use any edges incident to the same vertex in left or right part So maximizing the number of untouched numbers is actually the same as finding the maximum matching in this bipartite graph After you find the maximum matching restoring the actual answer is easy Remember that the edges saturated by the matching correspond to the integers we don t touch with our operations the order of operations does not matter and each integer has to be used in an operation only once So the actual answer is the set of all integers without those which correspond to the edges from the matching This solution runs in even with a straightforward implementation of bipartite matching since the bipartite graph has at most vertices and edges 
1370,First of all sort the fishermen so it is easier to consider them in ascending order The key observation that allows us to solve the problem is the following there will be an increasing sequence of happy fishermen and all other fishermen will be unhappy Consider the fisherman which belongs to the increasing sequence Let s analyze which fisherman will be next to it in the order It is either a fisherman that will be happy or a fisherman that will be sad In the first case the fish caught by this fisherman must have a size of at least in the second case at most The first case will be considered later For the second case if we know the number of fishermen that were already placed in the order we know that all of them except the th one belong to the sad category that is the fish of every already placed fisherman except for the th one is at least two times smaller than the fish of the th fisherman So if we have already placed fishermen the last happy fisherman was the th one and we want to place a sad fisherman then the number of ways to choose this sad fisherman is exactly where is the number of fishermen such that If we can handle the first case this observation will allow us to solve the problem with dynamic programming Let be the number of ways to choose first fishermen in the order so that the th fisherman is the last happy one The case when the next fisherman is sad can be handled with a transition to the state don t forget to multiply by the number of ways to choose the next sad fisherman as described earlier What about the case when the next fisherman is happy We should iterate on the fisherman such that and transition from to but this part works in To get an solution we have to speed it up with prefix sums or something like that 
1371,Let s look at where It can be proven that there always exists such pair and that and Brief proof is following calculate then let and Obviously such will make from and from if And since and since As we can see divides so if we will iterate over all pairs where there will be pairs in total Let s fix value of Then from one side but from the other side since then Anyway all valid form a segment possibly empty segment And we need to find any that divides any from the segment and doesn t exceed Obviously it s optimally to find the minimum possible such and just check inequality We can find such for a fixed using for example built in in a set with all divisors for all valid To maintain this set we can note that simillary So we can move valid segment s ends as two pointers Each pair will be added and erased from the segment exactly once That s why the total complexity of maintaining the set of divisors as well as the total complexity of queries for each will be equal to All pairs and can be precalculated in using the sieve like algorithm 
1372,As usual with tasks on an expected value let s denote as indicator function if and otherwise Then we can note that Now we can make some transformations Now we d like to make some casework if and aren t consecutive then and are independent that s why if then need further investigation For the simplicity let s transform segment to by increasing Let s denote as the probability that and Let s denote In result The final observation is the following is equal to the probability that and and can be calculated by inclusion exclusion principle where In result and can be calculated in time 
1373,This problem is a typical problem for some suffix data structure Four competitors who solved this problem during the contest used suffix automaton and one competitor used suffix tree My own solution used suffix tree so I ll describe solution with tree I think it s simple except of the building of the tree Let s build the new string by concatenation of all strings from input separating them by different separators The number of separators is so the alphabet is also So we should use map int int to store the tree and the complexity is increased by Let s build the suffix tree for the new string Let s match all the separators to the strings from the left of the separator Let s run dfs on the suffix tree that doesn t move over separators and returns the sum of the costs of the strings matched to the separators from the subtree of the current vertex Easy to see that we should simply update the answer by the product of the depth of the current vertex and the sum in the subtree of the current vertex 
1374,Let s try to analyze how the size of can be calculated Let s connect points having same coordinates to each other and do the same for points having same coordinates Then we can solve the problem for each component separatedly after the algorithm is run the component will contain the points such that at least one point in the component has coordinate equal to and at least one point in the component maybe same maybe another one has coordinate equal to So the answer for each component is the product of the number of distinct coordinates and the number of distinct coordinates in the component Now we can process insertion queries there are many ways to do it but in my opinion the easiest way to handle them is to create a separate vertex for every coordinate and coordinate and process each point as an edge connecting vertices corresponding to its coordinates edges can be easily added by using DSU with rank heuristics To handle removals we will get rid of them completely Transform the input into a set of events some point exists from query to query Then build a segment tree over queries and break each event into segments with this segment tree Then we can initialize a DSU and run DFS on the vertices of the segment tree to get answers for all queries When we enter some node we add all edges that exist on the corresponding segment into DSU If we are in a leaf node we may compute the for the corresponding query And when we leave a vertex we can rollback all changes we made when we entered it One important moment is that using path compression in DSU here is meaningless since it doesn t work with rollbacks well This solution works in 
1375,If was not really large then we could run the following dynamic programming solution Let be the number of ways to process first characters of so that the suffix of the subsequence of length matches the prefix of with length This is not really different from a usual approach with dynamic programming on KMP constraints in this problem allow us to build KMP automaton naively without the help of any fast prefix function algorithm However the length of is really large Let s consider the traversions we make in dynamic programming Let be the KMP automaton matrix that is let be the new value of prefix function if the previous value was and we added a character Then from the state if the following character is we make traversions to and to This actually leads to rewriting traversions as a matrix Let be the vector such that its th element is equal to Then advancing from to if th character is can be represented as follows where can be filled with the help of KMP automaton for every we add to and also add to The same approach can be used to form matrix that denotes adding character and if we want to add the string we can actually represent its matrix as This matrix multiplication approach will run in but the problem is that it doesn t give us the answer To obtain it we may add an auxiliary state to the dynamic programming add to it each time we traverse to state multiply it by each time we add a character and rewrite it into matrix form Model solution https pastebin com ctSVxmnD
1376,Suppose we have fixed some order of fishermen and calculated the values of Then we have the following constraints on all values of are pairwise distinct for every divides Not every possible array meeting these constraints can be achieved with some order of fishermen but we can show that if we choose an array with the among the arrays meeting these two constraints there exists an ordering of fishermen which yields this array The proof is simple suppose the ordering of fishermen is the following one the first fisherman is the one with minimum the second one the one with the second minimum and so on It s obvious that if we generate the values of according to this order they won t be greater than the values in the array we have chosen And if some value is less than the value in the chosen array it means that we haven t chosen the array with the minimum possible sum So we can rephrase the problem as the following one for each choose the value of so that it is divisible by all are distinct and their sum is minimized Using the pigeonhole principle we can show that for every we need to consider only the values of among So we can formulate the problem as an instance of the weighted bipartite matching build a graph with two parts where the left part contains nodes representing the values of the right part represents the values of the form where and there exists an edge between a vertex in the left part representing the number and a vertex in the right part representing the number with cost if and only if for some integer Okay now we need to solve this weighted matching problem but how The number of vertices is and the number of edges is as well so mincost flow will run in or which is too much Instead we can notice that the cost of the edges incident to the same vertex in the right part is the same so we can swap the parts of the graph sort the vertices of the new left part representing the numbers according to their costs and run the classical Kuhn s algorithm in sorted order Kuhn s algorithm in its original implementation will always match a vertex if it is possible so it obtains the minimum total cost for the matching if we do it in sorted order But this is still What should we do Well there are some implementations of Kuhn s algorithm which can run on graphs of size about sometimes even Why can t we use one of these Unfortunately For example greedy initialization of matching won t work So we need to choose optimizations carefully The model solution uses the following optimization of Kuhn s algorithm With this optimization Kuhn s algorithm works in where is the size of the maximum matching is the number of edges and is the number of vertices So this results in a solution with complexity of I think it s possible to show that some other optimizations of Kuhn can also work but the one I described is enough 
1377,The answer is if and only if the sum of values is not equal to Writing some number on edge does not change the total sum and the goal of the problem is to make in each vertex thus getting in total The algorithm is simple you get an arbitrary spanning tree with dfs or dsu output the difference between sums of values of subtrees can be calculated with dfs for edges in this tree and for the rest of edges Let s take an arbitrary correct answer If is has some cycle in graph of edges with non zero numbers on them then you can remove it For example select any edge on it and subtract the number on it from all the edges of the cycle This doesn t break the correctness of the answer as you change both in and out flows for each vertex by the same value Now that edge has This way any answer can be transformed to tree And for any edge on tree we want to tranfer excess water units from the larger subtree to the smaller Overall complexity 
1378,This problem can be solved with different suffix structures Model solution uses suffix array First of all let s reverse so for we will count only occurences that start in non forbidden indices Then if there is at least one non forbidden index there are two cases then the best option to choose is to use a suffix which begins in the leftmost after reversing non forbidden index then is the longest common prefix of some two suffixes of Let s build a suffix array then calculate the LCP array Then recall the fact that a LCP of two suffixes is the minimum on the segment of LCP array between these two suffixes so we can use a common stack algorithm that will for each LCP find the segment of suffixes such that this LCP is a prefix of these suffixes to do this for each element of LCP array we find the largest segment such that this element is minimal on that segment and then we can use prefix sums to find the number of non forbidden suffixes such that chosen LCP is a prefix of this suffix and so calculate easily for each LCP 
1379,The problem directly tells you do solve some kind of Dynamic Connectivity Problem You could use the online approach with Link Cut Tree if you d had its implementation beforehand There is also a nice modification to the solution of the offline version of DCP check out the comment I d tell the solution which is probably the easiest to come up with and to code Let s recall the sqrt optimization method of solving DCP Process blocks of queries of size one at a time Split the edges into two groups The edges which were added on queries before the block and aren t touched by the queries in the block the edges modified by the queries in the block The first type of edges can be added to the graph before the block processing starts You can use DSU for that The second type contains no more than edges Maintain the list of those of them which exist in the graph On each ask query add them to graph then delete them This can be done explicitly by doing DFS only over these edges and the vertices which correspond to the connected components on the edges of the first type Implicitly doing DSU merges for these edges and rolling them back is a viable option as well costs extra log factor but has lower constant It s easy to see that it isn t hard to modify this solution to our problem Let s define the edges of the first type more generally the edges which were added on queries before the block and touched by the queries in the block So neither from the add query nor could be of the first type Now there might be edges of the second type in the list However that doesn t make the complexity any worse Process block the same way rebuild the DSU with the edges of the first type every queries The overall complexity can be if you use DFS or if you use DSU notice how the rebuild is and the query is and set the size of the block so that these parts are about the same 
1380,Easy to see that only the numbers of the form and for different prime have exactly four positive divisors We can easily count the numbers of the form in where is the number from the problem statement Now let and be the number of primes from to Let s iterate over all the values Easy to see that So for fixed we should increase the answer by the value So the task is ot to find the number of primes not exceeding for all Denote the th prime number Denote the number of such that and all prime divisors of are at least note that 1 is counted in all since the set of its prime divisors is empty satisfy a simple recurrence since 2 hence Let be the smallest prime greater than Then by definition the first summand accounts for all the primes not less than If we evaluate the recurrence straightforwardly all the reachable states will be of the form We can also note that if and are both greater than then Thus for each it makes sense to keep only values of Instead of evaluating all DP states straightforwardly we perform a two step process Choose Run recursive evaluation of If we want to compute a state with memorize the query count the numbers not exceeding with all prime divisors at least Answer all the queries off line compute the sieve for numbers up to then sort all numbers by the smallest prime divisor Now all queries can be answered using RSQ structure Store all the answers globally Run recurisive evaluation of yet again If we want to compute a state with then we must have preprocessed a query for this state so take it from the global set of answers The performance of this approach relies heavily on the number of queries we have to preprocess Statement Proof Each state we have to preprocess is obtained by following a transition from some greater state It follows that doesn t exceed the total number of states for The preprocessing of queries can be done in and it is the heaviest part of the computation Choosing optimal we obtain the complexity 
1381,Let s maintain the set of not eaten mosquitoes for example with set in C or with TreeSet in Java and process mosquitoes in order of their landing Also we will maintain the set of segments ai bi where ai is the position of the i th frog and bi ai li where li is the current length of the tongue of the i th frog Let the current mosquito landed in the position x Let s choose segment ai bi with minimal ai such that bi x If the value ai x we found the frog that will eat mosquito Otherwise the current mosquito will not be eaten and we should add it to our set If the i th frog will eat mosquito then it s tongue length will be increased by the size of mosquito and we should update segment ai bi After that we should choose the nearest mosquito to the right the from frog and if it s possible eat that mosquito by the i th frog this can be done with lower bound in C Possibly we should eat several mosquitoes so we should repeat this process several times Segments ai bi we can store in segment tree by position ai and value bi Now to find segment we need we can do binary search by the value of ai and check the maximum bi value on the prefix to be at least x This will work in O nlog2n time We can improve this solution Let s go down in segment tree in the following manner if the maximum value bi in the left subtree of segment tree is at least x then we will go to the left otherwise we will go to the right Complexity O n m log n m 
1382,First of all let s try to solve the following problem given a DAG cover its vertices with the minimum number of vertex disjoint paths Solving this problem allows us to calculate the number of goblins that can pillage all of the halls when the tunnel network is fixed This problem is a fairly classical one since the number of vertices in each path is greater than the number of arcs in it exactly by we should take the maximum possible number of arcs into our paths So we can reduce this problem to bipartite maximum matching build a bipartite graph where each part consists of vertices and for every directed arc in the original graph connect the vertex of the left part to the vertex in the right part of the bipartite graph The maximum matching in this graph allows us to pick the maximum number of arcs into the paths of the original problem the matching ensures that each vertex has at most one chosen ingoing arc and at most one chosen outgoing arc so the paths are vertex disjoint Okay now we at least can check if the goblin wave can pillage all of the halls Let s say that the minimum number of goblins required to pillage the original city is Obviously in order to pass the th wave and waves after it we have to increase this number In one minute Monocarp can block all of the tunnels leading to some hall or out of some hall and in terms of our reduction to the bipartite matching problem it means that we remove all edges connected to some vertex of the bipartite graph Obviously in one minute we can increase by at most since is equal to the difference between and the maximum matching size It turns out that it s always possible to choose a vertex that belongs to all maximum matchings in the bipartite graph note that it doesn t work in non bipartite graphs but in our problem it doesn t matter For the proof of this fact you can check the last paragraph of the editorial So each minute Monocarp prepares for a wave he increases the maximum number of goblins he can repel by Now the solution splits into two much easier parts The first part is finding a sequence in which Monocarp blocks the tunnels so that each his action reduces the size of the maximum matching by Since the constraints are small even a naive approach in always iterate on the vertex we try to remove from the graph and check that removing it is possible by running Kuhn s algorithm is fast enough The second part is to choose when Monocarp calls waves of goblins and when he prepares for them this can be easily done with dynamic programming let be the maximum Monocarp s score if he has already passed waves and the current size of the maximum matching is The most naive implementation of this dynamic programming runs in so the whole solution works in We can improve it to though it is not needed under these constraints Instead of finding the vertices to remove from the bipartite graph one by one let s find all of them at once in Recall that the size of maximum matching in a bipartite graph is equal to the size of its minimum vertex cover and the minimum vertex cover can be reconstructed after finding the maximum matching If we remove a vertex from the minimum vertex cover the size of the minimum vertex cover of the remaining graph is reduced by so the size of the maximum matching is reduced by as well It means that we can always choose to remove a vertex from the minimum vertex cover we found By the way it also proves that it s always possible to remove a vertex from a bipartite graph so the size of the maximum matching decreases by obviously if it s not already 
1383,The naive solution is dynamic programming let be the probability that the first problems don t have any inversions and the th one got accepted solutions Let s somehow speed it up For convenience I will modify the variable denoting the maximum number of accepted solutions for each problem and I will also reverse the problem order so that we don t want the number of solutions to decrease from problem to problem We know that if and otherwise Let s divide the whole segment between and into segments with the values of and and analyse the behavior of values on each such segment Let If we consider the behavior of on some segment we got we can prove by induction that it is a polynomial of degree not exceeding All that is left is to carefully calculate and maintain these polynomials on segments The main thing we will use to calculate the polynomials is interpolation To transition from to we will consider each segment separately calculate the first several values of on each segment we need to calculate the sum fast if is a polynomial this can also be done with interpolation and then interpolate it on the whole segment This is actually slow we have to interpolate at least polynomials and not easy to write Let s consider a better solution We will use combinatoric approach instead of calculating probabilities we will count all the non descending sequences such that and divide it by the number of all sequences without the non descending condition that is just Let s again divide into segments using the points and enumerate these segments from left to right If there are two neighboring values and they either belong to the same segment or the segment belongs to is to the right of the segment belongs to We could try to write the following dynamic programming solution is the number of non descending prefixes of the sequence such that there are elements in the prefix and the last one belongs to segment It s easy to model transitions from to where but we don t know how to model the transition to Let s get rid of them altogether We will introduce an additional constraint in our dynamic programming is the number of prefixes of the sequence of length The transitions in this dynamic programming are different we iterate on the number of elements belonging to the next segment and transition into if possible Calculating the number of ways to take elements from an interval in sorted order can be reduced to calculating the number of ways to compose as the sum of non negative summands order matters We should be able to calculate binomial coefficients with fairly large and not so large but that s not really hard if we use the formula 
1384,Firstly let s prove that a good graph has one important property any two of its simple cycles intersect by at most one vertex i e there is no edge that belongs to more than one simple cycle cactus definition yeah Let s prove it by showing that if two simple cycles of weight k 0 intersects by edges then they will induce a simple cycle of weight neq k There are two cases if cycles intersect by a single path then we can create a new cycle by merging parts of cycles excluding the intersecting path it will be simple and will have weight k oplus k 0 neq k if cycles intersect by more than one path we can do the next transformation suppose the common paths are u 1 v 1 u 2 v 2 dots and they are ordered in the way how they lie on the first cycle Let s create a third cycle using two paths from v 1 to u 2 from the first cycle and from the second cycle It s easy to see that the third cycle is simple and more over it has only one common path with the second cycle So it s either the third cycle has weight not equal to k or the case 1 Okay let s analyze the edges we try to add Let s divide all edges in two types edges and all other edges we will name them edges Let s name an edge as a edge if it connects two different components at a moment when we are trying to add it in the graph It s obvious that we will add all tree edges in the graph since they can t make it bad since they don t induce new cycles But there is a more interesting observation when we try to add a cycle edge u v it should induce an only one simple cycle where all other edges are tree edges and these tree edges can t be used in any other cycle It induces at least one all tree edge cycle since u and v are already connected It can t induce more than one all tree edge cycle since it contradicts with definition and if it induces a cycle with some other cycle edge then we can replace that cycle edge with its own tree edge path our cycle will become all tree edge cycle but it will use already used tree edges In other words it s enough to consider only one all tree edge cycle induced by any cycle edge The final trick is to calculate the answer in two steps at the first step we will find only tree edges using DSU that will form a spanning forest in our graph The second step is for each cycle edge u v to calculate the operatorname XOR X on a path between u and v in our spanning forest check that X oplus text edge weight 1 and check that none of edges on the path from u to v are used in other cycle Calculating X is easy if we precalculate for each vertex v the operatorname XOR on path from v to root mathit xr v then X mathit xr u oplus mathit xr v Checking that none of the edges are used on the path from u to v is a bit tricky if we mark an edge by adding 1 to it then we should be able to take a sum on path and add on path There are structures that are capable of it like HLD and other but let s look closely Note that we mark each tree edge at most once so we can manually add 1 to each edge and only asking sum on path should be fast In other words we need a data structure DS that can add value at edge and take the sum on path and such DS is a Fenwick tree BIT built on Euler tour of tree it can add value at edge and ask a sum on path from v to root So we need to find LCA as well since sum of path u v is equal to sum u sum v 2 cdot sum LCA u v As a result complexity is O n m log n with quite a low constant from LCA and BIT 
1385,This problem can be solved using dynamic programming with broken profile First of all we have to make the number of rows not larger than if it is larger then we can just rotate the given matrix Let s fill the matrix from left to right and in each column from top to bottom Let be the number of ways to achieve the following situation we now want to fill cell with index denotes the rows which are already protected in this column so there is a wall in this row or there is a guard to the left is a flag that denotes if current cell is protected by some guard above and is a flag that denotes if there was a cell that was not protected When advancing from one column to another we have to change the mask so we update the rows that are currently protected The rows such that in the previous column there was a wall in this row become un protected and the rows such that there is a wall in current column in this row become protected And of course becomes zero When we place a guard we set to one and make the corresponding row protected And when we are at the wall we have to set to zero so the guard from above doesn t protect next cell The answer is the sum of all values 
1386,Let s calculate the answer as the difference between sum of maxima and sum of minima over all paths These sums can be found by the following approach Consider the sum of maxima Let s sort all vertices in ascending order of values of if two vertices have equal values their order doesn t matter This order has an important property that we can use for every path the maximum on this path is written on the vertex that has the greatest position in sorted order This allows us to do the following Let s denote as a tree rooted at vertex that is formed by the set of such vertices that are directly connected to or some other vertex from the set and have Consider the vertices that are connected to in this tree Let s denote them as the order doesn t matter and denote by the size of the subtree of in the tree Let s try to calculate the number of paths going through in this tree paths that have as its endpoint paths connecting a vertex from subtree of to a vertex from subtree of So vertex adds the sum of these values multiplied by to the sum of maxima To calculate these sums we will use the following algorithm Initialize a DSU disjoint set union making a set for each vertex Process the vertices in sorted order When we process some vertex find all its already processed neighbours they will be in For every neighbour denote the size of its set in DSU as Then calculate the number of paths going through using aforementioned formulas to do it in linear time use partial sums Add this number multiplied by to the sum of maxima and merge with in DSU To calculate the sum of minima you can do the same while processing vertices in reversed order Time complexity of this solution is 
1387,We will use the Contribution to the Sum technique to solve this problem for every integer from to let s calculate the number of ways to choose the operators so it belongs to the result and add all of the results For a fixed integer the number of ways to choose the operators so that belongs to the result can be done as follows let be the number of ways to choose the first operators so that after applying them the resulting set contains if and does not contain if The transitions from to depend on whether the number belongs to the segment Obviously this is too slow if we compute the dynamic programming from scratch for every integer Instead we can notice that the transitions from to are linear combinations both and are linear combinations of and with coefficients depending on whether the element belongs to the set or not So transitioning from to can be written in terms of multiplying by a matrix Let s build a segment tree where each vertex stores a transition matrix and operations are calculate the product of matrices on a segment and replace a matrix at some index We can build a sequence of these transition matrices for and store them in the segment tree for this sequence of transition matrices will change only in positions such that either belongs to and does not belong to it or vice versa So we can go from to by replacing these transition matrices in the segment tree For the only changes from are in positions such that either belongs to and does not belong to it or vice versa and we can replace the matrices in these positions as well In total there will be only such replacements so we solve the problem in where is the constraint on the numbers belonging to the sets 
1388,Let s break the problem into four general cases Case 1 Inversions between two unknown numbers Each pair of numbers can either be or inversion or not and the number of permutations for both cases is the same Thus the expected value of that is Case 2 and 3 Inversions between the known and unknown number Let s check the case with left number being unknown and right being known The opposite will be done similarly For each known number calculate the number of unknowns to the left of it and the total number of unknowns greater than it Then you ll need to put a greater number out of all possible to make an inversion Add to the answer Case 4 Inversions between two known numbers Just calculate that number ignoring all and add it to answer Overall complexity for the lase case all others are done in 
1389,Yes authors also implemented hashes Note that if substrings and are isomophic then position of first encounter of some character in must be position of first encounter of some character in More over if we sort all positions for all distict characters in and sort all positions for then must be equal for any This observation gives us fact that So to check isomorphism of and we need check for each that positions of all encounters of character equal to posistions of all encounters of character To do that we can generate for each character boolean array with checked positions of its encounter and calculate prefix hashes on this arrays Also we need precalculate order of first encounters for each suffix of string To do it fast note that in transition from to only can change its relative order Result complexity is with quite big constant from hashing 
1390,Let s observe what does the maximum weight of some fixed length path look like Among the edges on that path the last one has the maximum weight If it wasn t then the better total weight could be achieved by choosing a bigger weight edge earlier and going back and forth on it for the same number of steps It actually helps us arrive to a conclusion that all optimal paths look like that some simple path to an edge and then back and forth movement on it Any simple path in the graph has its length at most Let s separate the queries into two parts will be handled in a straightforward manner Let be the maximum weight of a path that ends in and has exactly edges in it That s pretty easy to calculate in You can also think of this as some kind of Ford Bellman algorithm let on the th step be the maximum weight of the path to of length Iterate over all edges and try to update and for each edge that s what I do in my solution if you refer to it Now for There was a very common assumption that after a bit more steps some edge will become the most optimal and will stay the most optimal until the end of time However that a bit cut off is in fact too high to rely on it must be somewhere around So the best path of length exactly ending in each vertex is Let the maximum weight adjacent edge to vertex be So the path of length will have weight Treat it like a line with coefficients and How do determine which line is the best for some Sure experienced participants will immediately answer convex hull Build a lower envelope of the convex hull of these lines If was a little smaller than we could query with binary search for each the same how convex hull is usually used We have to examine the hull further Each line in it becomes the best in some point then stays the best for some interval and then never appears the best again What are these line changing points Well it s just the intersection point of the adjacent lines in the hull So having these points and the parameters of the line we can calculate its contribution to the answer with a sum of arithmetic progression formula There were just lines in the hull so you can build the hull in any complexity I think I saw up to performances in the participants codes There is a cool solution that involves some kind of Divide Conquer on these lines I personally thought of it in a sense of traversing a Li Chao tree without actually building it If anyone wants to explain this solution feel free to do it in comments Overall complexity 
1391,Notice that increasing only increases the range of the jump distances in both directions So every rock that was reachable with some will be reachable with as well Thus let s try to find the smallest possible value of to reach each rock Let s imagine this problem as a graph one and consider the following algorithm For every pair of rocks make an edge of weight equal to the smallest required to jump from one to another For some rocks and that is How to check the reachability with these edges Well if the jump range value is then there should exist of path by edges of weight no more than So we can start with an empty graph first add the edges of the smallest weight then the second smallest and so on The first time a pair of vertices becomes reachable from each other is the minimum such weight An experienced reader can notice the resemblance with the Kruskal algorithm for finding the minimum spanning tree After the spanning tree is constructed the minimum is the maximum value on a path between the vertices The issue is that Kruskal requires to construct an MST for a complete graph Prim can make it which is still too much Thus the solution is to resort to Boruvka On each iteration of Boruvka we have to find the smallest weight edge from each component to some other one We can solve it the following way Maintain a sorted set of rocks coordinates The smallest weight edges are the ones that are the closest to distance from each rock So we could query a lower bound of and on each rock to find them Don t forget to look at the both sides of the lower bound result However the issue is that we can bump into the rocks from the same component Thus let s process components one by one When processing a component first remove all its vertices from the set Then query the edges for each vertex Then add the vertices back This way only the edges to other components will be considered That makes it an construction with one log from the number of Boruvka iterations and another from finding the edges That should pass if coded carefully enough and that is basically the intended solution Still there exists a construction That will require a algorithm for finding the edges So there are four possible edges for each rock the closest to from the left from the right and the same for Let s consider only the first case the rest will be similar The coordinates are sorted beforehand and we are processing the rocks from left to right We can maintain a pointer to the latest encountered rock to the left of The issue with it being from the same component is still there Let s go around it by also storing the second latest encountered rock such that it s from the different component from the actual latest one This can be updated in the same manner one calculates the second maximum of the array Now you just have to do that for all four cases This two pointers approach makes it for each iteration thus making the construction Since the queries ask for a path from some fixed vertex to a certain vertex it s the same as calculating the maximum edge on a path from the root of the tree to each vertex Can be done with a simple dfs The only thing left is to check if the minimum possible is less than or equal to the one provided in the query Overall complexity or 
1392,Let s look at suprefix of fixed substring we can t find its maximal length via binary search because this function isn t monotone in general case But by fixing not the left border but the center of the prefix we also fix the center of the corresponding suffix center of a prefix in position is tied with the center of the suffix in position and more important function becomes monotone So solution is next iterate over all valid centers of prefix and try to binary search maximal length of such substring that its center is in position and it s equal to the substing with center in then can be updated with value And don t forget to update each with value Easy way to check substrings for equality is to use hashes Harder way is to use string suffix structures like bundle of Suffix Array LCP Sparse Table or Suffix Tree LCA Note for SuffArray users don t forget about changing sort to stable sort merge sort and breaking if all suffixes are different This optimizations can save you from writing radix or bucket sort 
1393,For each word let s consider a graph on vertices where the th and the th vertices are connected by an edge iff the th character of the alphabet is adjacent to the th character of the alphabet in this string Obviously this graph is connected except for the isolated vertices If there is a vertex of degree or more in this graph or if there is a cycle in this graph it is impossible to design a keyboard to type the word easily in the first case the letter represented by that vertex must have at least three neighbors on the keyboard but can have only at most two in the second case the keyboard must be cyclic and it is not So the word can be typed easily only if the graph representing it consists of one path and several isolated vertices Let s write the letters along the path we constructed for the word in a single string For example for the word we get edges and in the graph so the letters along the path are either or and obviously one can be obtained from the other by reversing the string Let and be the two strings we obtain from the word using this method Now we claim that the word can be typed easily if and only if one of these two strings and is a substring of the keyboard this would mean that every pair of letters that should be on adjacent positions are actually on adjacent positions Okay now we construct and for each word and our goal is to find the permutation of the first characters of Latin alphabet such that the sum of over all words having either or as a substring is the maximum possible There are two key observations that allow us to solve this problem and cannot be the substrings of the same keyboard the proof is simple if is a substring its first character must be before its second character and if is a substring its second to last character which is the second character of must be before its last character which is the first character of neither nor can appear in the keyboard twice it s obvious since the keyboard is a permutation So we can reformulate the problem as follows let be the cost of the string and the cost of the string as well find the permutation of the first characters of the Latin alphabet so that its cost which is the sum of costs of its substrings is the maximum possible To solve this problem we can store the strings in an Aho Corasick automaton and for every state of the automaton precalculate the total cost of all string ending in this state that is the cost of this state and all states reachable from it via the suffix links Then run a dynamic programming of the form the maximum possible cost of a partial keyboard if we used a of characters and the Aho Corasick automaton is currently in the state This dynamic programming runs in where is the size of the alphabet and is the size of the automaton up to 
1394,The main idea of the solution is to calculate the following dynamic programming is the maximum prefix we can fully cover with first lanterns Let s look at how can we solve it in with this kind of dynamic programming First of all let s write it forward Which transitions from do we have iterate on the lantern facing left that will cover the lantern Let this lantern be It should cover all lanterns in so all lanterns from can be turned to the right and we need a max query to determine the new covered prefix if lantern is already covered we can just extend the prefix by turning the th lantern to the right Note that turning it to the right when it is not covered yet will be modeled by the first transition It is obviously how can we optimize it Let s write this dynamic programming backward The second transition is changed to backward dp easily what about the first one Suppose we want to turn some lantern to the left Let s iterate on the prefix that we will connect to it for this prefix should be at least and we update with the maximum of since it is covered by lantern and the result of max query on In fact we need only one such prefix the one with the minimum among those which have So we build a minimum segment tree where each pair is interpreted as the value of in position and with min query on the suffix from we find this optimal prefix from which we should update and to update we can use any DS that allows max queries on segment in my solution it s another segment tree 
1395,Let s interpret the problem geometrically the pairs from the set are the lines and the problem to find to topmost intersection of the vertical line with the lines from the set Let s split the queries to blocks Consider the lines added before the current block and that will not deleted in the current block Let s build the lower envelope by that lines Now to calculate the answer to the query we should get maximum over the lines from the envelope and the lines from the block before the current query that is not deleted yet There are no more than lines from the block so we can iterate over them Let s find the answers from the envelope for all queries of the third type from the block at once we should sort them and iterate over envelope using two pointers technique 
1396,Let s think about why we can t always make a perfect vertex cover such a vertex cover that each edge has exactly one endpoint in it Or why the answer can not exist at all Consider a bamboo It s always possible to find a perfect vertex cover Just choose every other vertex in it and account for parity Make a bamboo into a loop Now you can see that an even length loop has a perfect vertex cover An odd length doesn t That tells us that each odd length loop in a graph will have a bad edge on it Odd length loops should instantly make you think about bipartite colorings So we can see that a bipartite graph always has a perfect vertex cover Just choose one of the parts into a cover and each edge will have exactly one endpoint in it At the same time a non bipartite graph never has a perfect cover So our general goal is to remove basically mark as bad at most one edge in such a way that the remaining graph is bipartite Consider a dfs tree of the graph colored bipartitely Every edge in the tree is good has endpoints in different parts Every edge outside the tree can be either good or bad What happens to the tree if we remove an edge If we remove an edge outside the dfs tree then nothing happens to it So if there is no more than one bad edge outside the tree then we found the answer That was the easy part Now what happens if we remove an edge from the tree The back edges from the subtree of the edge can force the subtree to either remain colored the same or flip all its colors We don t really care if it remains the same because we already took care of it in the first part So let s pretend it always flips the colors Thus all edges that go from the subtree upwards above the removed edge have only one of their endpoints colors changed Good edges turn bad bad edges turn good All other edges don t change So you should choose such an edge to remove that all bad edges in the graph go from its subtree upwards above that edge and no good edges go from its subtree upwards above that edge That can be calculated with a dfs Since all non tree edges in the dfs tree are back edges you can simply increment a counter on the bottom vertex decrement the counter on the top vertex and collect sums from the bottom The sum in the vertex will tell you the number of edges that start below or in the vertex and end above the vertex Do this for both kinds of edge and check the conditions for all vertices Finally choose such a part to be a vertex cover that the removed edge has both ends in it if you choose the other part that edge won t be covered at all The solution is linear but the problem still requires a massive time and memory limit only because of recursion in the dfs Overall complexity per testcase 
1397,The best way to build a graph is to make a edge connected component with vertices and connect each of the remaining vertices to it with a single edge Then we will have bridges outside the component and edges in the component So the answer for some fixed and is let s denote is at Now since is increasing and is decreasing there exists some such that if then and if then Then is strictly increasing on the segment and strictly decreasing on the segment and this proves that we can use ternary search to find its maximum 
1398,Let s represent spells as points on cartesian plane If we consider three spells and such that and is above on the cartesian plane or belongs to it then we don t need to use spell because we can replace it with a linear combination of spells and without any additional mana cost We can maintain the lower boundary of the convex hull of all points from type queries and the point Then to process type query we have to find the intersection of aforementioned lower boundary and the line our average damage in this fight has to be at least this value If there is no intersection then the answer is because even with infinite mana Vova s character can t deal that much damage before dying If there is an intersection we have to check that it is not higher than the line to ensure that we have enough mana to kill the monster in given time Model solution uses only integral calculations but it seems that precision is enough Time complexity 
1399,Consider the undirected complete graph with nodes with an edge between nodes with cost Let denote the minimum possible value of the max edge of a path from to We know that by definition If the matrix is magic we can choose arbitrary such that by repeating invocations of the inequality given Also you can show that if this inequality is satisfied then the matrix is magic by choosing an and arbitrary So this shows that the matrix is magic if and only if Thus combining with we have We need a fast way to compute for all pairs This can be computed as the MST as the path in the MST minimizes the max edge between all pairs of nodes So the algorithm works as follows First find the MST on the complete graph Then the matrix is magic if and only if the max edge on the path between in the MST is exactly equal to Also you shouldn t forget to check symmetry of the matrix and diagonal for zeros P S Unfortunately we couldn t increase the value in this problem the tests already had the size about 67MB and they couldn t be given with generator So most of the users who solved this problem uses bitset s The complexity of their solution is where or 
1400,Suppose we don t have any constraints on the order of elements the resulting array just should not contain any duplicates Let s build the result one element after another in ascending order so each element we create is strictly greater than the previous To create an element just use some subset of elements and merge them into new element This process can be efficiently modeled with the following dynamic programming dp cnt mask is the minimum value of the last element if we merged all the elements from mask into cnt ascending numbers To model transitions we simply iterate on the mask of elements that will be merged into a new one and check if its sum is greater than the last element we created This runs in O n3 n if we use an efficient way to iterate on all masks that don t intersect with the given mask Okay how about maintaining the order When we create an element by merging some elements of the original array let s choose some position of an element we use in merging and state that all other elements are added to it Then to ensure that the result is ascending the position of this element should be greater than the position of the element we chose while building the previous number We can add the position we have chosen for the last element to the states of our dynamic programming so it becomes dp cnt mask pos the minimum value of the last element if we merged the mask of elements into cnt numbers and the last element originally had index pos in the array Using some greedy optimizations for example we should not iterate on the position we are choosing to merge it can be chosen greedily as the leftmost position after the position of previous element we are taking into consideration we can make it O n 2 3 n yet with a small constant factor To restore the answer we can maintain the previous values of mask and pos in each state since cnt just increases by 1 with each transition 
1401,Iterating over all possible values of and checking them may be too slow though heavily optimized brute force is difficult to eliminate in this problem so we need to speed this approach up The resulting number consists of bits Let s use the classical meet in the middle trick try all combinations of lowest bits try all combinations of highest bits and somehow merge the results When we fix a combination of lowest bits we fix lowest bits in every Suppose that there are ones among lowest bits of Analogically when we fix a combination of highest bits we fix highest bits in every Suppose that there are ones among highest bits of We want to find a combination of lowest and highest bits such that is the same for each Let s represent each combination of lowest bits with an dimensional vector with coordinates Let s also represent each combination of highest bits with an dimensional vector with coordinates We want to find a combination of lowest bits and a combination of highest bits such that their vectors are opposite We can do so for example by precalculating all vectors for all combinations of lowest bits storing them in a map or a trie iterating on a combination of highest bits and searching for the opposite vector in the map trie 
1402,Let s start by finding the maximum matching in the given graph Since the constraints are pretty big you need something fast The model solution converts the matching problem into a flow network and uses Dinic to find the matching in but something like heavily optimized Kuhn s algorithm can also work Okay then what about finding the minimum possible number of vertices to delete in order to reduce the maximum matching We claim that it is always enough to remove one vertex and the proof will also provide a way to quickly search for such vertices Let s recall that the size of the maximum matching is equal to the size of the minimum vertex cover So we will try to find a way to reduce the minimum vertex cover by and it s actually pretty easy just remove any vertex belonging to the vertex cover it s obvious that it reduces the vertex cover by and the maximum matching by as well So we can find the minimum vertex cover in the graph using the standard algorithm to convert the MM into MVC or if you re using Dinic to find the maximum matching you can represent the minimum vertex cover as the minimum cut problem and for each query of type just take a vertex from the vertex cover we found Now the only thing that s left is discussing how to maintain the structure of the maximum matching in the graph In fact it s quite easy on the one hand since we remove the vertices belonging to the minimum vertex cover every edge including the edges from the matching will be incident to one of the vertices we will remove on the other hand due to the definition of the maximum matching there is no vertex that is incident to two or more edges from the maximum matching so every vertex from the vertex cover has exactly one edge from the maximum matching that is incident to it and when we remove a vertex we can simply remove the corresponding edge from the maximum matching So the only thing we need to do is to maintain which edge from the matching corresponds to which vertex from the minimum vertex cover and it will allow us to maintain the structure of the maximum matching and since these pairs don t change when we remove a vertex it is enough to get this information right after we have constructed the maximum matching in the given graph we won t need to rebuild it 
1403,The key idea of the task is to prove that there is an optimal answer where the chosen elements in has a period equal to Let s work with instead of Firstly let s prove that if we ve chosen correct set in interval then if we take all then set will be corect as well By contradiction suppose we have then or contradiction It means that if we take the correct set in interval we can create a periodic answer by copying this interval several times Next let s prove that there is an optimal periodic answer Let s look at any optimal answer and its indicator vector binary vector of length where iff is in the set Let Let s split the vector in intervals The st rd th segments have length and nd th segments have length If we choose any two consecutive segments its total length will be equal to and we can use it to make periodic answer by replacing all length segments with the chosen one and segments with the other one We can prove that we can always find such two consecutive segments that the induced answer will be greater or equal to the initial one If we create vector where is equal to the sum of in the th segment then the task is equivalent to finding and such that replacing all by and all by won t decrease array sum The proof is down below Now since the answer is periodical taking element is equivalent to taking all elements so for each we can calc the number of integers with the same remainder And for each we either take it or not So we can write where is the maximum sum if we processed elements and last elements are described by mask We start with and when look at the th element either take it if we can or skip it Time complexity is Let s prove that for any array we can find pair such that replacing all with and all with won t decrease the total sum Let s define and Let s make array where and The meaning behind is how changes the total sum if we replace corresponding elements by Note that finding a good pair is equivalent to finding Also note that and analogically Let s prove by contradiction suppose that for any Let s look at But from the other side we know that so otherwise will be negative In the same way since then Analogically we can prove that each but contradiction So there is always a pair i e a pair 
1404,This problem is solved using minimum cost flows duh Suppose all arcs have even capacity Then we can just divide each arc s capacity by and solve a usual minimum cost flow problem However when we have arcs with odd capacity it s not that simple We will deal with them as follows split an arc with capacity into two arcs one with capacity the other with capacity and somehow enforce that the second arc must be saturated We cannot divide all arcs by now because that would lead to non integer capacities instead we will exclude these arcs with capacity and somehow handle the fact that they must be saturated and only then divide all capacities by Okay how do we handle the edges we deleted For each vertex let s check if the number of such arcs connected to it is even If it is not the total flow for this vertex cannot be so it s impossible to find the answer the only case when it might be possible is if this vertex is the source or the sink in this case we need to check that both of these vertices have an odd number of arcs we want to delete connected to them and consider an additional arc with capacity and weight to make it even If for each vertex the number of odd arcs connected to it is even let s consider how much excess flow these arcs bring into the vertices For example if a vertex has ingoing odd arcs it has units of flow going into it which will be lost if we remove the edges we want to ignore To handle this add a new source and a new sink to our network let s call them and and process excess flow going into the vertex using an arc from to that vertex in the previous example we can add an arc from to the vertex with capacity not since we divide all capacities by Similarly excess flow going outside the vertex can be processed with an arc from that vertex to We need to make sure that all these edges must be saturated Okay what about actually running the flow from to We can do it as in flow with lower bounds problem by adding an arc with infinite capacity Wait a minute this may cause a negative cycle to appear If your implementation of mincost flow handles them you can use this approach but if you don t want to mess with negative cycles instead do the following add an arc and an arc both with infinite capacities to make sure that flow can go from to since these arcs don t have to be saturated but other arcs going from or into must be saturated set the costs of these other arcs to Okay that s it we just need to find the minimum cost flow in the resulting network The constraints are low enough so any minimum cost flow algorith can pass 
1405,There are many ways to solve this problem you can use cartesian tree segment tree sqrt decomposition maybe something else I personally see the solution with the segment tree the easiest one so let me describe it Firstly let s notice that the queries are offline So we can compress the numbers by taking and of each query will be either one of these numbers or So now we have numbers up to and pretty basic task on segment tree The first two types of queries are translated to assign value or on a segment set the number on some position is either present or not The third is for each in segment assign to this will inverse the segment as described in statement Segment tree should keep sum of the segment in its nodes XOR on segment will turn into is the length of the segment being covered by the node The leftmost zero cell is While standing in some node check if its left son is full has in every cell of the segment like if you use 1 indexed tree and intervals for it If it is full then go down to the right son otherwise there exists some zero cell in a segment of the left child and you should go down to it You should use lazy propagation to guarantee per query Overall complexity 
1406,This problem can be solved using dynamic programming Let be the answer for first holes and mice If the constraints were smaller then we could calculate it in just trying to update by all values of where and calculating the cost to transport all mice from the segment to th hole To calculate this in we will use a deque maintaining the minimum or a queue implemented on two stacks for example We iterate on and update all the values of with the help of this deque for each index we insert a value in the deque equal to where is the total distance required to move first mice to hole Updating the value is just extracting the minimum and adding this to it Don t forget to delete values from the deque to ensure that we don t send too much mice to the hole Time complexity 
1407,To get the answer for some we can build the following network connect the source to every vertex of the first part with edge with capacity where is the degree of vertex then transform every edge of the original graph into a directed edge with capacity and then connect each vertex from the second part to the sink with capacity Then edges saturated by the maxflow are not present in the answer and all other edges are in the answer To solve it fastly we might just iterate on from its greatest value to and each time augment the flow we found on previous iteration Since maxflow in the network is at most and we will do not more than searches that don t augment the flow this solution is 
1408,First of all let s visualize the problem in a different way We have to set some constraints on the number of strings which have some kind of prefix Let s think about a data structure that would allow us to understand it better One of the most common data structures to store strings which works with their prefixes and maintains the number of strings with some prefix is a trie so we can reformulate this problem using tries Now the problem is the following one we have a binary trie of depth the leaves of this trie may store strings and for each vertex except for the root we can set a constraint on the number of strings stored in the subtree what is the number of ways to choose these constraints so that the maximum number of strings possibly with copies the trie can store is exactly To handle it we can use dynamic programming of the form the number of ways to choose the constraints for the vertex and its subtree so that the maximum number of strings which can be stored in the subtree is exactly When calculating we can iterate on the constraint for the vertex let it be and the maximum number of strings in the subtrees of and let these be and and make updates of the form add to the value of This dynamic programming will work in or depending on the implementation which is too slow However we can use the following optimizations to improve the complexity of the solution all vertices on the same depth can be treated as equivalent so we can actually calculate this dynamic programming not for vertices but just for when handling transitions from some node s children to that node let s split these transitions into two steps The first step is iterating on the number of strings which fit into the subtrees of the children the second step is iterating on the constraint for the subtree of the node The first step is actually a convolution if we don t consider the constraint for the node itself then the transitions would be something like add to the value of so it can be improved to with FFT The second step can be improved to as well if we iterate on the minimum between the constraint for the node and the total number of strings which can be stored in the children and maintain the sum on suffix for the values of dynamic programming Overall these optimizations lead to a solution with complexity 
1409,There are plenty of different solutions to this problem Here is one that doesn t use Hall s theorem Let s look at pair as fuction how many connections will be left for the th city if we take connections from the th station This function has the following structure there is a minimum required let s name it to meet the needs of the th city and with borrowed connections there will be free connections to the th city Increasing by some we can get free connections but there is upper bound to number of free connections In other words the function where For example let s calculate the corresponding coefficients for the th function if then and if then and Why did we define such functions If we can calculate result function then we can check the possibility of meeting all needs by checking that this fuction exists and i e the minimum free can be used as borrowed Fortunately it turns out that the superposition is either don t exists if for example or it has the same structure as any function So we can calculate in one pass and find the answer We will skip the detailed formulas to calculate you can either find them by yourself or look at function in author s solution The resulting complexity is 
1410,Let s simplify the problem a bit we need either to minimize the number of lowercase letters or to minimize the number of uppercase letters Both variants can be described by the following model we have a binary array a where a i 0 if s i is in the correct case and a i 1 otherwise We can do at most k operations set 0 on the segment i i l 1 and we d like to minimize the total sum of a At first let s start with a solution which is pretty slow but correct Let dp len c be the minimum sum of the prefix a 0 dots a len 1 such that c operations was already applied on it In order to calculate this dp somehow efficiently we need to understand that it s optimal to avoid intersections of segments of applied operations so we can further specify the state of dp with the following all c applied operations have their right borders le len 1 It s easy to specify the transitions we either apply set operation on len len l 1 and relax dp len l c 1 with dp len c or not and relax d len 1 c with dp len c a len It still O nk so we d like to optimize it more and we can do it using the lambda optimization i e aliens trick Here we will try to describe what aliens trick is and the features of its application on the discrete calculations In general aliens trick allows you to get rid of the restriction on the total number of operations applied to the array sometimes it s the number of segments in the partition of the array by replacing it with the binary search of the value lambda connected to it The lambda is the cost of using the operation or the cost to use one more segment in the partition In other words we can use as many operations as we want but we need to pay for each of them Often we can calculate the answer without the restriction faster The main restriction of the using this dp optimization is the following in case of the discrete model consider the answer ans c for the fixed c or dp n c If we look at the function ans c it should be somewhat convex i e ans c 1 ans c ge ans c ans c 1 or sometimes ans c ans c 1 ge ans c 1 ans c for all possible c Let s look at the answers of the modified version of the problem with cost lambda for each used operation as function res lambda c It s easy to prove that res lambda c ans c lambda c and it s also somewhat convex for a fixed lambda as a sum of convex functions But more important it has the following property let c lambda be the position where the res lambda c is the minimum possible It can be proven from the convex property that c lambda ge c lambda 1 This property leads to the solution binary search lambda while keeping track of the c lambda i e find the minimum lambda that c lambda le k But there are several problems related to the discrete origin of the problem The c lambda is not unique In general case there is a segment cl lambda cr lambda where the minimum res lambda c can be achieved But there is still a property that cl lambda ge cl lambda 1 and cr lambda ge cr lambda 1 So we need to ensure that we will always find either minimum such c lambda or maximum such c lambda The second problem comes from the first one There are situations when c lambda c lambda eps 1 It creates a problem in the next situation suppose the binary search finished with lambda opt the c lambda opt 1 k and c lambda opt k But we need to use exactly k operations what to do Using float values will not help so we don t need them so we ll use usual integer bs Suppose we minimized the c lambda opt then we can show that k in cl lambda opt cr lambda opt or in other words res lambda opt k res lambda opt c lambda opt So we can claim that we calculated the value not only for c lambda opt but also for k In the end if we can efficiently calculate c lambda and res lambda c lambda for the fixed lambda then we can binary search lambda opt extract res lambda opt c lambda opt and claim that the dp n k res lambda opt c lambda opt lambda opt k Finally let s discuss how to calculate c lambda and res lambda c lambda for a fixed lambda Since res lambda c lambda is just a minimum cost and the c lambda is the minimum number of operations with such cost We can calculate it by simplifying our starting dp Remember the cost is calculated in a next way for each remaining 1 in a we pay 1 and for each used operation we pay lambda Let d len cost len cnt len where cost len is minimum cost on the prefix of length len and cnt len is minimum number of operations cost len can be achieved Then the transitions are almost the same we either let a len be and relax d pos 1 with cost len a len cnt len or start new operation and relax d pos len with cost len lambda cnt len 1 The result is pair d n Some additional information we should carefully choose the borders of the binary search we should choose the left border so it s optimal to use operation whenever we can usually 0 or 1 And we should choose the right border so it s never optimal to use even one operation usually more than the maximum possible answer The total complexity is O n log n P S We don t have the strict proof that the ans c is convex but we have faith and stress We d appreciate it if someone would share the proof in the comment section 
1411,Note that because of the low constraints on the number of colors the problem can be solved independently for each color Now you can divide the queries into two types add a cell to the field and delete it You have to maintain the number of components formed by added cells Cell deletions will occur after all additions because of the condition The first part of the solution will be to calculate the number of components while adding new cells This is a standard problem that can be solved using the DSU After that we should note that if we consider the process of removing cells from the end this process is similar to the process of adding Therefore we have to process delete requests from the end in the same way as add requests only their contribution to the number of components will be opposite in sign 
1412,What does the condition the number of occurrences of in the array is than the number of occurrences of each non empty subarray of in mean First if contains two or more equal elements then any occurrence of introduces at least two occurrences of that element so any element in is forbidden it should not appear in the resulting array Now let s consider an array such that every its element is unique Every element of should be a part of an occurrence of in the array Let s rephrase this condition as follows Let s build a directed graph on vertices where an arc from vertex to vertex means that each occurrence of should be followed by and each occurrence of should be preceded by i e is followed by in some array Let s consider the weakly connected components in this graph If we have at least one occurrence of some element from a component in it means that all other elements from this component occur in as well Some integers from and are bad in a sense that we cannot uniquely determine which element should follow precede them in terms of graph theory it means that the in degree or out degree of a vertex is at least Since by picking one element from a component we will have to use all elements from a component it means that if a component contains at least one bad element the whole component will be bad we cannot use any element from it If a component is a cycle no vertex has in degree or out degree greater than but the component is still bad since if we include at least one element from we cannot finish the cycle the array is not infinite but the cycle is Okay the only good components are chains When we use an element from a chain in all elements from this chain will be used in exactly the same order that they were in the chain so should consist of some chains linked together chains may repeat and some chains may be absent from We can write a solution with dynamic programming let be the number of ways to construct an array of length using these chains The transitions are as follows where is the number of chains and is the length of the th chain The number of chains is up to and the number of states in dynamic programming is so the solution works in which is too slow We can improve it with the following two facts all chains of the same length are indistinguishable there are different lengths of chains So instead of iterating on the chains themselves in dynamic programming we will iterate on the lengths of the chains considering only lengths having at least one chain and process all chains of the same length as one by introducing a multiplier in our dynamic programming where is the number of chains of length That way our dynamic programming will work in if we skip the values of with 
1413,Suppose all queries have the same right border Then the answer for the query can be some integer such that the last occurence of on the prefix of the array is inside the segment but the second to last occurence is outside the segment or even does not exist More formally let be the maximum index such that and or if there is no such the answer to the query is some number such that and and is the rightmost occurence of in the segment For a fixed right border we can build a segment tree which for every index such that is the rightmost occurence of on stores the value of and if we query minimum on the segment in such tree we can try to find the answer Let the position of minimum be If then can be the answer otherwise there is no answer But this is too slow since we can t afford to build a segment tree for every possible value of There are two methods how to deal with this problem you may sort all queries by their right borders and maintain the segment tree while shifting the right border when going from to we have to update the values in the positions and or we may use a persistent segment tree and get an online solution We tried to eliminate solutions using Mo s algorithm but in fact it s possible to squeeze some implementations of it into TL There are two optimizations that might help there When dividing the elements into blocks we may sort the first block in the ascending order of right borders the second in descending the third in ascending order again and so on And also it s possible to obtain a Mo based solution with worst case complexity of if we maintain the set of possible answers using sqrt decomposition on it 
1414,Let s build the number from the lowest digit to the highest digit with the following dynamic programming the minimum number of ones if least significant digits are already fixed the carry to the next digit is can be negative there are positive numbers of the form of length greater than or equal to and negative numbers of length greater than or equal to First consider the transitions when we reduce the values of and or Such transitions correspond to the fact that in the optimal answer there were several numbers of length exactly and they should not be considered further If the value of matches the th least significant digit in then we can use transition to th state with the new value of and the number of ones in the answer increased by It remains to estimate what the maximum value of and we need The value of doesn t exceed the total number of numbers that we use in the answer Using at most numbers we can decrease the length of by at least Thus the maximum value of and is at most where n is the length of the number For the value of the condition should be met similarly for a negative value Thus we can assume that the absolute value of doesn t exceed The total complexity of this solution is yet with a high constant factor 
1415,Let s start with making some implications from the low constraints What s the upper estimate on the number of answers Too high let s think of a better one Using some combinatorics we can normalize the answers in such a way that there are at most th Bell s number of them The method basically defines the components of equal letters Given a string we write down the letters in it in the order they appear for the first time in the string and rename the first of them to the second one to and so on Only possible answers already Hmm but we should also have an even amount of each letter That is the absolute lowest estimate and it s equal to about What does it exactly mean for a string to be good There exists a path such that there s a pair of equal letters that occupy the st and the th vertex in the path a pair on the nd and th and so on So for each of possible answers we want to determine if there s a way to split the groups of equal letters into pairs of equal letters such that there exists a path through these pairs Such a path would mean building a palindrome from inside out A quick estimation on a number of splittings into pairs The first letter can be matched against other letters the first among the unmatched ones against other letters and so on Thus it s equal to For each splitting into pairs we can determine if there exists a path That is a straightforward dynamic programming similar to a usual hamiltonian path search It stores a mask of visited and the last visited pair For a transition you want to either go from the first vertex of one pair to the first vertex of another one and from the second to the second or the other way around That would take for each splitting The only thing left is to propagate the results from the splitting into pairs to splitting into even sized components of equal letters A splitting into pairs is a splitting into components of size Let that be a base case for the dp For every splitting into components find a component of size at least we still have to split it into pairs and separate it into a component of size a pair and the rest of the component Moreover a pair can always be chosen in such a way that one of its elements is the first element of the component So there are states and at most transitions from each of them Maybe there s a more convenient way to store the states but the one I found to be fast enough is hashing the state into a base integer since there are no more than components numbered through and storing it in a map hashmap 
1416,Let s root the tree at vertex and try to analyze when a tree contains a perfect matching If we want to find the maximum matching in a tree we can use some greedy approaches like take a leaf of the tree match it with its parent and remove both vertices repeat this process until only isolated vertices remain If we are interested in a perfect matching then this process should eliminate all of the vertices Let s modify this process a bit by always picking the deepest leaf If there exists a perfect matching picking the deepest leaf will ensure that the tree always remains a tree and doesn t fall apart i e there will always be one connected component It means that when we remove the leaf with its parent this leaf is the only descendant of its parent It s easy to see that whenever we remove a pair of vertices in this process for each remaining vertex the number of its descendants is either left unchanged or decreased by It means that if a vertex has an even number of descendants it will have an even number of descendants until it is removed and the same for odd number of descendants Let s call the vertices with even number of descendants including the vertex itself and all the other vertices A vertex cannot change its status in the process of building the perfect matching Each leaf is and odd vertex and if its parent has only one child this parent is an even vertex So when we remove a pair of vertices one of them the child is odd and the other of them the parent is even This leads us to another way of building the perfect matching match each odd vertex with its parent and make sure that everything is correct Unfortunately implementing it is per query so we need something faster We can see that each even vertex has at least one odd child because if all children of a vertex are even then the number of its descendants including the vertex itself is odd In order to find a perfect matching we have to make sure that each even vertex has one odd child each odd vertex has an even vertex as its parent All this means is that it cannot be greater since each even vertex has at least one odd child and if it is smaller it s impossible to match the vertices The perfect matching itself consists of edges that connect odd vertices with their parents Okay now we need some sort of data structure to maintain the status of each vertex and the sum of edges that lead to an odd vertex if directed from top to bottom In our problem we have to add new leaves to the tree it happens when a vertex is activated and this increases the number of descendants for every vertex on the path from the root to this new leaf So we need some sort of data structure that supports the operations add a new leaf and flip the status of all vertices on a path One of the structures that allow this is the Link Cut Tree but we can use the fact that the whole tree is given in advance to build a Heavy Light Decomposition on it which is much easier to code Operations on segments of paths can be done with a lazy segment tree and each vertex then will be added in 
1417,A lot of solutions which were written during the contest use Berlekamp Messey or some other algorithms related to analyzing linear recurrences but the model solution is based on other principles First of all if the number of inversions is at most it means that most elements of the permutation will stay at their own places and those which don t stay at their places can t be too far away from them Let s denote a block in a permutation as a segment of indices such that all elements less than are to the left of the block all elements greater than are to the right of the block all elements from belong to the block Let s say that a block is non trivial if it contains at least two elements Suppose we split a permutation into the maximum number of blocks Then for each block we can see that if its length is it has at least inversions to prove it you can use the fact that the number of inversions is equal to the number of swaps of adjacent elements required to sort the permutation and if we cannot split the block into other blocks it means that we have to swap each pair of adjacent elements in it at least once to sort it if the block is non trivial it has at least one such that From these two facts we can see that there will be at most non trivial blocks there will be at most elements in total belonging to non trivial blocks the maximum possible length of a block is The main idea of the solution is to calculate the following dynamic programming is the number of ways to split elements into non trivial blocks such that there are exactly inversions in them and exactly pairs Then to get the answer for the test case we can iterate on the number of non trivial blocks and the number of elements in them and choose the elements belonging to that blocks with a binomial coefficient The only thing that s left is how to calculate this dynamic programming efficiently There are a few ways to do it but the model solution uses a table the number of different non trivial blocks of length with elements and inversions to handle transitions This table is not very big so you can run an exhaustive search for minutes to calculate it and then just paste its results into the source code of your program Note that you have to make sure that you consider only the blocks which cannot be split any further 
1418,We are going to calculate the answer as follows for every point let be the number of points such that i e the number of points that are to the right of and have distance at most from it Then the number of beautiful triples where is the leftmost point is We can sum these values over all points to get the answer so the solution should somehow maintain and update the sum of these values efficiently Let s see what happens when we add a new point or remove an existing point For all points to the left of it with distance no more than the value of increases or decreases by So we need some sort of data structure that allows adding subtracting on segment and maintains the sum of This looks like a lazy segment tree but updating the sum of can be tricky One way to do this is to notice that So maybe we can maintain the sum of and the sum of on the segment It turns out we can The model solution does this as follows the leaf of the segment tree corresponding to the position stores a vector with three values The inner nodes store the sums of these vectors in the subtree We can find a matrix which when multiplied by gets the vector and the inverse matrix to it Then adding to on segment means multiplying all vectors on segment by that matrix and subtracting means multiplying by the inverse matrix and since matrix multiplication is both associative and distributive the segment tree can handle these queries Okay there s only one small issue left right now our structure can store the sum of and over all possible points we build it on segment for example but we only need the sum over points One way to handle it is to use a flag for each leaf of the segment tree and pull the value up from the leaf only if this flag is true We will need a function that changes the value of this flag for a single leaf but it s not very different from a function that changes one value in a lazy segment tree Time complexity of the solution is where is the maximum coordinate of the point although the constant factor of the described approach is fairly large since it involves matrix multiplications You can improve the constant factor by getting rid of the matrices as mentioned earlier 
1419,At first let s realize that the tree structure doesn t matter that much What we actually need is the array such that it stores the number of white vertices on depth Initially and all other are zero If you take a chain and attach it to some vertex on depth then the number of vertices on depth decreases by Also the added vertices update some other counts So far it s extremely unclear what to begin with Let s start by introducing some greedy ideas For each let s find the most optimal tree using exactly chains and update the answer with each of them First it s always optimal to attach a chain with its middle vertex Just consider the changes in the white vertices counts Second for each it s always optimal to take the longest chains to use If not the longest are used then you can replace any of them and there will be more white vertices It would be nice if we were able to just add another chain to the tree for to get the tree for However that s not always the case But we can still attempt it and show that the optimal answer was achieved somewhere in the process Let s show that it s always optimal to attach a new chain to the closest white vertex So there are basically two cases there is not enough white vertices yet and there is enough What happens if there is not enough vertices and we pick the closest one to attach a chain to If there are still not enough vertices then we ll just continue Otherwise we ll have to show that the answer can t get any smaller by rearranging something Consider what the answer actually is Build a prefix sum array over then the answer is the shortest prefix such that its prefix sum is greater or equal to So we put the th chain to the closest white vertex at depth It decreases by and increases and further by or Every chain we have put to this point was attached to a vertex at depth less or equal to the answer otherwise we could ve rearranged it and obtain the answer before The optimal answer can be neither nor also because we could ve rearranged Thus the answer is at least and every single chain we have put was packed as tightly as possible below that depth The second case works similarly We could ve obtained the optimal answer before So the answer is below and we can do nothing about that Or the optimal answer is ahead of us so putting the chain at can decrease it as much or stronger as any other choice Thus updating the answer on every iteration will give us the optimal result Now we are done with the greedy time to implement it I chose the most straightforward way We basically have to maintain a data structure that can add on range get the value of a cell and find the shortest prefix with sum at least That can be easily done with segtree Overall complexity 
1420,Let s delete all zeroes from the beginning of the array they won t affect the answer Also we will return an array of elements when calculating prefix sums sum of zero elements becomes a zero in the beginning of the array and so has to be removed If the size of array is at least then we will get after calculating only a few prefix sums so we can use simple iteration So now we have to obtain the solution in case array has less than elements If we remove zeroes from the beginning of each array then where is a matrix if otherwise Then we can use matrix exponentiation to check whether contains a number which is equal to or greater than and we can use binary search to find the answer To avoid overflows each time we get a number greater than we can set it to 
1421,A good start to solve the problem would be to check the answers for small values of One can see that the answers the sizes of the maximum subsets are not much different from itself or rather not less than Let s try to prove that this is true for all Consider is even Let let s see what the product is equal to if we take all the numbers from to From here we can see that for even the answer is at least because we can delete and the product of the remaining factorials will be the square of an integer for odd the answer is at least because we can delete and It remains to prove that the answer is at least for odd This is easy to do because the answer for is not less than the answer for minus because we can delete and solve the task with a smaller value Moreover it can be seen from the previous arguments that the answer can only be for and we already know that in this case one of the correct answers is to remove the factorials It remains to learn how to check whether it is possible to remove or numbers so that the remaining product of factorials is the square of an integer To do this we can use XOR hashes Let s assign each prime number a random bit number For composite numbers the hash is equal to the XOR of hashes of all its prime divisors from factorization Thus if some prime is included in the number an even number of times it will not affect the value of the hash which is what we need The hash of the product of two numbers is equal to the XOR of the hashes of these numbers Let s denote the hash function as Using the above let s calculate for all from to as well as for all from to this is easy to do because We will also store a map Let s calculate the hash and denote it as It remains to consider the following cases if then the current product is already the square of an integer for an answer of size we have to check that there exists such a that To find such let s check whether the map contains for an answer of size we have to check that there are such and that To do this iterate over and then check whether map contains otherwise the answer is and there is an answer where all numbers except are taken 
1422,For each index we will find the number of pairs before swapping such that is the first occurence of in the chosen segment Let be previous occurence of before if is the first occurence then if we suppose the array to be indexed Let s find the number of pairs such that and then multiply it by and subtract for this index has to be in segment and has to be in segment so the number of ways to choose this pair is The value we receive as the sum of these values over all segments is the total number of distinct elements over all pairs so we need to divide it by the number of these pairs 
1423,The constraint is a clear hint that we need some exponential solution Of course we cannot try all permutations Let s instead try to design a solution with bitmask dynamic programming A string is an RBS if its balance the difference between the number of opening and closing brackets is and the balance of its each prefix is non negative So let s introduce the following dynamic programming is the greatest number of RBS prefixes of a string if we considered a mask of strings the current balance of the prefix is and is a flag that denotes whether there already has been a prefix with negative balance We can already get rid of one of the states the current balance is uniquely determined by the mask So this dynamic programming will have states To perform transitions we need to find a way to recalculate the value of and the answer if we append a new string at the end of the current one Unfortunately it s too slow to simply simulate the process Instead for every string let s precalculate the value how does the flag and the answer change if the current flag is and the current balance is The resulting flag will be in one of the following two cases it is already the string we append creates a new prefix with non positive balance The second case can be checked as follows let s precalculate the minimum balance of a prefix of let it be If the flag will be Calculating how the answer changes is a bit trickier If the current flag is already the answer doesn t change But if it is the answer will increase by the number of new RBS prefixes If the balance before adding the string is then we get a new RBS prefix for every prefix of such that its balance is exactly to compensate the balance we already have there is no prefix with balance in before this prefix To quickly get the number of prefixes meeting these constraints we can create a data structure that stores the following information for every balance store a sorted vector of positions in with balance equal to Then to calculate the number of prefixes meeting the constraints we can find the first position in with balance equal to by looking at the beginning of the vector for and then get the number of elements less than this one from the vector for balance by binary search These optimizations yield a solution in although it s possible to improve to if you precalculate each value of for every string 
1424,Let be true if it s possible to have a collision before time That function is monotonous thus let s binary search for For some fixed car can end up in any point from to units along the ray That makes it a segment So the collision can happen if some pair of segments intersects Let s learn how to find that out The general idea is to use sweep line So let s add the events that the th segment such that opens at and closes at There were no vertical segments so and are always different At every moment of time we want to maintain the segments ordered by their intersection with the line Note that if two segments change their order moving along the sweep line then they intersect So we can maintain a set with a custom comparator that returns if one segment intersects the current line lower than the other one When adding a segment to set you want to check it s intersections with the next segment in the order and the previous one When removing a segment you want to check the intersection between the next and the previous segment in the order If any check triggers then return true immediately It s easy to show that if the intersection happens between some pair of segments then the intersection between only these pairs of segment also happens Now for the implementation details Precision errors play a huge role here since we use binary search and also store some stuff dependant on floats in the set The solution I want to tell requires no epsilon comparisons thus it calculates the answer only with the precision of binary search So the first issue rises when we have to erase elements from the set Notice that we can make a mistake when we are adding the segment and there is a segment with almost the same intersection point That will not make the answer incorrect that s not trivial to show but it s possible if you consider some cases If you can find it later to remove then it s not an issue at all However that will probably mess up the lower bound in the set Thus let s save the pointer to each element in the set and remove it later by that pointer The second issue comes when you have to check the intersection of two segments The error might appear when one segment let the first point be the original and the second point be calculated depending on has it s intersection point with segment at exactly So the slightest miscalculations could matter a lot Let s learn to intersect in such a way that no epsilon comparisons are required Firstly we can store lines in the set instead of segments Second we can check the intersection of rays first and only then proceed to check the intersection of segments So two rays intersect if their lines intersect easy to check in integers the intersection point lies in the correct direction of both rays the intersection point is always a pair of fractions and you want to compare the signs of and Finally if all the checks hold then you can compare maximum of distances from and to the intersection point and If is greater or equal then they intersect in time There is no way to make that comparison in integers However it s precision only depends on the precision of as in the error here can t affect the answer greatly Overall complexity 
1425,Note some observations if we meet a new wave and start shooting it s optimal to shoot monsters in the wave using full magazines while we can and there are no reasons to take breaks between shooting monsters from one wave That s why we can track only moments when waves start and the number of remaining bullets in magazine we have at these moments Moreover since the next wave starts not earlier than the previous ends we can think that when we start dealing with one wave we ve already dealt with the previous one Also instead of keeping track of the remaining bullets let s just look only at such indices of waves when we reloaded and threw remaining bullets before reaching them So we can write the next dp is the minimum number of bullets we spend dealing with the first waves and now we standing at the moment with full magazine Obviously Now with fixed we can iterate over the index of a wave before which we ll reload throwing away remaining bullets And for waves we need to check that we are able to exterminate all these waves without throwing away any bullets We can check it with several formulas If it s possible for segment then the possibility for the segment is just checking that we can exterminate the th wave having bullets in the start in no more than reloads plus checking that we have at least one unit before for a reload As a result the time complexity of the solution is 
1426,A lot of things in this problem may tell us that we should try thinking about a flow solution Okay let s try to model the problem as a flow network First of all our network will consist of vertices and edges of the original graph We somehow have to denote red blue and colorless edges we will do it as follows each edge of the original graph corresponds to a bidirectional edge with capacity in the network if the flow goes from the left part to the right part along the edge it is red if the flow goes from right to left it is a blue edge and if there is no flow along the edge it is colorless Okay we need to impose some constraints on the vertices Consider some vertex from the left part Each red edge incident to it transfers one unit of flow from it to some other vertex and each blue edge incident to it does the opposite So the difference between the number of blue and red edges incident to is the amount of excess flow that has to be transfered somewhere else If is colorless there are no constraints on the colors of edges so this amount of excess flow does not matter to model it we can add a directed edge from source to with infinite capacity and a directed edge from to sink with infinite capacity What if is red At least one unit of flow should be transfered to it so we add a directed edge from the source to with infinite capacity And if is blue we need to transfer at least one unit of excess flow from it so we add a directed edge from to the sink with infinite capacity such that there is at least one unit of flow along it The colors of the vertices in the right part can be modeled symmetrically How to deal with edges such that there should be some flow along them You may use classic flows with demands approach from here https cp algorithms com graph flow with demands html Or you can model it with the help of the costs if the flow along the edge should be between and we can add two edges one with capacity and cost where is a negative number with sufficiently large absolute value for example and another with capacity and cost Okay now we know how to find at least one painting How about finding the cheapest painting that meets all the constraints One of the simplest ways to do it is to impose costs on the edges of the original graph we can treat each edge of the original graph as a pair of directed edges one going from left to right with capacity and cost and another going from right to left with capacity and cost 
1427,Let s analyze how the perimeter of the fence can be calculated if we know its array of lengths Suppose there are boards in the fence The perimeter of the fence can be composed of the three following values the lower border of the fence with length horizontal segments in the upper border of the fence with total length vertical segment of the border The total length of all vertical segments before the red board including its left border is The total length of all vertical segments after the red board including its right border is too So the perimeter of the fence is where is the number of boards used in constructing the fence and is the length of the red board So for example if we want to create a fence that contains a red board with length and has perimeter it should contain exactly white boards Now let s solve the problem as follows iterate on the length of the red board that will be used and for each calculate the number of ways to construct a fence with a red board of length and exactly white boards which are shorter than Suppose all white boards shorter than have distinct lengths Then for each board there are three options not place it at all place it in the left part to the left of the red board or place it in the right part So if there are different white boards shorter than the number of ways to build a fence with white boards is Okay now let s consider the opposite situation there is no unique white board that is for each length we have either boards or at least boards Suppose the number of different lengths is For each length we can choose whether we place a board of such length in the left side and in the right side So the number of ways to build a fence with white boards is And now let s consider the general case Divide all boards into two categories unique and non unique If we want to build a fence with exactly white boards there are ways to do it Since we should calculate these values for many different values of we have to use FFT we should form two polynomials and and then multiply them Since the modulo is special it s better to use NTT 
1428,Whoops it seems this problem can be done in a similar manner as in problem Firstly is some number has of the prime powers not equal to then you can take root th power from it That is the same as dividing all powers by Now it turned out there are really a small amount of these numbers up to if you take the squares out Actually our solution wasn t that Let s count the answer using inclusion exclusion principle For this Mobius function can be used The answer is The power part is the amount of numbers which raised to the th power becomes less ot equal to This turns zero for like iterations on for any up to However calculating each log as it is will lead to a solution which might be too slow Let s process the queries in the decreasing order of will be calculated naively each time in or however complexity has the built in function maybe or The rest powers will be initialized with their upper limits in the start like for for and so on Now proceeding to the next number will only decrease the current maximum number for each power Subtract one until you reach the needed number and check in Overall complexity 
1429,Let s notice that if we process the queries of type naively then each such query consumes time where is the size of the array So queries with large can be processed naively For queries with small we may notice two things there are only possible queries each number in the array affects only possible queries So for small we may maintain the exact answer for each query and modify it each time we modify an element in the array If we process naively all queries with and maintain the answers for all queries with we will obtain a solution having time complexity Note that as in most problems related to sqrt heuristics it may be optimal to choose the constant that is not exactly but something similar to it but most solutions should pass without tuning the constant 
1430, editorial by PikMike Firtsly we can notice that we get the most profit by placing the edge in a same position no matter the query Moreover once you have calculated the minimum difference you can apply to the shortest path by adding edge of the weight you can answer the queries in each Let the current shortest distance between and be Then the answer to some query is Let s proceed to proofs of the following Consider any of the optimal positions for the edge of weight Then weight will add to the answer in this position if the path isn t already but that is trivial Let there be another position such that the answer in it is less than the current one That means that the answer for weight in it is less by which is smaller than the first one we got which leads to contradiction The second fact can deduced from the first one Then let me introduce the next bold statement We root the tree with vertex Then if there exists such a vertex in that it s not an ancestor of vertex and the number of vertices in its subtree inclusive is greater than then That is simple just put the edge between the parent of this vertex and any of vertices of the subtree there always be such that the edge doesn t exist yet That won t change the shortest path no matter which it is Then we have a graph of the following kind That is the simple path between and and some vetices on it have additional children leaves Finally let s proceed to the solution We want to choose such a pair of vertices that the sum of edge on a path between them which are also a part of the path between and plus the weights of the newly included to shortest path edges if any is minimal possible Let s precalc the sum of weights of edges from vertex to vertex and parent of vertex Let be the weight of an edge between and Then we end up with the four basic cases for these vertices and with having greater or equal number of edges on path to than each of the form whether belongs to the simple path between and whether belongs to it doesn t belong the answer is belongs doesn t both belongs Each of these formulas can be broken down to parts with exacly one of the vertices Let s call them and That means minimizing the result is be the same as minimizing each of the parts We run depth first search on vertices which belong to a simple path between and inclusive Maintain the minimum value of you have already passed by Try connecting each vertex with this and also parent of the parent of the current vertex using all the possible formulas and updating with the resulting value Finally after the precalc is finished asnwer the queries in with Overall complexity editorial by BledDest Let s denote the distance from vertex to vertex in the tree as Similarly denote the distance from to in the tree as Suppose we try to add a new edge between vertices and with length Then two new paths from to are formed one with length and another with length Then the new length of shortest path becomes So if we find two non adjacent vertices such that is maximum possible then it will always be optimal to add an edge between these two vertices How can we find this pair of vertices Firstly let s suppose that when we pick vertex we will try to pair it only with vertices corresponding to the aforementioned constraint This can be done by sorting vertices by the value of and then for each vertex pairing it only with vertices that are later than in the sorted order How do we find the best pair for The best pair could be just the vertex with maximum possible but it is not allowed to connect a vertex with itself or its neighbour To handle it we may maintain a set of possible vertices delete all neighbours of from it pick a vertex with maximum and then insert all neighbours of back into the set This solution works in time 
1431,There is a simple dynamic programming solution that works in Let s try to improve it Firstly if there are no obstacles in some column and we have calculated the number of paths to every cell of the previous column then we may get the values in column by multiplying the vector of values in column by the following matrix Then we may use binary exponentiation to skip long segments without obstacles in where is the length of the segment Let s try to modify this matrix if we have to forbid some rows All we need to change is to set every value in th row to if th row is forbidden So we may skip long segments not only if they don t contain any obstacles but also if the set of forbidden rows doesn t change on this segment So the solution is the following divide the whole matrix into segments by the endpoints of the obstacles then in every segment the set of forbidden rows doesn t change so we can skip it using fast matrix exponentiation 
1432,Let s define some functions at first indicator function if is true and otherwise is a number of that and Good observation Another observation Now it s time to transform what we d like to calculate Since transformation of the second sum was standard we ll look at the first sum So we can iterate over and we d like to calculate this two sums fast enough So more transformations So while iterating over we need to make queries of two types set value in position and calculate It can be done by BIT with coordinate compression can be calculated in the same way iterating over in reverse order Result complexity is 
1433,This problem has many approaches as Hall s theorem Kuhn algorithm and so on I will explain one or two of them Let s find the answer using binary search It is obvious that if we can pass all the exams in days we can also pass them in days For the fixed last day let s do the following thing firstly if there exists some exam with the day of the first opportunity to pass it greater than then the answer for the day is false Next while there exist exams having only one possibility to pass them because of the upper bound of the maximum possible day or constraints imposed by the other exams we choose this day for this exam and continue after choosing such day there can appear some new exams with the same property Now there are no exams having only one day to pass them Let s take a look on the graph where vertices represent days and edges represent exams the edge between some vertices and exists iff there is an exam with the first day to pass it equal to and the second day to pass it equal to Let s remove all the exams for which we identified the answer Now let s take a look on the connected components of this graph and analyze the problem which we have now Our problem is to choose exactly one vertex incident to each edge of the connected component such that no vertex is chosen twice and we have to do this for all the connected components we have Let be the number of vertices in the current connected component and be the number of edges in the current connected component The answer for the connected component is true iff for obvious reasons There is very easy constructive method to see how we can do this If then the current connected component is a tree Let s remove some leaf of this tree and set it as the chosen vertex for the edge incident to this leaf and remove this edge too If then let s remove all leaves as in the algorithm for the tree For the remaining cycle let s choose any edge and any vertex incident to it set this vertex as the chosen to this edge and remove them Now we have a chain Chain is a tree so let s apply the algorithm for the tree to this chain So if for some connected component holds then the answer for the day is false Otherwise the answer is true Overall complexity because of numbers compressing or using logarithmic data structures to maintain the graph Also there is another solution which can be too slow I don t know why it works It is well known fact that if we will apply Kuhn algorithm to the some bipartite graph in order of increasing indices of vertices of the left part then the last vertex in the left part of this graph which is in the matching will be minimum possible Oh that s what we need Let the left part of this graph consist of days and the right part consist of exams The edge between some vertices from the left part and from the right part exists iff is one of two days to pass the exam Let s apply Kuhn algorithm to this graph considering days in increasing order The first day when matching becomes all exams are in the matching will be the answer I don t know its complexity really Maybe it works too fast because of the special properties of the graph If someone can explain in which time it works I will very happy 
1434,The author solution for this problem uses dynamic programming I think that this problem can t be solved by greedy ideas Let s calculate two dp s z1i is the answer to the problem if all numbers less than ai are already printed but the others are not and z2i is the answer to the problem if all numbers less than or equal to ai are already printed but the others are not Let s denote dij the least distance between i and j on the circular array and odij is the distance from i to j in clockwise order Easy to see that z2i minj zj dij for all j such that the value aj is the least value greater than ai Now let s calculate the value z1i Consider all elements equals to ai in one of them we are If there is only one such element then z1i z2i Otherwise we have two alternatives to move in clockwise or counterclockwise direction Let we are moving in clockwise direction the last element from which we will write out the number would be the nearest to the i element in counterclockwise direction let s denote it u Otherwise at last we will write out the number from the nearest to the i element in clockwise direction let s denote it v Now z1i min z2u odiu z2v odvi Easy to see that the answer to the problem is mini z1i dsi over all i such that ai is the smallest value in array and s is the start position Additionally you should restore the answer To do that on my mind the simplest way is to write the recursive realization of dp test it carefully and then copy it to restore answer see my code below Of course it s possible to restore the answer without copy paste For example you can add to your dp parameter b which means it s need to restore answer or not Complexity O n2 Code 
1435,The first thing to come to one s mind is dynamic programming on a trie The most naive of the solutions take where is the total length of strings I ll introduce the faster approach Let be the solution for subtree of the vertex with buttons remaining and is the closest ancestor vertex with the button used in it This dp will be recalced via the other dp Let be the same thing as but only first children of is taken into consideration and doesn t have a button in it Give buttons to the current child then update with will then have two options for having button in it and for not having button in it has transitions and states has total transitions and also states 
1436,Let s solve the task as if there are no updates This can be done with a pretty straightforward dp is the number of pairs such that the result of the strange addition of and is the prefix of of length From each state you can add a single digit to and to at the same time You can either go to and multiply the answer by the number of pairs of digits than sum up to Or go to and multiply the answer by the number of pairs of digits than sum up to Note that no pair of digits can sum up to a three digit value so it makes no sense to go further Let s optimize this dp with some data structure Segment tree will work well Let the node store the number of ways to split the segment into blocks of size or so that both the leftmost character and the rightmost character are not taken into any block the leftmost character is taken into some block and the rightmost character is not taken into any block the leftmost character is not taken into any block and the rightmost character is taken into some block both the leftmost and the rightmost characters are taken into some blocks This structure makes the merge pretty manageable You should glue up the segments in such a way that all the middle characters are taken into some block either in separate blocks in their own segments or into the same block of length The answer will be in the root of the tree in a value such that both characters are taken The update in the segment tree will still work in Overall complexity 
1437,The naive version of the solution is just dynamic programming let be the minimum cost of removed elements or the maximum cost of remaining elements if we considered first elements of and the resulting sequence maps to the first elements of There are two versions of this solution both working in calculate this dp as it is so there are states and transitions from each state ensure that the th element is taken into so there are states since each element appears in exactly once the second state can be deduces from the first one but up to transitions from each state It turns out that we can optimize the second approach Let s calculate the values of in ascending order of first of all we calculate the values of such that then transition into states such that and so on Calculating for is easy since the first element of is always the first element of we should delete all elements before the th if we want it to be the first element in So if is the maximum possible sum of costs of remaining elements if we considered the first elements of and the th element gets included in then for indices such that Okay now let s consider advancing from to If we want to go from to such that and we should leave the element in the array and delete some elements between indices and Which ones should be deleted First of all they are all elements with negative deletion cost but we should also get rid of all elements which could replace in that is all elements that are greater than So the remaining elements are which have and and we should be able to compute the sum of such elements Even if we manage to do it in which is possible there may be up to possible pairs of and to consider The easiest way to get rid of that is to sort all occurences of and and process them in ascending order maintaining the best that was already met That way each of the elements of will be considered at most twice so this solution runs in We know how to calculate the values now but how to determine the answer We should consider all values of such that and delete all elements with negative costs and all elements that are greater than from the suffix so this is another query of the form compute the sum of over which have and The most straightforward way to process them in is to use a persistent segment tree but since does not decrease in these queries as we process them we may maintain the elements we are interested in with a much simpler data structure for example Fenwick tree 
1438,We will model the problem as the minimum cut in a flow network Build a network as follows create a source node a sink node and a vertex for every number from to Let s say that we are going to find the minimum cut in this network and the vertices belonging to the same cut part with represent the numbers that are taken into the answer Using the edges of the network we should model these constraints taking an element that depends on another element should force us to take as well taking an element with should add to our score taking an element with should subtract from our score Constraint can be modeled in the following way for every pair such that element depends on element and add a directed edge with infinite capacity from to That way if is taken and is not the value of the cut will be infinite because of this edge and this cut cannot be minimum Constraint is modeled in the following way for every such that add a directed edge with capacity from to That way if we take some element with into the answer is added to the value of the cut And for constraint for every such that add a directed edge with capacity from to That way if we take some element with is added to the value of the cut It s now easy to see that the answer is since it is exactly the sum of elements that were taken for positive elements we add them all up and then subtract the ones that don t belong to the answer for negative ones we just subtract those which belong to the answer To find a minimum cut just run maximum flow in this network There s one caveat though If for example all are equal or many are divisible by many other values in this network can contain edges To reduce the number of edges let s see that if for some index there exist two equal divisors of to the left of it let s say that these divisors are and then we only need to add an edge from to because taking also should force taking into the answer So for every divisor of we are interested in only one closest occurrence of this divisor to the left and we need to add a directed edge only to this occurrence and ignore all other occurrences That way for every vertex we add at most edges to other vertices where is the number of divisors of It can be proven that any maximum flow algorithm that relies on augmenting paths will finish after iterations in this network so it won t work longer than and both and are proportional to so any maximum flow solution will run in 
1439,Let be the length of number Then Let then and and we get Note that the right part is divisible by so the left part should as well Then we can see that should be divisible by since Let s say then divide both sides by We get Let s rearrange it and get the following Since is integer then should be integer In other words we can define such that is divisible by and is divisible by and is Since has a very special structure let s iterate over all lengths and all divisors of for a fixed Let s say and Then For a fixed and we know but don t know So let s just iterate over all possible and let s also iterate over all since is small since is a divisor of Next step is following let s look at previous equation but modulo Since then there is a solution to the previous module equation or Now we know exact value and so now the time to guess let s recall that Since we fixed then or Let s name the left border as and right border so inequality earlier is But we can make constrains even tighter note that but lately we said that or So or should be divisible by In total we can iterate in range with since we are interested only in divisible by Now we have enough variables to construct a triple we know and so If is already big we can skip that candidate Also we can calculate and check that pair is valid i e is really minimum possible We can understand it by checking that otherwise we can reduce by Value can be calculated from one of the formulas above as After that we calculate and check that is not too big Value can be calculated as At last we should check that the given triple satisfy all remaining assumptions we made is not too big is really and length of calculated is exactly we fixed If it s all fine then we found a correct triple It looks like thanks to all previous checks the triple we found is unique but just for safety let s push them all in one set to get rid of copies Calculating complexity is not trivial but let s note something the total number of divisors of for all is around For a fixed pair we iterate over all from to and for each we iterate from to but it s easy to prove that the total number of pairs is at most Now the last cycle iteration of with step where If we assume that is quite small then is proportional to and pairs are something like harmonic series with complexity In total the complexity is around 
1440,The crucial observation that we have to make is that the character that initially occupied the position cannot occupy the positions to the left of we can shift some character two positions to the left using a combination of operations but we can t go any further So the prefix of the first characters of the resulting string can only be affected by the prefix of the first characters of the initial string Let s use the following dynamic programming to solve the problem let be the that we can obtain by applying operations to the first characters that is is the answer to the problem if we consider only first characters of the original string The transitions here are a bit tricky If we apply the operation or to the character then where is the character we get when we apply the aforementioned operation to that character is a bit more complicated we have to insert the character just before the last character of Modeling that we can apply the operation is likely the most complex transition in our dynamic programming First of all we can t just make an update to or since it leads us to a situation where we can still apply some operations to the prefix we have built Instead we have to consider the operation we will be able to do with the character Using another operation is useless since the result is like performing no operations with those two characters at all so we have to consider two options for operation with the th character or whichever is better or In the first case we update by appending the resulting two characters to the one that we get when we change and the one that initially was In the second case things are a bit trickier but still not very complicated the character that was moves two positions backward so it is inserted right before the last character of and then we append to the string we get So there are four transitions we have to make a transition from to that models the case when we apply or to the th character a transition from to that models the case when we apply to the th character a transition from to to model the operations or a transition from to to model the operations Overall complexity is but it can be improved to with some complicated data structures like persistent segment tree with hashes to compare strings and append characters to them in 
1441,Let be the answer for the prefix of consisting of first characters How can we update from Suppose that we try to represent the substring from index to index indexed by writing it as some other string times Then this string has to be the smallest period of the substring and where is the length of the smallest period The smallest period of some string can be calculated as follows compute prefix function for and if is divisible by is the last value of prefix function then the length of the smallest period is if not then the length of the smallest period is This allows us to write a solution with complexity To improve it to we can use the fact that when we compute prefix function for some string we compute it for every prefix of this string So to obtain all values of we need in our solution we only need to compute prefix functions for every suffix of 
1442,Disclaimer the model solution is very complicated compared to most participants solutions Feel free to discuss your approaches in the comments First of all it s easy to determine when two strings cannot be made equal using these operations it s when their multisets of characters differ So we divide the strings into different equivalence classes and for any pair of strings from different classes the answer is For any pair of strings from the same class the answer is either or since operations are always enough to make the strings from the same equivalence class equal we just sort both of them Okay now for each class we have to calculate the number of pairs of strings with the distance equal to Okay suppose you have two strings and and you want to make them equal using one operation Suppose that lexicographically Since applying an operation can t result in getting a lexicographically larger string we should apply the operation on the string not Suppose we choose a substring of the string and sort it All characters to the left of position and to the right of position are untouched and all characters in are ordered in non descending order so in order to transform into we should choose a subsegment such that all characters outside this segment are the same in both strings and the substring of is sorted So the best way to choose a subsegment is to compute the longest common prefix of and the longest common suffix of and and try sorting everything in the middle in This gives us a solution in for a pair of strings we can check that one of them can be transformed into the other in To do so we need to build some data structure allowing to query longest common prefixes suffixes in a trie with LCA or precalculating LCP and building a sparse table of them can do the trick furthermore we want to be able to check if some subsegment of some string is sorted in but precalculating them is quite easy So we have a solution that works if the strings are long in the model solution this approach is used on classes having not more than strings The second approach can be used on classes having many strings If the number of strings is big it means that they are short so we can do the following thing for each string iterate on the subsegment we will sort and check if the resulting string exists The model solution uses some very complicated data structures to implement this but I believe that it s quite easy to get this approach working using string hashes The only dangerous thing in the second solution you have to consider is that choosing different substrings to sort may result in getting the same resulting string One good way to deal with this is to ignore some substrings if sorting them doesn t change the leftmost or the rightmost character in the substring for example if we sort the substring in the string the character in the beginning of this substring is unchanged so we can get the same result by sorting So we consider sorting the substring only if it changes both the first and the last characters of the substring Okay so we have two approaches one works well with a small number of long strings and the other works well with a big number of short strings We can choose which of them to run depending on the size of the equivalence class we are considering and this idea gives us a working solution 
1443,Let s get rid of the queries for deleting a string There are no strings that will be added two times so we can calculate the answer for the added but not deleted strings and for the deleted separately and subtract the second from the first to get the answer So we can consider that there are no queries of deletion Now let s use Aho Corasik algorithm The only difficulty is that the strings are adding in online mode but Aho Corasik algorithm works only after adding all the strings Note that the answer for the given set of strings equal to the answer for any part of the set plus the answer for the remaining part Let s use the trick with converting the static data structure Aho Corasik in this case to the dynamic one For the set of strings let s maintain a set of no more than sets of the strings with sizes of different powers of two After adding new string we should move the sets from the lowest powers of two to the largest until we got an invariant set of sets Easy to see that each string will be moved no more than times so we can process each query in time 
1444,The main idea is to use a two dimensional data structure one dimension is depth of vertices and other dimension is the time we entered a vertex during DFS Model solution uses sparse table for these purposes First of all let s renumerate the vertices so we can handle them easier We run DFS from the root and then sort the vertices by their depth and if depths are equal by time we entered them in DFS Then we renumerate vertices in this sorted order We need to denote some functions in order to continue depth of vertex in the tree the time we entered during DFS the time we left during DFS For each depth we can store a sorted array of vertices belonging do this depth This will allow us to build an auxiliary sparse table where is such vertex that is minimal among all vertices that meet first two conditions We also need a second sparse table where is iff is minimal among all vertices that meet first two conditions These sparse tables can be built using binary search in arrays we created for depths Okay why do we need them To create a third sparse table that will process the queries themselves the minimum value of among vertices such that belongs to blocked subtree of some vertex with index included in This table can be built backwards with the help of auxiliary tables So how do we answer the queries We need to look at the binary representation of and do something like binary lifting but descending the tree instead of ascending and maintain the leftmost and the rightmost vertices on current depth which belong to the subtree we are interested in and make queries to on the segment between these two vertices This solution works in but unfortunately or fortunately to some participants we made the time limit too high so the structures that require time to process each query such as two dimensional segment trees might also get AC 
1445,At first let s notice that this function converges very quickly for values up to it s at most steps Now we should learn how to skip updates on the numbers and The function values can be calculated from the factorization of numbers in with Eratosthenes sieve Let s write two segment trees one will store maximum value on segment the other will store the sum When updating some segment check if its maximum is greater than Updates are done in the manner one can usually write build function you go down to the node corresponding to the segment of length and update the value directly Overall complexity as we access any segment no more than times 
1446,Let s intruduce the following dynamic programming approach is the smallest number of elements of type page can end with If we learn to recalculate it the answer will be if or I will try to prove it on the fly Let s look into the constructing of each page from the following perspective I ll consider the cases when the current page ends with tables and the previous page ends with either tables or formulas Let s write down all the tables and then put formulas as separators to them I will call number of tables on the end of the previous page the number of formulas on the end of the previous page the number on tables on the current page and the number of formulas on the current page In the case with tables on the end of the previous page the smallest number of separators you can have is Moreover if you have you can put one of the formulas right before the end of the page ending it with table The only case is when there are too many separators should be less or equal to you can put up to separators before each table The case with formulas on the end of the previous page isn t that different The smallest number of separators is and the limit to the number of separators is you can t put separators before the first table as in the first case the maximum number to that position is determined by the previous page Now let s take a look at resulting expressions You can notice that lowering can only decrease the lower bound on the number of separators and lowering can only increase the upper bound on the number of separators That shows that minimizing the values in is always profitable Overall complexity 
1447,First of all let s try to find the best strategy to play minions All minions should be summoned if someone is not summoned summoning and deleting it won t make the answer worse the resulting number of minions should be exactly if it is less then we didn t need to delete the last deleted minion Furthermore if some minion should be deleted we can delete it just after it is summoned All these greedy ideas lead to the following structure of the answer we choose minions and summon them in some order we choose minions which will be summoned and instantly deleted we summon the remaining minion Let s analyze how these minions affect the answer The first minion has power and does not give bonus to anyone the second one has power and gives bonus to one minion and so on the th minion from the first group adds to the answer Minions from the second group buff minions each so they add to the answer and the last minion adds Let s unite the first group and the last minion then we will have two groups of minions those which are destroyed the second group and those which are not destroyed the first group From there we will have two possible ways to finish the solution there are minions and positions for them and for each pair minion position we may calculate the value this pair adds to the answer After that we should assign each monster a position in such a way that each position is chosen exactly once and the sum of values is maximized It can be done with mincost flows or Hungarian algorithm the minions from the first group should be played in non descending order of their Let s sort all minions by and write the following dynamic programming is the maximum answer if we considered first minions and of them were assigned to the first group Since the minions are sorted by whenever we add a minion to the first group it should add exactly to the answer and increase by and if a minion is added to the second group the answer is increased by 
1448,Initial portals divide the path from to into separate sections If we place a new portal between two given ones it only affects the section between these two portals Let s suppose we want to place new portals into a section of length This will divide it into sections and it s quite easy to prove that these sections should be roughly equal in size to prove it we can show that if the sizes of two sections differ by more than the longer one can be shortened and the shorter one can be elongated so the sum of squares of their lengths decreases So a section of length should be divided into sections of length and sections of length Let s denote the total energy cost of a section of length divided by new portals as since we divide it in roughly equal parts it s easy to see thatThe key observation that we need to make now is that i e if we add more portals to the same section the energy cost change from adding a new portal doesn t go up Unfortunately we can t give a simple strict proof of this fact but we have faith and stress this would be easy to prove if it was possible to place portals in non integer points we could just analyze the derivative but in integer case it s way more difficult Okay what should we do with the fact that for a section of length The main idea of the solution is binary search over the value of i e we use binary search to find the minimum possible change that a new portal would give us Let s say that we want to check that using the portals that give the cost change is enough then for each section we want to find the number of new portals such that but we can use another binary search to do that For a fixed integer we can calculate not only the number of new portals that we can add if the cost change for each portal should be at least but also the total cost of the path after these changes let s denote as the total cost of the path if we place new portals until the cost change is less than and is the number of portals we will place in that case We have to find the minimum value of such that Now it looks like is the answer but this solution gives WA on one of the sample tests The key observation we are missing is that for the value we don t have to add all of the portals that change the answer by we might need only some of them To calculate the answer let s compute four values If we place portals and add new portals one by one until the total cost becomes not greater than the cost change from each new portal will be equal to or just if we consider the fact that we start using the portals which change the cost by So we can easily calculate how many more additional portals we need to add if we start from portals and cost The total complexity of our solution is we have a binary search over the cost change for each new portal and for a fixed cost change to determine the number of portals we place in each section we run another binary search in every section separately 
1449,At first let s understand which trees are good For this let s consider some vertex we denote its segment as which is not a leaf Also let s consider some adjacent vertex we denote its segment as which also is not leaf It is claimed that segment can t be inside segment it s means and vice versa It s true because if segment is inside the segment then some vertex adjacent with also will be adjacent with So any non leaf vertex can be adjacent with at most non leaf vertexes Therefore good tree is a path with a leafs adjacent to this path So all the have to do it s find the such subtree of maximum size We can do it by subtree dynamic programming At first let chose the root of the tree some not leaf vertex Let be the answer for the subtree with root in and dp v 1 be the answer for the subtree with root in if we already took and its parent to the answer It can be calculated as follows there is a first maximum of all and is a second maximum and is a degree of vertex 
1450,At first let s represent permutations in the next form We assign to all numbers from to random 128 bit strings so the th number gets the string Then the permutation of length can be hashed as where is bitwise exclusive OR for example This representation is convenient because if we have two sets of numbers with a total number of elements equal to let s represent them as and we can easily check whether their union is a permutation of length condition must be hold Let s denote as Now let s iterate over position such that and calculate the number of permutations that contain this element To do it let s iterate over the right boundary and suppose that maximum element of permutation and its length at the same time is one of positions If it s true then the subpermutation should be on the positions And to check that this segment is a subpermutation we should just compare and Thus we will calculate all permutations in which the position of the maximum is to the right of the position of the To calculate all permutations we need to reverse array and repeat this algorithm and then add the number of ones in the array 
1451,Firstly let s find any spanning tree and root it at any vertex For each vertex we calculate the distance to the root let it be for vertex There are no more than edges that don t belong to the tree For each of these edges let s run Dijkstra s algorithm from some vertex incident to this edge Suppose we are answering a query If the shortest path between these vertices passes only along the edges of the tree then it can be calculated by the formula where is the lowest common ancestor of vertices and You may use any fast enough algorithm you know to calculate Otherwise there exists at least one vertex such that we ran Dijkstra s algorithm from it and it belongs to the shortest path Just iterate on every vertex for which we ran Dijkstra and update the answer with the value of where is the shortest path to the vertex from the fixed vertex 
1452,Statement the function of the sum is a polynomial of degree over variable This statement can be proved by induction to make step you should take the derivative Denote the value of the sum for We can easily calculate the values of for from to in time If then we already have the answer Otherwise let s use Lagrange polynomial to get the value of the sum for the given value The Largange polynomial have the following form In our case and To calculate in a linear time we should use that for all It s help us because with that property we can recalculate the inner product for from the inner product for simply by multiplying by two values and dividing by two values So we can calculate the sum in linear time over 
1453,Imagine there were no constraints of the second or the third types Then it would be possible to solve the problem with some greedy algorithm Unfortunately when both these constraints are present it s not immediately clear how to adapt the greedy Dynamic programming is probably also out of question because you can t maintain all possible cuts between equal values on each prefix Thus let s try to make a graph problem out of this Who knows maybe a flow or something else could work Create nodes for each position Let the th of them on the th position represent the condition of kind is equal to Then all constraints can be described as edges on this graph Binary variables restrictive edges Surely this is 2 SAT Connect the pairs of values that satisfy each constraint Add the edges between the adjacent positions to enforce the restriction on the non decreasing order Prohibit each position to be assigned to multiple values Force each position to be assigned at least one value Huh it s not that easy That s where the 2 SAT idea fails We want the conditions of form But that is not allowed since 2 SAT has to have two variables in a clause That s where the main idea of the problem comes up Instead of making our nodes represent let s make them and try building the graph again If then all nodes for will be true and the rest will be false So if is false then is false That will enforce the validity of the nodes themselves First the order If is true then is true The first type of constraints is basically the same as or For our conditions it s rather not or The second type of constraints Let be greater than or equal to some Then for this constraint to hold should be no greater than Thus if is true then should be false Same for and swapped The third type of constraints is similar Let be less than or equal to some Then for this constraint to hold should be greater than or equal to Thus if is false then should be true Same for and swapped And that s it Solve the 2 SAT and restore the answer I can advise making not but actually nodes for and force the values to be between and That will simplify the checks while adding the constraints Overall complexity 
1454,Let s start thinking about the problem from the easy cases How to solve the problem fast if all towers have full mana We can store prefix sums of their capacities and find the first tower that doesn t get drained completely with a binary search Let s try the opposite How to solve the problem fast if all towers were drained completely in the previous second It s the same but the prefix sums are calculated over regeneration rates What if all towers were drained at the same second earlier than the previous second and no tower is fully restored yet It s also the same but the regeneration rates are multiplied by the time passed since the drain What if we drop the condition about the towers not being fully restored How would a data structure that can answer prefix sum queries work It should store the total mana capacity of all towers that are full Then mana regeneration rates for all towers that aren t If these are kept separately then it s easy to obtain the prefix sum by providing the time passed This will be total capacity plus total regeneration rate multiplied by the time passed How to determine if the tower is fully restored since the drain or not That s easy For each tower we can calculate the number of seconds it takes it to get restored from zero That is Thus all towers that have this value smaller than the time passed won t get restored All the rest will Unfortunately in the actual problem not all towers were last drained at the same time However it s possible to reduce the problem to that Store the segments of towers that were drained at same time There are also towers that weren t drained completely but they can be stored as segments of length too When a monster comes it drains some prefix of the towers completely and possibly one more tower partially In terms of segments it removes some prefix of the them and possibly cuts one Then it creates a segment that covers the prefix and possibly a segment of length with a partially drained tower So each monster creates segments and removes no more segments than were created Thus if we were to process each creation and removal in some then the complexity will be All towers on each segment have the same time passed since the drain We want to query the sum on the entire segment If it is greater than the remaining health of the monster we want to find the largest prefix of this segment that has a smaller or equal sum than the monster health Given time passed let s learn to query the range sum If we knew the queries beforehand it would be easy Initialize a segment tree as if all towers are completely restored Then make events of two kinds a tower with restore time and a query with time Sort them in the decreasing order and start processing one by one When a tower event happens update a single position in the segment tree from capacity to regeneration rate When a query event happens find the sum Since the queries are not known beforehand make that segment tree persistent and ask specific versions of it If a segment of towers was last drained at time and the query is at time then you should query the segment tree in version Obviously you can store not all versions but only ones that have some tower change Moreover it s more convenient to make one version responsible for one tower update Then you can lower bound the array of sorted to find the version you want to ask at To determine the largest prefix of this segment that has a smaller or equal sum than the monster health you can either binary search for or traverse the segment tree for The time limit might be a little tight for the first approach but it can still pass Overall complexity 
1455,The problem has a rather obvious naive solution in for each starting city but it s too slow So we have to speed up this solution somehow Binary lifting is one of the options but here we have a problem that it is difficult to connect two consecutive groups of steps because after the first group there is a certain amount of fuel left Therefore one of the solutions is to switch to such steps that liters of fuel remains after it Let s consider one of such greedy steps Suppose we are in the city with fuel then the following situations are possible let s buy exactly liters of fuel to reach the next city then the step length is and the cost is and where is the maximum number such that i e the number of consecutive cities with the cost let s buy exactly liters of fuel to reach the next city then the step length is and the cost is and let s find a minimum such that and i e such that you can reach it by spending all of liters let s buy exactly liters with the cost in the city then the step length is and the cost is let s buy liters with the cost in the city and the remainder of liters with the cost in the city then the step length is and the cost is Now using these types of steps we maintain an important invariant after each step the amount of fuel is So we can easily calculate the total distance and cost for several consecutive steps Which leads us to a solution using binary lifting for each city calculate the length and cost of the path with for all up to greedy steps And then using this data we can calculate the answer for each starting city in 
1456,When a problem asks us to calculate the number of combinatorial objects that meet some constraints we can sometimes use inclusion exclusion formula Let s try to apply it in this problem We could use constraints that should not be violated The th constraint is formulated as follows there will be a constraint of this type for each Suppose we violated of these constraints and have chosen which constraints to violate then the number of colorings that meet these violations is for vertices the colors on them depend on some other independent vertices so we can assign only colors for independent vertices So the answer can be calculated as follows where is the number of ways to choose constraints to violate One initial guess how to calculate is that as it would be calculated in other more usual inclusion exclusion problems Unfortunately in this problem the constraints we violate are not independent For example if a vertex has several sons we can violate the constraint only on at most one edge leading from a vertex to its son simultaneously we cannot violate two or more such constraints Let s take care of this issue as follows we can write a dynamic programming of the form is the number of ways to process first vertices of the tree and choose exactly edges leading from these nodes to their sons so that no vertex has more than one edge leading to its sons chosen Then is exactly the number of ways to choose edges in the tree so that no vertex has more than one chosen edge leading to its sons and that will be equal to We can calculate this dynamic programming in a knapsack fashion in but it is too slow Instead let s optimize this knapsack DP with FFT for each vertex introduce a polynomial where is the number of children of the vertex Coefficients of this polynomial for the first vertex are the values of coefficients of the product of this polynomial with the polynomial for the second vertex are the values of and so on to obtain the values of we have to multiply all these polynomials and using FFT divide and conquer we can do it in 
1457,The solution is to choose some diameter of given tree then delete all the leaves which don t belong to diameter iteratively and then delete the diameter I e while tree includes vertices aside from the ones forming diameter we choose some leaf increase answer by the length of the path between this leaf and farthest endpoint of the diameter from this leaf and delete this leaf Then while tree consists of more than one vertex we choose two endpoints of diameter increase answer by the length of the path between it and delete any of them At first we need to prove that we can choose any diameter It can be proved by next fact we can find the diameter by two graph traversals DFS BFS we need to find farthest vertex and then again find farthest vertex from found farthest vertex given path is a diameter of the tree It means that for each vertex that doesn t belongs to the diameter we will add maximal possible path length by the algorithm described above And finally obviously that at some moment we need to delete the diameter and there is no way to do this better than we do it in described solution 
1458,A naive solution to this problem would be to implement a recursive function which answers each query let be the answer to the query we can calculate it as since for each child of vertex we either delete it and change the score by or choose to let it remain and this increases the score by Unfortunately it is too slow Let s try to optimize it First of all since if we choose the exact same subset of vertices to delete for the query as we ve chosen for the query our score won t decrease Using this fact we can show that if it s optimal to remove some vertex in the query it s also optimal to remove a vertex in the query because it s optimal to remove vertex if and if this condition holds for some value of then it holds for each smaller value of Let be the maximum value of when it s optimal to remove the vertex We will calculate these values for all vertices of the tree using an event processing method we ll process the values of from to and use a set or a priority queue to store events of the form at the value vertex becomes optimal to delete This set priority queue should sort the events in descending order of the value of and in case of ties in descending order of depths of the vertices to make sure that vertices with the same value of are processed from bottom to up Let s analyze the implementation of this process more in detail For each vertex we will store two values the number of vertices we should remove from its subtree and the number of children this vertex will optimally have Using these two values we can easily calculate the value of for a vertex When a vertex is removed that is the event corresponding to this vertex is processed these values for this vertex should be added to its current parent we can use DSU to find the current parent easily for example and don t forget that the number of vertices we have to remove for this new parent also increases by then we recalculate the value of for the current parent and change the event corresponding to this current parent note that the value of for the current parent shouldn t be greater than the value of for the vertex we ve deleted Okay this allows us to calculate when it s optimal to delete each vertex But how do we answer queries One of the ways to do this is to process queries in the same event processing algorithm and for every value of we first remove the vertices with then process the queries There is an issue that when we remove a vertex it can affect the answer not only for its current parent but also for the vertices that could be its parents but are already deleted to handle this instead of adding the values of the deleted vertex only to the values of its current parent we perform an addition on the whole path from the vertex to the current parent excluding the vertex itself This path addition can be performed with a Fenwick or Segment tree over the Eulerian tour of the tree and this yields a compexity of though with a high constant factor 
1459,First bonus solution implement idea from Blogewoosh 6 Time complexity will be somewhat and space complexity is Honest solution Note that for each truck lower bound on the answer is where is optimal partition of on segments partition which minimize maximum length of segment and doesn t depend on of truck So it enough to calculate optimal partition of segment on segments Let be position where last segment starts in partition with value Note that On the other hand But and then is somewhat convex Finally best is no more than And we can look at as second pointer along with as first pointer So we can for each move while answer relaxes while answer is decreasing or staying same In result for each and there will be operations in total Optimizing memory consumption is easy if we notice that we can iterate over but not save it as state of dp In the end time complexity is and space complexity is 
1460,First let s solve the following problem we need to maintain a multiset of numbers and process queries of 3 th types add a number to the multiset remove one occurrence of a number from the multiset it is guaranteed that it exists calculate the mode on this multiset To do this we will maintain the array cnt i the frequency of i in the multiset Now the mode is the position of the leftmost maximum in this array There are many ways to search for this position we will use the following we will build a sqrt decomposition on the array cnt for a block we will maintain a maximum on this block and an array c i the number of positions j in this block such that cnt j i Since in each of the initial requests cnt i changes by no more than 1 the maximum in the block also changes by no more than 1 and using the c array it is easy to update it after each query Now to find the mode the position of the leftmost maximum in the cnt array you first need to go through all the blocks to find the value of the maximum and the leftmost block in which this maximum occurs then iterate over the desired position in this block Thus queries to add and remove an element run in O 1 and a mode search query runs in O sqrt A where A is the number of possible distinct values in a given problem A 2 cdot 10 5 Now let s get back to the problem itself Let s build a Preorder traversal of our tree Let tin v be the position in the 0 indexing of the vertex v in the Preorder traversal tout v be the size of the Preorder traversal after leaving the vertex v Then the half interval tin v tout v of the Preorder traversal represents the set of vertices of the subtree of the vertex v For the i th query we will consider tin v i le tin u i Let sz v tout v tin v be the size of the subtree of v B be some integer then v will be called light if sz v B and heavy otherwise A query i is called light heavy if v i is a light heavy vertex We will solve the problem for light and heavy queries independently Let s use the small to large technique and maintain the multiset described at the beginning of the solution Let at the moment we have this multiset for the vertex w Let s answer all light queries for which u i w To do this take all the vertices from the subtree of v i and add the numbers written on them calculate the mode on the current multiset this will be the answer to the query and then delete the newly added vertices In the standard implementation of small to large you need to maintain several structures at the same time which in this case is impossible due to the fact that each of them takes up O A sqrt A of memory This problem can be avoided for example as follows before constructing the Preorder traversal for each vertex v put its heaviest son at the head of the adjacency list Then it will be possible to iterate over the vertices in the order of the Preorder traversal preserving the asymptotics This part of the solution runs in O n log n qB q sqrt A Let s divide all heavy vertices into non intersecting vertical paths so that two vertices from the same path have subtrees that differ by no more than B vertices and the number of the paths themselves is O frac n B To do this let s take the deepest of the unused heavy vertices and build one of the desired paths going up to the parent while the first of these conditions is met Then we mark all the vertices in this path as used and start over We will continue to do this while there are still unused heavy vertices It is easy to see that the resulting paths are vertical and the subtrees of two vertices from the same path differ by no more than B by construction Let s prove that there are not very many of these paths To do this we will understand in which cases the path breaks If the current path contains a root then since the root has no parent the path will terminate Obviously this path is only 1 If the parent of the last vertex of the path has only one heavy child this last vertex itself From the construction a break means that the number of vertices in this path plus the number of children outside the heaviest son subtree of the parent of the last vertex and each vertex of the path except for the initial one is more than B in total but each of the counted vertices can be counted in only one of such cases that is the number of paths that terminate in this way does not exceed frac n B If the parent of the last node has more than one heavy child Let s leave only heavy vertices in the tree since the parent of a heavy vertex is a heavy vertex too it will indeed be a tree or an empty graph This tree contains at most frac n B leafs Calculating the total degree of the vertices of this tree we can see that there are at most frac n B additional sons all sons of a vertex except one This means that the number of paths terminating in this way is at most frac n B We got that the paths are O frac n B Let s divide the heavy queries according to the paths where the v i is situated We will answer queries with vertices v from the same path together We will do it similarly to the case with light queries with minor differences at the very beginning we add to the multiset all the vertices of the subtree of the initial vertex of the path and mentally remove these vertices from the subtrees of v i vertices Everything else is preserved Let s calculate how long it takes add all vertices from one subtree O n small to large O n log n to answer one query due to condition on vertices from one path we have to add at most B vertices Since there are only O frac n B paths the whole solution will take O frac n 2 log n B qB q sqrt A We take B sqrt frac n 2 log n q and counting n approx q we get B sqrt n log n and total running time O n sqrt n log n n sqrt A As already mentioned a subtree corresponds to a segment of the Preorder traversal so 2 subtrees are 2 segments We will maintain the data structure described at the beginning on the sum of 2 segments By moving the boundaries of these segments you can move from one query to another as in Mo s algorithm It remains only to sort the queries Heavy queries are sorted first by path number of v i then by tin u i Light queries are sorted only by tin u i but here you can t just move the segment of the v subtree you need to rebuild it for each query Solve this problem for two subtrees and a path connecting the roots of these subtrees This solution partially intersects with the one described by the problem author We will use the same data structure for maintaining the mode and we will also use DFS order of the tree but before constructing it we will reorder the children of each vertex so that the heaviest child is the first one Let tin v be the moment we enter the vertex v in DFS and tout v be the moment we leave the vertex As usual the segment tin v tout v represents the subtree of vertex v and we can change the state of the structure from the subtree of the vertex x to the subtree of the vertex y in tin x tin y tout x tout y operations Let this number of operations be cost x y Let v 1 v 2 dots v n be the DFS order of the tree We can prove that cost v 1 v 2 cost v 2 v 3 dots cost v n 1 v n is estimated as O n log n if we order the children of each vertex in such a way that the first of them is the heaviest one Let s analyze how many times some vertex v is added when we go in DFS order and maintain the current set of vertices When some vertex is added to the current subtree this means that the previous vertex in DFS order was not an ancestor of the current vertex so the current vertex is not the first son of its parent So the size of the subtree of the parent is at least 2x the size of the current vertex Since the path from v to root can have at most O log n such vertices then the vertex v is added at most O log n times Okay how do we use it to process queries efficiently Let s say that the vertex v i the i th vertex in DFS order has coordinate equal to cost v 1 v 2 cost v 2 v 3 dots cost v i 1 v i Let this coordinate be c v i Then if we have the data structure for the query x 1 y 1 and we want to change it so it meets the query x 2 y 2 we can do it in at most c x 1 c x 2 c y 1 c y 2 operations which can be treated as the Manhattan distance between points c x 1 c y 1 and c x 2 c y 2 Do you see where this is going We can map each query x y to the point c x c y and then order them in such a way that the total distance we need to travel between them is not too large We can use Mo s algorithm to do this Since the coordinates are up to O n log n but there are only q points some alternative sorting orders for Mo like the one that uses Hilbert s curve may work better than the usual one 
1461,Let s use contribution to the sum technique to simplify the problem Instead of counting the number of colors that occure only once for each path let s for each color count the number of paths that contain this color exactly once Now we can solve the problem independently for each color and sum up the answers The first intended solution was the following So we want to calculate the answer for some color Mark all edges of color as good the rest are bad Then we can calculate the number of paths up to vertex such that they contain either or good edges The transitions should be pretty easy and the answer should be updated when you consider gluing up paths from different children in each vertex Obviously this is per color so overall However we can only calculate this dynamic programming as easily on a virtual tree of vertices adjacent to all good edges How to calculate the dp for some vertex First push the paths from all virtual children to That was enough in the dp for the entire tree but now there are also removed vertices that could also have paths starting in them All these paths contain good edges otherwise they would have had virtual vertices on them Their amount is the following the size of the real subtree of minus the sizes of real subtrees of all its virtual children The rest is exactly the same as in the dp on the real tree A little fun trick Usually you want to add lca of adjacent vertices to the virtual tree But that s actually not needed here you can just add the root of the tree and link the vertices without a parent to them That won t change the result of the dp That solution works in or The second intended solution is slower complexity wise but not time wise In the first solution we wanted to leave only the good edges in the tree Here we want to remove only them Consider the resulting connected components What s the number of paths that contain only one of the good edges It s actually the product of sizes of the connected components this edge connects So we want to remove edges add edges and maintain the sizes of the connected components of the tree That s basically the same problem as dynamic connectivity The implementation works well enough 
1462,Let s calculate answer in two steps At first let s calculate for each vertex what we can gain if we must return from subtree of in the end We need only pair of values minimal possible depth we can acquire to move up from subtree of and maximal number of different leaves we can visit Note that this two values are independent since we must return from and if for some child of we can return from it it s profitable to visit and return But if we can t return from so we are prohibited to descent to So number of visited leaves is just a sum of all if Also note that we can always reorder all children in such way that last visited vertex will have minimal So minimal possible depth is a minimum over all At second let s calculate maximal number of different leaves we can visit if we don t need to return from subtree of It can be calculated quite easy using array We just need to choose child we will not return from so from vertex we will take value and from other childen which we can return from value Result complexity is 
1463,Let s try dynamic programming approach to this problem Let be the number of ways to replace all with numbers from to in such a way that array is good and the last number of that array is Let Then initially it s if equals to or However we could include incorrect states such that segment consist of the same value It happens when as we should have at least elements segment has all its elements either equal to or If both of these conditions hold then you should subtract all the bad states from The number of them is 
1464,Notice that if we take offer exactly months before we buy the car it will provide us with money at the time of the car purchase Moreover the only values of that make sense are This means we can immediately solve the problem via an algorithm for the assignment problem such as min cost flow or the Hungarian algorithm This has a runtime of or which manages to fit under the time limit with a good implementation Code 49033783 The better solution is to notice that for all offers where we don t use up all months it s best to sort them by so that the highest values of have the lowest values of This leads to a very nice DP solution 49035446 
1465,Let s design a naive solution first For each of the given triples we have two options either write the string on the tree in the order from to or in reverse order Some options conflict with each other So we can treat this problem as an instance of 2 SAT create a variable for each of the given strings which is true if the string is not reversed and false if it is reversed find all conflicting pairs of options and then run the usual algorithm for solving 2 SAT Unfortunately the number of conflicting pairs can be up to so we need to improve this solution Let s introduce a variable for each vertex of the tree which will define the character we write on it At first it looks like we can t use these variables in 2 SAT since the number of possible characters is not But if a vertex is covered by at least one path in a triple then there are only two possible characters we can write in this vertex either the character which will land on this position if we write the string from to or the character on the opposite position in the string And obviously if a vertex is not covered by any triple we can write any character on it Okay now for each vertex we have two options for a character and Let the variable be true if we write on vertex and false if we write Also for each triple let s introduce a variable which is true if the string is written from to and false if it is written in reversed order If the vertex is the th one on the path from to then we should add the following constraints in our 2 SAT if we need a constraint NOT OR NOT if we need a constraint OR NOT if we need a constraint NOT OR if we need a constraint OR Thus we add at most constraints in our 2 SAT The only thing we haven t discussed is how to actually restore each path from to this can be done either with any fast algorithm that finds LCA or by searching for LCA naively by ascending from one of those vertices until we arrive at the ancestor of another vertex this approach will visit at most vertices Overall this solution runs in 
1466,The key observation is that since is only up to 20 there can t be that many different prime strings total turns out there are only about 2400 for the worst case of So we can generate all of them and perform a DP where our state is represented by the longest prefix of any of the strings we currently match We can do this by building a trie of all of the prime strings We then need to be able to transition around in this trie it turns out this is exactly what Aho Corasick does for us In particular knowing which node of the Aho Corasick tree we are currently at gives us the full information we need to determine whether or not we will match one of the strings after adding more characters later This leads to a fairly simple DP 90977148 
1467,We gave bad constraints to this problem so some participants solved it in time Note that The values can be simply precomputed Also you can notice that the value is equal to depending on the value modulo Let s use Mo s algorithm we should group all the queries to blocks by the left end and sort all the queries in each block by the right end Let be the maximal left end inside the current group then all left ends will be in distance not greater than from and right ends will be in nondecreasing order so we can move the right end by one total we will made no more than movements in each block During moving of the right end inside some group from the value to the value of the current right end we will maintain two tries the first for the values and the second for the values in the first we will maintain the minimal value of in the second the maximal After adding some values to the trie we should find the maximal value that can be formed by the current value To do that we should go down in the first trie maintaining the invariant that in the current subtree the minimal value is not greater than Each time we should go by the bit that is not equal to the corresponding bit in if we can do that otherwise we should go by the other bit In the second trie we should do the same thing with the difference that we should maintain the invariant that the maximal value in the current subtree is not less than the value After moving the right end we should iterate from the left end of the query to and update the answer without adding the current value to the tries Also after that all we should iterate over all the queries and with new empty tries iterate from the left end to add the current values to the tries and update the answer 
1468,Let s introduce the slightly naive solution Iterate over all values for periods and check the possibility of each one being correct The conditions for some period can be formulated the following way is the total length of the string is the number of full periods of length Let s find at least one such pair and such that and the remainder part of the string can be filled with letters A and letters B By easy construction one can deduce that the conditions of and are enough Thus should be greater or equal to and In order to move to the faster solution one should also remember that both remainder parts and should be non negative Let s learn how to solve the problem for the whole range of lengths which all have the number of full periods equal to the same value Let this range be From the aforementioned formulas one can notice that the restrictions on both and don t depend on the length itself but only on value of To be more specific The lowest and the highest values for and will be the following It is claimed that every value between and exists if the values are valid and The full proof about the given conditions being sufficient and the existence of every value on that range is left to the reader Some kind of a hint might be the suggestion to check how the inequalities change on the transition from some period to Restrict the values by and to count each answer on exactly one range of lengths Finally the value of is added to the answer The number of ranges with the same is Overall complexity 
1469, if an undirected graph is disconnected then its complement is connected Similarly if its complement is disconnected then the graph itself is connected suppose a graph is disconnected Pick two vertices and from different components Every vertex outside of s component is connected to in the complement and every vertex outside of s component is connected to in the complement the complement also contains the edge from to so all vertices in the complement graph belong to the single component Why do we need this lemma at all We can treat the graph formed by blue edges as the complement to the graph formed by red edges So if the red graph is disconnected then the blue graph is connected so we don t need to consider the case when some set of vertices is connected by neither color We only need to make sure that no set of vertices is connected by both colors Let be the answer for Every graph counted in is either red disconnected or blue disconnected since there is a bijection between red disconnected and blue disconnected graphs you can flip the colors of all edges to transform one type into the other we will count only red disconnected graphs and multiply it by Let be the number of blue connected graphs with vertices meeting the properties of the problem statement It s easy to see that if otherwise the case is special because a graph on one vertex is both red connected and blue connected To calculate let s iterate on the number of vertices which are in the same red component as This component must be a red connected graph which meets the problem statement so the number of ways to build the graph on these vertices is there are ways to choose the vertices in the same component as and the remaining graph can be either red connected or blue connected so the number of ways to build the remaining graph is Thus we get the following two relations We can calculate all values with dynamic programming using these formulas in 
1470, Okay we need more definitions Here they come This way we can transform the formula for to the following Or even this since This is almost the convolution of the sequences and with a bit extra additional operations after the convolution so to compute the sequence we just need to compute the sequences and and then calculate their convolution with NTT All that s left is to multiply every element by the corresponding factorial But wait that s not so easy In order to calculate and we need to know Note that we can ignore the fact that and appear in the formula for since they are multiplied by so at least we don t have a dependency cycle Unfortunately we cannot just straightforwardly use convolution if we don t know the sequences and The model solution handles it using the following approach Let s generate and in parallel on the th iteration calculate then calculate and using it And we will calculate the convolution of the sequences and Suppose we want to calculate and the last time we calculated the convolution of and was after the iteration Back then we knew all elements from to and from to So the th term in the convolution of and contained the sum of over all such that and So in order to calculate we have to pick this value from the convolution and then add the sum of over all such that or and there are such values Suppose we compute the convolution every iterations Then the maximum value of is and every value of is calculated in We also make convolutions so the total complexity of this solution will be which can be transformed into if we pick 
1471,Let s consider some division Represent the XOR sum of the subset via prefix XOR Those are I claim that you can collect any subset that is a XOR of an even number of for pairwise distinct values of Let s take a look on some prefix of processed segments where the last segment is taken into subset The previous taken s can t be changed the last taken can either be eliminated if we also take the current segment and that segment erases one value and adds one or added to the answer if we don t take it but the next taken segment will add two values You can see that the parity doesn t change Moreover you can collect any subset that is a XOR of an odd number of for pairwise distinct values of Just forget about taken into the answer as its value is Then all the even subsets which included it will become odd This way we can collect all subsets of for some division Now you just want find the division that produces the maximum number of linearly independent numbers binary vectors That is the size of the basis of the space of chosen numbers binary vectors Now it s time to abuse the fact that adding a number into the set can only increase the size of basis of the space Thus adding anything to the maximum set won t change the answer otherwise the result would be greater than the maximum Finally you say that the maximum basis size is equal to the basis size of all the prefix XOR and easily calculate in The only corner case is being itself Then for any division the full subset will also give result That is the only case with answer Overall complexity 
1472,Despite the fact that statement sounds like some dp or flow the actual solution is pretty greedy Let s iterate over all minutes Adilbek has to water at and maintain the cheapest liters he can obtain to this minute Let this be some structure which stores data in form price for 1 liter total volume Adilbek can buy for this price Pairs will be sorted by the price of a liter The most convenient structure for that might be a C map for example When moving to the next minute pop the cheapest liter out of this structure and add it to the answer If that minute some friend comes then push his water to the structure if the total updated volume in the structure is greater than then pop the most expensive left overs out of it so that the structure holds no more than liters total That prevents out solution to fill the watering system over its capacity The main idea for why this greedy strategy works is that it s never optimal to take not the cheapest liter because a liter of that price or cheaper will still be available in the future minutes Note that between each pairs of adjacent coming friends basically nothing happens Thus you can find the time between them and pop that number of cheapest liters right away instead of iterating minute by minute Overall complexity per query 
1473,The idea of solution is the following we build the answer letter by letter when choosing a character for some position we try all possible characters and check that we can build the suffix after placing this character But we need to somehow do this checking fast As in many previous Educational Rounds in this round some participants solutions were much easier to write and understand than our own model solution Let s build a flow network where we have vertices representing the characters of the string and vertices representing the masks of characters Add directed edges from the source to every node representing some character with capacity equal to the number of such characters in the original string also add directed edges from every node representing some character to all vertices representing masks where this character is contained with infinite capacity and finally add a directed edge from every mask node to the sink with capacity equal to the number of positions where this mask of characters is allowed If we find maximum flow in this network we can check that the answer exists and if it exists build some answer Now let s try to build optimal answer by somehow rebuilding the flow in the network Suppose we are trying to place a character to position containing mask To check whether we can do it we have to try rebuilding the flow in such a way that the edge from vertex corresponding to to vertex corresponding to has non zero flow If it is already non zero then we are done otherwise we may cancel a unit of flow going through an edge from source to vertex then cancel a unit of flow going through an edge from vertex to sink decrease the capacity of these two edges by and check that there exists an augmenting path If it exists then returning the capacities back and adding one unit of flow through the path actually builds some answer where some character is placed on some position with mask so we may place it there otherwise it s impossible When we finally decided to place on position we have to decrease the flow through and the capacities of edges and All this algorithm runs in where is the size of the alphabet Hall s theorem allows us to check that we may build the suffix of the answer much easier Each time we try to place some character we need to iterate on all possible subsets of characters we still need to place and check that the number of positions that are suitable for at least one character in a subset is not less than the size of subset just like in regular Hall s theorem The key fact here is that if we have for example characters yet to place then we don t need to check any subset containing exactly or characters since the number of suitable positions for this subset won t become larger if we add all remaining characters to a subset So the subsets we have to consider are limited by the masks of possible characters and there will be only of them 
1474,If the problem was to make the array strictly increasing then we could use the following approach for every element subtract its index from it find the longest non decreasing subsequence and change every element not belonging to this sequence In this problem we can use a similar technique Let s iterate on the element we will remove after changing everything we need let s call it For every we will subtract from and for every we will subtract from Let s maintain the longest non decreasing subsequence ending in every element on prefix and the longest non decreasing subsequence starting in every element on suffix this can be done by a lot of different techniques for example two segment trees and rollbacking which is used in our model solution Then we need to somehow merge these sequences The easiest way to do it is to consider only the subsequence ending in element since if we will need to consider the subsequence ending in some index less than we would check this possibility choosing other value of and use some data structure BIT segment tree or something similar to find the longest subsequence that can be appended to the one we fixed After checking if we need to delete element we add it to the data structure on prefix remove element from the data structure on suffix check if we have to remove element and so on Model solution https pastebin com BiaFgYx6
1475,Let s fix an fraction such that Obviously each good fraction is equal to exactly one of such irreducible fractions So if we iterate on and check that and find the number of good fractions that are equal to we will solve the problem Okay suppose we fixed and Any good fraction can be represented as where is some positive integer Let s try all possible values of and for them check whether they correspond to a good fraction How do we try all values of without iterating on them Let s construct the decimal representation of from the least significant digit to the most As soon as we fix least significant digits of we know least significant digits of and So let s try to use digit DP to try all possible values of Which states do we have to consider Of course we need to know the number of digits we already placed so that will be the first state After we placed digits we know first digits of the numerator of the fraction but to get the value of digit knowing only the value of the corresponding digit in is not enough there could be some value carried over after multiplying already placed digits by For example if and we placed the first digit of and it is we know that the first least significant digit of is and we know that after fixing the second digit of we should add to it to get the value of this digit in since is carried over from the first digit So the second state of DP should represent the number that is carried over from the previous digit in the numerator and the third state should do the same for the denominator Okay in order to know whether the fraction is good we have to keep track of some digits in the numerator and denominator If and then we have to keep track of the digit representing in the numerator and the digit representing in the denominator So we have two additional states that represent the masks of interesting digits we met in the numerator and in the denominator The only thing that s left to check is that both and are not greater than Let s construct the decimal representation of and prepend it with some leading zeroes and keep constructing the numerator and the denominator until they have the same number of digits as the decimal representation as Then we can compare the representation of for example numerator with the representation of as strings Comparing can be done with the following technique let s keep a flag denoting whether the number represented by the least significant digits of the numerator is less or equal than the number represented by the same digits from When we place another digit of the numerator we can get the new value of this flag as follows if new digit of the numerator is not equal to the corresponding digit of then the value of the flag is defined by comparing this pair of digits otherwise the value of the flag is the same as it was without this new digit Of course we should do the same for the denominator Okay now we can actually start coding this DP is the number of possible ways to put least significant digits in in such a way that the value carried over to the next digit of the numerator is and for the denominator denotes whether the current numerator is less or equal to the number represented by least significant digits of does the same for the denominator denotes which interesting digits we already met in the numerator of course does the same for the denominator If you are feeling confident in your programming abilities you can just start implementing this DP on a seven dimensional array I was too afraid to do it but looking at participants solutions I realize that it sounds much more scary than it looks in the code so I decided to write the model solution using a structure representing each state and a map to store all these structures This is a common technique when a dynamic programming solution you come up with has some really complex states and transitions it is sometimes better to use some self implemented structures to define these states and store them in a map or a hashmap Some advantages of this technique are it s sometimes much easier to code the code may be longer than the same solution with regular DP stored in a multi dimensional array but it s easier to write and understand this code if most states are unreachable they won t even appear in our map so we skip them altogether it is easy to add some optimizations related to reducing the number of states For example the number of different values for and may be too much so we can use the following optimization as soon as we find some pair of numbers in and that can represent and we can change these masks to some values that will mark that they are finished and stop updating them at all 
1476,Let s denote the string obtained by concatenation where is some dividing character that isn t a part of the alphabet as Recall that KMP algorithm builds the prefix function for this string We can calculate on this string where is the position in this string and is the value of prefix function in this position The value of is the maximum number of occurences of found so far or if this situation is impossible If th character is a Latin letter then we just recalculate prefix function for this position the fact that in KMP the value of prefix function won t exceed allows us to do so If th character is a question mark then we check all possible characters and recalculate prefix function for all of these characters and update the corresponding values The size of and is pretty big so we need to recalculate these values in time this can be done by precalculating the values of is the value of prefix function is a new character and is the value of prefix function after adding this character 
1477,The first idea that comes to mind is running some sort of dynamic programming the number of ways to cut the string consisting of the first characters When we calculate we need to take the sum of the previous values of and then subtract for every such that the string from the th character inclusive to the th character non inclusive is a Fibonacci string Unfortunately there are two main issues with this solution firstly we cannot store the array in memory and secondly we have to search for the Fibonacci strings ending in a certain index quickly something like Aho Corasick could work with a less strict memory limit but right now we cannot use it We will try to resolve both of these issues with the following approach while we process the characters we will maintain the list of tuples such that the string from the th character to the current one is a prefix of some Fibonacci string How do we maintain them Every Fibonacci string except for is a prefix of So all Fibonacci strings we are interested in except for again are prefixes of the same long Fibonacci string Suppose a tuple represents some index such that the string from the th character to the current one is a prefix of that long Fibonacci string Each time we append a character we filter this list of tuples by trying to check if this new character matches the next character in the prefix if it does not the tuple is discarded For the tuples that represent the prefixes equal to Fibonacci strings we need to subtract the value of from the new value we are trying to calculate checking if a prefix is a Fibonacci string is easy we just need to check its length How do we check that if we add a character or it is still a prefix There are two ways to do this either generate the first characters of the long Fibonacci string or represent the current prefix as the sum of Fibonacci strings such that for every the condition holds i e the Fibonacci strings we split the current prefix into are arranged in descending order and there is no pair of equal or adjacent by index Fibonacci strings in the split This representation is very similar to writing an integer in Zeckendorf system The next character in the prefix depends on whether belongs to this split if it belongs it is the last string in the split so we need to append to transform into otherwise we need to append Okay so now we can solve the problem in time where is the total length of the strings in the input and is the size of the list of tuples we discussed earlier This actually works since it looks like the size of the list of tuples is bounded as Unfortunately we don t have a strict mathematical proof of this we checked this by brute force with up to so it definitely works under the constraints of the problem 
1478,At first must be met since and Now let and From now on let s consider only such that Now let s look at must be met Let Since if then must have to the power of in its factorization otherwise power of can be any non negative integer It leads us to the bitmask of restrictions with size equal to the number of different prime divisors of In the same way let s process Of course and if then must have to the power of in its factorization This is another restriction bitmask So for any pair there exists if and only if Since we look only at where then can t have power of equal to and at the same time For any other it is enough to have power of in equal to the power of in even if it s equal to So for each we need to know the number of such that is a submask of So we just need to calculate sum of submasks for each mask it can be done with or Finally how to factorize number up to Of course Pollard algorithm helps but there is another way which works sometimes Let s factorize with primes up to So after that if there is only three cases or is easy to check helps Otherwise just check with all and if you have found and then and you have found Otherwise you can assume that because this probable mistake doesn t break anything in this task Result complexity is where is the number of prime divisors of 
1479,Suppose there is only one query i e we are given some array and we want to know who is the winner if the game is played on this array One of the obvious solutions is will the current player win if the chip is currently in the cell and the number in cell is We can already see that we don t need to know the exact value of we only want to know whether it s odd if there is a cell such that we can go from to and is a state where current player will lose then we should go to this cell since our opponent will enter a losing state of the game Otherwise we want to force our opponent to move out of cell and we can do so only if is odd So we found a dynamic programming solution with states but what is more important is that we can take all the elements in our array modulo Okay now let s solve the problem when there are only queries of type no modifications Since when calculating the values we are interested only in next cells and there are only variants of whether these cells are winning or losing we may consider each element of the array as a function that maps a mask of next states into a new mask of states if we pushed our new element into the front For example if the th element is even and states are winning losing losing winning and losing respectively and then we may consider a mask of next states as and then we can check if th state is winning and push a bit to the front of this mask discarding the last bit since new state is winning we will get a mask of It allows us to denote two functions and what will be the resulting mask of next states if current mask is and we push an even or odd element to the front Okay what about pushing more than one element We can just take the composition of their functions Since a function can be stored as an array of integers and the composition needs only time to be calculated then we can build a segment tree over the elements of the array and store a composition of all functions on the segment in each node This allows us to answer queries of type in The only thing that s left is additions on segment Adding an even number is easy just ignore this query To be able an odd number let s store another function in each node of the segment tree which would be the composition of all functions on the segment if we would add to all elements on the segment so the elements which were odd become even and vice versa This allows us to use lazy propagation if the query affects the whole node we may just swap two functions in it and push the query to the children of this node Overall complexity is It turns out we didn t think about it before the contest but some contestants submitted such solutions that it can be reduced to if we will use the distance to closest losing state instead of a mask of winning and losing states 
1480,First of all the information given in the input is the structure of a trie built on and some other strings so we can store this information in the same way as we store a trie Okay now let s calculate the number of seconds required to type each string with dynamic programming let be the number of seconds required to arrive to the th vertex of the trie For regular vertices where is the parent of vertex for vertices corresponding to strings from values should be updated with the time required to autocomplete some of the parents to the current vertex To do these updates let s calculate the answers for all strings in lexicographical order We will run DFS on the trie and maintain a segment tree on the path from the root to the current vertex In the segment tree we will store the values of where is the number of seconds required to autocomplete from to the current vertex Obviously if we are currently in a vertex representing a word from then we have to find the minimum in this segment tree and that will be the cost to get to current vertex using autocompletion How to maintain Recall that we are running DFS on trie in lexicographical order When we want to compute the answer for the first string the value of for all vertices is since our string will be the first in all autocompletion lists And here s a trick to maintain these values for other strings whenever we compute the answer for some string add on the whole tree For vertices that are ancestors of both current string and some next string this will stay and increase the cost to autocomplete the next string accordingly but for vertices which are not on the path to some next string the values of will be already deleted from the segment tree and replaced by new values so this addition does not affect them Overall this works in but it can be written in with a vector instead of a segment tree since all additions and minimum queries affect the whole structure 
1481,Firstly if we may obtain reliability at least then we may obtain reliability not less than with the same number of archers So we may use binary search and check whether we may obtain reliability at least How can we check it Let s find the leftmost section such that its defense level is less than Let its index be We obviously have to add some archers controlling this section and since every section to the left of it is already controlled the best option where to add archers is the section with index After we added enough archers we move to next section such that its defense level is less than and do the same If we run out of archers without protecting all the sections then it s impossible to obtain reliability To do checking in we may use prefix sums or sliding window technique 
1482,The model solution is where but it seems that there are faster ones I ll explain the model solution nevertheless It s easy to see using simple Nim theory that the answer for a query is iff the xor of for all chips such that is equal to Let s calculate this xor for every query This number contains at most bits and we will process these bits differently we will choose some number and use one solution to calculate lowest bits and another solution to compute highest bits One idea is common in both solutions we split each query into two queries a query can be represented as a combination of two queries and where is the xor of all numbers such that After converting the queries for every store each query of the form in some sort of vector or any other data structure We will use an approach similar to sweep line iterate on and solve the queries for the current These ideas will be used both for the solution calculating lowest bits and for the solution calculating highest bits How to find lowest bits in each query Iterate on from to and maintain the number of occurrences of each number we met so far Then at a moment we want to calculate simply iterate on all of the values of and process each value in if the number of occurrences of some value is odd update the current answer to the query by xoring the number with otherwise just skip it And since we are interested only in lowest bits for each we need only the remainder so the number of different values is Thus this part of the solution runs in Okay what about highest bits in each query We can see that for every number the highest bits of don t change too often when we iterate on there will be about segments where the highest bits of have different values We can build a data structure that allows use to process two queries xor all numbers on a segment with some value and get the value in some position Fenwick trees and segment trees can do it Then we again iterate on from to When we want to process a number we find the segments where the highest bits of have the same value and perform updates on these segments in our data structure When we process a query of the form we simply get the value in the position from our data structure This part of the solution works in By choosing optimally we can combine these two parts into a solution with complexity of 
1483,At first let s say that the expected value is equal to the average of total earnings over all positions and is equal to the sum of earnings over all positions divided by So we can trasition to minimizing the sum Let s learn how to solve the task for some fixed Fix some arrangement and rotate the rooms so that the last room contains a mimic So now you have regular chests then a single mimic regular chests single mimic regular chests single mimic All and Take a look at some of these intervals of length The last chest in the interval is taken from starting positions the second to last is taken times and so on Now let s find the optimal way to choose Fix some values of Take a look at the smallest of these values and the largest of them Let the values be and If they differ by at least then the smaller result can always be achieved by moving a regular chest from the larger one to the smaller one ProofConsider two sequences of coefficients for both intervals and However if you remove one chest then they will be equal to and If you only consider the difference between the numbers of both sequences then you can see that only coefficient got removed and coefficient was added So you can rearrange the chests in such a way that all chests are assigned to the same value and only the chest that was assigned to becomes assigned to thus decreasing the total value Now we have all set now The only thing left is to assign chests optimally Write down the union of all the coefficient sequences from all the intervals and sort them in the non decreasing order It s easy to show that the chests should be sorted in the non increasing order really classical thing you can try proving that by showing that any other arrangement can easily be improved once again That allows us to write a solution in Sort all the chests in the beginning after that for some multiply the value of the th chest by and sum up the results Finally let s speed this up with prefix sums Notice that the first values are multiplied by the second values by and so on If is not divisible by then the last block just has length smaller than Thus we can calculate the answer for some in And that s equal to Overall complexity 
1484,The core idea of the solution is the following dynamic programming is the minimum number of characters we have to delete if we considered a subsequence of first characters of and it maps to first characters of There are three obvious transitions in this dynamic programming we can go from to by skipping if we can go from to if is a dot we can go from to Unfortunately these transitions cannot fully handle the case when we want to put some character and then delete it these transitions don t allow us to do it for any character only for some specific ones in specific situations To handle it suppose we want to take the character and then delete it and we model it as follows there exists the fourth transition from to without deleting anything where is the length of the shortest substring of starting from that becomes empty if we apply the function to it This substring can be described as a regular bracket sequence where opening brackets correspond to letters and closing brackets to dots We can precalculate this substring for each in Why is this transition enough Suppose we don t want to take some letter from this shortest substring in the optimal answer since it is the shortest substring meeting these constraints the number of letters on each prefix of it excluding the substring itself is greater than the number of dots so we can instead skip the first letter and try applying this transition from so this case is handled And skipping any dots from this shortest substring is also suboptimal since we have to get rid of the character 
1485,For a fixed upper bound this is a well known problem that can be solved using inclusion exclusion Let s denote by the number of arrays with elements in range such that is divisible by Obviously With the help of inclusion exclusion formula we can prove that the number of arrays with is the sum of the following values over all possible sets where is some set of prime numbers possibly an empty set and is the product of all elements in the set in this formula denotes the number of arrays such that their is divisible by every number from set However the number of such sets is infinite so we need to use the fact that if With the help of this fact we can rewrite the sum over every set in such a way where is if there is no any set of prime numbers such that if this set exists and the sign is determined by the size of if is even otherwise An easier way to denote and calculate is the following by the way it is called M bius function if there is some prime number p such that Otherwise where is the number of primes in the factorization of Okay so we found a solution for one upper bound it s How can we calculate it for every from to Suppose we have calculated all values of for some and we want to recalculate them for The important fact is that these values change and thus need recalculation only for the numbers such that So if we recalculate only these values and each recalculation can be done in time if we precompute the for every then we will have to do only recalculations overall 
1486,I m feeling extremely amused by the power of Aho Corasick lately so I will describe two solutions of this problem with it Feel free to point out how cool you are solving the task with hashes or some suffix structure but Aho solutions will still be cooler I also want to mention I m quite proud of the name I came up with for that task First let s assume that the words in the dictionary are unique Build an Aho Corasick automaton on the dictionary Then build the tree of its suffix links For the first solution you can use the fact that there are not a lot of words in the dictionary that can end in each position To be exact at most one word per unique word length Thus that s bounded by the square root of the total length For that reason you can iterate over all the words that end in all positions of the queries in How to do that fast For each vertex of the automaton precalculate the closest vertex up the suffix link tree that s a terminal Feed the query word into the automaton and from each vertex you stay at just jump up the tree until you reach the root Take the maximum value over all the visited terminals The second solution actually involves an extra data structure on top of that No it s not HLD You are boring for using it Let s abuse the fact that you are allowed to solve the problem fully offline For each word you can save the list of pairs time value of the times the value of the word changed For each vertex of the automaton you can save all the times that vertex has been queried from Now traverse the tree with dfs When you enter the vertex you want to apply all the updates that are saved for the words that are terminals here What are the updates From the list we obtained for a word you can generate such triples that this word had value from query to query Don t forget the value from to the first update to this word Then ask all the queries Then go to children When you exit the vertex you want all the updates to be gone Well there is a trick for these kinds of operations it s called rollbacks Maintain a segment tree over the query times the th leaf should store the maximum value during the th query The update operation updates the range with the new possible maximum How to avoid using lazy propagation with such updates Well on point query you can collect all the values from the segtree nodes you visit on your way down That way you don t have to push the updates all the way to the leaves Not that it matters that much but the number of values to be saved for future rollbacks is decreased dramatically That solution works in 
1487,Suppose we want to calculate the maximum profit for some vertex in Let s try to find out how it can be done and then optimize this process so we don t have to run it times First of all we have to find the bridges and biconnected components in our graph Why do we need them Edges in each biconnected component can be directed in such a way that it becomes a strongly connected component so we don t have to leave these edges undirected it is never optimal Furthermore for each such component either all vertices are saturated or no vertex is saturated Let s build a tree where each vertex represents a biconnected component of the original graph and each edge represents a bridge We can solve the problem for this tree and then the answer for some vertex of the original graph is equal to the answer for the biconnected component this vertex belongs to Okay now we have a problem on tree Let s implement the following dynamic programming solution root the tree at the vertex we want to find the answer for and for each vertex calculate the value of the maximum profit we can get for the subtree of vertex if it should be reachable by all special vertices from its subtree Let s analyze how we can calculate these values Suppose we have a vertex with children we have already calculated the values for the children and we want to calculate First of all since the vertex is going to be saturated we will get the profit from it so we initialize with Then we should decide whether we want to get the profit from the children of vertex Suppose the edge leading from to has weight If we want to take the profit from the subtree of we usually have to make this edge undirected so both vertices are saturated thus we get as profit or we could leave this edge directed from to so the vertex is saturated and is not and get as the profit But sometimes we can gain the profit from the vertex and its subtree without leaving the edge undirected if all special vertices belong to the subtree of we can just direct this edge from to and there is no reason to choose the opposite direction or leave the edge undirected Similarly if all special vertices are outside of this subtree there s no reason to direct the edge from to So if one of this conditions is met we can get the full profit from the subtree of without leaving the edge undirected Okay let s summarize it We can calculate as where is either if one of the aforementioned conditions is met we don t have to leave the edge undirected if we want to saturate both vertices or otherwise Now we have an solution Let s optimize it to Root the tree at vertex and calculate the dynamic programming as if is the root Then we shall use technique to recalculate the dynamic programming for all other vertices we will try each vertex as the root of the tree and is the answer for the vertex if it is the root The rerooting technique works as follows let s run DFS from the initial root of the tree and when we traverse an edge by starting or finishing a recursive call of DFS we move the root along the edge so if we call is the current root if it has some child we move the root to the same moment when we call and when the call of ends the root moves back to Okay the only thing that s left is to describe how we move the root If the current root is and we want to move it to a vertex adjacent to then we have to change only the values of and first of all since is no longer a child of we have to subtract the value that was added to while we considered vertex then we have to make the child of vertex so we add the profit we can get from the vertex to It can be done in so our solution runs in though with a very heavy constant factor 
1488,Let s firstly try to come up with some naive solution Suppose we have a list and want to calculate for it Let s sort this list comparing the pairs by their values of and then process them one by one We will divide this list into some parts we will call them with the following process when processing the first pair in the sorted order let s iterate on the next pairs also in the sorted order and add them to the first pair s component until the following condition is met where is the index of the first pair we added and is the index of the pair we are currently trying to add to s component remember that we consider all these pairs in the sorted order What is the meaning of this condition means that the number of pairs between and including these two is not less that the number of integers in and while this condition is met we can use the first operation in order to make a pair having for every And the first time when the condition is met we obviously cannot expand the segment in such a way It means that the value of will always be greater than value of and won t belong to the same component with and will start creating its own component instead These components we form have one special property Suppose we expanded the component so that there are no two equal values of in it Then we may reorder the pairs in this component as we wish to do so we may contract the component using the second operation and then expand it again Of course the best course of action is to sort the pairs in the component by their values of in descending order After doing this for every component we will obtain an optimal configuration such that all values of are distinct and it s easy to calculate the answer Okay now we need to do it fast The following will help us DSU Some implicit logarithmic data structure the operations we need are count the sum of elements less than and count the number of elements greater than your implementation might use other operations Small to large merging DSU will help us maintain the components A data structre will be built for each component containing the values of in it it will help us to maintain the sum of where is the optimal index of in this component Depending on your implementation you may or may not need to store the minimum value of in the component When inserting some element having into some component the elements having don t change their position the new element will be added right after them and the remaining elements will be shifted to the right so the sum of can be maintained if we query the number of elements greater than and the sum of elements less than Okay but we still don t know how we create the components and how we determine if two components are to merge We will keep these components in expanded form that is when processing a pair let s find the leftmost unoccupied position after or if it is not occupied and occupy it with the new pair creating a new component for it If the newly occupied index is let s try to merge new component with components occupying and if there are any to merge two components do the required operations in DSU and unite the data structures built in these components with small to large method All this works in the most time consuming part is merging the data structures 
1489,The problem consists of two parts what do we want to calculate and how to calculate it What do we want to calculate There are several ways to figure it out At first you could have met this problem before and all you need is to remember a solution At second you can come up with the solution in a purely theoretical way Hasse diagram can help with it greatly Let s define as the number of primes in prime factorization of For example and If you look at Hasse diagram of you can see that all divisors with lies on level If is divisible by then so all divisors on the same level don t divide each other Moreover the diagram somehow symmetrical about its middle level and sizes of levels are increasing while moving to the middle It gives us an idea that the answer is the size of the middle level i e the number of divisors with The final way is just to brute force the answers for small s and find the sequence in OEIS with name A096825 where the needed formulas are described The second step is to calculate the number of divisors with Suppose we have distinct primes and the number of occurences of is equal to Then we need to calculate pretty standard knapsack problem where you need to calculate number of ways to choose subset of size where you can take each up to times Or formally number of vectors with and Calculating the answer using will lead to time limit so we need to make the following transformation Let s build for each a polynomial Now the answer is just a coefficient before in product Note that the product has degree so we can multiply polynomials efficiently with integer FFT in the special order to acquire time complexity There several ways to choose the order of multiplications At first you can at each step choose two polynomials with the lowest degree and multiply them At second you can use the divide and conquer technique by dividing the current segment in two with pretty same total degrees At third you can also use D n C but divide the segment at halves and it seems still to be in total What about the proof of the solution Thanks to tyrion for the link at the article https pure tue nl ws files 4373475 597494 pdf The result complexity is time and space if carefully written Note that the hidden constant in integer FFT is pretty high and highly depends on the implementation so it s possible for poor implementations not to pass the time limit 
1490,Suppose we want to minimize the number of traversed edges of the second type edges that connect odd vertices to each other or even vertices to each other and minimizing the length of the path has lower priority Then we exactly know the number of edges of the second type we will use to get from one vertex to another and when building a path we each time either jump from one tree to another using an edge of the first type or use the only edge of the second type that brings us closer to the vertex we want to reach So in this case problem can be solved either by binary lifting or by centroid decomposition The model solution uses the latter merge the graph into one tree vertices and of the original graph merge into vertex in the tree build its centroid decomposition and for each centroid and vertex of its centroid subtree calculate the length of the shortest path from and to and using dynamic programming Then the answer for each pair of vertices and may be calculated as follows find the deepest centroid controlling the both vertices and try either shortest path or shortest path But this solution won t work in the original problem because sometimes we want to choose an edge of the second type that leads us further from the vertex we want to reach in the merged tree but allows us to use a cheaper edge of the first type to jump from one tree to another Let s make this situation impossible We may change the weights of all edges of the second type so that the weight of edge between and becomes the length of the shortest path between and This can be done by solving a SSSP problem build a graph of vertices where each vertex from to represents the path between from and Add a directed edge with weight equal to going from vertex to vertex And finally for every pair such that and are connected by edge of weight and and are connected by edge of weight add an undirected edge connecting and in the new graph its weight should be Then the distance from to in this graph will be equal to the length of the shortest path from to in the original graph 
1491,Suppose we added all the suffixes of into a trie Then we can find th suffix by descending the trie checking the sizes of subtrees to choose where to go on each iteration The model solution actually does that but computes the sizes of subtrees without building the whole trie Recall that if we insert all suffixes of a string into the trie then the size of subtree of some vertex is equal to the number of occurences of the string denoted by this vertex in the original string Since in our problem the strings are recurrent we may use prefix automaton to count the number of occurences To calculate the number of occurences of string in let s build prefix function for and an automaton which tells the value of prefix function if the previous value was and we appended to the string the same approach is used in KMP substring search algorithm Then let s build another automaton that will help us work with Fibonacci string what will be the value of prefix function if we append to the string For and this automaton can be easily built using and and for we may build using the automatons for and We also have to keep track of the number of occurences that can be done with another automaton on fibonacci strings There is a corner case when we need to stop descending the trie to handle it we need to check whether some string is a suffix of but that can be easily made by checking if Each step in trie forces us to do up to three depending on your implementation queries like count the number of occurences of some string in so overall the solution works in 
1492,The solution consists of several steps Let s find out does the first box contain stone or valuable gift using random Let s make queries to compare the weight of the first box with the weight of another random box If the first box is lighter than we found an answer otherwise the probability of the first box having stones is at least Let s compare the weights of the first box and the second one If they are equal then let s compare the weights of boxes and If they are equal then let s compare the boxes and and so on In other words let s find the minimum such that contains only boxes with stones but contain at least one box with a valuable gift It s easy to see that we d spend no more than queries We have segment with only stones and with at least one gift Let s just binary search the leftmost gift in the segment using boxes from as reference if we need to know does segment of boxes have at least one gift let s just compare it with segment which have only stones if is lighter then it has otherwise doesn t have This part also requires no more than queries 
1493,Consider the following dynamic programming the minimum cost to make have value after the th line The transitions here are pretty easy on set you just consider two options of skipping or not skipping the instructions and on if you either go to the next line or to the end of the block depending on the value There are a lot of possible values so that dp works in First let s notice that all the values that don t appear in the input won t matter so you can keep only the existing values in the dp Next let s consider the following modification to it What happens when you enter an if block It s actually the same dp but the only starting value is not with cost as in the beginning of the whole program but some value with some cost So let s calculate this dp separately from the outer one and just merge the values together Notice that if some value doesn t appear inside the if block then its cost can not decrease exiting out of it Thus it s enough to calculate the inner dp only for values that appear inside the if block Okay the transitions for if became easier The set transitions are still slow though Examine the nature of them All the values besides the written on the set instruction increase their cost by As for the its cost becomes equal to the cost of the cheapest value before the instruction Thus let s maintain the dp in some data structure that allows to add the same integer to all elements and take the minimum of its elements That can be done with a set and a single integer that stores the current shift that should be applied to all elements Surely you ll also need a map to retrieve the current cost of particular values The final part is fast merging of the if block dp and the outer one It might not appear obvious but if you do that in a straightforward manner of adding all the costs from if one by one it can become in total So we can apply small to large and swap these dp s based on their sizes Overall complexity 
1494,Let s build a directed graph where vertices represent notes and a directed edge comes from vertex to vertex iff and and can be consecutive notes in a melody Now we have to find four longest vertex disjoint paths in this graph This problem can be solved with mincost flow algorithms We build a network where each vertex of the graph is split into two let s denote the vertices that we obtain when we are splitting some vertex as and Then each directed edge transforms into a directed edge from vertex to vertex in the network the capacity of this edge is and the cost is Also we add directed edges from the source to every vertex and from every vertex to the sink they have the same characteristics capacity is cost is And for each we add a directed edge between and these edges actually represent that we are using some note in a melody so their capacities are also equal to and their costs are The answer to the problem is equal to the absolute value of minimum cost of flow in this network The bad thing is that the network is really large So we have to use some advanced mincost algorithm here Model solution uses Dijkstra s algorithm with Johnson s potentials to find augmenting paths of minimum cost We set a number for each vertex of the network these numbers are called potentials Then we modify costs of the edges if some edge had cost now it s cost is It s easy to prove that if some path from vertex to vertex was the shortest one between these vertices without modifying the costs with potentinals then after modifying it will also be the shortest between these vertices So instead of looking for an augmenting path in the original network we can try looking for it in a network with modified edges Why Because it is always possible to set all potentials in such a way that all costs of edges will be non negative and we will be able to use Dijkstra to find the shortest path from the source to the sink Before looking for the first augmenting path we calculate potentials recursively we check all s such that there is an edge in the network The network is acyclic before we push flow so there is always a way to calculate these potentials with dynamic programming Then each time we want to find an augmenting path we run Dijkstra s algoritm on modified network push flow through the path we found and modify the potentials new potential of each vertex becomes where is the distance between the source and vertex in the modified network and we found this distance with Dijkstra When we have found four augmenting paths we are done and it s time to evaluate the cost of the flow 
1495,This task was inspired by an older edu task and another task proposed by RockyB Let s learn to solve the problem for at least one starting vertex for Alice Let this vertex be In general Alice s strategy is basically this run to some vertex as fast as possible and stay in it until Bob reaches Hesitation on a way to this vertex won t be optimal Visiting the same vertex multiple times won t as well I guess that can be proven more formally by analyzing the set of possible solutions after each move What properties should vertex have for Alice to be able to escape to it There shouldn t be a way for Bob to catch her midway However it s not necessary to check any midway intersections If Bob can catch her anywhere on a path she can also follow her to the end by moving the same path and catch her at the destination Thus this vertex should be further from any Bob s chips than from So you can precalculate the distance to the closest Bob s chip to each vertex Just push all chips to a queue and run a bfs We ve learned to solve the problem in for each vertex Just iterate over all vertices and take the maximum of over such of them that have greater than the distance from to Now the solution can go two ways You can stop thinking here and obtain an one or think more and get an The first one goes like that Notice that the function if the Alice can make at least moves from vertex is monotonous in regard to So we can binary search the answer The check query transforms to the following Consider all vertices with distance less or equal to from There should exist at least one vertex with value for the check to return true So at least the maximum value of them should be greater than That is basically a centroid exercise Let each centroid store such an array that is the maximum value of over all such that belong to this centroid s subgraph and are no further than distance from the centroid That array can be constructed in for all centroids in total You can easily see that the length of this array doesn t exceed the number of vertices in the subgraph of the corresponding centroid that is be definition For the query iterate over all centroids belongs to and check the value from some cell of each one s array For the second solution let s reverse the problem Consider the vertex Alice escapes to If there is a starting vertex no further than from it then the answer for can be updated with So we can update the subgraph of vertices with distance no more than with the maximum of their current answer and The solution will be almost the same centroid Iterate over all centroids belongs to and write into the cell of each one s array where is the distance from to this centroid Then build an array of prefix maximums over this array Finally for each collect the best answer over all centroids belongs to Overall complexity or 
1496,First of all one crucial observation is that no person should come to the meeting later than minutes after receiving the message the length of any simple path in the graph won t exceed and even if all organization members should choose the same path we can easily make them walk alone if the first person starts as soon as he receives the message the second person waits one minute the third person waits two minutes and so on Let s model the problem using mincost flows First of all we need to expand our graph let s create time layer of the graph where th layer represents the state of the graph after minutes have passed The members of the organization represent the flow in this graph We should add a directed edge from the source to every crossroad where some person lives with capacity equal to the number of persons living near that crossroad of course this edge should lead into th time layer since everyone starts moving immediately To model that some person can wait without moving we can connect consecutive time layers for every vertex representing some crossroad in time layer let s add a directed edge with infinite capacity to the vertex representing the same crossroad in the layer To model that people can walk along the street for every street and every layer let s add several edges going from crossroad in the layer to crossroad in the layer the costs and the capacities of these edges will be discussed later And to model that people can attend the meeting for each layer let s add a directed edge from the vertex representing crossroad in that layer to the sink the capacity should be infinite the cost should be equal to Okay if we find a way to model the increase of discontent from the companies of people going along the same street at the same moment then the minimum cost of the maximum flow in this network is the answer maximization of the flow ensures that all people attend the meeting and minimization of the cost ensures that the discontent is minimized To model the increase of discontent from the companies of people let s convert each edge of the original graph into a large set of edges for each layer let s add edges with capacity from the crossroad in the layer to the crossroad in the layer The first edge should have the cost equal to the second edge equal to the third and so on so if we choose minimum cost edges between this pair of nodes their total cost will be equal to Don t forget that each edge in the original graph is undirected so we should do the same for the node representing in layer and the node representing in layer Okay now we have a network with vertices and edges and we have to find the minimum cost flow in it and the total flow does not exceed Strangely enough we could not construct a test where the basic implementation of Ford Bellman algorithm with a queue runs for a long time but perhaps it s possible to fail it But if you are not sure about its complexity you can improve it with the following two optimizations use Dijkstra with potentials instead of Ford Bellman with queue compress all edges that connect the same nodes of the network into one edge with varying cost 
1497,Firstly for every we can calculate the number of paths such that is divisible by We can do it as follows generate all divisors of numbers numbers not exceeding have at most divisors so this will be fast enough and then for every analyze the graph containing the vertices that have as its divisor Each component of this graph gives us paths if its size is and this is the only formula we need to calculate the number of paths where is divisible by let this be How can we get the answer if we know the values of We can use inclusion exclusion with Mobius function for example to prove that and then if we want to apply the same technique for finding with any possible we could divide all numbers by and do the same thing But it might be too slow so it s better to rewrite this formula as because we will do exactly the same when dividing all numbers by In fact most contestants have written a much easier version of this solution so this might be a bit too complicated This problem can also be solved with centroid decomposition 
1498,Let be the number of ways to paint the graph so that all numbers on edges belong to the set Using inclusion exclusion we may get that the answer is Okay let s analyze everything separatedly is because every number is allowed will be analyzed later is where is the number of connected components in each component we have to use the same number is where is the number of isolated vertices every non isolated vertex should have number on it and all isolated vertices may have any numbers since these cases are symmetric is the number of bipartite colorings of the graph It is if the graph contains an odd cycle or if it is bipartite since these cases are symmetric is if there are no edges in the graph otherwise it is So the only thing left to consider is Actually it is easier to calculate it is the number of independent sets of this graph This problem is NP complete but when we may apply meet in the middle technique as follows divide all vertices into two sets and of roughly equal size for find all its independent subsets and for each such subset find which vertices from can be added to it without breaking its independency for each subset of find the number of independent subsets of such that no vertex from chosen subset of is adjacent to any vertex from chosen subset of you may use subset DP and OR convolution here find all independent subsets of and for every such subset add the number of subsets of that can be merged with it so the resulting set is independent The most time consuming part is counting all independent sets so the time complexity is 
1499,Let s split all edges of the graph into several paths and cycles each edge will belong to exactly one path or cycle Each path and each cycle will be colored in an alternating way the first edge will be red the second blue the third red and so on or vice versa Since the graph is bipartite each cycle can be colored in an alternating way The main idea of the solution is to add the edges one by one maintain the structure of cycles and paths and make sure that for each vertex at most one path starts ends in it If we are able to maintain this invariant then the value of for every vertex will be minimum possible each cycle going through a vertex covers an even number of edges incident to it half of them will be red half of them will be blue so if the degree of a vertex is odd one path will have this vertex as an endpoint and otherwise it won t be an endpoint of any path so Okay how do we maintain this structure Let s add edges one by one even the original edges of the graph and rebuild the structure in online mode For each vertex we will maintain the indices of the paths that have this vertex as an endpoint If some vertex has or more paths as its endpoints we can choose two of them and link them together Whenever we add an edge from to we just create a new path and check if we can link together some paths that have or as their endpoints How do we link the paths together If we try to link a path with itself it means that we try to close a cycle and when we do it we just forget about the resulting cycle its structure won t change in future queries When we link a path with some other path we might need to reverse and or repaint the paths before merging them into one There are at least two possible data structures we can use to do this either an implicit key treap that supports reversing and repainting or a deque with small to large merging whenever we try to link two paths together we repaint and or reverse the smaller one Both of those methods give a solution in or depending on your implementation The model solution uses deques and small to large merging 
1500,Let s calculate for each position position the closest greater from the right element to and add directed edge from to Then we will get oriented forest or tree if we d add fictive vertex where all edges are directed to some root So we can look at current subsegment we need to calculate the answer for as at a number of marked vertices in the tree Then the answer itself is a longest path up to the tree consisting only from marked vertices Key observation is next if and are marked and is an ancestor of then any vertex on path from to is also marked So the longest path up to the tree consisting only from marked vertices has length equal to a number of marked vertices on path to the root And we have three types of queries mark a vertex unmark a vertex and calculate maximum number of marked vertices among all paths to the root It can be done with Segment Tree on Euler Tour of the tree if we calculate and for each vertex in dfs order then marking unmarking is just adding to a segment and maximum among all paths is a maximum on the whole tree Result time complexity is and space complexity is 
1501,Let s start without the queries How to calculate the number of ways for the given lanterns First it s much easier to calculate the number of bad ways some point of interest is not illuminated If at least one point of interest is not illuminated then all lanterns have power lower than the distance from them to this point of interest More importantly it s less than Thus the number of good ways is minus the number of bad ways Let s use inclusion exclusion For a mask of non illuminated points of interest let s calculate the number of ways to assign the powers to the lanterns in such a way that at least these points of interest are not illuminated All other points can be either illuminated or not Let s call it With the values for all masks the answer is the sum of over all masks How to calculate the value for the mask First let s do it in for each mask Each lantern can have any power from to the distance to the closest point of interest inside the mask non inclusive Thus we can iterate over the lanterns and find the closest point to each of them then multiply the number of ways for all lanterns Let s calculate it the other way around Initialize the answers for the masks with Then iterate over the lantern and the point of interest that will be the closest non illuminated one to this lantern Let the distance between them be some value Which masks will this pair affect Let the lantern be to the right of that point of interest The opposite can be handled similarly All points to the left of the chosen point can be in either state All points between the chosen one and the lantern must be illuminated All points to the right of the lantern and with distance smaller than must also be illumunated All point to the right of these can be in either state Thus the masks look like 1000 000 where 1 denotes the chosen non illuminated point All masks that correspond to this template will be multiplied by You have to be careful when there are two points of interest with the same distance to some lantern one to the left of it and one to the right of it In particular in one case you should force illumination on all points with distance In another case you should force illumination on all points with distance How to multiply fast enough We ll use a technique called sum over subsets Let s express the template in terms of submasks For a template 100000 all submasks of 111100000111 will be multiplied by However we accidentally multiplied masks of form 000000 too Let s cancel them by dividing the submasks of 111000000111 by Record all multiplications for all pairs them force push them into submasks with sum over subsets well product over subsets in this case Now we have the values of for all masks in basically give or take the time to find the points that must be forced illuminated extra from lower bound or two pointers which is not really faster Now for the queries How does the answer change after an extra lantern is added Again let s iterate over the closest point of interest and find the mask template All masks corresponding to this template will get multiplied by Thus the answer will change by the sum of values of these masks multiplied by including the inclusion exclusion coefficient How to handle that Well yet another sum over subsets Just collect the sum of values over the submasks beforehand and use these during the query That gives us an per query Overall complexity 
1502,There is a common approach for the problem you are given a lot of strings and texts count the number of occurences of the strings in the texts build an Aho Corasick automaton on the given strings and somehow process the texts with it Let s see if it can handle this problem The names of the songs can be represented as a tree We may build an Aho Corasick on the strings given in the queries then try to input the names of the album into the automaton character by character with DFS on the aforementioned tree feeding a character to the automaton when we enter a node and reverting the automaton to the previous state when we leave that node Suppose that when we are in the vertex corresponding to the th song the automaton is in state If is a terminal state corresponding to some string from the queries it means that the string from the query is a suffix of the th song But some other strings can also be the suffixes of the same song to find all such strings we can start ascending from the state to the root of Aho Corasick automaton using suffix links or dictionary links Since suffix links can be represented as the edges of some rooted tree then we can build some data structure on this tree that allows adding an integer to all vertices on the path from the root to the given vertex for example we can use Fenwick tree over Euler tour of the tree Then to check whether some string from the query is a suffix of the song we may add to all vertices on the path to state and then check the value in the state corresponding to Okay what about counting the occurences of in Let s consider the path from the root to in the song tree Every vertex on this path corresponds to some prefix of the song so we can add on the path to state corresponding to some prefix and then extract the answer from the state corresponding to In fact that s all we have to do to obtain a solution Build an automaton on strings from queries a tree of suffix links over this automaton and a data structure on this tree for each vertex of the song tree store all queries to it Then run a DFS on the song tree When we enter some vertex input the corresponding character into the automaton and add to all states from the root of suffix link tree to the current state when we have to process queries to the current vertex extract the values from the data structure and when we leave a vertex subtract from all states from the root of suffix link tree to the current state and revert to the previous state This solution has complexity of where is the total length of all strings in the input 
1503,Suppose we want to calculate the value of some already fixed string we should be able to do so at least to solve the test cases without question marks How can we do it We can use some substring searching algorithms to calculate but a better solution is to build an Aho Corasick automaton over the array and then for each node calculate the sum of costs of all strings ending in that node these are the strings represented by that node and the strings represented by other nodes reachable by suffix links After that process by the automaton and calculate the sum of the aforementioned values over all states that were reached Building an Aho Corasick automaton can be done in and processing the string in Okay what if we ve got some question marks in our string The first solution that comes to mind is to calculate we processed first positions in used a of characters for question marks and the current state of the automaton is then denotes the maximum value of first characters of we could have got But it s where and is the size of the alphabet which is too slow To speed it up we can see that there are only positions in our string where we actually choose something in our dynamic programming All substrings not containing question marks can be skipped in as follows for each substring of bounded by two question marks or bounded by one question mark and one of the ends of and each state of the automaton we may precalculate the resulting state of the automaton and the change to the value of the string if we process this substring by the automaton with the initial state This precalculation is done in overall and using this we may skip the states of dynamic programming such that is not a position with a question mark so our complexity becomes A note about the model solution it s a bit more complicated because we wanted to increase the constraints to but then we decided that it would be too complicated to code so the main function still contains some parts of the code that were used to improve its complexity We will post a clearer version of the model solution soon 
1504,Let s use binary searching to find the answer Denote as the number of positive integers such that and the answer is the smallest integer such that We may use for example as the right border of segment where we use binary searching although the answers are a lot smaller than this number for it is obvious that will be really large for any from How can we calculate fastly Let s factorize and use inclusion exclusion Let be a subset of the set of prime divisors of and be the product of all numbers from For each possible subset we have to add to the result since there are exactly integers from divisible by every prime from Since any number from has at most prime divisors there are at most subsets to process 
1505,Let s solve the problem for a single query at first There are two possible types of collisions between two buildings and between a building and a ray Obviously if the collision of the second type happens then it s the building which is the closest to the bend point from either left or right The less obvious claim is that among all buildings collisions the closest is the biggest angle one Let s boil down some possibilities of colliding buildings Let two buildings be the same distance from the bend point Then they will collide and the collision point will Two buildings also collide if the left one is from and the right one is Then the point of collision is And for the opposite case the point of collision is also These points can be easily proven by checking the distances to upper corners of each building No other two buildings will collide Now that we know this we can transition to solving a problem of checking if there exists such a pair that the distances to from them differ by at most one Finding such a pair with minimal is enough Obviously this can be done with some sort of two pointers However that s not the intended solution Let s constuct bitset of 7000 positions to the left of the bend and to the right of the bend AND of these bitsets will give you the pairs such that the distance is the same for them However you can put 1 in points and for each building to the left and and for each building to the right This way AND will give you the exact pairs you need Use Find first to find the closest one Let collision happen on distance Then the collision of the first type will have angle and the collision of the second type will have angle The answer is the maximum of these two values Be careful with cases where How to process lots of queries Let s just move the bitsets to the right while going through queries in ascending order Bitsets can be updated in for each query and only buildings will be added to them in total Overall complexity 
1506,The naive solution would be the number of sequences of allowed digits with length and sum We compute it for and for every possible and the answer is Let s speed this up Let s denote the following polynomial where if is an allowed digit otherwise It s easy to see that the coefficients of are equal to the values of Using mathematical induction we may prove that the coefficients of are equal to So now we need to compute There are two possible ways to do this that result in complexity The first option is to apply binary exponentiation with NTT polynomial multiplication The second option is to use the fact that if we apply NTT to a polynomial we get a set of its values in some points So if we exponentiate these values we get a set of values of exponentiated polynomial in the same points So we may apply NTT to treating it as a polynomial of degree raise each resulting value to the power of and apply inverse transformation 
1507,We can represent a query as a function if If we want to apply two functions then we can calculate a composition of these functions in time in this problem is So we can do the following Use scanline technique Build a segment tree over queries where we store a composition of functions on segment in each vertex Initially all transformations are When a segment where we apply a query begins we update the segment tree we change the transformations on this query s index to the following if When a segment ends we revert the transformation on this index to The trick is that the composition of all current transformations is stored in the root of the segment tree so we can easily calculate the result of transformation 
1508,Firstly let s prove that at first and last positions of the most frequent elements should be placed but not necessary the same WLOG let s prove that for any By contradiction let s be the smallest index such that What happens if we swap them Since is the first such index then there are no for so contribution of will increase by exactly From the other side contribution of consists of two parts pairs with elements from and from For all elements from decrease will be equal to and from elements in So the total decrease after moving to position equal to The total difference in such case is equal to So our placement is not optimal contradiction Let s suggest that there is exactly one with maximum According to what we proved earlier both and must be equal to Contribution of the first and last elements will be equal to for pair and for each element with we add for pairs and So the total contribution of is equal to Note that this contribution is independent of positions of other in the array so that s why we can cut first and last elements of and solve the task recursively Unfortunately in the initial task we may have several with maximum But we in the similar manner can prove that the first and last elements should be some permutation of Now let s prove that any permutation of first and last elements is optimal Suppose positions of are and Then the contribution of is equal to The total contribution of all is This contribution doesn t depend on chosen and so any permutation of first elements and any permutation of last elements give optimal answer As a result the algorithm is following Find all maximums in If then any permutation of remaining elements has there are such permutations Otherwise add to the total balance and multiply the number of variants by Cut prefix and suffix by making for each obviously and repeat the whole process We can implement the algorithm fast if we keep the number of equal to each from to So the total complexity is 
1509,In order to take care of the and constraints we can iterate on the number of mercenaries we ll choose and find the number of choices for each count The key constraint in this problem is that is at most 20 which means that there can only be a few connected components that aren t just a single node In particular the largest possible connected component size is 21 since a connected graph with edges has at most nodes This means that for each connected component we can iterate over all of the subsets of nodes in that component and check whether the subset is a valid choice i e is an independent set We can then do a DP for each component where dp mask k the number of submasks of mask that have k ones and represent a valid independent set subset of the component Finally we can iterate over the total number of mercenaries we want We can then do a knapsack over each of the components making sure to only consider nodes in each component where and work with our number of mercenaries Finally we determine how many valid mercenaries are available outside of our components and the rest is a simple choose function Code 90977154 
1510,Let s consider a problem without queries of the second type Now we can try to solve the problem using Mo s algorithm Let s maintain array the number of occurrences of on the current segment and array array sorted in descending order Let s take a look at how we should handle adding an element equal to Surely we should increase by but now we should erase an element equal to from the array and insert an element is such a way that the array is still sorted Instead we can increase the leftmost element equal to by Similarly we can handle deleting an element decrease the rightmost element equal to by In order to quickly find the leftmost rightmost element equal to we can store the left and the right bounds of the array where all the numbers are equal to To answer the query of type we should find two elements in the array at distance whose absolute difference is minimal Since the size of the array without zero elements is we can t look at the whole array But using the fact that there are no more than different values in the array we can create an auxiliary array of pairs the value from the array and the number of occurrences of that value In such an array we need to find a subarray where the sum of the second elements in the pairs is at least and the absolute difference between the first elements in the pairs is minimal That can be solved using standard two pointers method in The total complexity of the solution is In fact we can use Mo s algorithm even with updates But its complexity is You can read the editorial of the problem 940F on Codeforces or the following blog to learn about processing updates in Mo https codeforces com blog entry 72690
1511,Let s rewrite the formula of distance between two points as follows where if otherwise Consider what will happen if we change some to the opposite value The result of this formula obviously won t increase so we may try all possible values of and pick maximum result This allows us to consider every option to set values of there are such options separately and when we fix a set of values of find two points that maximize the distance if it is expressed with fixed To do so we have to find the point having maximum and having minimum So actually our problem is reduced to the following we have arrays we want to process some queries in the form change an element of some array and find maximum and minimum on some segment of some array This can be done simply by building a segment tree over each array and then we will get the solution having time complexity 
1512,I could ve explained the jury solution however after the contest I found a much easier and more understandable solution by one of the participants I put one of jury s solutions under the spoiler along with a link to the solution I m explaining Let s restate the problem in a more convinient way Initially we are given some directed acyclic graph Let there be nodes of two kinds For a direct set operation These will have a single outgoing edge to another node For a binary operation These will have two outgoing edges to other nodes However it s important which edge is the left one and which is the right one We also have to make dummy vertices for the variables which only appeared at the right side of some operation We are allowed to remove any direct set operations we will simulate this by compressing the edges of the graph Instead of doing we ll do Value wise this is the same but variable don t rely on anymore so might be deleted We ll build the entire graph line by line Let s maintain array which will keep the current value of each variable It will store the node itself It s probably better to store both kinds of nodes in a separate array so that and the pointers to the ends of the edges could be integers If we encountered no variable getting set then the answer is 0 Otherwise let s traverse from the node representing the current value of to every reachable node While building the graph we were compressing every unoptimal operation thus all reachable nodes matter Finally the last operation on might have been just a direct set That s unoptimal so we ll handle that case separately 
1513,Let s look at some facts At first the answer is the sum of weights taken with some coefficients So it s enough to calculate those coefficients Then can be calculated by iterating on the size of the subset containing th element where is the number of partitions of set with elements into nonempty subsets with one subset of fixed size where belongs This solution is still quite slow so the next fact is if two elements and belong to the same subset then increases the coefficient before So for each element we can iterate over all elements which will lie in one subset with In other words is the number of ways to divide set with elements into subsets in such a way that elements and wil lie in one subset can be calculated using Stirling numbers of the second kind let be the number of partitions of set with elements into non empty subsets If then else we just merge and into one element and let Final formula is And the answer is Counting Stirling numbers can be done with inclusion exclusion principle or by searching Wiki Resulting complexity is 
1514,For each pawn with initial position there exists a minimum index of row such that the pawn can reach the cell but cannot reach the cell It s easy to see that In the resulting configuration this pawn can occupy the cell or any other cell having Suppose the board consists of rows For each row the number of rows above it should be not less than the number of pawns that occupy the cells above it that is having greater than the index of that row because if this condition is not fulfilled we can t assign each pawn a unique cell If we denote the number of pawns that should go strictly above the th row as then for every row the condition must be met To prove that this condition is sufficient we may for example use Hall s theorem Okay now what about finding the minimum satisfying it Let s initially set to and for each row maintain the value of the minimum number of rows we have to add to our board so that the condition for the row is met we also have to maintain this value for auxiliary rows from to since some pawns cannot fit in the initial board at all Finding the minimum value we have to add to equals finding the maximum of all these values on some prefix we don t need to look at the values on some rows with large indices if there are no pawns after them so we need a maximum query on the segment where is the maximum index among all pawns and when a pawn is added or removed we should add or to all values on some suffix A segment tree with lazy propagation will do the trick solving the problem for us in 
1515,Most of the solutions used the fact that we can read all the queries compress them and process after the compression using simple segment tree But there is also an online solution Let s build a sparse table on array to answer queries on segments that are not modified in To process modification segments we will use implicit segment tree and lazy propagation technique We do not build the whole segment tree instead in the beginning we have only one node for segment and if some modification query accesses some node but does not modify the complete segment this node maintains only then we create the children of this node So the leaves of the segment tree are the nodes such that their segments are completely set to some value or not modified at all Since each modification query affects only nodes the resulting complexity will be 
1516,This problem can be reduced to one of well known flow problems Projects and Instruments In this problem we have a set of projects we can do each with its cost and a set of instruments each also having some cost Each project depends on some instruments and each instrument can be used any number of times We have to choose a subset of projects and a subset of instruments so that if a project is chosen all instruments that this project depends on are also chosen and we have to maximize the difference between the sum of costs of chosen projects and the sum of costs of chosen instruments The problem about projects and instruments can be solved with the following flow network for each project create a vertex and add a directed edge from the source to this vertex with capacity equal to the cost of this project for each instrument create a vertex and add a directed edge from this vertex to the sink with capacity equal to the cost of this instrument for each project create edges with infinite capacity from the vertex denoting this project to all vertices denoting the required instruments for this project Let s analyze an cut between the source and the sink in this vertex and construct some answer based on this cut as follows if a project vertex belongs to then we take this project if an instrument vertex belongs to then we take this instrument all other projects and instruments are discarded If an edge between some project and some instrument is cut then it means that the answer is incorrect we try to take a project requiring some instrument we don t take and the cut value is infinite Otherwise the value of the cut is equal to the total cost of taken instruments and discarded projects and we need to minimize it So the minimum cut in this network denotes the best answer Reducing the given problem to this problem is easy edges of the given graph are projects vertices of the given graph are instruments Regarding implementation any flow algorithm using capacity scaling should be sufficient It seems that Dinic also passes even though its complexity is 
1517,We need some sort of better criterion other than all matches can be predicted first Suppose the ratings of the participants are in the order of their indices Then if all games are predictable the th game should be won by the participant with the rating equal to and in the th game they will play against the participant with rating So in order for each game to be predictable This is the criterion we will use So we will try to count the number of orderings meeting this condition One very important observation we need to make is that if we remove several participants with the lowest ratings from the ordering that ordering still satisfies the condition for each element either the prefix before it is removed completely or the maximum on it is unchanged So this allows us to construct the correct ordering by placing the sportsmen from the maximum rating to the minimum rating and making sure that on every step the order stays correct Okay Let s reverse the ratings array and try to write the following dynamic programming is the number of correct orderings of the first sportsmen the highest rated sportsmen since we reversed the ratings array Let s try to place the next sportsman We run into the following issue for some orderings of the first sportsmen it is possible to place the next one anywhere these orderings are where the first sportsman in the ordering doesn t conflict with the sportsman we are trying to place but for other orderings some positions might be forbidden And to keep track of which positions are forbidden and for which sportsmen we probably need some additional states for the dynamic programming which we don t really want to since states is probably the most we can allow Okay so let s avoid this issue entirely We don t like the orderings where the next sportsman can t be placed anywhere so let s find a way to ignore them discard the previous definition of Now let is the number of correct orderings of the highest rated sportsmen when we place the next sportsman in case it becomes the first element and conflicts with some of the elements we haven t placed yet So this leads to the following transitions in the dynamic programming if we place the th sportsman on any position other than the first one there are ways to do it and we transition from to otherwise if we place the th sportsman on the first position let be the last sportsman conflicting with the sportsman Let s try placing all sportsmen from to before placing the sportsman They cannot be placed on the first position otherwise they will conflict either with each other or with the sportsman so the first one can be placed in ways the second one in ways and so on this product can be easily calculated in by preparing factorials and inverse factorials So then we transition from to There is a special case in our dynamic programming It should start with but what if the st sportsman conflicts with someone Then the ordering of the first sportsmen is incorrect In this case the answer is since the st and the nd sportsmen are conflicting Overall complexity of this solution is or depending on your implementation 
1518,Let s denote and analogically Then we can note that So we can switch to calculating and Let s be the closest from the left to element such that To calculate we will look from the other side we will look at it as the sum of lengths of segments induced by each element from Each element will add to value equal to or a piecewise linear function if we look at as a variable And is a value of a sum of linear functions induced by in a point To process it efficiently we can one by one add induced linear functions to the corresponding subsegments using BIT or Segment Tree and if we ve added functions induced by we can calculate answer for all queries which looks like To calculate we can just reverse array and all queries Result time complexity is Note that it s still works quite slow so you should use fast data structures like BIT of iterative segment tree 
1519,Let s consider what the sequence of removals looks like in general We will base some intuition on a fact that at least one valid sequence is guaranteed to exist Remove all vertices that have their degree correct from the start at once There surely be such vertices since a valid sequence would have to start with some of them Notice that there can t be any adjacent vertices among them If there were we wouldn t be able to remove such a pair regardless of the order we choose since removing one of them makes another one s degree too low Now remove the vertices that just got their degrees correct from removing the first layer Once again these must exist if the graph is not empty yet because otherwise any valid sequence would get stuck Process until nothing is left This algorithm is basically a bfs and you can implement it like one Note that each vertex becomes available to be removed only after a certain subset of its neighbours is removed No matter what order you choose to remove the vertices in these vertices will always be the same Huh so for each vertex some of its neighbours have to be removed before it and the rest have to be removed after it since otherwise the degree of that vertex will become too low That actually means that our graph is not as undirected as it seemed We can direct each edge from a vertex that is removed before the other This makes a valid sequence of removals just a topological sort of that directed graph So a pair is nice if there exist two topological orders such that and go one before another in them We can make a bold but perfectly reasonable guess about all nice pairs A pair is nice if neither of and are reachable from each other The necessity of this condition is obvious Let s show sufficiency Let s show the construction such that goes before To remove we first have to remove all vertices that have edges to To remove them we have to remove vertices with edge to them And so on Basically to remove we have to remove all vertices that are reachable from on the transposed directed graph Since is not reachable from it doesn t have to be removed before So we can first remove all the required vertices then remove then continue removing vertices until we are able to remove By switching and in the description of that construction we can obtain the construction for before Thus we reduced the problem to a rather well known one Calculate the number of reachable pairs of vertices in a directed graph As far as I know it s not known to be solvable in sub quadratic time And we are not given a specific graph Yes it s obviously acyclic but turns out every acyclic graph can be made into a test for this problem You just have to make equal to the number of the outgoing edges for each Somehow we are still given vertices and edges If you are more familiar with that problem you might know that you can use bitset to solve it In particular let be a bitset such that if if reachable from Then you can initialize for all vertices and propagate the knowledge in reverse topological order by applying for all edges Unfortunately that requires memory and bits is over a gigabyte Let s use of my favorite tricks to make a solution with memory and the same complexity Man I love that trick Process vertices in batches of Let s calculate which vertices can reach vertices from to The algorithm is basically the same For each vertex store a smaller bitset of size also known as an unsigned long long Initialize the bitset for vertices from the batch and propagate the same way for all vertices Now just add up the number of ones in each bitset builtin popcountll Proceed to the next batch That makes it iterations of a algorithm This might require some constant optimizations In particular I suggest not to use dfs inside the iteration since the recursion makes it really slow You might iterate over a vertex in reverse topological order and its outgoing edges Or which is way faster unroll that graph into a list of edges and iterate over it directly 
1520,First of all let s find all possible lengths of the laps after doing that we can just check every divisor of to find the maximum possible length of a lap for a given query A lap is always a rectangle you can t construct a lap without using any vertical segments or using an odd number of vertical segments and if you try to use or more vertical segments you can t go back to the point where you started because both horizontal segments are already partially visited So a lap is a rectangle bounded by two vertical segments and if we use vertical segments and the perimeter of this rectangle is Let s find all values that can be represented as A naive approach will be too slow we have to speed it up somehow Let s build an array of numbers where is some integer greater than Each number that can be represented as can also be represented as so we have to find all possible sums of two elements belonging to different arrays The key observation here is that if and are small we can treat each array as a polynomial let and similarly Let s look at the product of that polynomials The coefficient for is non zero if and only if there exist and such that so finding all possible sums and all possible differences can be reduced to multiplying two polynomials which can be done faster than using Karatsuba s algorithm or FFT 
1521,Let s find some path from to Let its length be then the answer to the problem can be represented as where is the total length of some set of cycles in the graph they can be disconnected it doesn t matter because we can traverse the whole graph and return to the starting vertex with cost Let s treat each cycle s cost as a vector where is the th bit in binary representation of cycle s cost We can use Gaussian elimination to find the independent set of vectors that generates all these vectors To do this let s build any spanning tree of the graph and then for any edge not belonging to the spanning tree we can try to add to the independent set is the length of the path from the root to in the spanning tree When trying to add some vector we firstly need to check if it can be represented as a combination of some vectors from the set and only if it s impossible then we add it to the set The number of vectors in the set won t exceed so we can use Gaussian elimination to check if the vector is a combination of elements from the set Then after we found the basis let s build the answer greedily from the most significant bit to the least we will check if we can set the current bit so it is equal to the corresponding bit of while maintaining all the previous bit To check it we also can use Gaussian elimination 
1522,Since the graph is acyclic then for every vertex there exists a path to some sink and to every vertex there exists a path from some source So our problem can be reduced to the following check that after running our algorithm all vertices from the initial set of sources and sinks belong to the same strongly connected component Let be the number of sources or sinks in the initial graph First of all let s run DFS or any other graph traversal from every source to form a set of reachable sinks for every source This part of solution has complexity of If is some set of sources of the original graph let be the set of sinks such that every sink from is reachable from at least one source from It s easy to see that there exists some set such that and then the answer is if we connected the sinks from with the sources from then any sink not belonging to would be unreachable from any sink belonging to Checking every possible set can be done in or in Let s prove that there is no such set then the answer is Let be an arbitrary sink of the original graph Also if is some set of sinks let be the set of sources containing every source directly connected to some sink from We can use mathematical induction to prove that every source and every sink is reachable from in the resulting graph Initially we state that is reachable from quite obvious If there is a set of sinks reachable from then either and the whole graph is reachable from or the number of sinks reachable from is at least so some set of sinks is reachable from So in fact checking every possible subset of sources is enough 
1523,Suppose there is no constraint on the number of letters used Then this problem can be solved with the following dynamic programming let be the number of strings of length ending with characters and that don t contain palindromes of odd length greater than obviously each forbidden palindrome contains a subpalindrome of length so we only need to ensure that there are no palindromes of length The thing we are going to use in order to ensure that all the constraints on the number of characters are met is inclusion exclusion Since each at most two characters can violate their constraints in a single string so we will iterate on some character of the alphabet and subtract the number of strings violating the constraint on this character from the answer then iterate on a pair of characters and add the number of strings violating the constraints on these two characters to the answer Okay how to calculate the number of strings violating the constraint on some fixed character Let s use dynamic programming the number of strings such that they contain characters of them have the same type that we fixed the previous to last character is and the last character is The number of states here seems to be something about but in fact and can be optimized to have only two different values since we are interested in two types of characters the ones that coincide with the character we fixed and the ones that don t Okay what about violating the constraints on two characters The same method can be used here let be the number of strings consisting of characters such that the number of occurrences of the first fixed character is the number of occurrences of the second fixed character is the previous to last character is and the last character is Again at first it seems that there are up to states but and can be optimized to have only different values so the number of states is actually It seems that we have to run this dynamic programming for each pair of characters right In fact no the only difference is which states violate the constraints and which don t We can run this dp only once and when we need an answer for the pair of characters we can use two dimensional prefix sums to query the sum over with and in In fact this dynamic programming can also be used for the first and the second part of the solution calculating the strings that don t violate any constraints and the strings that violate the constraints on one character so the hardest part of the solution runs in though with a pretty big constant factor 
1524,For a string let s define its as the mask of bits where th bit is if and only if is a subsequence of Let s suppose we somehow calculate the number of strings for each and we denote this as for a mask How can we use this information to find Suppose this set of strings is represented by a mask then the strings which are included in are the strings such that their characteristic mask has bitwise AND with equal to i e these characteristic masks are submasks of We can use SOS DP to calculate these sums of over submasks in The only problem is how to calculate for every mask Let s analyze when a string is a subsequence of a sorted string The subsequence should be sorted as well and the number of occurrences of every character in a subsequence should not exceed the number of occurrences of that character in So if there are characters in characters in and so on then the number of its subsequences is What about subsequences of every string from a set These conditions on the number of occurrences should apply to every string in the set so for each character we can calculate the minimum number of occurrences of this character in each string of the set add and multiply these numbers to get the number of strings that are subsequences of each string in a set These values can be calculated in for all subsequences of using recursive approach Can these numbers be used as Not so fast Unfortunately these values let s call them are the numbers of subsequences of the chosen sets of strings but we have no information about the strings that are not included in the chosen set of strings To handle it we can use the following equation where means that is a submask of To transform the values of into the values of we can flip all bits in the masks so is the sum of over all submasks of apply inverse SOS DP also known as Mobius transformation and then flip all bits in the masks again So we found a way to calculate all values of in and we have already discussed what to do with them in the first paragraph of the editorial The overall complexity of the solution is 
1525,We will run two tests for each substring of we are interested in If at least one of them shows that the substring is not an occurence of we print otherwise we print The first test is fairly easy The given permutation can be decomposed into cycles Let s replace each character with the index of its cycle in both strings and check if each substring of is equal to after this replacement for example using regular KMP algorithm If some substring is not equal to after the replacement then it is definitely not an occurence The second test will help us distinguish the characters belonging to the same cycle Let be some cycle in our permutation elements are listed in the order they appear in the cycle so We will replace each character with a complex number in such a way that the case when they match are easily distinguishable from the case when they don t match One of the ways to do this is to replace with a complex number having magnitude equal to and argument equal to if this character belongs to or to if this character belongs to How does this replacement help us checking the occurence If we multiply the numbers for two matching characters we get a complex number with argument equal to or to and its real part will be In any other case the real part of the resulting number will be strictly less than and the difference will be at least So if we compute the value of for the th substring of where is the number that replaced the character we can check if the real part of the result is close to the value we would get if we matched with itself and if the difference is big enough at least one pair of characters didn t match The only case when this method fails is if we try to match characters from different cycles of the permutation that s why we needed the first test Overall the first test can be done in using prefix function or any other linear substring search algorithm and the second test can be done in if we compute the aforementioned values for each substring using FFT 
1526,Let s use centroid decomposition to solve the problem We need to process all the paths going through each centroid somehow Consider a path from vertex to vertex going through vertex which is an ancestor of both and in the centroid decomposition tree Suppose the sequence of numbers on path from to including both these vertices is and the sequence of numbers on path from to including but excluding is Let and We can show that the sum of prefix sums of is equal to Now suppose we fix the second part of the path and are fixed and we want to find the best first part for this second part Each possible first part is represented by a linear function and our goal is to find the maximum over all these linear functions in the point and add to this maximum This can be done with the help of convex hull or Li Chao tree The most difficult part of implementation is how to process each centroid s subtree It s easy to obtain all first parts and second parts of paths going through the centroid but pairing them up can be complicated for each second part we have to build a convex hull or Li Chao tree on all first parts going to this centroid excluding those which go through the same child of the centroid as the second part we are considering One of the best ways to implement this is the following Suppose our centroid has children is the set of first parts going from the th child of the centroid and is the set of second parts going to the th child We will create a new data structure initially empty process all second parts from add all first parts from process all second parts from add all first parts from and so on After that we will clear our data structure process all second parts from add all first parts from process all second parts from add all first parts from and so on until we add all first parts from That way we will consider all possible first parts for each second part we are trying to use 
1527,Let s solve this task in several steps At first let s calculate sum of all triples For each player consider three cases there are exactly ways to choose triple there are ways there are ways At second let s calculate sum over all triples such that exists pair or To calculate it we need for each iterate over all neighbors of Again some cases if then there are exactly ways to choose if there are ways to choose But we calculated some triples twice so we need to subtract triples where both and exists It is easy to calculate sorting adjacency lists of all At third let s calculate sum over all triple where exists pair but pairs and are not is a sum of all triples where pair exists It can be calculated while iterating in increasing order is a sum of all triples where pairs and exists It can be calculated while iterating and asking sum on segment of adjacency list of with prefix sums for each vertex is a sum of all triples where pairs and exists It can be calculated while iterating and asking sum on prefix of adjacency list of same is a sum of all triples where all pairs and exists It is modification of calculating number of triangles in graph It can be done in and will be explained below Then result The algorithm of finding in the given graph is following Let s call vertex if and otherwise For each heavy vertex precalculate boolean array of adjacency of vertex It s cost of memory and time but memory can be reduced by using bitsets To calculate number of triangles let s iterate over There are two cases if is heavy then just iterate over all edges and check and This part works with time since there are heavy vertices if is light then iterate over all pair where at first fix then iterate To check existence of edge consider two more cases if is heavy just check It works in if is light just check in some global array all neighbors of check all with and uncheck neighbors of Checking in array require time and will be done times So it will be in total Similarly iterating pairs works with in total So comlexity of algorithm and all task is 
1528,Let s denote as the largest of the terms of the sum and is the smaller one Consider cases or If then So we need to find two consecutive substrings of length such that if we convert these substrings into integers their sum is equal to If let be the largest common prefix of and if we consider them as strings Then or So it is necessary to check only these two cases and whether goes before or after in the string Thus we have reduced the number of variants where the substrings for and are located to It remains to consider how to quickly check whether the selected substrings are suitable To do this you can use hashes preferably with several random modules 
1529,Let s consider two solutions a non deterministic and a deterministic one The random solution goes like that Let s assign a random integer to each value from to to value not to a position Let the value of the subarray be the trit wise sum of the assigned integers of all values on it Trit wise is the analogue of bit wise sum xor but in ternary system So adding up the same integer three times trit wise is always equal to zero Thus if the value on a subarray is zero then each value appears on it a multiple of three times How to count the number of such subarrays Process the array from left to right and store the prefix trit wise sums in a map The number of the valid subarrays that end in the current position is the number of occurrences of the current prefix trit wise sum in a map The current sum should be added to the map afterwards However that s not what the problem asks us to find Let s consider another problem count the number of subarray such that each number appears no more than three times This can be done with two pointers Process the array from left to right and for each number store the positions it occurred on If some number appears at least four times than the left pointer should be moved to the next position after the fourth to last position The number of valid subarrays the end in the current position is the distance to the left pointer Let s combine these problems maintain the pointer to only the valid positions and remove the prefix trit wise sums from the map as you increase the pointer That way the map will only store the valid sums and they can be added to answer as they are Assume you use trits I guess the probability of the collision is the same as two vectors out of colliding in a dimensional space with their coordinates being from to That will be about when according to birthday paradox and way less if we increase Overall complexity The deterministic solution a k a the boring one goes like that Let s again process the array from left to right Let the current position be the right border of the segment Each number makes some constraints on where the left border might be More specifically it s two possible segments between its last occurrence and the current position and between its fourth to last occurrence and its third to last one Let s actually invert these segments Bad segments are from the beginning of the array to the fourth to last occurrence then from the second to last occurrence to the last one So the valid left borders are in such positions that are covered by zero bad segments Let s keep track of them in a segment tree Add on the bad subarrays Now you have to count the number of values in a segtree That s a pretty common problem As we know that no values can go below should be a minimum element on the segment So we can store a pair of minimum on segment number of minimums on segment At the end the second value is the number of zeros if the first value is zero Overall complexity 
1530,The group of the rows where the number of rectangular tiles increases times and then decreases times can be represented as a rectangular table with diagonals where the size of the first diagonal is equal to the number of rectangular tiles before the operations are applied let their number be and the size of the last diagonal is In such a rectangular table one can move from the cell to the cells and if they exist which lie on the next diagonal next row in terms of the original problem It s a well known fact that the number of different paths from one cell to another is some binomial coefficient Let s define as the number of paths from the st row to the th tile in the th row i e row after the th group of operations Now we want to find the values of using the values of let its size be Using the fact described in the first paragraphs we know that depends on with some binomial coefficient In fact for But this solution is too slow To speed up this solution we have to notice that the given formula is a convolution of and some binomial coefficients So we can use NTT to multiply them in instead of time 
1531,After the first query make the vertex that we painted black the root of the tree and for each other vertex calculate the minimum index on the path to the root This can be done by simple DFS Then suppose we are painting some vertex black In can easily proved that for every vertex and every vertex that is on a path form to the root there exists a path from to some black vertex coming through So we have to store the minimum index among all vertices such that belongs to the path from the root to some black vertex it is a global value let s call it and the answer to every query of type is just the minimum of the value we calculated in DFS and To update quickly after painting vertex black we ascend from to the root until we arrive to some node that was visited during previous queries and we stop there because this node and all nodes on the path from it to the root were used to update in previous queries This solution works in time 
1532,Let s solve this task in several steps Step 1 Calculate for each vertex Let be maximal profit of some 2 path starting at and finishing at If vertex is a root of the tree then equivalent to where maximal profit of 2 path when we can go only in subtree of The can be calculated with next approach To calculate we can use next technique Let s manage next invariant when processing vertex all its neighbours even parent will hold as if its parent Then After that we can proceed with each child of but before moving to it we must change value since we must keep invariant true To keep it true it s enough to set Also let s memorize value as Step 2 Processing queries Let simple path be If then answer is Otherwise each edge on this simple path must be used exactly once But while travelling from to using this simple path at each vertex we can go somewhere and return to the only condition is not use edges from simple path And we can do it using precalculated values and So if we want to find max profit of 2 path with prohibited edges so we can use value Finally to process queries let s find divide it on two queries Now we can handle all queries offline travelling on tree in dfs order Let s manage some data structure on current path from current vertex to the root this DS can be based on array of depths Then when we come to vertex just add value to DS in position and erase it before exit Each query becomes a query of sum to some subsegment in DS don t forget carefully handle value in lca And before moving from to you need subtract from current value of here you can at once subtract weight of edge Don t forget to return each change in DS when it needed As we can see DS is just a BIT with sum on segment and change in position Result complexity is Fast IO are welcome 
1533,We can first compute all values of Since we only care about the maximum such value within our segment we can use div conquer to solve every segment In particular if we know the index of the maximum value in we know that any segment crossing this index has this value as its maximum We can thus solve all segments crossing this maximum and recurse on the left and right sides To find the best crossing segment note that each problem contributes a value of We can independently find the largest sum starting from our crossing index going left and the largest sum going right and add these two together for the best overall crossing segment Unfortunately since we can t guarantee that the maximum indices will divide our interval nicely in half this does not lead to the usual runtime of div conquer but is instead in the worst case To improve on this we can precompute partial sums of and use RMQ to find the minimum sum left of the crossing index and the maximum sum right of the crossing index This reduces the crossing computation from per index to or giving an overall runtime of Code 49036431 
1534,Firstly let s define the weight of path as On contrary to weighted distances and also Now let s define the diameter of a tree as path with maximum It s okay if diameter may be explicit case The useful part of such definition is next our diameter still holds most properties of the usual diameter Let s look at two of them There is a vertex on diameter path with and It s easy to prove after noting the fact that and otherwise you could choose diameter or For any vertex eccentricity In other words either or has the maximum distance from You can also prove it by contradiction It also means that The two properties above give us an easy way to calculate the radius just maintain diameter and the answer is a half of it Now let s look how the diameter changes when we change the weight If it s quite easy The only paths that change weights are the paths ending at Denote such path as and note that either or In other words there will be only three candidates for a new diameter path with path with path with The only thing you need to calculate fast enough is the two distances and And since your task is to calculate Finally how to handle decreasing s Let s get rid of them using DCP dynamic connectivity problem technique Keep track of each value each possible value for some vertex will be active on some segment of queries Since there are only queries there will be exactly such segments for all vertices in total Now all queries becomes assign on some segment of queries Note that in that case the previous value of was so you are dealing with only increasing value queries Finally to handle all range queries efficiently you build a Segment Tree on queries set all queries and then traverse your Segment Tree while maintaining the current diameter in order to calculate answers for all queries Each of queries transforms in queries to segment tree vertices and preforming each query asks you to calculate two times If you use the usual binary lifting then your complexity becomes what is okay But if you use Sparse Table on Euler tour you can take in and your complexity will be 
1535,Some notes At first there is since lets define as That means that for each there is exactly one that So if we look at this problem as the graph then it consists of cycles consider loops as cycles of length one So we need to know number of cycles in this graph At second since and and So all can be divided in groups by its And we can calculate number of cylces in each group independently Let fix some equal to All numbers such that can be represented as and Number of such equals to Moreover Here we can shift from and to and In result we need for each calculate number of cycles created by from numbers that and Lets set Next step is to find minimal such that let s name it order of or Then for each if then and so each cycle will have length equal to and number of cycles will be equal to Last step is calculate for each There is a fact that so can try to iterate over all divisors of and check by binary exponentiation It seems as but it s faster and author s version work around 2 seconds It doesn t pass but somebody can write better But we ll speed it up Let So we can independently for each find its minimal power such that We can just iterate over all and since Some words about finding its factorization differs from factorization of just by lowering degrees of primes and adding factorizations of some But we can manually find factorization of with memorization or even without it since So our steps are next factorize recursively iterate over all divisors of find and and add to the answer Result complexity is And the last note is how to multiply modulo You can use binary multiplification which will give you extra what is not critically in this task in C of course Or you can use multiplification from hashes which will work with 64 bit double since it s only 
1536,We can use Boruvka s algorithm to solve this problem This algorithm usually works in initially MST is empty and then we run a number of iterations During each iteration we find connected components in the graph formed by already added edges and for each component we find the shortest edge that leads out of this component Then we add the edges we found to the MST but we should be careful to avoid adding edges that form cycles in MST The number of iterations is at most and each of iterations can be done in However in this problem we need to speed up this algorithm We can do each iteration in time using a binary trie We can store all values from in a trie When we need to find the shortest edge that connects some component with vertices outside of it we firstly remove all values contained in this component from the trie After that for each vertex in the component we can find the closest vertex outside the component in by descending the trie And then we insert the values of belonging to the component back into the trie Since for each vertex we descend the trie three times to remove it to find closest vertex and to add it back each iteration requries and the whole algorithm works in time 
1537,The key observation in this problem is that the values of should form a contiguous segment of integers For example suppose there exists a value such that there is at least one there is at least one but no We can decrease all values of that are greater than by so the answer will still be valid but the value of will decrease So the values of form a contiguous segment of integers We can always assume that this segment is since subtracting the same value from each does not change anything The other observation we need is that we can rewrite the expression we have to minimize as follows where is the signed sum of weights of all arcs incident to the vertex the weights of all arcs leading from are taken with positive sign and the weights of all arcs leading to are taken with negative sign These two observations lead us to a bitmask dynamic programming solution let be the minimum value of if we assigned the values from to the vertices from A naive way to calculate this dynamic programming is to iterate on the submask of check that choosing the integer for each vertex from that submask doesn t ruin anything for each vertex that belongs to this submask all vertices that are reachable from it should have so they should belong to but not to the submask we iterate on and update the dynamic programming value But this solution is and depending on your implementation this might be too slow It s possible to speed this up to in a way similar to how profile dp can be optimized from to we won t iterate on the submask instead we will try to add the vertices one by one and we should be able to add a vertex to the mask only if all vertices that are reachable from it already belong to the mask There is a possibility that we add two vertices connected by an arc with the same value of so for a fixed value of we should consider assigning it to vertices in topological sorting order that way if one vertex is reachable from another it will be considered later so we won t add both of those with the same value of 
1538,At first implement your favourite string suffix structure for comparing pair of suffixes lexicographically fast enough For example it s a Suffix Array linear LCP Sparse Table Now we can compare two suffixes and by finding and comparing with We will process queries online Let current query be a pair of arrays and We will calculate answer in two parts To calculate the first sum we can sort all suffixes in lexicographical order and maintain some information for prefixes of What information we need to maintain We need some Data Structure which will hold of suffixes from When we process some we need just a total sum of all in the DS If we should add to the DS length of th suffix And when we move from to we must recalculate some Since is sorted all we need is to set In fact this Data Structure is just a In this we will hold for each length number of suffixes with we will hold only non zero values When we should add some suffix we manually increase some value by one Setting with can be done with decreasing maximum in while its more than It can be proven that there will be operations with for one query The total sum can be maintained in some global variable which will be recalculated each time changes To calculate the second sum we can just reverse and run the same algorithm So total complexity is 
1539,First of all let s calculate minimum cut instead of maximum flow The value of the cut is minimum if we choose the first set of the cut as first vertices of part and first vertices of part That s because if is the minimum index such that then we don t have to add any vertices such that to because that would only increase the value of the cut Similarly if is the maximum index such that then it s optimal to add every vertex such that to Okay so we can try finding minimum cut as a function value of the cut if we choose as the union of first vertices in and first vertices in To find its minimum let s rewrite it as where is the sum of capacities of edges added to the cut in part it doesn t depend on part is the sum of capacities added to the cut from part and is the sum of capacities added to the cut by edges going from to These functions can be denoted this way if otherwise is the capacity of the edge going from to if otherwise is the capacity of the edge going from to is the sum of capacities over all edges such that and Since only the values of are not fixed we can solve this problem with the following algorithm For each find the minimum possible sum of Let s denote this as and let s denote Build a segment tree that allows to get minimum value and modify a single value over the values of When we need to change capacity of an edge we add the difference between new and old capacities to and to calculate the maximum flow we query minimum over the whole tree But how can we calculate the values of We can do it using another segment tree that allows to query minimum on segment and add some value to the segment First of all let s set and build this segment tree over values of The value of is fixed for given so it is not modified the value of is initially since when there are no vertices belonging to in the part And then we calculate the values of one by one When we increase we need to process all edges leading from to part When we process an edge leading to vertex with capacity we have to add to every value of such that since if then and this can be performed by addition on segment in the segment tree After processing each edge leading from to part we can query as the minimum value in the segment tree Time complexity of this solution is 
1540,Important note the author solution is using both linear Convex hull trick and persistent Li Chao tree As mentioned in commentaries applying the Divide and Conquer technique can help get rid of Li Chao tree More about both structures you can read in this article Let s try to write standard dp we can come up with arrays will be 0 indexed Let be the minimal weight if we splitted prefix of length in subsegments Then we can calculate it as 1 Maximums on segments are inconvenient let s try to group segments by the value of So we can find such sequence of borders where for each In other words and is the closest from the left position where Note that we can maintain this sequence with stack of maximums Ok then for each interval equation 1 transforms to Why did we use variables and Because there are two problems is needed because we iterate over and can t recalculate everything is needed because sequence is changing over time so do the But what we can already see we can maintain for each segment Convex hull with linear functions so we can take in logarithmic time Moreover we can store values in other Convex hull to take minimum over all segments in logarithmic time The problems arise when we try modificate structures while iterating Fortunately segments change not at random but according to stack of maximums So all we should handle are to merge segment on top of the stack with current segment in case when to erase segment on top of the stack along with its value to insert new segment on top of the stack along with its value To handle the third type is easy since all Convex hulls can insert elements There will be at most such operations on a single layer and we can ask value in and insert a line with To handle the second type is harder but possible since we can make Convex hull persistent and store its versions in the stack Persistent Convex hull persistent Li Chao tree There will be also operations in total and they cost us To handle the first type is trickiest part Note that all line coefficients of one convex hull are strictly lower than all line coefficients of the other So we can use linear Convex hulls to make insertions to back in amortized But to merge efficiently we should use Small to Large technique that s why we should be able also push front in and moreover still be able to ask minimum in And here comes the hack in C which can push pop front back in amortized and also have random access iterator to make binary search possible So each element of every segment will be transfered times with cost of amortized on a single layer In the end result complexity is Space complexity is 
1541,At first when we read the problem a simple solution comes to our mind take a look at the LCA Lowest Common Ancestor of that starting and ending vertices of the path and then use combinatorics to calculate the number of the paths but after trying to implement this or solve this on paper it doesn t seem to be easy at all and it may even be impossible to implement this So lets try to solve this problem in a different way For calculating the answer we count the number of times each path starts or ends at every vertex and then divide them by to get the answer for each vertex For calculating the answer to the above it is easy to see that all vertices with the same height have the same number of paths going through them so if we calculate the number of paths going through one of them and then multiply it by the number of the vertices in that height let it be it gets equal to our answer We can calculate the answer for a certain height So to do that we divide the paths into two types paths that go only into the subtree of a vertex let s call it and paths that go up let s call it For the ones that are in the subtree it is easy to see if there are at least other vertices that go down we can go all paths going down let the number of them be and the answer for this part equals to For the ones that go up we use dynamic programming and we define the number of paths that start at a vertex with height and have length and do not use the leftmost edge exiting the vertex at height To update this either we go down on one of the paths and then we go through a path of length or we go up and get a path of length starting at a vertex from height so the answer for this one equals to Now And the final complexity of the solution will be but because of the large constant of the solution the time limit is higher 
1542,Unfortunately it seems we failed to eliminate bitset solutions The approach in our model solution is the following Firstly let s try to find some naive solution for calculating the distance between two strings We may build an undirected graph where vertices represent letters and edges represent that one letter must be transformed into another Then all letters in the same component should become one letter so the answer is the number of distinct letters minus the number of components Then let s get back to original problem For every substring of we have to find which letters have to be merged to make it equal with This can be done with the help of FFT to find all positions in substrings of with character that coincide with occurences of in we may compute a convolution of two following arrays set to every position in where occurs and to every position in where occurs all other elements should be After trying these convolutions for every pair of different characters we compute the answer for every substring using DFS or any other method 
