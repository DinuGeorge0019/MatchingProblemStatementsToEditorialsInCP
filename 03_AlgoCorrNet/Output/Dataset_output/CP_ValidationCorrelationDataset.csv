,statement,editorial,label
0,You have barrels lined up in a row numbered from left to right from one Initially the th barrel contains liters of water You can pour water from one barrel to another In one act of pouring you can choose two different barrels and the th barrel shouldn t be empty and pour any possible amount of water from barrel to barrel possibly all water You may assume that barrels have infinite capacity so you can pour any amount of water in each of them Calculate the maximum possible difference between the maximum and the minimum amount of water in the barrels if you can pour water times Some examples if you have four barrels each containing liters of water and you may pour liters from the second barrel into the fourth so the amounts of water in the barrels are and the difference between the maximum and the minimum is if all barrels are empty you can t make any operation so the difference between the maximum and the minimum amount is still ,A greedy strategy always works take largest barrels choose one barrel among them and pour all water from those barrels to the chosen barrel That way we make the minimum amount equal to it s quite obvious that we can t do anything better here and the maximum amount as large as possible so the difference between them will be as large as possible ,1
1,Ivan wants to play a game with you He picked some string of length consisting only of lowercase Latin letters You don t know this string Ivan has informed you about all its improper prefixes and suffixes i e prefixes and suffixes of lengths from to but he didn t tell you which strings are prefixes and which are suffixes Ivan wants you to guess which of the given strings are prefixes of the given string and which are suffixes It may be impossible to guess the string Ivan picked since multiple strings may give the same set of suffixes and prefixes but Ivan will accept your answer if there is at least one string that is consistent with it Let the game begin ,The first observation if we will take two strings of length then we can restore the initial string Why Because there are two possible options when the first string of length is a prefix and the second one is the suffix and vice versa Let s write a function which will check if the first string can be the prefix of the guessed string and the second one can be the suffix After we write this function we can run it two times depending on the order of strings of length and find any suitable answer If the first string is the prefix and the second one is the suffix then the whole string indexed where is the concatenation of strings Let s check if we have all prefixes and suffixes of this string in the input We can easy do it with two nested loops and some boolean array which can say us if some string is already used or not Firstly let s iterate over the length of the prefix or suffix and inside let s find any string from the input matching to the current prefix or suffix If we find all strings then the current string is one of the guessed and we can print the answer ,1
2,The construction of subway in Bertown is almost finished The President of Berland will visit this city soon to look at the new subway himself There are stations in the subway It was built according to the For each station there exists exactly one train that goes from this station Its destination station is possibly For each station there exists exactly one station such that The President will consider the of subway after visiting it The is the number of ordered pairs such that person can start at station and after taking some subway trains possibly zero arrive at station The mayor of Bertown thinks that if the subway is not enough then the President might consider installing a new mayor and of course the current mayor doesn t want it to happen Before President visits the city mayor has enough time to rebuild some paths of subway thus changing the values of for Of course breaking the is really bad so the subway must be built according to the even after changes The mayor wants to do these changes in such a way that the of the subway is maximized Help him to calculate the maximum possible he can get ,Let s notice that one swap can affect at most two cycles of this permutation Moreover you can join two cycles into one with the length equal to the sums of lengths of initial ones The function we are going to maximize is where and are the lengths of the cycles we are joining together Now its easily seen that the maximum is achived when joining two cycles with the greatest product of lengths Finally they are the two longest cycles in permutation Overall complexity ,1
3,Mishka s favourite experimental indie band has recently dropped a new album Songs of that album share one gimmick Each name is one of the following types a single lowercase Latin letter name with a single lowercase Latin letter appended to its end Songs are numbered from to It s guaranteed that the first song is always of type Vova is rather interested in the new album but he really doesn t have the time to listen to it entirely Thus he asks Mishka some questions about it to determine if some song is worth listening to Questions have the following format count the number of occurrences of string in the name of the th song of the album as a continuous substring consists only of lowercase Latin letters Mishka doesn t question the purpose of that information yet he struggles to provide it Can you please help Mishka answer all Vova s questions ,Call a pair if it satisfies the condition Let s split the inequality into three parts Note that if for any then it can t be an element of a good pair because it fails the first and third conditions So we can throw out all elements of the array satisfying For the remaining elements the first and third inequalities are already satisfied so we only have to count the number of pairs with Let s iterate through the array from the left to the right and make a list storing all that appear before Then for each count the number of less than by binary searching on the number of elements in the list less than Afterwards add to the end of the list Since we iterate from left to right the list will always remain sorted we insert the indices of elements which are increasing from left to right so the binary search will always work The time complexity is ,0
4,Ilya is working for the company that constructs robots Ilya writes programs for entertainment robots and his current project is Bob a new generation game robot Ilya s boss wants to know his progress so far Especially he is interested if Bob is better at playing different games than the previous model Alice So now Ilya wants to compare his robots performance in a simple game called 1 2 3 This game is similar to the Rock Paper Scissors game both robots secretly choose a number from the set and say it at the same moment If both robots choose the same number then it s a draw and noone gets any points But if chosen numbers are different then one of the robots gets a point beats beats and beats Both robots programs make them choose their numbers in such a way that their choice in th game depends only on the numbers chosen by them in th game Ilya knows that the robots will play games Alice will choose number in the first game and Bob will choose in the first game He also knows both robots programs and can tell what each robot will choose depending on their choices in previous game Ilya doesn t want to wait until robots play all games so he asks you to predict the number of points they will have after the final game ,Since we must use exactly colors each element that occurs in the sequence may have no more than painted occurrences for each element its occurrences where is the number of all its occurrences in the sequence Let be a sequence of all elements that occur in the sequence but in the sequence they will occur only once Let s create a indexed array in which we will add indices of occurrences of in the sequence then the selected occurrences of and so on till Currently is a set of occurrences which wonderful coloring is a wonderful coloring of the whole sequence because if we want to paint an occurrence outside we can do it only by selecting an occurrence of the same element in which we will not paint so that no more than occurrences will be painted We must use exactly colors and paint for each color an equal number of occurrences hence if we want to paint all occurrences from we must remove from it the minimum number of occurrences so that the size of the array will be divided by i e remove the number of occurrences equal to the remainder of dividing the size of by We can remove any occurrences for example let s delete it from the suffix of Currently we can paint all occurrences from using the following rule the occurrence we must paint in the color with a number where takes the remainder of dividing the left operand by the right operand So all occurrences from will be painted and all colors will be used Since all occurrences of one element belong to one subsegment of and their number isn t greater than they will be painted in different colors It may be so that the array before painting will be empty In this case the wonderful coloring of doesn t contain any painted element ,0
5,You are given an integer Find the minimum integer such that and the number is A number is called if its decimal representation having no leading zeroes contains no more than different digits E g if the numbers and are whereas the numbers and are not ,Suppose the number contains digits The desired number isn t greater than the number consisting of digits This number is beautiful whereas any beautiful number is at the same time beautiful so contains at most digits At the same time so contains at least digits Therefore the desired number contains exactly digits Suppose There are exactly beautiful numbers containing exactly digits To get the answer fast it s possible to consider all these numbers Suppose If is already beautiful let s output it Otherwise let s initialize the answer by the value as if Let s iterate two digits and such that Let s search for the answer by considering the strings consisting only of digits and Let s iterate a prefix of starting from the empty one so that the prefix will be the prefix of This prefix must contain only the digits and Consider the leftmost digit that doesn t belong to the prefix Let s try to increase it If the digit is less than a possible answer is a number such that it has the considered prefix and all other digits are equal to Let s update the answer by this number i e if the found number is less than the best previously found answer let s set the answer to the found number If the considered digit is at least and is less than let s update the answer by the number such that it has the considered prefix the digit follows the prefix and all other digits are equal to ,1
6,You are given a chessboard of size It is filled with numbers from to in the following way the first numbers from to are written in the cells with even sum of coordinates from left to right from top to bottom The rest numbers from to are written in the cells with odd sum of coordinates from left to right from top to bottom The operation means division by rounded up For example the left board on the following picture is the chessboard which is given for and the right board is the chessboard which is given for You are given queries The th query is described as a pair The answer to the th query is the number written in the cell is the row is the column Rows and columns are numbered from to ,We can prove that if we have white cells on the board then we can place any white dominoes as long as The proof is the following if let s place one domino at position otherwise let s place domino at position Then we can solve the placement of dominoes in cells in the first row and cells of the second row recursively or analogically and At the end either all dominoes are placed or and If or then since then or we successfully placed all dominoes If and then we possibly need to place one domino more and we can place it vertically We can prove that we can place any dominoes as long as in the same manner As a result all we need to check is that and ,0
7,A group of friends decide to go to a restaurant Each of the friends plans to order meals for burles and has a total of burles The friends decide to split their visit to the restaurant into several days Each day some group of friends goes to the restaurant Each of the friends visits the restaurant no more than once that is these groups do not intersect These groups must satisfy the condition that the total budget of each group must be than the amount of burles that the friends in the group are going to spend at the restaurant In other words the sum of all values in the group must not exceed the sum of values in the group What is the maximum number of days friends can visit the restaurant For example let there be friends for whom and Then first and sixth friends can go to the restaurant on the first day They will spend burles at the restaurant and their total budget is burles Since they can actually form a group friends with indices can form a second group They will spend burles at the restaurant and their total budget will be burles It can be shown that they will not be able to form more groups so that each group has at least two friends and each group can pay the bill So the maximum number of groups the friends can split into is Friends will visit the restaurant for a maximum of two days Note that the rd friend will not visit the restaurant at all Output the maximum number of days the friends can visit the restaurant for given and ,Let s start by finding the maximum matching in the given graph Since the constraints are pretty big you need something fast The model solution converts the matching problem into a flow network and uses Dinic to find the matching in but something like heavily optimized Kuhn s algorithm can also work Okay then what about finding the minimum possible number of vertices to delete in order to reduce the maximum matching We claim that it is always enough to remove one vertex and the proof will also provide a way to quickly search for such vertices Let s recall that the size of the maximum matching is equal to the size of the minimum vertex cover So we will try to find a way to reduce the minimum vertex cover by and it s actually pretty easy just remove any vertex belonging to the vertex cover it s obvious that it reduces the vertex cover by and the maximum matching by as well So we can find the minimum vertex cover in the graph using the standard algorithm to convert the MM into MVC or if you re using Dinic to find the maximum matching you can represent the minimum vertex cover as the minimum cut problem and for each query of type just take a vertex from the vertex cover we found Now the only thing that s left is discussing how to maintain the structure of the maximum matching in the graph In fact it s quite easy on the one hand since we remove the vertices belonging to the minimum vertex cover every edge including the edges from the matching will be incident to one of the vertices we will remove on the other hand due to the definition of the maximum matching there is no vertex that is incident to two or more edges from the maximum matching so every vertex from the vertex cover has exactly one edge from the maximum matching that is incident to it and when we remove a vertex we can simply remove the corresponding edge from the maximum matching So the only thing we need to do is to maintain which edge from the matching corresponds to which vertex from the minimum vertex cover and it will allow us to maintain the structure of the maximum matching and since these pairs don t change when we remove a vertex it is enough to get this information right after we have constructed the maximum matching in the given graph we won t need to rebuild it ,0
8, and the sum of over all test cases does not exceed A is a row of equal segments numbered to in order There are two terminals one above the other You are given an array of length For all there should be a straight wire from some point on segment of the top terminal to some point on segment of the bottom terminal You can t select the endpoints of a segment For example the following pictures show two possible wirings if and A occurs when two wires share a point in common In the picture above crossings are circled in red What is the number of crossings there can be if you place the wires optimally ,Let s carry the current answer as the last position we re checked as and the number of occurrences as Initially the answer is is and is 0 indexed We don t need to check the position because there is the beginning of the occurrence of at this position Also is by the same reason Let s repeat the following algorithm while if where ans is the length of the answer let s add to the answer increase and by In the other case let s check if there is a prefix of starting from If it is let be its length Then we need to add the suffix of starting from till the end of increase and by If there is no prefix of starting from the we just increase The other idea is the following we have to find the period of the string Let this period will be Then the answer is repeated times and The period of the string is the minimum prefix of this string such that we can repeat this prefix infinite number of times so the prefix of this infinite string will be For example the period of the string is the period of the string is and the period of the string is The period of the string can be found using prefix function of the string or in naively ,0
9,You are given a string consisting only of first lowercase Latin letters Recall that the substring of the string is the string For example the substrings of are but not and You can perform the following operation choose some substring and it i e the string becomes Your goal is to maximize the length of the maximum substring of consisting of i e unique characters The string consists of characters if no character in this string appears more than once For example strings and consist of distinct characters but strings do not consist of distinct characters ,First of all let s find the resulting position for each character of the string It s easy to see that we don t need to swap equal adjacent characters it changes nothing so the first character in the original string is the first character in the resulting string the second character in the original string is the second character in the resulting string and so on Now let s build a permutation of elements where is the resulting position of the element that was on position in the original string For example for the string this permutation will be In one operation we may swap two elements in this permutation and our goal is to sort it since each character of the string has its own required position and when for every the condition holds each character is on the position it should be The required number of swaps of adjacent elements to sort a permutation is exactly the number of inversions in it since each swap changes the number of inversions by and this number can be calculated using many different techniques for example mergesort tree or Fenwick tree ,0
10,A sequence of non negative integers is called if for all from to all ones of binary representation in are in the places of ones of binary representation in in other words where denotes bitwise AND If then the sequence is considered as well For example the following four sequences are growing in binary it s in binary it s in binary it s in binary it s The following three sequences are non growing in binary it s in binary it s in binary it s Consider two sequences of non negative integers and Let s call this pair of sequences if the sequence is where denotes bitwise XOR You are given a sequence of integers Find the lexicographically minimal sequence such that sequences and are co growing The sequence is lexicographically smaller than the sequence if there exists such that for any but ,In order to build lexicographically minimal co growing with sequence it is enough to build its elements iteratively beginning from and minimizing the th element assuming that have already been found Assign According to the statement all elements of the sequence are non negative so cannot be less than zero It turns out that is the minimal possible first element The existence of an answer with follows from the construction algorithm described below Let s use mathematical induction and construct under the assumption that all the previous elements of the sequence have already been constructed In order to satisfy the condition for the growth of the final sequence the number must contain one bits at all places but not necessarily limited to them on which there are one bits in the number Let s denote for and find out what bits can be in to satisfy this condition If in stands bit then independently from in at the same spot we can place any bit because there is no limit on the corresponding bit in If in stands bit and in then the corresponding bit in should be equal so that in the corresponding bit also equals one If in and in stands bit then in should be bit at the corresponding place for the same reasons The bit transformation described above can be given by the expression Indeed this expression gives us bit one at the fixed position if and only if at that place in stands bit and in stands bit For the full solution it remains only to apply this formula in a loop from to ,1
11,You are given the array of integer numbers For each element find the distance to the nearest zero to the element which equals to zero There is at least one zero element in the given array ,Let s divide the solution into two parts firstly check the closest zero to the left and then the closest zero to the right After that we can take minimum of these numbers Initialize distance with infinity Iterate over array from left to right If value in current position is then set distance to otherwise increase distance by On each step write value of distance to the answer array Do the same thing but going from right to left This will find closest zero to the right Now you should write minimum of current value of distance and value that s already in answer array Finally you should retrieve the answer from distances Overall complexity ,1
12,You are given a binary string consisting of only characters and or You can perform several operations on this string possibly zero There are two types of operations choose two consecutive elements and swap them In order to perform this operation you pay coins choose any element from the string and remove it In order to perform this operation you pay coins Your task is to calculate the minimum number of coins required to sort the string in non decreasing order i e transform so that where is the length of the string after applying all operations An empty string is also considered sorted in non decreasing order ,Note that the price of operations is much greater than the difference between them Therefore first of all we have to minimize the number of operations and then maximize the number of operations of the first type Swapping two elements if at least one of them will be deleted later is not optimal Therefore first let s delete some elements of the string and then sort the remaining elements using swaps The number of swaps for sorting is equal to the number of inversions i e the number of pairs such that and From here we can notice that if the number of inversions is greater than then there is an element that produces at least inversions So it is more profitable for us to remove it to minimize the number of operations From the above we get that the number of operations of the first type is at most If all operations are only of the second type then we need to find a subsequence of the maximum length of the form To do this we can iterate over the number of zeros that we include in the final string and then add the number of ones from the remaining suffix of the string that goes after the fixed number of zeros If there is an operation of the first type then it is enough to iterate over the pair that creates the inversion to the left of it take all zeros and to the right of it take all ones you can notice that in fact it is enough to iterate over only a pair of neighboring elements of the string ,1
13,Conveyor matrix is matrix of size where is an number The matrix consists of concentric ribbons moving clockwise In other words the conveyor matrix for is simply a matrix whose cells form a cycle of length clockwise For any natural the matrix is obtained by adding to the matrix an outer layer forming a clockwise cycle You are standing in a cell with coordinates and you want to get into a cell with coordinates A cell has coordinates if it is located at the intersection of the th row and the th column Standing on some cell every second you will move to the cell next in the direction of movement of the tape on which you are You can also move to a neighboring cell by spending one unit of energy Movements happen instantly and you can make an unlimited number of them at any time Your task is to find the minimum amount of energy that will have to be spent to get from the cell with coordinates to the cell with coordinates For example initially you are in a cell with coordinates and you want to get into a cell with coordinates You can immediately make movements once you are in a cell with coordinates and then after seconds you will be in the right cell ,The first observation if we will take two strings of length then we can restore the initial string Why Because there are two possible options when the first string of length is a prefix and the second one is the suffix and vice versa Let s write a function which will check if the first string can be the prefix of the guessed string and the second one can be the suffix After we write this function we can run it two times depending on the order of strings of length and find any suitable answer If the first string is the prefix and the second one is the suffix then the whole string indexed where is the concatenation of strings Let s check if we have all prefixes and suffixes of this string in the input We can easy do it with two nested loops and some boolean array which can say us if some string is already used or not Firstly let s iterate over the length of the prefix or suffix and inside let s find any string from the input matching to the current prefix or suffix If we find all strings then the current string is one of the guessed and we can print the answer ,0
14,Three friends are going to meet each other Initially the first friend stays at the position the second friend stays at the position and the third friend stays at the position on the coordinate axis In one minute from other friends can change the position by to the left or by to the right i e set or or even don t change it Let s introduce the total pairwise distance the sum of distances between each pair of friends Let and be the final positions of the first the second and the third friend correspondingly Then the total pairwise distance is where is the absolute value of Friends are interested in the minimum total pairwise distance they can reach if they will move optimally So more formally they want to know the minimum total pairwise distance they can reach after one minute You have to answer independent test cases ,Let s check all splitting points for all We denote a splitting point as the last index of the first string we take and all the remaining characters will go to the second string We need to keep a dynamic count of the number of distinct characters in both strings the first string and the second string We can do this using two frequency arrays and adding one to the distinct count of either string or when the frequency of a character is greater than zero ,0
15,Ilya is working for the company that constructs robots Ilya writes programs for entertainment robots and his current project is Bob a new generation game robot Ilya s boss wants to know his progress so far Especially he is interested if Bob is better at playing different games than the previous model Alice So now Ilya wants to compare his robots performance in a simple game called 1 2 3 This game is similar to the Rock Paper Scissors game both robots secretly choose a number from the set and say it at the same moment If both robots choose the same number then it s a draw and noone gets any points But if chosen numbers are different then one of the robots gets a point beats beats and beats Both robots programs make them choose their numbers in such a way that their choice in th game depends only on the numbers chosen by them in th game Ilya knows that the robots will play games Alice will choose number in the first game and Bob will choose in the first game He also knows both robots programs and can tell what each robot will choose depending on their choices in previous game Ilya doesn t want to wait until robots play all games so he asks you to predict the number of points they will have after the final game ,Notice that there are only possible patterns in this game You can used in a following way Simulate games till one of the patterns get repeated Games between this pair of occurences will get you the same total outcome no matter when they are played Let the distance between the games with the same pattern is and index of these games are and zero indexed Total score of some interval is Then the answer will be ,1
16,Let s call some square matrix with integer values in its cells if it doesn t change after the order of rows is reversed and it doesn t change after the order of columns is reversed For example the following matrices are The following matrices are because they change after the order of rows is reversed The following matrices are because they change after the order of columns is reversed You are given integers Put them into a matrix of rows and columns so that each number is used exactly once each cell contains exactly one number and the resulting matrix is If there are multiple answers print any If there is no solution print ,Basically what does the matrix being palindromic imply For each values in cells and are equal all zero indexed You can easily prove it by reversing the order of rows or columns and checking the overlapping cells in them Thus all cells can be split up into equivalence classes The even case is simple all classes have size The odd case has classes of sizes and Let s fill the classes one by one Obviously the order between the classes of the same size doesn t matter I claim that filling the classes in order in sizes construct the answer if any exists The key observation is that each next size is divisible by the previous one The implementation can come in lots of different forms and complexities Mine works in you can refer to it in attachment ,1
17,You are given an integer and two sequences and Let s call a set of integers such that if for every element of the following condition is met for every if divides then is also included in An empty set is always The of the set is You have to calculate the maximum possible of a set ,We will model the problem as the minimum cut in a flow network Build a network as follows create a source node a sink node and a vertex for every number from to Let s say that we are going to find the minimum cut in this network and the vertices belonging to the same cut part with represent the numbers that are taken into the answer Using the edges of the network we should model these constraints taking an element that depends on another element should force us to take as well taking an element with should add to our score taking an element with should subtract from our score Constraint can be modeled in the following way for every pair such that element depends on element and add a directed edge with infinite capacity from to That way if is taken and is not the value of the cut will be infinite because of this edge and this cut cannot be minimum Constraint is modeled in the following way for every such that add a directed edge with capacity from to That way if we take some element with into the answer is added to the value of the cut And for constraint for every such that add a directed edge with capacity from to That way if we take some element with is added to the value of the cut It s now easy to see that the answer is since it is exactly the sum of elements that were taken for positive elements we add them all up and then subtract the ones that don t belong to the answer for negative ones we just subtract those which belong to the answer To find a minimum cut just run maximum flow in this network There s one caveat though If for example all are equal or many are divisible by many other values in this network can contain edges To reduce the number of edges let s see that if for some index there exist two equal divisors of to the left of it let s say that these divisors are and then we only need to add an edge from to because taking also should force taking into the answer So for every divisor of we are interested in only one closest occurrence of this divisor to the left and we need to add a directed edge only to this occurrence and ignore all other occurrences That way for every vertex we add at most edges to other vertices where is the number of divisors of It can be proven that any maximum flow algorithm that relies on augmenting paths will finish after iterations in this network so it won t work longer than and both and are proportional to so any maximum flow solution will run in ,1
18,Two integer sequences existed initially one of them was increasing and another one decreasing Strictly increasing sequence is a sequence of integers And strictly decreasing sequence is a sequence of integers Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing Elements of increasing sequence were inserted between elements of the decreasing one and possibly before its first element and after its last element For example sequences and can produce the following resulting sequences The following sequence cannot be the result of these insertions because the order of elements in the increasing sequence was changed Let the obtained sequence be This sequence is given in the input Your task is to find two suitable initial sequences One of them should be increasing and another one decreasing If there is a contradiction in the input and it is impossible to split the given sequence into one increasing sequence and one decreasing sequence print ,I know about greedy solutions and other approaches but I ll describe my solution This is dynamic programming I ll consider all positions indexed Let be the minimal element in the decreasing sequence if the last element th was in the increasing sequence and be the maximum element in the increasing sequence if the last element th was in the decreasing sequence Initially all are and all are except two values and What about transitions Let s consider four cases The previous element was in the increasing sequence and we want to add the current element to the increasing sequence We can do if the previous element was in the increasing sequence and we want to add the current element to the decreasing sequence We can do if the previous element was in the decreasing sequence and we want to add the current element to the decreasing sequence We can do if the previous element was in the decreasing sequence and we want to add the current element to the increasing sequence We can do if The logic behind these transitions is kinda hard but understandable If and then the answer is Otherwise we can restore any possible answer using parents in the dynamic programming ,1
19,You are walking through a parkway near your house The parkway has benches in a row numbered from to from left to right The distance between the bench and is meters Initially you have units of energy To walk meter of distance you spend unit of your energy You can t walk if you have no energy Also you can restore your energy by and this is the only way to restore the energy When you are sitting you can restore any integer amount of energy you want if you sit longer you restore more energy Note that the amount of your energy Your task is to find the amount of energy you have to by sitting on benches to reach the bench from the bench and end your walk You have to answer independent test cases ,If you have at least units of energy then the answer is because you can just walk to the end Otherwise the answer is because you can just sit on the first bench and then just go Time complexity ,1
20,You are given a string consisting only of first lowercase Latin letters Recall that the substring of the string is the string For example the substrings of are but not and You can perform the following operation choose some substring and it i e the string becomes Your goal is to maximize the length of the maximum substring of consisting of i e unique characters The string consists of characters if no character in this string appears more than once For example strings and consist of distinct characters but strings do not consist of distinct characters ,First of all I wanted to offer you one little challenge I found a solution that I can t break and I don t sure if it can be broken and I will be so happy if anyone will give me countertest which will break it You can see its code below Let s notice that we can reduce our problem to the following find two substrings of the given string that letters in them do not intersect and the total length of these substrings is the maximum possible Why can we make such a reduction It is so because our answer consists of at most two non intersecting parts one fixed substring and at most one substring that we appended to the first one We can always append any other substring to the first one by one reverse operation just look at some examples to understand it Let s iterate over all possible substrings of length at most AL where AL is the size of the alphabet which contain distinct letters We can do it in O n AL Let the current substring containing distinct letters be s i j Let s create the bitmask corresponding to this substring the bit pos is 1 if the pos th letter of the alphabet is presented in the substring and 0 otherwise letters are Store all these masks somewhere Notice that our current problem can be reduced to the following we have the set of masks and we need to find a pair of masks that they do not intersect and their total number of ones in them is the maximum possible This reduction is less obvious than the previous one but you also can understand it considering some examples So how to solve this problem We can do it with easy bitmasks dynamic programming Let dp mask be the maximum number of ones in some mask that is presented in the given string and it is the submask of mask How to calculate this dynamic programming First of all all values dp mask for all masks presented in the string are equal to the number of ones in corresponding masks Let s iterate over all masks from 0 to 2 AL 1 Let the current mask be mask Then let s try to update the answer for this mask with the answer for one of its submasks It is obvious that because of dynamic programming we need to remove at most one bit from our mask to cover all possible submasks that can update our answer So let s iterate over all bits in mask let the current bit be pos If this bit is zero then just skip it Otherwise update dp mask max dp mask dp mask hat 2 pos where hat is the operation After calculating this dynamic programming we can finally calculate the answer Let s iterate over all masks presented in the string let the current mask be mask We can update the answer with the number of ones in mask plus dp mask hat 2 AL 1 mask hat 2 AL 1 is the completion of mask Total complexity O n AL AL 2 AL ,1
21,On an grid some horizontal rows have been painted red and some vertical columns have been painted blue in some order The stripes are drawn sequentially one after the other When the stripe is drawn it repaints all the cells through which it passes Determine which color was used last ,Let s notice that you should never say that you didn t notice signs no speed limit and overtake is allowed Also if you drive with speed you don t want to remove signs speed limit with number greater or equal to Thus greedy solution will work Process all the events in chronological order We should maintain stack of signs speed limit and amount of signs no overtake allowed If we meet sign speed limit we push its limit to stack sign no overtake allowed increase no speed limit clear stack overtake is allowed assign to zero After every event we should check if our speed is fine While value of sign on the top of the stack is less than current speed pop it and increase answer If we overtake someone we add to answer and assign to zero Overall complexity ,0
22,New Year is getting near So it s time to change handles on codeforces Mishka wants to change his handle but in such a way that people would not forget who he is To make it work he only allowed to change letters case More formally during handle change he can choose any segment of his handle and apply or to all letters of his handle on this segment more fomally replace all uppercase letters with corresponding lowercase or vice versa The length is fixed for all changes Because it is not allowed to change codeforces handle too often Mishka can perform at most such operations What is the value of where is the number of lowercase letters and is the number of uppercase letters can be obtained after optimal sequence of changes ,The key observation in this problem is that the values of should form a contiguous segment of integers For example suppose there exists a value such that there is at least one there is at least one but no We can decrease all values of that are greater than by so the answer will still be valid but the value of will decrease So the values of form a contiguous segment of integers We can always assume that this segment is since subtracting the same value from each does not change anything The other observation we need is that we can rewrite the expression we have to minimize as follows where is the signed sum of weights of all arcs incident to the vertex the weights of all arcs leading from are taken with positive sign and the weights of all arcs leading to are taken with negative sign These two observations lead us to a bitmask dynamic programming solution let be the minimum value of if we assigned the values from to the vertices from A naive way to calculate this dynamic programming is to iterate on the submask of check that choosing the integer for each vertex from that submask doesn t ruin anything for each vertex that belongs to this submask all vertices that are reachable from it should have so they should belong to but not to the submask we iterate on and update the dynamic programming value But this solution is and depending on your implementation this might be too slow It s possible to speed this up to in a way similar to how profile dp can be optimized from to we won t iterate on the submask instead we will try to add the vertices one by one and we should be able to add a vertex to the mask only if all vertices that are reachable from it already belong to the mask There is a possibility that we add two vertices connected by an arc with the same value of so for a fixed value of we should consider assigning it to vertices in topological sorting order that way if one vertex is reachable from another it will be considered later so we won t add both of those with the same value of ,0
23,You are given a binary matrix of size Rows are numbered from top to bottom from to columns are numbered from left to right from to The element located at the intersection of row and column is called Consider a set of operations Cyclically shift all rows up The row with index will be written in place of the row the row with index will be written in place of the row Cyclically shift all rows down The row with index will be written in place of the row the row with index will be written in place of the row Cyclically shift all columns to the left The column with index will be written in place of the column the column with index will be written in place of the column Cyclically shift all columns to the right The column with index will be written in place of the column the column with index will be written in place of the column You can perform an arbitrary possibly zero number of operations on the matrix the operations can be performed in any order After that you can perform an arbitrary possibly zero number of new xor operations Select any element and assign it with new value In other words the value of will have to be written into element Each application of this xor operation costs one burl Note that the shift operations are free These operations can only be performed before xor operations are performed Output the minimum number of burles you would have to pay to make the matrix unitary A is a matrix with ones on the main diagonal and the rest of its elements are zeros that is if and otherwise ,Let s consider a problem where you can subtract the weight of any edge not only the maximum one that belong to the current path and similarly add the weight of any edge not only the minimum one that belong to the current path To solve that problem we can build a new graph where the node can be represented as the following triple node from the initial graph flag that some edge has been subtracted flag that some edge has been added Now we can run Dijkstra s algorithm to find the length of the shortest paths in such a graph We can notice that on the shortest path the maximum weight edge was subtracted and the minimum weight edge was added Let s assume that this is not the case and an edge of non maximum weight was subtracted from the path then we can reduce the length of the path by choosing an edge of maximum weight But this is not possible because we considered the shortest path Similarly it is proved that the added edge was of minimal weight Using this fact it is not difficult to notice that by solving the modified problem we have solved the original one ,0
24,Let s define the sequence of Fibonacci strings as follows is is is for denotes the concatenation of two strings So for example is is is For a given string let s define as the number of ways to cut it into several any number possibly even just one strings such that none of these strings are Fibonacci strings For example if is since there are three ways to cut it You are given a sequence of strings Calculate Since these values can be huge print them modulo ,At first lets precalc the array The value of if equal the maximum position in range such that After that lets iterate over the right boundary of substring and high bit position denote it as and respectively Note that if then So we iterate over such pair that and Lets look at value If then we have to increase the length of substring without increasing the value of So we need to check if there exists a position such that and This position exists if the condition is met is equal to 1 ,0
25,You play a computer game In this game you lead a party of heroes and you have to clear a dungeon with monsters Each monster is characterized by its power Each hero is characterized by his power and endurance The heroes clear the dungeon day by day In the beginning of each day you choose a hero exactly one who is going to enter the dungeon this day When the hero enters the dungeon he is challenged by the first monster which was not defeated during the previous days so if the heroes have already defeated monsters the hero fights with the monster When the hero fights the monster there are two possible outcomes if the monster s power is strictly greater than the hero s power the hero retreats from the dungeon The current day ends otherwise the monster is defeated After defeating a monster the hero either continues fighting with the next monster or leaves the dungeon He leaves the dungeon either if he has already defeated the number of monsters equal to his endurance during this day so the th hero cannot defeat more than monsters during each day or if all monsters are defeated otherwise he fights with the next monster When the hero leaves the dungeon the current day ends Your goal is to defeat the last monster What is the minimum number of days that you need to achieve your goal Each day you have to use exactly one hero it is possible that some heroes don t fight the monsters at all Each hero can be used arbitrary number of times ,Notice that sum limits i 0 k 1 2 i 2 k 1 Thus we can replace the initial equation with the following 2 k 1 x n So we can iterate over all possible k in range 2 29 because 2 30 1 10 9 and check if n is divisible by 2 k 1 If it is then we can print x frac n 2 k 1 P S I know that so many participants found the formula sum limits i 0 k 1 2 i 2 k 1 using geometric progression sum but there is the other way to understand this and it is a way more intuitive for me Just take a look at the binary representation of numbers we can notice that 2 0 1 2 1 10 2 2 100 and so on Thus 2 0 1 2 0 2 1 11 2 0 2 1 2 2 111 and so on And if we add one to this number consisting of k ones then we get 2 k ,0
26,Let s call an array of size iff where is the greatest common divisor of the arguments You are given two numbers and For each you have to determine the number of arrays of size such that for every Since the answers can be very large you have to calculate them modulo ,For a fixed upper bound this is a well known problem that can be solved using inclusion exclusion Let s denote by the number of arrays with elements in range such that is divisible by Obviously With the help of inclusion exclusion formula we can prove that the number of arrays with is the sum of the following values over all possible sets where is some set of prime numbers possibly an empty set and is the product of all elements in the set in this formula denotes the number of arrays such that their is divisible by every number from set However the number of such sets is infinite so we need to use the fact that if With the help of this fact we can rewrite the sum over every set in such a way where is if there is no any set of prime numbers such that if this set exists and the sign is determined by the size of if is even otherwise An easier way to denote and calculate is the following by the way it is called M bius function if there is some prime number p such that Otherwise where is the number of primes in the factorization of Okay so we found a solution for one upper bound it s How can we calculate it for every from to Suppose we have calculated all values of for some and we want to recalculate them for The important fact is that these values change and thus need recalculation only for the numbers such that So if we recalculate only these values and each recalculation can be done in time if we precompute the for every then we will have to do only recalculations overall ,1
27,You are given a weighted undirected connected graph consisting of vertices and edges It is guaranteed that there are no self loops or multiple edges in the given graph Let s define the weight of the path consisting of edges with indices as where weight of the th edge in the graph Your task is to find the minimum weight of the path from the st vertex to the th vertex for each ,Suppose the given list of divisors is a list of divisors of some in other words suppose that the answer exists Then the minimum divisor multiplied by maximum divisor should be This is true because if we have a divisor we also have a divisor Let s sort all divisors and let Now we need to check if all divisors of except and are the permutation of the array check that our answer is really correct We can find all divisors of in sort them and compare with the array If arrays are equal then the answer is otherwise the answer is ,0
28,Some number of people this number is even have stood in a circle The people stand in the circle evenly They are numbered clockwise starting from a person with the number Each person is looking through the circle s center at the opposite person You don t know the exact number of people standing in the circle but this number is even no doubt It is known that the person with the number is looking at the person with the number and vice versa of course What is the number associated with a person being looked at by the person with the number If for the specified and no such circle exists output ,The person with the number looks at the person with the number so the count of people standing to the left of between and is equal to the count of people standing to the right of between and Therefore both counts are equal to hence must be a solution of the equation The only solution of the equation is Let s check that in the circle of people can occur the numbers and i e let s check that If it s false there s no solution output Since the person with the number looks at the person with the number the condition must be met Let s solve the equation for There are two solutions We can output any of such that It s easy to prove that exactly one of the solutions meets the condition ,1
29,The elections in which three candidates participated have recently ended The first candidate received votes the second one received votes the third one received votes For each candidate solve the following problem how many votes should be added to this candidate so that he wins the election i e the number of votes for this candidate was strictly greater than the number of votes for any other candidate Please note that for each candidate it is necessary to solve this problem i e the added votes for any candidate affect the calculations when getting the answer for the other two candidates ,Let s solve the problem for the first candidate To win the election he needs to get at least more votes than every other candidate Therefore the first candidate needs to get at least votes If is already greater than this value then you don t need to add any votes otherwise you need to add votes So the answer for the first candidate is Similarly the answer for the second candidate is and for the third one the answer is ,1
30,You are given an integer Find the minimum integer such that and the number is A number is called if its decimal representation having no leading zeroes contains no more than different digits E g if the numbers and are whereas the numbers and are not ,The solution of this problem is based on Dilworth s theorem You can read about it on Wikipedia In two words this theorem says that the minimum number of non decreasing sequences we need to cover the whole sequence equals the length of longest decreasing subsequence Let s calculate the dynamic programming the length of longest decreasing sequence that ends in the position To recalculate this dynamic let s carry the array of length where means the maximum value of for the character on the prefix we already considered So initially all are ones all values of are zeros For the position we update with and update with Okay how to restore the answer That s pretty easy The color of the th character is exactly Why it is so If becomes greater than then we surely need to use the new color for this character because we cannot append it to the end of any existing sequence Otherwise we will append it to some existing sequence with the maximum possible number and because it has the maximum number and we didn t update the value of with the number of this sequence plus one the current character is not less than the last in this sequence Time complexity or ,0
31,Conveyor matrix is matrix of size where is an number The matrix consists of concentric ribbons moving clockwise In other words the conveyor matrix for is simply a matrix whose cells form a cycle of length clockwise For any natural the matrix is obtained by adding to the matrix an outer layer forming a clockwise cycle You are standing in a cell with coordinates and you want to get into a cell with coordinates A cell has coordinates if it is located at the intersection of the th row and the th column Standing on some cell every second you will move to the cell next in the direction of movement of the tape on which you are You can also move to a neighboring cell by spending one unit of energy Movements happen instantly and you can make an unlimited number of them at any time Your task is to find the minimum amount of energy that will have to be spent to get from the cell with coordinates to the cell with coordinates For example initially you are in a cell with coordinates and you want to get into a cell with coordinates You can immediately make movements once you are in a cell with coordinates and then after seconds you will be in the right cell ,Note that the conveyor matrix consists of cycles through each of which we can move without wasting energy Now you need to find the distance between the cycles where the start and end cells are located In one step from any cycle you can go either to the cycle that is closer to the edge of the matrix or to the cycle that is further from the edge of the matrix It turns out that it is enough to find on which cycles there are cells on the edge and take their difference modulo ,1
32,A string is called if it does not contain any characters other than and A bracket sequence is called shortly RBS if it is possible to obtain correct arithmetic expression by inserting characters and into this sequence For example and are RBS and and are not We can see that each opening bracket in RBS is paired with some closing bracket and using this fact we can define of the RBS as maximum number of bracket pairs such that the nd pair lies inside the st one the rd one inside the nd one and so on For example nesting depth of is is and is Now you are given RBS of even length You should color each bracket of into one of two colors red or blue Bracket sequence consisting only of red brackets should be RBS and bracket sequence consisting only of blue brackets should be RBS Any of them can be empty You are not allowed to reorder characters in or No brackets can be left uncolored Among all possible variants you should choose one that of s and s nesting depth If there are multiple solutions you can print any of them ,Consider the 2D array with for all Increase by if there is an rectangle in the input Now for each query we need to find the sum of all in a rectangle with lower left corner at and upper right corner at This is the standard problem that can be solved with 2D prefix sums The time complexity is per testcase ,0
33,There is a grid with rows and columns and three types of cells An empty cell denoted with A stone denoted with An obstacle denoted with the lowercase Latin letter All stones fall down until they meet the floor the bottom row an obstacle or other stone which is already immovable In other words all the stones just fall down as long as they can fall Simulate the process What does the resulting grid look like ,The person with the number looks at the person with the number so the count of people standing to the left of between and is equal to the count of people standing to the right of between and Therefore both counts are equal to hence must be a solution of the equation The only solution of the equation is Let s check that in the circle of people can occur the numbers and i e let s check that If it s false there s no solution output Since the person with the number looks at the person with the number the condition must be met Let s solve the equation for There are two solutions We can output any of such that It s easy to prove that exactly one of the solutions meets the condition ,0
34,Berland has a long and glorious history To increase awareness about it among younger citizens King of Berland decided to compose an anthem Though there are lots and lots of victories in history of Berland there is the one that stand out the most King wants to mention it in the anthem as many times as possible He has already composed major part of the anthem and now just needs to fill in some letters King asked you to help him with this work The anthem is the string of no more than small Latin letters and question marks The most glorious victory is the string of no more than small Latin letters You should replace all the question marks with small Latin letters in such a way that the number of occurrences of string in string is maximal Note that the occurrences of string in can overlap Check the third example for clarification ,Notice that for has no more than powers which give numbers no greater than So let s store all possible sums of all powers of and Now the answer to the query can be obtained in linear time by checking difference between neighbouring unlucky years in sorted order Don t forget that you should handle multiplying of such big numbers very carefully For example instead of writingwhile num 1e18 num num xorwhile num x 1e18 num num xyou should writewhile num 1e18 x num num xto avoid getting overflow errors of 64 bit type Integer division will work fine in that case because will never exceed if doesn t exceed Overall complexity ,0
35,There are of independent carriages on the rails The carriages are numbered from left to right from to The carriages are not connected to each other The carriages move to the left so that the carriage with number moves ahead of all of them The th carriage has its own engine which can accelerate the carriage to km h but the carriage cannot go faster than the carriage in front of it See example for explanation All carriages start moving to the left at the same time and they naturally form We will call consecutive moving carriages having the same speed For example we have carriages and array Then the final speeds of the carriages will be Respectively of the train will be formed There are also messages saying that some engine has been corrupted message means that the speed of the th carriage has decreased by that is there has been a change in the maximum speed of the carriage Messages arrive sequentially the processing of the next message takes into account the changes from all previous messages After each message determine the number of formed trains ,First we sort the friends in descending order of Now for each friend we know the amount of money he lacks or vice versa which he has in excess In order to maximize the number of days it is most advantageous for friends to break into pairs It is the number of groups that matters not the number of people in the group so adding a third person to the pair won t improve the answer in any way Let s solve the problem using two pointers for the richest friend find the first friend from the end such that the sum of their values exceeds the sum of their values Then repeat this for all subsequent friends until the pointers meet If no pair could be formed or none of the friends has a value greater than then the answer is Otherwise print the number of pairs formed ,0
36,Ivan wants to play a game with you He picked some string of length consisting only of lowercase Latin letters You don t know this string Ivan has informed you about all its improper prefixes and suffixes i e prefixes and suffixes of lengths from to but he didn t tell you which strings are prefixes and which are suffixes Ivan wants you to guess which of the given strings are prefixes of the given string and which are suffixes It may be impossible to guess the string Ivan picked since multiple strings may give the same set of suffixes and prefixes but Ivan will accept your answer if there is at least one string that is consistent with it Let the game begin ,Since we must use exactly colors each element that occurs in the sequence may have no more than painted occurrences for each element its occurrences where is the number of all its occurrences in the sequence Let be a sequence of all elements that occur in the sequence but in the sequence they will occur only once Let s create a indexed array in which we will add indices of occurrences of in the sequence then the selected occurrences of and so on till Currently is a set of occurrences which wonderful coloring is a wonderful coloring of the whole sequence because if we want to paint an occurrence outside we can do it only by selecting an occurrence of the same element in which we will not paint so that no more than occurrences will be painted We must use exactly colors and paint for each color an equal number of occurrences hence if we want to paint all occurrences from we must remove from it the minimum number of occurrences so that the size of the array will be divided by i e remove the number of occurrences equal to the remainder of dividing the size of by We can remove any occurrences for example let s delete it from the suffix of Currently we can paint all occurrences from using the following rule the occurrence we must paint in the color with a number where takes the remainder of dividing the left operand by the right operand So all occurrences from will be painted and all colors will be used Since all occurrences of one element belong to one subsegment of and their number isn t greater than they will be painted in different colors It may be so that the array before painting will be empty In this case the wonderful coloring of doesn t contain any painted element ,0
37,Eve is a beginner stand up comedian Her first show gathered a grand total of two spectators Alice and Bob Eve prepared jokes to tell grouped by their type type 1 both Alice and Bob like them type 2 Alice likes them but Bob doesn t type 3 Bob likes them but Alice doesn t type 4 neither Alice nor Bob likes them Initially both spectators have their mood equal to When a spectator hears a joke he she likes his her mood increases by When a spectator hears a joke he she doesn t like his her mood decreases by If the mood of a spectator becomes negative strictly below zero he she leaves When someone leaves Eve gets sad and ends the show If no one leaves and Eve is out of jokes she also ends the show Thus Eve wants to arrange her jokes in such a way that the show lasts as long as possible Help her to calculate the maximum number of jokes she can tell before the show ends ,Suppose we decided to make exactly turns or in other words our path will consist of exactly segments Since we should finish at point and vertical and horizontal segments alternates then it means that and From the other side we should minimize But it means that we can minimize and independently How to minimize if we know that and It s easy to prove that it s optimal to assign all except minimum and assign to this minimum the remaining part In other words to calculate the optimal path consisting of segments we need to know the sum of on odd and even positions among and also minimum among odd and even positions Then we can drive out the answer as a quite easy formula Finally we should iterate over all from to and find the minimum answer among all variants It s easy to recalculate sums and minimums when we make transition form to Complexity is ,0
38,You are given a permutation of length a permutation of length is an array of length in which each integer from to occurs exactly once You can perform the following operation any number of times possibly zero choose two different elements and and erase them from the permutation insert the minimum of and into the permutation in such a way that it becomes the first element insert the maximum of and into the permutation in such a way that it becomes the last element For example if and we want to apply the operation to the elements and then after the first step of the operation the permutation becomes and after we insert the elements it becomes Your task is to calculate the minimum number of operations described above to sort the permutation in ascending order i e transform so that ,Let s denote as some stack sortable array which contains all integers from to inclusive We can see that if the first element of is then where by we mean concatenation of arrays It s easy to prove this fact if the first element is then we have to store it in the stack until we have processed all elements less than so in no element that is greater than can precede any element less than This way we can represent the prefix we are given For example if and prefix is then we can rewrite the permutation we have to obtain as So the unknown suffix is a contatenation of some stack sortable arrays It s easy to see that if an array is sorted in non increasing order then it is stack sortable So we can replace each block with an array If during rewriting the given prefix we obtain some impossible situation for example when and given prefix is we have and can t be the beginning of then answer is ,0
39,There is a grid with rows and columns and three types of cells An empty cell denoted with A stone denoted with An obstacle denoted with the lowercase Latin letter All stones fall down until they meet the floor the bottom row an obstacle or other stone which is already immovable In other words all the stones just fall down as long as they can fall Simulate the process What does the resulting grid look like ,Note that the columns don t affect each other so we can solve for each column by itself For each column go from the bottom to the top and keep track of the row of the last obstacle seen call it Note that initially since we treat the floor as the th row of obstacles Whenever we see a new obstacle we should update Now if we ever see a stone we should move it to row since it will be one row above the last obstacle seen it will fall on top of it Afterwards we should also decrease by because if any future stones fall on top of it they will land on the row above this stone This solution works in We also accepted slower solutions that run in that simulate each stone falling ,1
40,There is an infinite board of square tiles Initially all tiles are white Vova has a red marker and a blue marker Red marker can color tiles Blue marker can color tiles If some tile isn t white then you can t use marker of any color on it Each marker must be drained completely so at the end there should be exactly red tiles and exactly blue tiles across the board Vova wants to color such a set of tiles that they would form a consisting of exactly colored tiles all tiles of at least one color would also form a Here are some examples of correct colorings Here are some examples of incorrect colorings Among all correct colorings Vova wants to choose the one with the minimal perimeter What is the minimal perimeter Vova can obtain It is guaranteed that there exists at least one correct coloring ,We can prove that if we have white cells on the board then we can place any white dominoes as long as The proof is the following if let s place one domino at position otherwise let s place domino at position Then we can solve the placement of dominoes in cells in the first row and cells of the second row recursively or analogically and At the end either all dominoes are placed or and If or then since then or we successfully placed all dominoes If and then we possibly need to place one domino more and we can place it vertically We can prove that we can place any dominoes as long as in the same manner As a result all we need to check is that and ,0
41,The string is given the string length is number The string consists of lowercase letters of the Latin alphabet As long as the string length is greater than the following operation can be performed on it select any two adjacent letters in the string and delete them from the string For example from the string in one operation you can get any of the four strings or In particular in one operation the length of the string reduces by Formally let the string have the form During one operation you choose an arbitrary index and replace For the given string and the letter determine whether it is possible to make such a sequence of operations that in the end the equality will be true In other words is there such a sequence of operations that the process will end with a string of length which consists of the letter ,In this problem we can simply increase times the current time by one minute after each increasing we should check the hours and the minutes for overflow Another solution is to use the next formulas as the answer ,0
42,Alperen is standing at the point He is given a string of length and performs moves The th move is as follows if then move one unit left if then move one unit right if then move one unit up if then move one unit down There is a candy at that is one unit above and one unit to the right of Alperen s starting point You need to determine if Alperen ever passes the candy ,First of all I wanted to offer you one little challenge I found a solution that I can t break and I don t sure if it can be broken and I will be so happy if anyone will give me countertest which will break it You can see its code below Let s notice that we can reduce our problem to the following find two substrings of the given string that letters in them do not intersect and the total length of these substrings is the maximum possible Why can we make such a reduction It is so because our answer consists of at most two non intersecting parts one fixed substring and at most one substring that we appended to the first one We can always append any other substring to the first one by one reverse operation just look at some examples to understand it Let s iterate over all possible substrings of length at most AL where AL is the size of the alphabet which contain distinct letters We can do it in O n AL Let the current substring containing distinct letters be s i j Let s create the bitmask corresponding to this substring the bit pos is 1 if the pos th letter of the alphabet is presented in the substring and 0 otherwise letters are Store all these masks somewhere Notice that our current problem can be reduced to the following we have the set of masks and we need to find a pair of masks that they do not intersect and their total number of ones in them is the maximum possible This reduction is less obvious than the previous one but you also can understand it considering some examples So how to solve this problem We can do it with easy bitmasks dynamic programming Let dp mask be the maximum number of ones in some mask that is presented in the given string and it is the submask of mask How to calculate this dynamic programming First of all all values dp mask for all masks presented in the string are equal to the number of ones in corresponding masks Let s iterate over all masks from 0 to 2 AL 1 Let the current mask be mask Then let s try to update the answer for this mask with the answer for one of its submasks It is obvious that because of dynamic programming we need to remove at most one bit from our mask to cover all possible submasks that can update our answer So let s iterate over all bits in mask let the current bit be pos If this bit is zero then just skip it Otherwise update dp mask max dp mask dp mask hat 2 pos where hat is the operation After calculating this dynamic programming we can finally calculate the answer Let s iterate over all masks presented in the string let the current mask be mask We can update the answer with the number of ones in mask plus dp mask hat 2 AL 1 mask hat 2 AL 1 is the completion of mask Total complexity O n AL AL 2 AL ,0
43,Your task is to calculate the number of arrays such that each array contains elements each element is an integer from to for each array there is one pair of equal elements for each array there exists an index such that the array is before the th element and after it formally it means that if and if ,At first lets precalc array is equal to maximum hero power whose endurance is greater than or equal to Now let s notice that every day it s profitable for as to kill as many monster as possible Remains to understand how to calculate it Suppose that we already killed monsters If then answer is because we can t kill the th monster Otherwise we can kill at least monsters All we have to do it increase the value until conditions holds After calculating the value we just move to the next day with killed monsters ,0
44, You are given a weighted rooted tree vertex is the root of this tree A tree is a connected graph without cycles A rooted tree has a special vertex called the root A parent of a vertex is the last different from vertex on the path from the root to the vertex Children of vertex are all vertices for which is the parent A vertex is a leaf if it has no children The weighted tree is such a tree that each edge of this tree has some weight The weight of the path is the sum of edges weights on this path The weight of the path from the vertex to itself is You can make a sequence of zero or more moves On each move you select an edge and divide its weight by rounding down More formally during one move you choose some edge and divide its weight by rounding down Your task is to find the minimum number of required to make the from the root to each leaf at most In other words if is the weight of the path from the vertex to the vertex then you have to make where is the list of all leaves You have to answer independent test cases ,Note that if a stripe is painted last then the entire stripe appears in the final picture because no other stripe is covering it Since rows are only painted red and columns are only painted blue we can just check if any row contains 8 s If there is such a row then red was painted last otherwise blue was painted last ,0
45,You are given a directed acyclic graph a directed graph that does not contain cycles of vertices and arcs The th arc leads from the vertex to the vertex and has the weight Your task is to select an integer for each vertex and then write a number on each arcs such that You must select the numbers so that all are positive the value of the expression is the lowest possible It can be shown that for any directed acyclic graph with non negative such a way to choose numbers exists ,There are many different ways to solve this problem generate all Berland words with two for loops and store them in an array then for each test case go through the array of words to find the exact word you need generate all Berland words with two for loops and store them in a dictionary like data structure in C in Python etc using words as keys and their numbers as values This allows to search for the index of the given word quickly for each test case run two for loops to iterate over the words count the number of words we skipped and stop at the word from the test case try to invent some formulas that allow counting the number of words before the given one ,0
46,Let s call yet again a string if its length is even and every character in odd position of this string is different from the next character the first character is different from the second the third is different from the fourth and so on For example the strings and are good strings and the strings and are not good You are given a string you have to delete minimum number of characters from this string so that it becomes good ,Let s define as the number of leaves in the subtree of the th edge of course in terms of vertices in the subtree of the lower vertex of this edge Values of can be calculated with pretty standard and simple dfs and dynamic programming Then we can notice that our edges are independent and we can consider the initial answer sum of weights of paths as Let be the difference between the current impact of the th edge and the impact of the th edge if we divide its weight by This value means how the sum of weights decreases if we divide the weight of the th edge by Create ordered set which contains pairs Then the following greedy solution works let s take the edge with maximum and divide its weight by Then re add it into the set with new value When the sum becomes less than or equal to just stop and print the number of divisions we made The maximum number of operations can reach so the solution complexity is each operation takes time because the size of the set is ,0
47,The construction of subway in Bertown is almost finished The President of Berland will visit this city soon to look at the new subway himself There are stations in the subway It was built according to the For each station there exists exactly one train that goes from this station Its destination station is possibly For each station there exists exactly one station such that The President will consider the of subway after visiting it The is the number of ordered pairs such that person can start at station and after taking some subway trains possibly zero arrive at station The mayor of Bertown thinks that if the subway is not enough then the President might consider installing a new mayor and of course the current mayor doesn t want it to happen Before President visits the city mayor has enough time to rebuild some paths of subway thus changing the values of for Of course breaking the is really bad so the subway must be built according to the even after changes The mayor wants to do these changes in such a way that the of the subway is maximized Help him to calculate the maximum possible he can get ,First of all there will be exactly distinct elements in our array Let s choose them there are ways to do that After that there should be exactly one element that appears twice There are elements to choose from but are all of them eligible If we duplicate the maximum element there will be no way to meet the fourth condition So we should multiply the current answer by not And finally some elements will appear earlier than the maximum in our array and some later The duplicated element will appear on both sides but all other elements should appear either to the left or to the right so there are ways to choose their positions Thus the answer is Note that you have to precompute all factorials and use their inverse elements to calculate Note that there is a tricky case when some binpow implementations go into infinite loop trying to compute so you may have to handle it specifically ,0
48,Recently Vova found candy wrappers He remembers that he bought candies during the first day candies during the second day candies during the third day candies during the th day But there is an issue Vova remembers neither nor but he is sure that and are positive integers and Vova will be satisfied if you tell him integer so there is an integer that It is guaranteed that at least one solution exists You have to answer independent test cases ,Let s construct the graph the following manner Take all the vertices with and build a bamboo out of them Surely all but the end ones will have degree the diameter now is the number of vertices minus 1 One can show that building the graph any other way won t make the diameter greater How should we distribute the other vertices Two of them can be used to increase diameter And all the others won t matter they can be paired with any of the vertices with degrees to spare If no loops are added then the diameter won t change the path that was the longest won t become any shorter All those facts imply that the graph should be a tree and the sum of should be at least Overall complexity ,0
49,You have an axis aligned rectangle room with width and height so the lower left corner is in point and the upper right corner is in There is a rectangular table standing in this room The sides of the table are parallel to the walls the lower left corner is in and the upper right corner in You want to place another rectangular table in this room with width and height with the width of the table parallel to the width of the room The problem is that sometimes there is not enough space to place the second table without intersecting with the first one there are no problems with tables touching though You any of the tables but you can move the first table inside the room What is the minimum distance you should move the first table to free enough space for the second one ,Let s look at one fixed color When we search a card of such color we take the card with minimum index and after we place it on the top of the deck it remains the one with minimum index It means that for each color we take and move the same card one card for each color In other words we need to keep track of only cards where is the number of colors As a result if is the position of a card of color then we can simulate a query in the following way for each color such that we increase by one since the card will move down and then set Complexity is But if we look closely we may note that we don t even need array We can almost manually find the first card of color and move it to the first position either by series of swaps or for example using function present in C and it will work fast Why Let s look at one color For the first time it will cost operations to search the corresponding card and move it to the position But after that at any moment of time the position of the card won t exceed since all cards before are pairwise different due to the nature of queries So all next moves the color costs only time As a result the complexity of such almost naive solution is ,0
50,You are beta testing the new secret Terraria update This update will add quests to the game Simply the world map can be represented as an array of length where the th column of the world has height There are quests you have to test The th of them is represented by two integers and In this quest you have to go from the column to the column At the start of the quest you are appearing at the column In one move you can go from the column to the column or to the column In this version you have Spectre Boots which allow you to fly Since it is a beta version they are bugged so they only allow you to fly when you are going up and have infinite fly duration When you are moving from the column with the height to the column with the height then you get some amount of fall damage If the height is greater than the height you get fall damage otherwise you fly up and get damage For each of the given quests determine the minimum amount of fall damage you can get during this quest ,Let s solve the problem using dynamic programming Let be the maximum total beauty of pictures if Vova is at the th picture now the number of remaining reposts is and Vova reposted the th picture Initially and all other values of are Let s learn to do some transitions to calculate this dynamic programming What is the way to do it Let s iterate over the position of the previously reposted picture and try to update using previously calculated values Obviously this position can be from to So let s iterate over the position let it be and if we need one more repost to repost the th picture is not then try to update pictures are indexed So where can we find the answer The answer is If this value is then the answer is Overall complexity is ,0
51,It is given a positive integer In move one can select any single digit and remove it i e one selects some position in the number and removes the digit located at this position The operation cannot be performed if only one digit remains If the resulting number contains leading zeroes they are automatically removed E g if one removes from the number the rd digit the resulting number will be If one removes from the number the first digit the resulting number will be the zeroes going next to the first digit are automatically removed What is the minimum number of steps to get a number such that it is divisible by and It is guaranteed that for each occurring in the input the answer exists It is guaranteed that the number has no leading zeros ,A number is divisible by if and only if its last two digits represent one of the following strings Let s solve for each string the following subtask what is the minimum number of characters to be deleted so that the string becomes a suffix of the number Then choosing the minimum of the answers for all subtasks we solve the whole problem Let s solve the subtask for a string where and are digits We can do it using the following algorithm let s delete the last digit of the number until it is equal to then the second to last digit of the number until it is equal to If it is not possible then this subtask has no solution i e its result will not affect the answer ,1
52,Maksim walks on a Cartesian plane Initially he stands at the point and in one move he can go to any of four adjacent points left right up down For example if Maksim is currently at the point he can go to any of the following points in one move There are also key points at this plane The th point is It is guaranteed that and and there is no key point Let the first level points be such points that the second level points be such points that and so on Maksim wants to visit all the key points But he shouldn t visit points of level if he does not visit all the points of level He starts visiting the points from the minimum level of point from the given set The distance between two points and is where is the absolute value of Maksim wants to visit all the key points in such a way that the total distance he walks will be minimum possible Your task is to find this distance ,The main idea is that we don t need more than border points on each level So if we consider than the point is less than point when or and then let s distribute all the points by their levels using or something like it sort points on each level by the comparator above and remain the first one and the last one on each level Also let s add the fictive level with the point It is always true to remain at most points and can be easily proved but this fact is very intuitive I think Now let s do dynamic programming on the points means that now we are at the level and stay in the first point if or in the last point if and we are already visit all the points on the level The value of this dynamic programming is the minimum possible total distance to reach this state Initially other values are equal to Let s calculate this dynamic programming in order of increasing levels Let be the first key point at the level and be the last key point at the level Now if we are at the level and the previous level is these transitions are sufficient to calculate states of dynamic programming on the current level There means the distance between points and Let last level we have be After calculating this dynamic programming the answer is ,1
53,Your task is to calculate the number of arrays such that each array contains elements each element is an integer from to for each array there is one pair of equal elements for each array there exists an index such that the array is before the th element and after it formally it means that if and if ,First of all there will be exactly distinct elements in our array Let s choose them there are ways to do that After that there should be exactly one element that appears twice There are elements to choose from but are all of them eligible If we duplicate the maximum element there will be no way to meet the fourth condition So we should multiply the current answer by not And finally some elements will appear earlier than the maximum in our array and some later The duplicated element will appear on both sides but all other elements should appear either to the left or to the right so there are ways to choose their positions Thus the answer is Note that you have to precompute all factorials and use their inverse elements to calculate Note that there is a tricky case when some binpow implementations go into infinite loop trying to compute so you may have to handle it specifically ,1
54, You are given a string consisting of lowercase Latin letters You have to color its characters each character to exactly one color the same letters can be colored the same or different colors i e you can choose exactly one color for each index in After coloring you can swap two neighboring characters of the string that are colored colors You can perform such an operation arbitrary possibly zero number of times The goal is to make the string sorted i e all characters should be in alphabetical order Your task is to find the minimum number of colors which you have to color the given string in so that after coloring it can become sorted by sequence of swaps Note that you have to restore only coloring not the sequence of swaps ,So the first idea that is coming into mind is prefix sums Let s define two values and The value means the amount of fall damage when we are going to the right from the column to the column and means the amount of fall damage when we are going to the left from the column to the column Then let s build prefix sums on these two arrays Now let be the sum of all on a prefix i e and be the sum of all on a prefix Then if in a query the answer is otherwise if the answer is Time complexity ,0
55,You are given a string You can build new string from using the following operation choose any subsequence where erase the chosen subsequence from can become empty concatenate chosen subsequence to the right of the string in other words Of course initially the string is empty For example let At first let s choose subsequence we will get and At second let s choose we will get and So we can build from Can you build a given string using the algorithm above ,In order to build lexicographically minimal co growing with sequence it is enough to build its elements iteratively beginning from and minimizing the th element assuming that have already been found Assign According to the statement all elements of the sequence are non negative so cannot be less than zero It turns out that is the minimal possible first element The existence of an answer with follows from the construction algorithm described below Let s use mathematical induction and construct under the assumption that all the previous elements of the sequence have already been constructed In order to satisfy the condition for the growth of the final sequence the number must contain one bits at all places but not necessarily limited to them on which there are one bits in the number Let s denote for and find out what bits can be in to satisfy this condition If in stands bit then independently from in at the same spot we can place any bit because there is no limit on the corresponding bit in If in stands bit and in then the corresponding bit in should be equal so that in the corresponding bit also equals one If in and in stands bit then in should be bit at the corresponding place for the same reasons The bit transformation described above can be given by the expression Indeed this expression gives us bit one at the fixed position if and only if at that place in stands bit and in stands bit For the full solution it remains only to apply this formula in a loop from to ,0
56,You are given a tree consisting of vertices numbered from to and edges numbered from to Initially all vertices except vertex are inactive You have to process queries of three types activate the vertex It is guaranteed that the vertex is inactive before this query and one of its neighbors is active After activating the vertex you have to choose a subset of edges of the tree such that each vertex is incident to chosen edge and each vertex is not incident to any of the chosen edges in other words this subset should represent a perfect matching on the active part of the tree If any such subset of edges exists print the sum of indices of edges in it otherwise print queries of this type will be asked only right after a query of type and there will be such queries If your answer to the previous query was simply print otherwise print the subset of edges for the previous query as follows first print the number of edges in the subset then print the indices of the chosen edges The sum of indices should be equal to your answer to the previous query terminate the program Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query Use functions in and in languages after each writing in your program ,Let s consider a problem where you can subtract the weight of any edge not only the maximum one that belong to the current path and similarly add the weight of any edge not only the minimum one that belong to the current path To solve that problem we can build a new graph where the node can be represented as the following triple node from the initial graph flag that some edge has been subtracted flag that some edge has been added Now we can run Dijkstra s algorithm to find the length of the shortest paths in such a graph We can notice that on the shortest path the maximum weight edge was subtracted and the minimum weight edge was added Let s assume that this is not the case and an edge of non maximum weight was subtracted from the path then we can reduce the length of the path by choosing an edge of maximum weight But this is not possible because we considered the shortest path Similarly it is proved that the added edge was of minimal weight Using this fact it is not difficult to notice that by solving the modified problem we have solved the original one ,0
57,Mishka received a gift of multicolored pencils for his birthday Unfortunately he lives in a monochrome world where everything is of the same color and only saturation differs This pack can be represented as a sequence of integer numbers saturation of the color of each pencil Now Mishka wants to put all the mess in the pack in order He has an infinite number of empty boxes to do this He would like to fill some boxes in such a way that Each pencil belongs to one box Each non empty box has at least pencils in it If pencils and belong to the same box then where means absolute value of Note that the opposite is optional there can be pencils and such that and they belong to different boxes Help Mishka to determine if it s possible to distribute all the pencils into boxes Print if there exists such a distribution Otherwise print ,To be honest the solution to this problem is easier to code than to prove Let s follow the next strategy Write down all the letters of the string which have odd positions in alphabet and even positions in alphabet Sort both of these lists in non decreasing order The answer is either concatenation of the lists odd even or even odd or Now for the proof part Let s establish that we don t care about equal letters and leave just a single copy of each letter of the string Let s check some cases There is just a single letter That s trivial There are two letters of the same parity There is no incorrect arrangement for this There are two letters of different parity If they differ by one then no answer exists Otherwise any arrangement works There are three letters and they are consecutive in alphabet No answer exists There are other types of three letters Then the one of the different parity can put on the side e g and As the difference between at least one of these letters and that one isn t 1 that arrangement will be ok Finally there are at least 4 letters It means that the difference between either the smallest odd and the largest even or between the smallest even and the largest odd isn t 1 The only thing you need to do is to implement the check function the most straightforward way possible and check both arrangements Overall complexity ,0
58,Vova promised himself that he would never play computer games But recently Firestorm a well known game developing company published their newest game World of Farcraft and it became really popular Of course Vova started playing it Now he tries to solve a quest The task is to come to a settlement named Overcity and spread a rumor in it Vova knows that there are characters in Overcity Some characters are friends to each other and they share information they got Also Vova knows that he can bribe each character so he or she starts spreading the rumor th character wants gold in exchange for spreading the rumor When a character hears the rumor he tells it to all his friends and they start spreading the rumor to their friends for free and so on The quest is finished when all characters know the rumor What is the minimum amount of gold Vova needs to spend in order to finish the quest Take a look at the notes if you think you haven t understood the problem completely ,Suppose we decided to make exactly turns or in other words our path will consist of exactly segments Since we should finish at point and vertical and horizontal segments alternates then it means that and From the other side we should minimize But it means that we can minimize and independently How to minimize if we know that and It s easy to prove that it s optimal to assign all except minimum and assign to this minimum the remaining part In other words to calculate the optimal path consisting of segments we need to know the sum of on odd and even positions among and also minimum among odd and even positions Then we can drive out the answer as a quite easy formula Finally we should iterate over all from to and find the minimum answer among all variants It s easy to recalculate sums and minimums when we make transition form to Complexity is ,0
59,The store sells beads The color of each bead is described by a lowercase letter of the English alphabet You want to buy some beads to assemble a necklace from them A necklace is a set of beads connected in a circle For example if the store sells beads then you can assemble the following necklaces these are not all possible options And the following necklaces cannot be assembled from beads sold in the store We call a necklace beautiful if when it is turned clockwise by beads the necklace remains unchanged For example here is a sequence of three turns of a necklace As you can see this necklace is for example beautiful beautiful beautiful and so on but it is not beautiful or beautiful In particular a necklace of length is beautiful for any integer A necklace that consists of beads of the same color is also beautiful for any You are given the integers and and also the string containing lowercase letters of the English alphabet each letter defines a bead in the store You can buy any subset of beads and connect them in any order Find the maximum length of a beautiful necklace you can assemble ,Let s iterate over the length of the beautiful necklace For each position make an edge to the position where is the remainder of dividing by What is a cyclic shift by in this construction A bead located at position will go along the edge to position Consider all the cycles of a graph constructed on You may notice that if only equal letters are found in each cycle then with a cyclic shift by the graph and the string will remain unchanged Thus in order to check whether it is possible to make a beautiful necklace of length you need to make a graph find the cycles in it and check whether it is possible to distribute the letters from the string in cycles such that each cycle have equal letters The last part of the solution can be done with simple greedy ,1
60,There s a chip in the point of the coordinate plane In one operation you can move the chip from some point to some point if the Euclidean distance between these two points is an i e is integer Your task is to determine the minimum number of operations required to move the chip from the point to the point ,Let s rewrite the formula of distance between two points as follows where if otherwise Consider what will happen if we change some to the opposite value The result of this formula obviously won t increase so we may try all possible values of and pick maximum result This allows us to consider every option to set values of there are such options separately and when we fix a set of values of find two points that maximize the distance if it is expressed with fixed To do so we have to find the point having maximum and having minimum So actually our problem is reduced to the following we have arrays we want to process some queries in the form change an element of some array and find maximum and minimum on some segment of some array This can be done simply by building a segment tree over each array and then we will get the solution having time complexity ,0
61,You have a board represented as a grid with cells The first cells on the first row and first cells on the second row are colored in white All other cells are colored in black You have white dominoes tiles both cells are colored in white and black dominoes tiles both cells are colored in black You can place a white domino on the board if both board s cells are white and not occupied by any other domino In the same way you can place a black domino if both cells are black and not occupied by any other domino Can you place all dominoes on the board if you can place dominoes both horizontally and vertically ,We can keep track of our current point as we iterate over the string if then decrement set if then increment set if then increment set if then decrement set Initially set If is ever true then we should output otherwise we output The time complexity is ,0
62, and the sum of over all test cases does not exceed A is a row of equal segments numbered to in order There are two terminals one above the other You are given an array of length For all there should be a straight wire from some point on segment of the top terminal to some point on segment of the bottom terminal You can t select the endpoints of a segment For example the following pictures show two possible wirings if and A occurs when two wires share a point in common In the picture above crossings are circled in red What is the number of crossings there can be if you place the wires optimally ,Read the solution of the easy version We want to count the number of pairs such that and This is a standard problem and we can do this we can use a segment tree or BIT for example Insert the from to and then for each count the number of using a BIT It is also related to the problem of counting inversions so you can solve it using a modification of merge sort Either way the solution is ,1
63, You are given a weighted rooted tree vertex is the root of this tree A tree is a connected graph without cycles A rooted tree has a special vertex called the root A parent of a vertex is the last different from vertex on the path from the root to the vertex Children of vertex are all vertices for which is the parent A vertex is a leaf if it has no children The weighted tree is such a tree that each edge of this tree has some weight The weight of the path is the sum of edges weights on this path The weight of the path from the vertex to itself is You can make a sequence of zero or more moves On each move you select an edge and divide its weight by rounding down More formally during one move you choose some edge and divide its weight by rounding down Each edge has an associated cost which is either or coins Each move with edge costs coins Your task is to find the minimum total to make the from the root to each leaf at most In other words if is the weight of the path from the vertex to the vertex then you have to make where is the list of all leaves You have to answer independent test cases ,Read the easy version editorial first because almost all solution is the solution to the easy version with little changes Firstly let s simulate the greedy process we used to solve the easy version problem for edges with cost and edges with cost independently But we don t stop when our sum reach something let s simulate until our sum becomes and store each intermediate result in the array for edges with cost and for edges with cost So the array contains the initial total impact of edges of cost then the impact after making one move two moves and so on The same with but for edges with cost Now let s fix how many moves on edges with cost we do Let it be and arrays and are indexed Then the sum we obtain from the cost edges is So we need to find the minimum number of moves we can do on cost edges so that This can be done using binary search or moving pointer if we iterate over in increasing order place at the end of and move it to the left while Then if we can update the answer with the value Time complexity is actually the same as in easy version of the problem ,1
64,There are piranhas with sizes in the aquarium Piranhas are numbered from left to right in order they live in the aquarium Scientists of the Berland State University want to find if there is piranha in the aquarium The piranha is called if it can eat all the other piranhas in the aquarium except itself of course Other piranhas will do nothing while the piranha will eat them Because the aquarium is pretty narrow and long the piranha can eat only one of the adjacent piranhas during one move Piranha can do as many moves as it needs or as it can More precisely The piranha can eat the piranha if the piranha exists and The piranha can eat the piranha if the piranha exists and When the piranha eats some piranha its becomes Your task is to find piranha in the aquarium or determine if there are no such piranhas Note that you have to find exactly one dominant piranha you don t have to find all of them For example if then the third piranha can be Consider the sequence of its moves The piranha eats the second piranha and becomes the underlined piranha is our candidate The piranha eats the third piranha and becomes The piranha eats the first piranha and becomes The piranha eats the second piranha and becomes You have to answer independent test cases ,If all the piranhas have the same size then the answer is Otherwise there are at least two different sizes of piranhas and the answer always exists Claim that the answer is such a piranha with the maximum size that one of the adjacent piranhas has the size less than a maximum Why is it true and why the answer always exists First if the piranha with the maximum size eats some other piranha it becomes the only maximum in the array and can eat all other piranhas Why is there always such a pair of piranhas Let s change our array a bit replace every maximum with and every non maximum with There is always some pair or pair in such array because we have at least two different elements ,1
65,Apart from having lots of holidays throughout the year residents of Berland also have whole years Year is considered if it has no more than non zero digit in its number So years 100 40000 5 are and 12 3001 and 12345 are not You are given current year in Berland Your task is to find how long will residents of Berland wait till the next year ,Notice that the next lucky year always looks like first digit of the current 1 10 number of digits of the current 1 It holds also for numbers starting with 9 it will be 10 10 number of digits 1 The answer is the difference between the next lucky year and current year ,1
66, year in Berland is such a year that its number can be represented as where and are non negative integer numbers For example if and then the years and are and year isn t as there is no such representation for it Such interval of years that there are no years in it is called You should write a program which will find maximum length of which starts no earlier than the year and ends no later than the year If all years in the interval are then the answer is ,Notice that for has no more than powers which give numbers no greater than So let s store all possible sums of all powers of and Now the answer to the query can be obtained in linear time by checking difference between neighbouring unlucky years in sorted order Don t forget that you should handle multiplying of such big numbers very carefully For example instead of writingwhile num 1e18 num num xorwhile num x 1e18 num num xyou should writewhile num 1e18 x num num xto avoid getting overflow errors of 64 bit type Integer division will work fine in that case because will never exceed if doesn t exceed Overall complexity ,1
67,You are given a binary matrix of size Rows are numbered from top to bottom from to columns are numbered from left to right from to The element located at the intersection of row and column is called Consider a set of operations Cyclically shift all rows up The row with index will be written in place of the row the row with index will be written in place of the row Cyclically shift all rows down The row with index will be written in place of the row the row with index will be written in place of the row Cyclically shift all columns to the left The column with index will be written in place of the column the column with index will be written in place of the column Cyclically shift all columns to the right The column with index will be written in place of the column the column with index will be written in place of the column You can perform an arbitrary possibly zero number of operations on the matrix the operations can be performed in any order After that you can perform an arbitrary possibly zero number of new xor operations Select any element and assign it with new value In other words the value of will have to be written into element Each application of this xor operation costs one burl Note that the shift operations are free These operations can only be performed before xor operations are performed Output the minimum number of burles you would have to pay to make the matrix unitary A is a matrix with ones on the main diagonal and the rest of its elements are zeros that is if and otherwise ,Count to the variable the number of all ones in the matrix Then consider pairs of diagonals one of which starts in cell and the other in cell for Using cyclic shifts we can assemble the main diagonal from this pair Then among all such pairs and the main diagonal find the one that contains the maximal number of ones and store this number in the variable The number of zeros on the main diagonal which should be turned into ones is equal to The number of ones to be turned into zeros because they are not on the main diagonal is calculated as The total answer is calculated as ,1
68,For a given set of two dimensional points let s denote its extension as the result of the following algorithm Create another set of two dimensional points which is initially equal to Then while there exist four numbers and such that and add to When it is impossible to find such four integers let be the result of the algorithm Now for the problem itself You are given a set of two dimensional points which is initially empty You have to process two types of queries add some point to or remove some point from it After each query you have to compute the size of ,Let s try to analyze how the size of can be calculated Let s connect points having same coordinates to each other and do the same for points having same coordinates Then we can solve the problem for each component separatedly after the algorithm is run the component will contain the points such that at least one point in the component has coordinate equal to and at least one point in the component maybe same maybe another one has coordinate equal to So the answer for each component is the product of the number of distinct coordinates and the number of distinct coordinates in the component Now we can process insertion queries there are many ways to do it but in my opinion the easiest way to handle them is to create a separate vertex for every coordinate and coordinate and process each point as an edge connecting vertices corresponding to its coordinates edges can be easily added by using DSU with rank heuristics To handle removals we will get rid of them completely Transform the input into a set of events some point exists from query to query Then build a segment tree over queries and break each event into segments with this segment tree Then we can initialize a DSU and run DFS on the vertices of the segment tree to get answers for all queries When we enter some node we add all edges that exist on the corresponding segment into DSU If we are in a leaf node we may compute the for the corresponding query And when we leave a vertex we can rollback all changes we made when we entered it One important moment is that using path compression in DSU here is meaningless since it doesn t work with rollbacks well This solution works in ,1
69,Let s call an array of size iff where is the greatest common divisor of the arguments You are given two numbers and For each you have to determine the number of arrays of size such that for every Since the answers can be very large you have to calculate them modulo ,Let s try to analyze how the size of can be calculated Let s connect points having same coordinates to each other and do the same for points having same coordinates Then we can solve the problem for each component separatedly after the algorithm is run the component will contain the points such that at least one point in the component has coordinate equal to and at least one point in the component maybe same maybe another one has coordinate equal to So the answer for each component is the product of the number of distinct coordinates and the number of distinct coordinates in the component Now we can process insertion queries there are many ways to do it but in my opinion the easiest way to handle them is to create a separate vertex for every coordinate and coordinate and process each point as an edge connecting vertices corresponding to its coordinates edges can be easily added by using DSU with rank heuristics To handle removals we will get rid of them completely Transform the input into a set of events some point exists from query to query Then build a segment tree over queries and break each event into segments with this segment tree Then we can initialize a DSU and run DFS on the vertices of the segment tree to get answers for all queries When we enter some node we add all edges that exist on the corresponding segment into DSU If we are in a leaf node we may compute the for the corresponding query And when we leave a vertex we can rollback all changes we made when we entered it One important moment is that using path compression in DSU here is meaningless since it doesn t work with rollbacks well This solution works in ,0
70,You have a board represented as a grid with cells The first cells on the first row and first cells on the second row are colored in white All other cells are colored in black You have white dominoes tiles both cells are colored in white and black dominoes tiles both cells are colored in black You can place a white domino on the board if both board s cells are white and not occupied by any other domino In the same way you can place a black domino if both cells are black and not occupied by any other domino Can you place all dominoes on the board if you can place dominoes both horizontally and vertically ,We can prove that if we have white cells on the board then we can place any white dominoes as long as The proof is the following if let s place one domino at position otherwise let s place domino at position Then we can solve the placement of dominoes in cells in the first row and cells of the second row recursively or analogically and At the end either all dominoes are placed or and If or then since then or we successfully placed all dominoes If and then we possibly need to place one domino more and we can place it vertically We can prove that we can place any dominoes as long as in the same manner As a result all we need to check is that and ,1
71,You are given a binary string consisting of only characters and or You can perform several operations on this string possibly zero There are two types of operations choose two consecutive elements and swap them In order to perform this operation you pay coins choose any element from the string and remove it In order to perform this operation you pay coins Your task is to calculate the minimum number of coins required to sort the string in non decreasing order i e transform so that where is the length of the string after applying all operations An empty string is also considered sorted in non decreasing order ,Firstly let s prove that at first and last positions of the most frequent elements should be placed but not necessary the same WLOG let s prove that for any By contradiction let s be the smallest index such that What happens if we swap them Since is the first such index then there are no for so contribution of will increase by exactly From the other side contribution of consists of two parts pairs with elements from and from For all elements from decrease will be equal to and from elements in So the total decrease after moving to position equal to The total difference in such case is equal to So our placement is not optimal contradiction Let s suggest that there is exactly one with maximum According to what we proved earlier both and must be equal to Contribution of the first and last elements will be equal to for pair and for each element with we add for pairs and So the total contribution of is equal to Note that this contribution is independent of positions of other in the array so that s why we can cut first and last elements of and solve the task recursively Unfortunately in the initial task we may have several with maximum But we in the similar manner can prove that the first and last elements should be some permutation of Now let s prove that any permutation of first and last elements is optimal Suppose positions of are and Then the contribution of is equal to The total contribution of all is This contribution doesn t depend on chosen and so any permutation of first elements and any permutation of last elements give optimal answer As a result the algorithm is following Find all maximums in If then any permutation of remaining elements has there are such permutations Otherwise add to the total balance and multiply the number of variants by Cut prefix and suffix by making for each obviously and repeat the whole process We can implement the algorithm fast if we keep the number of equal to each from to So the total complexity is ,0
72,You are given a binary string recall that a string is binary if each character is either or Let be the decimal representation of integer written in binary form possibly with leading zeroes For example and The substring is good if For example string has good substrings and Your task is to calculate the number of good substrings of string You have to answer independent queries ,At first lets precalc the array The value of if equal the maximum position in range such that After that lets iterate over the right boundary of substring and high bit position denote it as and respectively Note that if then So we iterate over such pair that and Lets look at value If then we have to increase the length of substring without increasing the value of So we need to check if there exists a position such that and This position exists if the condition is met is equal to 1 ,1
73,A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and and and are not You are given an integer Your goal is to construct and print different regular bracket sequences of length ,There are many ways to solve this problem The model solution does the following thing start with the sequence merge the first characters into one sequence to get merge the first characters into one sequence to get and so on ,1
74,You are given three arrays and Initially array consists of elements arrays and are empty You are performing the following algorithm that consists of two steps Step while is not empty you take from and move it of array If currently has odd length you can choose place the element from to the left or to the right of the middle element of As a result becomes empty and consists of elements Step while is not empty you take from and move it of array If currently has even length you can choose which of two middle elements to take As a result becomes empty and now consists of elements Refer to the Note section for examples Can you make array sorted in non decreasing order ,Let s look at elements and After the first step they will always move to positions and it s up to you to choose and or vice versa because all remaining for will be placed between and After the second step elements and will always be placed at positions and it s also up to you to decide the exact order because it s easy to see that you first take all for and only after that and In other words elements and are moved to positions and We can analogically prove that each pair is moved to a pair of positions you first take all elements for and place them at positions and then you move and finally you move all remaining elements from between and Step just does everything in reverse order to step It means that array is basically array but you can swap elements in pairs for And to make sorted we can try to sort each pair and check is it enough to sort the whole array or not ,1
75,Let number be such number that adding some leading zeros possible none to it produces a palindromic string String is called a palindrome if it reads the same from left to right and from right to left For example numbers and are they can be transformed to strings and respectively which are palindromes You are given some integer number Check if it s a number ,You can check if the given is by removing all the trailing zeros and checking if resulting string is a palindrome ,1
76,Mishka received a gift of multicolored pencils for his birthday Unfortunately he lives in a monochrome world where everything is of the same color and only saturation differs This pack can be represented as a sequence of integer numbers saturation of the color of each pencil Now Mishka wants to put all the mess in the pack in order He has an infinite number of empty boxes to do this He would like to fill some boxes in such a way that Each pencil belongs to one box Each non empty box has at least pencils in it If pencils and belong to the same box then where means absolute value of Note that the opposite is optional there can be pencils and such that and they belong to different boxes Help Mishka to determine if it s possible to distribute all the pencils into boxes Print if there exists such a distribution Otherwise print ,At first you need to sort the sequence Then if there exists some answer there also exists an answer such that every box in it contains some segment of pencils Now it s pretty standard dp approach Let be if it s possible to distribute the first pencils into boxes correctly otherwise initially Now you can come up with straightforward implementation Let s iterate over every and set to if for some and Now we should optimize it a bit Notice that the second and the third conditions actually form some segment of indices You need to check if there is at least one value on this segment This can be maintained with two pointers set BIT segment tree Anything you can code to get update in point and sum max on segment queries Overall complexity ,1
77,There are people in a row The height of the th person is You can choose subset of these people and try to arrange them into a A is such an order of people that the difference between heights of any adjacent people is no more than For example let heights of chosen people be where is the number of people you choose Then the condition should be satisfied for all from to and the condition should be also satisfied means the absolute value of It is obvious that the circle consisting of one person is balanced Your task is to choose the maximum number of people and construct a consisting of all chosen people It is obvious that the circle consisting of one person is balanced so the answer always exists ,Why did the author choose the width of the hallway to be only Well in that case you can show that the robot will never move to the left while cleaning That is not true on width already When does the robot break Let the robot currently be in the cell indexed and the next column with a dirty cell be possibly The robot breaks only if both and are dirty That helps us to do a dynamic programming solution Since we can only care about next columns we would want to have some the largest number of dirty cells we can leave to the robot if we processed the first columns of the hallway and are currently standing in the th row of the th column Maybe with some additional states of the current or the next columns We want the dp to maintain the invariant that everything to the left of the th column is cleaned in such a way the robot can reach the cell We can choose when to fix the th column either maintain it being correct prior to entering the state or handling it in the transition to the next one I chose the former option There probably exists a million different dps that work I ll describe the one I did Let be the largest number of dirty cells that we can leave to the robot if we fixed which of the dirty cells in the first columns inclusive are cleaned by hand the robot reaches the cell from the left is true if the cell in the opposite row of the th column is dirty The transitions handle what to do with the dirty cells in the st column and where the robot goes based on that In particular there are the following transitions if is true then we have to clean the cell and the robot will move into otherwise the robot breaks from having two options if is false then let s say that the robot doesn t break immediately but moves into the next column in a unique way it moves horizontally first then possibly vertically we can leave the next column as is and the robot will move into if the cell is clean or if it s dirty if is false then we can clean the cell and the robot will move into Since we maintained the invariant that the th column is valid we can update the answer from all four states in the last column Overall complexity ,0
78,Polycarp wants to build a fence near his house He has white boards and red boards he can use to build it Each board is characterised by its length which is an integer A good fence should consist of red board and several possibly zero white boards The red board should be the longest one in the fence every white board used in the fence should be strictly shorter and the sequence of lengths of boards should be ascending before the red board and descending after it Formally if boards are used and their lengths are in the order they are placed in the fence from left to right let s call this array the following conditions should hold there should be exactly one red board in the fence let its index be for every for every When Polycarp will build his fence he will place all boards from left to right on the same height of without any gaps so these boards compose a polygon Polycarp is interested in fences of some special perimeters He has integers he really likes these integers are and for every such integer he wants to calculate the number of different fences with perimeter he can build two fences are considered different if their are different Can you help him calculate these values ,Let s analyze how the perimeter of the fence can be calculated if we know its array of lengths Suppose there are boards in the fence The perimeter of the fence can be composed of the three following values the lower border of the fence with length horizontal segments in the upper border of the fence with total length vertical segment of the border The total length of all vertical segments before the red board including its left border is The total length of all vertical segments after the red board including its right border is too So the perimeter of the fence is where is the number of boards used in constructing the fence and is the length of the red board So for example if we want to create a fence that contains a red board with length and has perimeter it should contain exactly white boards Now let s solve the problem as follows iterate on the length of the red board that will be used and for each calculate the number of ways to construct a fence with a red board of length and exactly white boards which are shorter than Suppose all white boards shorter than have distinct lengths Then for each board there are three options not place it at all place it in the left part to the left of the red board or place it in the right part So if there are different white boards shorter than the number of ways to build a fence with white boards is Okay now let s consider the opposite situation there is no unique white board that is for each length we have either boards or at least boards Suppose the number of different lengths is For each length we can choose whether we place a board of such length in the left side and in the right side So the number of ways to build a fence with white boards is And now let s consider the general case Divide all boards into two categories unique and non unique If we want to build a fence with exactly white boards there are ways to do it Since we should calculate these values for many different values of we have to use FFT we should form two polynomials and and then multiply them Since the modulo is special it s better to use NTT ,1
79,You are given two integer arrays and of length You can reverse subarray continuous subsegment of the array Your task is to reverse such a subarray that the sum is ,Let s firstly consider tree with only distinct values in its nodes Then value will be reached if and only if all the jumps to the left children on the path from the root were done from the vertices with values greater than the current one and all the jumps to the right children on the path from the root were done from the vertices with values less than the current one Thus let s run dfs from the root and maintain maximal transition to the left child on current path and minimal transition to the right child on current path If the value of current node is greater than left bound and less than right bound then it will be found Now let s return to the original problem Notice that transitions and comparations won t change Store every found value in set and just calculate how many values of vertices isn t present there Overall complexity ,0
80,Recently Paul and Mary have found a new favorite sequence of integers They want to paint it using pieces of chalk of colors The coloring of a sequence is called if the following conditions are met each element of the sequence is either painted in one of colors or isn t painted each two elements which are painted in the same color are different i e there s no two equal values painted in the same color let s calculate for each of colors the number of elements painted in the color all calculated numbers must be equal the total number of painted elements of the sequence is the among all colorings of the sequence which meet the first three conditions E g consider a sequence and One of the wonderful colorings of the sequence is shown in the figure Help Paul and Mary to find a wonderful coloring of a given sequence ,Let s denote as some stack sortable array which contains all integers from to inclusive We can see that if the first element of is then where by we mean concatenation of arrays It s easy to prove this fact if the first element is then we have to store it in the stack until we have processed all elements less than so in no element that is greater than can precede any element less than This way we can represent the prefix we are given For example if and prefix is then we can rewrite the permutation we have to obtain as So the unknown suffix is a contatenation of some stack sortable arrays It s easy to see that if an array is sorted in non increasing order then it is stack sortable So we can replace each block with an array If during rewriting the given prefix we obtain some impossible situation for example when and given prefix is we have and can t be the beginning of then answer is ,0
81, You are given a weighted rooted tree vertex is the root of this tree A tree is a connected graph without cycles A rooted tree has a special vertex called the root A parent of a vertex is the last different from vertex on the path from the root to the vertex Children of vertex are all vertices for which is the parent A vertex is a leaf if it has no children The weighted tree is such a tree that each edge of this tree has some weight The weight of the path is the sum of edges weights on this path The weight of the path from the vertex to itself is You can make a sequence of zero or more moves On each move you select an edge and divide its weight by rounding down More formally during one move you choose some edge and divide its weight by rounding down Each edge has an associated cost which is either or coins Each move with edge costs coins Your task is to find the minimum total to make the from the root to each leaf at most In other words if is the weight of the path from the vertex to the vertex then you have to make where is the list of all leaves You have to answer independent test cases ,Firstly let s prove that at first and last positions of the most frequent elements should be placed but not necessary the same WLOG let s prove that for any By contradiction let s be the smallest index such that What happens if we swap them Since is the first such index then there are no for so contribution of will increase by exactly From the other side contribution of consists of two parts pairs with elements from and from For all elements from decrease will be equal to and from elements in So the total decrease after moving to position equal to The total difference in such case is equal to So our placement is not optimal contradiction Let s suggest that there is exactly one with maximum According to what we proved earlier both and must be equal to Contribution of the first and last elements will be equal to for pair and for each element with we add for pairs and So the total contribution of is equal to Note that this contribution is independent of positions of other in the array so that s why we can cut first and last elements of and solve the task recursively Unfortunately in the initial task we may have several with maximum But we in the similar manner can prove that the first and last elements should be some permutation of Now let s prove that any permutation of first and last elements is optimal Suppose positions of are and Then the contribution of is equal to The total contribution of all is This contribution doesn t depend on chosen and so any permutation of first elements and any permutation of last elements give optimal answer As a result the algorithm is following Find all maximums in If then any permutation of remaining elements has there are such permutations Otherwise add to the total balance and multiply the number of variants by Cut prefix and suffix by making for each obviously and repeat the whole process We can implement the algorithm fast if we keep the number of equal to each from to So the total complexity is ,0
82,Let be arbitrary binary tree tree every vertex of which has no more than two children Given tree is rooted so there exists only one vertex which doesn t have a parent it s the root of a tree Every vertex has an integer number written on it Following algorithm is run on every value from the tree Set pointer to the root of a tree Return success if the value in the current vertex is equal to the number you are looking for Go to the left child of the vertex if the value in the current vertex is greater than the number you are looking for Go to the right child of the vertex if the value in the current vertex is less than the number you are looking for Return fail if you try to go to the vertex that doesn t exist Here is the pseudo code of the described algorithm bool find TreeNode t int x if t null return false if t value x return true if x t value return find t left x else return find t right x find root x The described algorithm works correctly if the tree is binary search tree i e for each node the values of left subtree are less than the value in the node the values of right subtree are greater than the value in the node But it can return invalid result if tree is not a binary search tree Since the given tree is not necessarily a binary search tree not all numbers can be found this way Your task is to calculate how many times the search will fail being running on every value from the tree If the tree has multiple vertices with the same values on them then you should run algorithm on every one of them separately ,There is a common approach for the problem you are given a lot of strings and texts count the number of occurences of the strings in the texts build an Aho Corasick automaton on the given strings and somehow process the texts with it Let s see if it can handle this problem The names of the songs can be represented as a tree We may build an Aho Corasick on the strings given in the queries then try to input the names of the album into the automaton character by character with DFS on the aforementioned tree feeding a character to the automaton when we enter a node and reverting the automaton to the previous state when we leave that node Suppose that when we are in the vertex corresponding to the th song the automaton is in state If is a terminal state corresponding to some string from the queries it means that the string from the query is a suffix of the th song But some other strings can also be the suffixes of the same song to find all such strings we can start ascending from the state to the root of Aho Corasick automaton using suffix links or dictionary links Since suffix links can be represented as the edges of some rooted tree then we can build some data structure on this tree that allows adding an integer to all vertices on the path from the root to the given vertex for example we can use Fenwick tree over Euler tour of the tree Then to check whether some string from the query is a suffix of the song we may add to all vertices on the path to state and then check the value in the state corresponding to Okay what about counting the occurences of in Let s consider the path from the root to in the song tree Every vertex on this path corresponds to some prefix of the song so we can add on the path to state corresponding to some prefix and then extract the answer from the state corresponding to In fact that s all we have to do to obtain a solution Build an automaton on strings from queries a tree of suffix links over this automaton and a data structure on this tree for each vertex of the song tree store all queries to it Then run a DFS on the song tree When we enter some vertex input the corresponding character into the automaton and add to all states from the root of suffix link tree to the current state when we have to process queries to the current vertex extract the values from the data structure and when we leave a vertex subtract from all states from the root of suffix link tree to the current state and revert to the previous state This solution has complexity of where is the total length of all strings in the input ,0
83,Let s define for a positive integer as the length of the base 10 representation of without leading zeros I like to call it a digital logarithm Similar to a digital root if you are familiar with that You are given two arrays and each containing positive integers In one operation you do the following pick some integer from to assign either to or to Two arrays are considered similar to each other if you can rearrange the elements in both of them so that they are equal e g for all from to What s the smallest number of operations required to make and similar to each other ,First why can you always make the arrays similar Applying a digital logarithm to any number will eventually make it equal to Thus you can at least make all numbers into s in both arrays Then notice the most improtant thing applying the digital logarithm to a number greater than always makes this number smaller Thus if a number appears in only one of the arrays you will have to do one of the followings two things decrease some greater number to make it equal to this one decrease this number What if there is no greater number at all This is the case for the largest number in both arrays altogether If it appears in only one of the arrays you must always decrease If it appears in both though why decrease it further Worst case you will decrease it in one array then you ll have to decrease it in the other array as well This is never more optimal than just matching one occurrence in both arrays to each other and removing them from the arrays So the proposed solution is the following Consider the largest element in each array If they are equal remove both If not apply digital logarithm to the larger of them Continue until the arrays are empty What s the estimated complexity of this algorithm Each number in the first array will be considered at most the number of times you can decrease it with a digital logarithm operation plus one That is at most a number greater than always becomes a single digit and a single digit always becomes Same goes for the second array So the complexity is basically linear To implement it efficiently you will have to use some data structure that provides three operations peek at the maximum remove the maximum insert a new element The perfect one is a heap priority queue in C Overall complexity per testcase ,1
84,You are given a permutation of length a permutation of length is an array of length in which each integer from to occurs exactly once You can perform the following operation any number of times possibly zero choose two different elements and and erase them from the permutation insert the minimum of and into the permutation in such a way that it becomes the first element insert the maximum of and into the permutation in such a way that it becomes the last element For example if and we want to apply the operation to the elements and then after the first step of the operation the permutation becomes and after we insert the elements it becomes Your task is to calculate the minimum number of operations described above to sort the permutation in ascending order i e transform so that ,If the array is already sorted then the answer is Otherwise there is a last operation after which the permutation takes the form Which means that the elements and are selected as the last operation because they are at the first and last positions after the operation Now we know that the last operation is and it doesn t matter where exactly these numbers are in the permutation i e we can assume that the answer has increased by and consider only the numbers 1 Similarly for the remaining permutation there are two options either it is sorted and then the answer is or there is a last operation and the numbers and are used in it And so on until the remaining permutation is sorted or empty It remains to find out how to quickly check whether the numbers in the segment are sorted they go in the correct order in the initial permutation Note that this segment corresponds to values of elements not to positions in the permutation If this segment is sorted for some then the answer does not exceed There are several ways to check let s consider one of them Note that if the segment is sorted for some value then it will be sorted for large values as well So we can start with the maximum value of which is equal to and decrease it until the segment remains sorted Now for each we need only two checks that and where is the position of the element in the permutation Thus we got the solution in linear time Another way is to run binary search on since if the numbers in appear in the permutation in sorted order the same holds for This approach yields a solution in ,1
85,There are piranhas with sizes in the aquarium Piranhas are numbered from left to right in order they live in the aquarium Scientists of the Berland State University want to find if there is piranha in the aquarium The piranha is called if it can eat all the other piranhas in the aquarium except itself of course Other piranhas will do nothing while the piranha will eat them Because the aquarium is pretty narrow and long the piranha can eat only one of the adjacent piranhas during one move Piranha can do as many moves as it needs or as it can More precisely The piranha can eat the piranha if the piranha exists and The piranha can eat the piranha if the piranha exists and When the piranha eats some piranha its becomes Your task is to find piranha in the aquarium or determine if there are no such piranhas Note that you have to find exactly one dominant piranha you don t have to find all of them For example if then the third piranha can be Consider the sequence of its moves The piranha eats the second piranha and becomes the underlined piranha is our candidate The piranha eats the third piranha and becomes The piranha eats the first piranha and becomes The piranha eats the second piranha and becomes You have to answer independent test cases ,This problem can be solved with mincost maxflow approach Let s construct a following network Construct a vertex for every number from to For each of these vertices add directed edges from the source to this vertex the capacity of each edge will be and the costs will be so pushing flow from the source to the vertex will cost exactly Also construct a vertex for every index of the array For each number make add a directed edge with capacity and cost to every position in the array such that this number can be put into this position and for every index make a directed edge from the vertex constructed for this index to the sink with capacity and cost Minimum cost maximum flow in this network will construct a suitable array with minimum cost so the answer to the problem is minimum cost of maximum flow in the network ,0
86,Ivan is developing his own computer game Now he tries to create some levels for his game But firstly for each level he needs to draw a graph representing the structure of the level Ivan decided that there should be exactly vertices in the graph representing level and the edges have to be bidirectional When constructing the graph Ivan is interested in special edges called An edge between two vertices and is called a if this edge belongs to every path between and and these vertices will belong to different connected components if we delete this edge For each level Ivan wants to construct a graph where at least half of the edges are He also wants to maximize the number of edges in each constructed graph So the task Ivan gave you is given numbers for each tell the maximum number of edges in a graph with vertices if at least half of the edges are ,The best way to build a graph is to make a edge connected component with vertices and connect each of the remaining vertices to it with a single edge Then we will have bridges outside the component and edges in the component So the answer for some fixed and is let s denote is at Now since is increasing and is decreasing there exists some such that if then and if then Then is strictly increasing on the segment and strictly decreasing on the segment and this proves that we can use ternary search to find its maximum ,1
87,You are given an undirected complete graph on vertices A complete graph is a graph where each pair of vertices is connected by an edge You have to paint the edges of the graph into two colors red and blue each edge will have one color A set of vertices is if for every pair of vertices such that and there exists a path from to that goes only through red edges and vertices from Similarly a set of vertices is if for every pair of vertices such that and there exists a path from to that goes only through blue edges and vertices from You have to paint the graph in such a way that there is at least one red edge there is at least one blue edge for each set of vertices such that is either red connected or blue connected but Calculate the number of ways to paint the graph and print it modulo , if an undirected graph is disconnected then its complement is connected Similarly if its complement is disconnected then the graph itself is connected suppose a graph is disconnected Pick two vertices and from different components Every vertex outside of s component is connected to in the complement and every vertex outside of s component is connected to in the complement the complement also contains the edge from to so all vertices in the complement graph belong to the single component Why do we need this lemma at all We can treat the graph formed by blue edges as the complement to the graph formed by red edges So if the red graph is disconnected then the blue graph is connected so we don t need to consider the case when some set of vertices is connected by neither color We only need to make sure that no set of vertices is connected by both colors Let be the answer for Every graph counted in is either red disconnected or blue disconnected since there is a bijection between red disconnected and blue disconnected graphs you can flip the colors of all edges to transform one type into the other we will count only red disconnected graphs and multiply it by Let be the number of blue connected graphs with vertices meeting the properties of the problem statement It s easy to see that if otherwise the case is special because a graph on one vertex is both red connected and blue connected To calculate let s iterate on the number of vertices which are in the same red component as This component must be a red connected graph which meets the problem statement so the number of ways to build the graph on these vertices is there are ways to choose the vertices in the same component as and the remaining graph can be either red connected or blue connected so the number of ways to build the remaining graph is Thus we get the following two relations We can calculate all values with dynamic programming using these formulas in ,1
88,There is a building consisting of apartments numbered from to inclusive Call an apartment if its number consists of Examples of boring apartments are and so on Our character is a troublemaker and he calls the intercoms of all apartments till someone answers the call in the following order First he calls all apartments consisting of digit in increasing order Next he calls all apartments consisting of digit in increasing order And so on The resident of the boring apartment answers the call and our character calling anyone further Our character wants to know how many digits he pressed in total and your task is to help him to count the total number of keypresses For example if the resident of boring apartment answered then our character called apartments with numbers and the total number of digits he pressed is You have to answer independent test cases ,This problem has a lot of solutions You could even hard code all possible tests to solve it But this problem has solution Let the digit of be Then our character pressed each digit before exactly times And the amount of times he pressed the digit depends on the length of Let be the length of then the amount of times he pressed the digit is So the final answer is ,1
89,Alperen is standing at the point He is given a string of length and performs moves The th move is as follows if then move one unit left if then move one unit right if then move one unit up if then move one unit down There is a candy at that is one unit above and one unit to the right of Alperen s starting point You need to determine if Alperen ever passes the candy ,We can keep track of our current point as we iterate over the string if then decrement set if then increment set if then increment set if then decrement set Initially set If is ever true then we should output otherwise we output The time complexity is ,1
90,An array of integers is called a if it contains each number from to exactly once For example the following arrays are permutations and The following arrays are permutations Polycarp invented a really cool permutation of length It is very disappointing but he forgot this permutation He only remembers the array of length where Given and help Polycarp restore the invented permutation ,Let s Thus It means that the sequence of partial sums is the required permutation if we do to each element The value of is unknown yet Find such that is minimum Thus Exactly this value will change to be after you add So add to each element of and check that now it is a permutation Probably you need to use to avoid possible integer overflows ,1
91,You are given an array Count the number of pairs of indices such that ,Let be nested depth of RBS There is an interesting fact that From the other side we can always reach equation using some approaches Let s look at prefix of length of string Let be number of opening bracket in the prefix number of closing brackets Then we can define balance of the th prefix of as The author s approach is next Let s define of pair of brackets matched in natural way as where is position of opening bracket of this pair Then we will color in red all pairs with even level and in blue with odd level Proof of It can be shown that and exists such that After any coloring of we can define number of opening closing red blue brackets of th prefix of as and respectively Since and then Finally ,0
92,Eve is a beginner stand up comedian Her first show gathered a grand total of two spectators Alice and Bob Eve prepared jokes to tell grouped by their type type 1 both Alice and Bob like them type 2 Alice likes them but Bob doesn t type 3 Bob likes them but Alice doesn t type 4 neither Alice nor Bob likes them Initially both spectators have their mood equal to When a spectator hears a joke he she likes his her mood increases by When a spectator hears a joke he she doesn t like his her mood decreases by If the mood of a spectator becomes negative strictly below zero he she leaves When someone leaves Eve gets sad and ends the show If no one leaves and Eve is out of jokes she also ends the show Thus Eve wants to arrange her jokes in such a way that the show lasts as long as possible Help her to calculate the maximum number of jokes she can tell before the show ends ,First let Eve tell the jokes of the first type they will never do any harm At the same time let her tell the jokes of the fourth time at the very end they will not do any good Types two and three are kind of opposites of each other If you tell jokes of each of them one after another then the moods of both spectators don t change Let s use that to our advantage Tell the jokes of these types in pairs until one of them runs out There s a little corner case here though If there were no jokes of the first type then you can t use a single pair because of the spectators leaves after one joke Finally try to tell the remaining jokes of the same type before the fourth type So the construction looks like with and possibly swapped with each other Let s recover the answer from that construction After the first type both moods are After the alternating jokes the moods are still the same After that one of the spectators will have his her mood only decreasing until the end Once it reaches the show ends Thus Eve can tell jokes if Otherwise it s always Overall complexity ,1
93,An array of integers is called a if it contains each number from to exactly once For example the following arrays are permutations and The following arrays are permutations Polycarp invented a really cool permutation of length It is very disappointing but he forgot this permutation He only remembers the array of length where Given and help Polycarp restore the invented permutation ,Let s solve the problem for the first candidate To win the election he needs to get at least more votes than every other candidate Therefore the first candidate needs to get at least votes If is already greater than this value then you don t need to add any votes otherwise you need to add votes So the answer for the first candidate is Similarly the answer for the second candidate is and for the third one the answer is ,0
94,You are given three integers and Consider all binary strings i e all strings consisting of characters and or of length from to For every such string you need to choose an integer from to A multiset of binary strings of length is considered beautiful if for every binary string with length from to the number of strings in the multiset such that is their prefix is not exceeding For example let and The multiset of strings is beautiful since for the string there are strings in the multiset such that is their prefix and for the string there is one string in the multiset such that is its prefix and for the string there are strings in the multiset such that is their prefix and for the string there is one string in the multiset such that is its prefix and for the string there are strings in the multiset such that is their prefix and for the string there is one string in the multiset such that is its prefix and Now for the problem itself You have to calculate the number of ways to choose the integer for every binary string of length from to in such a way that the possible size of a beautiful multiset is ,Notice that there are only possible patterns in this game You can used in a following way Simulate games till one of the patterns get repeated Games between this pair of occurences will get you the same total outcome no matter when they are played Let the distance between the games with the same pattern is and index of these games are and zero indexed Total score of some interval is Then the answer will be ,0
95, You are given a weighted rooted tree vertex is the root of this tree A tree is a connected graph without cycles A rooted tree has a special vertex called the root A parent of a vertex is the last different from vertex on the path from the root to the vertex Children of vertex are all vertices for which is the parent A vertex is a leaf if it has no children The weighted tree is such a tree that each edge of this tree has some weight The weight of the path is the sum of edges weights on this path The weight of the path from the vertex to itself is You can make a sequence of zero or more moves On each move you select an edge and divide its weight by rounding down More formally during one move you choose some edge and divide its weight by rounding down Your task is to find the minimum number of required to make the from the root to each leaf at most In other words if is the weight of the path from the vertex to the vertex then you have to make where is the list of all leaves You have to answer independent test cases ,Let s define as the number of leaves in the subtree of the th edge of course in terms of vertices in the subtree of the lower vertex of this edge Values of can be calculated with pretty standard and simple dfs and dynamic programming Then we can notice that our edges are independent and we can consider the initial answer sum of weights of paths as Let be the difference between the current impact of the th edge and the impact of the th edge if we divide its weight by This value means how the sum of weights decreases if we divide the weight of the th edge by Create ordered set which contains pairs Then the following greedy solution works let s take the edge with maximum and divide its weight by Then re add it into the set with new value When the sum becomes less than or equal to just stop and print the number of divisions we made The maximum number of operations can reach so the solution complexity is each operation takes time because the size of the set is ,1
96,This year Alex has finished school and now he is a first year student of Berland State University For him it was a total surprise that even though he studies programming he still has to attend physical education lessons The end of the term is very soon but unfortunately Alex still hasn t attended a single lesson Since Alex doesn t want to get expelled he wants to know the number of working days left until the end of the term so he can attend physical education lessons during these days But in BSU calculating the number of working days is a complicated matter There are days left before the end of the term numbered from to and initially all of them are working days Then the university staff sequentially publishes orders one after another Each order is characterised by three numbers and If then all days from to inclusive become non working days If some of these days are made working days by some previous order then these days still become non working days If then all days from to inclusive become working days If some of these days are made non working days by some previous order then these days still become working days Help Alex to determine the number of working days left after each order ,Let s store current intervals with non working days in set sorted by the right border When new query comes you search for the first interval to have its right border greater or equal than the currect left border and update all intervals to intersect the query either fully delete or insert back its part which doesn t intersect query Finally if then insert the query into current set Updates on the number of working days can be done while deleting segments on the fly Overall complexity ,1
97,The store sells beads The color of each bead is described by a lowercase letter of the English alphabet You want to buy some beads to assemble a necklace from them A necklace is a set of beads connected in a circle For example if the store sells beads then you can assemble the following necklaces these are not all possible options And the following necklaces cannot be assembled from beads sold in the store We call a necklace beautiful if when it is turned clockwise by beads the necklace remains unchanged For example here is a sequence of three turns of a necklace As you can see this necklace is for example beautiful beautiful beautiful and so on but it is not beautiful or beautiful In particular a necklace of length is beautiful for any integer A necklace that consists of beads of the same color is also beautiful for any You are given the integers and and also the string containing lowercase letters of the English alphabet each letter defines a bead in the store You can buy any subset of beads and connect them in any order Find the maximum length of a beautiful necklace you can assemble ,The person with the number looks at the person with the number so the count of people standing to the left of between and is equal to the count of people standing to the right of between and Therefore both counts are equal to hence must be a solution of the equation The only solution of the equation is Let s check that in the circle of people can occur the numbers and i e let s check that If it s false there s no solution output Since the person with the number looks at the person with the number the condition must be met Let s solve the equation for There are two solutions We can output any of such that It s easy to prove that exactly one of the solutions meets the condition ,0
98,You are given the current time in hour format Find and print the time after minutes Note that you should find only the time after minutes see the examples to clarify the problem statement You can read more about hour format here https en wikipedia org wiki 24 hour clock ,First of all let s visualize the problem in a different way We have to set some constraints on the number of strings which have some kind of prefix Let s think about a data structure that would allow us to understand it better One of the most common data structures to store strings which works with their prefixes and maintains the number of strings with some prefix is a trie so we can reformulate this problem using tries Now the problem is the following one we have a binary trie of depth the leaves of this trie may store strings and for each vertex except for the root we can set a constraint on the number of strings stored in the subtree what is the number of ways to choose these constraints so that the maximum number of strings possibly with copies the trie can store is exactly To handle it we can use dynamic programming of the form the number of ways to choose the constraints for the vertex and its subtree so that the maximum number of strings which can be stored in the subtree is exactly When calculating we can iterate on the constraint for the vertex let it be and the maximum number of strings in the subtrees of and let these be and and make updates of the form add to the value of This dynamic programming will work in or depending on the implementation which is too slow However we can use the following optimizations to improve the complexity of the solution all vertices on the same depth can be treated as equivalent so we can actually calculate this dynamic programming not for vertices but just for when handling transitions from some node s children to that node let s split these transitions into two steps The first step is iterating on the number of strings which fit into the subtrees of the children the second step is iterating on the constraint for the subtree of the node The first step is actually a convolution if we don t consider the constraint for the node itself then the transitions would be something like add to the value of so it can be improved to with FFT The second step can be improved to as well if we iterate on the minimum between the constraint for the node and the total number of strings which can be stored in the children and maintain the sum on suffix for the values of dynamic programming Overall these optimizations lead to a solution with complexity ,0
99,Some number of people this number is even have stood in a circle The people stand in the circle evenly They are numbered clockwise starting from a person with the number Each person is looking through the circle s center at the opposite person You don t know the exact number of people standing in the circle but this number is even no doubt It is known that the person with the number is looking at the person with the number and vice versa of course What is the number associated with a person being looked at by the person with the number If for the specified and no such circle exists output ,Let s solve the problem for the first candidate To win the election he needs to get at least more votes than every other candidate Therefore the first candidate needs to get at least votes If is already greater than this value then you don t need to add any votes otherwise you need to add votes So the answer for the first candidate is Similarly the answer for the second candidate is and for the third one the answer is ,0
100,You are given an array consisting of integers Your task is to determine if has some of length at least that is a palindrome Recall that an array is called a of the array if can be obtained by removing some possibly zero elements from not necessarily consecutive without changing the order of remaining elements For example and are subsequences of but and are not Also recall that a palindrome is an array that reads the same backward as forward In other words the array of length is the palindrome if for all from to For example arrays and are palindromes but arrays and are not You have to answer independent test cases ,Let s solve the problem for the first candidate To win the election he needs to get at least more votes than every other candidate Therefore the first candidate needs to get at least votes If is already greater than this value then you don t need to add any votes otherwise you need to add votes So the answer for the first candidate is Similarly the answer for the second candidate is and for the third one the answer is ,0
101,You have a card deck of cards numbered from top to bottom i e the top card has index and bottom card index Each card has its color the th card has color You should process queries The th query is described by integer For each query you should find the highest card in the deck with color i e the card with minimum index print the position of the card you found take the card and place it on top of the deck ,Let s look at one fixed color When we search a card of such color we take the card with minimum index and after we place it on the top of the deck it remains the one with minimum index It means that for each color we take and move the same card one card for each color In other words we need to keep track of only cards where is the number of colors As a result if is the position of a card of color then we can simulate a query in the following way for each color such that we increase by one since the card will move down and then set Complexity is But if we look closely we may note that we don t even need array We can almost manually find the first card of color and move it to the first position either by series of swaps or for example using function present in C and it will work fast Why Let s look at one color For the first time it will cost operations to search the corresponding card and move it to the position But after that at any moment of time the position of the card won t exceed since all cards before are pairwise different due to the nature of queries So all next moves the color costs only time As a result the complexity of such almost naive solution is ,1
102,You are given a directed acyclic graph a directed graph that does not contain cycles of vertices and arcs The th arc leads from the vertex to the vertex and has the weight Your task is to select an integer for each vertex and then write a number on each arcs such that You must select the numbers so that all are positive the value of the expression is the lowest possible It can be shown that for any directed acyclic graph with non negative such a way to choose numbers exists ,The key observation in this problem is that the values of should form a contiguous segment of integers For example suppose there exists a value such that there is at least one there is at least one but no We can decrease all values of that are greater than by so the answer will still be valid but the value of will decrease So the values of form a contiguous segment of integers We can always assume that this segment is since subtracting the same value from each does not change anything The other observation we need is that we can rewrite the expression we have to minimize as follows where is the signed sum of weights of all arcs incident to the vertex the weights of all arcs leading from are taken with positive sign and the weights of all arcs leading to are taken with negative sign These two observations lead us to a bitmask dynamic programming solution let be the minimum value of if we assigned the values from to the vertices from A naive way to calculate this dynamic programming is to iterate on the submask of check that choosing the integer for each vertex from that submask doesn t ruin anything for each vertex that belongs to this submask all vertices that are reachable from it should have so they should belong to but not to the submask we iterate on and update the dynamic programming value But this solution is and depending on your implementation this might be too slow It s possible to speed this up to in a way similar to how profile dp can be optimized from to we won t iterate on the submask instead we will try to add the vertices one by one and we should be able to add a vertex to the mask only if all vertices that are reachable from it already belong to the mask There is a possibility that we add two vertices connected by an arc with the same value of so for a fixed value of we should consider assigning it to vertices in topological sorting order that way if one vertex is reachable from another it will be considered later so we won t add both of those with the same value of ,1
103,You are given a text consisting of space separated words There is exactly one space character between any pair of adjacent words There are no spaces before the first word and no spaces after the last word The length of text is the number of letters and spaces in it is the th word of text All words consist only of lowercase Latin letters Let s denote a segment of words as a sequence of words Two segments of words and are considered if and for every For example for the text the segments and are equal they correspond to the words An abbreviation is a replacement of some segments of words with their first letters In order to perform an abbreviation you have to choose non intersecting equal segments of words and replace each chosen segment with the string consisting of first letters of the words in the segment written in uppercase For example for the text you can replace segments of words and with an abbreviation and obtain the text or you can replace segments of words and with an abbreviation and obtain the text What is the minimum length of the text after at most one abbreviation ,Let eq i j equals true if words s i and s j are equal otherwise it will be equals false We can iterate over all pairs of words and compare they just using standard string comparator constraints are really small so we can do it naively The next step is to calculate dynamic programming dp i j which will be equal to the maximum length of coinciding segments of words which starts in positions i and j respectively In other words if dp i j equals k then s i i k 1 s j j k 1 word by word We can calculate this dynamic programming in reverse order i n 1 0 j n 1 0 and dp i j 0 if s i ne s j else if i n 1 and j n 1 then dp i j dp i 1 j 1 1 otherwise dp i j 1 Let s keep the length of the text in the variable allsum Then iterate over all starting positions of the possible abbreviation and all its possible lengths Let the current starting position will be equals i 0 indexed and its length will be equal j Then we need to calculate the number of possible replacements by its abbreviation Let it be cnt and now it equals 1 Let s iterate over all positions pos at the beginning pos i j 0 indexed If dp i pos ge j then we can replace the segment of words which starts at the position pos with its abbreviation so cnt cnt 1 and pos pos j because we cannot replace intersecting segments otherwise pos pos 1 After this we need to update the answer The length of the segment of words s i j can be calculated easily let it be seglen Also let segcnt be the number of words in the current segment of words Then we can update the answer with the value allsum seglen cnt cnt segcnt Overall complexity is O n 3 n cdot sum limits i 0 n 1 s i where s i is the length of the i th word ,1
104,You are given two integers and Calculate the number of pairs of arrays such that the length of both arrays is equal to each element of each array is an integer between and inclusive for any index from to array is sorted in non descending order array is sorted in non ascending order As the result can be very large you should print it modulo ,The first observation is that we can always try to find the palindrome of length otherwise we can remove some characters from the middle until its length becomes The second observation is that the palindrome of length is two equal characters and some other maybe the same character between them Now there are two ways find the pair of equal non adjacent characters in or do it in for each character we only need to consider its left and right occurrences ,0
105,You are given a text consisting of space separated words There is exactly one space character between any pair of adjacent words There are no spaces before the first word and no spaces after the last word The length of text is the number of letters and spaces in it is the th word of text All words consist only of lowercase Latin letters Let s denote a segment of words as a sequence of words Two segments of words and are considered if and for every For example for the text the segments and are equal they correspond to the words An abbreviation is a replacement of some segments of words with their first letters In order to perform an abbreviation you have to choose non intersecting equal segments of words and replace each chosen segment with the string consisting of first letters of the words in the segment written in uppercase For example for the text you can replace segments of words and with an abbreviation and obtain the text or you can replace segments of words and with an abbreviation and obtain the text What is the minimum length of the text after at most one abbreviation ,Suppose all queries have the same right border Then the answer for the query can be some integer such that the last occurence of on the prefix of the array is inside the segment but the second to last occurence is outside the segment or even does not exist More formally let be the maximum index such that and or if there is no such the answer to the query is some number such that and and is the rightmost occurence of in the segment For a fixed right border we can build a segment tree which for every index such that is the rightmost occurence of on stores the value of and if we query minimum on the segment in such tree we can try to find the answer Let the position of minimum be If then can be the answer otherwise there is no answer But this is too slow since we can t afford to build a segment tree for every possible value of There are two methods how to deal with this problem you may sort all queries by their right borders and maintain the segment tree while shifting the right border when going from to we have to update the values in the positions and or we may use a persistent segment tree and get an online solution We tried to eliminate solutions using Mo s algorithm but in fact it s possible to squeeze some implementations of it into TL There are two optimizations that might help there When dividing the elements into blocks we may sort the first block in the ascending order of right borders the second in descending the third in ascending order again and so on And also it s possible to obtain a Mo based solution with worst case complexity of if we maintain the set of possible answers using sqrt decomposition on it ,0
106,For a given set of two dimensional points let s denote its extension as the result of the following algorithm Create another set of two dimensional points which is initially equal to Then while there exist four numbers and such that and add to When it is impossible to find such four integers let be the result of the algorithm Now for the problem itself You are given a set of two dimensional points which is initially empty You have to process two types of queries add some point to or remove some point from it After each query you have to compute the size of ,First of all I wanted to offer you one little challenge I found a solution that I can t break and I don t sure if it can be broken and I will be so happy if anyone will give me countertest which will break it You can see its code below Let s notice that we can reduce our problem to the following find two substrings of the given string that letters in them do not intersect and the total length of these substrings is the maximum possible Why can we make such a reduction It is so because our answer consists of at most two non intersecting parts one fixed substring and at most one substring that we appended to the first one We can always append any other substring to the first one by one reverse operation just look at some examples to understand it Let s iterate over all possible substrings of length at most AL where AL is the size of the alphabet which contain distinct letters We can do it in O n AL Let the current substring containing distinct letters be s i j Let s create the bitmask corresponding to this substring the bit pos is 1 if the pos th letter of the alphabet is presented in the substring and 0 otherwise letters are Store all these masks somewhere Notice that our current problem can be reduced to the following we have the set of masks and we need to find a pair of masks that they do not intersect and their total number of ones in them is the maximum possible This reduction is less obvious than the previous one but you also can understand it considering some examples So how to solve this problem We can do it with easy bitmasks dynamic programming Let dp mask be the maximum number of ones in some mask that is presented in the given string and it is the submask of mask How to calculate this dynamic programming First of all all values dp mask for all masks presented in the string are equal to the number of ones in corresponding masks Let s iterate over all masks from 0 to 2 AL 1 Let the current mask be mask Then let s try to update the answer for this mask with the answer for one of its submasks It is obvious that because of dynamic programming we need to remove at most one bit from our mask to cover all possible submasks that can update our answer So let s iterate over all bits in mask let the current bit be pos If this bit is zero then just skip it Otherwise update dp mask max dp mask dp mask hat 2 pos where hat is the operation After calculating this dynamic programming we can finally calculate the answer Let s iterate over all masks presented in the string let the current mask be mask We can update the answer with the number of ones in mask plus dp mask hat 2 AL 1 mask hat 2 AL 1 is the completion of mask Total complexity O n AL AL 2 AL ,0
107,You a captain of a ship Initially you are standing in a point obviously all positions in the sea can be described by cartesian plane and you want to travel to a point You know the weather forecast the string of length consisting only of letters and The letter corresponds to a direction of wind Moreover the forecast is periodic e g the first day wind blows to the side the second day the th day and th day again and so on Ship coordinates change the following way if wind blows the direction then the ship moves from to if wind blows the direction then the ship moves from to if wind blows the direction then the ship moves from to if wind blows the direction then the ship moves from to The ship can also either go one of the four directions or stay in place each day If it goes then it s exactly 1 unit of distance Transpositions of the ship and the wind add up If the ship stays in place then only the direction of wind counts For example if wind blows the direction and the ship moves the direction then from point it will move to the point and if it goes the direction then it will move to the point You task is to determine the minimal number of days required for the ship to reach the point ,Note that if we can reach the destination in days so we can reach it in days since we can stay in the destination point by moving to the opposite to the wind direction So we can binary search the answer To check the possibility to reach the destination point in days we should at first look at the position the wind moves ship to Now we can calculate where we can go since each day we can move in one of four directions or not move at all we can reach any point with Manhattan distance So we need to check that To calculate we can note that there were full cycles and extra days So it can be calculated with time using prefix sums Finally about borders of binary search to reach the destination point we need to move closer at least by one it terms of Manhattan distance from the full cycle of the wind So if answer exists then it doesn t exceed ,1
108,There s a chip in the point of the coordinate plane In one operation you can move the chip from some point to some point if the Euclidean distance between these two points is an i e is integer Your task is to determine the minimum number of operations required to move the chip from the point to the point ,Note that the answer does not exceed because the chip can be moved as follows Obviously in this case both operation are valid It remains to check the cases when the answer is or The answer is only if the destination point is and the answer is if is integer ,1
109,Ivan is developing his own computer game Now he tries to create some levels for his game But firstly for each level he needs to draw a graph representing the structure of the level Ivan decided that there should be exactly vertices in the graph representing level and the edges have to be bidirectional When constructing the graph Ivan is interested in special edges called An edge between two vertices and is called a if this edge belongs to every path between and and these vertices will belong to different connected components if we delete this edge For each level Ivan wants to construct a graph where at least half of the edges are He also wants to maximize the number of edges in each constructed graph So the task Ivan gave you is given numbers for each tell the maximum number of edges in a graph with vertices if at least half of the edges are ,If you have at least units of energy then the answer is because you can just walk to the end Otherwise the answer is because you can just sit on the first bench and then just go Time complexity ,0
110,Maksim walks on a Cartesian plane Initially he stands at the point and in one move he can go to any of four adjacent points left right up down For example if Maksim is currently at the point he can go to any of the following points in one move There are also key points at this plane The th point is It is guaranteed that and and there is no key point Let the first level points be such points that the second level points be such points that and so on Maksim wants to visit all the key points But he shouldn t visit points of level if he does not visit all the points of level He starts visiting the points from the minimum level of point from the given set The distance between two points and is where is the absolute value of Maksim wants to visit all the key points in such a way that the total distance he walks will be minimum possible Your task is to find this distance ,A number is divisible by if and only if its last two digits represent one of the following strings Let s solve for each string the following subtask what is the minimum number of characters to be deleted so that the string becomes a suffix of the number Then choosing the minimum of the answers for all subtasks we solve the whole problem Let s solve the subtask for a string where and are digits We can do it using the following algorithm let s delete the last digit of the number until it is equal to then the second to last digit of the number until it is equal to If it is not possible then this subtask has no solution i e its result will not affect the answer ,0
111,You play a computer game In this game you lead a party of heroes and you have to clear a dungeon with monsters Each monster is characterized by its power Each hero is characterized by his power and endurance The heroes clear the dungeon day by day In the beginning of each day you choose a hero exactly one who is going to enter the dungeon this day When the hero enters the dungeon he is challenged by the first monster which was not defeated during the previous days so if the heroes have already defeated monsters the hero fights with the monster When the hero fights the monster there are two possible outcomes if the monster s power is strictly greater than the hero s power the hero retreats from the dungeon The current day ends otherwise the monster is defeated After defeating a monster the hero either continues fighting with the next monster or leaves the dungeon He leaves the dungeon either if he has already defeated the number of monsters equal to his endurance during this day so the th hero cannot defeat more than monsters during each day or if all monsters are defeated otherwise he fights with the next monster When the hero leaves the dungeon the current day ends Your goal is to defeat the last monster What is the minimum number of days that you need to achieve your goal Each day you have to use exactly one hero it is possible that some heroes don t fight the monsters at all Each hero can be used arbitrary number of times ,At first lets precalc array is equal to maximum hero power whose endurance is greater than or equal to Now let s notice that every day it s profitable for as to kill as many monster as possible Remains to understand how to calculate it Suppose that we already killed monsters If then answer is because we can t kill the th monster Otherwise we can kill at least monsters All we have to do it increase the value until conditions holds After calculating the value we just move to the next day with killed monsters ,1
112,Polycarp has just attempted to pass the driving test He ran over the straight road with the signs of four types speed limit this sign comes with a positive integer number maximal speed of the car after the sign cancel the action of the previous sign of this type overtake is allowed this sign means that after some car meets it it can overtake any other car no speed limit this sign cancels speed limit if any car can move with arbitrary speed after this sign no overtake allowed some car can t overtake any other car after this sign Polycarp goes past the signs consequentially each new sign cancels the action of all the previous signs of it s kind speed limit overtake It is possible that two or more no overtake allowed signs go one after another with zero overtake is allowed signs between them It works with no speed limit and overtake is allowed signs as well In the beginning of the ride overtake is allowed and there is no speed limit You are given the sequence of events in chronological order events which happened to Polycarp during the ride There are events of following types Polycarp changes the speed of his car to specified this event comes with a positive integer number Polycarp s car overtakes the other car Polycarp s car goes past the speed limit sign this sign comes with a positive integer Polycarp s car goes past the overtake is allowed sign Polycarp s car goes past the no speed limit Polycarp s car goes past the no overtake allowed It is guaranteed that the first event in chronological order is the event of type Polycarp changed the speed of his car to specified After the exam Polycarp can justify his rule violations by telling the driving instructor that he just didn t notice some of the signs What is the minimal number of signs Polycarp should say he didn t notice so that he would make no rule violations from his point of view ,First of all let s find the resulting position for each character of the string It s easy to see that we don t need to swap equal adjacent characters it changes nothing so the first character in the original string is the first character in the resulting string the second character in the original string is the second character in the resulting string and so on Now let s build a permutation of elements where is the resulting position of the element that was on position in the original string For example for the string this permutation will be In one operation we may swap two elements in this permutation and our goal is to sort it since each character of the string has its own required position and when for every the condition holds each character is on the position it should be The required number of swaps of adjacent elements to sort a permutation is exactly the number of inversions in it since each swap changes the number of inversions by and this number can be calculated using many different techniques for example mergesort tree or Fenwick tree ,0
113,You are given an array consisting of integers Your task is to determine if has some of length at least that is a palindrome Recall that an array is called a of the array if can be obtained by removing some possibly zero elements from not necessarily consecutive without changing the order of remaining elements For example and are subsequences of but and are not Also recall that a palindrome is an array that reads the same backward as forward In other words the array of length is the palindrome if for all from to For example arrays and are palindromes but arrays and are not You have to answer independent test cases ,The first observation is that we can always try to find the palindrome of length otherwise we can remove some characters from the middle until its length becomes The second observation is that the palindrome of length is two equal characters and some other maybe the same character between them Now there are two ways find the pair of equal non adjacent characters in or do it in for each character we only need to consider its left and right occurrences ,1
114,It is winter now and Max decided it s about time he watered the garden The garden can be represented as consecutive garden beds numbered from to beds contain water taps th tap is located in the bed which if turned on start delivering water to neighbouring beds If the tap on the bed is turned on then after one second has passed the bed will be watered after two seconds have passed the beds from the segment will be watered if they exist after seconds have passed the beds from the segment will be watered if they exist The garden from test White colour denotes a garden bed without a tap red colour a garden bed with a tap The garden from test after seconds have passed after turning on the tap White colour denotes an unwatered garden bed blue colour a watered bed Max wants to and now he wonders what is the minimum number of seconds that have to pass after he turns on some taps until the whole garden is watered Help him to find the answer ,Let s divide the solution into two parts firstly check the closest zero to the left and then the closest zero to the right After that we can take minimum of these numbers Initialize distance with infinity Iterate over array from left to right If value in current position is then set distance to otherwise increase distance by On each step write value of distance to the answer array Do the same thing but going from right to left This will find closest zero to the right Now you should write minimum of current value of distance and value that s already in answer array Finally you should retrieve the answer from distances Overall complexity ,0
115,You are given segments on a coordinate line each endpoint of every segment has integer coordinates Some segments can degenerate to points Segments can intersect with each other be nested in each other or even coincide Your task is the following for every calculate the number of points with integer coordinates such that the number of segments that cover these points equals A segment with endpoints and covers point if and only if ,This problem with small coordinates can be solved using partial sums and some easy counting Let s carry an array where will be equal to the number of segments that cover the point with coordinate How to calculate in For each segment let s add to and to Now build on this array prefix sums and notice that equals the number of segments that cover the point with coordinate Then will be equal to All the answers can be calculated in in total So the total complexity of this solution is But in our problem it is too slow to build an entire array So what should we do It is obvious that if any coordinate is not equals some or some then So we do not need carry all the positions explicitly Let s carry all and in some logarithmic data structure or let s use the coordinate compression method The coordinate compression method allows us to transform the set of big sparse objects to the set of small compressed objects maintaining the relative order In our problems let s make the following things push all and in vector sort this vector keep only unique values and then use the position of elements in vector instead of original value any position can be found in by binary search or standard methods as in C So the first part of the solution works in Answer can be calculated using almost the same approach as in solution to this problem with small coordinates But now we know that between two adjacent elements and there is exactly points with answer equals to So if we will iterate over all pairs of the adjacent elements and and add to the we will calculate all the answers in So the total complexity of the solution is ,1
116,You are given an array An array is constructed in such a way that it consists of integers and for each there are exactly occurrences of integer in So the number of elements in is exactly Let s define for such array the value as In other words is the total sum of distances between all pairs of equal elements Your task is to calculate the maximum possible value of and the number of arrays yielding the maximum possible value of Two arrays are considered different if elements at some position differ ,Firstly let s prove that at first and last positions of the most frequent elements should be placed but not necessary the same WLOG let s prove that for any By contradiction let s be the smallest index such that What happens if we swap them Since is the first such index then there are no for so contribution of will increase by exactly From the other side contribution of consists of two parts pairs with elements from and from For all elements from decrease will be equal to and from elements in So the total decrease after moving to position equal to The total difference in such case is equal to So our placement is not optimal contradiction Let s suggest that there is exactly one with maximum According to what we proved earlier both and must be equal to Contribution of the first and last elements will be equal to for pair and for each element with we add for pairs and So the total contribution of is equal to Note that this contribution is independent of positions of other in the array so that s why we can cut first and last elements of and solve the task recursively Unfortunately in the initial task we may have several with maximum But we in the similar manner can prove that the first and last elements should be some permutation of Now let s prove that any permutation of first and last elements is optimal Suppose positions of are and Then the contribution of is equal to The total contribution of all is This contribution doesn t depend on chosen and so any permutation of first elements and any permutation of last elements give optimal answer As a result the algorithm is following Find all maximums in If then any permutation of remaining elements has there are such permutations Otherwise add to the total balance and multiply the number of variants by Cut prefix and suffix by making for each obviously and repeat the whole process We can implement the algorithm fast if we keep the number of equal to each from to So the total complexity is ,1
117,You are given an array consisting of integers and queries to it th query is denoted by two integers and For each query you have to find integer that occurs in the subarray of from index to index a subarray is a contiguous subsegment of an array For example if then for query the subarray we are interested in is and possible answers are and for query the subarray we are interested in is and there is no such element that occurs exactly once Can you answer all of the queries ,Suppose all queries have the same right border Then the answer for the query can be some integer such that the last occurence of on the prefix of the array is inside the segment but the second to last occurence is outside the segment or even does not exist More formally let be the maximum index such that and or if there is no such the answer to the query is some number such that and and is the rightmost occurence of in the segment For a fixed right border we can build a segment tree which for every index such that is the rightmost occurence of on stores the value of and if we query minimum on the segment in such tree we can try to find the answer Let the position of minimum be If then can be the answer otherwise there is no answer But this is too slow since we can t afford to build a segment tree for every possible value of There are two methods how to deal with this problem you may sort all queries by their right borders and maintain the segment tree while shifting the right border when going from to we have to update the values in the positions and or we may use a persistent segment tree and get an online solution We tried to eliminate solutions using Mo s algorithm but in fact it s possible to squeeze some implementations of it into TL There are two optimizations that might help there When dividing the elements into blocks we may sort the first block in the ascending order of right borders the second in descending the third in ascending order again and so on And also it s possible to obtain a Mo based solution with worst case complexity of if we maintain the set of possible answers using sqrt decomposition on it ,1
118,New Year is coming and you are excited to know how many minutes remain before the New Year You know that currently the clock shows hours and minutes where and Your task is to find the number of minutes before the New Year You know that New Year comes when the clock shows hours and minutes You have to answer independent test cases ,In this problem we just need to print ,1
119,Consider a hallway which can be represented as the matrix with rows and columns Let s denote the cell on the intersection of the th row and the th column as The distance between the cells and is There is a cleaning robot in the cell Some cells of the hallway are clean other cells are dirty the cell with the robot is clean You want to clean the hallway so you are going to launch the robot to do this After the robot is launched it works as follows While at least one cell is dirty the robot chooses among those which are dirty moves there and cleans it so the cell is no longer dirty After cleaning a cell the robot again finds the closest dirty cell and so on This process repeats until the whole hallway is clean However there is a critical bug in the robot s program If at some moment there are multiple closest to the robot s current position dirty cells the robot malfunctions You want to clean the hallway in such a way that the robot doesn t malfunction you can clean some possibly zero of the dirty cells yourself However you don t want to do too much dirty work yourself while you have this nice smart yet buggy robot to do this Note that you cannot make a clean cell dirty Calculate the maximum possible number of cells you can leave dirty before launching the robot so that it doesn t malfunction ,Why did the author choose the width of the hallway to be only Well in that case you can show that the robot will never move to the left while cleaning That is not true on width already When does the robot break Let the robot currently be in the cell indexed and the next column with a dirty cell be possibly The robot breaks only if both and are dirty That helps us to do a dynamic programming solution Since we can only care about next columns we would want to have some the largest number of dirty cells we can leave to the robot if we processed the first columns of the hallway and are currently standing in the th row of the th column Maybe with some additional states of the current or the next columns We want the dp to maintain the invariant that everything to the left of the th column is cleaned in such a way the robot can reach the cell We can choose when to fix the th column either maintain it being correct prior to entering the state or handling it in the transition to the next one I chose the former option There probably exists a million different dps that work I ll describe the one I did Let be the largest number of dirty cells that we can leave to the robot if we fixed which of the dirty cells in the first columns inclusive are cleaned by hand the robot reaches the cell from the left is true if the cell in the opposite row of the th column is dirty The transitions handle what to do with the dirty cells in the st column and where the robot goes based on that In particular there are the following transitions if is true then we have to clean the cell and the robot will move into otherwise the robot breaks from having two options if is false then let s say that the robot doesn t break immediately but moves into the next column in a unique way it moves horizontally first then possibly vertically we can leave the next column as is and the robot will move into if the cell is clean or if it s dirty if is false then we can clean the cell and the robot will move into Since we maintained the invariant that the th column is valid we can update the answer from all four states in the last column Overall complexity ,1
120,Recently Ivan noticed an array while debugging his code Now Ivan can t remember this array but the bug he was trying to fix didn t go away so Ivan thinks that the data from this array might help him to reproduce the bug Ivan clearly remembers that there were elements in the array and each element was not less than and not greater than Also he remembers facts about the array There are two types of facts that Ivan remembers for each such that for each such that Also Ivan thinks that this array was a permutation but he is not so sure about it He wants to restore some array that corresponds to the facts that he remembers and is very similar to permutation Formally Ivan has denoted the of array as follows where is the number of occurences of in the array Help Ivan to determine minimum possible of the array that corresponds to the facts ,There will be one character left in the end so we have to delete all the characters going before and after it That is delete some prefix and suffix Since we always delete some substring of length we can only delete the prefix and suffix of even length it means the answer is in the case when there is an odd position in with the character and otherwise ,0
121,You are given a string You have to reverse it that is the first letter should become equal to the last letter before the reversal the second letter should become equal to the second to last letter before the reversal and so on For example if your goal is to reverse the string you should get the string To accomplish your goal you can swap the Your task is to calculate the minimum number of swaps you have to perform to reverse the given string ,Basically what does the matrix being palindromic imply For each values in cells and are equal all zero indexed You can easily prove it by reversing the order of rows or columns and checking the overlapping cells in them Thus all cells can be split up into equivalence classes The even case is simple all classes have size The odd case has classes of sizes and Let s fill the classes one by one Obviously the order between the classes of the same size doesn t matter I claim that filling the classes in order in sizes construct the answer if any exists The key observation is that each next size is divisible by the previous one The implementation can come in lots of different forms and complexities Mine works in you can refer to it in attachment ,0
122,It is winter now and Max decided it s about time he watered the garden The garden can be represented as consecutive garden beds numbered from to beds contain water taps th tap is located in the bed which if turned on start delivering water to neighbouring beds If the tap on the bed is turned on then after one second has passed the bed will be watered after two seconds have passed the beds from the segment will be watered if they exist after seconds have passed the beds from the segment will be watered if they exist The garden from test White colour denotes a garden bed without a tap red colour a garden bed with a tap The garden from test after seconds have passed after turning on the tap White colour denotes an unwatered garden bed blue colour a watered bed Max wants to and now he wonders what is the minimum number of seconds that have to pass after he turns on some taps until the whole garden is watered Help him to find the answer ,The answer is the maximal value among the following values to cover all water beds within some segment to cover water beds before the first tap to cover all water beds after the last tap ,1
123,Recently Paul and Mary have found a new favorite sequence of integers They want to paint it using pieces of chalk of colors The coloring of a sequence is called if the following conditions are met each element of the sequence is either painted in one of colors or isn t painted each two elements which are painted in the same color are different i e there s no two equal values painted in the same color let s calculate for each of colors the number of elements painted in the color all calculated numbers must be equal the total number of painted elements of the sequence is the among all colorings of the sequence which meet the first three conditions E g consider a sequence and One of the wonderful colorings of the sequence is shown in the figure Help Paul and Mary to find a wonderful coloring of a given sequence ,Since we must use exactly colors each element that occurs in the sequence may have no more than painted occurrences for each element its occurrences where is the number of all its occurrences in the sequence Let be a sequence of all elements that occur in the sequence but in the sequence they will occur only once Let s create a indexed array in which we will add indices of occurrences of in the sequence then the selected occurrences of and so on till Currently is a set of occurrences which wonderful coloring is a wonderful coloring of the whole sequence because if we want to paint an occurrence outside we can do it only by selecting an occurrence of the same element in which we will not paint so that no more than occurrences will be painted We must use exactly colors and paint for each color an equal number of occurrences hence if we want to paint all occurrences from we must remove from it the minimum number of occurrences so that the size of the array will be divided by i e remove the number of occurrences equal to the remainder of dividing the size of by We can remove any occurrences for example let s delete it from the suffix of Currently we can paint all occurrences from using the following rule the occurrence we must paint in the color with a number where takes the remainder of dividing the left operand by the right operand So all occurrences from will be painted and all colors will be used Since all occurrences of one element belong to one subsegment of and their number isn t greater than they will be painted in different colors It may be so that the array before painting will be empty In this case the wonderful coloring of doesn t contain any painted element ,1
124,The next lecture in a high school requires two topics to be discussed The th topic is interesting by units for the teacher and by units for the students The pair of topics and is called if i e it is more interesting for the teacher Your task is to find the number of pairs of topics ,The naive approach is to iterate over and reverse the subsegment of the array and calculate the answer But this solution is too slow and works in Instead we can iterate over the center of the reversed segment and its length If the current segment is and we want to go to then the answer for the subsegment will increase by It remains to add the answer for and but without reversion this is easy to do if you pre calculate the prefix sums of the values ,0
125,Let be arbitrary binary tree tree every vertex of which has no more than two children Given tree is rooted so there exists only one vertex which doesn t have a parent it s the root of a tree Every vertex has an integer number written on it Following algorithm is run on every value from the tree Set pointer to the root of a tree Return success if the value in the current vertex is equal to the number you are looking for Go to the left child of the vertex if the value in the current vertex is greater than the number you are looking for Go to the right child of the vertex if the value in the current vertex is less than the number you are looking for Return fail if you try to go to the vertex that doesn t exist Here is the pseudo code of the described algorithm bool find TreeNode t int x if t null return false if t value x return true if x t value return find t left x else return find t right x find root x The described algorithm works correctly if the tree is binary search tree i e for each node the values of left subtree are less than the value in the node the values of right subtree are greater than the value in the node But it can return invalid result if tree is not a binary search tree Since the given tree is not necessarily a binary search tree not all numbers can be found this way Your task is to calculate how many times the search will fail being running on every value from the tree If the tree has multiple vertices with the same values on them then you should run algorithm on every one of them separately ,Let s firstly consider tree with only distinct values in its nodes Then value will be reached if and only if all the jumps to the left children on the path from the root were done from the vertices with values greater than the current one and all the jumps to the right children on the path from the root were done from the vertices with values less than the current one Thus let s run dfs from the root and maintain maximal transition to the left child on current path and minimal transition to the right child on current path If the value of current node is greater than left bound and less than right bound then it will be found Now let s return to the original problem Notice that transitions and comparations won t change Store every found value in set and just calculate how many values of vertices isn t present there Overall complexity ,1
126,Let s call some square matrix with integer values in its cells if it doesn t change after the order of rows is reversed and it doesn t change after the order of columns is reversed For example the following matrices are The following matrices are because they change after the order of rows is reversed The following matrices are because they change after the order of columns is reversed You are given integers Put them into a matrix of rows and columns so that each number is used exactly once each cell contains exactly one number and the resulting matrix is If there are multiple answers print any If there is no solution print ,Let s consider a problem where you can subtract the weight of any edge not only the maximum one that belong to the current path and similarly add the weight of any edge not only the minimum one that belong to the current path To solve that problem we can build a new graph where the node can be represented as the following triple node from the initial graph flag that some edge has been subtracted flag that some edge has been added Now we can run Dijkstra s algorithm to find the length of the shortest paths in such a graph We can notice that on the shortest path the maximum weight edge was subtracted and the minimum weight edge was added Let s assume that this is not the case and an edge of non maximum weight was subtracted from the path then we can reduce the length of the path by choosing an edge of maximum weight But this is not possible because we considered the shortest path Similarly it is proved that the added edge was of minimal weight Using this fact it is not difficult to notice that by solving the modified problem we have solved the original one ,0
127,You are given a binary string recall that a string is binary if each character is either or Let be the decimal representation of integer written in binary form possibly with leading zeroes For example and The substring is good if For example string has good substrings and Your task is to calculate the number of good substrings of string You have to answer independent queries ,Note that whichever order you choose the total time will always contain all initial health in other words any answer will contain as its part So the lower the sum of you will add to the answer the better Look at some monster If you kill it while it has both left and right neighbor it will add to the answer If it is the first or the last in the row it will add just And if it is the last monster it will add There can be only one last monster so any other will add at least to the answer And for any chosen last monster you can find the order that gives exactly for all other monsters For example you can firstly kill monsters then and finally moster In other words if the last monster is the th one the total answer will be equal to Since we need to minimize answer we can choose monster with maximum So the answer is ,0
128,You are given a string consisting of lowercase Latin letters and an integer number Let s define a substring of some string with indices from to as Your task is to construct such string of minimum possible length that there are exactly positions such that In other words your task is to construct such string of minimum possible length that there are exactly substrings of equal to It is guaranteed that the answer is always unique ,Let s carry the current answer as the last position we re checked as and the number of occurrences as Initially the answer is is and is 0 indexed We don t need to check the position because there is the beginning of the occurrence of at this position Also is by the same reason Let s repeat the following algorithm while if where ans is the length of the answer let s add to the answer increase and by In the other case let s check if there is a prefix of starting from If it is let be its length Then we need to add the suffix of starting from till the end of increase and by If there is no prefix of starting from the we just increase The other idea is the following we have to find the period of the string Let this period will be Then the answer is repeated times and The period of the string is the minimum prefix of this string such that we can repeat this prefix infinite number of times so the prefix of this infinite string will be For example the period of the string is the period of the string is and the period of the string is The period of the string can be found using prefix function of the string or in naively ,1
129,Ivan plays an old action game called Heretic He s stuck on one of the final levels of this game so he needs some help with killing the monsters The main part of the level is a large corridor so large and narrow that it can be represented as an infinite coordinate line The corridor is divided into two parts let s assume that the point is where these parts meet The right part of the corridor is filled with monsters for each monster its initial coordinate is given and since all monsters are in the right part every is positive The left part of the corridor is filled with crusher traps If some monster enters the left part of the corridor or the origin so its current coordinate becomes to it gets instantly killed by a trap The main weapon Ivan uses to kill the monsters is the Phoenix Rod It can launch a missile that explodes upon impact obliterating every monster caught in the explosion and throwing all other monsters away from the epicenter Formally suppose that Ivan launches a missile so that it explodes in the point Then every monster is either killed by explosion or pushed away Let some monster s current coordinate be then if then the monster is killed if then the monster is pushed units to the left so its current coordinate becomes if then the monster is pushed units to the right so its current coordinate becomes Ivan is going to kill the monsters as follows choose some integer point and launch a missile into that point then wait until it explodes and all the monsters which are pushed to the left part of the corridor are killed by crusher traps then if at least one monster is still alive choose another integer point probably the one that was already used and launch a missile there and so on What is the minimum number of missiles Ivan has to launch in order to kill all of the monsters You may assume that every time Ivan fires the Phoenix Rod he chooses the impact point optimally You have to answer independent queries ,Notice the following fact it s never optimal to fire a missile at such a position that there are monsters to the right of it That suggests the next solution sort the positions leave only the unique ones and process to shoot at the rightmost alive monster until every monster is dead Position of some monster after shots are made is the original position minus because the monster could only be pushed to the left Overall complexity ,1
130,Let s suppose you have an array a stack initially empty and an array also initially empty You may perform the following operations until both and are empty Take the first element of push it into and remove it from if is not empty Take the top element from append it to the end of array and remove it from if is not empty You can perform these operations in arbitrary order If there exists a way to perform the operations such that array is sorted in non descending order in the end then array is called For example is because will be sorted if we perform the following operations Remove from and push it into Remove from and push it into Remove from and append it to the end of Remove from and push it into Remove from and append it to the end of Remove from and append it to the end of After all these operations so is is not You are given first elements of some permutation of size recall that a permutation of size is an array of size where each integer from to occurs exactly once You have to restore the remaining elements of this permutation so it is If there are multiple answers choose the answer such that is lexicographically maximal an array is lexicographically greater than an array iff there exists some integer such that for every and Print the lexicographically maximal permutation you can obtain If there exists no answer then output ,Let s denote as some stack sortable array which contains all integers from to inclusive We can see that if the first element of is then where by we mean concatenation of arrays It s easy to prove this fact if the first element is then we have to store it in the stack until we have processed all elements less than so in no element that is greater than can precede any element less than This way we can represent the prefix we are given For example if and prefix is then we can rewrite the permutation we have to obtain as So the unknown suffix is a contatenation of some stack sortable arrays It s easy to see that if an array is sorted in non increasing order then it is stack sortable So we can replace each block with an array If during rewriting the given prefix we obtain some impossible situation for example when and given prefix is we have and can t be the beginning of then answer is ,1
131,New Year is getting near So it s time to change handles on codeforces Mishka wants to change his handle but in such a way that people would not forget who he is To make it work he only allowed to change letters case More formally during handle change he can choose any segment of his handle and apply or to all letters of his handle on this segment more fomally replace all uppercase letters with corresponding lowercase or vice versa The length is fixed for all changes Because it is not allowed to change codeforces handle too often Mishka can perform at most such operations What is the value of where is the number of lowercase letters and is the number of uppercase letters can be obtained after optimal sequence of changes ,Let s simplify the problem a bit we need either to minimize the number of lowercase letters or to minimize the number of uppercase letters Both variants can be described by the following model we have a binary array a where a i 0 if s i is in the correct case and a i 1 otherwise We can do at most k operations set 0 on the segment i i l 1 and we d like to minimize the total sum of a At first let s start with a solution which is pretty slow but correct Let dp len c be the minimum sum of the prefix a 0 dots a len 1 such that c operations was already applied on it In order to calculate this dp somehow efficiently we need to understand that it s optimal to avoid intersections of segments of applied operations so we can further specify the state of dp with the following all c applied operations have their right borders le len 1 It s easy to specify the transitions we either apply set operation on len len l 1 and relax dp len l c 1 with dp len c or not and relax d len 1 c with dp len c a len It still O nk so we d like to optimize it more and we can do it using the lambda optimization i e aliens trick Here we will try to describe what aliens trick is and the features of its application on the discrete calculations In general aliens trick allows you to get rid of the restriction on the total number of operations applied to the array sometimes it s the number of segments in the partition of the array by replacing it with the binary search of the value lambda connected to it The lambda is the cost of using the operation or the cost to use one more segment in the partition In other words we can use as many operations as we want but we need to pay for each of them Often we can calculate the answer without the restriction faster The main restriction of the using this dp optimization is the following in case of the discrete model consider the answer ans c for the fixed c or dp n c If we look at the function ans c it should be somewhat convex i e ans c 1 ans c ge ans c ans c 1 or sometimes ans c ans c 1 ge ans c 1 ans c for all possible c Let s look at the answers of the modified version of the problem with cost lambda for each used operation as function res lambda c It s easy to prove that res lambda c ans c lambda c and it s also somewhat convex for a fixed lambda as a sum of convex functions But more important it has the following property let c lambda be the position where the res lambda c is the minimum possible It can be proven from the convex property that c lambda ge c lambda 1 This property leads to the solution binary search lambda while keeping track of the c lambda i e find the minimum lambda that c lambda le k But there are several problems related to the discrete origin of the problem The c lambda is not unique In general case there is a segment cl lambda cr lambda where the minimum res lambda c can be achieved But there is still a property that cl lambda ge cl lambda 1 and cr lambda ge cr lambda 1 So we need to ensure that we will always find either minimum such c lambda or maximum such c lambda The second problem comes from the first one There are situations when c lambda c lambda eps 1 It creates a problem in the next situation suppose the binary search finished with lambda opt the c lambda opt 1 k and c lambda opt k But we need to use exactly k operations what to do Using float values will not help so we don t need them so we ll use usual integer bs Suppose we minimized the c lambda opt then we can show that k in cl lambda opt cr lambda opt or in other words res lambda opt k res lambda opt c lambda opt So we can claim that we calculated the value not only for c lambda opt but also for k In the end if we can efficiently calculate c lambda and res lambda c lambda for the fixed lambda then we can binary search lambda opt extract res lambda opt c lambda opt and claim that the dp n k res lambda opt c lambda opt lambda opt k Finally let s discuss how to calculate c lambda and res lambda c lambda for a fixed lambda Since res lambda c lambda is just a minimum cost and the c lambda is the minimum number of operations with such cost We can calculate it by simplifying our starting dp Remember the cost is calculated in a next way for each remaining 1 in a we pay 1 and for each used operation we pay lambda Let d len cost len cnt len where cost len is minimum cost on the prefix of length len and cnt len is minimum number of operations cost len can be achieved Then the transitions are almost the same we either let a len be and relax d pos 1 with cost len a len cnt len or start new operation and relax d pos len with cost len lambda cnt len 1 The result is pair d n Some additional information we should carefully choose the borders of the binary search we should choose the left border so it s optimal to use operation whenever we can usually 0 or 1 And we should choose the right border so it s never optimal to use even one operation usually more than the maximum possible answer The total complexity is O n log n P S We don t have the strict proof that the ans c is convex but we have faith and stress We d appreciate it if someone would share the proof in the comment section ,1
132,You are playing a computer game To pass the current level you have to kill a big horde of monsters In this horde there are monsters standing in the row numbered from to The th monster has health and a special Death s Blessing spell of strength attached to it You are going to kill all of them It takes exactly seconds to kill a monster with health When the th monster dies it casts its spell that increases the health of its by the neighbors of the th monster in the row are the monsters on places and The first and the last monsters have only one neighbor each After each monster is killed the row shrinks so its former neighbors become adjacent to each other so if one of them dies the other one is affected by its spell For example imagine a situation with monsters with health and spells One of the ways to get rid of the monsters is shown below As a result we can kill all monsters in seconds Note that it s only an example and may not be the fastest way to get rid of the monsters What is the minimum time required to kill all monsters in the row ,Note that whichever order you choose the total time will always contain all initial health in other words any answer will contain as its part So the lower the sum of you will add to the answer the better Look at some monster If you kill it while it has both left and right neighbor it will add to the answer If it is the first or the last in the row it will add just And if it is the last monster it will add There can be only one last monster so any other will add at least to the answer And for any chosen last monster you can find the order that gives exactly for all other monsters For example you can firstly kill monsters then and finally moster In other words if the last monster is the th one the total answer will be equal to Since we need to minimize answer we can choose monster with maximum So the answer is ,1
133, A permutation of length is an array of integers such that every integer from to appears in it exactly once An element of permutation is reachable from element if or or and so on The of a permutation is defined as follows firstly we have a permutation all elements of which are and an empty list Then we do the following while there is at least one element in we find the leftmost such element list all elements that are reachable from it mark all of these elements then cyclically shift the list of those elements so that the maximum appears at the first position and add this list of After all elements are marked is the result of this decomposition For example if we want to build a decomposition of we do the following initially bold elements are marked the leftmost unmarked element is and are reachable from it so the list we want to shift is there is no need to shift it since maximum is already the first element the leftmost unmarked element is the list of reachable elements is the maximum is already the first element so there s no need to shift it the leftmost unmarked element is the list of reachable elements is we have to shift it so it becomes all elements are marked so is the result The of a permutation is defined as follows we build the decomposition of this permutation then we sort all lists in decomposition in ascending order of the first elements we don t swap the elements in these lists only the lists themselves then we concatenate the lists into one list which becomes a new permutation For example the of is built as follows the decomposition is after sorting the decomposition it becomes is the result of the transformation We call a permutation if the result of its transformation is the same as the permutation itself For example is a good permutation and is bad since the result of transformation is Your task is the following given and find the th lexicographically good permutation of length ,Let s calculate cycle n the number of permutations of length n which have a maximum at the position 1 and consist of exactly one cycle Each good permutation can be divided into such blocks so we ll need this value later It is easy to notice that cycle n n 2 Let s calculate the following dynamic programming dp i the number of good permutations consisting of elements i n To calculate dp i let s iterate over j the maximum element of the first block it determines the length of this block j i 1 dp i sum j i n dp j 1 cdot cycle j i 1 Now let s use the standard method of lexicographic recovery We will iterate over which element to put next it immediately determines the size of the new block and all the elements in it If the number of permutations starting with such block is at least k then you need to restore this block entirely and reduce the task to the one without this block Otherwise you need to subtract the number of permutations starting on such block from k and proceed to the next option for the block We will also use lexicographic recovery to restore the block You must carefully maintain the current block so that it consists of exactly one cycle To do this you can use DSU or explicitly check for a cycle ,1
134,Mishka s favourite experimental indie band has recently dropped a new album Songs of that album share one gimmick Each name is one of the following types a single lowercase Latin letter name with a single lowercase Latin letter appended to its end Songs are numbered from to It s guaranteed that the first song is always of type Vova is rather interested in the new album but he really doesn t have the time to listen to it entirely Thus he asks Mishka some questions about it to determine if some song is worth listening to Questions have the following format count the number of occurrences of string in the name of the th song of the album as a continuous substring consists only of lowercase Latin letters Mishka doesn t question the purpose of that information yet he struggles to provide it Can you please help Mishka answer all Vova s questions ,There is a common approach for the problem you are given a lot of strings and texts count the number of occurences of the strings in the texts build an Aho Corasick automaton on the given strings and somehow process the texts with it Let s see if it can handle this problem The names of the songs can be represented as a tree We may build an Aho Corasick on the strings given in the queries then try to input the names of the album into the automaton character by character with DFS on the aforementioned tree feeding a character to the automaton when we enter a node and reverting the automaton to the previous state when we leave that node Suppose that when we are in the vertex corresponding to the th song the automaton is in state If is a terminal state corresponding to some string from the queries it means that the string from the query is a suffix of the th song But some other strings can also be the suffixes of the same song to find all such strings we can start ascending from the state to the root of Aho Corasick automaton using suffix links or dictionary links Since suffix links can be represented as the edges of some rooted tree then we can build some data structure on this tree that allows adding an integer to all vertices on the path from the root to the given vertex for example we can use Fenwick tree over Euler tour of the tree Then to check whether some string from the query is a suffix of the song we may add to all vertices on the path to state and then check the value in the state corresponding to Okay what about counting the occurences of in Let s consider the path from the root to in the song tree Every vertex on this path corresponds to some prefix of the song so we can add on the path to state corresponding to some prefix and then extract the answer from the state corresponding to In fact that s all we have to do to obtain a solution Build an automaton on strings from queries a tree of suffix links over this automaton and a data structure on this tree for each vertex of the song tree store all queries to it Then run a DFS on the song tree When we enter some vertex input the corresponding character into the automaton and add to all states from the root of suffix link tree to the current state when we have to process queries to the current vertex extract the values from the data structure and when we leave a vertex subtract from all states from the root of suffix link tree to the current state and revert to the previous state This solution has complexity of where is the total length of all strings in the input ,1
135,You have rectangles the th rectangle has height and width You are asked queries of the form For each query output the total area of rectangles you own that a rectangle of height and width while also a rectangle of height and width In other words print for such that and Also note that you rotate rectangles Please note that the answer for some test cases won t fit into 32 bit integer type so you should use at least 64 bit integer type in your programming language like for C ,Consider the 2D array with for all Increase by if there is an rectangle in the input Now for each query we need to find the sum of all in a rectangle with lower left corner at and upper right corner at This is the standard problem that can be solved with 2D prefix sums The time complexity is per testcase ,1
136,You are given a string You have to reverse it that is the first letter should become equal to the last letter before the reversal the second letter should become equal to the second to last letter before the reversal and so on For example if your goal is to reverse the string you should get the string To accomplish your goal you can swap the Your task is to calculate the minimum number of swaps you have to perform to reverse the given string ,First of all let s find the resulting position for each character of the string It s easy to see that we don t need to swap equal adjacent characters it changes nothing so the first character in the original string is the first character in the resulting string the second character in the original string is the second character in the resulting string and so on Now let s build a permutation of elements where is the resulting position of the element that was on position in the original string For example for the string this permutation will be In one operation we may swap two elements in this permutation and our goal is to sort it since each character of the string has its own required position and when for every the condition holds each character is on the position it should be The required number of swaps of adjacent elements to sort a permutation is exactly the number of inversions in it since each swap changes the number of inversions by and this number can be calculated using many different techniques for example mergesort tree or Fenwick tree ,1
137,On an grid some horizontal rows have been painted red and some vertical columns have been painted blue in some order The stripes are drawn sequentially one after the other When the stripe is drawn it repaints all the cells through which it passes Determine which color was used last ,Note that if a stripe is painted last then the entire stripe appears in the final picture because no other stripe is covering it Since rows are only painted red and columns are only painted blue we can just check if any row contains 8 s If there is such a row then red was painted last otherwise blue was painted last ,1
138, year in Berland is such a year that its number can be represented as where and are non negative integer numbers For example if and then the years and are and year isn t as there is no such representation for it Such interval of years that there are no years in it is called You should write a program which will find maximum length of which starts no earlier than the year and ends no later than the year If all years in the interval are then the answer is ,Firstly consider the field in indexation Suppose that the cell has some fixed height Let it be Then we can determine what should be the height of the cell as In fact it does not matter which way we choose we actually need only the number of moves to reach the cell and the height of the cell Then when the height of the cell is fixed we can solve the problem with the following dynamic programming is the minimum number of operations we need to reach the cell from the cell Initially all values except Then can be calculated as But one more thing if then this value of is incorrect and we cannot use it We also can t update from the incorrect values The answer for the problem with the fixed height of the cell is only when is correct and This part can be calculated in But if we iterate over all possible heights our solution obvious will get time limit exceeded verdict Now we can notice one important fact in the optimal answer the height of some cell remains unchanged Let this cell be Then we can restore the height of the cell as and run our quadratic dynamic programming to find the answer for this height Time complexity ,0
139, A permutation of length is an array of integers such that every integer from to appears in it exactly once An element of permutation is reachable from element if or or and so on The of a permutation is defined as follows firstly we have a permutation all elements of which are and an empty list Then we do the following while there is at least one element in we find the leftmost such element list all elements that are reachable from it mark all of these elements then cyclically shift the list of those elements so that the maximum appears at the first position and add this list of After all elements are marked is the result of this decomposition For example if we want to build a decomposition of we do the following initially bold elements are marked the leftmost unmarked element is and are reachable from it so the list we want to shift is there is no need to shift it since maximum is already the first element the leftmost unmarked element is the list of reachable elements is the maximum is already the first element so there s no need to shift it the leftmost unmarked element is the list of reachable elements is we have to shift it so it becomes all elements are marked so is the result The of a permutation is defined as follows we build the decomposition of this permutation then we sort all lists in decomposition in ascending order of the first elements we don t swap the elements in these lists only the lists themselves then we concatenate the lists into one list which becomes a new permutation For example the of is built as follows the decomposition is after sorting the decomposition it becomes is the result of the transformation We call a permutation if the result of its transformation is the same as the permutation itself For example is a good permutation and is bad since the result of transformation is Your task is the following given and find the th lexicographically good permutation of length ,Let s solve the problem using dynamic programming Let be the maximum total beauty of pictures if Vova is at the th picture now the number of remaining reposts is and Vova reposted the th picture Initially and all other values of are Let s learn to do some transitions to calculate this dynamic programming What is the way to do it Let s iterate over the position of the previously reposted picture and try to update using previously calculated values Obviously this position can be from to So let s iterate over the position let it be and if we need one more repost to repost the th picture is not then try to update pictures are indexed So where can we find the answer The answer is If this value is then the answer is Overall complexity is ,0
140,We define the of an array as You are given a tree consisting of vertices Each vertex has an integer written on it We define the value of the path from vertex to vertex as follows consider all vertices appearing on the path from to write down all the numbers written on these vertices in the order they appear on the path and compute the of the resulting sequence Your task is to calculate the maximum value over all paths in the tree ,If all the piranhas have the same size then the answer is Otherwise there are at least two different sizes of piranhas and the answer always exists Claim that the answer is such a piranha with the maximum size that one of the adjacent piranhas has the size less than a maximum Why is it true and why the answer always exists First if the piranha with the maximum size eats some other piranha it becomes the only maximum in the array and can eat all other piranhas Why is there always such a pair of piranhas Let s change our array a bit replace every maximum with and every non maximum with There is always some pair or pair in such array because we have at least two different elements ,0
141,You are given a bipartite graph with vertices in the first part vertices in the second part and edges The maximum matching in this graph is the maximum possible by size subset of edges of this graph such that no vertex is incident to more than one chosen edge You have to process two types of queries to this graph remove the number of vertices from this graph so that the size of the maximum matching gets reduced and print the vertices that you have removed Then find any maximum matching in this graph and print the sum of indices of edges belonging to this matching query of this type will be asked only after a query of type As the answer to this query you have to print the edges forming the maximum matching you have chosen in the previous query Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query Use functions in and in languages after each writing in your program ,If the array is already sorted then the answer is Otherwise there is a last operation after which the permutation takes the form Which means that the elements and are selected as the last operation because they are at the first and last positions after the operation Now we know that the last operation is and it doesn t matter where exactly these numbers are in the permutation i e we can assume that the answer has increased by and consider only the numbers 1 Similarly for the remaining permutation there are two options either it is sorted and then the answer is or there is a last operation and the numbers and are used in it And so on until the remaining permutation is sorted or empty It remains to find out how to quickly check whether the numbers in the segment are sorted they go in the correct order in the initial permutation Note that this segment corresponds to values of elements not to positions in the permutation If this segment is sorted for some then the answer does not exceed There are several ways to check let s consider one of them Note that if the segment is sorted for some value then it will be sorted for large values as well So we can start with the maximum value of which is equal to and decrease it until the segment remains sorted Now for each we need only two checks that and where is the position of the element in the permutation Thus we got the solution in linear time Another way is to run binary search on since if the numbers in appear in the permutation in sorted order the same holds for This approach yields a solution in ,0
142,You have barrels lined up in a row numbered from left to right from one Initially the th barrel contains liters of water You can pour water from one barrel to another In one act of pouring you can choose two different barrels and the th barrel shouldn t be empty and pour any possible amount of water from barrel to barrel possibly all water You may assume that barrels have infinite capacity so you can pour any amount of water in each of them Calculate the maximum possible difference between the maximum and the minimum amount of water in the barrels if you can pour water times Some examples if you have four barrels each containing liters of water and you may pour liters from the second barrel into the fourth so the amounts of water in the barrels are and the difference between the maximum and the minimum is if all barrels are empty you can t make any operation so the difference between the maximum and the minimum amount is still ,Count to the variable the number of all ones in the matrix Then consider pairs of diagonals one of which starts in cell and the other in cell for Using cyclic shifts we can assemble the main diagonal from this pair Then among all such pairs and the main diagonal find the one that contains the maximal number of ones and store this number in the variable The number of zeros on the main diagonal which should be turned into ones is equal to The number of ones to be turned into zeros because they are not on the main diagonal is calculated as The total answer is calculated as ,0
143,You are given a square board consisting of rows and columns Each tile in it should be colored either white or black Let s call some coloring if each pair of adjacent rows are either the same or different in every position The same condition should be held for the columns as well Let s call some coloring if it is and there is no of the single color consisting of at least tiles Your task is to count the number of colorings of the board of the given size Since the answer can be very large print it modulo ,This problem can be solved with simple simulation Let be the new position of the first friend and are new positions of the second and the third friends correspondingly For the fixed positions you can update the answer with the value And iterating over three positions can be implemented with nested loops Time complexity per test case ,0
144,A sequence of non negative integers is called if for all from to all ones of binary representation in are in the places of ones of binary representation in in other words where denotes bitwise AND If then the sequence is considered as well For example the following four sequences are growing in binary it s in binary it s in binary it s in binary it s The following three sequences are non growing in binary it s in binary it s in binary it s Consider two sequences of non negative integers and Let s call this pair of sequences if the sequence is where denotes bitwise XOR You are given a sequence of integers Find the lexicographically minimal sequence such that sequences and are co growing The sequence is lexicographically smaller than the sequence if there exists such that for any but ,A greedy strategy always works take largest barrels choose one barrel among them and pour all water from those barrels to the chosen barrel That way we make the minimum amount equal to it s quite obvious that we can t do anything better here and the maximum amount as large as possible so the difference between them will be as large as possible ,0
145,There are players numbered from to with ranks The th player has rank Players can form teams the team should consist of three players and of players in the team should have a conflict The rank of the team is calculated using the following algorithm let be the ranks of players in the team and then the rank of the team is equal to You are given information about the pairs of players who a conflict Calculate the total sum of ranks over all possible valid teams modulo ,Let s solve this task in several steps At first let s calculate sum of all triples For each player consider three cases there are exactly ways to choose triple there are ways there are ways At second let s calculate sum over all triples such that exists pair or To calculate it we need for each iterate over all neighbors of Again some cases if then there are exactly ways to choose if there are ways to choose But we calculated some triples twice so we need to subtract triples where both and exists It is easy to calculate sorting adjacency lists of all At third let s calculate sum over all triple where exists pair but pairs and are not is a sum of all triples where pair exists It can be calculated while iterating in increasing order is a sum of all triples where pairs and exists It can be calculated while iterating and asking sum on segment of adjacency list of with prefix sums for each vertex is a sum of all triples where pairs and exists It can be calculated while iterating and asking sum on prefix of adjacency list of same is a sum of all triples where all pairs and exists It is modification of calculating number of triangles in graph It can be done in and will be explained below Then result The algorithm of finding in the given graph is following Let s call vertex if and otherwise For each heavy vertex precalculate boolean array of adjacency of vertex It s cost of memory and time but memory can be reduced by using bitsets To calculate number of triangles let s iterate over There are two cases if is heavy then just iterate over all edges and check and This part works with time since there are heavy vertices if is light then iterate over all pair where at first fix then iterate To check existence of edge consider two more cases if is heavy just check It works in if is light just check in some global array all neighbors of check all with and uncheck neighbors of Checking in array require time and will be done times So it will be in total Similarly iterating pairs works with in total So comlexity of algorithm and all task is ,1
146,Limak is an old brown bear He often goes bowling with his friends Today he feels really good and tries to beat his own record For rolling a ball one gets a score an integer maybe negative number of points Score for the th roll is multiplied by and scores are summed up So for rolls with scores the total score is The total score is if there were no rolls Limak made rolls and got score for the th of them He wants to maximize his total score and he came up with an interesting idea He can say that some first rolls were only a warm up and that he wasn t focused during the last rolls More formally he can cancel any prefix and any suffix of the sequence It is allowed to cancel all rolls or to cancel none of them The total score is calculated as if there were only non canceled rolls So the first non canceled roll has score multiplied by the second one has score multiplied by and so on till the last non canceled roll What maximum total score can Limak get ,This problem has a lot of solutions You could even hard code all possible tests to solve it But this problem has solution Let the digit of be Then our character pressed each digit before exactly times And the amount of times he pressed the digit depends on the length of Let be the length of then the amount of times he pressed the digit is So the final answer is ,0
147,The string is given the string length is number The string consists of lowercase letters of the Latin alphabet As long as the string length is greater than the following operation can be performed on it select any two adjacent letters in the string and delete them from the string For example from the string in one operation you can get any of the four strings or In particular in one operation the length of the string reduces by Formally let the string have the form During one operation you choose an arbitrary index and replace For the given string and the letter determine whether it is possible to make such a sequence of operations that in the end the equality will be true In other words is there such a sequence of operations that the process will end with a string of length which consists of the letter ,There will be one character left in the end so we have to delete all the characters going before and after it That is delete some prefix and suffix Since we always delete some substring of length we can only delete the prefix and suffix of even length it means the answer is in the case when there is an odd position in with the character and otherwise ,1
148,You are given two integers and Calculate the number of pairs of arrays such that the length of both arrays is equal to each element of each array is an integer between and inclusive for any index from to array is sorted in non descending order array is sorted in non ascending order As the result can be very large you should print it modulo ,Let s consider the following sequence It s sequence of length sorted in non descending order where each element of each sequence is an integer between and We can find the number of such sequences by simple combinatorics it s combination with repetitions So the answer is ,1
149, Polycarp has to write a coursework The coursework consists of pages Polycarp also has cups of coffee The coffee in the th cup Polycarp has caffeine in it Polycarp can drink some cups of coffee each one no more than once He can drink cups in Polycarp drinks each cup and i e he cannot split any cup into several days Surely courseworks are not being written in a single day in a perfect world of Berland at least Let s consider some day of Polycarp s work Consider Polycarp drinks cups of coffee during this day and caffeine dosages of cups Polycarp drink during this day are Then the first cup he drinks gives him energy to write pages of coursework the second cup gives him energy to write pages the third cup gives him energy to write pages the th cup gives him energy to write pages If Polycarp doesn t drink coffee during some day he cannot write coursework at all that day Polycarp has to finish his coursework as soon as possible spend the minimum number of days to do it Your task is to find out this number of days or say that it is impossible ,Well the main idea is described in the previous D1 problem editorial Read it firstly So now we have to improve our solution somehow How can we do it Wait What is it We iterate over all numbers of days And the number of pages Polycarp can write when we consider days instead of is strictly increases because we always can drink any cup even with the minimum value of as a first during the new day and the number of pages will increase So what is it Oh this is binary search So all we need is to replace linear search to binary search submit the written code and get AC ,1
150,You are given a tree consisting of vertices numbered from to and edges numbered from to Initially all vertices except vertex are inactive You have to process queries of three types activate the vertex It is guaranteed that the vertex is inactive before this query and one of its neighbors is active After activating the vertex you have to choose a subset of edges of the tree such that each vertex is incident to chosen edge and each vertex is not incident to any of the chosen edges in other words this subset should represent a perfect matching on the active part of the tree If any such subset of edges exists print the sum of indices of edges in it otherwise print queries of this type will be asked only right after a query of type and there will be such queries If your answer to the previous query was simply print otherwise print the subset of edges for the previous query as follows first print the number of edges in the subset then print the indices of the chosen edges The sum of indices should be equal to your answer to the previous query terminate the program Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query Use functions in and in languages after each writing in your program ,Let s root the tree at vertex and try to analyze when a tree contains a perfect matching If we want to find the maximum matching in a tree we can use some greedy approaches like take a leaf of the tree match it with its parent and remove both vertices repeat this process until only isolated vertices remain If we are interested in a perfect matching then this process should eliminate all of the vertices Let s modify this process a bit by always picking the deepest leaf If there exists a perfect matching picking the deepest leaf will ensure that the tree always remains a tree and doesn t fall apart i e there will always be one connected component It means that when we remove the leaf with its parent this leaf is the only descendant of its parent It s easy to see that whenever we remove a pair of vertices in this process for each remaining vertex the number of its descendants is either left unchanged or decreased by It means that if a vertex has an even number of descendants it will have an even number of descendants until it is removed and the same for odd number of descendants Let s call the vertices with even number of descendants including the vertex itself and all the other vertices A vertex cannot change its status in the process of building the perfect matching Each leaf is and odd vertex and if its parent has only one child this parent is an even vertex So when we remove a pair of vertices one of them the child is odd and the other of them the parent is even This leads us to another way of building the perfect matching match each odd vertex with its parent and make sure that everything is correct Unfortunately implementing it is per query so we need something faster We can see that each even vertex has at least one odd child because if all children of a vertex are even then the number of its descendants including the vertex itself is odd In order to find a perfect matching we have to make sure that each even vertex has one odd child each odd vertex has an even vertex as its parent All this means is that it cannot be greater since each even vertex has at least one odd child and if it is smaller it s impossible to match the vertices The perfect matching itself consists of edges that connect odd vertices with their parents Okay now we need some sort of data structure to maintain the status of each vertex and the sum of edges that lead to an odd vertex if directed from top to bottom In our problem we have to add new leaves to the tree it happens when a vertex is activated and this increases the number of descendants for every vertex on the path from the root to this new leaf So we need some sort of data structure that supports the operations add a new leaf and flip the status of all vertices on a path One of the structures that allow this is the Link Cut Tree but we can use the fact that the whole tree is given in advance to build a Heavy Light Decomposition on it which is much easier to code Operations on segments of paths can be done with a lazy segment tree and each vertex then will be added in ,1
151,You are given a string You have to determine whether it is possible to build the string out of strings and or by concatenating them You can use the strings and or any number of times and in any order For example can be built as can be built as can be built as cannot be built from and or ,Every character in strings and has at least one character adjacent to it that is the same So if there is an isolated character in our string a character that has no neighbors equal to it we cannot build it It s easy to see that in the other case we can build the string we can split it into blocks of consecutive equal characters and since there are no isolated characters each block will have at least characters so it can be formed from strings of length and or consisting of equal characters So the problem is reduced to checking if each character has a neighbor equal to it ,1
152,You are given the current time in hour format Find and print the time after minutes Note that you should find only the time after minutes see the examples to clarify the problem statement You can read more about hour format here https en wikipedia org wiki 24 hour clock ,In this problem we can simply increase times the current time by one minute after each increasing we should check the hours and the minutes for overflow Another solution is to use the next formulas as the answer ,1
153,There is an infinite board of square tiles Initially all tiles are white Vova has a red marker and a blue marker Red marker can color tiles Blue marker can color tiles If some tile isn t white then you can t use marker of any color on it Each marker must be drained completely so at the end there should be exactly red tiles and exactly blue tiles across the board Vova wants to color such a set of tiles that they would form a consisting of exactly colored tiles all tiles of at least one color would also form a Here are some examples of correct colorings Here are some examples of incorrect colorings Among all correct colorings Vova wants to choose the one with the minimal perimeter What is the minimal perimeter Vova can obtain It is guaranteed that there exists at least one correct coloring , should be area of the outer rectangle It means that its sides are divisors of The same holds for the inner rectangle Let s assume that red color forms a rectangle we ll try it and then swap with and solve the same problem again Write down all the divisors of up to these are the possible smaller sides of the inner rectangle Divisors of up to are possible smaller sides of the outer rectangle Let s put inner rectangle to the left bottom corner of the outer rectangle and choose smaller sides of both of them as bottom and top ones Iterate over the divisors of for each of them choose the greatest divisor of smaller or equal to it and check that Update the answer with if it holds You can use both binary search or two pointers both get AC pretty easily The number of divisors of can usually be estimated as Overall complexity ,1
154,Petya has an array consisting of integers He wants to remove duplicate equal elements Petya wants to leave only the rightmost entry occurrence for each element of the array The relative order of the remaining unique elements should not be changed ,Why did the author choose the width of the hallway to be only Well in that case you can show that the robot will never move to the left while cleaning That is not true on width already When does the robot break Let the robot currently be in the cell indexed and the next column with a dirty cell be possibly The robot breaks only if both and are dirty That helps us to do a dynamic programming solution Since we can only care about next columns we would want to have some the largest number of dirty cells we can leave to the robot if we processed the first columns of the hallway and are currently standing in the th row of the th column Maybe with some additional states of the current or the next columns We want the dp to maintain the invariant that everything to the left of the th column is cleaned in such a way the robot can reach the cell We can choose when to fix the th column either maintain it being correct prior to entering the state or handling it in the transition to the next one I chose the former option There probably exists a million different dps that work I ll describe the one I did Let be the largest number of dirty cells that we can leave to the robot if we fixed which of the dirty cells in the first columns inclusive are cleaned by hand the robot reaches the cell from the left is true if the cell in the opposite row of the th column is dirty The transitions handle what to do with the dirty cells in the st column and where the robot goes based on that In particular there are the following transitions if is true then we have to clean the cell and the robot will move into otherwise the robot breaks from having two options if is false then let s say that the robot doesn t break immediately but moves into the next column in a unique way it moves horizontally first then possibly vertically we can leave the next column as is and the robot will move into if the cell is clean or if it s dirty if is false then we can clean the cell and the robot will move into Since we maintained the invariant that the th column is valid we can update the answer from all four states in the last column Overall complexity ,0
155,You are playing one famous sandbox game with the three dimensional world The map of the world can be represented as a matrix of size where the height of the cell is You are in the cell right now and want to get in the cell You can move only down from the cell to the cell or right from the cell to the cell There is an additional if the height of the current cell is then you can move only to the cell with height you can perform several operations During one operation you can decrease the height of cell by one I e you choose some cell and assign set Note that you make heights Also note that you decrease the height of the cell Your task is to find the number of operations you have to perform to obtain at least one suitable path from the cell to the cell It is guaranteed that the answer exists You have to answer independent test cases ,Firstly consider the field in indexation Suppose that the cell has some fixed height Let it be Then we can determine what should be the height of the cell as In fact it does not matter which way we choose we actually need only the number of moves to reach the cell and the height of the cell Then when the height of the cell is fixed we can solve the problem with the following dynamic programming is the minimum number of operations we need to reach the cell from the cell Initially all values except Then can be calculated as But one more thing if then this value of is incorrect and we cannot use it We also can t update from the incorrect values The answer for the problem with the fixed height of the cell is only when is correct and This part can be calculated in But if we iterate over all possible heights our solution obvious will get time limit exceeded verdict Now we can notice one important fact in the optimal answer the height of some cell remains unchanged Let this cell be Then we can restore the height of the cell as and run our quadratic dynamic programming to find the answer for this height Time complexity ,1
156,Graph constructive problems are back This time the graph you are asked to build should match the following properties The graph is connected if and only if there exists a path between every pair of vertices The diameter aka longest shortest path of a connected undirected graph is the maximum number of edges in the path between any pair of its vertices The degree of a vertex is the number of edges incident to it Given a sequence of integers construct a graph of vertices such that the graph contains no self loops and no multiple edges the degree of the th vertex doesn t exceed i e the diameter of the graph is maximum possible Output the resulting graph or report that no solution exists ,Let s construct the graph the following manner Take all the vertices with and build a bamboo out of them Surely all but the end ones will have degree the diameter now is the number of vertices minus 1 One can show that building the graph any other way won t make the diameter greater How should we distribute the other vertices Two of them can be used to increase diameter And all the others won t matter they can be paired with any of the vertices with degrees to spare If no loops are added then the diameter won t change the path that was the longest won t become any shorter All those facts imply that the graph should be a tree and the sum of should be at least Overall complexity ,1
157,We guessed some integer number You are given a list of its divisors means that there are in the list Your task is to find the minimum possible integer that can be the guessed number or say that the input data is contradictory and it is impossible to find such number You have to answer independent queries ,Suppose the given list of divisors is a list of divisors of some in other words suppose that the answer exists Then the minimum divisor multiplied by maximum divisor should be This is true because if we have a divisor we also have a divisor Let s sort all divisors and let Now we need to check if all divisors of except and are the permutation of the array check that our answer is really correct We can find all divisors of in sort them and compare with the array If arrays are equal then the answer is otherwise the answer is ,1
158,You are given two integer arrays and of length You can reverse subarray continuous subsegment of the array Your task is to reverse such a subarray that the sum is ,The naive approach is to iterate over and reverse the subsegment of the array and calculate the answer But this solution is too slow and works in Instead we can iterate over the center of the reversed segment and its length If the current segment is and we want to go to then the answer for the subsegment will increase by It remains to add the answer for and but without reversion this is easy to do if you pre calculate the prefix sums of the values ,1
159,You are given an array An array is constructed in such a way that it consists of integers and for each there are exactly occurrences of integer in So the number of elements in is exactly Let s define for such array the value as In other words is the total sum of distances between all pairs of equal elements Your task is to calculate the maximum possible value of and the number of arrays yielding the maximum possible value of Two arrays are considered different if elements at some position differ ,To be honest the solution to this problem is easier to code than to prove Let s follow the next strategy Write down all the letters of the string which have odd positions in alphabet and even positions in alphabet Sort both of these lists in non decreasing order The answer is either concatenation of the lists odd even or even odd or Now for the proof part Let s establish that we don t care about equal letters and leave just a single copy of each letter of the string Let s check some cases There is just a single letter That s trivial There are two letters of the same parity There is no incorrect arrangement for this There are two letters of different parity If they differ by one then no answer exists Otherwise any arrangement works There are three letters and they are consecutive in alphabet No answer exists There are other types of three letters Then the one of the different parity can put on the side e g and As the difference between at least one of these letters and that one isn t 1 that arrangement will be ok Finally there are at least 4 letters It means that the difference between either the smallest odd and the largest even or between the smallest even and the largest odd isn t 1 The only thing you need to do is to implement the check function the most straightforward way possible and check both arrangements Overall complexity ,0
160,You are given a string You have to determine whether it is possible to build the string out of strings and or by concatenating them You can use the strings and or any number of times and in any order For example can be built as can be built as can be built as cannot be built from and or ,There will be one character left in the end so we have to delete all the characters going before and after it That is delete some prefix and suffix Since we always delete some substring of length we can only delete the prefix and suffix of even length it means the answer is in the case when there is an odd position in with the character and otherwise ,0
161,You are given the array of integer numbers For each element find the distance to the nearest zero to the element which equals to zero There is at least one zero element in the given array ,Let s look at string Since we should get it using no more than two subsequences then where is the first subsequence and is the second one In the general case can be empty Let iterate all possible lengths of so we can check the existence of solution for each pair and If we d fix and we need to check the following is it true that contains and as subsequences and these subsequences don t intersect Initially we can invent the following dp let be if the prefix of of length contains prefixes of and of length and as non intersecting subsequences The transitions are straingforward if we can either skip indexed and update If indexed then we can update and if then we can update But this dp has complexity in general case But we can transform it in the next way instead of the boolean value we will make as a value of dp In other words we will maintain as minimal appropriate prefix But the problem now is to define transitions Let s note the next fact suppose we have and we d like to add next character to which is equal to The idea is next it s always optimal to choose the first occurrence of in It can be proved by contradiction if the first occurrence is free then it s better to take it or if the first occurrence will be occupied by then this will be handled by the other state with The logic for increasing is analogical In result we need to precalculate array with the next occurrence of character in suffix of one time before choosing and and use it each time to acquire complexity The total complexity if for each test case ,0
162,You are given a string consisting of lowercase Latin letters A pair of letters in a string is considered ugly if these letters are also in a alphabet For example string contains ugly pairs at positions and Letters and aren t considered neighbouring in a alphabet Can you rearrange the letters of a given string so that there are no ugly pairs You can choose any order of the letters of the given string but you can t add any new letters or remove the existing ones You can also leave the order the same If there are multiple answers print any of them You also have to answer separate queries ,Let s check all splitting points for all We denote a splitting point as the last index of the first string we take and all the remaining characters will go to the second string We need to keep a dynamic count of the number of distinct characters in both strings the first string and the second string We can do this using two frequency arrays and adding one to the distinct count of either string or when the frequency of a character is greater than zero ,0
163,You are given an array of points in dimensional space Let the distance between two points and be it is also known as Manhattan distance You have to process queries of the following two types set th element of to the point find the maximum distance between two points and where ,Let s rewrite the formula of distance between two points as follows where if otherwise Consider what will happen if we change some to the opposite value The result of this formula obviously won t increase so we may try all possible values of and pick maximum result This allows us to consider every option to set values of there are such options separately and when we fix a set of values of find two points that maximize the distance if it is expressed with fixed To do so we have to find the point having maximum and having minimum So actually our problem is reduced to the following we have arrays we want to process some queries in the form change an element of some array and find maximum and minimum on some segment of some array This can be done simply by building a segment tree over each array and then we will get the solution having time complexity ,1
164,You are given a string consisting of lowercase Latin letters and an integer number Let s define a substring of some string with indices from to as Your task is to construct such string of minimum possible length that there are exactly positions such that In other words your task is to construct such string of minimum possible length that there are exactly substrings of equal to It is guaranteed that the answer is always unique ,The only thing you need to do is to place letters by blocks and so on The last block can contain less than letters but it is ok It is easy to see that this letters distribution is always not worse than others ,0
165,You play your favourite game yet another time You chose the character you didn t play before It has points of strength and points of intelligence Also at start the character has free experience points you can invest either in strength or in intelligence by investing one point you can either raise strength by or raise intelligence by Since you d like to make some fun you want to create a jock character so it has more strength than intelligence points resulting strength is than the resulting intelligence Calculate the number of different character builds you can create for the purpose of replayability if you must Two character builds are different if their strength and or intellect are different ,There are many different ways to solve this problem generate all Berland words with two for loops and store them in an array then for each test case go through the array of words to find the exact word you need generate all Berland words with two for loops and store them in a dictionary like data structure in C in Python etc using words as keys and their numbers as values This allows to search for the index of the given word quickly for each test case run two for loops to iterate over the words count the number of words we skipped and stop at the word from the test case try to invent some formulas that allow counting the number of words before the given one ,0
166,Berland has a long and glorious history To increase awareness about it among younger citizens King of Berland decided to compose an anthem Though there are lots and lots of victories in history of Berland there is the one that stand out the most King wants to mention it in the anthem as many times as possible He has already composed major part of the anthem and now just needs to fill in some letters King asked you to help him with this work The anthem is the string of no more than small Latin letters and question marks The most glorious victory is the string of no more than small Latin letters You should replace all the question marks with small Latin letters in such a way that the number of occurrences of string in string is maximal Note that the occurrences of string in can overlap Check the third example for clarification ,Let s denote the string obtained by concatenation where is some dividing character that isn t a part of the alphabet as Recall that KMP algorithm builds the prefix function for this string We can calculate on this string where is the position in this string and is the value of prefix function in this position The value of is the maximum number of occurences of found so far or if this situation is impossible If th character is a Latin letter then we just recalculate prefix function for this position the fact that in KMP the value of prefix function won t exceed allows us to do so If th character is a question mark then we check all possible characters and recalculate prefix function for all of these characters and update the corresponding values The size of and is pretty big so we need to recalculate these values in time this can be done by precalculating the values of is the value of prefix function is a new character and is the value of prefix function after adding this character ,1
167,Polycarp has just attempted to pass the driving test He ran over the straight road with the signs of four types speed limit this sign comes with a positive integer number maximal speed of the car after the sign cancel the action of the previous sign of this type overtake is allowed this sign means that after some car meets it it can overtake any other car no speed limit this sign cancels speed limit if any car can move with arbitrary speed after this sign no overtake allowed some car can t overtake any other car after this sign Polycarp goes past the signs consequentially each new sign cancels the action of all the previous signs of it s kind speed limit overtake It is possible that two or more no overtake allowed signs go one after another with zero overtake is allowed signs between them It works with no speed limit and overtake is allowed signs as well In the beginning of the ride overtake is allowed and there is no speed limit You are given the sequence of events in chronological order events which happened to Polycarp during the ride There are events of following types Polycarp changes the speed of his car to specified this event comes with a positive integer number Polycarp s car overtakes the other car Polycarp s car goes past the speed limit sign this sign comes with a positive integer Polycarp s car goes past the overtake is allowed sign Polycarp s car goes past the no speed limit Polycarp s car goes past the no overtake allowed It is guaranteed that the first event in chronological order is the event of type Polycarp changed the speed of his car to specified After the exam Polycarp can justify his rule violations by telling the driving instructor that he just didn t notice some of the signs What is the minimal number of signs Polycarp should say he didn t notice so that he would make no rule violations from his point of view ,Let s notice that you should never say that you didn t notice signs no speed limit and overtake is allowed Also if you drive with speed you don t want to remove signs speed limit with number greater or equal to Thus greedy solution will work Process all the events in chronological order We should maintain stack of signs speed limit and amount of signs no overtake allowed If we meet sign speed limit we push its limit to stack sign no overtake allowed increase no speed limit clear stack overtake is allowed assign to zero After every event we should check if our speed is fine While value of sign on the top of the stack is less than current speed pop it and increase answer If we overtake someone we add to answer and assign to zero Overall complexity ,1
168,You are given an array of points in dimensional space Let the distance between two points and be it is also known as Manhattan distance You have to process queries of the following two types set th element of to the point find the maximum distance between two points and where ,First let Eve tell the jokes of the first type they will never do any harm At the same time let her tell the jokes of the fourth time at the very end they will not do any good Types two and three are kind of opposites of each other If you tell jokes of each of them one after another then the moods of both spectators don t change Let s use that to our advantage Tell the jokes of these types in pairs until one of them runs out There s a little corner case here though If there were no jokes of the first type then you can t use a single pair because of the spectators leaves after one joke Finally try to tell the remaining jokes of the same type before the fourth type So the construction looks like with and possibly swapped with each other Let s recover the answer from that construction After the first type both moods are After the alternating jokes the moods are still the same After that one of the spectators will have his her mood only decreasing until the end Once it reaches the show ends Thus Eve can tell jokes if Otherwise it s always Overall complexity ,0
169, Polycarp has to write a coursework The coursework consists of pages Polycarp also has cups of coffee The coffee in the th cup Polycarp has caffeine in it Polycarp can drink some cups of coffee each one no more than once He can drink cups in Polycarp drinks each cup and i e he cannot split any cup into several days Surely courseworks are not being written in a single day in a perfect world of Berland at least Let s consider some day of Polycarp s work Consider Polycarp drinks cups of coffee during this day and caffeine dosages of cups Polycarp drink during this day are Then the first cup he drinks gives him energy to write pages of coursework the second cup gives him energy to write pages the third cup gives him energy to write pages the th cup gives him energy to write pages If Polycarp doesn t drink coffee during some day he cannot write coursework at all that day Polycarp has to finish his coursework as soon as possible spend the minimum number of days to do it Your task is to find out this number of days or say that it is impossible ,You can check if the given is by removing all the trailing zeros and checking if resulting string is a palindrome ,0
170,Polycarp wants to build a fence near his house He has white boards and red boards he can use to build it Each board is characterised by its length which is an integer A good fence should consist of red board and several possibly zero white boards The red board should be the longest one in the fence every white board used in the fence should be strictly shorter and the sequence of lengths of boards should be ascending before the red board and descending after it Formally if boards are used and their lengths are in the order they are placed in the fence from left to right let s call this array the following conditions should hold there should be exactly one red board in the fence let its index be for every for every When Polycarp will build his fence he will place all boards from left to right on the same height of without any gaps so these boards compose a polygon Polycarp is interested in fences of some special perimeters He has integers he really likes these integers are and for every such integer he wants to calculate the number of different fences with perimeter he can build two fences are considered different if their are different Can you help him calculate these values ,Let s simplify the problem a bit we need either to minimize the number of lowercase letters or to minimize the number of uppercase letters Both variants can be described by the following model we have a binary array a where a i 0 if s i is in the correct case and a i 1 otherwise We can do at most k operations set 0 on the segment i i l 1 and we d like to minimize the total sum of a At first let s start with a solution which is pretty slow but correct Let dp len c be the minimum sum of the prefix a 0 dots a len 1 such that c operations was already applied on it In order to calculate this dp somehow efficiently we need to understand that it s optimal to avoid intersections of segments of applied operations so we can further specify the state of dp with the following all c applied operations have their right borders le len 1 It s easy to specify the transitions we either apply set operation on len len l 1 and relax dp len l c 1 with dp len c or not and relax d len 1 c with dp len c a len It still O nk so we d like to optimize it more and we can do it using the lambda optimization i e aliens trick Here we will try to describe what aliens trick is and the features of its application on the discrete calculations In general aliens trick allows you to get rid of the restriction on the total number of operations applied to the array sometimes it s the number of segments in the partition of the array by replacing it with the binary search of the value lambda connected to it The lambda is the cost of using the operation or the cost to use one more segment in the partition In other words we can use as many operations as we want but we need to pay for each of them Often we can calculate the answer without the restriction faster The main restriction of the using this dp optimization is the following in case of the discrete model consider the answer ans c for the fixed c or dp n c If we look at the function ans c it should be somewhat convex i e ans c 1 ans c ge ans c ans c 1 or sometimes ans c ans c 1 ge ans c 1 ans c for all possible c Let s look at the answers of the modified version of the problem with cost lambda for each used operation as function res lambda c It s easy to prove that res lambda c ans c lambda c and it s also somewhat convex for a fixed lambda as a sum of convex functions But more important it has the following property let c lambda be the position where the res lambda c is the minimum possible It can be proven from the convex property that c lambda ge c lambda 1 This property leads to the solution binary search lambda while keeping track of the c lambda i e find the minimum lambda that c lambda le k But there are several problems related to the discrete origin of the problem The c lambda is not unique In general case there is a segment cl lambda cr lambda where the minimum res lambda c can be achieved But there is still a property that cl lambda ge cl lambda 1 and cr lambda ge cr lambda 1 So we need to ensure that we will always find either minimum such c lambda or maximum such c lambda The second problem comes from the first one There are situations when c lambda c lambda eps 1 It creates a problem in the next situation suppose the binary search finished with lambda opt the c lambda opt 1 k and c lambda opt k But we need to use exactly k operations what to do Using float values will not help so we don t need them so we ll use usual integer bs Suppose we minimized the c lambda opt then we can show that k in cl lambda opt cr lambda opt or in other words res lambda opt k res lambda opt c lambda opt So we can claim that we calculated the value not only for c lambda opt but also for k In the end if we can efficiently calculate c lambda and res lambda c lambda for the fixed lambda then we can binary search lambda opt extract res lambda opt c lambda opt and claim that the dp n k res lambda opt c lambda opt lambda opt k Finally let s discuss how to calculate c lambda and res lambda c lambda for a fixed lambda Since res lambda c lambda is just a minimum cost and the c lambda is the minimum number of operations with such cost We can calculate it by simplifying our starting dp Remember the cost is calculated in a next way for each remaining 1 in a we pay 1 and for each used operation we pay lambda Let d len cost len cnt len where cost len is minimum cost on the prefix of length len and cnt len is minimum number of operations cost len can be achieved Then the transitions are almost the same we either let a len be and relax d pos 1 with cost len a len cnt len or start new operation and relax d pos len with cost len lambda cnt len 1 The result is pair d n Some additional information we should carefully choose the borders of the binary search we should choose the left border so it s optimal to use operation whenever we can usually 0 or 1 And we should choose the right border so it s never optimal to use even one operation usually more than the maximum possible answer The total complexity is O n log n P S We don t have the strict proof that the ans c is convex but we have faith and stress We d appreciate it if someone would share the proof in the comment section ,0
171,You are given a directed graph consisting of vertices Each directed edge or arc labeled with a single character Initially the graph is empty You should process queries with it Each query is one of three types add arc from to with label It s guaranteed that there is no arc in the graph at this moment erase arc from to It s guaranteed that the graph contains arc at this moment find the sequence of vertices such that there exist both routes and and if you write down characters along both routes you ll get the same string You can visit the same vertices any number of times ,Let s denote as some stack sortable array which contains all integers from to inclusive We can see that if the first element of is then where by we mean concatenation of arrays It s easy to prove this fact if the first element is then we have to store it in the stack until we have processed all elements less than so in no element that is greater than can precede any element less than This way we can represent the prefix we are given For example if and prefix is then we can rewrite the permutation we have to obtain as So the unknown suffix is a contatenation of some stack sortable arrays It s easy to see that if an array is sorted in non increasing order then it is stack sortable So we can replace each block with an array If during rewriting the given prefix we obtain some impossible situation for example when and given prefix is we have and can t be the beginning of then answer is ,0
172,You are given two integers and Your task is to construct such a string of length that for each from to there is at least one th letter of the Latin alphabet in this string the first letter is a the second is b and so on and there are no other letters except these You have to of some letter the frequency of a letter is the number of occurrences of this letter in a string If there are several possible answers you can print You have to answer queries ,The person with the number looks at the person with the number so the count of people standing to the left of between and is equal to the count of people standing to the right of between and Therefore both counts are equal to hence must be a solution of the equation The only solution of the equation is Let s check that in the circle of people can occur the numbers and i e let s check that If it s false there s no solution output Since the person with the number looks at the person with the number the condition must be met Let s solve the equation for There are two solutions We can output any of such that It s easy to prove that exactly one of the solutions meets the condition ,0
173, You are given a string consisting of lowercase Latin letters You have to color its characters each character to exactly one color the same letters can be colored the same or different colors i e you can choose exactly one color for each index in After coloring you can swap two neighboring characters of the string that are colored colors You can perform such an operation arbitrary possibly zero number of times The goal is to make the string sorted i e all characters should be in alphabetical order Your task is to find the minimum number of colors which you have to color the given string in so that after coloring it can become sorted by sequence of swaps Note that you have to restore only coloring not the sequence of swaps ,The solution of this problem is based on Dilworth s theorem You can read about it on Wikipedia In two words this theorem says that the minimum number of non decreasing sequences we need to cover the whole sequence equals the length of longest decreasing subsequence Let s calculate the dynamic programming the length of longest decreasing sequence that ends in the position To recalculate this dynamic let s carry the array of length where means the maximum value of for the character on the prefix we already considered So initially all are ones all values of are zeros For the position we update with and update with Okay how to restore the answer That s pretty easy The color of the th character is exactly Why it is so If becomes greater than then we surely need to use the new color for this character because we cannot append it to the end of any existing sequence Otherwise we will append it to some existing sequence with the maximum possible number and because it has the maximum number and we didn t update the value of with the number of this sequence plus one the current character is not less than the last in this sequence Time complexity or ,1
174,A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and and and are not You are given an integer Your goal is to construct and print different regular bracket sequences of length ,A greedy strategy always works take largest barrels choose one barrel among them and pour all water from those barrels to the chosen barrel That way we make the minimum amount equal to it s quite obvious that we can t do anything better here and the maximum amount as large as possible so the difference between them will be as large as possible ,0
175,Let s suppose you have an array a stack initially empty and an array also initially empty You may perform the following operations until both and are empty Take the first element of push it into and remove it from if is not empty Take the top element from append it to the end of array and remove it from if is not empty You can perform these operations in arbitrary order If there exists a way to perform the operations such that array is sorted in non descending order in the end then array is called For example is because will be sorted if we perform the following operations Remove from and push it into Remove from and push it into Remove from and append it to the end of Remove from and push it into Remove from and append it to the end of Remove from and append it to the end of After all these operations so is is not You are given first elements of some permutation of size recall that a permutation of size is an array of size where each integer from to occurs exactly once You have to restore the remaining elements of this permutation so it is If there are multiple answers choose the answer such that is lexicographically maximal an array is lexicographically greater than an array iff there exists some integer such that for every and Print the lexicographically maximal permutation you can obtain If there exists no answer then output ,Every character in strings and has at least one character adjacent to it that is the same So if there is an isolated character in our string a character that has no neighbors equal to it we cannot build it It s easy to see that in the other case we can build the string we can split it into blocks of consecutive equal characters and since there are no isolated characters each block will have at least characters so it can be formed from strings of length and or consisting of equal characters So the problem is reduced to checking if each character has a neighbor equal to it ,0
176,You are given a square board consisting of rows and columns Each tile in it should be colored either white or black Let s call some coloring if each pair of adjacent rows are either the same or different in every position The same condition should be held for the columns as well Let s call some coloring if it is and there is no of the single color consisting of at least tiles Your task is to count the number of colorings of the board of the given size Since the answer can be very large print it modulo ,You can notice that every coloring can be encoded by the two binary strings of length You firstly generate one string to put as a first row and then use the second string to mark if you put the first string as it is or inverting each color That way you can also guess that the area of maximum rectangle of a single color you will get in you coloring is the product of maximum lengths of segments of a single color in both of the strings Let s consider the following dynamic programming solution is the number of binary strings of length such the current last segment of a single color has length and the maximum segment of a single color has length The transitions are color the new tile the same as the previous one color the new tile the opposite from the previous one The starting state is Let s sum the values of this dp to an array the number of binary strings of length such that the maximum segment of a single color in them has length You can also do another dp to calculate this not in but in using some partial sums in it Finally you iterate over the first side of the resulting rectangle the maximum length of segment of a single color in a first binary string and multiply the number of ways to get it by the total number of ways to get the second side of the resulting rectangle so that the area doesn t Overall complexity or ,1
177,Let number be such number that adding some leading zeros possible none to it produces a palindromic string String is called a palindrome if it reads the same from left to right and from right to left For example numbers and are they can be transformed to strings and respectively which are palindromes You are given some integer number Check if it s a number ,Let s solve the problem using dynamic programming Let be the maximum total beauty of pictures if Vova is at the th picture now the number of remaining reposts is and Vova reposted the th picture Initially and all other values of are Let s learn to do some transitions to calculate this dynamic programming What is the way to do it Let s iterate over the position of the previously reposted picture and try to update using previously calculated values Obviously this position can be from to So let s iterate over the position let it be and if we need one more repost to repost the th picture is not then try to update pictures are indexed So where can we find the answer The answer is If this value is then the answer is Overall complexity is ,0
178,Vova likes pictures with kittens The news feed in the social network he uses can be represented as an array of consecutive pictures with kittens of course Vova likes all these pictures but some are more beautiful than the others the th picture has beauty Vova wants to repost exactly pictures in such a way that each segment of the news feed of at least consecutive pictures has at least one picture reposted by Vova the sum of beauty values of reposted pictures is maximum possible For example if then Vova has to repost all the pictures in the news feed If then Vova can skip some pictures but between every pair of consecutive pictures Vova has to repost at least one of them Your task is to calculate the maximum possible sum of values of reposted pictures if Vova follows conditions described above or say that there is no way to satisfy all conditions ,Let s solve the problem using dynamic programming Let be the maximum total beauty of pictures if Vova is at the th picture now the number of remaining reposts is and Vova reposted the th picture Initially and all other values of are Let s learn to do some transitions to calculate this dynamic programming What is the way to do it Let s iterate over the position of the previously reposted picture and try to update using previously calculated values Obviously this position can be from to So let s iterate over the position let it be and if we need one more repost to repost the th picture is not then try to update pictures are indexed So where can we find the answer The answer is If this value is then the answer is Overall complexity is ,1
179,The Berland language consists of words having Moreover Any combination of two different Berland letters which by the way are the same as the lowercase letters of Latin alphabet is a correct word in Berland language The Berland dictionary contains all words of this language The words are listed in a way they are usually ordered in dictionaries Formally word comes earlier than word in the dictionary if one of the following conditions hold the first letter of is less than the first letter of the first letters of and are the same and the second letter of is less than the second letter of So the dictionary looks like that Word Word Word Word Word Word Word You are given a word from the Berland language Your task is to find its index in the dictionary ,There are many different ways to solve this problem generate all Berland words with two for loops and store them in an array then for each test case go through the array of words to find the exact word you need generate all Berland words with two for loops and store them in a dictionary like data structure in C in Python etc using words as keys and their numbers as values This allows to search for the index of the given word quickly for each test case run two for loops to iterate over the words count the number of words we skipped and stop at the word from the test case try to invent some formulas that allow counting the number of words before the given one ,1
180,New Year is coming and you are excited to know how many minutes remain before the New Year You know that currently the clock shows hours and minutes where and Your task is to find the number of minutes before the New Year You know that New Year comes when the clock shows hours and minutes You have to answer independent test cases ,The first observation is that we can always try to find the palindrome of length otherwise we can remove some characters from the middle until its length becomes The second observation is that the palindrome of length is two equal characters and some other maybe the same character between them Now there are two ways find the pair of equal non adjacent characters in or do it in for each character we only need to consider its left and right occurrences ,0
181,There are of independent carriages on the rails The carriages are numbered from left to right from to The carriages are not connected to each other The carriages move to the left so that the carriage with number moves ahead of all of them The th carriage has its own engine which can accelerate the carriage to km h but the carriage cannot go faster than the carriage in front of it See example for explanation All carriages start moving to the left at the same time and they naturally form We will call consecutive moving carriages having the same speed For example we have carriages and array Then the final speeds of the carriages will be Respectively of the train will be formed There are also messages saying that some engine has been corrupted message means that the speed of the th carriage has decreased by that is there has been a change in the maximum speed of the carriage Messages arrive sequentially the processing of the next message takes into account the changes from all previous messages After each message determine the number of formed trains ,In the set we will keep the indices that start the trains That is if the array the real speeds of the carriages then we will store in the network such values that As well as the value of Thus the size of the set is the answer to the problem Consider now the operation to reduce the speed of the carriage find such maximal index in the set if the value then we should add the value to the set since it will start a new train Then we should remove all subsequent indexes from the set such that Thus for all operations we will add no more than elements to the array and remove in total no more than elements from the set We obtain the asymptotic ,1
182,Consider a hallway which can be represented as the matrix with rows and columns Let s denote the cell on the intersection of the th row and the th column as The distance between the cells and is There is a cleaning robot in the cell Some cells of the hallway are clean other cells are dirty the cell with the robot is clean You want to clean the hallway so you are going to launch the robot to do this After the robot is launched it works as follows While at least one cell is dirty the robot chooses among those which are dirty moves there and cleans it so the cell is no longer dirty After cleaning a cell the robot again finds the closest dirty cell and so on This process repeats until the whole hallway is clean However there is a critical bug in the robot s program If at some moment there are multiple closest to the robot s current position dirty cells the robot malfunctions You want to clean the hallway in such a way that the robot doesn t malfunction you can clean some possibly zero of the dirty cells yourself However you don t want to do too much dirty work yourself while you have this nice smart yet buggy robot to do this Note that you cannot make a clean cell dirty Calculate the maximum possible number of cells you can leave dirty before launching the robot so that it doesn t malfunction ,You can notice that every coloring can be encoded by the two binary strings of length You firstly generate one string to put as a first row and then use the second string to mark if you put the first string as it is or inverting each color That way you can also guess that the area of maximum rectangle of a single color you will get in you coloring is the product of maximum lengths of segments of a single color in both of the strings Let s consider the following dynamic programming solution is the number of binary strings of length such the current last segment of a single color has length and the maximum segment of a single color has length The transitions are color the new tile the same as the previous one color the new tile the opposite from the previous one The starting state is Let s sum the values of this dp to an array the number of binary strings of length such that the maximum segment of a single color in them has length You can also do another dp to calculate this not in but in using some partial sums in it Finally you iterate over the first side of the resulting rectangle the maximum length of segment of a single color in a first binary string and multiply the number of ways to get it by the total number of ways to get the second side of the resulting rectangle so that the area doesn t Overall complexity or ,0
183,Let s denote the function for a string as the number of distinct characters that the string contains For example and Given a string split it into two non empty strings and such that is the maximum possible In other words find the maximum possible value of such that the concatenation of string and string is equal to string ,I know about greedy solutions and other approaches but I ll describe my solution This is dynamic programming I ll consider all positions indexed Let be the minimal element in the decreasing sequence if the last element th was in the increasing sequence and be the maximum element in the increasing sequence if the last element th was in the decreasing sequence Initially all are and all are except two values and What about transitions Let s consider four cases The previous element was in the increasing sequence and we want to add the current element to the increasing sequence We can do if the previous element was in the increasing sequence and we want to add the current element to the decreasing sequence We can do if the previous element was in the decreasing sequence and we want to add the current element to the decreasing sequence We can do if the previous element was in the decreasing sequence and we want to add the current element to the increasing sequence We can do if The logic behind these transitions is kinda hard but understandable If and then the answer is Otherwise we can restore any possible answer using parents in the dynamic programming ,0
184,You are given an integer and two sequences and Let s call a set of integers such that if for every element of the following condition is met for every if divides then is also included in An empty set is always The of the set is You have to calculate the maximum possible of a set ,Let s denote the string obtained by concatenation where is some dividing character that isn t a part of the alphabet as Recall that KMP algorithm builds the prefix function for this string We can calculate on this string where is the position in this string and is the value of prefix function in this position The value of is the maximum number of occurences of found so far or if this situation is impossible If th character is a Latin letter then we just recalculate prefix function for this position the fact that in KMP the value of prefix function won t exceed allows us to do so If th character is a question mark then we check all possible characters and recalculate prefix function for all of these characters and update the corresponding values The size of and is pretty big so we need to recalculate these values in time this can be done by precalculating the values of is the value of prefix function is a new character and is the value of prefix function after adding this character ,0
185,We define the of an array as You are given a tree consisting of vertices Each vertex has an integer written on it We define the value of the path from vertex to vertex as follows consider all vertices appearing on the path from to write down all the numbers written on these vertices in the order they appear on the path and compute the of the resulting sequence Your task is to calculate the maximum value over all paths in the tree ,Let s use centroid decomposition to solve the problem We need to process all the paths going through each centroid somehow Consider a path from vertex to vertex going through vertex which is an ancestor of both and in the centroid decomposition tree Suppose the sequence of numbers on path from to including both these vertices is and the sequence of numbers on path from to including but excluding is Let and We can show that the sum of prefix sums of is equal to Now suppose we fix the second part of the path and are fixed and we want to find the best first part for this second part Each possible first part is represented by a linear function and our goal is to find the maximum over all these linear functions in the point and add to this maximum This can be done with the help of convex hull or Li Chao tree The most difficult part of implementation is how to process each centroid s subtree It s easy to obtain all first parts and second parts of paths going through the centroid but pairing them up can be complicated for each second part we have to build a convex hull or Li Chao tree on all first parts going to this centroid excluding those which go through the same child of the centroid as the second part we are considering One of the best ways to implement this is the following Suppose our centroid has children is the set of first parts going from the th child of the centroid and is the set of second parts going to the th child We will create a new data structure initially empty process all second parts from add all first parts from process all second parts from add all first parts from and so on After that we will clear our data structure process all second parts from add all first parts from process all second parts from add all first parts from and so on until we add all first parts from That way we will consider all possible first parts for each second part we are trying to use ,1
186,Recently Ivan noticed an array while debugging his code Now Ivan can t remember this array but the bug he was trying to fix didn t go away so Ivan thinks that the data from this array might help him to reproduce the bug Ivan clearly remembers that there were elements in the array and each element was not less than and not greater than Also he remembers facts about the array There are two types of facts that Ivan remembers for each such that for each such that Also Ivan thinks that this array was a permutation but he is not so sure about it He wants to restore some array that corresponds to the facts that he remembers and is very similar to permutation Formally Ivan has denoted the of array as follows where is the number of occurences of in the array Help Ivan to determine minimum possible of the array that corresponds to the facts ,This problem can be solved with mincost maxflow approach Let s construct a following network Construct a vertex for every number from to For each of these vertices add directed edges from the source to this vertex the capacity of each edge will be and the costs will be so pushing flow from the source to the vertex will cost exactly Also construct a vertex for every index of the array For each number make add a directed edge with capacity and cost to every position in the array such that this number can be put into this position and for every index make a directed edge from the vertex constructed for this index to the sink with capacity and cost Minimum cost maximum flow in this network will construct a suitable array with minimum cost so the answer to the problem is minimum cost of maximum flow in the network ,1
187,Vova promised himself that he would never play computer games But recently Firestorm a well known game developing company published their newest game World of Farcraft and it became really popular Of course Vova started playing it Now he tries to solve a quest The task is to come to a settlement named Overcity and spread a rumor in it Vova knows that there are characters in Overcity Some characters are friends to each other and they share information they got Also Vova knows that he can bribe each character so he or she starts spreading the rumor th character wants gold in exchange for spreading the rumor When a character hears the rumor he tells it to all his friends and they start spreading the rumor to their friends for free and so on The quest is finished when all characters know the rumor What is the minimum amount of gold Vova needs to spend in order to finish the quest Take a look at the notes if you think you haven t understood the problem completely ,In this problem you are given an undirected graph with weighted vertices And the problem is to calculate the sum of minimum values in every connected component To do this we just need to run or several times ,1
188,You are given a garland consisting of lamps States of the lamps are represented by the string of length The th character of the string equals if the th lamp is turned off or if the th lamp is turned on You are also given a positive integer In one move you can choose and change its state i e turn it on if it is turned off and vice versa The garland is called periodic if the distance between is Consider the case Then garlands and are good but garlands and are not Note that i e the first turned on lamp is not going after the last turned on lamp and vice versa Your task is to find the number of moves you need to make to obtain periodic garland from the given one You have to answer independent test cases ,Let be the string containing all characters of that have indices and so on i e all such positions that have the remainder modulo Suppose we choose that all turned on lamps will have remainder modulo Then we need to remove all ones at the positions that do not belong to this remainder Also considering the string we need to spend the number of moves to make this string of kind contiguous block of zeros contiguous block of ones and again contiguous block of zeros because considering the characters modulo will lead us to exactly this pattern notice that some blocks can be empty How to calculate the answer for the string in linear time Let be the number of moves we need to fix the prefix of till the th character in a way that the th character of is Let be the number of ones in on the segment Notice that we can calculate all required values in linear time using prefix sums Then we can calculate as where is the boolean value of the expression if is true and otherwise Let be the length of Then the actual answer for the string can be calculated as thus we consider the case when the obtained string doesn t contan ones at all and consider each position as the last position of some one So the actual answer can be calculated as Time complexity ,1
189,You are given segments on a coordinate line each endpoint of every segment has integer coordinates Some segments can degenerate to points Segments can intersect with each other be nested in each other or even coincide Your task is the following for every calculate the number of points with integer coordinates such that the number of segments that cover these points equals A segment with endpoints and covers point if and only if ,Let s rewrite the inequality from to This looks much simpler Let s build the array where and sort this array Now our problem is to find the number of pairs such that Let s iterate over all elements of from left to right For simplicity we consider only greater summands Because our sum must be greater than then at least one of these summands will be positive So if just skip it Now and we need to calculate the number of such that and It means that each for some will be okay Such leftmost position can be found with or binary search Then add the value to the answer and consider the next element Time complexity ,0
190,You have a card deck of cards numbered from top to bottom i e the top card has index and bottom card index Each card has its color the th card has color You should process queries The th query is described by integer For each query you should find the highest card in the deck with color i e the card with minimum index print the position of the card you found take the card and place it on top of the deck ,Let s calculate cycle n the number of permutations of length n which have a maximum at the position 1 and consist of exactly one cycle Each good permutation can be divided into such blocks so we ll need this value later It is easy to notice that cycle n n 2 Let s calculate the following dynamic programming dp i the number of good permutations consisting of elements i n To calculate dp i let s iterate over j the maximum element of the first block it determines the length of this block j i 1 dp i sum j i n dp j 1 cdot cycle j i 1 Now let s use the standard method of lexicographic recovery We will iterate over which element to put next it immediately determines the size of the new block and all the elements in it If the number of permutations starting with such block is at least k then you need to restore this block entirely and reduce the task to the one without this block Otherwise you need to subtract the number of permutations starting on such block from k and proceed to the next option for the block We will also use lexicographic recovery to restore the block You must carefully maintain the current block so that it consists of exactly one cycle To do this you can use DSU or explicitly check for a cycle ,0
191,Petya has an array consisting of integers He wants to remove duplicate equal elements Petya wants to leave only the rightmost entry occurrence for each element of the array The relative order of the remaining unique elements should not be changed ,We will store integers which we already met in a set Let s iterate through the given array from the right to the left Let the current element is equal to So if does not contain in we add in a vector answer and add in After we considered all elements the answer sequence contains in the vector in reversed order So we should reverse the vector and simply print all its elements ,1
192,A group of friends decide to go to a restaurant Each of the friends plans to order meals for burles and has a total of burles The friends decide to split their visit to the restaurant into several days Each day some group of friends goes to the restaurant Each of the friends visits the restaurant no more than once that is these groups do not intersect These groups must satisfy the condition that the total budget of each group must be than the amount of burles that the friends in the group are going to spend at the restaurant In other words the sum of all values in the group must not exceed the sum of values in the group What is the maximum number of days friends can visit the restaurant For example let there be friends for whom and Then first and sixth friends can go to the restaurant on the first day They will spend burles at the restaurant and their total budget is burles Since they can actually form a group friends with indices can form a second group They will spend burles at the restaurant and their total budget will be burles It can be shown that they will not be able to form more groups so that each group has at least two friends and each group can pay the bill So the maximum number of groups the friends can split into is Friends will visit the restaurant for a maximum of two days Note that the rd friend will not visit the restaurant at all Output the maximum number of days the friends can visit the restaurant for given and ,First we sort the friends in descending order of Now for each friend we know the amount of money he lacks or vice versa which he has in excess In order to maximize the number of days it is most advantageous for friends to break into pairs It is the number of groups that matters not the number of people in the group so adding a third person to the pair won t improve the answer in any way Let s solve the problem using two pointers for the richest friend find the first friend from the end such that the sum of their values exceeds the sum of their values Then repeat this for all subsequent friends until the pointers meet If no pair could be formed or none of the friends has a value greater than then the answer is Otherwise print the number of pairs formed ,1
193,You are given three arrays and Initially array consists of elements arrays and are empty You are performing the following algorithm that consists of two steps Step while is not empty you take from and move it of array If currently has odd length you can choose place the element from to the left or to the right of the middle element of As a result becomes empty and consists of elements Step while is not empty you take from and move it of array If currently has even length you can choose which of two middle elements to take As a result becomes empty and now consists of elements Refer to the Note section for examples Can you make array sorted in non decreasing order ,Let s start by finding the maximum matching in the given graph Since the constraints are pretty big you need something fast The model solution converts the matching problem into a flow network and uses Dinic to find the matching in but something like heavily optimized Kuhn s algorithm can also work Okay then what about finding the minimum possible number of vertices to delete in order to reduce the maximum matching We claim that it is always enough to remove one vertex and the proof will also provide a way to quickly search for such vertices Let s recall that the size of the maximum matching is equal to the size of the minimum vertex cover So we will try to find a way to reduce the minimum vertex cover by and it s actually pretty easy just remove any vertex belonging to the vertex cover it s obvious that it reduces the vertex cover by and the maximum matching by as well So we can find the minimum vertex cover in the graph using the standard algorithm to convert the MM into MVC or if you re using Dinic to find the maximum matching you can represent the minimum vertex cover as the minimum cut problem and for each query of type just take a vertex from the vertex cover we found Now the only thing that s left is discussing how to maintain the structure of the maximum matching in the graph In fact it s quite easy on the one hand since we remove the vertices belonging to the minimum vertex cover every edge including the edges from the matching will be incident to one of the vertices we will remove on the other hand due to the definition of the maximum matching there is no vertex that is incident to two or more edges from the maximum matching so every vertex from the vertex cover has exactly one edge from the maximum matching that is incident to it and when we remove a vertex we can simply remove the corresponding edge from the maximum matching So the only thing we need to do is to maintain which edge from the matching corresponds to which vertex from the minimum vertex cover and it will allow us to maintain the structure of the maximum matching and since these pairs don t change when we remove a vertex it is enough to get this information right after we have constructed the maximum matching in the given graph we won t need to rebuild it ,0
194,You have an axis aligned rectangle room with width and height so the lower left corner is in point and the upper right corner is in There is a rectangular table standing in this room The sides of the table are parallel to the walls the lower left corner is in and the upper right corner in You want to place another rectangular table in this room with width and height with the width of the table parallel to the width of the room The problem is that sometimes there is not enough space to place the second table without intersecting with the first one there are no problems with tables touching though You any of the tables but you can move the first table inside the room What is the minimum distance you should move the first table to free enough space for the second one ,Firstly let s notice the next property if two axis aligned rectangles don t intersect then we can draw a vertical or horizontal line between them In other words either max x 1 x 2 le min x 3 x 4 or max x 3 x 4 le min x 1 x 2 if x 1 and x 2 are coordinates of the one rectangle and x 3 and x 4 of the other one analogically for y coordinates Now suppose you want to move the first table by dx dy Note that if in result they will be divided by vertical line then we can set dy 0 they still will be divided but the total distance will decrease Analogically if divided by horizontal line we can set dx 0 In other words it s always optimal to move the table either horizontally or vertically Let s look at the case of horizontal move at first we need to check that both tables can fit in the room or their total width w x 2 x 1 le W If yes then we calculate the movement distance dx as follows if we move the table right then there should be at least w to the left of it or w le x 1 dx Leftrightarrow dx ge w x 1 Since we want to minimize dx then we take dx max 0 w x 1 If we want to move the table left then there should be at least w to the right or x 2 dx le W w Leftrightarrow dx ge x 2 W w minimizing dx means taking dx max 0 x 2 W w So the result is min max 0 w x 1 max 0 x 2 W w The vertical case can be handled in the same manner if h y 2 y 1 le H then the result is min max 0 h y 1 max 0 y 2 H h The answer is the minimum among all possible variants or 1 if both cases are impossible ,1
195,Let s call yet again a string if its length is even and every character in odd position of this string is different from the next character the first character is different from the second the third is different from the fourth and so on For example the strings and are good strings and the strings and are not good You are given a string you have to delete minimum number of characters from this string so that it becomes good ,The following greedy solution works let s iterate over all characters of the string from left to right and if the last block of two consecutive characters in the resulting string is full just add the current character to the resulting string otherwise add this character if it is not equal to the first character of the last block And don t forget about the parity of length remove last character if the length is odd ,1
196,You are given three integers and Consider all binary strings i e all strings consisting of characters and or of length from to For every such string you need to choose an integer from to A multiset of binary strings of length is considered beautiful if for every binary string with length from to the number of strings in the multiset such that is their prefix is not exceeding For example let and The multiset of strings is beautiful since for the string there are strings in the multiset such that is their prefix and for the string there is one string in the multiset such that is its prefix and for the string there are strings in the multiset such that is their prefix and for the string there is one string in the multiset such that is its prefix and for the string there are strings in the multiset such that is their prefix and for the string there is one string in the multiset such that is its prefix and Now for the problem itself You have to calculate the number of ways to choose the integer for every binary string of length from to in such a way that the possible size of a beautiful multiset is ,First of all let s visualize the problem in a different way We have to set some constraints on the number of strings which have some kind of prefix Let s think about a data structure that would allow us to understand it better One of the most common data structures to store strings which works with their prefixes and maintains the number of strings with some prefix is a trie so we can reformulate this problem using tries Now the problem is the following one we have a binary trie of depth the leaves of this trie may store strings and for each vertex except for the root we can set a constraint on the number of strings stored in the subtree what is the number of ways to choose these constraints so that the maximum number of strings possibly with copies the trie can store is exactly To handle it we can use dynamic programming of the form the number of ways to choose the constraints for the vertex and its subtree so that the maximum number of strings which can be stored in the subtree is exactly When calculating we can iterate on the constraint for the vertex let it be and the maximum number of strings in the subtrees of and let these be and and make updates of the form add to the value of This dynamic programming will work in or depending on the implementation which is too slow However we can use the following optimizations to improve the complexity of the solution all vertices on the same depth can be treated as equivalent so we can actually calculate this dynamic programming not for vertices but just for when handling transitions from some node s children to that node let s split these transitions into two steps The first step is iterating on the number of strings which fit into the subtrees of the children the second step is iterating on the constraint for the subtree of the node The first step is actually a convolution if we don t consider the constraint for the node itself then the transitions would be something like add to the value of so it can be improved to with FFT The second step can be improved to as well if we iterate on the minimum between the constraint for the node and the total number of strings which can be stored in the children and maintain the sum on suffix for the values of dynamic programming Overall these optimizations lead to a solution with complexity ,1
197,You have rectangles the th rectangle has height and width You are asked queries of the form For each query output the total area of rectangles you own that a rectangle of height and width while also a rectangle of height and width In other words print for such that and Also note that you rotate rectangles Please note that the answer for some test cases won t fit into 32 bit integer type so you should use at least 64 bit integer type in your programming language like for C ,We will store integers which we already met in a set Let s iterate through the given array from the right to the left Let the current element is equal to So if does not contain in we add in a vector answer and add in After we considered all elements the answer sequence contains in the vector in reversed order So we should reverse the vector and simply print all its elements ,0
198,You are walking through a parkway near your house The parkway has benches in a row numbered from to from left to right The distance between the bench and is meters Initially you have units of energy To walk meter of distance you spend unit of your energy You can t walk if you have no energy Also you can restore your energy by and this is the only way to restore the energy When you are sitting you can restore any integer amount of energy you want if you sit longer you restore more energy Note that the amount of your energy Your task is to find the amount of energy you have to by sitting on benches to reach the bench from the bench and end your walk You have to answer independent test cases ,In this problem we can simply increase times the current time by one minute after each increasing we should check the hours and the minutes for overflow Another solution is to use the next formulas as the answer ,0
199,There are cities along the road which can be represented as a straight line The th city is situated at the distance of kilometers from the origin All cities are situated in the same direction from the origin There are trucks travelling from one city to another Each truck can be described by integers starting city finishing city fuel consumption and number of possible refuelings The th truck will spend litres of fuel per one kilometer When a truck arrives in some city it can be refueled but refueling is impossible in the middle of nowhere The th truck can be refueled at most times Each refueling makes truck s gas tank full All trucks start with full gas tank All trucks will have gas tanks of the same size litres You should find minimum possible such that all trucks can reach their destinations without refueling more times than allowed ,Let s look at string Since we should get it using no more than two subsequences then where is the first subsequence and is the second one In the general case can be empty Let iterate all possible lengths of so we can check the existence of solution for each pair and If we d fix and we need to check the following is it true that contains and as subsequences and these subsequences don t intersect Initially we can invent the following dp let be if the prefix of of length contains prefixes of and of length and as non intersecting subsequences The transitions are straingforward if we can either skip indexed and update If indexed then we can update and if then we can update But this dp has complexity in general case But we can transform it in the next way instead of the boolean value we will make as a value of dp In other words we will maintain as minimal appropriate prefix But the problem now is to define transitions Let s note the next fact suppose we have and we d like to add next character to which is equal to The idea is next it s always optimal to choose the first occurrence of in It can be proved by contradiction if the first occurrence is free then it s better to take it or if the first occurrence will be occupied by then this will be handled by the other state with The logic for increasing is analogical In result we need to precalculate array with the next occurrence of character in suffix of one time before choosing and and use it each time to acquire complexity The total complexity if for each test case ,0
200,You are given an undirected complete graph on vertices A complete graph is a graph where each pair of vertices is connected by an edge You have to paint the edges of the graph into two colors red and blue each edge will have one color A set of vertices is if for every pair of vertices such that and there exists a path from to that goes only through red edges and vertices from Similarly a set of vertices is if for every pair of vertices such that and there exists a path from to that goes only through blue edges and vertices from You have to paint the graph in such a way that there is at least one red edge there is at least one blue edge for each set of vertices such that is either red connected or blue connected but Calculate the number of ways to paint the graph and print it modulo ,The first idea that comes to mind is running some sort of dynamic programming the number of ways to cut the string consisting of the first characters When we calculate we need to take the sum of the previous values of and then subtract for every such that the string from the th character inclusive to the th character non inclusive is a Fibonacci string Unfortunately there are two main issues with this solution firstly we cannot store the array in memory and secondly we have to search for the Fibonacci strings ending in a certain index quickly something like Aho Corasick could work with a less strict memory limit but right now we cannot use it We will try to resolve both of these issues with the following approach while we process the characters we will maintain the list of tuples such that the string from the th character to the current one is a prefix of some Fibonacci string How do we maintain them Every Fibonacci string except for is a prefix of So all Fibonacci strings we are interested in except for again are prefixes of the same long Fibonacci string Suppose a tuple represents some index such that the string from the th character to the current one is a prefix of that long Fibonacci string Each time we append a character we filter this list of tuples by trying to check if this new character matches the next character in the prefix if it does not the tuple is discarded For the tuples that represent the prefixes equal to Fibonacci strings we need to subtract the value of from the new value we are trying to calculate checking if a prefix is a Fibonacci string is easy we just need to check its length How do we check that if we add a character or it is still a prefix There are two ways to do this either generate the first characters of the long Fibonacci string or represent the current prefix as the sum of Fibonacci strings such that for every the condition holds i e the Fibonacci strings we split the current prefix into are arranged in descending order and there is no pair of equal or adjacent by index Fibonacci strings in the split This representation is very similar to writing an integer in Zeckendorf system The next character in the prefix depends on whether belongs to this split if it belongs it is the last string in the split so we need to append to transform into otherwise we need to append Okay so now we can solve the problem in time where is the total length of the strings in the input and is the size of the list of tuples we discussed earlier This actually works since it looks like the size of the list of tuples is bounded as Unfortunately we don t have a strict mathematical proof of this we checked this by brute force with up to so it definitely works under the constraints of the problem ,0
201,You a captain of a ship Initially you are standing in a point obviously all positions in the sea can be described by cartesian plane and you want to travel to a point You know the weather forecast the string of length consisting only of letters and The letter corresponds to a direction of wind Moreover the forecast is periodic e g the first day wind blows to the side the second day the th day and th day again and so on Ship coordinates change the following way if wind blows the direction then the ship moves from to if wind blows the direction then the ship moves from to if wind blows the direction then the ship moves from to if wind blows the direction then the ship moves from to The ship can also either go one of the four directions or stay in place each day If it goes then it s exactly 1 unit of distance Transpositions of the ship and the wind add up If the ship stays in place then only the direction of wind counts For example if wind blows the direction and the ship moves the direction then from point it will move to the point and if it goes the direction then it will move to the point You task is to determine the minimal number of days required for the ship to reach the point ,There are many ways to solve this problem The model solution does the following thing start with the sequence merge the first characters into one sequence to get merge the first characters into one sequence to get and so on ,0
202,Let be the length of the longest common prefix of strings and Also let be the substring of from index to index inclusive For example if then You are given a string of length and queries Each query is a pair of integer sets and Calculate for each query ,A greedy strategy always works take largest barrels choose one barrel among them and pour all water from those barrels to the chosen barrel That way we make the minimum amount equal to it s quite obvious that we can t do anything better here and the maximum amount as large as possible so the difference between them will be as large as possible ,0
203,The next lecture in a high school requires two topics to be discussed The th topic is interesting by units for the teacher and by units for the students The pair of topics and is called if i e it is more interesting for the teacher Your task is to find the number of pairs of topics ,Let s rewrite the inequality from to This looks much simpler Let s build the array where and sort this array Now our problem is to find the number of pairs such that Let s iterate over all elements of from left to right For simplicity we consider only greater summands Because our sum must be greater than then at least one of these summands will be positive So if just skip it Now and we need to calculate the number of such that and It means that each for some will be okay Such leftmost position can be found with or binary search Then add the value to the answer and consider the next element Time complexity ,1
204,You are given a weighted undirected connected graph consisting of vertices and edges It is guaranteed that there are no self loops or multiple edges in the given graph Let s define the weight of the path consisting of edges with indices as where weight of the th edge in the graph Your task is to find the minimum weight of the path from the st vertex to the th vertex for each ,Let s consider a problem where you can subtract the weight of any edge not only the maximum one that belong to the current path and similarly add the weight of any edge not only the minimum one that belong to the current path To solve that problem we can build a new graph where the node can be represented as the following triple node from the initial graph flag that some edge has been subtracted flag that some edge has been added Now we can run Dijkstra s algorithm to find the length of the shortest paths in such a graph We can notice that on the shortest path the maximum weight edge was subtracted and the minimum weight edge was added Let s assume that this is not the case and an edge of non maximum weight was subtracted from the path then we can reduce the length of the path by choosing an edge of maximum weight But this is not possible because we considered the shortest path Similarly it is proved that the added edge was of minimal weight Using this fact it is not difficult to notice that by solving the modified problem we have solved the original one ,1
205,Let s say you are standing on the plane at point and you want to reach point You can move only in two directions to the i e horizontally and in the direction that increase your coordinate or i e vertically and in the direction that increase your coordinate In other words your path will have the following structure initially you choose to go to the right or up then you go some distance in the chosen direction distances can be chosen independently after that you change your direction from right to up or from up to right and repeat the process You don t like to change your direction too much so you will make no more than direction changes As a result your path will be a polygonal chain from to consisting of line segments where each segment has positive integer length and vertical and horizontal segments alternate Not all paths are equal You have integers where is the cost of the th segment Using these costs we can define the as the sum of lengths of the segments of this path multiplied by their cost i e if the path consists of segments then the cost of the path is equal to segments are numbered from to in the order they are in the path Find the path of the minimum cost and print its cost ,Suppose we decided to make exactly turns or in other words our path will consist of exactly segments Since we should finish at point and vertical and horizontal segments alternates then it means that and From the other side we should minimize But it means that we can minimize and independently How to minimize if we know that and It s easy to prove that it s optimal to assign all except minimum and assign to this minimum the remaining part In other words to calculate the optimal path consisting of segments we need to know the sum of on odd and even positions among and also minimum among odd and even positions Then we can drive out the answer as a quite easy formula Finally we should iterate over all from to and find the minimum answer among all variants It s easy to recalculate sums and minimums when we make transition form to Complexity is ,1
206,It is given a positive integer In move one can select any single digit and remove it i e one selects some position in the number and removes the digit located at this position The operation cannot be performed if only one digit remains If the resulting number contains leading zeroes they are automatically removed E g if one removes from the number the rd digit the resulting number will be If one removes from the number the first digit the resulting number will be the zeroes going next to the first digit are automatically removed What is the minimum number of steps to get a number such that it is divisible by and It is guaranteed that for each occurring in the input the answer exists It is guaranteed that the number has no leading zeros ,Observe the cost of inserting a single element Notice that inserting any value between the minimum of the sequence and the maximum of the sequence is free Why is this true The argument is similar to the algorithm of finding some such that for a continous function if you know some such that and such that As a more general idea it s free to insert some value into a segment such that and WLOG assume Let s find the position that is free If then you can insert between and since it s free Otherwise you can choose an arbitrary position will be either between and or between and or both of them Descend into the one that holds to continue the search Since the lenght decreases at some point you will reach the segment of length How does that help Well you can insert somewhere then insert somewhere The rest of insertions will be free Now it s an algorithmic problem First consider all options to insert both and between the same pair of elements Next assume you insert somewhere before Iterate from left to right maintaning the lowest price to insert Try to insert at the current position and into the cheapest position before it Then update the lowest price for inserting After you finish reverse the sequence and solve the problem again that will be the same as inserting before Overall complexity per testcase ,0
207,Let s define the sequence of Fibonacci strings as follows is is is for denotes the concatenation of two strings So for example is is is For a given string let s define as the number of ways to cut it into several any number possibly even just one strings such that none of these strings are Fibonacci strings For example if is since there are three ways to cut it You are given a sequence of strings Calculate Since these values can be huge print them modulo ,The first idea that comes to mind is running some sort of dynamic programming the number of ways to cut the string consisting of the first characters When we calculate we need to take the sum of the previous values of and then subtract for every such that the string from the th character inclusive to the th character non inclusive is a Fibonacci string Unfortunately there are two main issues with this solution firstly we cannot store the array in memory and secondly we have to search for the Fibonacci strings ending in a certain index quickly something like Aho Corasick could work with a less strict memory limit but right now we cannot use it We will try to resolve both of these issues with the following approach while we process the characters we will maintain the list of tuples such that the string from the th character to the current one is a prefix of some Fibonacci string How do we maintain them Every Fibonacci string except for is a prefix of So all Fibonacci strings we are interested in except for again are prefixes of the same long Fibonacci string Suppose a tuple represents some index such that the string from the th character to the current one is a prefix of that long Fibonacci string Each time we append a character we filter this list of tuples by trying to check if this new character matches the next character in the prefix if it does not the tuple is discarded For the tuples that represent the prefixes equal to Fibonacci strings we need to subtract the value of from the new value we are trying to calculate checking if a prefix is a Fibonacci string is easy we just need to check its length How do we check that if we add a character or it is still a prefix There are two ways to do this either generate the first characters of the long Fibonacci string or represent the current prefix as the sum of Fibonacci strings such that for every the condition holds i e the Fibonacci strings we split the current prefix into are arranged in descending order and there is no pair of equal or adjacent by index Fibonacci strings in the split This representation is very similar to writing an integer in Zeckendorf system The next character in the prefix depends on whether belongs to this split if it belongs it is the last string in the split so we need to append to transform into otherwise we need to append Okay so now we can solve the problem in time where is the total length of the strings in the input and is the size of the list of tuples we discussed earlier This actually works since it looks like the size of the list of tuples is bounded as Unfortunately we don t have a strict mathematical proof of this we checked this by brute force with up to so it definitely works under the constraints of the problem ,1
208,You are beta testing the new secret Terraria update This update will add quests to the game Simply the world map can be represented as an array of length where the th column of the world has height There are quests you have to test The th of them is represented by two integers and In this quest you have to go from the column to the column At the start of the quest you are appearing at the column In one move you can go from the column to the column or to the column In this version you have Spectre Boots which allow you to fly Since it is a beta version they are bugged so they only allow you to fly when you are going up and have infinite fly duration When you are moving from the column with the height to the column with the height then you get some amount of fall damage If the height is greater than the height you get fall damage otherwise you fly up and get damage For each of the given quests determine the minimum amount of fall damage you can get during this quest ,So the first idea that is coming into mind is prefix sums Let s define two values and The value means the amount of fall damage when we are going to the right from the column to the column and means the amount of fall damage when we are going to the left from the column to the column Then let s build prefix sums on these two arrays Now let be the sum of all on a prefix i e and be the sum of all on a prefix Then if in a query the answer is otherwise if the answer is Time complexity ,1
209,Vova likes pictures with kittens The news feed in the social network he uses can be represented as an array of consecutive pictures with kittens of course Vova likes all these pictures but some are more beautiful than the others the th picture has beauty Vova wants to repost exactly pictures in such a way that each segment of the news feed of at least consecutive pictures has at least one picture reposted by Vova the sum of beauty values of reposted pictures is maximum possible For example if then Vova has to repost all the pictures in the news feed If then Vova can skip some pictures but between every pair of consecutive pictures Vova has to repost at least one of them Your task is to calculate the maximum possible sum of values of reposted pictures if Vova follows conditions described above or say that there is no way to satisfy all conditions ,There will be one character left in the end so we have to delete all the characters going before and after it That is delete some prefix and suffix Since we always delete some substring of length we can only delete the prefix and suffix of even length it means the answer is in the case when there is an odd position in with the character and otherwise ,0
210,Limak is an old brown bear He often goes bowling with his friends Today he feels really good and tries to beat his own record For rolling a ball one gets a score an integer maybe negative number of points Score for the th roll is multiplied by and scores are summed up So for rolls with scores the total score is The total score is if there were no rolls Limak made rolls and got score for the th of them He wants to maximize his total score and he came up with an interesting idea He can say that some first rolls were only a warm up and that he wasn t focused during the last rolls More formally he can cancel any prefix and any suffix of the sequence It is allowed to cancel all rolls or to cancel none of them The total score is calculated as if there were only non canceled rolls So the first non canceled roll has score multiplied by the second one has score multiplied by and so on till the last non canceled roll What maximum total score can Limak get ,The key is to use divide and conquer We need a recursive function f left right that runs f left mid and f mid 1 right where and also considers all intervals going through We will eventually need a convex hull of lines linear functions and let s see how to achieve it For variables we will try to write the score of interval as a linear function It would be good to get something close to where and depend on and depends on only For each we should find a linear function where should fit the equation Now we have a set of linear functions representing all possible left endpoints For each right endpoint we should find and to fit equation again With value of we can iterate over functions to find the one maximizing value of And still for fixed we should add to get the maximum possible score of interval ending in ,1
211,You are given a sequence of integers You are also given integers You are asked to insert each of the extra integers into the sequence Each integer can be inserted at the beginning of the sequence at the end of the sequence or between any elements of the sequence The score of the resulting sequence is the sum of absolute differences of adjacent elements in it What is the smallest possible score of the resulting sequence ,I know about greedy solutions and other approaches but I ll describe my solution This is dynamic programming I ll consider all positions indexed Let be the minimal element in the decreasing sequence if the last element th was in the increasing sequence and be the maximum element in the increasing sequence if the last element th was in the decreasing sequence Initially all are and all are except two values and What about transitions Let s consider four cases The previous element was in the increasing sequence and we want to add the current element to the increasing sequence We can do if the previous element was in the increasing sequence and we want to add the current element to the decreasing sequence We can do if the previous element was in the decreasing sequence and we want to add the current element to the decreasing sequence We can do if the previous element was in the decreasing sequence and we want to add the current element to the increasing sequence We can do if The logic behind these transitions is kinda hard but understandable If and then the answer is Otherwise we can restore any possible answer using parents in the dynamic programming ,0
212,Ivan plays an old action game called Heretic He s stuck on one of the final levels of this game so he needs some help with killing the monsters The main part of the level is a large corridor so large and narrow that it can be represented as an infinite coordinate line The corridor is divided into two parts let s assume that the point is where these parts meet The right part of the corridor is filled with monsters for each monster its initial coordinate is given and since all monsters are in the right part every is positive The left part of the corridor is filled with crusher traps If some monster enters the left part of the corridor or the origin so its current coordinate becomes to it gets instantly killed by a trap The main weapon Ivan uses to kill the monsters is the Phoenix Rod It can launch a missile that explodes upon impact obliterating every monster caught in the explosion and throwing all other monsters away from the epicenter Formally suppose that Ivan launches a missile so that it explodes in the point Then every monster is either killed by explosion or pushed away Let some monster s current coordinate be then if then the monster is killed if then the monster is pushed units to the left so its current coordinate becomes if then the monster is pushed units to the right so its current coordinate becomes Ivan is going to kill the monsters as follows choose some integer point and launch a missile into that point then wait until it explodes and all the monsters which are pushed to the left part of the corridor are killed by crusher traps then if at least one monster is still alive choose another integer point probably the one that was already used and launch a missile there and so on What is the minimum number of missiles Ivan has to launch in order to kill all of the monsters You may assume that every time Ivan fires the Phoenix Rod he chooses the impact point optimally You have to answer independent queries ,Let s consider the following sequence It s sequence of length sorted in non descending order where each element of each sequence is an integer between and We can find the number of such sequences by simple combinatorics it s combination with repetitions So the answer is ,0
213,A string is called if it does not contain any characters other than and A bracket sequence is called shortly RBS if it is possible to obtain correct arithmetic expression by inserting characters and into this sequence For example and are RBS and and are not We can see that each opening bracket in RBS is paired with some closing bracket and using this fact we can define of the RBS as maximum number of bracket pairs such that the nd pair lies inside the st one the rd one inside the nd one and so on For example nesting depth of is is and is Now you are given RBS of even length You should color each bracket of into one of two colors red or blue Bracket sequence consisting only of red brackets should be RBS and bracket sequence consisting only of blue brackets should be RBS Any of them can be empty You are not allowed to reorder characters in or No brackets can be left uncolored Among all possible variants you should choose one that of s and s nesting depth If there are multiple solutions you can print any of them ,Let be nested depth of RBS There is an interesting fact that From the other side we can always reach equation using some approaches Let s look at prefix of length of string Let be number of opening bracket in the prefix number of closing brackets Then we can define balance of the th prefix of as The author s approach is next Let s define of pair of brackets matched in natural way as where is position of opening bracket of this pair Then we will color in red all pairs with even level and in blue with odd level Proof of It can be shown that and exists such that After any coloring of we can define number of opening closing red blue brackets of th prefix of as and respectively Since and then Finally ,1
214,You are given an undirected connected graph consisting of vertices and edges Your goal is to destroy all edges of the given graph You may choose any vertex as the starting one and begin walking from it along the edges When you walk along an edge you destroy it Obviously you cannot walk along an edge if it is destroyed You can perform the operation at most once during your walk and this operation can only be performed when you are at some vertex you cannot perform it while traversing an edge After the the edges you go through are deleted in the following way the first edge after the is not destroyed the second one is destroyed the third one is not destroyed the fourth one is destroyed and so on You cannot switch back to the original mode and you don t have to perform this operation if you don t want to Can you destroy all the edges of the given graph ,Let s suppose our graph is split into two graphs and the first graph contains the edges we delete before the mode shift the second graph contains the edges we delete after the mode shift It s quite obvious that the graph has an eulerian path The structure of is a bit harder to analyze but we can prove that it is always a star graph a vertex and some other vertices connected directly to it and the center of the star coincides with the last vertex in the eulerian path in To prove that is a star graph we can consider the second part of the path after the mode shift backward the last edge we traversed was deleted and the previous to last move could have been only along that edge The third last and the fourth last moves should have been along another edge connecting some vertex to the center of the star and so on Okay how do we find a way to split the graph into and Iterate on the center of the star let it be For the graph to contain an eulerian path it should have at most vertices with an odd degree Let s construct in such a way that we minimize the number of odd vertices in for each edge incident to we either move it to or in such a way that the resulting degree of the other vertex is even All other edges belong to If there is an eulerian path in that ends in we are done Otherwise we should iterate on some edge adjacent to and change its status in order to check if can have an eulerian path after that We can t flip two edges because flipping two edges increases the number of odd vertices in at least by if it is already or greater the eulerian path won t exist and if it s then flipping two edges creates two odd vertices none of which is so eulerian path can t end in After flipping each edge we try to find an eulerian path in once again and flip the edge back After checking the vertex as the center of the star we return all adjacent edges to and move to the next vertex The whole algorithm requires checking for the existence of the eulerian path times so it should work in or depending on the implementation Fun fact initially I wanted to give a harder version of a problem with that would require some sort of dynamic connectivity to check for an eulerian path fast but when I started coding it I realized that implementation there was a bit painful so I ve decided to drop the constraints to allow quadratic solutions ,1
215,There are players numbered from to with ranks The th player has rank Players can form teams the team should consist of three players and of players in the team should have a conflict The rank of the team is calculated using the following algorithm let be the ranks of players in the team and then the rank of the team is equal to You are given information about the pairs of players who a conflict Calculate the total sum of ranks over all possible valid teams modulo ,Let s calculate cycle n the number of permutations of length n which have a maximum at the position 1 and consist of exactly one cycle Each good permutation can be divided into such blocks so we ll need this value later It is easy to notice that cycle n n 2 Let s calculate the following dynamic programming dp i the number of good permutations consisting of elements i n To calculate dp i let s iterate over j the maximum element of the first block it determines the length of this block j i 1 dp i sum j i n dp j 1 cdot cycle j i 1 Now let s use the standard method of lexicographic recovery We will iterate over which element to put next it immediately determines the size of the new block and all the elements in it If the number of permutations starting with such block is at least k then you need to restore this block entirely and reduce the task to the one without this block Otherwise you need to subtract the number of permutations starting on such block from k and proceed to the next option for the block We will also use lexicographic recovery to restore the block You must carefully maintain the current block so that it consists of exactly one cycle To do this you can use DSU or explicitly check for a cycle ,0
216,There are people in a row The height of the th person is You can choose subset of these people and try to arrange them into a A is such an order of people that the difference between heights of any adjacent people is no more than For example let heights of chosen people be where is the number of people you choose Then the condition should be satisfied for all from to and the condition should be also satisfied means the absolute value of It is obvious that the circle consisting of one person is balanced Your task is to choose the maximum number of people and construct a consisting of all chosen people It is obvious that the circle consisting of one person is balanced so the answer always exists ,Let s realize what we need to construct the with heights from l to r We can represent it as l l 1 dots r 1 r r 1 dots l 1 As we can see we need one occurrence of l and r and two occurrences of all other heights from l 1 to r 1 How can we find the using this information We can find the segment of neighboring heights with at least two occurrences using the array of frequencies cnt sorted array of unique heights b and two pointers technique For the current left border l we should increase r initially it is l 1 and it is an excluded border while b r b r 1 1 and cnt b r ge 2 Then for the current left and right borders we can try to extend the segment to the left if b l b l 1 1 and to the right if b r 1 b r 1 and try to update the answer with the the current segment and go to the next segment There may be some corner cases like n 1 or all cnt are 1 but you can avoid them if you will implement the solution carefully There are almost no corner cases in my solution you can see details of implementation in authors code Time complexity O n log n or O n depends on sorting method ,1
217,Graph constructive problems are back This time the graph you are asked to build should match the following properties The graph is connected if and only if there exists a path between every pair of vertices The diameter aka longest shortest path of a connected undirected graph is the maximum number of edges in the path between any pair of its vertices The degree of a vertex is the number of edges incident to it Given a sequence of integers construct a graph of vertices such that the graph contains no self loops and no multiple edges the degree of the th vertex doesn t exceed i e the diameter of the graph is maximum possible Output the resulting graph or report that no solution exists ,Note that if we can reach the destination in days so we can reach it in days since we can stay in the destination point by moving to the opposite to the wind direction So we can binary search the answer To check the possibility to reach the destination point in days we should at first look at the position the wind moves ship to Now we can calculate where we can go since each day we can move in one of four directions or not move at all we can reach any point with Manhattan distance So we need to check that To calculate we can note that there were full cycles and extra days So it can be calculated with time using prefix sums Finally about borders of binary search to reach the destination point we need to move closer at least by one it terms of Manhattan distance from the full cycle of the wind So if answer exists then it doesn t exceed ,0
218,You are given a string You can build new string from using the following operation choose any subsequence where erase the chosen subsequence from can become empty concatenate chosen subsequence to the right of the string in other words Of course initially the string is empty For example let At first let s choose subsequence we will get and At second let s choose we will get and So we can build from Can you build a given string using the algorithm above ,Let s look at string Since we should get it using no more than two subsequences then where is the first subsequence and is the second one In the general case can be empty Let iterate all possible lengths of so we can check the existence of solution for each pair and If we d fix and we need to check the following is it true that contains and as subsequences and these subsequences don t intersect Initially we can invent the following dp let be if the prefix of of length contains prefixes of and of length and as non intersecting subsequences The transitions are straingforward if we can either skip indexed and update If indexed then we can update and if then we can update But this dp has complexity in general case But we can transform it in the next way instead of the boolean value we will make as a value of dp In other words we will maintain as minimal appropriate prefix But the problem now is to define transitions Let s note the next fact suppose we have and we d like to add next character to which is equal to The idea is next it s always optimal to choose the first occurrence of in It can be proved by contradiction if the first occurrence is free then it s better to take it or if the first occurrence will be occupied by then this will be handled by the other state with The logic for increasing is analogical In result we need to precalculate array with the next occurrence of character in suffix of one time before choosing and and use it each time to acquire complexity The total complexity if for each test case ,1
219,A positive integer is called a if it can be represented as where is a non negative integer So the are You are given two positive integers and Your task is to represent as the of ,Note that whichever order you choose the total time will always contain all initial health in other words any answer will contain as its part So the lower the sum of you will add to the answer the better Look at some monster If you kill it while it has both left and right neighbor it will add to the answer If it is the first or the last in the row it will add just And if it is the last monster it will add There can be only one last monster so any other will add at least to the answer And for any chosen last monster you can find the order that gives exactly for all other monsters For example you can firstly kill monsters then and finally moster In other words if the last monster is the th one the total answer will be equal to Since we need to minimize answer we can choose monster with maximum So the answer is ,0
220,There is a building consisting of apartments numbered from to inclusive Call an apartment if its number consists of Examples of boring apartments are and so on Our character is a troublemaker and he calls the intercoms of all apartments till someone answers the call in the following order First he calls all apartments consisting of digit in increasing order Next he calls all apartments consisting of digit in increasing order And so on The resident of the boring apartment answers the call and our character calling anyone further Our character wants to know how many digits he pressed in total and your task is to help him to count the total number of keypresses For example if the resident of boring apartment answered then our character called apartments with numbers and the total number of digits he pressed is You have to answer independent test cases ,There is a common approach for the problem you are given a lot of strings and texts count the number of occurences of the strings in the texts build an Aho Corasick automaton on the given strings and somehow process the texts with it Let s see if it can handle this problem The names of the songs can be represented as a tree We may build an Aho Corasick on the strings given in the queries then try to input the names of the album into the automaton character by character with DFS on the aforementioned tree feeding a character to the automaton when we enter a node and reverting the automaton to the previous state when we leave that node Suppose that when we are in the vertex corresponding to the th song the automaton is in state If is a terminal state corresponding to some string from the queries it means that the string from the query is a suffix of the th song But some other strings can also be the suffixes of the same song to find all such strings we can start ascending from the state to the root of Aho Corasick automaton using suffix links or dictionary links Since suffix links can be represented as the edges of some rooted tree then we can build some data structure on this tree that allows adding an integer to all vertices on the path from the root to the given vertex for example we can use Fenwick tree over Euler tour of the tree Then to check whether some string from the query is a suffix of the song we may add to all vertices on the path to state and then check the value in the state corresponding to Okay what about counting the occurences of in Let s consider the path from the root to in the song tree Every vertex on this path corresponds to some prefix of the song so we can add on the path to state corresponding to some prefix and then extract the answer from the state corresponding to In fact that s all we have to do to obtain a solution Build an automaton on strings from queries a tree of suffix links over this automaton and a data structure on this tree for each vertex of the song tree store all queries to it Then run a DFS on the song tree When we enter some vertex input the corresponding character into the automaton and add to all states from the root of suffix link tree to the current state when we have to process queries to the current vertex extract the values from the data structure and when we leave a vertex subtract from all states from the root of suffix link tree to the current state and revert to the previous state This solution has complexity of where is the total length of all strings in the input ,0
221,You are playing one famous sandbox game with the three dimensional world The map of the world can be represented as a matrix of size where the height of the cell is You are in the cell right now and want to get in the cell You can move only down from the cell to the cell or right from the cell to the cell There is an additional if the height of the current cell is then you can move only to the cell with height you can perform several operations During one operation you can decrease the height of cell by one I e you choose some cell and assign set Note that you make heights Also note that you decrease the height of the cell Your task is to find the number of operations you have to perform to obtain at least one suitable path from the cell to the cell It is guaranteed that the answer exists You have to answer independent test cases ,Since we must use exactly colors each element that occurs in the sequence may have no more than painted occurrences for each element its occurrences where is the number of all its occurrences in the sequence Let be a sequence of all elements that occur in the sequence but in the sequence they will occur only once Let s create a indexed array in which we will add indices of occurrences of in the sequence then the selected occurrences of and so on till Currently is a set of occurrences which wonderful coloring is a wonderful coloring of the whole sequence because if we want to paint an occurrence outside we can do it only by selecting an occurrence of the same element in which we will not paint so that no more than occurrences will be painted We must use exactly colors and paint for each color an equal number of occurrences hence if we want to paint all occurrences from we must remove from it the minimum number of occurrences so that the size of the array will be divided by i e remove the number of occurrences equal to the remainder of dividing the size of by We can remove any occurrences for example let s delete it from the suffix of Currently we can paint all occurrences from using the following rule the occurrence we must paint in the color with a number where takes the remainder of dividing the left operand by the right operand So all occurrences from will be painted and all colors will be used Since all occurrences of one element belong to one subsegment of and their number isn t greater than they will be painted in different colors It may be so that the array before painting will be empty In this case the wonderful coloring of doesn t contain any painted element ,0
222,Apart from having lots of holidays throughout the year residents of Berland also have whole years Year is considered if it has no more than non zero digit in its number So years 100 40000 5 are and 12 3001 and 12345 are not You are given current year in Berland Your task is to find how long will residents of Berland wait till the next year ,First of all let s analyze how can we calculate the minimum number of powers of two needed to get as the sum We can use binary representation of each bit in it which is equal to becomes a summand in the answer Firstly if the number of summands is greater than then the answer is Okay what if we don t have enough summands Every summand can be broken down into two summands equal to Let s maintain all summands greater than somewhere stack array queue multiset anything you want and pick an arbitrary summand and break it into two until we have exactly summands If then this process will terminate since we will have some summand to pick until all of them are equal to ,0
223,There are cities along the road which can be represented as a straight line The th city is situated at the distance of kilometers from the origin All cities are situated in the same direction from the origin There are trucks travelling from one city to another Each truck can be described by integers starting city finishing city fuel consumption and number of possible refuelings The th truck will spend litres of fuel per one kilometer When a truck arrives in some city it can be refueled but refueling is impossible in the middle of nowhere The th truck can be refueled at most times Each refueling makes truck s gas tank full All trucks start with full gas tank All trucks will have gas tanks of the same size litres You should find minimum possible such that all trucks can reach their destinations without refueling more times than allowed ,First bonus solution implement idea from Blogewoosh 6 Time complexity will be somewhat and space complexity is Honest solution Note that for each truck lower bound on the answer is where is optimal partition of on segments partition which minimize maximum length of segment and doesn t depend on of truck So it enough to calculate optimal partition of segment on segments Let be position where last segment starts in partition with value Note that On the other hand But and then is somewhat convex Finally best is no more than And we can look at as second pointer along with as first pointer So we can for each move while answer relaxes while answer is decreasing or staying same In result for each and there will be operations in total Optimizing memory consumption is easy if we notice that we can iterate over but not save it as state of dp In the end time complexity is and space complexity is ,1
224,You are given a bipartite graph with vertices in the first part vertices in the second part and edges The maximum matching in this graph is the maximum possible by size subset of edges of this graph such that no vertex is incident to more than one chosen edge You have to process two types of queries to this graph remove the number of vertices from this graph so that the size of the maximum matching gets reduced and print the vertices that you have removed Then find any maximum matching in this graph and print the sum of indices of edges belonging to this matching query of this type will be asked only after a query of type As the answer to this query you have to print the edges forming the maximum matching you have chosen in the previous query Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query Use functions in and in languages after each writing in your program ,Let s start by finding the maximum matching in the given graph Since the constraints are pretty big you need something fast The model solution converts the matching problem into a flow network and uses Dinic to find the matching in but something like heavily optimized Kuhn s algorithm can also work Okay then what about finding the minimum possible number of vertices to delete in order to reduce the maximum matching We claim that it is always enough to remove one vertex and the proof will also provide a way to quickly search for such vertices Let s recall that the size of the maximum matching is equal to the size of the minimum vertex cover So we will try to find a way to reduce the minimum vertex cover by and it s actually pretty easy just remove any vertex belonging to the vertex cover it s obvious that it reduces the vertex cover by and the maximum matching by as well So we can find the minimum vertex cover in the graph using the standard algorithm to convert the MM into MVC or if you re using Dinic to find the maximum matching you can represent the minimum vertex cover as the minimum cut problem and for each query of type just take a vertex from the vertex cover we found Now the only thing that s left is discussing how to maintain the structure of the maximum matching in the graph In fact it s quite easy on the one hand since we remove the vertices belonging to the minimum vertex cover every edge including the edges from the matching will be incident to one of the vertices we will remove on the other hand due to the definition of the maximum matching there is no vertex that is incident to two or more edges from the maximum matching so every vertex from the vertex cover has exactly one edge from the maximum matching that is incident to it and when we remove a vertex we can simply remove the corresponding edge from the maximum matching So the only thing we need to do is to maintain which edge from the matching corresponds to which vertex from the minimum vertex cover and it will allow us to maintain the structure of the maximum matching and since these pairs don t change when we remove a vertex it is enough to get this information right after we have constructed the maximum matching in the given graph we won t need to rebuild it ,1
225,Recently Vova found candy wrappers He remembers that he bought candies during the first day candies during the second day candies during the third day candies during the th day But there is an issue Vova remembers neither nor but he is sure that and are positive integers and Vova will be satisfied if you tell him integer so there is an integer that It is guaranteed that at least one solution exists You have to answer independent test cases ,Notice that sum limits i 0 k 1 2 i 2 k 1 Thus we can replace the initial equation with the following 2 k 1 x n So we can iterate over all possible k in range 2 29 because 2 30 1 10 9 and check if n is divisible by 2 k 1 If it is then we can print x frac n 2 k 1 P S I know that so many participants found the formula sum limits i 0 k 1 2 i 2 k 1 using geometric progression sum but there is the other way to understand this and it is a way more intuitive for me Just take a look at the binary representation of numbers we can notice that 2 0 1 2 1 10 2 2 100 and so on Thus 2 0 1 2 0 2 1 11 2 0 2 1 2 2 111 and so on And if we add one to this number consisting of k ones then we get 2 k ,1
226,Let be the length of the longest common prefix of strings and Also let be the substring of from index to index inclusive For example if then You are given a string of length and queries Each query is a pair of integer sets and Calculate for each query ,At first implement your favourite string suffix structure for comparing pair of suffixes lexicographically fast enough For example it s a Suffix Array linear LCP Sparse Table Now we can compare two suffixes and by finding and comparing with We will process queries online Let current query be a pair of arrays and We will calculate answer in two parts To calculate the first sum we can sort all suffixes in lexicographical order and maintain some information for prefixes of What information we need to maintain We need some Data Structure which will hold of suffixes from When we process some we need just a total sum of all in the DS If we should add to the DS length of th suffix And when we move from to we must recalculate some Since is sorted all we need is to set In fact this Data Structure is just a In this we will hold for each length number of suffixes with we will hold only non zero values When we should add some suffix we manually increase some value by one Setting with can be done with decreasing maximum in while its more than It can be proven that there will be operations with for one query The total sum can be maintained in some global variable which will be recalculated each time changes To calculate the second sum we can just reverse and run the same algorithm So total complexity is ,1
227,You are given a directed graph consisting of vertices Each directed edge or arc labeled with a single character Initially the graph is empty You should process queries with it Each query is one of three types add arc from to with label It s guaranteed that there is no arc in the graph at this moment erase arc from to It s guaranteed that the graph contains arc at this moment find the sequence of vertices such that there exist both routes and and if you write down characters along both routes you ll get the same string You can visit the same vertices any number of times ,At first if there should be both routes and then there are both arcs and i e there should exist at least one pair that both arcs and are present in the graph Now if is odd and we have at least one pair then we can simply create sequence This sequence is a palindrome so obviously both routes generate the same string If is even or we can note that in the sequence there is a middle arc and it should have the same character as arc since it s a middle arc in reverse route i e there should exist at least one pair that both arcs and are present in the graph and have the same label Now if we have at least one such pair then routes and generate the same one letter strings Since each arc is a part of at most one pair we can just maintain two sets with pairs one for pairs with different labels and the other one for pairs with equal labels If is odd we check that at least one of the sets is not empty If is even we check that the second set is not empty ,1
228,You are given a chessboard of size It is filled with numbers from to in the following way the first numbers from to are written in the cells with even sum of coordinates from left to right from top to bottom The rest numbers from to are written in the cells with odd sum of coordinates from left to right from top to bottom The operation means division by rounded up For example the left board on the following picture is the chessboard which is given for and the right board is the chessboard which is given for You are given queries The th query is described as a pair The answer to the th query is the number written in the cell is the row is the column Rows and columns are numbered from to ,Let s see the following fact if we will decrease from all numbers written in cells with an odd sum of coordinates and write out the numbers obtained on the board from left to right from top to bottom the sequence will looks like for even for odd there is only one number at the end of the sequence but in general it does not matter Let s try to find out the answer for some query Let 1 indexed There is the position of our cell in order of the written sequence The first approximation of the answer is But now we are remember that we decreased from all numbers written in cells with an odd sum of coordinates So if is even then the answer is otherwise the answer is Note that you should be careful with integer overflow in C Java or similar languages 64 bit datatype is quite enough Time complexity ,1
229,This year Alex has finished school and now he is a first year student of Berland State University For him it was a total surprise that even though he studies programming he still has to attend physical education lessons The end of the term is very soon but unfortunately Alex still hasn t attended a single lesson Since Alex doesn t want to get expelled he wants to know the number of working days left until the end of the term so he can attend physical education lessons during these days But in BSU calculating the number of working days is a complicated matter There are days left before the end of the term numbered from to and initially all of them are working days Then the university staff sequentially publishes orders one after another Each order is characterised by three numbers and If then all days from to inclusive become non working days If some of these days are made working days by some previous order then these days still become non working days If then all days from to inclusive become working days If some of these days are made non working days by some previous order then these days still become working days Help Alex to determine the number of working days left after each order , if an undirected graph is disconnected then its complement is connected Similarly if its complement is disconnected then the graph itself is connected suppose a graph is disconnected Pick two vertices and from different components Every vertex outside of s component is connected to in the complement and every vertex outside of s component is connected to in the complement the complement also contains the edge from to so all vertices in the complement graph belong to the single component Why do we need this lemma at all We can treat the graph formed by blue edges as the complement to the graph formed by red edges So if the red graph is disconnected then the blue graph is connected so we don t need to consider the case when some set of vertices is connected by neither color We only need to make sure that no set of vertices is connected by both colors Let be the answer for Every graph counted in is either red disconnected or blue disconnected since there is a bijection between red disconnected and blue disconnected graphs you can flip the colors of all edges to transform one type into the other we will count only red disconnected graphs and multiply it by Let be the number of blue connected graphs with vertices meeting the properties of the problem statement It s easy to see that if otherwise the case is special because a graph on one vertex is both red connected and blue connected To calculate let s iterate on the number of vertices which are in the same red component as This component must be a red connected graph which meets the problem statement so the number of ways to build the graph on these vertices is there are ways to choose the vertices in the same component as and the remaining graph can be either red connected or blue connected so the number of ways to build the remaining graph is Thus we get the following two relations We can calculate all values with dynamic programming using these formulas in ,0
230,A positive integer is called a if it can be represented as where is a non negative integer So the are You are given two positive integers and Your task is to represent as the of ,First of all let s analyze how can we calculate the minimum number of powers of two needed to get as the sum We can use binary representation of each bit in it which is equal to becomes a summand in the answer Firstly if the number of summands is greater than then the answer is Okay what if we don t have enough summands Every summand can be broken down into two summands equal to Let s maintain all summands greater than somewhere stack array queue multiset anything you want and pick an arbitrary summand and break it into two until we have exactly summands If then this process will terminate since we will have some summand to pick until all of them are equal to ,1
231,You are given an array consisting of integers and queries to it th query is denoted by two integers and For each query you have to find integer that occurs in the subarray of from index to index a subarray is a contiguous subsegment of an array For example if then for query the subarray we are interested in is and possible answers are and for query the subarray we are interested in is and there is no such element that occurs exactly once Can you answer all of the queries ,Let s rewrite the inequality from to This looks much simpler Let s build the array where and sort this array Now our problem is to find the number of pairs such that Let s iterate over all elements of from left to right For simplicity we consider only greater summands Because our sum must be greater than then at least one of these summands will be positive So if just skip it Now and we need to calculate the number of such that and It means that each for some will be okay Such leftmost position can be found with or binary search Then add the value to the answer and consider the next element Time complexity ,0
232,You are given an undirected connected graph consisting of vertices and edges Your goal is to destroy all edges of the given graph You may choose any vertex as the starting one and begin walking from it along the edges When you walk along an edge you destroy it Obviously you cannot walk along an edge if it is destroyed You can perform the operation at most once during your walk and this operation can only be performed when you are at some vertex you cannot perform it while traversing an edge After the the edges you go through are deleted in the following way the first edge after the is not destroyed the second one is destroyed the third one is not destroyed the fourth one is destroyed and so on You cannot switch back to the original mode and you don t have to perform this operation if you don t want to Can you destroy all the edges of the given graph ,In order to build lexicographically minimal co growing with sequence it is enough to build its elements iteratively beginning from and minimizing the th element assuming that have already been found Assign According to the statement all elements of the sequence are non negative so cannot be less than zero It turns out that is the minimal possible first element The existence of an answer with follows from the construction algorithm described below Let s use mathematical induction and construct under the assumption that all the previous elements of the sequence have already been constructed In order to satisfy the condition for the growth of the final sequence the number must contain one bits at all places but not necessarily limited to them on which there are one bits in the number Let s denote for and find out what bits can be in to satisfy this condition If in stands bit then independently from in at the same spot we can place any bit because there is no limit on the corresponding bit in If in stands bit and in then the corresponding bit in should be equal so that in the corresponding bit also equals one If in and in stands bit then in should be bit at the corresponding place for the same reasons The bit transformation described above can be given by the expression Indeed this expression gives us bit one at the fixed position if and only if at that place in stands bit and in stands bit For the full solution it remains only to apply this formula in a loop from to ,0
233,The Berland language consists of words having Moreover Any combination of two different Berland letters which by the way are the same as the lowercase letters of Latin alphabet is a correct word in Berland language The Berland dictionary contains all words of this language The words are listed in a way they are usually ordered in dictionaries Formally word comes earlier than word in the dictionary if one of the following conditions hold the first letter of is less than the first letter of the first letters of and are the same and the second letter of is less than the second letter of So the dictionary looks like that Word Word Word Word Word Word Word You are given a word from the Berland language Your task is to find its index in the dictionary ,Let eq i j equals true if words s i and s j are equal otherwise it will be equals false We can iterate over all pairs of words and compare they just using standard string comparator constraints are really small so we can do it naively The next step is to calculate dynamic programming dp i j which will be equal to the maximum length of coinciding segments of words which starts in positions i and j respectively In other words if dp i j equals k then s i i k 1 s j j k 1 word by word We can calculate this dynamic programming in reverse order i n 1 0 j n 1 0 and dp i j 0 if s i ne s j else if i n 1 and j n 1 then dp i j dp i 1 j 1 1 otherwise dp i j 1 Let s keep the length of the text in the variable allsum Then iterate over all starting positions of the possible abbreviation and all its possible lengths Let the current starting position will be equals i 0 indexed and its length will be equal j Then we need to calculate the number of possible replacements by its abbreviation Let it be cnt and now it equals 1 Let s iterate over all positions pos at the beginning pos i j 0 indexed If dp i pos ge j then we can replace the segment of words which starts at the position pos with its abbreviation so cnt cnt 1 and pos pos j because we cannot replace intersecting segments otherwise pos pos 1 After this we need to update the answer The length of the segment of words s i j can be calculated easily let it be seglen Also let segcnt be the number of words in the current segment of words Then we can update the answer with the value allsum seglen cnt cnt segcnt Overall complexity is O n 3 n cdot sum limits i 0 n 1 s i where s i is the length of the i th word ,0
234,Let s say you are standing on the plane at point and you want to reach point You can move only in two directions to the i e horizontally and in the direction that increase your coordinate or i e vertically and in the direction that increase your coordinate In other words your path will have the following structure initially you choose to go to the right or up then you go some distance in the chosen direction distances can be chosen independently after that you change your direction from right to up or from up to right and repeat the process You don t like to change your direction too much so you will make no more than direction changes As a result your path will be a polygonal chain from to consisting of line segments where each segment has positive integer length and vertical and horizontal segments alternate Not all paths are equal You have integers where is the cost of the th segment Using these costs we can define the as the sum of lengths of the segments of this path multiplied by their cost i e if the path consists of segments then the cost of the path is equal to segments are numbered from to in the order they are in the path Find the path of the minimum cost and print its cost ,Let s define as the number of leaves in the subtree of the th edge of course in terms of vertices in the subtree of the lower vertex of this edge Values of can be calculated with pretty standard and simple dfs and dynamic programming Then we can notice that our edges are independent and we can consider the initial answer sum of weights of paths as Let be the difference between the current impact of the th edge and the impact of the th edge if we divide its weight by This value means how the sum of weights decreases if we divide the weight of the th edge by Create ordered set which contains pairs Then the following greedy solution works let s take the edge with maximum and divide its weight by Then re add it into the set with new value When the sum becomes less than or equal to just stop and print the number of divisions we made The maximum number of operations can reach so the solution complexity is each operation takes time because the size of the set is ,0
235,You are given two integers and Your task is to construct such a string of length that for each from to there is at least one th letter of the Latin alphabet in this string the first letter is a the second is b and so on and there are no other letters except these You have to of some letter the frequency of a letter is the number of occurrences of this letter in a string If there are several possible answers you can print You have to answer queries ,The only thing you need to do is to place letters by blocks and so on The last block can contain less than letters but it is ok It is easy to see that this letters distribution is always not worse than others ,1
236,You are given a string consisting of lowercase Latin letters A pair of letters in a string is considered ugly if these letters are also in a alphabet For example string contains ugly pairs at positions and Letters and aren t considered neighbouring in a alphabet Can you rearrange the letters of a given string so that there are no ugly pairs You can choose any order of the letters of the given string but you can t add any new letters or remove the existing ones You can also leave the order the same If there are multiple answers print any of them You also have to answer separate queries ,To be honest the solution to this problem is easier to code than to prove Let s follow the next strategy Write down all the letters of the string which have odd positions in alphabet and even positions in alphabet Sort both of these lists in non decreasing order The answer is either concatenation of the lists odd even or even odd or Now for the proof part Let s establish that we don t care about equal letters and leave just a single copy of each letter of the string Let s check some cases There is just a single letter That s trivial There are two letters of the same parity There is no incorrect arrangement for this There are two letters of different parity If they differ by one then no answer exists Otherwise any arrangement works There are three letters and they are consecutive in alphabet No answer exists There are other types of three letters Then the one of the different parity can put on the side e g and As the difference between at least one of these letters and that one isn t 1 that arrangement will be ok Finally there are at least 4 letters It means that the difference between either the smallest odd and the largest even or between the smallest even and the largest odd isn t 1 The only thing you need to do is to implement the check function the most straightforward way possible and check both arrangements Overall complexity ,1
237,You are playing a computer game To pass the current level you have to kill a big horde of monsters In this horde there are monsters standing in the row numbered from to The th monster has health and a special Death s Blessing spell of strength attached to it You are going to kill all of them It takes exactly seconds to kill a monster with health When the th monster dies it casts its spell that increases the health of its by the neighbors of the th monster in the row are the monsters on places and The first and the last monsters have only one neighbor each After each monster is killed the row shrinks so its former neighbors become adjacent to each other so if one of them dies the other one is affected by its spell For example imagine a situation with monsters with health and spells One of the ways to get rid of the monsters is shown below As a result we can kill all monsters in seconds Note that it s only an example and may not be the fastest way to get rid of the monsters What is the minimum time required to kill all monsters in the row ,We will model the problem as the minimum cut in a flow network Build a network as follows create a source node a sink node and a vertex for every number from to Let s say that we are going to find the minimum cut in this network and the vertices belonging to the same cut part with represent the numbers that are taken into the answer Using the edges of the network we should model these constraints taking an element that depends on another element should force us to take as well taking an element with should add to our score taking an element with should subtract from our score Constraint can be modeled in the following way for every pair such that element depends on element and add a directed edge with infinite capacity from to That way if is taken and is not the value of the cut will be infinite because of this edge and this cut cannot be minimum Constraint is modeled in the following way for every such that add a directed edge with capacity from to That way if we take some element with into the answer is added to the value of the cut And for constraint for every such that add a directed edge with capacity from to That way if we take some element with is added to the value of the cut It s now easy to see that the answer is since it is exactly the sum of elements that were taken for positive elements we add them all up and then subtract the ones that don t belong to the answer for negative ones we just subtract those which belong to the answer To find a minimum cut just run maximum flow in this network There s one caveat though If for example all are equal or many are divisible by many other values in this network can contain edges To reduce the number of edges let s see that if for some index there exist two equal divisors of to the left of it let s say that these divisors are and then we only need to add an edge from to because taking also should force taking into the answer So for every divisor of we are interested in only one closest occurrence of this divisor to the left and we need to add a directed edge only to this occurrence and ignore all other occurrences That way for every vertex we add at most edges to other vertices where is the number of divisors of It can be proven that any maximum flow algorithm that relies on augmenting paths will finish after iterations in this network so it won t work longer than and both and are proportional to so any maximum flow solution will run in ,0
238,Let s define for a positive integer as the length of the base 10 representation of without leading zeros I like to call it a digital logarithm Similar to a digital root if you are familiar with that You are given two arrays and each containing positive integers In one operation you do the following pick some integer from to assign either to or to Two arrays are considered similar to each other if you can rearrange the elements in both of them so that they are equal e g for all from to What s the smallest number of operations required to make and similar to each other ,The solution of this problem is based on Dilworth s theorem You can read about it on Wikipedia In two words this theorem says that the minimum number of non decreasing sequences we need to cover the whole sequence equals the length of longest decreasing subsequence Let s calculate the dynamic programming the length of longest decreasing sequence that ends in the position To recalculate this dynamic let s carry the array of length where means the maximum value of for the character on the prefix we already considered So initially all are ones all values of are zeros For the position we update with and update with Okay how to restore the answer That s pretty easy The color of the th character is exactly Why it is so If becomes greater than then we surely need to use the new color for this character because we cannot append it to the end of any existing sequence Otherwise we will append it to some existing sequence with the maximum possible number and because it has the maximum number and we didn t update the value of with the number of this sequence plus one the current character is not less than the last in this sequence Time complexity or ,0
239,You are given a sequence of integers You are also given integers You are asked to insert each of the extra integers into the sequence Each integer can be inserted at the beginning of the sequence at the end of the sequence or between any elements of the sequence The score of the resulting sequence is the sum of absolute differences of adjacent elements in it What is the smallest possible score of the resulting sequence ,Observe the cost of inserting a single element Notice that inserting any value between the minimum of the sequence and the maximum of the sequence is free Why is this true The argument is similar to the algorithm of finding some such that for a continous function if you know some such that and such that As a more general idea it s free to insert some value into a segment such that and WLOG assume Let s find the position that is free If then you can insert between and since it s free Otherwise you can choose an arbitrary position will be either between and or between and or both of them Descend into the one that holds to continue the search Since the lenght decreases at some point you will reach the segment of length How does that help Well you can insert somewhere then insert somewhere The rest of insertions will be free Now it s an algorithmic problem First consider all options to insert both and between the same pair of elements Next assume you insert somewhere before Iterate from left to right maintaning the lowest price to insert Try to insert at the current position and into the cheapest position before it Then update the lowest price for inserting After you finish reverse the sequence and solve the problem again that will be the same as inserting before Overall complexity per testcase ,1
240,You are given an array Count the number of pairs of indices such that ,Call a pair if it satisfies the condition Let s split the inequality into three parts Note that if for any then it can t be an element of a good pair because it fails the first and third conditions So we can throw out all elements of the array satisfying For the remaining elements the first and third inequalities are already satisfied so we only have to count the number of pairs with Let s iterate through the array from the left to the right and make a list storing all that appear before Then for each count the number of less than by binary searching on the number of elements in the list less than Afterwards add to the end of the list Since we iterate from left to right the list will always remain sorted we insert the indices of elements which are increasing from left to right so the binary search will always work The time complexity is ,1
241,We guessed some integer number You are given a list of its divisors means that there are in the list Your task is to find the minimum possible integer that can be the guessed number or say that the input data is contradictory and it is impossible to find such number You have to answer independent queries ,Let s notice that you should never say that you didn t notice signs no speed limit and overtake is allowed Also if you drive with speed you don t want to remove signs speed limit with number greater or equal to Thus greedy solution will work Process all the events in chronological order We should maintain stack of signs speed limit and amount of signs no overtake allowed If we meet sign speed limit we push its limit to stack sign no overtake allowed increase no speed limit clear stack overtake is allowed assign to zero After every event we should check if our speed is fine While value of sign on the top of the stack is less than current speed pop it and increase answer If we overtake someone we add to answer and assign to zero Overall complexity ,0
242,Two integer sequences existed initially one of them was increasing and another one decreasing Strictly increasing sequence is a sequence of integers And strictly decreasing sequence is a sequence of integers Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing Elements of increasing sequence were inserted between elements of the decreasing one and possibly before its first element and after its last element For example sequences and can produce the following resulting sequences The following sequence cannot be the result of these insertions because the order of elements in the increasing sequence was changed Let the obtained sequence be This sequence is given in the input Your task is to find two suitable initial sequences One of them should be increasing and another one decreasing If there is a contradiction in the input and it is impossible to split the given sequence into one increasing sequence and one decreasing sequence print ,First bonus solution implement idea from Blogewoosh 6 Time complexity will be somewhat and space complexity is Honest solution Note that for each truck lower bound on the answer is where is optimal partition of on segments partition which minimize maximum length of segment and doesn t depend on of truck So it enough to calculate optimal partition of segment on segments Let be position where last segment starts in partition with value Note that On the other hand But and then is somewhat convex Finally best is no more than And we can look at as second pointer along with as first pointer So we can for each move while answer relaxes while answer is decreasing or staying same In result for each and there will be operations in total Optimizing memory consumption is easy if we notice that we can iterate over but not save it as state of dp In the end time complexity is and space complexity is ,0
243,You are given a garland consisting of lamps States of the lamps are represented by the string of length The th character of the string equals if the th lamp is turned off or if the th lamp is turned on You are also given a positive integer In one move you can choose and change its state i e turn it on if it is turned off and vice versa The garland is called periodic if the distance between is Consider the case Then garlands and are good but garlands and are not Note that i e the first turned on lamp is not going after the last turned on lamp and vice versa Your task is to find the number of moves you need to make to obtain periodic garland from the given one You have to answer independent test cases ,So the first idea that is coming into mind is prefix sums Let s define two values and The value means the amount of fall damage when we are going to the right from the column to the column and means the amount of fall damage when we are going to the left from the column to the column Then let s build prefix sums on these two arrays Now let be the sum of all on a prefix i e and be the sum of all on a prefix Then if in a query the answer is otherwise if the answer is Time complexity ,0
244,Let s denote the function for a string as the number of distinct characters that the string contains For example and Given a string split it into two non empty strings and such that is the maximum possible In other words find the maximum possible value of such that the concatenation of string and string is equal to string ,Let s check all splitting points for all We denote a splitting point as the last index of the first string we take and all the remaining characters will go to the second string We need to keep a dynamic count of the number of distinct characters in both strings the first string and the second string We can do this using two frequency arrays and adding one to the distinct count of either string or when the frequency of a character is greater than zero ,1
245,The elections in which three candidates participated have recently ended The first candidate received votes the second one received votes the third one received votes For each candidate solve the following problem how many votes should be added to this candidate so that he wins the election i e the number of votes for this candidate was strictly greater than the number of votes for any other candidate Please note that for each candidate it is necessary to solve this problem i e the added votes for any candidate affect the calculations when getting the answer for the other two candidates ,If you have at least units of energy then the answer is because you can just walk to the end Otherwise the answer is because you can just sit on the first bench and then just go Time complexity ,0
246,You play your favourite game yet another time You chose the character you didn t play before It has points of strength and points of intelligence Also at start the character has free experience points you can invest either in strength or in intelligence by investing one point you can either raise strength by or raise intelligence by Since you d like to make some fun you want to create a jock character so it has more strength than intelligence points resulting strength is than the resulting intelligence Calculate the number of different character builds you can create for the purpose of replayability if you must Two character builds are different if their strength and or intellect are different ,Let and be number of free points that we invest in the strength and intelligence respectively It s obvious that since we must spend all free points From the other side we must make Now we can expess and put it in the inequality Since must be non negative we can get We can use or write the correct ceiling function that works with negative numerator or use one hack and magic and get with usual integer division Let s denote this value as Since all integer values from are good for us so the number of pairs is equal to P S Let me explain how to prove that is equal to P P S Interesting fact the formula above works for all positive and thats why it works in our case even though can be negative ,1
247,Three friends are going to meet each other Initially the first friend stays at the position the second friend stays at the position and the third friend stays at the position on the coordinate axis In one minute from other friends can change the position by to the left or by to the right i e set or or even don t change it Let s introduce the total pairwise distance the sum of distances between each pair of friends Let and be the final positions of the first the second and the third friend correspondingly Then the total pairwise distance is where is the absolute value of Friends are interested in the minimum total pairwise distance they can reach if they will move optimally So more formally they want to know the minimum total pairwise distance they can reach after one minute You have to answer independent test cases ,This problem can be solved with simple simulation Let be the new position of the first friend and are new positions of the second and the third friends correspondingly For the fixed positions you can update the answer with the value And iterating over three positions can be implemented with nested loops Time complexity per test case ,1
