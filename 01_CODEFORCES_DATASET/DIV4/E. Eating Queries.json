{"link": "https://codeforces.com//contest/1676/problem/E", "problemId": "1394657", "shortId": "1676E", "contest_number": "1676", "name": "E. Eating Queries", "statement": "Timur has  candies. The -th candy has a quantity of sugar equal to . So, by eating the -th candy, Timur consumes a quantity of sugar equal to .Timur will ask you  queries regarding his candies. For the -th query you have to answer what is the  number of candies he needs to eat in order to reach a quantity of sugar   or print  if it's not possible to obtain such a quantity. In other words, you should print the minimum possible  such that after eating  candies, Timur consumes a quantity of sugar of at least  or say that no possible  exists.Note that he can't eat the same candy twice and queries are independent of each other (Timur can use the same candy in different queries).", "input": "The first line of input contains a single integer  () \u00a0\u2014 the number of test cases. The description of test cases follows. The first line contains  integers  and  ()\u00a0\u2014 the number of candies Timur has and the number of queries you have to print an answer for respectively. The second line contains  integers  ()\u00a0\u2014 the quantity of sugar in each of the candies respectively. Then  lines follow.  Each of the next  lines contains a single integer  ()\u00a0\u2013 the quantity Timur wants to reach for the given query. It is guaranteed that the sum of  and the sum of  over all test cases do not exceed .", "output": "For each test case output  lines. For the -th line output the number of candies Timur needs to eat in order to reach a quantity of sugar greater than or equal to  or print  if it's not possible to obtain such a quantity.", "tutorial": "Let's solve the problem with just one query. Greedily, we should pick the candies with the most sugar first, since there is no benefit to picking a candy with less sugar.So the solution is as follows: sort the candies in descending order, and then find the prefix whose sum is . This is  per query, which is too slow for us.To speed it up, notice that we just need to find a prefix sum at least . So if we compute the prefix sums of the reverse-sorted array, we need to find the first element that is at least .Since all elements of  are positive, the array of prefix sums is increasing. Therefore, you can binary search the first element . This solves the problem in  per query.Total time complexity: .", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {  \n    int t; cin >> t;\n    while(t--) {\n        int n, q; cin >> n >> q;\n        vector<long long> a(n), p(n);\n        for(int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        sort(a.rbegin(), a.rend());\n        for(int i = 0; i < n; ++i) {\n            p[i] = (i ? p[i - 1] : 0) + a[i];\n        }\n    \n        while(q--) {\n            long long x; cin >> x;\n            int l = 1, r = n, ans = -1;\n            while(l <= r) {\n                int mid = (l + r) / 2;\n                if(p[mid - 1] >= x) {\n                    ans = mid;\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            cout << ans << \"\\n\";\n        }\n    }\n}   ", "interactive": false, "noSolution": false, "noTutorial": false}