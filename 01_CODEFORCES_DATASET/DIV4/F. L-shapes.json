{"link": "https://codeforces.com//contest/1722/problem/F", "problemId": "1524438", "shortId": "1722F", "contest_number": "1722", "name": "F. L-shapes", "statement": "An L-shape is a figure on gridded paper that looks like the first four pictures below. An L-shape contains exactly three shaded cells (denoted by ), which can be rotated in any way.  You are given a rectangular grid. Determine if it contains L-shapes only, where L-shapes can't touch an edge or corner. More formally:   Each shaded cell in the grid is part of exactly one L-shape, and  no two L-shapes are adjacent by edge or corner. For example, the last two grids in the picture above  satisfy the condition because the two L-shapes touch by corner and edge, respectively.", "input": "The input consists of multiple test cases. The first line contains an integer  ()\u00a0\u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains two integers  and  ()\u00a0\u2014 the number of rows and columns in the grid, respectively. Then  lines follow, each containing  characters. Each of these characters is either '' or ''\u00a0\u2014 an empty cell or a shaded cell, respectively.", "output": "For each test case, output \"\" if the grid is made up of L-shape that don't share edges or corners, and \"\" otherwise. You can output the answer in any case (for example, the strings \"\", \"\", \"\" and \"\" will be recognized as a positive answer).", "tutorial": "The problem is mainly a tricky implementation problem. Let's denote the  of an L-shape as the square in the middle (the one that is side-adjacent to two other squares). Every elbow is part of exactly one L-shape, and every L-shape has exactly one elbow.Iterate through the grid and count the number of side-adjacent neighbors they have. If there is a cell with more than 2, or if there is a cell with exactly two neighbors on opposite sides, then the answer is . Otherwise, if there are exactly 2 neighbors, this cell is an elbow. Mark all three cells of this L-shape with a unique number (say, mark the first one you find with , the second with , and so on.) If you ever remark a cell that already has a number, then two elbows are adjacent, and you can output .After all elbows are marked, check if all shaded cells have a number. If some don't, then they are not part of an L-shape, so you can output .Finally, we should check that L-shapes don't share edge or corner. Just check, for each number, if it is only diagonally adjacent to other numbers equal to it or unshaded cells. If it is diagonally adjacent to other unequal numbers, then the answer is , because two L-shapes share an edge or corner then.Otherwise the answer is .There are many other solutions, all of which are various ways to check the conditions. The complexity is  per testcase.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 200007;\nconst int MOD = 1000000007;\n\nconst int dx[3] = {-1, 0, 1}, dy[3] = {-1, 0, 1};\n\nvoid solve() {\n\tint n, m;\n\tcin >> n >> m;\n\tchar g[n][m];\n\tint id[n][m];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcin >> g[i][j];\n\t\t\tid[i][j] = 0;\n\t\t}\n\t}\n\tint curr = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (g[i][j] == '*') {\n\t\t\t\tvector<pair<int, int>> adjh, adjv;\n\t\t\t\tif (i > 0 && g[i - 1][j] == '*') {\n\t\t\t\t\tadjh.emplace_back(i - 1, j);\n\t\t\t\t}\n\t\t\t\tif (i < n - 1 && g[i + 1][j] == '*') {\n\t\t\t\t\tadjh.emplace_back(i + 1, j);\n\t\t\t\t}\n\t\t\t\tif (j > 0 && g[i][j - 1] == '*') {\n\t\t\t\t\tadjv.emplace_back(i, j - 1);\n\t\t\t\t}\n\t\t\t\tif (j < m - 1 && g[i][j + 1] == '*') {\n\t\t\t\t\tadjv.emplace_back(i, j + 1);\n\t\t\t\t}\n\t\t\t\tif (adjh.size() == 1 && adjv.size() == 1) {\n\t\t\t\t\tif (id[i][j] == 0) {id[i][j] = curr;}\n\t\t\t\t\telse {cout << \"NO\\n\"; return;}\n\t\t\t\t\tif (id[adjh[0].first][adjh[0].second] == 0) {id[adjh[0].first][adjh[0].second] = curr;}\n\t\t\t\t\telse {cout << \"NO\\n\"; return;}\n\t\t\t\t\tif (id[adjv[0].first][adjv[0].second] == 0) {id[adjv[0].first][adjv[0].second] = curr;}\n\t\t\t\t\telse {cout << \"NO\\n\"; return;}\n\t\t\t\t\tcurr++;\n\t\t\t\t}\n\t\t\t\telse if (adjh.size() > 1 || adjv.size() > 1) {\n\t\t\t\t\tcout << \"NO\\n\"; return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (g[i][j] == '*') {\n\t\t\t\tif (id[i][j] == 0) {cout << \"NO\\n\"; return;}\n\t\t\t\telse {\n\t\t\t\t\tfor (int x = 0; x < 3; x++) {\n\t\t\t\t\t\tfor (int y = 0; y < 3; y++) {\n\t\t\t\t\t\t\tif (0 <= i + dx[x] && i + dx[x] < n) {\n\t\t\t\t\t\t\t\tif (0 <= j + dy[y] && j + dy[y] < m) {\n\t\t\t\t\t\t\t\t\tif (id[i + dx[x]][j + dy[y]] != id[i][j] && id[i + dx[x]][j + dy[y]] != 0) {\n\t\t\t\t\t\t\t\t\t\tcout << \"NO\\n\"; return;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}