{"link": "https://codeforces.com//contest/1807/problem/C", "problemId": "1838163", "shortId": "1807C", "contest_number": "1807", "name": "C. Find and Replace", "statement": "You are given a string  consisting of lowercase Latin characters. In an operation, you can take a character and replace  occurrences of this character with  or replace  occurrences of this character with .Is it possible to perform some number of moves so that the resulting string is an alternating binary string? For example, consider the string . You can perform the following moves:   Replace  with . Now the string is .  Replace  with . Now the string is .  Replace  with . Now the string is . This is an alternating binary string. An  is a string of s and s such that no two adjacent bits are equal. For example, , ,  are alternating binary strings, but , ,  are not.", "input": "The input consists of multiple test cases. The first line contains an integer  ()\u00a0\u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains an integer  ()\u00a0\u2014 the length of the string . The second line of each test case contains a string consisting of  lowercase Latin characters\u00a0\u2014 the string .", "output": "For each test case, output \"\" (without quotes) if you can make the string into an alternating binary string, and \"\" (without quotes) otherwise. You can output the answer in any case (for example, the strings \"\", \"\", \"\" and \"\" will be recognized as a positive answer).", "tutorial": "Let's solve a harder problem: given a string  and a binary string , can we make  into  using the find and replace operations?We can simply iterate through each character of  and see the bit it has turned to in  (that is,  for each ). Keep track of each change, and see if there is some letter that needs to be turned into both  and . If there is some letter, it is impossible, since each operation requires changing all occurrences of a letter into the same bit. Otherwise, it is possible, and we can directly change each letter into the bit it needs to be. (See the implementation for a better understanding.)Now for this problem, since there are only two alternating binary strings of length  ( and ), we can simply check both. (Actually, we only have to check one\u00a0\u2014 do you see why?) The time complexity is .", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MAX = 200007;\nconst int MOD = 1000000007;\n \nvoid solve() {\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tint mp[26];\n\tfor (int i = 0; i < 26; i++) {\n\t\tmp[i] = -1;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint curr = (s[i] - 'a');\n\t\tif (mp[curr] == -1) {\n\t\t\tmp[curr] = (i % 2);\n\t\t}\n\t\telse {\n\t\t\tif (mp[curr] != (i % 2)) {cout << \"NO\\n\"; return;}\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n}\n \nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}\n\n", "interactive": false, "noSolution": false, "noTutorial": false}