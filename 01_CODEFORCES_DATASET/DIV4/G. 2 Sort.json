{"link": "https://codeforces.com//contest/1692/problem/G", "problemId": "1429121", "shortId": "1692G", "contest_number": "1692", "name": "G. 2 Sort", "statement": "Given an array  of length  and an integer , find the number of indices  such that the subarray  with length  ( with length ) has the following property:   If you multiply the first element by , the second element by , ..., and the ()-st element by , then this subarray is sorted in strictly increasing order.  More formally, count the number of indices  such that  ", "input": "The first line contains an integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers ,  (, )\u00a0\u2014 the length of the array and the number of inequalities. The second line of each test case contains  integers  ()\u00a0\u2014 the elements of the array. The sum of  across all test cases does not exceed .", "output": "For each test case, output a single integer\u00a0\u2014 the number of indices satisfying the condition in the statement.", "tutorial": "Note that  is the same as , since we can divide by . This means that we only need to check whether  for each pair of adjacent elements.Let's consider as an example . Note that  and , so if you multiply the first element by , the second by , and the third by , the array is sorted.So let's make a new array  where  if  and  otherwise. Then we know that the whole chain of inequalities holds true if all values in a subarray of length  in  have all their values equal to .For example, if , . Say . Then  works, since  is sorted. We can write this as  and . This is equivalent to  (since ) and  (since ). So the problem is equivalent to counting the number of subarrays of length  in  whose elements are all equal to . There are many ways to do this. For example, you can compute prefix sums and then find the sum of all subarrays of length , and count the number whose sum is . The model solution uses a sliding window and updates the number of ones in the current subarray as we move from left to right.Time complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 200007;\nconst int MOD = 1000000007;\n\nvoid solve() {\n\tint n, k;\n\tcin >> n >> k;\n\tint a[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tint ok[n];\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tok[i] = (a[i] < 2 * a[i + 1]);\n\t}\n\tint tot = 0;\n\tfor (int i = 0; i < k; i++) {\n\t\ttot += ok[i];\n\t}\n\tint res = 0;\n\tif (tot == k) {res++;}\n\tfor (int i = k; i < n - 1; i++) {\n\t\ttot += ok[i];\n\t\ttot -= ok[i - k];\n\t\tif (tot == k) {res++;}\n\t}\n\tcout << res << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n    // solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}