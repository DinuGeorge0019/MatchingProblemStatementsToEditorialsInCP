{"link": "https://codeforces.com//contest/1692/problem/D", "problemId": "1429118", "shortId": "1692D", "contest_number": "1692", "name": "D. The Clock", "statement": "Victor has a 24-hour clock that shows the time in the format \"\" (    ,     ). He looks at the clock every  minutes, and the clock is currently showing time . How many  palindromes will Victor see in total after looking at the clock every  minutes, the first time being at time ?For example, if the clock starts out as  and Victor looks at the clock every  minutes (i.e. every  hours), then he will see the times , , , , , and the times will continue to repeat. Here the time  is the only palindrome he will ever see, so the answer is .A palindrome is a string that reads the same backward as forward. For example, the times , ,  are palindromes but , ,  are not.", "input": "The first line of the input contains an integer  ()\u00a0\u2014 the number of test cases. The description of each test case follows. The only line of each test case contains a string  of length  with the format \"\" where \"\" is from \"\" to \"\" and \"\" is from \"\" to \"\" (both \"\" and \"\" have exactly two digits) and an integer  ()\u00a0\u2014 the number of minutes Victor takes to look again at the clock.", "output": "For each test case, output a single integer\u00a0\u2014 the number of different palindromes Victor will see if he looks at the clock every  minutes starting from time .", "tutorial": "Note that Victor looks at the clock forever, but there are only at most  different times the clock can show (because there are  different minutes in a day). So we only have to check the first  times Victor sees, and count the palindromes (you can check a few more just to be safe, but they will repeat anyways).Now we just have to implementing adding  minutes to a clock. There are several ways to do this. One of the slower ways might be writing functions converting a number of minutes into a time for a clock, or you can just compute all palindrome times in terms of minutes and that way you don't have to convert from clock time to number of minutes.The complexity is  per test case, since you only have to check a constant number of times. ", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a[5] = {600, 60, 0, 10, 1};\nint good[16] = {0, 70, 140, 210, 280, 350, 601, 671, 741, 811, 881, 951, 1202, 1272, 1342, 1412};\n\nvoid solve() {\n\tstring s;\n\tcin >> s;\n\tint x;\n\tcin >> x;\n\tint tot = 0;\n\tfor (int i = 0; i < 5; i++) {\n\t\ttot += (int)(s[i] - '0') * a[i];\n\t}\n\tset<int> t;\n\tfor (int i = 0; i < 2022; i++) {\n\t\tt.insert(tot);\n\t\ttot += x;\n\t\ttot %= 1440;\n\t}\n\tint res = 0;\n\tfor (int i : t) {\n\t\tfor (int j = 0; j < 16; j++) {\n\t\t\tif (good[j] == i) {res++;}\n\t\t}\n\t}\n\tcout << res << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n    // solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}