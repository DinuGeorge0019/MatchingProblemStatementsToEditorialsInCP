{"link": "https://codeforces.com//contest/1791/problem/F", "problemId": "1764446", "shortId": "1791F", "contest_number": "1791", "name": "F. Range Update Point Query", "statement": "Given an array , you need to handle a total of  updates and queries of two types:  \u00a0\u00a0\u00a0\u2014 for each index  with , update the value of  to the sum of the digits of .  \u00a0\u00a0\u2014 output . ", "input": "The first line of the input contains an integer  ()\u00a0\u2014 the number of testcases. The first line of each test case contains two integers  and  ()\u00a0\u2014 the size of the array and the number of queries, respectively. The second line of each test case contains  integers  (). The next  lines of each test case are of two forms:   \u00a0\u00a0 ()\u00a0\u2014 it means, for each index  with , you should update the value of  to the sum of its digits.  \u00a0 ()\u00a0\u2014 it means you should output .  There is at least one query of the second type. The sum of  over all test cases does not exceed . The sum of  over all test cases does not exceed .", "output": "For each test case, output the answers of queries of the second type, in the order they are given.", "tutorial": "Let  denote the sum of the digits of . The key observation is the following: after the operation is applied to index  thrice, it won't change after any further operations. The proof is provided at the bottom of the editorial.So we only need to update  if it's been updated at most  times so far; otherwise, we can ignore it. This allows us to do the following solution: store the current \"active\" indices (that is, indices that have been updated  times) in a sorted list (for example,  in C++). Then:   \u00a0\u00a0\u00a0\u2014 search for the smallest active index at least  (since the list is sorted, we can do it in ). Afterwards, update that index (replace  with ), remove it if it's no longer active, and binary search for the next largest active index in the sorted list, until we pass .  \u00a0\u00a0\u2014 just output .  Although it looks like we take  time for each update, we actually only ever update each element of the array at most  times, so we will do no more than  binary searches.Therefore the time complexity is amortized . To show this, note that initially . The maximum possible value of the sum of the digits of  is , achieved when . So .Now considering the numbers from  to , the one with maximum sum of digits is , with . Hence . Finally, considering the numbers from  to , the one with maximum sum of digits is , so . That is, after three operations,  becomes a single digit. Any further operations, and it won't change any more.", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint digit_sum(int n) {\n    int ret = 0;\n    while(n) {\n        ret += n % 10;\n        n /= 10;\n    }\n    return ret;\n}\nvoid solve() {\n    int n, q; cin >> n >> q;\n    vector<int> a(n);\n    set<int> s;\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i];\n        if(a[i] > 9) s.insert(i);\n    }\n    while(q--) {\n        int type; cin >> type;\n        if(type == 1) {\n            int l, r; cin >> l >> r; --l, --r;\n            int lst = l;\n            while(!s.empty()) {\n                auto it = s.lower_bound(lst);\n                if(it == s.end() || *it > r) break;\n                a[*it] = digit_sum(a[*it]);\n                int paiu = *it;\n                s.erase(it);\n                if(a[paiu] > 9) s.insert(paiu);\n                lst = paiu + 1;\n            }\n        } else {\n            int x; cin >> x; --x;\n            cout << a[x] << \"\\n\";\n        }\n    }\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(0);\n\tint t; cin >> t;\n\twhile(t--) {\n\t    solve();\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}