{"link": "https://codeforces.com//contest/1676/problem/H2", "problemId": "1394661", "shortId": "1676H2", "contest_number": "1676", "name": "H2. Maximum Crossings  Hard Version ", "statement": "  and the sum of  over all test cases does not exceed A  is a row of  equal segments numbered  to  in order. There are two terminals, one above the other. You are given an array  of length . For all , there should be a straight wire from some point on segment  of the top terminal to some point on segment  of the bottom terminal. You can't select the endpoints of a segment. For example, the following pictures show two possible wirings if  and .  A  occurs when two wires share a point in common. In the picture above, crossings are circled in red.What is the  number of crossings there can be if you place the wires optimally?", "input": "The first line contains an integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains an integer  ()\u00a0\u2014 the length of the array. The second line of each test case contains  integers  ()\u00a0\u2014 the elements of the array. The sum of  across all test cases does not exceed .", "output": "For each test case, output a single integer\u00a0\u2014 the  number of crossings there can be if you place the wires optimally.", "tutorial": "Read the solution of the easy version.We want to count the number of pairs  such that  and . This is a standard problem, and we can do this we can use a segment tree or BIT, for example. Insert the  from  to , and then for each  count the number of  using a BIT.It is also related to the problem of counting inversions, so you can solve it using a modification of merge sort.Either way, the solution is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 200007;\nconst int MOD = 1000000007;\n\nlong long merge(int a[], int temp[], int left, int mid, int right) {\n   int i, j, k;\n   long long count = 0;\n   i = left;\n   j = mid;\n   k = left;\n   while ((i <= mid - 1) && (j <= right)) {\n      if (a[i] <= a[j]){\n      temp[k++] = a[i++];\n      } else {\n         temp[k++] = a[j++];\n         count += (mid - i);\n      }\n   }\n   while (i <= mid - 1)\n      temp[k++] = a[i++];\n   while (j <= right)\n      temp[k++] = a[j++];\n   for (i=left; i <= right; i++)\n      a[i] = temp[i];\n   return count;\n}\nlong long mergeSort(int a[], int temp[], int left, int right){\n   int mid;\n   long long count = 0;\n   if (right > left) {\n      mid = (right + left)/2;\n      count = mergeSort(a, temp, left, mid);\n      count += mergeSort(a, temp, mid+1, right);\n      count += merge(a, temp, left, mid+1, right);\n   }\n   return count;\n}\nlong long aInversion(int a[], int n) {\n   int temp[n];\n   return mergeSort(a, temp, 0, n - 1);\n}\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tint a[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tlong long res = aInversion(a, n);\n\tsort(a, a + n);\n\tlong long curr = 1;\n\tfor (int i = 1; i < n; i++) {\n\t    if (a[i] != a[i - 1]) {res += (curr * (curr - 1)) / 2; curr = 1;}\n\t    else {curr++;}\n\t}\n\tres += (curr * (curr - 1)) / 2;\n\tcout << res << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n    // solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}