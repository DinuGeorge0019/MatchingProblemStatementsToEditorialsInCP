{"link": "https://codeforces.com//contest/1742/problem/G", "problemId": "1584062", "shortId": "1742G", "contest_number": "1742", "name": "G. Orray", "statement": "You are given an array  consisting of  nonnegative integers. Let's define the prefix OR array  as the array , where  represents the bitwise OR operation. In other words, the array  is formed by computing the  of every prefix of .You are asked to rearrange the elements of the array  in such a way that its prefix OR array is lexicographically maximum.An array  is lexicographically greater than an array  if in the first position where  and  differ, .", "input": "The first line of the input contains a single integer  () \u2014 the number of test cases. The description of test cases follows. The first line of each test case contains a single integer  () \u2014 the length of the array . The second line of each test case contains   integers  (). It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case print  integers \u2014 any rearrangement of the array  that obtains the lexicographically maximum prefix OR array.", "tutorial": "Note that in this context  denotes .We can make the observation that only the first  elements matter, since after placing them optimally we can be sure all bits that could be set in the prefix OR would have already been set. So, we can brute force the optimal choice  times (we choose to add an element if it provides the largest new prefix OR value among all unused elements) and then just add the rest of the unused elements. ", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define ll long long\n \n#define       forn(i,n)              for(int i=0;i<n;i++)\n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n\nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n);\n    forn(i, n) cin >> a[i];\n    //we care at most about first log2(a) values\n    int cur_or = 0;\n    vector<bool> vis(n, false);\n    for(int i = 0; i < min(31, n); ++i) {\n        int mx = 0, idx = -1;\n        for(int j = 0; j < n; ++j) {\n            if(vis[j]) continue;\n            if((cur_or | a[j]) > mx) {\n                mx = (cur_or | a[j]);\n                idx = j;\n            }\n        }\n        vis[idx] = true;\n        cout << a[idx] << \" \";\n        cur_or |= a[idx];\n    }\n    forn(i, n) if(!vis[i]) cout << a[i] << \" \";\n    cout << '\\n';\n}   \n \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}