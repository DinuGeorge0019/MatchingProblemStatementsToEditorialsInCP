{"link": "https://codeforces.com//contest/1722/problem/G", "problemId": "1524439", "shortId": "1722G", "contest_number": "1722", "name": "G. Even-Odd XOR", "statement": "Given an integer , find any array  of   nonnegative integers less than  such that the bitwise XOR of the elements on odd indices equals the bitwise XOR of the elements on even indices.", "input": "The first line of the input contains an integer  ()\u00a0\u2014 the number of test cases. Then  lines follow, each containing a single integer  \u00a0\u2014 the length of the array. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, output one line containing  distinct integers that satisfy the conditions. If there are multiple answers, you can output any of them.", "tutorial": "There are a lot of solutions to this problem. Here I will describe one of them.First, we observe that having the XOR of even indexed numbers and odd indexed numbers equal is equivalent to having the XOR of all the elements equal to 0. Let's note with  the XOR of all odd indexed numbers and  the xor of all even indexed numbers. Notice that the XOR of all the array equals  if and only if a = b.So how do we generate such an array with XOR of all elements ? Our first instinct might be to arbitrarily generate the first  numbers, then set the last element as the XOR of the first , ensuring that the total XOR is . However, we might have problems with the condition that all elements must be distinct. Let's arbitrarily set the first  so that they don't have the highest bit() set, and then the -th number can be just . The last number can be the XOR of the first  XOR the -th number; you will be sure that the last number has not occurred in the first  elements because they don't have the highest bit set while the last number must have the highest bit set. But how do we know that the -th number and the -th number will not be equal? This occurs only if the total XOR of the first  numbers equals . To fix this, we can just choose a different arbitrary number in one of the  spots.For example, my solution checks if the XOR of the numbers  is . If it is not , great! We can use the simple solution without any changes. However, if the XOR is  I use the numbers  in their place. These two sequences have different XORs, so it ensures that one of them always works.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve()\n{\n    int n;\n    cin >> n;\n    int case1 = 0;\n    int case2 = 0;\n    for(int i = 0; i < n-2; i++)\n    {\n        case1^=i;\n        case2^=(i+1);\n    }\n    long long addLast = ((long long)1<<31)-1;\n    if(case1 != 0)\n    {\n        for(int i = 0; i < n-2; i++)\n        {\n            cout << i << \" \";\n        }\n        case1^=addLast;\n        cout << addLast << \" \" << case1 << endl;\n    }\n    else\n    {\n        for(int i = 1; i <= n-2; i++)\n        {\n            cout << i << \" \";\n        }\n        case2^=addLast;\n        cout << addLast << \" \" << case2 << endl;\n    }\n}\n\nint main()\n{\n    int t = 1;\n    cin >> t;\n    while(t--)\n    {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}