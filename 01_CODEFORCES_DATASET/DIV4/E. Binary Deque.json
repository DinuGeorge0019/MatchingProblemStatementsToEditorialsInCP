{"link": "https://codeforces.com//contest/1692/problem/E", "problemId": "1429119", "shortId": "1692E", "contest_number": "1692", "name": "E. Binary Deque", "statement": "Slavic has an array of length  consisting only of zeroes and ones. In one operation, he removes either the first or the last element of the array. What is the minimum number of operations Slavic has to perform such that the total sum of the array is equal to  after performing all the operations? In case the sum  can't be obtained after any amount of operations, you should output .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers  and  ()\u00a0\u2014 the length of the array and the needed sum of elements. The second line of each test case contains  integers  ()\u00a0\u2014 the elements of the array. It is guaranteed that the sum of  over all test cases doesn't exceed .", "output": "For each test case, output a single integer\u00a0\u2014 the minimum amount of operations required to have the total sum of the array equal to , or  if obtaining an array with sum  isn't possible.", "tutorial": "Note that the remaining array is a subarray of the original array. There are many ways to approach the problem. Here is one solution, which the main solution uses:Compute prefix sums on the array, so we can find out the value of  quickly. Let's iterate through the left endpoint  from  to . Afterwards, we can binary search on the smallest value of  such that , since this sum is strictly increasing.The time complexity is .", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define ll long long\n \n#define       forn(i,n)              for(int i=0;i<n;i++)\n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n\n\nll query(int l, int r, vector<ll>& p) {\n    return p[r] - (l ? p[l - 1] : 0);\n}\n\nvoid solve() {  \n    int n, s; cin >> n >> s;\n    vector<ll> a(n), p(n);\n    forn(i, n) {\n        cin >> a[i];\n        p[i] = a[i];\n        if(i) p[i] += p[i - 1];\n    }\n\n    int ans = INT_MAX;\n\n    for(int i = 0; i < n; ++i) {\n        int l = i, r = n - 1, pos = -1;\n        while(l <= r) {\n            int mid = l + r >> 1;\n            if(query(i, mid, p) <= s) {\n                pos = mid;\n                l = mid + 1;\n            } else r = mid - 1;\n        }\n        if(pos == -1 || query(i, pos, p) != s) continue;\n        ans = min(ans, n - (pos - i + 1));\n    }\n\n    cout << (ans == INT_MAX ? -1 : ans) << \"\\n\";\n} \n     \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}   ", "interactive": false, "noSolution": false, "noTutorial": false}