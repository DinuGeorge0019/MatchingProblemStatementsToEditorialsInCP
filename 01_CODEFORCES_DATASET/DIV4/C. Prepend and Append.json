{"link": "https://codeforces.com//contest/1791/problem/C", "problemId": "1764443", "shortId": "1791C", "contest_number": "1791", "name": "C. Prepend and Append", "statement": "Timur initially had a binary string  (possibly of length ). He performed the following operation several (possibly zero) times:   Add  to one end of the string and  to the other end of the string. For example, starting from the string , you can obtain either  or .  You are given Timur's final string. What is the length of the  possible string he could have started with? A binary string is a string (possibly the empty string) whose characters are either  or .", "input": "The first line of the input contains an integer  ()\u00a0\u2014 the number of testcases. The first line of each test case contains an integer  ()\u00a0\u2014 the length of Timur's final string. The second line of each test case contains a string  of length  consisting of characters  or , denoting the final string.", "output": "For each test case, output a single nonnegative integer\u00a0\u2014 the shortest possible length of Timur's original string. Note that Timur's original string could have been empty, in which case you should output .", "tutorial": "Let's perform the process in reverse: we will remove the first and last character of the string, if these two characters are different. We should do this as long as possible, since we need to find the shortest initial string. So the algorithm is straightfoward: keep track of the left and right characters, and if they are different, remove both. Otherwise, output the length of the current string (or output  if the string became empty).There are a few ways to implement this. For example, you can keep two pointers, one at the beginning of the string and one at the end, say,  and , and check if . If it's true, then we increment  and decrement . Otherwise, we output . We stop when .Alternatively, you can use deque to simulate the operations directly. The time complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 200007;\nconst int MOD = 1000000007;\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tint l = 0, r = n - 1, ans = n;\n\twhile (s[l] != s[r] && ans > 0) {l++; r--; ans -= 2;}\n\tcout << ans << '\\n';\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}