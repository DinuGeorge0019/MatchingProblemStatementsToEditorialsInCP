{"link": "https://codeforces.com//contest/1669/problem/G", "problemId": "1375144", "shortId": "1669G", "contest_number": "1669", "name": "G. Fall Down", "statement": "There is a grid with  rows and  columns, and three types of cells:   An empty cell, denoted with ''.  A stone, denoted with ''.  An obstacle, denoted with the lowercase Latin letter ''. All stones fall down until they meet the floor (the bottom row), an obstacle, or other stone which is already immovable. (In other words, all the stones just fall down as long as they can fall.)Simulate the process. What does the resulting grid look like?", "input": "The input consists of multiple test cases. The first line contains an integer  ()\u00a0\u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains two integers  and  ()\u00a0\u2014 the number of rows and the number of columns in the grid, respectively. Then  lines follow, each containing  characters. Each of these characters is either '', '', or ''\u00a0\u2014 an empty cell, a stone, or an obstacle, respectively.", "output": "For each test case, output a grid with  rows and  columns, showing the result of the process. ", "tutorial": "Note that the columns don't affect each other, so we can solve for each column by itself.For each column, go from the bottom to the top, and keep track of the row of the last obstacle seen; call it . Note that initially, , since we treat the floor as the th row of obstacles. Whenever we see a new obstacle, we should update .Now, if we ever see a stone, we should move it to row , since it will be one row above the last obstacle seen (it will fall on top of it). Afterwards, we should also decrease  by , because if any future stones fall on top of it, they will land on the row above this stone.This solution works in . We also accepted slower solutions that run in  that simulate each stone falling.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 200007;\nconst int MOD = 1000000007;\n\nvoid solve() {\n\tint n, m;\n\tcin >> n >> m;\n\tchar g[n + 7][m + 7];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcin >> g[i][j];\n\t\t}\n\t}\n\tfor (int j = 0; j < m; j++) {\n\t\tint last = n - 1;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tif (g[i][j] == 'o') {last = i - 1;}\n\t\t\telse if (g[i][j] == '*') {swap(g[i][j], g[last][j]); last--;}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcout << g[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n    // solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}