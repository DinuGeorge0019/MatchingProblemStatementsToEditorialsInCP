{"link": "https://codeforces.com//contest/1703/problem/G", "problemId": "1459221", "shortId": "1703G", "contest_number": "1703", "name": "G. Good Key, Bad Key", "statement": "There are  chests. The -th chest contains  coins. You need to open all  chests .There are two types of keys you can use to open a chest:   a good key, which costs  coins to use;  a bad key, which does not cost any coins, but will halve all the coins in each unopened chest, . The halving operation  to the nearest integer for each chest halved. In other words using a bad key to open chest  will do , ;  any key (both good and bad) breaks after a usage, that is, it is a one-time use. You need to use in total  keys, one for each chest. Initially, you have no coins and no keys. If you want to use a good key, then you need to buy it.During the process, you are allowed to go into debt; for example, if you have  coin, you are allowed to buy a good key worth  coins, and your balance will become  coins.Find the maximum number of coins you can have after opening all  chests in order from chest  to chest .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers  and  (; )\u00a0\u2014 the number of chests and the cost of a good key respectively. The second line of each test case contains  integers  () \u00a0\u2014 the amount of coins in each chest. The sum of  over all test cases does not exceed .", "output": "For each test case output a single integer \u00a0\u2014 the maximum number of coins you can obtain after opening the chests in order from chest  to chest . Please note, that the answer for some test cases won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like  for C++).", "tutorial": "We will prove it is always optimal to use good keys for a prefix then only use bad keys. Consider we have used a bad key then a good key, by doing this we obtain  coins. If we switch and use a good key first, the a bad key then we obtain , this number is clearly bigger so we will never encounter a bad key before a good key in an optimal solution, thus we will use a prefix of good keys then move on to using bad keys. For every possible prefix of good keys we will calculate the coins we get at the end. We do this by maintaining a variable with the prefix sum where we use the good keys and then calculate what we will get from the chests where we use bad keys. Notice that because we halve all the chests when we use a bad key we only need to verify the next  chests, all chests after it will go to  coins.Final complexity: .", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n \nvoid solve()\n{\n    int n, k;\n    cin >> n >> k;\n    int a[n];\n    for(int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    long long ans = 0;\n    long long sum = 0;\n    for(int i = -1; i < n; i++)\n    {\n        long long now = sum;\n        for(int j = i+1; j < min(n, i+32); j++)\n        {\n            int copy = a[j];\n            copy>>=j-i;\n            now+=copy;\n        }\n        ans = max(ans, now);\n        if(i+1 != n)\n        {\n            sum+=a[i+1]-k;\n        }\n    }\n    cout << ans << endl;\n}\n \nint main(){\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        solve();\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}