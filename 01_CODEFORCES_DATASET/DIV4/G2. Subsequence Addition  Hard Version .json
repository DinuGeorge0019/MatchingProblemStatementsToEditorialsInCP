{"link": "https://codeforces.com//contest/1807/problem/G2", "problemId": "1838168", "shortId": "1807G2", "contest_number": "1807", "name": "G2. Subsequence Addition  Hard Version ", "statement": "Initially, array  contains just the number . You can perform several operations in order to change the array. In an operation, you can select some subsequence of  and add into  an element equal to the sum of all elements of the subsequence. You are given a final array . Check if  can be obtained from the initial array  by performing some number (possibly 0) of operations on the initial array. A sequence  is a subsequence of a sequence  if  can be obtained from  by the deletion of several (possibly zero, but not all) elements. In other words, select  () distinct indices  and insert anywhere into  a new element with the value equal to .", "input": "The first line of the input contains an integer  ()\u00a0\u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains a single integer  () \u00a0\u2014 the number of elements the final array  should have. The second line of each test case contains  space-separated integers  () \u00a0\u2014 the elements of the final array  that should be obtained from the initial array . It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, output \"\" (without quotes) if such a sequence of operations exists, and \"\" (without quotes) otherwise. You can output the answer in any case (for example, the strings \"\", \"\", \"\" and \"\" will be recognized as a positive answer).", "tutorial": "Let's prove that for an array  that was created by using a number of operations, with a sum of elements  we can add into  any number  ().Suppose that it is true that in the array  with some length  we introduce a number  (). Then after introducing we can create using the initial elements of the array any number  () and using the element  and some subset of the initial elements we can create any number  (), and because  we proved that for the new array of length  we can still create any number between  and .Since it is true for the initial array, we can use induction and this fact to prove it is true for all arrays. So we just need to verify if our array satisfies this condition. We should sort the array and check for each  () if .", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define ll long long\n \n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n \nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    sort(all(a));\n    if(a[0] != 1) {\n        cout << \"NO\\n\";\n        return;\n    }\n    long long sum = a[0];\n    for(int i = 1; i < n; ++i) {\n        if(sum < a[i]) {\n            cout << \"NO\\n\";\n            return;\n        }\n        sum += a[i];\n    }\n    cout << \"YES\\n\";\n}\n \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}