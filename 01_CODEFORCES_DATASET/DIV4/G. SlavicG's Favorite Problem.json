{"link": "https://codeforces.com//contest/1760/problem/G", "problemId": "1654044", "shortId": "1760G", "contest_number": "1760", "name": "G. SlavicG's Favorite Problem", "statement": "You are given a weighted tree with  vertices. Recall that a tree is a connected graph without any cycles. A weighted tree is a tree in which each edge has a certain weight. The tree is undirected, it doesn't have a root.Since trees bore you, you decided to challenge yourself and play a game on the given tree.In a move, you can travel from a node to one of its neighbors (another node it has a direct edge with).You start with a variable  which is initially equal to . When you pass through edge ,  changes its value to  (where  is the weight of the -th edge). Your task is to go from vertex  to vertex , but you are allowed to enter node  if and only if after traveling to it, the value of  will become . In other words, you can travel to node  only by using an edge  such that . Once you enter node  the game ends and you win.Additionally, you can teleport  at any point in time to any vertex except vertex . You can teleport from any vertex, even from .Answer with \"\" if you can reach vertex  from , and \"\" otherwise.Note that  represents the bitwise XOR operation.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains three integers , , and  (), ()\u00a0\u2014 the number of vertices, and the starting and desired ending node respectively. Each of the next  lines denotes an edge of the tree. Edge  is denoted by three integers ,  and  \u00a0\u2014 the labels of vertices it connects () and the weight of the respective edge. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case output \"\" if you can reach vertex , and \"\" otherwise.", "tutorial": "Let's ignore the teleporting, and decide how to find the answer. Note that we don't need to ever go over an edge more than once, since going over an edge twice cancels out (since  for all ). In other words, the only possible value of  equals the  of the edges on the unique path from  to . We can find it through a BFS from , continuing to keep track of s as we move to each adjacent node, and ing it by the weight of the corresponding edge as we travel across it.Now let's include the teleport. It means that we travel from , then teleport to , and go from , for some nodes  and . Also, we cannot pass  on the path from .Again, note that the value of  is fixed on each of the paths from  and , since there is a unique path between them. Let  be the  of the first path and  be the  of the second. Then we need . So we need to find if there are two nodes ,  such that the s from  and  to those nodes are the same. To do this, we can do our BFS from before, but instead run one BFS from  and another from , and check if any two values are the same.Make sure not to include nodes past  while we look for  on our BFS from .The time complexity is .", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\n \nusing ll = long long;\n \n#define       forn(i,n)              for(int i=0;i<n;i++)\n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n\nconst int N = 1e5 + 10;\nvector<pair<int, int>> adj[N];\nset<int> s;\nbool ok = true;\nint n, a, b;\nvoid dfs1(int u, int par, int x) {\n    if(u == b) return;\n    s.insert(x);\n    for(auto e: adj[u]) {\n        int v = e.first, w = e.second;\n        if(v == par) continue;\n        dfs1(v, u, x ^ w);\n    }\n}\n\nbool dfs2(int u, int par, int x) {\n    if(u != b && s.count(x)) return true;\n    for(auto e: adj[u]) {\n        int v = e.first, w = e.second;\n        if(v == par) continue;\n        if(dfs2(v, u, w ^ x)) return true;\n    } \n    return false;\n}\n\nvoid solve() {\n    s.clear();\n    cin >> n >> a >> b; --a, --b;\n    forn(i, n) adj[i].clear();\n    for(int i = 0; i < n - 1; ++i) {\n        int u, v, w; cin >> u >> v >> w; --u, --v;\n        adj[u].pb({v, w});\n        adj[v].pb({u, w});\n    }\n    dfs1(a, -1, 0);\n    if(dfs2(b, -1, 0)) cout << \"YES\\n\";\n    else cout << \"NO\\n\";\n}   \n \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}