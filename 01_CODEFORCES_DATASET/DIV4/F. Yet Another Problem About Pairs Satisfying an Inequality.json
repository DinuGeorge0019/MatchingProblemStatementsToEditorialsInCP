{"link": "https://codeforces.com//contest/1703/problem/F", "problemId": "1459220", "shortId": "1703F", "contest_number": "1703", "name": "F. Yet Another Problem About Pairs Satisfying an Inequality", "statement": "You are given an array . Count the number of pairs of indices  such that .", "input": "The first line contains an integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains an integer  ()\u00a0\u2014 the length of the array. The second line of each test case contains  integers  ()\u00a0\u2014 the elements of the array. It is guaranteed that the sum of  across all test cases does not exceed .", "output": "For each test case, output a single integer\u00a0\u2014 the number of pairs of indices satisfying the condition in the statement. Please note, that the answer for some test cases won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like  for C++).", "tutorial": "Call a pair  if it satisfies the condition. Let's split the inequality into three parts: , , .Note that if  for any , then it can't be an element of a good pair, because it fails the first and third conditions. So we can throw out all elements of the array satisfying .For the remaining elements, the first and third inequalities are already satisfied, so we only have to count the number of pairs  with . Let's iterate  through the array from the left to the right, and make a list storing all  that appear before . Then for each , count the number of  less than  by binary searching on the number of elements in the list less than . Afterwards, add  to the end of the list.Since we iterate from left to right, the list will always remain sorted (we insert the indices of elements, which are increasing from left to right), so the binary search will always work.The time complexity is .", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MAX = 200007;\nconst int MOD = 1000000007;\n \nvoid solve() {\n\tint n;\n\tcin >> n;\n\tint a[n + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tlong long res = 0;\n\tvector<int> v;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i] >= i) {continue;}\n\t\tres += (long long)(lower_bound(v.begin(), v.end(), a[i]) - v.begin());\n\t\tv.push_back(i);\n\t}\n\tcout << res << '\\n';\n}\n \nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}