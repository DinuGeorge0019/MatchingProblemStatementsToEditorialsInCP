{"link": "https://codeforces.com//contest/1352/problem/D", "problemId": "616896", "shortId": "1352D", "contest_number": "1352", "name": "D. Alice, Bob and Candies", "statement": "There are  candies in a row, they are numbered from left to right from  to . The size of the -th candy is .Alice and Bob play an interesting and tasty game: they eat candy. Alice will eat candy , and Bob \u2014 . The game ends if all the candies are eaten.The process consists of moves. During a move, the player eats one or more sweets from her/his side (Alice eats from the left, Bob \u2014 from the right).Alice makes the first move. During the first move, she will eat  candy (its size is ). Then, each successive move the players alternate \u2014 that is, Bob makes the second move, then Alice, then again Bob and so on.On each move, a player counts the total size of candies eaten during the current move. Once this number becomes strictly greater than the total size of candies eaten by the other player on their previous move, the current player stops eating and the move ends. In other words, on a move, a player eats the smallest possible number of candies such that the sum of the sizes of candies eaten on this move is  than the sum of the sizes of candies that the other player ate on the  move. If there are not enough candies to make a move this way, then the player eats up all the remaining candies and the game ends.For example, if  and , then:  move 1: Alice eats one candy of size  and the sequence of candies becomes .  move 2: Alice ate  on the previous move, which means Bob must eat  or more. Bob eats one candy of size  and the sequence of candies becomes .  move 3: Bob ate  on the previous move, which means Alice must eat  or more. Alice eats three candies with the total size of  and the sequence of candies becomes .  move 4: Alice ate  on the previous move, which means Bob must eat  or more. Bob eats two candies with the total size of  and the sequence of candies becomes .  move 5: Bob ate  on the previous move, which means Alice must eat  or more. Alice eats two candies with the total size of  and the sequence of candies becomes .  move 6 (the last): Alice ate  on the previous move, which means Bob must eat  or more. It is impossible, so Bob eats the two remaining candies and the game ends. Print the number of moves in the game and two numbers:   \u2014 the total size of all sweets eaten by Alice during the game;   \u2014 the total size of all sweets eaten by Bob during the game. ", "input": "The first line contains an integer  () \u2014 the number of test cases in the input. The following are descriptions of the  test cases. Each test case consists of two lines. The first line contains an integer  () \u2014 the number of candies. The second line contains a sequence of integers  () \u2014 the sizes of candies in the order they are arranged from left to right. It is guaranteed that the sum of the values of  for all sets of input data in a test does not exceed .", "output": "For each set of input data print three integers \u2014 the number of moves in the game and the required values  and .", "tutorial": "This is just an implementation problem and it can be solved in  time but we didn't ask for such solutions so you could solve it in  or maybe even in . I'll describe  solution anyway.Firstly, we need to maintain several variables:  (initially , the number of moves passed),  (the position of the leftmost remaining candy, initially ),  (the position of the rightmost remaining candy, initially ),  (the sum of candies eaten by Alice, initially ),  (the sum of candied eaten by Bob, initially ),  (the sum of candies eaten by Alice during her last move, initially ) and  (the sum of candies eaten by Bob during his last move, initially ).So, let's just simulate the following process while : if the number of moves  is even then now is Alice's move and we need to maintain   \u2014 the sum of candies Alice eats during this move. How to calculate it? While  and , let's eat the leftmost candy, so variables will change like this: . After all, let's add  to , replace  with  (assign ) and increase  by . If the number of moves  is odd then the process is the same but from the Bob's side.I'll also add a simply implemented  solution written by Gassa below :)", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tint l = 0, r = n - 1;\n\t\tint suml = 0, sumr = 0;\n\t\tint cnt = 0, ansl = 0, ansr = 0;\n\t\twhile (l <= r) {\n\t\t\tif (cnt % 2 == 0) {\n\t\t\t\tint nsuml = 0;\n\t\t\t\twhile (l <= r && nsuml <= sumr) {\n\t\t\t\t\tnsuml += a[l++];\n\t\t\t\t}\n\t\t\t\tansl += nsuml;\n\t\t\t\tsuml = nsuml;\n\t\t\t} else {\n\t\t\t\tint nsumr = 0;\n\t\t\t\twhile (l <= r && nsumr <= suml) {\n\t\t\t\t\tnsumr += a[r--];\n\t\t\t\t}\n\t\t\t\tansr += nsumr;\n\t\t\t\tsumr = nsumr;\n\t\t\t}\n\t\t\t++cnt;\n\t\t}\n\t\tcout << cnt << \" \" << ansl << \" \" << ansr << endl;\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}