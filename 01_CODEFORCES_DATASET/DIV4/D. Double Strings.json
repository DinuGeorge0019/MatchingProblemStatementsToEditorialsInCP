{"link": "https://codeforces.com//contest/1703/problem/D", "problemId": "1459218", "shortId": "1703D", "contest_number": "1703", "name": "D. Double Strings", "statement": "You are given  strings  of length at most . For each string , determine if there exist two strings  and  such that . That is,  is the concatenation of  and . Note that   be equal to .Recall that the concatenation of strings  and  is , where  and  are the lengths of strings  and  respectively. For example, concatenation of \"\" and \"\" is \"\".", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains a single integer  ()\u00a0\u2014 the number of strings. Then  lines follow, the -th of which contains non-empty string  of length at most , consisting of lowercase English letters. Among the given  strings, there may be equal (duplicates). The sum of  over all test cases doesn't exceed .", "output": "For each test case, output a binary string of length . The -th bit should be  if there exist two strings  and  where , and  otherwise. Note that  can be equal to .", "tutorial": "Use some data structure that allows you to answer queries of the form: \"does the string  appear in the array ?\" For example, in C++ you can use a , while in Python you can use a dictionary .Afterwards, for each string , brute force all strings  and  such that . There are at most  such strings, because  has length at most . Then check if both  and  appear in the array using your data structure.The time complexity is  per test case, where  is the maximum length of an input string. ", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MAX = 200007;\nconst int MOD = 1000000007;\n \nvoid solve() {\n\tint n;\n\tcin >> n;\n\tstring s[n];\n\tmap<string, bool> mp;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tmp[s[i]] = true;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tbool ok = false;\n\t\tfor (int j = 1; j < s[i].length(); j++) {\n\t\t\tstring pref = s[i].substr(0, j), suff = s[i].substr(j, s[i].length() - j);\n\t\t\tif (mp[pref] && mp[suff]) {ok = true;}\t\n\t\t}\n\t\tcout << ok;\n\t}\n\tcout << '\\n';\n}\n \nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}