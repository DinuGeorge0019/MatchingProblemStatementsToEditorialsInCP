{"link": "https://codeforces.com//contest/1807/problem/G1", "problemId": "1838167", "shortId": "1807G1", "contest_number": "1807", "name": "G1. Subsequence Addition  Easy Version ", "statement": "Initially, array  contains just the number . You can perform several operations in order to change the array. In an operation, you can select some subsequence of  and add into  an element equal to the sum of all elements of the subsequence. You are given a final array . Check if  can be obtained from the initial array  by performing some number (possibly 0) of operations on the initial array. A sequence  is a subsequence of a sequence  if  can be obtained from  by the deletion of several (possibly zero, but not all) elements. In other words, select  () distinct indices  and insert anywhere into  a new element with the value equal to .", "input": "The first line of the input contains an integer  ()\u00a0\u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains a single integer  () \u00a0\u2014 the number of elements the final array  should have. The second line of each test case contains  space-separated integers  () \u00a0\u2014 the elements of the final array  that should be obtained from the initial array . It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, output \"\" (without quotes) if such a sequence of operations exists, and \"\" (without quotes) otherwise. You can output the answer in any case (for example, the strings \"\", \"\", \"\" and \"\" will be recognized as a positive answer).", "tutorial": "Firstly, let's note that it doesn't matter in what order we add the elements to the array, since if we can add an element in any position, if it's possible to get the said elements of the array, then we can obtain them in any order.Now, let's note that it's always optimal to obtain the needed elements in sorted order (since we only use smaller values in order to obtain the current one), so we will consider the array  as sorted. If the first element of the array isn't  then we immediately know such an array doesn't exist. Otherwise, we can use dynamic programming for finding out if the remaining  elements are obtainable. Let's denote  a boolean array which tells us whether sum  is obtainable. Initially,  (since the first element is guaranteed to be ). We will go in increasing order of  and if we calculated an element to be obtainable in the past, we update all obtainable values with the new  value. We do this in , by going through all sums  and updating  ( is true if it already was true, or if  was true and we add to that sum the new value .The total time complexity of this solution is .", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define ll long long\n \n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n \nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    sort(all(a));\n    if(a[0] != 1) {\n        cout << \"NO\\n\";\n        return;\n    }\n    vector<int> dp(5005, 0);\n    dp[1] = 1;\n    for(int i = 1; i < n; ++i) {\n        if(!dp[a[i]]) {\n            cout << \"NO\\n\";\n            return;\n        }\n        for(int j = 5000; j >= a[i]; --j) {\n            dp[j] |= dp[j - a[i]];\n        }\n    }\n    cout << \"YES\\n\";\n}\n \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}\n\n", "interactive": false, "noSolution": false, "noTutorial": false}