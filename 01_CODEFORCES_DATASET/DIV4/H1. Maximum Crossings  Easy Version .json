{"link": "https://codeforces.com//contest/1676/problem/H1", "problemId": "1394660", "shortId": "1676H1", "contest_number": "1676", "name": "H1. Maximum Crossings  Easy Version ", "statement": "  and the sum of  over all test cases does not exceed A  is a row of  equal segments numbered  to  in order. There are two terminals, one above the other. You are given an array  of length . For all , there should be a straight wire from some point on segment  of the top terminal to some point on segment  of the bottom terminal. You can't select the endpoints of a segment. For example, the following pictures show two possible wirings if  and .  A  occurs when two wires share a point in common. In the picture above, crossings are circled in red.What is the  number of crossings there can be if you place the wires optimally?", "input": "The first line contains an integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains an integer  ()\u00a0\u2014 the length of the array. The second line of each test case contains  integers  ()\u00a0\u2014 the elements of the array. The sum of  across all test cases does not exceed .", "output": "For each test case, output a single integer\u00a0\u2014 the  number of crossings there can be if you place the wires optimally.", "tutorial": "Let's look at two wires from  and .   If , there can never be any intersection.  If , there has to be an intersection.  If , it is possible that there is an intersection or not, depending on how we arrange the wires on the bottom terminal.  In the last case, if there are multiple wires that go to the same segment , we can make all pairs of them cross by arranging the points in which they hit this segment from right to left. For example, if , then we can make all pairs of segments cross as shown.   Since we want to maximize the number of intersections, we just need to count the number of pairs  such that . You can brute force all pairs in .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 200007;\nconst int MOD = 1000000007;\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tint a[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (a[i] >= a[j]) {res++;}\n\t\t}\n\t}\n\tcout << res << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n    // solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}