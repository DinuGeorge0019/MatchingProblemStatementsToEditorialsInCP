{"link": "https://codeforces.com//contest/1760/problem/E", "problemId": "1654042", "shortId": "1760E", "contest_number": "1760", "name": "E. Binary Inversions", "statement": "You are given a binary array of length . You are allowed to perform one operation on it . In an operation, you can choose any element and flip it: turn a  into a  or vice-versa.What is the maximum number of inversions the array can have after performing  operation? A binary array is an array that contains only zeroes and ones. The number of inversions in an array is the number of pairs of indices  such that  and .", "input": "The input consists of multiple test cases. The first line contains an integer  ()\u00a0\u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains an integer  ()\u00a0\u2014 the length of the array. The following line contains  space-separated positive integers , ,...,  ()\u00a0\u2014 the elements of the array. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, output a single integer \u00a0\u2014 the maximum number of inversions the array can have after performing  operation.", "tutorial": "Let's find out how to count the number of binary inversions, without flips. This is the number of $$$1$$$s that appear before a $$$0$$$. To do this, iterate through the array and keep a running total $$$k$$$ of the number of $$$1$$$s seen so far. When we see a $$$0$$$, increase the total inversion count by $$$k$$$, since this $$$0$$$ makes $$$k$$$ inversions: one for each of the $$$1$$$s before it.Now let's see how to maximize the inversions. Consider the flip $$$0 \\to 1$$$. We claim that it is best to always flip the earliest $$$0$$$ in the array. It's never optimal to flip a later $$$0$$$, since we have strictly fewer $$$0$$$s after it to form inversions. Similarly, we should flip the latest $$$1$$$ in the array.Now recalculate the answer for these two choices for flipping, and pick the maximum. The complexity is $$$\\mathcal{O}(n)$$$.", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\n \nusing ll = long long;\n \n#define       forn(i,n)              for(int i=0;i<n;i++)\n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n\nll calc(vector<int>& a) {\n    ll zeroes = 0, ans = 0;\n    for(int i = sz(a) - 1; i >= 0; --i) {\n        if(a[i] == 0) ++zeroes;\n        else ans += zeroes;\n    }\n    return ans;\n}\nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n);\n    forn(i, n) cin >> a[i];\n    ll ans = calc(a);\n    forn(i, n) {\n        if(a[i] == 0) {\n            a[i] = 1;\n            ans = max(ans, calc(a));\n            a[i] = 0;\n            break;\n        }\n    }\n    for(int i = n - 1; i >= 0; --i) {\n        if(a[i] == 1) {\n            a[i] = 0;\n            ans = max(ans, calc(a));\n            a[i] = 1;\n            break;\n        }\n    }\n    cout << ans << \"\\n\";\n}   \n \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}