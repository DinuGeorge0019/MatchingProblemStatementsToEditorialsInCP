{"link": "https://codeforces.com//contest/1703/problem/E", "problemId": "1459219", "shortId": "1703E", "contest_number": "1703", "name": "E. Mirror Grid", "statement": "You are given a square grid with  rows and  columns. Each cell contains either  or . In an operation, you can select a cell of the grid and flip it (from  or ). Find the minimum number of operations you need to obtain a square that remains the same when rotated , ,  and .The picture below shows an example of all rotations of a grid.  ", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains a single integer  ()\u00a0\u2014 the size of the grid. Then  lines follow, each with  characters  ()\u00a0\u2014 the number written in each cell.", "output": "For each test case output a single integer \u00a0\u2014 the minimum number of operations needed to make the square look the same rotated , ,  and .", "tutorial": "Let's rotate the grid by , , , and , and mark all cells that map to each other under these rotations. For example, for  and  grids, mirror grid must have the following patterns, the same letters denoting equal values:In general, we can rotate the grid by , , , and  and see which cells need to have equal values by seeing the positions which each cell maps to.Now to solve the problem, we consider each equal value (each of the letters , , , ... in the above figures) independently, and consider the minimum number of moves to make them all  or all . The answer is the total across all values. See the implementation for better understanding.The time complexity is  per testcase.", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n \nvoid solve()\n{\n    int n;\n    cin >> n;\n    int a[n][n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n            char c;\n            cin >> c;\n            a[i][j] = c-'0';\n        }\n    }\n    int ans = 0;\n    for(int i = 0; i < (n+1)/2; i++)\n    {\n        for(int j = 0; j < n/2; j++)\n        {\n            int nowi = i, nowj = j;\n            int oldnowj = nowj;\n            int sum = a[nowi][nowj];\n            nowj = n-nowi-1;\n            nowi = oldnowj;\n            sum+=a[nowi][nowj];\n            oldnowj = nowj;\n            nowj = n-nowi-1;\n            nowi = oldnowj;\n            sum+=a[nowi][nowj];\n            oldnowj = nowj;\n            nowj = n-nowi-1;\n            nowi = oldnowj;\n            sum+=a[nowi][nowj];\n            ans+=min(sum, 4-sum);\n        }\n    }\n    cout << ans << endl;\n}\n \nint main(){\n    int t;\n    cin>> t;\n    while(t--)\n    {\n        solve();\n    }\n    return 0;\n} ", "interactive": false, "noSolution": false, "noTutorial": false}