{"link": "https://codeforces.com//contest/1692/problem/H", "problemId": "1429122", "shortId": "1692H", "contest_number": "1692", "name": "H. Gambling", "statement": "Marian is at a casino. The game at the casino works like this.Before each round, the player selects a number between  and . After that, a dice with  faces is rolled so that a random number between  and  appears. If the player guesses the number correctly their total money is doubled, else their total money is halved. Marian predicted the future and knows all the numbers  that the dice will show in the next  rounds. He will pick three integers ,  and  (). He will play  rounds (rounds between  and  inclusive). In each of these rounds, he will guess the same number . At the start (before the round ) he has  dollar.Marian asks you to determine the integers ,  and  (, ) such that he makes the most money at the end.Note that during halving and multiplying there is no rounding and there are no precision errors. So, for example during a game, Marian could have money equal to , , , , , , etc. (any value of , where  is an integer of any sign).", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains a single integer  ()\u00a0\u2014 the number of rounds. The second line of each test case contains  integers  (), where  is the number that will fall on the dice in the -th round. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, output three integers , , and  such that Marian makes the most amount of money gambling with his strategy. If there are multiple answers, you may output any of them.", "tutorial": "There are several solutions. Here is one.If we fix the value of , then let's make a new array  as follows:  if , and  otherwise. Then the total amount of money earned will just be , so we only need to maximize . In other words, we need to find the maximum sum of a subarray. This is a standard problem that can be solved using segment tree.Note that we need to iterate over all values of , of which there are  possibilities. So we have to update elements of the segment tree  times and query once for each , which means overall the solution runs in . ", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define ll long long\n \n#define       forn(i,n)              for(int i=0;i<n;i++)\n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n \nstruct DynamicMaxSubarraySum {\n    struct node {\n        ll pref, suf, val, sum;\n    };  \n    int N;\n    ll neutral;\n    vector<node> t;\n    DynamicMaxSubarraySum(int _N, ll assign_value) {\n        neutral = assign_value;\n        N = _N;\n        t.resize(4 * N);\n        forn(i, 4 * N) t[i] = {0, 0, 0, 0};\n        build(1, 0, N - 1); \n    }\n    void build(int i, int l, int r) {\n        if(l == r) {\n            t[i].pref = t[i].suf = t[i].val = t[i].sum = neutral;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(2 * i, l, mid);\n        build(2 * i + 1, mid + 1, r);\n        t[i] = merge(t[2 * i], t[2 * i + 1]);\n    }\n    node merge(node a, node b) {\n        node c;\n        c.pref = max(a.pref, a.sum + b.pref);\n        c.suf = max(b.suf, b.sum + a.suf);\n        c.val = max({a.val, b.val, a.suf + b.pref});\n        c.sum = a.sum + b.sum;\n        return c;\n    }\n \n    void modif(int i, int l, int r, int pos, ll val) {\n        if(l > pos || r < pos) return;\n        if(l == pos && r == pos) {\n            t[i].pref = t[i].suf = t[i].val = t[i].sum = val;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        modif(2 * i, l, mid, pos, val);\n        modif(2 * i + 1, mid + 1, r, pos, val);\n        t[i] = merge(t[2 * i], t[2 * i + 1]);\n    }\n    node query(int i, int l, int r, int tl, int tr) {\n        if(l > tr || r < tl) return {0, 0, 0, 0};\n        if(l >= tl && r <= tr) return t[i];\n        int mid = (l + r) >> 1;\n        return merge(query(2 * i, l, mid, tl, tr), query(2 * i + 1, mid + 1, r, tl, tr));\n    }\n \n    void modif(int pos, int val) {\n        modif(1, 0, N - 1, pos, val);\n    }\n    node query(int l, int r) {\n        return query(1, 0, N - 1, l, r);\n    }\n    node query(int pos) {\n        return query(1, 0, N - 1, pos, pos);\n    }\n};\n \nvoid solve() {  \n    int n; cin >> n;\n    vector<int> a(n);\n    forn(i, n) cin >> a[i];\n    map<int, vector<int>> vv;\n    forn(i, n) {\n        vv[a[i]].pb(i);\n    }\n    DynamicMaxSubarraySum st(n, -1);\n \n    ll mx = 0, ans = -1;\n    for(auto i: vv) {\n        vector<int> v = i.second;\n        for(auto x: v) st.modif(x, 1);\n        if(mx < st.query(0, n - 1).val) {\n            ans = i.first;\n            mx = st.query(0, n - 1).val;\n        }\n        for(auto x: v) st.modif(x, -1);\n    }  \n    int ansl = -1, ansr = -1;\n    for(int i = 0; i < n; ++i) {\n        if(a[i] == ans) a[i] = 1;\n        else a[i] = -1;\n    }\n    ll sum = 0, lastl = 0;\n    mx = 0;\n    for(int i = 0; i < n; ++i) {\n        sum += a[i];\n        if(sum > mx) {\n            mx = sum;\n            ansr = i;\n            ansl = lastl;\n        }\n        if(sum <= 0) {\n            lastl = i + 1;\n            sum = 0;\n        }\n    }\n \n    cout << ans << \" \" << ansl + 1 << \" \" << ansr + 1 << \"\\n\"; \n}   \n     \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}