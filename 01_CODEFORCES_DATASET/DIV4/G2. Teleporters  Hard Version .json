{"link": "https://codeforces.com//contest/1791/problem/G2", "problemId": "1764448", "shortId": "1791G2", "contest_number": "1791", "name": "G2. Teleporters  Hard Version ", "statement": "Consider the points  on the number line. There is a teleporter located on each of the points . At point , you can do the following:  Move left one unit: it costs  coin.  Move right one unit: it costs  coin.  Use a teleporter at point , if it exists: it costs  coins. As a result, you can choose whether to teleport to point  or point . Once you use a teleporter, you  use it again. You have  coins, and you start at point . What's the most number of teleporters you can use?", "input": "The input consists of multiple test cases. The first line contains an integer  ()\u00a0\u2014 the number of test cases. The descriptions of the test cases follow. The first line of each test case contains two integers  and  (; ) \u00a0\u2014 the length of the array and the number of coins you have respectively. The following line contains  space-separated positive integers  ()\u00a0\u2014 the costs to use the teleporters. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, output the maximum number of teleporters you can use.", "tutorial": "Please also refer to the tutorial for the easy version.If we are not at the first taken portal, the problem is still independent for each portal, but this time the cost of a portal is  (since we can come to a portal either from point  or point ). So, we again sort the portals by their costs. But this time, we need to make sure that the first taken portal is taken from point , so we will iterate over all portals and check the maximum amount of portals we can take if we use it as the first one. We can check this using prefix sums over the minimum cost array and binary searching, checking if the amount of considered portals taken doesn't exceed the number of coins we initially have (we also have to deal with the case when the portal we are considering is included both times as the initial portal and in the minimum cost prefix).", "solution": "#include <bits/stdc++.h>\n#define startt ios_base::sync_with_stdio(false);cin.tie(0);\ntypedef long long  ll;\nusing namespace std;\n#define vint vector<int>\n#define all(v) v.begin(), v.end()\n#define MOD 1000000007\n#define MOD2 998244353\n#define MX 1000000000\n#define MXL 1000000000000000000\n#define PI (ld)2*acos(0.0)\n#define pb push_back\n#define sc second\n#define fr first\n#define int long long\n#define endl '\\n'\n#define ld long double\n#define NO cout << \"NO\" << endl\n#define YES cout << \"YES\" << endl\nint ceildiv(int one, int two) {if (one % two == 0) {return one / two;}else {return one / two + 1;}} int power(int n, int pow, int m) {if (pow == 0) return 1;if (pow % 2 == 0) {ll x = power(n, pow / 2, m);return (x * x) % m;}else return (power(n, pow - 1, m) * n) % m;} int gcd(int a, int b) { if (!b)return a; return gcd(b, a % b);} int factorial(int n, int mod) {if (n > 1)return (n * factorial(n - 1, mod)) % mod; else return 1;} int lcm(int a, int b) {return (a * b) / gcd(a, b);} vector<int> read(int n) {vector<int> a; for (int i = 0; i < n; i++) { int x; cin >> x; a.pb(x);} return a;}struct prefix_sum{vint pref;void build(vint a){pref.pb(0);for(int i = 0; i < a.size(); i++){pref.pb(pref.back()+a[i]);}}int get(int l, int r){return pref[r]-pref[l-1];}};//mesanu\n\nvoid solve()\n{\n    int n, c;\n    cin >> n >> c;\n    vector<pair<int, int>> a;\n    for(int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        a.pb({x+min(i+1, n-i), x+i+1});\n    }\n    sort(all(a));\n    vector<int> pref;\n    pref.pb(0);\n    for(int i = 0; i < n; i++)\n    {\n        pref.pb(pref.back()+a[i].fr);\n    }\n    int ans = 0;\n    for(int i = 0; i < n; i++)\n    {\n        int new_c = c-a[i].sc;\n        int l = 0, r = n;\n        int mx = 0;\n        while(l <= r)\n        {\n            int mid = l+r>>1;\n            // Calculate price\n            int price = pref[mid];\n            int now = mid+1;\n            if(mid > i)\n            {\n                price-=a[i].fr;\n                now--;\n            }\n            if(price <= new_c)\n            {\n                mx = max(now, mx);\n                l = mid+1;\n            }\n            else\n            {\n                r = mid-1;\n            }\n        }\n        ans = max(ans, mx);\n    }\n    cout << ans << endl;\n}\n\nint32_t main(){\n    startt\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}