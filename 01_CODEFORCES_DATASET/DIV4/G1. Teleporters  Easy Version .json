{"link": "https://codeforces.com//contest/1791/problem/G1", "problemId": "1764447", "shortId": "1791G1", "contest_number": "1791", "name": "G1. Teleporters  Easy Version ", "statement": "Consider the points  on the number line. There is a teleporter located on each of the points . At point , you can do the following:  Move left one unit: it costs  coin.  Move right one unit: it costs  coin.  Use a teleporter at point , if it exists: it costs  coins. As a result, you teleport to point . Once you use a teleporter, you  use it again. You have  coins, and you start at point . What's the most number of teleporters you can use?", "input": "The input consists of multiple test cases. The first line contains an integer  ()\u00a0\u2014 the number of test cases. The descriptions of the test cases follow. The first line of each test case contains two integers  and  (; ) \u00a0\u2014 the length of the array and the number of coins you have respectively. The following line contains  space-separated integers  ()\u00a0\u2014 the costs to use the teleporters. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, output the maximum number of teleporters you can use.", "tutorial": "It's easy to see that it's optimal to only move right or to use a portal once we are at it. We can notice that when we teleport back, the problem is independent of the previous choices. We still are at point  and have some portals left. Thus, we can just find out the individual cost of each portal, sort portals by individual costs, and take them from smallest to largest by cost as long as we can. The cost of portal  is  (since we pay  to use it and need  moves to get to it).", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define ll long long\n\n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n\nvoid solve() {\n    int n, c, ans = 0; cin >> n >> c;\n    priority_queue<int> q;\n    for(int i = 1, x; i <= n; ++i) {\n        cin >> x;\n        q.push(-x - i);\n    }\n    while(!q.empty()) {\n        int x = -q.top(); q.pop();\n        if(x > c) break;\n        ++ans;\n        c -= x;\n    }\n    cout << ans << \"\\n\";\n}   \n \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}