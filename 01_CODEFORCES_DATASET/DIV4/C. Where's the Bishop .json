{"link": "https://codeforces.com//contest/1692/problem/C", "problemId": "1429117", "shortId": "1692C", "contest_number": "1692", "name": "C. Where's the Bishop ", "statement": "Mihai has an  chessboard whose rows are numbered from  to  from top to bottom and whose columns are numbered from  to  from left to right.Mihai has placed exactly one bishop on the chessboard.  (In other words, the row and column of the bishop are between  and , inclusive.)The bishop attacks in all directions diagonally, and there is no limit to the distance which the bishop can attack. Note that the cell on which the bishop is placed is also considered attacked.      Mihai has marked all squares the bishop attacks, but forgot where the bishop was! Help Mihai find the position of the bishop.", "input": "The first line of the input contains a single integer  ()\u00a0\u2014 the number of test cases. The description of test cases follows. There is an empty line before each test case. Each test case consists of  lines, each containing  characters. Each of these characters is either '' or '', denoting a square under attack and a square not under attack, respectively.", "output": "For each test case, output two integers  and  ()\u00a0\u2014 the row and column of the bishop.  The input is generated in such a way that there is always exactly one possible location of the bishop that is not on the edge of the board.", "tutorial": "There are many ways to solve the problem. One way is to look for the following pattern:  There can only be one such pattern if there is one bishop and it's not on the edge of the board. We can iterate through all cells and see if we can match this pattern, and if we can we output the centre cell.You can also look at the positions of the two diagonals and intersect them, but it requires more implementation.Time complexity:  per testcase.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n\tchar g[9][9];\n\tfor (int i = 1; i <= 8; i++) {\n\t\tfor (int j = 1; j <= 8; j++) {\n\t\t\tcin >> g[i][j];\n\t\t}\n\t}\n\tfor (int i = 2; i <= 7; i++) {\n\t\tfor (int j = 2; j <= 7; j++) {\n\t\t\tif (g[i][j] == '#' && g[i - 1][j - 1] == '#' && g[i - 1][j + 1] == '#' && g[i + 1][j - 1] == '#' && g[i + 1][j + 1] == '#') {\n\t\t\t\tcout << i << ' ' << j << '\\n'; return;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n    // solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}