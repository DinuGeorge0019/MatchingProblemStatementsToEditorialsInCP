{"link": "https://codeforces.com//contest/1807/problem/F", "problemId": "1838166", "shortId": "1807F", "contest_number": "1807", "name": "F. Bouncy Ball", "statement": "You are given a room that can be represented by a  grid. There is a ball at position  (the intersection of row  and column ), and it starts going diagonally in one of the four directions:  The ball is going down and right, denoted by ; it means that after a step, the ball's location goes from  to .  The ball is going down and left, denoted by ; it means that after a step, the ball's location goes from  to .  The ball is going up and right, denoted by ; it means that after a step, the ball's location goes from  to .  The ball is going up and left, denoted by ; it means that after a step, the ball's location goes from  to . After each step, the ball maintains its direction unless it hits a wall (that is, the direction takes it out of the room's bounds in the next step). In this case, the ball's direction gets flipped along the axis of the wall; if the ball hits a corner, both directions get flipped. Any instance of this is called a . The ball never stops moving.  In the above example, the ball starts at  and goes  until it reaches the bottom wall, then it bounces and continues in the direction . After reaching the left wall, the ball bounces and continues to go in the direction . When the ball reaches the upper wall, it bounces and continues in the direction . After reaching the bottom-right corner, it bounces  and continues in direction , and so on.Your task is to find how many bounces the ball will go through until it reaches cell  in the room, or report that it never reaches cell  by printing .Note that the ball first goes in a cell and only after that bounces if it needs to.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains six integers and a string  (; ; ; )\u00a0\u2014 the dimensions of the grid, the starting coordinates of the ball, the coordinates of the final cell and the starting direction of the ball. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, output a single integer\u00a0\u2014 the number of bounces the ball does until it reaches cell  for the first time, or  if the ball never reaches the final cell.", "tutorial": "We can see that there are at most  states the ball can be in, because there are  cells and  states of direction. We can simulate the bouncing process, keeping count of the bounces until we arrive at the finish cell when we can output the answer, or we arrive at a previously visited state and end up in a loop, then we can output -1.Bonus: Can you prove there are at most  states for any given starting position?", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n \nvoid solve()\n{\n    int n, m, x1, y1, x2, y2;\n    string d_string;\n    cin >> n >> m >> x1 >> y1 >> x2 >> y2;\n    x1--;x2--;y1--;y2--;\n    cin >> d_string;\n    int d = (d_string[0] == 'U' ? 1+(d_string[1] == 'R' ? 2 : 0) : 0+(d_string[1] == 'R' ? 2 : 0));\n    bool vis[n][m][4];\n    memset(vis, false, sizeof(vis));\n    int i = x1, j = y1;\n    int bounces = 0;\n    while(!vis[i][j][d])\n    {\n        if(i == x2 && j == y2){cout << bounces << endl; return;}\n        int na = 0;\n        if(d%2 == 1 && i == 0){d-=1;na++;}\n        if(d%2 == 0 && i == n-1){d+=1;na++;}\n        if(d >= 2 && j == m-1){d-=2;na++;}\n        if(d < 2 && j == 0){d+=2;na++;}\n        bounces+=min(1, na);\n        if(vis[i][j][d])\n        {\n            break;\n        }\n        vis[i][j][d] = true;\n        if(d%2 == 1){i--;}else{i++;}\n        if(d >= 2){j++;}else{j--;}\n    }\n    cout << -1 << endl;\n}\n \nint32_t main(){\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}