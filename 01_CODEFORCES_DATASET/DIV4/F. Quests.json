{"link": "https://codeforces.com//contest/1760/problem/F", "problemId": "1654043", "shortId": "1760F", "contest_number": "1760", "name": "F. Quests", "statement": "There are  quests. If you complete the -th quest, you will gain  coins. You can only complete at most one quest per day. However, once you complete a quest, you cannot do the same quest again for  days. (For example, if  and you do quest  on day , then you cannot do it on day  or , but you can do it again on day .)You are given two integers  and . Find the maximum value of  such that you can gain at least  coins over  days. If no such  exists, output . If  can be arbitrarily large, output .", "input": "The input consists of multiple test cases. The first line contains an integer  ()\u00a0\u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains three integers  (; ; )\u00a0\u2014 the number of quests, the number of coins you need, and the number of days. The second line of each test case contains  integers  ()\u00a0\u2014 the rewards for the quests. The sum of  over all test cases does not exceed , and the sum of  over all test cases does not exceed .", "output": "For each test case, output one of the following.    If no such  exists, output .  If  can be arbitrarily large, output .  Otherwise, output a single integer\u00a0\u2014 the maximum value of  such that you can gain at least  coins over  days.   Please note, the checker is  , and you should output strings exactly as they are given.", "tutorial": "Let's fix $$$k$$$ and find the maximum number of coins we can get. Here we can do a greedy solution: at every step, we should always take the most rewarding quest. (Intuitively, it makes sense, since doing more rewarding quests earlier allows us to do them again later.) If no quests are available, we do nothing. To implement this, sort the quests in decreasing order, and $$$0$$$-index them. On day $$$i$$$ we should do quest $$$i \\bmod k$$$, provided that this value is less than $$$n$$$. This is because after every $$$k$$$ days, we cycle back to the first quest. Thus we solved the problem for a fixed $$$k$$$ in $$$\\mathcal{O}(d)$$$ with $$$\\mathcal{O}(n \\log n)$$$ precomputation to sort the array.Now to solve the problem, we can binary search on the answer, since if some $$$k$$$ works, then all smaller $$$k$$$ work. The minimum value of $$$k$$$ is $$$0$$$, and the maximum value is $$$n$$$ (for larger $$$k$$$, we won't be able to do the same quest multiple times anyways, so it's useless to consider them). If we find that $$$k$$$ always goes towards the smaller end of our binary search and $$$k=0$$$ still fails, we output . If we find that $$$k$$$ always goes towards the larger end of our binary search and $$$k=n$$$ still fails, we output . Otherwise, just output $$$k$$$.The overall time complexity is $$$\\mathcal{O}(n \\log n + d \\log n)$$$. It is not hard to improve the solution to $$$\\mathcal{O}(n \\log n)$$$. Originally, I proposed the problem this way, but we ended up removing this part of the problem because the implementation of this solution was tricky enough.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 200007;\nconst int MOD = 1000000007;\n\nvoid solve() {\n\tint n, d;\n\tlong long c;\n\tcin >> n >> c >> d;\n\tlong long a[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a, a + n, greater<long long>());\n\tint l = 0, r = d + 2;\n\twhile (l < r) {\n\t\tint m = l + (r - l + 1) / 2;\n\t\tlong long tot = 0;\n\t\tint curr = 0;\n\t\tfor (int i = 0; i < d; i++) {\n\t\t\tif (i % m < n) {tot += a[i % m];}\n\t\t}\n\t\tif (tot >= c) {\n\t\t\tl = m;\n\t\t}\n\t\telse {\n\t\t\tr = m - 1;\n\t\t}\n\t}\n\tif (l == d + 2) {cout << \"Infinity\\n\"; return;}\n\tif (l == 0) {cout << \"Impossible\\n\"; return;}\n\tcout << l - 1 << '\\n';\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}