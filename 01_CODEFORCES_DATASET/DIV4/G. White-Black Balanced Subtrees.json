{"link": "https://codeforces.com//contest/1676/problem/G", "problemId": "1394659", "shortId": "1676G", "contest_number": "1676", "name": "G. White-Black Balanced Subtrees", "statement": "You are given a rooted tree consisting of  vertices numbered from  to . The root is vertex . There is also a string  denoting the color of each vertex: if , then vertex  is black, and if , then vertex  is white.A subtree of the tree is called balanced if the number of white vertices equals the number of black vertices. Count the number of balanced subtrees.A  is a connected undirected graph without cycles. A  is a tree with a selected vertex, which is called the . In this problem, all trees have root .The tree is specified by an array of parents  containing  numbers:  is the parent of the vertex with the number  for all . The parent of a vertex  is a vertex that is the next vertex on a simple path from  to the root.The  of a vertex  is the set of all vertices that pass through  on a simple path to the root. For example, in the picture below,  is in the subtree of  because the simple path  passes through . Note that a vertex is included in its subtree, and the subtree of the root is the entire tree.  The picture shows the tree for , , and . The subtree at the vertex  is balanced. ", "input": "The first line of input contains an integer  () \u2014 the number of test cases. The first line of each test case contains an integer  ()\u00a0\u2014 the number of vertices in the tree. The second line of each test case contains  integers  ()\u00a0\u2014 the parents of the vertices . The third line of each test case contains a string  of length  consisting of the characters  and \u00a0\u2014 the coloring of the tree. It is guaranteed that the sum of the values  over all test cases does not exceed .", "output": "For each test case, output a single integer\u00a0\u2014 the number of balanced subtrees.", "tutorial": "Let's run a dynamic programming from the leaves to the root. For each vertex store the values of the number of balanced subtrees, as well as the number of white and black vertices in it. Then from a vertex we can count the total number of white vertices in its subtree as well as the black vertices in its subtree, and update our total if they are equal. Remember to include the color of the vertex itself in these counts. The answer is the answer at the root.Therefore the problem is solved in  time. ", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 200007;\nconst int MOD = 1000000007;\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tvector<int> child[n + 7];\n\tfor (int i = 2; i <= n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tchild[x].push_back(i);\n\t}\n\tstring s;\n\tcin >> s;\n\tint res = 0;\n\tfunction<int(int)> dp = [&] (int x) {\n\t\tint bal = (s[x - 1] == 'B') ? -1 : 1;\n\t\tif (child[x].empty()) {return bal;}\n\t\tfor (int i : child[x]) {\n\t\t\tbal += dp(i);\n\t\t}\n\t\tif (bal == 0) {res++;}\n\t\treturn bal;\n\t};\n\tdp(1);\n\tcout << res << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n    // solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}