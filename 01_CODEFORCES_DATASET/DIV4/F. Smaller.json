{"link": "https://codeforces.com//contest/1742/problem/F", "problemId": "1584061", "shortId": "1742F", "contest_number": "1742", "name": "F. Smaller", "statement": "Alperen has two strings,  and  which are both initially equal to \"\". He will perform  operations of two types on the given strings:   \u2014 Append the string  exactly  times at the end of string . In other words, .   \u2014 Append the string  exactly  times at the end of string . In other words, . After each operation, determine if it is possible to  the characters of  and  such that  is lexicographically smaller than .Note that the strings change after performing each operation and  go back to their initial states. Simply speaking, the lexicographical order is the order in which words are listed in a dictionary. A formal definition is as follows: string  is lexicographically smaller than string  if there exists a position  such that , and for all , . If no such  exists, then  is lexicographically smaller than  if the length of  is less than the length of . For example,  and , where we write  if  is lexicographically smaller than .", "input": "The first line of the input contains an integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains an integer  \u00a0\u2014 the number of operations Alperen will perform. Then  lines follow, each containing two positive integers  and  (; ) and a non-empty string  consisting of lowercase English letters \u2014 the type of the operation, the number of times we will append string  and the string we need to append respectively. It is guaranteed that the sum of  over all test cases doesn't exceed  and that the sum of lengths of all strings  in the input doesn't exceed .", "output": "For each operation, output \"\", if it is possible to arrange the elements in both strings in such a way that  is lexicographically smaller than  and \"\" otherwise.", "tutorial": "First of all, let's think about how we should rearrange the two strings in such a way that  (if that is ever possible). It's always optimal to arrange 's characters increasingly in lexicographic order and 's characters decreasingly.Since initially both  and  contain a character \"\", the first time  receives any other letter than \"\" the answer will always be \"\", because that character will always be lexicographically larger than 's first character which should be \"\".In the other case, we know that  doesn't have any other characters than \"\", so we can compare the string  with multiple \"\" characters and we know that  will be smaller if and only if it's only formed of \"\"s and has a smaller size than .", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define ll long long\n \n#define       forn(i,n)              for(int i=0;i<n;i++)\n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n\nvoid solve() {\n    int q; cin >> q;\n    bool otherA = false, otherB = false;\n    ll cntA = 0, cntB = 0;\n    while(q--) {\n        ll d, k; string x; cin >> d >> k >> x;\n        for(auto c: x) {\n            if(d == 1) {\n                if(c != 'a') otherA = 1;\n                else cntA += k;\n            } else {\n                if(c != 'a') otherB = 1;\n                else cntB += k;\n            } \n        }\n        if(otherB) {\n            cout << \"YES\\n\";\n        } else if(!otherA && cntA < cntB) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n}   \n \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}