{"link": "https://codeforces.com//contest/1722/problem/D", "problemId": "1524436", "shortId": "1722D", "contest_number": "1722", "name": "D. Line", "statement": "There are  people in a horizontal line, each looking either to the left or the right. Each person counts the number of people in the direction they are looking. The  of the line is the sum of each person's count.For example, in the arrangement , where  stands for a person looking left and  stands for a person looking right, the counts for each person are , and the value is .You are given the initial arrangement of people in the line. For each  from  to , determine the maximum value of the line if you can change the direction of   people.", "input": "The input consists of multiple test cases. The first line contains an integer  ()\u00a0\u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains an integer  ()\u00a0\u2014 the length of the line. The following line contains a string consisting of  characters, each of which is either  or , representing a person facing left or right, respectively\u00a0\u2014 the description of the line. It is guaranteed that the sum of  over all test cases does not exceed . Please note that the answer for some test cases won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like  for C++).", "output": "For each test case, output  space-separated non-negative integers\u00a0\u2014 the maximum value of the line if you can change the direction of   people for each  from  to , inclusive.", "tutorial": "For each person, let's calculate how much the value will change if they turn around. For example, in the line , if the -th person turns around, then the value of the line will change by , , , , , respectively. (For instance, if the second person turns around, they see  people before and  person after, so the value of the line changes by  if they turn around.)Now note that if a person turns around, it doesn't affect anyone else's value. So the solution is a greedy one: let's sort the array of values in increasing order. Afterwards, we should go from the left to the right, and see if the value will increase if this person turns around; if it does, we should add it to the current total and continue.The time complexity of this solution is  per testcase.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 200007;\nconst int MOD = 1000000007;\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tlong long tot = 0;\n\tvector<long long> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == 'L') {\n\t\t\tv.push_back((n - 1 - i) - i);\n\t\t\ttot += i;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(i - (n - 1 - i));\n\t\t\ttot += n - 1 - i;\n\t\t}\n\t}\n\tsort(v.begin(), v.end(), greater<int>());\n\tfor (int i = 0; i < n; i++) {\n\t\tif (v[i] > 0) {tot += v[i];}\n\t\tcout << tot << ' ';\n\t}\n\tcout << '\\n';\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}