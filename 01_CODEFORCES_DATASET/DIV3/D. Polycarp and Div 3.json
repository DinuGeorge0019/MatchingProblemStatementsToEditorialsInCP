{"link": "https://codeforces.com//contest/1005/problem/D", "problemId": "196284", "shortId": "1005D", "contest_number": "1005", "name": "D. Polycarp and Div 3", "statement": "Polycarp likes numbers that are divisible by 3.He has a huge number . Polycarp wants to cut from it the maximum number of numbers that are divisible by . To do this, he makes an arbitrary number of vertical cuts between pairs of adjacent digits. As a result, after  such cuts, there will be  parts in total. Polycarp analyzes each of the obtained numbers and finds the number of those that are divisible by .For example, if the original number is , then Polycarp can cut it into three parts with two cuts: . As a result, he will get two numbers that are divisible by .Polycarp can make an arbitrary number of vertical cuts, where each cut is made between a pair of adjacent digits. The resulting numbers cannot contain extra leading zeroes (that is, the number can begin with  if and only if this number is exactly one character ''). For example, ,  and  are not valid numbers, but ,  and  are valid.What is the maximum number of numbers divisible by  that Polycarp can obtain?", "input": "The first line of the input contains a positive integer . The number of digits of the number  is between  and , inclusive. The first (leftmost) digit is not equal to .", "output": "Print the maximum number of numbers divisible by  that Polycarp can get by making vertical cuts in the given number .", "tutorial": "There are multiple approaches to solve this problem. We will use dynamic programming approach.Let's calculate values of the array , where  is the answer for prefix of the length . Obviously, , since for the empty string (the prefix of the length ) the answer is .For  you can find  in the following way.Let's look in the last digit of the prefix of length . It has index . Either it doesn't belong to segment divisible by , or it belongs.If it doesn't belongs, it means we can't use the last digit, so . If it belongs we need to find shortest  that is divisible by  and try to update  with the value . It means that we \"bite off\" the shortest divisible by  suffix and reduce the problem to a previous.A number is divisible by  if and only if sum of its digits is divisible by . So the task is to find the shortest suffix of  with sum of digits divisible by . If such suffix is  then  and  have the same remainder of sum of digits modulo .Let's maintain  \u2014 array of the length , where  is the length of the longest processed prefix with sum of digits equal to  modulo . Use  if there is no such prefix. It is easy to see that  where  is the sum of digits on the -th prefix modulo .So to find the maximal  that substring  is divisible by , just check that  and use , where  is the sum of digits on the -th prefix modulo .It means that to handle case that the last digit belongs to divisible by  segment, you should try to update  with value . In other words, just do .Sequentially calculating the values of , we obtain a linear  solution.\n", "solution": "string s;\ncin >> s;\nint n = s.length();\n\nint r = 0;\nvector<int> fin(3, -1);\nfin[0] = 0;\n\nvector<int> z(n + 1);\nfor (int i = 1; i <= n; i++) {\n    r = (r + s[i - 1] - '0') % 3;\n    z[i] = z[i - 1];\n    if (fin[r] != -1)\n        z[i] = max(z[i], z[fin[r]] + 1);\n    fin[r] = i;\n}\n\ncout << z[n] << endl;", "interactive": false, "noSolution": false, "noTutorial": false}