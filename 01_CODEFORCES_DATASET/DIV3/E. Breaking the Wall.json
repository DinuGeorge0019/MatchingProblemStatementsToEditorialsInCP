{"link": "https://codeforces.com//contest/1674/problem/E", "problemId": "1387201", "shortId": "1674E", "contest_number": "1674", "name": "E. Breaking the Wall", "statement": "Monocarp plays \"Rage of Empires II: Definitive Edition\" \u2014 a strategic computer game. Right now he's planning to attack his opponent in the game, but Monocarp's forces cannot enter the opponent's territory since the opponent has built a wall.The wall consists of  sections, aligned in a row. The -th section initially has durability . If durability of some section becomes  or less, this section is considered broken.To attack the opponent, Monocarp needs to break at least two sections of the wall (any two sections: possibly adjacent, possibly not). To do this, he plans to use an onager \u2014 a special siege weapon. The onager can be used to shoot any section of the wall; the shot deals  damage to the target section and  damage to adjacent sections. In other words, if the onager shoots at the section , then the durability of the section  decreases by , and the durability of the sections  and  (if they exist) decreases by  each. Monocarp can shoot at any sections any number of times, .Monocarp wants to calculate the minimum number of onager shots needed to break at least two sections. Help him!", "input": "The first line contains one integer  () \u2014 the number of sections. The second line contains the sequence of integers  (), where  is the initial durability of the -th section.", "output": "Print one integer \u2014 the minimum number of onager shots needed to break at least two sections of the wall.", "tutorial": "Let's analyze three cases based on the distance between two sections we are going to break:  break two neighboring sections ( and );  break two sections with another section between them ( and );  break two sections with more than one section between them. Why exactly these cases? Because the damage from the shots and the possibility to hit both sections with the same shot depends on the distance between them.If there is more than one section between the two we want to break, then any shot hits only one of these sections, so each shot should be aimed at one of those sections, and we break them independently. Let's pick two sections with minimum durability and calculate the number of shots required to break them; if these sections are  and , then the required number of shots is . It actually does not matter if the distance between them is less than ; if it is so, these sections will be analyzed in one of the other cases.Okay, now let's deal with two sections having exactly one section between them. We can iterate on all combinations of these sections (iterate on  from  to  and pick sections  and ). Let's analyze how can we damage them. If we shoot at the section between them, we deal  damage to both sections; if we shoot at one of those sections, we deal  damage to it and  damage to the other section. So, each shot distributes  damage between these two sections the way we want to distribute it, and the number of shots required to break these two sections is .The case when we try to break two adjacent sections is the trickiest one. Let's say that these sections are  and , , and . If we target one of these sections, we deal  damage to it and  damage to the other section. Let's try to run the following algorithm: shoot at the section with higher durability, until both of them break. It can be slow, but we can see that after the first  shots, the durabilities of the sections become equal, and each pair of shots after that deals  damage to both sections. So, we can model the first  shots, subtract  from  and  from , and then we'll need  shots. The only case when this doesn't work is if we break both sections before we equalize their durabilities; it means that  and we need to do only  shots.", "solution": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <iomanip>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cmath>\n\n#define forn(i, n) for(int i=0;i<n;++i)\n#define fore(i, l, r) for(int i = int(l); i <= int(r); ++i)\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y1 ________y1\n#define y second\n#define ft first\n#define sc second\n#define pt pair<int, int>\n\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\ntypedef long long li;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int INF = 1000 * 1000 * 1000;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n\nconst int N = 200 * 1000 + 13;\n\nint n;\nint a[N];\n\ninline void read() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }   \n}\n\ninline void solve() {   \n    int ans = INF;\n    for (int i = 0; i < n - 1; i++) {\n        int cur = 0;\n        int x = a[i], y = a[i + 1];\n        if (x < y) {\n            swap(x, y);\n        }\n        int cnt = min(x - y, (x + 1) / 2);\n        cur += cnt;\n        x -= 2 * cnt;\n        y -= cnt;\n        if (x > 0 && y > 0) {\n            cur += (x + y + 2) / 3;\n        }\n        ans = min(ans, cur);    \n    }\n\n    for (int i = 0; i < n - 2; i++) {\n        int cur = 0;\n        int x = a[i], y = a[i + 2];\n        if (x < y) {\n            swap(x, y);\n        }\n        int cnt = (x - y + 1) / 2;\n        cur += cnt;\n        cur += y;\n        ans = min(ans, cur);\n    }\n    \n    sort(a, a + n);\n    ans = min(ans, (a[0] + 1) / 2 + (a[1] + 1) / 2);\n    cout << ans << endl;\n}\n\nint main () {\n#ifdef fcspartakm\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    srand(time(NULL));\n    cerr << setprecision(10) << fixed;\n    \n    read();\n    solve();\n \n    //cerr << \"TIME: \" << clock() << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}