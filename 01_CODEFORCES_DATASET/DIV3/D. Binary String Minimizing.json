{"link": "https://codeforces.com//contest/1256/problem/D", "problemId": "459827", "shortId": "1256D", "contest_number": "1256", "name": "D. Binary String Minimizing", "statement": "You are given a binary string of length  (i.\u2009e. a string consisting of  characters '' and '').In one move you can swap two adjacent characters of the string. What is the lexicographically minimum possible string you can obtain from the given one if you can perform  than  moves? It is possible that you do not perform any moves at all.Note that you can swap the same pair of adjacent characters with indices  and  arbitrary (possibly, zero) number of times. Each such swap is considered a separate move.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. The first line of the test case contains two integers  and  () \u2014 the length of the string and the number of moves you can perform. The second line of the test case contains one string consisting of  characters '' and ''. It is guaranteed that the sum of  over all test cases does not exceed  ().", "output": "For each test case, print the answer on it: the lexicographically minimum possible string of length  you can obtain from the given one if you can perform  than  moves.", "tutorial": "This problem has a very standard solution: let's take the leftmost zero, place it as left as possible, and solve the problem without this zero and all operations we spent.But we should do it fast. Let's go from left to right and carry the number of ones on the prefix . If we meet , let's just increase  and continue the algorithm. It is obvious that if we meet  we need to make exactly  swaps to place it before all ones. If we can do it, let's just add  to the answer, decrease  by  and continue. Otherwise, this zero will be between some of these  ones and we can place it naively. In this case, the suffix of the string will not change. If after all operations we didn't meet the case above, let's add all ones to the suffix of the resulting string.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint n;\n\t\tlong long k;\n\t\tstring s;\n\t\tcin >> n >> k >> s;\n\t\tstring res;\n\t\tint cnt = 0;\n\t\tbool printed = false;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (s[i] == '0') {\n\t\t\t\tif (cnt <= k) {\n\t\t\t\t\tres += '0';\n\t\t\t\t\tk -= cnt;\n\t\t\t\t} else {\n\t\t\t\t\tres += string(cnt - k, '1');\n\t\t\t\t\tres += '0';\n\t\t\t\t\tres += string(k, '1');\n\t\t\t\t\tres += s.substr(i + 1);\n\t\t\t\t\tcout << res << endl;\n\t\t\t\t\tprinted = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\n\t\tif (!printed) {\n\t\t\tres += string(cnt, '1');\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}