{"link": "https://codeforces.com//contest/1772/problem/F", "problemId": "1699973", "shortId": "1772F", "contest_number": "1772", "name": "F. Copy of a Copy of a Copy", "statement": "It all started with a black-and-white picture, that can be represented as an  matrix such that all its elements are either  or . The rows are numbered from  to , the columns are numbered from  to .Several operations were performed on the picture (possibly, zero), each of one of the two kinds:   choose a cell such that it's not on the border (neither row  or , nor column  or ) and it's surrounded by four cells of the opposite color (four zeros if it's a one and vice versa) and paint it the opposite color itself;  make a copy of the current picture. Note that the order of operations could be arbitrary, they were not necessarily alternating.You are presented with the outcome: all  copies that were made. Additionally, you are given the initial picture. However, all  pictures are shuffled.Restore the sequence of the operations. If there are multiple answers, print any of them. The tests are constructed from the real sequence of operations, i.\u2009e. at least one answer always exists.", "input": "The first line contains three integers  and  (; )\u00a0\u2014 the number of rows and columns of the pictures and the number of copies made, respectively. Then  pictures follow\u00a0\u2014  copies and the initial picture. Their order is arbitrary. Each picture consists of  lines, each consisting of  characters, each character is either  or . ", "output": "In the first line, print a single integer\u00a0\u2014 the index of the initial picture. The pictures are numbered from  to  in the order they appear in the input. In the second line, print a single integer \u00a0\u2014 the number of operations. Each of the next  lines should contain an operation. The operations should be listed in order they were applied. Each operation is one of two types:      \u00a0\u2014 recolor a cell  (the -th cell in the -th row, it should not be on the border and it should be surrounded by four cells of opposite color to itself);   \u00a0\u2014 make a copy of the current picture and assign it index  (picture with index the  should be equal to the current picture).  Each index from  to  should appear in the output exactly once\u00a0\u2014 one of them is the index of the initial picture, the remaining  are arguments of the operations of the second kind. If there are multiple answers, print any of them. The tests are constructed from the real sequence of operations, i.\u2009e. at least one answer always exists.", "tutorial": "Notice the following: once you apply the recolor operation to some cell, you can never recolor it again. That happens because you can't recolor its neighbors too as each of them has at least one neighbor of the same color\u00a0\u2014 this cell itself.In particular, that implies that applying a recolor operation always decreases the possible number of operations that can be made currently. It doesn't always decrease them by : from  to  operations can become unavailable, but it always decreases.That gives us an order of copies. Just sort them in the decreasing order of the number of recolor operations that can be made currently. If the numbers are the same, the copies must be equal, so their order doesn't matter.The only thing remains is to apply the operations. Turns out, their order doesn't matter at all. Consider all different cells for a pair of adjacent pictures. It's never possible that there are two different cells that are adjacent to each other. Thus, no operation can interfere with another one. Just print all positions of different cells in any order you want and make a copy.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define forn(i, n) for(int i = 0; i < int(n); i++)\n\nstruct op{\n    int t, x, y, i;\n};\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main(){\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<vector<string>> a(k + 1, vector<string>(n));\n    forn(z, k + 1) forn(i, n)\n        cin >> a[z][i];\n    \n    vector<int> cnt(k + 1);\n    forn(z, k + 1){\n        for (int i = 1; i < n - 1; ++i){\n            for (int j = 1; j < m - 1; ++j){\n                bool ok = true;\n                forn(t, 4)\n                    ok &= a[z][i][j] != a[z][i + dx[t]][j + dy[t]];\n                cnt[z] += ok;\n            }\n        }\n    }\n    \n    vector<int> ord(k + 1);\n    iota(ord.begin(), ord.end(), 0);\n    sort(ord.begin(), ord.end(), [&cnt](int x, int y){\n        return cnt[x] > cnt[y];\n    });\n    \n    vector<op> ops;\n    forn(z, k){\n        forn(i, n) forn(j, m) if (a[ord[z]][i][j] != a[ord[z + 1]][i][j]){\n            a[ord[z]][i][j] ^= '0' ^ '1';\n            ops.push_back({1, i + 1, j + 1, -1});\n        }\n        ops.push_back({2, -1, -1, ord[z + 1] + 1});\n    }\n    \n    cout << ord[0] + 1 << '\\n';\n    cout << ops.size() << '\\n';\n    for (auto it : ops){\n        cout << it.t << \" \";\n        if (it.t == 1)\n            cout << it.x << \" \" << it.y << '\\n';\n        else\n            cout << it.i << '\\n';\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}