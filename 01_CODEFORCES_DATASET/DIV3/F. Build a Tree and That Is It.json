{"link": "https://codeforces.com//contest/1714/problem/F", "problemId": "1490432", "shortId": "1714F", "contest_number": "1714", "name": "F. Build a Tree and That Is It", "statement": "A tree is a connected undirected graph without cycles. Note that in this problem, we are talking about not rooted trees.You are given four positive integers  and . Construct a tree such that:  it contains  vertices numbered from  to ,  the distance (length of the shortest path) from vertex  to vertex  is ,  distance from vertex  to vertex  is ,  the distance from vertex  to vertex  is . Output any tree that satisfies all the requirements above, or determine that no such tree exists.", "input": "The first line of the input contains an integer  ()\u00a0\u2014the number of test cases in the test. This is followed by  test cases, each written on a separate line. Each test case consists of four positive integers  and  (). It is guaranteed that the sum of  values for all test cases does not exceed .", "output": "For each test case, print  if the suitable tree exists, and  otherwise.  If the answer is positive, print another  line each containing a description of an edge of the tree \u2014 a pair of positive integers , which means that the th edge connects vertices  and .  The edges and vertices of the edges can be printed in any order. If there are several suitable trees, output any of them.", "tutorial": "If the answer exists, you can hang the tree by some vertex such that the distances  and  can be expressed through the sums of distances to vertices  and . Then from the system of equations we express the required values of distances to vertices  and construct a suitable tree. If the distance to a vertex is , then that vertex is the root. There cannot be two roots, nor can there be negative distances.If none of the vertices of  is the root, then make vertex  the root. Next we build the required tree: add the required number of unique vertices on the path from the root to vertices . Note also that if the sum of distances is greater than or equal to , then we cannot build the tree either.The remaining vertices can be simply joined to the root.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nint main() {\n    int t;\n    cin >> t;\n    forn(tt, t) {\n        int n;\n        cin >> n;\n        vector<int> d(3);\n        forn(i, 3)\n            cin >> d[i];\n        int sum = d[0] + d[1] + d[2];\n        if (sum % 2 == 0) {\n            vector<int> w(3);\n            forn(i, 3)\n                w[i] = sum / 2 - d[(i + 1) % 3];\n            vector<int> sw(w.begin(), w.end());\n            sort(sw.begin(), sw.end());\n            if (sw[0] >= 0 && sw[1] >= 1) {\n                vector<pair<int,int>> edges;\n                int num = 3;\n                int center;\n                if (sw[0] == 0)\n                    center = min_element(w.begin(), w.end()) - w.begin();\n                else\n                    center = num++;\n                forn(i, 3) {\n                    int before = center;\n                    forn(j, w[i] - 1) {\n                        edges.push_back({before, num});\n                        before = num++;\n                    }\n                    if (w[i] > 0)\n                        edges.push_back({before, i});\n                }\n                if (num <= n) {\n                    while (num < n)\n                        edges.push_back({center, num++});\n                    cout << \"YES\" << endl;\n                    for (auto& [u, v]: edges)\n                        cout << u + 1 << \" \" << v + 1 << endl;\n                    continue;\n                }\n            }\n        }\n        cout << \"NO\" << endl;\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}