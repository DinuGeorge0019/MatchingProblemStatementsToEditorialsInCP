{"link": "https://codeforces.com//contest/1118/problem/C", "problemId": "300357", "shortId": "1118C", "contest_number": "1118", "name": "C. Palindromic Matrix", "statement": "Let's call some square matrix with integer values in its cells  if it doesn't change after the order of rows is reversed and it doesn't change after the order of columns is reversed.For example, the following matrices are :  The following matrices are  because they change after the order of rows is reversed:  The following matrices are  because they change after the order of columns is reversed:  You are given  integers. Put them into a matrix of  rows and  columns so that each number is used exactly once, each cell contains exactly one number and the resulting matrix is . If there are multiple answers, print any. If there is no solution, print \"\".", "input": "The first line contains one integer  (). The second line contains  integers  () \u2014 the numbers to put into a matrix of  rows and  columns.", "output": "If it is possible to put all of the  numbers into a matrix of  rows and  columns so that each number is used exactly once, each cell contains exactly one number and the resulting matrix is , then print \"\". Then print  lines with  space-separated numbers \u2014 the resulting matrix. If it's impossible to construct any matrix, then print \"\". You can print each letter in any case (upper or lower). For example, \"\", \"\" and \"\" are all acceptable.", "tutorial": "Basically, what does the matrix being palindromic imply? For each  values in cells , ,  and  are equal (all zero-indexed). You can easily prove it by reversing the order of rows or columns and checking the overlapping cells in them.Thus, all cells can be split up into equivalence classes. The even  case is simple: all classes have size . The odd  case has classes of sizes ,  and .Let's fill the classes one by one. Obviously, the order between the classes of the same size doesn't matter. I claim that filling the classes in order  in sizes construct the answer if any exists. The key observation is that each next size is divisible by the previous one.The implementation can come in lots of different forms and complexities. Mine works in , you can refer to it in attachment.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 1000 + 7;\n\nint cnt[N];\nint a[20][20];\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tforn(i, n * n){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\t++cnt[x];\n\t}\n\t\n\tvector<pair<int, pt>> cells;\n\tforn(i, (n + 1) / 2) forn(j, (n + 1) / 2){\n\t\tif (i != n - i - 1 && j != n - j - 1)\n\t\t\tcells.push_back({4, {i, j}});\n\t\telse if ((i != n - i - 1) ^ (j != n - j - 1))\n\t\t\tcells.push_back({2, {i, j}});\n\t\telse\n\t\t\tcells.push_back({1, {i, j}});\n\t}\n\t\n\tfor (auto cur : {4, 2, 1}){\n\t\tint lst = 1;\n\t\tfor (auto it : cells){\n\t\t\tif (it.first != cur) continue;\n\t\t\tint i = it.second.first;\n\t\t\tint j = it.second.second;\n\t\t\twhile (lst < N && cnt[lst] < cur)\n\t\t\t\t++lst;\n\t\t\tif (lst == N){\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ta[i][j] = a[n - i - 1][j] = a[i][n - j - 1] = a[n - i - 1][n - j - 1] = lst;\n\t\t\tcnt[lst] -= cur;\n\t\t}\n\t}\n\t\n\tputs(\"YES\");\n\tforn(i, n){\n\t\tforn(j, n)\n\t\t\tprintf(\"%d \", a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}