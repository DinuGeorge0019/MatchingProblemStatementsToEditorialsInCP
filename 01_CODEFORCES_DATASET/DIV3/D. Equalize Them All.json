{"link": "https://codeforces.com//contest/1144/problem/D", "problemId": "322485", "shortId": "1144D", "contest_number": "1144", "name": "D. Equalize Them All", "statement": "You are given an array  consisting of  integers. You can perform the following operations arbitrary number of times (possibly, zero):  Choose a pair of indices  such that  (indices  and  are adjacent) and set ;  Choose a pair of indices  such that  (indices  and  are adjacent) and set . The value  means the absolute value of . For example, , .Your task is to find the minimum number of operations required to obtain the array of equal elements and print the order of operations to do it...", "input": "The first line of the input contains one integer  () \u2014 the number of elements in . The second line of the input contains  integers  (), where  is the -th element of .", "output": "In the first line print one integer  \u2014 the minimum number of operations required to obtain the array of equal elements. In the next  lines print operations itself. The -th operation should be printed as a triple of integers , where  is either  or  ( means that you perform the operation of the first type, and  means that you perform the operation of the second type), and  and  are indices of adjacent elements of the array such that , . See the examples for better understanding. . If there are many possible answers, you can print any.", "tutorial": "Let's find the most frequent element in the array (using the array of frequencies , of course). Let this element be . If we will see the operations more carefully, we can see that the part of these operations means \"\". if  then this operation is , otherwise it is .Now let's consider the number of operations in the optimal answer. It is obvious that we need at least  operations to equalize all the elements. And it is also obvious that we can always do it with  such operations we have.How to restore the answer? There is an easy way to do it: find the first occurrence of . Let it be . Then let's go from  to  and set each element to the next element (element at the position  to ,  to  and so on). And don't forget to print right type of operation. Then let's go from left to right from  to  and if the -th element don't equal to  then set it to -th element using right operation.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\t\n\tvector<int> a(n), cnt(200 * 1000 + 1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\t++cnt[a[i]];\n\t}\n\t\n\tint val = max_element(cnt.begin(), cnt.end()) - cnt.begin();\n\tint pos = find(a.begin(), a.end(), val) - a.begin();\n\t\n\tcout << n - cnt[val] << endl;\n\tint siz = 0;\n\tfor (int i = pos - 1; i >= 0; --i) {\n\t\tcout << 1 + (a[i] > a[i + 1]) << \" \" << i + 1 << \" \" << i + 2 << \" \" << endl;\n\t\ta[i] = a[i + 1];\n\t\t++siz;\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tif (a[i + 1] != val) {\n\t\t\tassert(a[i] == val);\n\t\t\tcout << 1 + (a[i + 1] > a[i]) << \" \" << i + 2 << \" \" << i + 1 << \" \" << endl;\n\t\t\ta[i + 1] = a[i];\n\t\t\t++siz;\n\t\t}\n\t}\n\t\n\tassert(siz == n - cnt[val]);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}