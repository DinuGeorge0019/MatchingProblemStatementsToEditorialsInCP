{"link": "https://codeforces.com//contest/1741/problem/C", "problemId": "1580859", "shortId": "1741C", "contest_number": "1741", "name": "C. Minimize the Thickness", "statement": "You are given a sequence  consisting of   integers.Let's call a group of consecutive elements a . Each  is characterized by two indices: the index of its left end and the index of its right end. Denote by  a  of the sequence  with the left end in  and the right end in , i.e. .For example, if , then , ,  are .We split the given sequence  into  so that:   each element is in  one ;  the sums of elements for all  are . For example, if  = [], then such a sequence can be split into three : , , . Each element belongs to exactly , the sum of the elements of each  is .Let's define  of split as the length of the longest . For example, the thickness of the split from the example above is .Find the minimum thickness among all possible splits of the given sequence of  into  in the required way.", "input": "The first line contains a single integer  () \u2014 the number of test cases. Each test case is described by two lines. The first line of each test case contains a single integer  () \u2014 the length of the sequence . The second line of each test case contains exactly  integers:  () \u2014 elements of the sequence . It is guaranteed that the sum of  for all test cases does not exceed .", "output": "For each test case, output one integer \u2014 the minimum possible thickness of a split of the sequence  into . Note that there always exist a split, you can always consider whole sequence as one segment.", "tutorial": "Let's iterate over the length of the first segment of the split. Having fixed it, we actually fixed the sum that needs to be collected on all other segments. Since each element must belong to exactly one segment, we can build other segments greedily. If we have found a solution, we will remember the length of the longest segment in it and try to update the answer. We have  possible lengths of the first segment, for each of which we greedily built the answer for . Thus, the asymptotics of the solution will be .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 2020;\n\nint n;\nint arr[MAXN];\n\nint go(int i, int sum) {\n\tif (i == n) return 0;\n\tfor (int j = i + 1, cur = 0; j <= n; ++j) {\n\t\tcur += arr[j - 1];\n\t\tif (cur > sum) return n;\n\t\tif (cur == sum) return max(j - i, go(j, sum));\n\t}\n\treturn n;\n}\n\nint solve() {\n\tint ans = n;\n\tfor (int len = 1, sum = 0; len < n; ++len) {\n\t\tsum += arr[len - 1];\n\t\tans = min(ans, go(0, sum));\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint t; cin >> t;\n\twhile (t--) {\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcin >> arr[i];\n\t\tcout << solve() << endl;\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}