{"link": "https://codeforces.com//contest/1744/problem/D", "problemId": "1588809", "shortId": "1744D", "contest_number": "1744", "name": "D. Divisibility by 2 n", "statement": "You are given an array of positive integers .Make the product of all the numbers in the array (that is, ) divisible by .You can perform the following operation as many times as you like:  select an arbitrary index  () and replace the value  with . You cannot apply the operation repeatedly to a single index. In other words, all selected values of  must be different.Find the smallest number of operations you need to perform to make the product of all the elements in the array divisible by . Note that such a set of operations does not always exist.", "input": "The first line of the input contains a single integer  ) \u2014 the number test cases. Then the descriptions of the input data sets follow. The first line of each test case contains a single integer  () \u2014 the length of array . The second line of each test case contains exactly  integers:  (). It is guaranteed that the sum of  values over all test cases in a test does not exceed .", "output": "For each test case, print the least number of operations to make the product of all numbers in the array divisible by . If the answer does not exist, print .", "tutorial": "Let's notice that if we multiply the numbers , then the power of two of the product is equal to the sum of the powers of two in each of the numbers.Let's calculate the initial sum of the powers of twos in the product. This can be done as follows: let's take the element  and divide it by  as long as we can, while remembering to increase our counter by the number of occurrences of a power of two.Now let's move on to operations and note that choosing the index  will increase the degree of occurrence of two by a fixed number (that is, it does not matter when to apply this operation). Choosing an index  will increment the counter by a number  such that  is divisible by  but not by \u00a0\u2014 you can find this , again , by dividing by  while we can.Since we want to minimize the number of operations used, at each moment of time we will try to use an index that increases the counter by the largest number. To do this, it is enough to sort the indices by this index of increase and take them greedily from the largest increase to the smallest.We get the solution in .", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\nint t,n,cnt,s,ans;\nint a[200007];\nint br[200007];\n\nint main(){\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin>>t;\n    for(int i=1;i<=t;i++){\n        cin>>n;\n        for(int f=1;f<=n;f++)br[f]=0;\n        cnt=ans=0;\n\n        for(int f=1;f<=n;f++){\n            cin>>a[f];\n            while(a[f]%2==0){\n                a[f]/=2; cnt++;\n            }\n            s=f;\n            while(s%2==0){\n                s/=2; br[f]++;\n            }\n        }\n\n        sort(br+1,br+n+1);\n        for(int f=n;f>=1;f--){\n            if(cnt>=n)break;\n            cnt+=br[f]; ans++;\n        }\n\n        if(cnt>=n)cout<<ans<<\"\\n\";\n        else cout<<\"-1\\n\";\n    }\n\n    return 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}