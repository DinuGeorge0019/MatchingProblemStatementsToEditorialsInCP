{"link": "https://codeforces.com//contest/1759/problem/G", "problemId": "1648495", "shortId": "1759G", "contest_number": "1759", "name": "G. Restore the Permutation", "statement": "A sequence of  numbers is called  if it contains all numbers from  to  exactly once. For example, the sequences [], [] and [] are permutations, but [], [] and []\u00a0\u2014 are not.For a permutation  of even length  you can make an array  of length  such that:    for  For example, if  = [], then:         As a result, we made  = .For a given array , find the  permutation  such that you can make the given array  from it.If  = [], then the lexicographically minimal permutation from which it can be made is  = [], since:        A permutation  is lexicographically smaller than a permutation  if and only if there exists such  () that  and .", "input": "The first line of input data contains a single integer  ()\u00a0\u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains one even integer  (). The second line of each test case contains exactly  integers  () \u2014 elements of array . It is guaranteed that the sum of  values over all test cases does not exceed .", "output": "For each test case, print on a separate line:    lexicographically minimal permutation  such that you can make an array  from it;  or a number  if the permutation you are looking for does not exist. ", "tutorial": "First, let's check the  array for correctness, that is, that it has no repeating elements.Then let's look at the following ideas:   each number  must be paired with another permutation element , with  by the definition of array . Then, since we want a lexicographically minimal permutation, it is always more advantageous to put element  before .  for the permutation to be lexicographically minimal, the smallest possible numbers must be placed at the beginning. Consequently, the largest numbers must be placed at the end. Let's proceed as follows:   Let's select the set of  numbers that are not included in the  array.  For an element , find the maximum number  of the set  such that  and put that number in front of the element .  moving from the end of the array to its beginning, each element  will be matched with such an element. If at some point  can not be matched \u2014 array  is not composed correctly, and the answer to the query \u2014 \"\".  Otherwise, print \"\" and the resulting permutation . ", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\nint n;\n\nvoid solve(){\n    cin >> n;\n    vector<int>b(n / 2), p(n);\n    vector<bool>isUsed(n + 1, false);\n    set<int>unused;\n\n    for(int i = 0; i < n / 2; i++){\n        cin >> b[i];\n        p[i * 2 + 1] = b[i];\n        isUsed[b[i]] = true;\n    }\n    for(int i = 1; i <= n; i++){\n        if(!isUsed[i]) unused.insert(i);\n    }\n\n\n    if(int(unused.size()) != n / 2){\n        cout << \"-1\\n\";\n        return;\n    }\n\n    for(int i = n / 2 - 1; i >= 0; i--){\n        auto k = unused.upper_bound(p[2 * i + 1]);\n        if(k == unused.begin()){\n            cout << \"-1\\n\";\n            return;\n        }\n\n        k--;\n\n\n        if(*k < p[2 * i + 1]){\n            p[2 * i] = *k;\n            unused.erase(k);\n        }\n        else{\n            cout << \"-1\\n\";\n            return;\n        }\n    }\n    for(auto i : p) cout << i << ' ';\n    cout << endl;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while(t--){\n        solve();\n    }\n\n}", "interactive": false, "noSolution": false, "noTutorial": false}