{"link": "https://codeforces.com//contest/1399/problem/F", "problemId": "691722", "shortId": "1399F", "contest_number": "1399", "name": "F. Yet Another Segments Subset", "statement": "You are given  segments on a coordinate axis . The -th segment has borders . All points , for which  holds, belong to the -th segment.Your task is to choose the  by size (the number of segments) subset of the given set of segments such that each pair of segments in this subset either non-intersecting or one of them lies inside the other one.Two segments  and  are non-intersecting if they have . For example, segments  and ,  and  are non-intersecting, while segments  and ,  and  are intersecting.The segment  lies inside the segment  if  and . For example, segments , ,  and  lie inside the segment , while  and  are not.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the number of segments. The next  lines describe segments. The -th segment is given as two integers  and  (), where  is the left border of the -th segment and  is the right border of the -th segment. Additional constraint on the input: there are  in the list of segments. It is guaranteed that the sum of  does not exceed  ().", "output": "For each test case, print the answer: the  possible size of the subset of the given set of segments such that each pair of segments in this subset either non-intersecting or one of them lies inside the other one.", "tutorial": "Firstly, let's compress the given borders of segments (just renumerate them in such a way that the maximum value is the minimum possible and the relative order of integers doesn't change). Pretty standard approach.Now let's do recursive dynamic programming . This state stores the answer for the segment  (not necessarily input segment!). How about transitions? Firstly, if there is a segment covering the whole segment , why don't just take it? It doesn't change anything for us. The first transition is just skip the current left border and try to take the additional answer from the state . The second transition is the following: let's iterate over all possible segments starting at  (we can store all right borders of such segments in some array ). Let the current segment be . If , just skip it (if  then we can't take this segment into the answer because it's out of , and if  then we can't take it because we considered it already). Then we can take two additional answers: from  and from . Don't forger about some corner cases, like when  or  and something like that.You can get the answer if you run the calculation from the whole segment.What is the time complexity of this solution? We obviously have  states. And the number of transitions is also pretty easy to calculate. Let's fix some right border . For this right border, we consider  segments in total. Summing up, we get  transitions. So the time complexity is .P.S. I am sorry about pretty tight ML (yeah, I saw Geothermal got some memory issues because of using map). I really wanted to make it 512MB but just forgot to do that.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int>> rg;\nvector<vector<int>> dp;\n\nint calc(int l, int r) {\n\tif (dp[l][r] != -1) return dp[l][r];\n\tdp[l][r] = 0;\n\tif (l > r) return dp[l][r];\n\tbool add = count(rg[l].begin(), rg[l].end(), r); // can't be greater than 1\n\tdp[l][r] = max(dp[l][r], add + (l + 1 > r ? 0 : calc(l + 1, r)));\n\tfor (auto nr : rg[l]) {\n\t\tif (nr >= r) continue;\n\t\tdp[l][r] = max(dp[l][r], add + calc(l, nr) + (nr + 1 > r ? 0 : calc(nr + 1, r)));\n\t}\n\treturn dp[l][r];\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> l(n), r(n);\n\t\tvector<int> val;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> l[i] >> r[i];\n\t\t\tval.push_back(l[i]);\n\t\t\tval.push_back(r[i]);\n\t\t}\n\t\tsort(val.begin(), val.end());\n\t\tval.resize(unique(val.begin(), val.end()) - val.begin());\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tl[i] = lower_bound(val.begin(), val.end(), l[i]) - val.begin();\n\t\t\tr[i] = lower_bound(val.begin(), val.end(), r[i]) - val.begin();\n\t\t}\n\t\tint siz = val.size();\n\t\tdp = vector<vector<int>>(siz, vector<int>(siz, -1));\n\t\trg = vector<vector<int>>(siz);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\trg[l[i]].push_back(r[i]);\n\t\t}\n\t\tcout << calc(0, siz - 1) << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}