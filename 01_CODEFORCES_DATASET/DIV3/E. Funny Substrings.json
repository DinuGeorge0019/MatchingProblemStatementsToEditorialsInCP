{"link": "https://codeforces.com//contest/1538/problem/E", "problemId": "1011925", "shortId": "1538E", "contest_number": "1538", "name": "E. Funny Substrings", "statement": "Polycarp came up with a new programming language. There are only two types of statements in it:   \"\": assign the variable named  the value  (where  is a string). For example, the statement  assigns the variable named  the value . Note that  is the value of a string, not the name of a variable. Between the variable name, the  operator and the string contains exactly one space each. \"\": assign the variable named  the concatenation of values of two variables  and . For example, if the program consists of three statements , , , then the variable  will contain the string . It is guaranteed that the program is correct and the variables  and  were previously defined. There is exactly one space between the variable names and the  and  operators. All variable names and strings only consist of lowercase letters of the English alphabet and do not exceed  characters.The result of the program is the number of occurrences of string  in the string that was written to the variable in the last statement.Polycarp was very tired while inventing that language. He asks you to implement it. Your task is\u00a0\u2014 for given program statements calculate the number of occurrences of string  in the last assigned variable.", "input": "The first line contains an integer  (). Then  test cases follow. The first line of each test case contains a single integer  ()\u00a0\u2014 the number of statements in the program. All variable names and strings are guaranteed to consist only of lowercase letters of the English alphabet and do not exceed  characters. This is followed by  lines describing the statements in the format described above. It is guaranteed that the program is correct.", "output": "For each set of input data, output the number of occurrences of the  substring in the string that was written to the variable in the last statement.", "tutorial": "We can't model this process directly, since the maximum string length reaches  (look at the second example from the statements).To optimize this process, you can store each row as a set of the following values.   Number of occurrences of  in the string \u00a0\u2014 .  String length \u00a0\u2014 .  The first three characters of the string are \u00a0\u2014 .  The last three characters of the string are \u00a0\u2014 . Then, to process the second type of request and combine the two strings  and  into the string , you need:   .  . (New occurrences may be added at the junction of two words)   (However, if the string length is less than , then you need to handle this case carefully with your hands)   (Similarly, you need to process small strings separately). ", "solution": "#include <bits/stdc++.h>\n#include \"random\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing cd = complex<ld>;\n\nvector<string> split(const string& s, char p) {\n    vector<string> res(1);\n    for (char c : s) {\n        if (c == p) {\n            res.emplace_back();\n        } else {\n            res.back() += c;\n        }\n    }\n    return res;\n}\n\nstruct Word {\n    ll len;\n    ll cnt;\n    string s;\n};\n\nstring getFirst(string s) {\n    if (s.size() < 3) {\n        return s;\n    }\n    return s.substr(0, 3);\n}\n\nstring getLast(string s) {\n    if (s.size() < 3) {\n        return s;\n    }\n    return s.substr(s.size() - 3, 3);\n}\n\nint count(const string& s, const string& p) {\n    int cnt = 0;\n    for (int i = 0; i + p.size() <= s.size(); i++) {\n        if (s.substr(i, p.size()) == p) {\n            cnt++;\n        }\n    }\n    return cnt;\n}\n\nWord merge(const Word& a, const Word& b) {\n    Word c;\n    c.len = a.len + b.len;\n    c.s = a.s + b.s;\n    c.cnt = a.cnt + b.cnt + count(getLast(a.s) + getFirst(b.s), \"haha\");\n    if (c.s.size() >= 7) {\n        c.s = getFirst(c.s) + \"@\" + getLast(c.s);\n    }\n    return c;\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    map<string, Word> vars;\n    ll ans = 0;\n    for (int i = 0; i < n; i++) {\n        string var;\n        cin >> var;\n        string opr;\n        cin >> opr;\n        if (opr == \"=\") {\n            string a, plus, b;\n            cin >> a >> plus >> b;\n            vars[var] = merge(vars[a], vars[b]);\n        } else {\n            string str;\n            cin >> str;\n            Word word;\n            word.len = str.length();\n            word.cnt = count(str, \"haha\");\n            word.s = str;\n            vars[var] = word;\n        }\n        ans = vars[var].cnt;\n    }\n    cout << ans << \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}