{"link": "https://codeforces.com//contest/1176/problem/E", "problemId": "356087", "shortId": "1176E", "contest_number": "1176", "name": "E. Cover it ", "statement": "You are given an undirected unweighted connected graph consisting of  vertices and  edges. It is guaranteed that there are no self-loops or multiple edges in the given graph.Your task is to choose   vertices in this graph so  unchosen vertex is adjacent (in other words, connected by an edge) to at least one of chosen vertices.It is guaranteed that the answer exists. If there are multiple answers, you can print any.You will be given multiple independent queries to answer.", "input": "The first line contains a single integer  () \u2014 the number of queries. Then  queries follow. The first line of each query contains two integers  and  (, ) \u2014 the number of vertices and the number of edges, respectively. The following  lines denote edges: edge  is represented by a pair of integers ,  (, ), which are the indices of vertices connected by the edge. There are no self-loops or multiple edges in the given graph, i.\u2009e. for each pair () there are no other pairs () or () in the list of edges, and for each pair () the condition  is satisfied. It is guaranteed that the given graph is . It is guaranteed that  over all queries.", "output": "For each query print two lines. In the first line print  () \u2014 the number of chosen vertices. In the second line print   integers  in any order, where  is the index of the -th chosen vertex. It is guaranteed that the answer exists. If there are multiple answers, you can print any.", "tutorial": "Firstly, let's run bfs on the given graph and calculate distances for all vertices. In fact, we don't need distances, we need their parities. The second part is to find all vertices with an even distance, all vertices with and odd distance, and print the smallest by size part. Why is it always true? Firstly, it is obvious that at least one of these sizes will not exceed . And secondly, because we are checking just parities of distances, it is obvious that each vertex of some parity is connected with at least one vertex of the opposite parity (because it has this parity from some vertex of the opposite parity).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint n, m;\nvector<int> d;\nvector<vector<int>> g;\n\nvoid bfs(int s) {\n\td = vector<int>(n, INF);\n\td[s] = 0;\n\t\n\tqueue<int> q;\n\tq.push(s);\n\t\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop();\n\t\t\n\t\tfor (auto to : g[v]) {\n\t\t\tif (d[to] == INF) {\n\t\t\t\td[to] = d[v] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor (int tc = 0; tc < t; ++tc){\n\t\tcin >> n >> m;\n\t\tg = vector<vector<int>>(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\t--x, --y;\n\t\t\tg[x].push_back(y);\n\t\t\tg[y].push_back(x);\n\t\t}\n\t\n\t\tbfs(0);\n\t\tvector<int> even, odd;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (d[i] & 1) odd.push_back(i);\n\t\t\telse even.push_back(i);\n\t\t}\n\t\n\t\tif (even.size() < odd.size()) {\n\t\t\tcout << even.size() << endl;\n\t\t\tfor (auto v : even) cout << v + 1 << \" \";\n\t\t} else {\n\t\t\tcout << odd.size() << endl;\n\t\t\tfor (auto v : odd) cout << v + 1 << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}