{"link": "https://codeforces.com//contest/1249/problem/D1", "problemId": "447562", "shortId": "1249D1", "contest_number": "1249", "name": "D1. Too Many Segments  easy version ", "statement": ".You are given  segments on the coordinate axis . Segments can intersect, lie inside each other and even coincide. The -th segment is  () and it covers all integer points  such that .The integer point is called  if it is covered by  than  segments.Your task is to remove the minimum number of segments so that there are no  points at all.", "input": "The first line of the input contains two integers  and  () \u2014 the number of segments and the maximum number of segments by which each integer point can be covered. The next  lines contain segments. The -th line contains two integers  and  () \u2014 the endpoints of the -th segment.", "output": "In the first line print one integer  () \u2014 the minimum number of segments you need to remove so that there are no  points. In the second line print   integers  () \u2014 indices of segments you remove in any order. If there are multiple answers, you can print any of them.", "tutorial": "In this problem, the following greedy solution works: let's find the leftmost point covered by more than  segments. We should fix it somehow. How to do it? Let's find some segment that was not removed already, it covers this point and its rightmost end is maximum possible, and remove this segment.You can implement it in any time you want, even in  naively.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 250;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<pair<int, int>> segs(n);\n\tvector<int> cnt(N);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> segs[i].first >> segs[i].second;\n\t\t++cnt[segs[i].first];\n\t\t--cnt[segs[i].second + 1];\n\t}\n\t\n\tfor (int i = 0; i + 1 < N; ++i) {\n\t\tcnt[i + 1] += cnt[i];\n\t}\n\t\n\tvector<int> ans(n);\n\tfor (int i = 0; i < N; ++i) {\n\t\twhile (cnt[i] > k) {\n\t\t\tint pos = -1;\n\t\t\tfor (int p = 0; p < n; ++p) {\n\t\t\t\tif (!ans[p] && (segs[p].first <= i && i <= segs[p].second) && (pos == -1 || segs[p].second > segs[pos].second)) {\n\t\t\t\t\tpos = p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(pos != -1);\n\t\t\tfor (int j = segs[pos].first; j <= segs[pos].second; ++j) {\n\t\t\t\t--cnt[j];\n\t\t\t}\n\t\t\tans[pos] = 1;\n\t\t}\n\t}\n\t\n\tcout << accumulate(ans.begin(), ans.end(), 0) << endl;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (ans[i]) cout << i + 1 << \" \";\n\t}\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}