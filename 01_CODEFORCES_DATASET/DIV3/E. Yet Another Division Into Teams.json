{"link": "https://codeforces.com//contest/1256/problem/E", "problemId": "459828", "shortId": "1256E", "contest_number": "1256", "name": "E. Yet Another Division Into Teams", "statement": "There are  students at your university. The programming skill of the -th student is . As a coach, you want to divide them into teams to prepare them for the upcoming ICPC finals. Just imagine how good this university is if it has  students ready for the finals!Each team should consist of . Each student should belong to . The  of a team is the difference between the  programming skill of some student that belongs to this team and the  programming skill of some student that belongs to this team (in other words, if the team consists of  students with programming skills , then the  of this team is ).The total  is the sum of  of all teams formed.Your task is to minimize the total  of the division of students and find the optimal way to divide the students.", "input": "The first line of the input contains one integer  () \u2014 the number of students. The second line of the input contains  integers  (), where  is the programming skill of the -th student.", "output": "In the first line print two integers  and  \u2014 the minimum total  of the division of students and the number of teams in your division, correspondingly. In the second line print  integers  (), where  is the number of team to which the -th student belong. If there are multiple answers, you can print any. Note that you don't need to minimize the number of teams. Each team should consist of .", "tutorial": "Let's sort all students by their programming skills but save the initial indices to restore the answer.Now we can understand that we don't need to compose the team of size greater than  because in this case we can split it into more teams with fewer participants and obtain the same or even less answer.Now we can do the standard dynamic programming  \u2014 the minimum total diversity of the division if we divided the first  students (in sorted order). Initially, , all other values of  are . Because of the fact above, we can do only three transitions (-indexed):  ;  ;  . The answer is  and we can restore it by standard carrying parent values (as a parent of the state we can use, for example, the number of participants in the team).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\n#define x first\n#define y second\n#define mp make_pair\n\nconst int N = 200043;\nconst int INF = int(1e9) + 43;\n\nint n;\nint dp[N];\nint p[N];\npt a[N];\nint t[N];\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++)\n    {\n    \ta[i].y = i;\n    \tscanf(\"%d\", &a[i].x);\n    }\n    sort(a, a + n);\n    for(int i = 1; i <= n; i++)\n    {\n    \tdp[i] = INF;\n    \tp[i] = -1;\n    }\n    for(int i = 0; i < n; i++)\n    \tfor(int j = 3; j <= 5 && i + j <= n; j++)\n    \t{\n    \t\tint diff = a[i + j - 1].x - a[i].x;\n    \t\tif(dp[i + j] > dp[i] + diff)\n    \t\t{\n    \t\t\tp[i + j] = i;\n    \t\t\tdp[i + j] = dp[i] + diff;\n    \t\t}\n    \t}\n    int cur = n;\n    int cnt = 0;\n    while(cur != 0)\n    {\n    \tfor(int i = cur - 1; i >= p[cur]; i--)\n    \t\tt[a[i].y] = cnt;\n    \tcnt++;\n    \tcur = p[cur]; \n    }\n    printf(\"%d %d\\n\", dp[n], cnt);\n    for(int i = 0; i < n; i++)\n    {\n    \tif(i) printf(\" \");\n    \tprintf(\"%d\", t[i] + 1); \n    }\n    puts(\"\");\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}