{"link": "https://codeforces.com//contest/1102/problem/E", "problemId": "280231", "shortId": "1102E", "contest_number": "1102", "name": "E. Monotonic Renumeration", "statement": "You are given an array  consisting of  integers. Let's denote  of array  as an array  consisting of  integers such that all of the following conditions are met:  ;  for every pair of indices  and  such that , if , then  (note that if , it is still possible that );  for every index  either  or . For example, if , then two possible monotonic renumerations of  are  and .Your task is to calculate the number of different monotonic renumerations of . The answer may be large, so print it modulo .", "input": "The first line contains one integer  () \u2014 the number of elements in . The second line contains  integers  ().", "output": "Print one integer \u2014 the number of different monotonic renumerations of , taken modulo .", "tutorial": "We are interested in such subsegments of the array  that for every value belonging to this segment all occurences of this value in the array are inside this segment. Let's call such segments . For example, if , then ,  and  are closed segments.We can see that the result is some partition of the given array into several closed segments \u2014 if for some value  all occurences of  in  do not form a segment in , then there exists some pair  such that  (which contradicts the statement); and if the formed segment is not a closed segment, then for some indices  and  such that  it is not true that  (which also contradicts the statement).Okay, let's try to partition the array into closed segments greedily: take the first prefix of the array that is a closed segment, erase it, take the next prefix, and so on. Let  be the number of closed segments we got with this procedure.The key fact is that . To prove it, suppose we partitioned the array in some other way. The intersection of two closed segments, if it exists, is also a closed segment; so there exists at least one segment in the partition we picked greedily that can be broken into two \u2014 but that contradicts the algorithm we used to construct this partition.So we may merge some of  segments to get a valid partition. There are exactly  ways to do so, because for every pair of adjacent segments we may choose whether we will merge it.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main()\n{\n \tint n;\n \tscanf(\"%d\", &n);\n \tvector<int> a(n);\n \tfor(int i = 0; i < n; i++)\n \t\tscanf(\"%d\", &a[i]);\n \tmap<int, int> lst;\n \tvector<int> last_pos(n);\n \tfor(int i = n - 1; i >= 0; i--)\n \t{\n \t\tif(!lst.count(a[i]))\n \t\t\tlst[a[i]] = i;\n \t\tlast_pos[i] = lst[a[i]];\n \t}\n \tint ans = 1;\n \tint cur_max = -1;\n \tfor(int i = 0; i < n - 1; i++)\n \t{\n \t\tcur_max = max(cur_max, last_pos[i]);\n \t\tif(cur_max == i)\n \t\t\tans = (2 * ans) % MOD;\n \t}\t\n \tprintf(\"%d\\n\", ans);\n \treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}