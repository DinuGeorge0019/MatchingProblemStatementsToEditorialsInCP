{"link": "https://codeforces.com//contest/1674/problem/G", "problemId": "1387203", "shortId": "1674G", "contest_number": "1674", "name": "G. Remove Directed Edges", "statement": "You are given a directed acyclic graph, consisting of  vertices and  edges. The vertices are numbered from  to . There are no multiple edges and self-loops.Let  be the number of incoming edges (indegree) and  be the number of outgoing edges (outdegree) of vertex .You are asked to remove some edges from the graph. Let the new degrees be  and .You are only allowed to remove the edges if the following conditions hold for every vertex :    or ;   or . Let's call a set of vertices   if for each pair of vertices  and  () such that  and , there exists a path either from  to  or from  to  over the non-removed edges.What is the maximum possible size of a  set  after you remove some edges from the graph and both indegrees and outdegrees of all vertices either decrease or remain equal to ?", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the number of vertices and the number of edges of the graph. Each of the next  lines contains two integers  and  (; )\u00a0\u2014 the description of an edge. The given edges form a valid directed acyclic graph. There are no multiple edges.", "output": "Print a single integer\u00a0\u2014 the maximum possible size of a  set  after you remove some edges from the graph and both indegrees and outdegrees of all vertices either decrease or remain equal to .", "tutorial": "Let's solve the problem in reverse.Imagine we have already removed some edges, so that the conditions hold. When is some set of vertices considered ? Since the graph is acyclic, we can topologically sort the vertices in the set. The vertices are reachable from each other, so there exists a path from the -th vertex in the set to the -st vertex. Thus, there exists a path that goes through all chosen vertices.However, we can make this conclusion even stronger. In the optimal answer, not just the path goes from the -th vertex to the -st one, but a single edge. That can be shown by contradiction. Let there be some vertices  and  that are adjacent in the chosen  set. There exists a path between them, but not a single edge. We want to show that this set is not optimal and can be made larger.The vertices on that path don't belong to the set. If they did, they would be between  and  in the set (because of the topological order). We can add them to the set. Every vertex that can reach , can reach them too, and every vertex that can be reached from , can be reached from them. Thus, it will still be a  set. Now every vertex from  to  has an edge between them and the size of the set is larger.Thus, we showed that the maximum set in the answer is always some path in the graph.So the task is to choose some path, then remove some edges so that this path still exists and the conditions hold. Note that if the conditions hold for some set of remaining edges, then we can remove any edge from it, and the conditions will still be met. Thus, we can only leave this path.Let's look closer into the conditions. What they actually tell is the following. If a vertex has incoming edges, then remove at least one of them. The same for the outgoing edges.Since we are looking for a path, it's enough to leave one outgoing edge for all vertices except the last one and leave one incoming edge for all vertices except the first one.In order to achieve that, every vertex except the last one should have at least two outgoing edges and every vertex except the first one should have at least two incoming edges.We can see that this condition is not only necessary, but sufficient as well. Just remove the outgoing edges which don't go to the next vertex and the incoming edges which don't go from the previous vertex.Now we can wrap this up into the dynamic programming. Initialize the answer with , since you can always remove all edges, and get a set with one vertex.Then let  be the longest path such that it starts in vertex , all vertices in it have at least two incoming edges and all vertices except maybe the final one have at least two outgoing edges.Initialize the  for the vertices that can be the final in the path (have at least two incoming edges) with . Then update  for all  that can be internal vertices (have at least two outgoing and two incoming edges) with  for all outgoing edges .Finally, update the answer from the vertices that can be the first one in the path. For each vertex  that has at least two outgoing edges, take the value of  for all outgoing edges .Overall complexity: .", "solution": "#include <bits/stdc++.h>\n \n#define forn(i, n) for (int i = 0; i < int(n); i++)\n \nusing namespace std;\n \nconst int INF = 1e9;\n \nvector<int> in, out;\nvector<vector<int>> g;\nvector<int> dp;\n \nint calc(int v){\n    if (dp[v] != -1) return dp[v];\n    if (in[v] >= 2 && out[v] >= 2){\n        dp[v] = 1;\n        for (int u : g[v])\n            dp[v] = max(dp[v], calc(u) + 1);\n    }\n    else if (in[v] >= 2){\n        dp[v] = 1;\n    }\n    else{\n        dp[v] = -INF;\n    }\n    return dp[v];\n}\n \nint main() {\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    g.resize(n);\n    in.resize(n);\n    out.resize(n);\n    forn(i, m){\n        int v, u;\n        scanf(\"%d%d\", &v, &u);\n        --v, --u;\n        g[v].push_back(u);\n        ++in[u];\n        ++out[v];\n    }\n    int ans = 1;\n    dp.resize(n, -1);\n    forn(v, n) if (out[v] >= 2){\n        for (int u : g[v]){\n            ans = max(ans, calc(u) + 1);\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}