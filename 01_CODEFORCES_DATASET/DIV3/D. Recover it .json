{"link": "https://codeforces.com//contest/1176/problem/D", "problemId": "356086", "shortId": "1176D", "contest_number": "1176", "name": "D. Recover it ", "statement": "Authors guessed an array  consisting of  integers; each integer is not less than  and not greater than . You don't know the array , but you know the array  which is formed from it with the following sequence of operations:  Firstly, let the array  be equal to the array ;  Secondly, for each  from  to :   if  is a  number, then one integer  is appended to array , where  is an infinite sequence of prime numbers ();  otherwise (if  is not a  number), the greatest divisor of  which is not equal to  is appended to ;   Then the obtained array of length  is shuffled and given to you in the input. Here  means the -th prime number. The first prime , the second one is , and so on.Your task is to recover  suitable array  that forms the given array . It is guaranteed that the answer exists (so the array  is obtained from some suitable array ). If there are multiple answers, you can print any.", "input": "The first line of the input contains one integer  () \u2014 the number of elements in . The second line of the input contains  integers  (), where  is the -th element of .  is the -th prime number.", "output": "In the only line of the output print  integers  () in  order \u2014 the array  from which the array  can be obtained using the sequence of moves given in the problem statement. If there are multiple answers, you can print any.", "tutorial": "Firstly, let's generate first  primes. It can be done in  almost naively (just check all elements in range ). It also can be done with Eratosthenes sieve in  or . We also can calculate for each number in this range the maximum its divisor non-equal to it (if this number is not a prime). And in other case we can calculate the index of this prime. Using all this information we can restore the array .Let's maintain a multiset (a set in which multiple copies of the same element are allowed) of all elements in . While it is not empty, let's take the maximum element from this set . If it is prime (we can check it using the information calculated earlier) then it is some . Let's find the index of this prime () using calculated information, remove this element and , push  in  and continue. Otherwise this element is not a prime and then it is some . Let's remove it and its maximum divisor non-equal to it from the multiset, push  in  and continue.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 3 * 1000 * 1000 + 13;\n\nint lst[N];\nint num[N];\n\nvoid sieve(){\n\tforn(i, N) lst[i] = i;\n\tfor (int i = 2; i < N; ++i){\n\t\tif (lst[i] != i){\n\t\t\tlst[i] = i / lst[i];\n\t\t\tcontinue;\n\t\t}\n\t\tfor (long long j = i * 1ll * i; j < N; j += i)\n\t\t\tlst[j] = min(lst[j], i);\n\t}\n\tint cur = 0;\n\tfor (int i = 2; i < N; ++i) if (lst[i] == i)\n\t\tnum[i] = ++cur;\n}\n\nint cnt[N];\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tforn(i, 2 * n){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\t++cnt[x];\n\t}\n\t\n\tsieve();\n\t\n\tvector<int> res;\n\tfor (int i = N - 1; i >= 0; --i){\n\t\twhile (cnt[i] > 0){\n\t\t\tif (lst[i] == i){\n\t\t\t\t--cnt[num[i]];\n\t\t\t\tres.push_back(num[i]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\t--cnt[lst[i]];\n\t\t\t\tres.push_back(i);\n\t\t\t}\n\t\t\t--cnt[i];\n\t\t}\n\t}\n\t\n\tfor (auto it : res)\n\t\tprintf(\"%d \", it);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}