{"link": "https://codeforces.com//contest/1490/problem/D", "problemId": "898526", "shortId": "1490D", "contest_number": "1490", "name": "D. Permutation Transformation", "statement": "A permutation\u00a0\u2014 is a sequence of length  integers from  to , in which all the numbers occur exactly once. For example, , , \u00a0\u2014 permutations, and , , \u00a0\u2014 no.Polycarp was recently gifted a permutation  of length . Polycarp likes trees more than permutations, so he wants to transform permutation  into a rooted binary tree. He transforms an array of different integers into a tree as follows:   the maximum element of the array becomes the root of the tree;  all elements to the left of the maximum \u2014 form a left subtree (which is built according to the same rules but applied to the left part of the array), but if there are no elements to the left of the maximum, then the root has no left child;  all elements to the right of the maximum \u2014 form a right subtree (which is built according to the same rules but applied to the right side of the array), but if there are no elements to the right of the maximum, then the root has no right child. For example, if he builds a tree by permutation , then the root will be the element , and the left subtree will be the tree that will be built for the subarray , and the right one \u2014 for the subarray . As a result, the following tree will be built:      Another example: let the permutation be . In this case, the tree looks like this:      Let us denote by  the depth of the vertex , that is, the number of edges on the path from the root to the vertex numbered . Note that the root depth is zero. Given the permutation , for each vertex, find the value of .", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. Then  test cases follow. The first line of each test case contains an integer  ()\u00a0\u2014 the length of the permutation. This is followed by  numbers \u00a0\u2014 permutation .", "output": "For each test case, output  values\u00a0\u2014 .", "tutorial": "We will construct the required tree recursively. Let us describe the state of tree construction by three values , where \u00a0\u2014 is the segment of the permutation, and \u00a0\u2014 is the current depth. Then the following transitions can be described:   find the position  of the maximum element on the segment , that is, ;  the depth of the vertex  is equal to ;  if , then make the transition to the state ;  if , then make the transition to the state ; Then, in order to construct the required tree, it is necessary to take  as the initial state.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid build(int l, int r, vector<int> const &a, vector<int> &d, int curD = 0) {\n  if (r < l) {\n    return;\n  }\n  if (l == r) {\n    d[l] = curD;\n    return;\n  }\n  int m = l;\n  for (int i = l + 1; i <= r; i++) {\n    if (a[m] < a[i]) {\n      m = i;\n    }\n  }\n  d[m] = curD;\n  build(l, m - 1, a, d, curD + 1);\n  build(m + 1, r, a, d, curD + 1);\n}\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int &x : a) {\n    cin >> x;\n  }\n  vector<int> d(n);\n  build(0, n - 1, a, d);\n  for (int x :d) {\n    cout << x << \" \";\n  }\n  cout << endl;\n}\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}