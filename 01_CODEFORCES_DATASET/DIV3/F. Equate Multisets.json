{"link": "https://codeforces.com//contest/1702/problem/F", "problemId": "1456431", "shortId": "1702F", "contest_number": "1702", "name": "F. Equate Multisets", "statement": "\u00a0\u2014is a set of numbers in which there can be equal elements, and the order of the numbers does not matter. Two multisets are equal when each value occurs the same number of times. For example, the multisets  and  are equal, but the multisets  and \u00a0\u2014 are not.You are given two multisets  and , each consisting of  integers.In a single operation, any element of the  multiset can be doubled or halved (rounded down). In other words, you have one of the following operations available for an element  of the  multiset:   replace  with ,  or replace  with  (round down).  Note that you cannot change the elements of the  multiset.See if you can make the multiset  become equal to the multiset  in an arbitrary number of operations (maybe ).For example, if , , , then the answer is yes. We can proceed as follows:   Replace  with . We get .  Replace  with . We get .  Replace  with . We get .  Replace  with . We get .  Got equal multisets  and . ", "input": "The first line of input data contains a single integer  ()\u00a0\u2014the number of test cases. Each test case consists of three lines. The first line of the test case contains an integer  ()\u00a0\u2014the number of elements in the multisets  and . The second line gives  integers:  ()\u00a0\u2014the elements of the multiset . Note that the elements may be equal. The third line contains  integers:  ()\u00a0\u2014 elements of the multiset . Note that the elements may be equal. It is guaranteed that the sum of  values over all test cases does not exceed .", "output": "For each test case, print on a separate line:    if you can make the multiset  become equal to ,   otherwise.  You can output  and  in any case (for example, strings , ,  and  will be recognized as positive answer).", "tutorial": "We divide each number from the multiset  by  as long as it is divisible without a remainder. Because if we can get a new number from the multiset , we can also increase it to the original number by multiplication by . Now notice that it does not make sense to use the first operation (multiplication by ), because we get an even number, and only odd numbers remain in the multiset . Then we take the largest number from  and if it is in , we remove this number from both multisets. Otherwise, we use the second operation, if the number is greater than . If it is equal to , then it is impossible to equalize the multisets  and .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define sz(v) (int)v.size()\n#define all(v) v.begin(),v.end()\n#define eb emplace_back\n\nconst int INF = 1e9;\n\nvoid solve() {\n    int n; cin >> n;\n    multiset<int> a, b;\n\n    forn(i, n) {\n        int x; cin >> x;\n        while (x % 2 == 0) {\n            x /= 2;\n        }\n        a.insert(x);\n    }\n\n    forn(i, n) {\n        int x; cin >> x;\n        b.insert(x);\n    }\n    n = sz(a);\n\n    while (!b.empty()) {\n        int x = *b.rbegin();\n        // cout << x << endl;\n        if (!a.count(x)) {\n            if (x == 1) break;\n            b.erase(b.find(x));\n            b.insert(x / 2);\n        } else {\n            b.erase(b.find(x));\n            a.erase(a.find(x));\n        }\n    }\n\n    cout << (b.empty() ? \"YES\" : \"NO\") << endl;\n\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    forn(tt, t) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}