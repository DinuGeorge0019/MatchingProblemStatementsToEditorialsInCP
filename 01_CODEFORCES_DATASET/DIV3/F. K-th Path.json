{"link": "https://codeforces.com//contest/1196/problem/F", "problemId": "377796", "shortId": "1196F", "contest_number": "1196", "name": "F. K-th Path", "statement": "You are given a connected undirected weighted graph consisting of  vertices and  edges.You need to print the -th smallest shortest path in this graph (paths from the vertex to itself are not counted, paths from  to  and from  to  are counted as one).More formally, if  is the matrix of shortest paths, where  is the length of the shortest path between vertices  and  (), then you need to print the -th element in the sorted array consisting of all , where .", "input": "The first line of the input contains three integers  and  (, , \u00a0\u2014 the number of vertices in the graph, the number of edges in the graph and the value of , correspondingly. Then  lines follow, each containing three integers ,  and  (, , ) denoting an edge between vertices  and  of weight . It is guaranteed that the given graph is  (there is a path between any pair of vertices), there are no self-loops (edges connecting the vertex with itself) and multiple edges (for each pair of vertices  and , there is at most one edge between this pair of vertices in the graph).", "output": "Print one integer\u00a0\u2014 the length of the -th smallest shortest path in the given graph (paths from the vertex to itself are not counted, paths from  to  and from  to  are counted as one).", "tutorial": "The main observation is that you don't need more than  smallest by weight edges (among all edges with the maximum weights you can choose any). Maybe there will be a proof later, but now I ask other participant to write it.So you sort the initial edges and after that you can construct a graph consisting of no more than  vertices and no more than  edges. You just can build the new graph consisting only on these vertices and edges and run Floyd-Warshall algorithm to find the matrix of shortest paths. Then sort all shorted distances and print the -th element of this sorted array.Time complexity: .I know that there are other approaches that can solve this problem with greater , but to make this problem easily this solution is enough.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tvector<pair<int, pair<int, int>>> e;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y, w;\n\t\tscanf(\"%d %d %d\", &x, &y, &w);\n\t\t--x, --y;\n\t\te.push_back(make_pair(w, make_pair(x, y)));\n\t}\n\tsort(e.begin(), e.end());\n\t\n\tvector<int> vert;\n\tfor (int i = 0; i < min(m, k); ++i) {\n\t\tvert.push_back(e[i].second.first);\n\t\tvert.push_back(e[i].second.second);\n\t}\n\tsort(vert.begin(), vert.end());\n\tvert.resize(unique(vert.begin(), vert.end()) - vert.begin());\n\tint cntv = vert.size();\n\tvector<vector<long long>> dist(cntv, vector<long long>(cntv, INF64));\n\tfor (int i = 0; i < cntv; ++i) dist[i][i] = 0;\n\t\n\tfor (int i = 0; i < min(m, k); ++i) {\n\t\tint x = lower_bound(vert.begin(), vert.end(), e[i].second.first) - vert.begin();\n\t\tint y = lower_bound(vert.begin(), vert.end(), e[i].second.second) - vert.begin();\n\t\tdist[x][y] = dist[y][x] = min(dist[x][y], (long long)e[i].first);\n\t}\n\t\n\tfor (int z = 0; z < cntv; ++z) {\n\t\tfor (int x = 0; x < cntv; ++x) {\n\t\t\tfor (int y = 0; y < cntv; ++y) {\n\t\t\t\tdist[x][y] = min(dist[x][y], dist[x][z] + dist[z][y]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<long long> res;\n\tfor (int i = 0; i < cntv; ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tres.push_back(dist[i][j]);\n\t\t}\n\t}\n\t\n\tsort(res.begin(), res.end());\n\tcout << res[k - 1] << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}