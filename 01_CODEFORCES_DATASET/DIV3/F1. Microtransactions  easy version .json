{"link": "https://codeforces.com//contest/1165/problem/F1", "problemId": "344229", "shortId": "1165F1", "contest_number": "1165", "name": "F1. Microtransactions  easy version ", "statement": ".Ivan plays a computer game that contains some microtransactions to make characters look cooler. Since Ivan wants his character to be really cool, he wants to use some of these microtransactions \u2014 and he won't start playing until he gets all of them.Each day (during the ) Ivan earns exactly one burle.There are  types of microtransactions in the game. Each microtransaction costs  burles usually and  burle if it is on sale. Ivan has to order exactly  microtransactions of the -th type (he orders microtransactions during the ).Ivan can order  (possibly zero) number of microtransactions of  types during any day (of course, ). If the microtransaction he wants to order is on sale then he can buy it for  burle and otherwise he can buy it for  burles.There are also  special offers in the game shop. The -th offer  means that microtransactions of the -th type are on sale during the -th day.Ivan wants to order all microtransactions as soon as possible. Your task is to calculate the minimum day when he can buy all microtransactions he want and actually start playing.", "input": "The first line of the input contains two integers  and  () \u2014 the number of types of microtransactions and the number of special offers in the game shop. The second line of the input contains  integers  (), where  is the number of copies of microtransaction of the -th type Ivan has to order. It is guaranteed that . The next  lines contain special offers. The -th of these lines contains the -th special offer. It is given as a pair of integers  () and means that microtransactions of the -th type are on sale during the -th day.", "output": "Print one integer \u2014 the minimum day when Ivan can order all microtransactions he wants and actually start playing.", "tutorial": "Let's iterate over all possible answers. Obviously, this value is always in the range . The first day when Ivan can order all microtransactions he wants will be the answer. How to check if the current day  is enough to order everything Ivan wants?If we had several sale days for some type of microtransaction (of course, we can use only such days that are not greater than the fixed last day ), let's use the last one, it is always not worse than some of the previous days. Then let's iterate over all days from  to  and do the following: firstly, let's increase our balance by one burle. Then let's try to order all microtransactions for which the current day is the last sale day (and pay one burle per copy). If we are out of money at some moment then just say that we should order all microtransactions that remain in this sale day during the last day for two burles per copy. It is true because it does not matter which types will remain because this day is the last sale day for all of these types. So, after all, we had some remaining microtransactions that we cannot buy during sales, and the current balance. And the current day is good if the number of such microtransactions multiplied by two is not greater than the remaining balance.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nvector<int> k;\nvector<pair<int, int>> q(1001);\n\nbool can(int day) {\n\tvector<int> lst(n, -1);\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (q[i].first <= day) {\n\t\t\tlst[q[i].second] = max(lst[q[i].second], q[i].first);\n\t\t}\n\t}\n\tvector<vector<int>> off(1001);\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (lst[i] != -1) {\n\t\t\toff[lst[i]].push_back(i);\n\t\t}\n\t}\n\tvector<int> need = k;\n\tint cur_money = 0;\n\tfor (int i = 0; i <= day; ++i) {\n\t\t++cur_money;\n\t\tif (i > 1000) continue;\n\t\tfor (auto it : off[i]) {\n\t\t\tif (cur_money >= need[it]) {\n\t\t\t\tcur_money -= need[it];\n\t\t\t\tneed[it] = 0;\n\t\t\t} else {\n\t\t\t\tneed[it] -= cur_money;\n\t\t\t\tcur_money = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn accumulate(need.begin(), need.end(), 0) * 2 <= cur_money;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m;\n\tk = vector<int>(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> k[i];\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> q[i].first >> q[i].second;\n\t\t--q[i].first;\n\t\t--q[i].second;\n\t}\n\t\n\tfor (int l = 0; l <= 2000; ++l) {\n\t\tif (can(l)) {\n\t\t\tcout << l + 1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tassert(false);\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}