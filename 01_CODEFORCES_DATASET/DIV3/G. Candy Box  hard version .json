{"link": "https://codeforces.com//contest/1183/problem/G", "problemId": "363547", "shortId": "1183G", "contest_number": "1183", "name": "G. Candy Box  hard version ", "statement": "There are  candies in a candy box. The type of the -th candy is  (). You have to prepare a gift using some of these candies with the following restriction: the numbers of candies of each type presented in a gift should be all distinct (i.\u2009e. for example, a gift having two candies of type  and two candies of type  is bad).. It is also possible that  of some types will be taken to a gift.You really like some of the candies and don't want to include them into the gift, but you want to eat them yourself instead. For each candy, a number  is given, which is equal to  if you really want to keep -th candy for yourself, or  if you don't mind including it into your gift. It is possible that two candies of the same type have different values of .You want your gift to be as large as possible, but you don't want to include too many of the candies you want to eat into the gift. So, you want to calculate the maximum possible number of candies that can be included into a gift, and among all ways to choose maximum number of candies, you want to maximize the number of candies having  in your gift.You have to answer  independent queries.", "input": "The first line of the input contains one integer  () \u2014 the number of queries. The first line of each query contains one integer  () \u2014 the number of candies. Then  lines follow, each containing two integers  and  (, ), where  is the type of the -th candy, and  denotes whether you want to keep the -th candy for yourself ( if you want to keep it,  if you don't mind giving it away). It is guaranteed that the sum of  over all queries does not exceed .", "output": "For each query print two integers:   the maximum number of candies in a gift you can compose, according to the constraints in the statement;  the maximum number of candies having  in a gift you can compose that contains the maximum possible number of candies.   ", "tutorial": "First of all, to maximize the number of candies in the gift, we can use the following greedy algorithm: let's iterate on the number of candies of some type we take from  to  backwards. For fixed , let's try to find any suitable type of candies. A type is suitable if there are at least  candies of this type in the box. If there exists at least one such type that wasn't used previously, let's pick any such type and take exactly  candies of this type (and decrease ). It does not matter which type we pick if we only want to maximize the number of candies we take.Okay, let's now modify this solution to maximize the number of candies having . We initially could pick any type that has at least  candies, but now we should choose a type depending on the number of candies with  in this type. For example, if we have two types having  and  candies with  respectively, and we want to pick  candies from one type and  candies from another type, and  and , it's better to pick  candies of the first type and  candies of the second type. In this case we have  candies with , in the other case it's . And if  and , then . So, when we want to pick a type of candies such that we will take exactly  candies of this type, it's optimal to choose a type that wasn't used yet, contains at least  candies, and has maximum possible number of candies with . This best type can be maintained with a multiset or a set of pairs.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> cnt(n);\n\tvector<int> cnt_good(n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint a, f;\n\t\tscanf(\"%d %d\", &a, &f);\n\t\t--a;\n\t\tcnt[a]++;\n\t\tif(f) cnt_good[a]++;\n\t}\n\tvector<vector<int> > types(n + 1);\n\tfor(int i = 0; i < n; i++)\n\t\ttypes[cnt[i]].push_back(cnt_good[i]);\n\tint ans1 = 0;\n\tint ans2 = 0;\n\tmultiset<int> cur;\n\tfor(int i = n; i > 0; i--)\n\t{\n\t\tfor(auto x : types[i]) cur.insert(x);\n\t\tif(!cur.empty())\n\t\t{\n\t\t\tint z = *cur.rbegin();\n\t\t\tans1 += i;\n\t\t\tans2 += min(i, z);\n\t\t\tcur.erase(cur.find(z));\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", ans1, ans2);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor(int i = 0; i < t; i++)\n\t\tsolve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}