{"link": "https://codeforces.com//contest/1102/problem/D", "problemId": "280230", "shortId": "1102D", "contest_number": "1102", "name": "D. Balanced Ternary String", "statement": "You are given a string  consisting of exactly  characters, and each character is either '', '' or ''. Such strings are called .Your task is to  in this string with other characters to obtain a  ternary string ( ternary string is a ternary string such that the number of characters '' in this string is equal to the number of characters '', and the number of characters '' (and '' obviously) is equal to the number of characters '').Among all possible  ternary strings you have to obtain the lexicographically (alphabetically) smallest.Note that you can neither remove characters from the string nor add characters to the string. Also note that you can replace the given characters only with characters '', '' and ''.It is  that the answer exists.", "input": "The first line of the input contains one integer  (,  is ) \u2014 the number of characters in . The second line contains the string  consisting of exactly  characters '', '' and ''.", "output": "Print one string \u2014 the lexicographically (alphabetically) smallest  ternary string which can be obtained from the given one with  number of replacements. Because  is  it is obvious that the answer exists. And it is obvious that there is only one possible answer.", "tutorial": "Let's count how many characters '', '' and '' we have in the string  and store it in the array . Also let's count our \"goal\" array . Firstly, the array  is .The main idea of this problem is a pretty standard lexicographically greedy approach. We go from left to right and try to place the minimum possible character at the current position in such a way that placing this character is not breaking conditions of our problem. How can we apply this approach to this problem?Firstly, let's define a function . What does the value of this function mean? It means the number of replacements we need to reach  from . Let  at the beginning of the program. This value means the minimum number of replacements to obtain some balanced ternary string. Let's maintain the variable  which initially is  and means the number of replacements we already made.So, we iterate over all positions  from  to . Firstly, let's decrease . So the array  maintains the current amount of characters on suffix of the string. Now let's iterate over characters  from  to  and try to place every character. If the current character is needed (), then let's decrease  and if the number of replacements will still be minimum possible after such replacement () then let's place this character, set  and go to the next position. This will form lexicographically minimum possible answer with minimum number of replacements.There is another (simpler) solution from PikMike, you can call him to explain it, I just will add his code to the editorial.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\n\nint needRep(const vector<int> &cnt, const vector<int> &need) {\n\tint res = 0;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tres += abs(cnt[i] - need[i]);\n\t}\n\tassert(res % 2 == 0);\n\treturn res / 2;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tstring s;\n\tcin >> n >> s;\n\t\n\tvector<int> cnt(3), cur(3, n / 3);\n\tfor (auto c : s) {\n\t\t++cnt[c - '0'];\n\t}\n\t\n\tint need = needRep(cnt, cur);\n\t\t\n\tint curRep = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\t--cnt[s[i] - '0'];\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (cur[j] == 0) continue;\n\t\t\tint rep = j != s[i] - '0';\n\t\t\t--cur[j];\n\t\t\tif (curRep + rep + needRep(cnt, cur) == need) {\n\t\t\t\ts[i] = j + '0';\n\t\t\t\tcurRep += rep;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++cur[j];\n\t\t}\n\t}\n\t\n\tcout << s << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}