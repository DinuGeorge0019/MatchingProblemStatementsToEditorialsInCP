{"link": "https://codeforces.com//contest/1353/problem/E", "problemId": "620791", "shortId": "1353E", "contest_number": "1353", "name": "E. K-periodic Garland", "statement": "You are given a garland consisting of  lamps. States of the lamps are represented by the string  of length . The -th character of the string  equals '' if the -th lamp is turned off or '' if the -th lamp is turned on. You are also given a positive integer .In one move, you can choose  and change its state (i.e. turn it on if it is turned off and vice versa).The garland is called -periodic if the distance between  is  . Consider the case . Then garlands \"\", \"\", \"\" and \"\" are good but garlands \"\", \"\" and \"\" are not. Note that , i.e. the first turned on lamp is not going after the last turned on lamp and vice versa.Your task is to find the  number of moves you need to make to obtain -periodic garland from the given one.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains two integers  and  () \u2014 the length of  and the required period. The second line of the test case contains the string  consisting of  characters '' and ''. It is guaranteed that the sum of  over all test cases does not exceed  ().", "output": "For each test case, print the answer \u2014 the  number of moves you need to make to obtain -periodic garland from the given one.", "tutorial": "Let  be the string containing all characters of  that have indices  and so on (i.e. all such positions that have the remainder  modulo ). Suppose we choose that all turned on lamps will have remainder  modulo . Then we need to remove all ones at the positions that do not belong to this remainder. Also considering the string , we need to spend the  number of moves to make this string of kind \"contiguous block of zeros, contiguous block of ones and again contiguous block of zeros\", because considering the characters modulo  will lead us to exactly this pattern (notice that some blocks can be empty).How to calculate the answer for the string  in linear time? Let  be the number of moves we need to fix the prefix of  till the -th character in a way that the -th character of  is ''. Let  be the number of ones in  on the segment . Notice that we can calculate all required values  in linear time using prefix sums. Then we can calculate  as , where  is the boolean value of the expression  ( if  is true and  otherwise). Let  be the length of . Then the actual answer for the string  can be calculated as  (thus we consider the case when the obtained string doesn't contan ones at all and consider each position as the last position of some one).So the actual answer can be calculated as .Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tauto solve = [](const string &s) {\n\t\tint n = s.size();\n\t\tint all = count(s.begin(), s.end(), '1');\n\t\tint ans = all;\n\t\tvector<int> res(n);\n\t\tint pref = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint cur = (s[i] == '1');\n\t\t\tpref += cur;\n\t\t\tres[i] = 1 - cur;\n\t\t\tif (i > 0) res[i] += min(res[i - 1], pref - cur);\n\t\t\tans = min(ans, res[i] + all - pref);\n\t\t}\n\t\treturn ans;\n\t};\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, k;\n\t\tstring s;\n\t\tcin >> n >> k >> s;\n\t\tvector<string> val(k);\n\t\tint cnt = count(s.begin(), s.end(), '1');\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tval[i % k] += s[i];\n\t\t}\n\t\tint ans = 1e9;\n\t\tfor (auto &it : val) ans = min(ans, solve(it) + (cnt - count(it.begin(), it.end(), '1')));\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}