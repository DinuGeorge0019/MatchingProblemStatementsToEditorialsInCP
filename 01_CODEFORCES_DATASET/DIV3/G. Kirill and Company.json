{"link": "https://codeforces.com//contest/1741/problem/G", "problemId": "1580863", "shortId": "1741G", "contest_number": "1741", "name": "G. Kirill and Company", "statement": "Kirill lives on a connected undirected graph of  vertices and  edges at vertex . One fine evening he gathered  friends, the -th friend lives at the vertex . So all friends are now in the vertex , the -th friend must get to his home to the vertex .The evening is about to end and it is time to leave. It turned out that  () of his friends have no cars, and they would have to walk if no one gives them a ride. One friend with a car can give a ride to  number of friends without cars, but only if he can give them a ride by driving along one of the  paths to his house.For example, in the graph below, a friend from vertex  can give a ride to friends from the following sets of vertices: , , , , , but can't give a ride to friend from vertex  or a set .     Kirill wants as few friends as possible to have to walk. Help him find the  possible number.", "input": "The first line of input data contains an integer  ()\u00a0\u2014 the number of test cases in the test. The first line of the test case contains two integers  and  (, )\u00a0\u2014 the number of vertices and edges, respectively. The next  lines of the test case contain a description of the edges, two integers each  and  (, )\u00a0\u2014 indexes of vertices connected by an edge. It is guaranteed that there is at most one edge between any pair of vertices (i.e. no multiple edges in the graph). Then follows line containing the number  ()\u00a0\u2014 the number of Kirill's friends. The next line of the test case contains  integers:  ()\u00a0\u2014 the vertices in which they live. Some vertices may be repeated. The next line of the set contains the number  ()\u00a0\u2014 the number of friends without cars. The last line of each test case contains  integers:  (, )\u00a0\u2014 indexes of friends without cars. It is guaranteed that the sum of  over all cases does not exceed , as well as the sums of  and .", "output": "Output  lines, each of which contains the answer to the corresponding test case. As an answer, output a single integer\u00a0\u2014  possible number of friends who will have to walk.", "tutorial": "To begin with, let's learn how to find possible sets of friends for the vertex, whom he can give a ride, in the form of masks. Let's use a breadth first search, every time we find the shortest path to the vertex  with the previous vertex , we will add the masks of the vertex  to the masks of the vertex , updating them with friends living in .Now, according to the resulting sets, you need to get the best combination of them. We will find it using the knapsack problem, we will use masks as weights, and the total weight will be the bitwise  of the selected set.", "solution": "from collections import deque\n \n \ndef solve():\n    n, m = map(int, input().split())\n    sl = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        sl[u] += [v]\n        sl[v] += [u]\n    f = int(input())\n    h = [int(x) - 1 for x in input().split()]\n    mask = [0] * n\n    k = int(input())\n    p = [int(x) - 1 for x in input().split()] + [-1]\n    for i in range(k):\n        mask[h[p[i]]] += 1 << i\n    vars = [set() for _ in range(n)]\n    dist = [-1] * n\n    dist[0] = 0\n    vars[0].add(mask[0])\n    q = deque([0])\n    while len(q) > 0:\n        v = q.popleft()\n        for u in sl[v]:\n            if dist[u] == -1:\n                dist[u] = dist[v] + 1\n                q.append(u)\n            if dist[u] == dist[v] + 1:\n                for msk in vars[v]:\n                    vars[u].add(msk | mask[u])\n    backpack = [False] * (1 << k)\n    backpack[0] = True\n    j = 0\n    for i in range(f):\n        if i == p[j]:\n            j += 1\n            continue\n        nw = backpack.copy()\n        for msk in range(1 << k):\n            if not backpack[msk]:\n                continue\n            for var in vars[h[i]]:\n                nw[msk | var] = True\n        backpack, nw = nw, backpack\n    mn = k\n    for msk in range(1 << k):\n        if not backpack[msk]:\n            continue\n        ans = 0\n        for b in range(k):\n            if msk & (1 << b) == 0:\n                ans += 1\n        mn = min(mn, ans)\n    print(mn)\n \n \nt = int(input())\nfor _ in range(t):\n    solve()", "interactive": false, "noSolution": false, "noTutorial": false}