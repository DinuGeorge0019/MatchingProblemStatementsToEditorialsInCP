{"link": "https://codeforces.com//contest/1133/problem/D", "problemId": "308947", "shortId": "1133D", "contest_number": "1133", "name": "D. Zero Quantity Maximization", "statement": "You are given two arrays  and , each contains  integers.You want to create a new array  as follows: choose some real (i.e. not necessarily integer) number , and then for every  let .Your goal is to maximize the number of zeroes in array . What is the largest possible answer, if you choose  optimally?", "input": "The first line contains one integer  () \u2014 the number of elements in both arrays. The second line contains  integers , , ...,  (). The third line contains  integers , , ...,  ().", "output": "Print one integer \u2014 the maximum number of zeroes in array , if you choose  optimally.", "tutorial": "For each index  let's try to find which  we should use in order to make -th element of  equal to zero.If , then  no matter which  we choose. So we should just ignore this index and add  to the answer if .Otherwise, we should choose . Let's calculate the required fraction for each index, and among all fractions find one that fits most indices (this can be done, for example, by storing all fractions in a ).The only thing that's left to analyze is how to compare the fractions, because floating-point numbers may be not precise enough. Let's store each fraction as a pair of integers , where  is the numenator and  is the denominator. We should normalize each fraction as follows: firstly, we reduce it by finding the greatest common divisor of  and , and then dividing both numbers by this divisor. Secondly, we should ensure that numenator is non-negative, and if numenator is zero, then denominator should also be non-negative (this can be achieved by multiplying both numbers by ).", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\nconst int N = 200043;\n\nvoid norm(pair<int, int>& p)\n{\n\tif(p.x < 0)\n\t{\n\t\tp.x *= -1;\n\t\tp.y *= -1;\n\t}\n\telse if (p.x == 0 && p.y < 0)\n\t{\n\t\tp.y *= -1;\n\t}\n\tint d = __gcd(abs(p.x), abs(p.y));\n\tp.x /= d;\n\tp.y /= d;\n}\n\nmap<pair<int, int>, int> m;\n\nint a[N];\nint b[N];\nint n;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &b[i]);\n\tint ans = 0;\n\tint cnt0 = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(a[i] == 0)\n\t\t{\n\t\t\tif(b[i] == 0)\n\t\t\t\tcnt0++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<int, int> p = make_pair(-b[i], a[i]);\n\t\t\tnorm(p);\n\t\t\tm[p]++;\n\t\t\tans = max(ans, m[p]);\n\t\t}\n\t}\n\tcout << cnt0 + ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}