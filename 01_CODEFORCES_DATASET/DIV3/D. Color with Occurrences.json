{"link": "https://codeforces.com//contest/1714/problem/D", "problemId": "1490430", "shortId": "1714D", "contest_number": "1714", "name": "D. Color with Occurrences", "statement": "You are given some text  and a set of  strings . In one step, you can choose any occurrence of any string  in the text  and color the corresponding characters of the text in red. For example, if  and , , you can get ,  or  in one step.You want to color all the letters of the text  in red. When you color a letter in red again, it stays red.In the example above, three steps are enough:  Let's color  in red, we get ;  Let's color  in red, we get ;  Let's color  in red, we get . Each string  can be applied any number of times (or not at all). Occurrences for coloring can intersect arbitrarily.Determine the minimum number of steps needed to color all letters  in red and how to do it. If it is impossible to color all letters of the text  in red, output .", "input": "The first line of the input contains an integer  ()\u00a0\u2014the number of test cases in the test. The descriptions of the test cases follow. The first line of each test case contains the text  (), consisting only of lowercase Latin letters, where  is the length of the text . The second line of each test case contains a single integer  () \u2014 the number of strings in the set. This is followed by  lines, each containing a string  () consisting only of lowercase Latin letters, where \u00a0\u2014 the length of string .", "output": "For each test case, print the answer on a separate line. If it is impossible to color all the letters of the text in red, print a single line containing the number . Otherwise, on the first line, print the number  \u2014 the minimum number of steps it will take to turn all the letters  red. Then in the next  lines print pairs of indices:  and  (), which denote that the string with index  was used as a substring to cover the occurrences starting in the text  from position . The pairs can be output in any order. If there are several answers, output any of them.", "tutorial": "The first step is to find the word that covers the maximum length prefix. If there is no such word, we cannot color the string.Then go through the positions inside the found prefix and find the next word, which is a tweak of , has the maximal length, and ends not earlier than the previous found word, and not later than the text . If there is no such word, it is impossible to color .After the second word is found, similarly continue looking for the next ones.", "solution": "#include<bits/stdc++.h>\n#define len(s) (int)s.size()\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\nint ans = 0;\nbool ok = true;\n\nvoid Find(int a, int b, string &t, vector<string>&str, vector<pair<int, int>>&match){\n    int Max = 0, id = -1, pos = -1;\n    for(int i = a; i <= b; i++){\n        for(int j = 0; j < len(str); j++){\n            string s = str[j];\n            if(i + len(s) > len(t) || i + len(s) <= b) continue;\n            if(t.substr(i, len(s)) == s) {\n                if(i + len(s) > Max){\n                    Max = i + len(s);\n                    id = j;\n                    pos = i;\n                }\n            }\n        }\n    }\n    if(id == -1) {\n        ok = false;\n        return;\n    }\n    else{\n        match.emplace_back(id, pos);\n        ans++;\n        if(Max == len(t)) return;\n        else Find(max(pos + 1, b +1), Max, t, str, match);\n    }\n}\n\n\nvoid solve(){\n    ans = 0;\n    ok = true;\n\n    string t;\n    cin >> t;\n    int n;\n    cin >> n;\n\n    vector<string>s(n);\n    vector<pair<int, int>>match;\n\n    forn(i, n) {\n        cin >> s[i];\n    }\n\n    Find(0, 0, t, s, match);\n    if(!ok) cout << \"-1\\n\";\n    else{\n        cout << ans << endl;\n        for(auto &p : match) cout << p.first + 1 << ' ' << p.second + 1 << endl;\n    }\n\n}\n\nint main(){\n    int q;\n    cin >> q;\n    while(q--){\n        solve();\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}