{"link": "https://codeforces.com//contest/1328/problem/F", "problemId": "573972", "shortId": "1328F", "contest_number": "1328", "name": "F. Make k Equal", "statement": "You are given the array  consisting of  elements and the integer .You want to obtain   equal elements in the array . In one move, you can make one of the following two operations:  Take  of the minimum elements of the array and increase its value by one (more formally, if the minimum value of  is  then you choose such index  that  and set );  take  of the maximum elements of the array and decrease its value by one (more formally, if the maximum value of  is  then you choose such index  that  and set ). Your task is to calculate the minimum number of moves required to obtain   equal elements in the array.", "input": "The first line of the input contains two integers  and  () \u2014 the number of elements in  and the required number of equal elements. The second line of the input contains  integers  (), where  is the -th element of .", "output": "Print one integer \u2014 the minimum number of moves required to obtain   equal elements in the array.", "tutorial": "This problem is just all about the implementation. Firstly, let's sort the initial values and compress them to pairs , where  is the number of elements . The first observation is pretty standard and easy: some equal elements will remain unchanged. So let's iterate over all elements  in some order and suppose that all elements  will remain unchanged. Firstly, we need  elements which we should obtain by some moves. The second observation is that we first need to take elements from one end (only less or only greater) and only then from the other (if needed).Consider the case when we first take less elements. The other case is almost symmetric.Let  be the number of less than  which we need to increase to . If  then skip the following step. Otherwise, let  be the number of elements less than or equal to ,  be the sum of all elements less than or equal to  and  be the previous value (the maximum value less than ). Then we need to increase all elements less than or equal to  at least to the value . It costs  moves. And then we need  moves to increase  elements to .And let  be the number of elements greater than  which we need to decrease to  if we increased  elements already. If  then skip the following step. Otherwise, let  be the number of elements greater than or equal to ,  be the sum of all elements greater than or equal to  and  be the next value (the minimum value greater than ). Then we need to decrease all elements greater than or equal to  at least to the value . It costs  moves. And then we need  moves to decrease  elements to .So we can update the answer with the sum of values described above and proceed to the next value. Arrays  are just simple prefix and suffix sums which can be calculated in  using very standard and easy dynamic programming. Don't forget about the overflow.Total time complexity:  because of sorting.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (auto &it : a) cin >> it;\n\t\n\tsort(a.begin(), a.end());\n\tvector<pair<int, int>> cnt;\n\tfor (auto it : a) {\n\t\tif (cnt.empty() || cnt.back().first != it) {\n\t\t\tcnt.push_back({it, 1});\n\t\t} else {\n\t\t\t++cnt.back().second;\n\t\t}\n\t}\n\tvector<long long> prefsum, sufsum;\n\tvector<int> prefcnt, sufcnt; \n\tfor (int i = 0; i < int(cnt.size()); ++i) {\n\t\tlong long cursum = cnt[i].first * 1ll * cnt[i].second;\n\t\tint curcnt = cnt[i].second;\n\t\tif (prefsum.empty()) {\n\t\t\tprefsum.push_back(cursum);\n\t\t\tprefcnt.push_back(curcnt);\n\t\t} else {\n\t\t\tprefsum.push_back(prefsum.back() + cursum);\n\t\t\tprefcnt.push_back(prefcnt.back() + curcnt);\n\t\t}\n\t}\n\tfor (int i = int(cnt.size()) - 1; i >= 0; --i) {\n\t\tlong long cursum = cnt[i].first * 1ll * cnt[i].second;\n\t\tint curcnt = cnt[i].second;\n\t\tif (sufsum.empty()) {\n\t\t\tsufsum.push_back(cursum);\n\t\t\tsufcnt.push_back(curcnt);\n\t\t} else {\n\t\t\tsufsum.push_back(sufsum.back() + cursum);\n\t\t\tsufcnt.push_back(sufcnt.back() + curcnt);\n\t\t}\n\t}\n\treverse(sufsum.begin(), sufsum.end());\n\treverse(sufcnt.begin(), sufcnt.end());\n\t\n\tlong long ans = INF64;\n\tfor (int i = 0; i < int(cnt.size()); ++i) {\n\t\tint cur = max(0, k - cnt[i].second);\n\t\t\n\t\tint needl = 0;\n\t\tif (i > 0) needl = min(cur, prefcnt[i - 1]);\n\t\tint needr = max(0, cur - needl);\n\t\tlong long res = 0;\n\t\tif (i > 0 && needl > 0) {\n\t\t\tres += prefcnt[i - 1] * 1ll * (cnt[i].first - 1) - prefsum[i - 1];\n\t\t\tres += needl;\n\t\t}\n\t\tif (i + 1 < int(cnt.size()) && needr > 0) {\n\t\t\tres += sufsum[i + 1] - sufcnt[i + 1] * 1ll * (cnt[i].first + 1);\n\t\t\tres += needr;\n\t\t}\n\t\tans = min(ans, res);\n\t\t\n\t\tneedr = 0;\n\t\tif (i + 1 < int(cnt.size())) needr = min(cur, sufcnt[i + 1]);\n\t\tneedl = max(0, cur - needr);\n\t\tres = 0;\n\t\tif (i > 0 && needl > 0) {\n\t\t\tres += prefcnt[i - 1] * 1ll * (cnt[i].first - 1) - prefsum[i - 1];\n\t\t\tres += needl;\n\t\t}\n\t\tif (i + 1 < int(cnt.size()) && needr > 0) {\n\t\t\tres += sufsum[i + 1] - sufcnt[i + 1] * 1ll * (cnt[i].first + 1);\n\t\t\tres += needr;\n\t\t}\n\t\tans = min(ans, res);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}