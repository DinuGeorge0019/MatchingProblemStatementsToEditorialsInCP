{"link": "https://codeforces.com//contest/1538/problem/G", "problemId": "1011927", "shortId": "1538G", "contest_number": "1538", "name": "G. Gift Set", "statement": "Polycarp has  of red and  of blue candies. Using them, he wants to make gift sets. Each gift set contains either  red candies and  blue candies, or  blue candies and  red candies. Any candy can belong to at most one gift set.Help Polycarp to find the largest number of gift sets he can create.For example, if , , , and , then Polycarp can make three gift sets:   In the first set there will be  red candies and  blue candies;  In the second set there will be  blue candies and  red candies;  In the third set will be  blue candies and  red candies. Note that in this example there is one red candy that Polycarp does not use in any gift set.", "input": "The first line contains an integer  (). Then  test cases follow. Each test case consists of a single string containing four integers , , , and  ().", "output": "For each test case, output one number\u00a0\u2014 the maximum number of gift sets that Polycarp can make.", "tutorial": "In this problem, we can use a binary search for the answer (If we can make  sets, then we can make  sets). So, we need to come up with the following test, whether we can make  sets knowing the parameters .Let  (otherwise we will swap them). If , the answer is .Otherwise, let's say we want to make  sets of the first kind. Then we get a system of inequalities  Let's express from here   We need to check whether these four equations have an intersection in integers. If there is, then the division into  gifts exists.", "solution": "#include <bits/stdc++.h>\n#include \"random\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing cd = complex<ld>;\n\nvoid solve() {\n    ll x, y, a, b;\n    cin >> x >> y >> a >> b;\n    ll l = 0, r = 1e9 + 100;\n    if (a == b) {\n        cout << min(x, y) / a << \"\\n\";\n        return;\n    }\n    if (a < b) {\n        swap(a, b);\n    }\n    while (r - l > 1) {\n        ll m = (l + r) / 2;\n        ll right = floorl((x - m * b) * 1.0l / (a - b));\n        ll left = ceill((y - m * a) * 1.0l / (b - a));\n        if (max(left, 0ll) <= min(right, m)) {\n            l = m;\n        } else {\n            r = m;\n        }\n    }\n    cout << l << \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}