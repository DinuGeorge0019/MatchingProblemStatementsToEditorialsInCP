{"link": "https://codeforces.com//contest/1759/problem/D", "problemId": "1648492", "shortId": "1759D", "contest_number": "1759", "name": "D. Make It Round", "statement": "Inflation has occurred in Berlandia, so the store needs to change the price of goods.The current price of good  is given. It is allowed to increase the price of the good by  times, with , k is an integer. Output the roundest possible new price of the good. That is, the one that has the maximum number of zeros at the end.For example, the number  is more round than the number  (three zeros at the end of  and only one at the end of ).If there are several possible variants, output the one in which the new price is maximal.If it is impossible to get a rounder price, output  (that is, the maximum possible price).", "input": "The first line contains a single integer  ()\u00a0\u2014the number of test cases in the test. Each test case consists of one line. This line contains two integers:  and  (). Where  is the old price of the good, and the number  means that you can increase the price  no more than  times.", "output": "For each test case, output on a separate line the roundest integer of the form  (, \u00a0\u2014 an integer). If there are several possible variants, output the one in which the new price (value ) is maximal. If it is impossible to get a more rounded price, output  (that is, the maximum possible price).", "tutorial": "The answer is .First, count two numbers:  which denote the degree of occurrence of  and  in the number  respectively, that is . Where  is not divisible by either  or . Now while  we will increase the corresponding value. For example, if , then as long as  and at that  we will increase  by  and multiply  by  times. That way we can get the most round number possible by spending the least possible .Now we either have , or  or . Then in the first case, we will multiply the number  by  as long as we can. That is, until .Now in either case we have: . Then . Then we multiply  by  times and get our desired answer.In the last step, we can no longer get a rounder number, but just find the maximal possible number.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define sz(v) (int)v.size()\n#define all(v) v.begin(),v.end()\n#define eb emplace_back\n\nusing ll = long long;\n\nvoid solve() {\n    ll n,m; cin >> n >> m;\n    ll n0 = n;\n    int cnt2 = 0, cnt5 = 0;\n    ll k = 1;\n    while (n > 0 && n % 2 == 0) {\n        n /= 2;\n        cnt2++;\n    }\n    while (n > 0 && n % 5 == 0) {\n        n /= 5;\n        cnt5++;\n    }\n    while (cnt2 < cnt5 && k * 2 <= m) {\n        cnt2++;\n        k *= 2;\n    }\n    while (cnt5 < cnt2 && k * 5 <= m) {\n        cnt5++;\n        k *= 5;\n    }\n    while (k * 10 <= m) {\n        k *= 10;\n    }\n    if (k == 1) {\n        cout << n0 * m << endl;\n    } else {\n        k *= m / k; // 1 <= m/k < 10\n        cout << n0 * k << endl;\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    forn(tt, t) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}