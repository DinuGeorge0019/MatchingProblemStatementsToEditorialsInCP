{"link": "https://codeforces.com//contest/1216/problem/B", "problemId": "416601", "shortId": "1216B", "contest_number": "1216", "name": "B. Shooting", "statement": "Recently Vasya decided to improve his pistol shooting skills. Today his coach offered him the following exercise. He placed  cans in a row on a table. Cans are numbered from left to right from  to . Vasya has to knock down each can exactly once to finish the exercise. He is allowed to choose  in which he will knock the cans down.Vasya knows that the  of the -th can is . It means that if Vasya has already knocked  cans down and is now about to start shooting the -th one, he will need  shots to knock it down. You can assume that if Vasya starts shooting the -th can, he will be shooting it until he knocks it down.Your task is to choose such an order of shooting so that the number of shots required to knock each of the  given cans down exactly once is minimum possible.", "input": "The first line of the input contains one integer   \u2014 the number of cans. The second line of the input contains the sequence  , where  is the durability of the -th can.", "output": "In the first line print the minimum number of shots required to knock each of the  given cans down exactly once. In the second line print the sequence consisting of   integers from  to  \u2014 the order of indices of cans that minimizes the number of shots required. If there are several answers, you can print any of them.", "tutorial": "We can see that because the multiplier  in the formula  is the position of the number and we want to minimize the sum of such formulas, the following greedy solution comes up to mind: because we want to count greater values as earlier as possible, let's sort the array  in non-increasing order (saving initial indices of elements), calculate the answer and print the permutation of indices in order from left to right.", "solution": "n, a = int(input()), list(map(int, input().split()))\nres = []\nans = 0\nfor i in range(n):\n\tpos = -1\n\tfor j in range(n):\n\t\tif (pos == -1 or a[j] > a[pos]): pos = j\n\tres.append(pos + 1)\n\tans += i * a[pos] + 1\n\ta[pos] = 0\nprint(ans)\nprint(' '.join([str(x) for x in res]))", "interactive": false, "noSolution": false, "noTutorial": false}