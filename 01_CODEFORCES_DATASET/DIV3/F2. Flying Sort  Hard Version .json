{"link": "https://codeforces.com//contest/1367/problem/F2", "problemId": "650999", "shortId": "1367F2", "contest_number": "1367", "name": "F2. Flying Sort  Hard Version ", "statement": "You are given an array  of  integers . You can perform the following operations on array elements:  choose any index  () and move the element  to the  of the array;  choose any index  () and move the element  to the  of the array. For example, if , , then the following sequence of operations can be performed:   after performing the operation of the first type to the second element, the array  will become ;  after performing the operation of the second type to the second element, the array  will become . You can perform operations of any type any number of times in any order.Find the minimum total number of operations of the first and second type that will make the  array sorted in non-decreasing order. In other words, what is the minimum number of operations must be performed so the array satisfies the inequalities .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases in the test. Then  test cases follow. Each test case starts with a line containing an integer  ()\u00a0\u2014 the size of the array . Then follow  integers  ()\u00a0\u2014 an array that needs to be sorted by the given operations. . The sum of  for all test cases in one test does not exceed .", "output": "For each test case output one integer\u00a0\u2014 the minimum total number of operations of the first and second type, which will make the array sorted in non-decreasing order.", "tutorial": "Let's replace each number  with the number of unique numbers less than .For example, the array  will be replaced by .Note that the values of the numbers themselves were not important to us, only the order between them was important.Let's sort such an array. Let's see what maximum length of the segment from the array  is already sorted (it forms a subsequence). This segment can be left in place, and all other numbers can be moved either to the beginning or to the end. That is, the task came down to finding the maximum sorted subsequence in the array.This problem can be solved with the help of simple dynamic programming. Let \u00a0\u2014- be the maximum length of a subsequence ending in position . To calculate it, we will find the closest past position, which also has the value  and the position with value  (lower numbers cannot be used, since  must stand between them). Any of these positions can be extended, so we take the maximum out of them and add 1. It is necessary to separately consider the first numbers in the subsequence and the last, since the first should include their suffix, and the last should have their prefix.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ld = long double;\nusing ll = long long;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    vector<pair<int, int>> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> v[i];\n        a[i] = {v[i], i};\n    }\n    sort(a.begin(), a.end());\n    vector<int> p(n);\n    int j = 0;\n    unordered_multiset<int> next;\n    for (int i = 0; i < n; i++) {\n        if (i > 0 && a[i].first != a[i - 1].first) {\n            j++;\n        }\n        p[a[i].second] = j;\n        next.insert(j);\n    }\n    unordered_map<int, int> d;\n    vector<int> dp1(n), dp2(n), dp3(n), cnt(n);\n    for (int i = 0; i < n; i++) {\n        if (next.count(p[i])) {\n            next.erase(next.find(p[i]));\n        }\n        if (d.count(p[i] - 1)) {\n            if (!d.count(p[i])) {\n                dp2[i] = max(dp2[i], dp1[d[p[i] - 1]] + 1);\n                if (!next.count(p[i] - 1)) {\n                    dp2[i] = max(dp2[i], dp2[d[p[i] - 1]] + 1);\n                }\n            }\n            if (!next.count(p[i] - 1)) {\n                dp3[i] = max(dp3[i], dp2[d[p[i] - 1]] + 1);\n            }\n            dp3[i] = max(dp3[i], dp1[d[p[i] - 1]] + 1);\n        }\n        if (d.count(p[i])) {\n            dp3[i] = max(dp3[i], dp3[d[p[i]]] + 1);\n            dp2[i] = max(dp2[i], dp2[d[p[i]]] + 1);\n            dp1[i] = dp1[d[p[i]]] + 1;\n        } else {\n            dp1[i] = 1;\n        }\n        dp2[i] = max(dp2[i], dp1[i]);\n        dp3[i] = max(dp3[i], dp2[i]);\n        d[p[i]] = i;\n    }\n    cout << n - *max_element(dp3.begin(), dp3.end()) << \"\\n\";\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n--) {\n        solve();\n    }\n}\n\n", "interactive": false, "noSolution": false, "noTutorial": false}