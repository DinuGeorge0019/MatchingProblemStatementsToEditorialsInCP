{"link": "https://codeforces.com//contest/1183/problem/H", "problemId": "363548", "shortId": "1183H", "contest_number": "1183", "name": "H. Subsequences  hard version ", "statement": ".A subsequence is a string that can be derived from another string by deleting some or no symbols without changing the order of the remaining symbols. Characters to be deleted are not required to go successively, there can be any gaps between them. For example, for the string \"\" the following strings are subsequences: \"\", \"\", \"\", \"\" and \"\" (empty string). But the following strings are not subsequences: \"\", \"\" and \"\".You are given a string  consisting of  lowercase Latin letters.In one move you can take  subsequence  of the given string and add it to the set . The set  can't contain duplicates. This move costs , where  is the length of the added subsequence (i.e. the price equals to the number of the deleted characters).Your task is to find out the minimum possible total cost to obtain a set  of size  or report that it is impossible to do so.", "input": "The first line of the input contains two integers  and  () \u2014 the length of the string and the size of the set, correspondingly. The second line of the input contains a string  consisting of  lowercase Latin letters.", "output": "Print one integer \u2014 if it is impossible to obtain the set  of size , print . Otherwise, print the minimum possible total cost to do it.", "tutorial": "Firstly, let's calculate the following auxiliary matrix:  means the maximum position  that is less than or equal to , and the character  (in order from  to , '' = , '' = , and so on). It can be calculated naively or with some easy dynamic programming (initially all  are  and then for each  from  to  all values  are equal to  except  which is ).After calculating this matrix we can solve the problem by the following dynamic programming: let  be the number of subsequences of length  that ends exactly in the position . Initially all values are zeros except  for each  from  to .How do we perform transitionss? Let's iterate over all lengths  from  to , then let's iterate over all positions  from  to  in a nested loop, and for the current state  we can calculate it as . If  then we don't need to add this state of the dynamic programming to the current state. Don't forget to take the minimum with  after each transition!This transition means that we take all subsequences that end with each possible character of the alphabet and try to add the current character to each of them. You can understand that there are no overlapping subsequences in this dynamic programming.After that let's iterate over all possible lengths  from  to  and calculate the number of subsequences of the current length . It equals to . The same, if  then we don't need to add this state of the dynamic programming to . Don't forget to take the minimum with ! If  then let's add  to the answer and break the cycle. Otherwise let's add  to the answer and decrease  by .If after all iterations  is greater than zero then let's try to add the empty string to the answer (we didn't take it into account earlier). Increase the answer by  and decrease  by one. If after this  is still greater than zero then the answer is , otherwise the answer is the calculated sum.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e12;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tlong long k;\n\tcin >> n >> k;\n\t--k; // the whole string costs nothing\n\tstring s;\n\tcin >> s;\n\t\n\tvector<vector<int>> lst(n, vector<int>(26, -1));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < 26; ++j) {\n\t\t\tif (i > 0) lst[i][j] = lst[i - 1][j];\n\t\t}\n\t\tlst[i][s[i] - 'a'] = i;\n\t}\n\t\n\tvector<vector<long long>> dp(n + 1, vector<long long>(n + 1));\n\tfor (int i = 0; i < n; ++i) {\n\t\tdp[i][1] = 1;\n\t}\n\t\n\tfor (int len = 2; len < n; ++len) {\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tfor (int j = 0; j < 26; ++j) {\n\t\t\t\tif (lst[i - 1][j] != -1) {\n\t\t\t\t\tdp[i][len] = min(INF64, dp[i][len] + dp[lst[i - 1][j]][len - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long ans = 0;\n\tfor (int len = n - 1; len >= 1; --len) {\n\t\tlong long cnt = 0;\n\t\tfor (int j = 0; j < 26; ++j) {\n\t\t\tif (lst[n - 1][j] != -1) {\n\t\t\t\tcnt += dp[lst[n - 1][j]][len];\n\t\t\t}\n\t\t}\n\t\tif (cnt >= k) {\n\t\t\tans += k * (n - len);\n\t\t\tk = 0;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tans += cnt * (n - len);\n\t\t\tk -= cnt;\n\t\t}\n\t}\n\t\n\tif (k == 1) {\n\t\tans += n;\n\t\t--k;\n\t}\n\t\n\tif (k > 0) cout << -1 << endl;\n\telse cout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}