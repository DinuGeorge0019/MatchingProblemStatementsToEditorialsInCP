{"link": "https://codeforces.com//contest/1790/problem/C", "problemId": "1753648", "shortId": "1790C", "contest_number": "1790", "name": "C. Premutation", "statement": "A sequence of  numbers is called  if it contains all integers from  to  exactly once. For example, the sequences [], [] and [] are permutations, but [], [] and []\u00a0\u2014 are not.Kristina had a permutation  of  elements. She wrote it on the whiteboard  times in such a way that:   while writing the permutation at the -th ( time she skipped the element   So, she wrote in total  sequences of length  each.For example, suppose Kristina had a permutation  =  of length . Then she did the following:   Wrote the sequence , skipping the element  from the original permutation.  Wrote the sequence , skipping the element  from the original permutation.  Wrote the sequence , skipping the element  from the original permutation.  Wrote the sequence , skipping the element  from the original permutation. You know all  of sequences that have been written on the whiteboard, but you do not know the order in which they were written. They are given in . Reconstruct the original permutation from them.For example, if you know the sequences , , , , then the original permutation will be  = .", "input": "The first line of input data contains a single integer  ()\u00a0\u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains one integer  (). This is followed by  lines, each containing exactly  integers and describing one of the sequences written out on the whiteboard. It is guaranteed that all sequences could be obtained from some permutation , and that the sum  over all input sets does not exceed .", "output": "For each test case, output on a separate line a permutation  such that the given  sequences could be obtained from it. It is guaranteed that the answer exists and it is the only one. In other words, for each test case the required permutation is sure to exist.", "tutorial": "When Kristina writes sequences on the whiteboard, she removes an element with each index exactly once. Thus, the first element of the permutation will be deleted only once \u2014 on the first step. All sequences except one will start with itTo solve the problem, find a sequence  such that:   it starts with some element   all sequences other than this one begin with some element  Then this permutation will describe the sequence of numbers remaining after removing the th element, and the first element itself will be equal to the number . The initial permutation will look like [].", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\nint n;\n\nvoid solve(){\n    cin >> n;\n    vector<vector<int>>perm(n, vector<int>(n - 1));\n    vector<int>p(n, 0);\n    vector<int>cnt(n + 1, 0);\n    for(int i = 0; i < n; i++){\n        p[i] = i + 1;\n        for(int j = 0; j < n - 1; j++){\n            cin >> perm[i][j];\n            if(j == 0) cnt[perm[i][j]]++;\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        if(cnt[i] == n - 1){\n            p[0] = i;\n            break;\n        }\n    }\n    for(int i = 0; i < n; i++){\n        if(perm[i][0] != p[0]){\n            for(int j = 0; j < n - 1; j++){\n                p[j + 1] = perm[i][j];\n            }\n        }\n    }\n    for(int i = 0; i < n; i++) cout << p[i] << ' ';\n    cout << endl;\n\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        solve();\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}