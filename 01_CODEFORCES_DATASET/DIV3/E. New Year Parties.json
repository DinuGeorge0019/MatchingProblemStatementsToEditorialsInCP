{"link": "https://codeforces.com//contest/1283/problem/E", "problemId": "504971", "shortId": "1283E", "contest_number": "1283", "name": "E. New Year Parties", "statement": "Oh, New Year. The time to gather all your friends and reflect on the heartwarming events of the past year... friends live in a city which can be represented as a number line. The -th friend lives in a house with an integer coordinate . The -th friend can come celebrate the New Year to the house with coordinate ,  or stay at . Each friend is allowed to move no more than once.For all friends  holds, however, they can come to houses with coordinates  and  (if their houses are at  or , respectively).For example, let the initial positions be . The final ones then can be , , ,  and so on. The number of occupied houses is the number of distinct positions among the final ones.So all friends choose the moves they want to perform. After that the number of occupied houses is calculated. What is the minimum and the maximum number of occupied houses can there be?", "input": "The first line contains a single integer  () \u2014 the number of friends. The second line contains  integers  () \u2014 the coordinates of the houses of the friends.", "output": "Print two integers \u2014 the minimum and the maximum possible number of occupied houses after all moves are performed.", "tutorial": "At first treat the two subtasks as completely independent problems.For both solutions the array of frequences is more convinient to use, so let's build it ( is the number of friends living in house ).1) MinimumCollect the answer greedily from left to right. If  then proceed to , otherwise add  to the answer and proceed to .To prove that let's maximize the number of merges of houses instead of minimizing the actual count of them. It's easy to show that the final number of houses is the initial one minus the number of merges.So if there are people in all  consecutive houses starting from , then  merges is the absolute best you can do with them, skipping any of the merges won't get the better answer. For only  of them occupied  merge is the best and we can achieve that  merge. And a single occupied house obviously will do  merges.2) MaximumAlso greedy but let's process the houses in segments of consecutive positions with positive . Take a look at the sum of some segment of houses. If the sum is greater than the length then you can enlarge that segment  house to the left or to the right. If the sum is greater by at least , than you can enlarge it both directions at the same time.Thus the following greedy will work. Let's update the segments from left to right. For each segments check the distance to the previous one (if it was enlarged to the right then consider the new right border). If you can enlarge the current segment and there is space on the left, then enlarge it. And if you still have possibility to enlarge the segment then enlarge it to the right.Notice that it doesn't matter which of any pair of consecutive segments will take the spot between them as the answer changes the same.The initial segments can be obtained with two pointers.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint n;\nvector<int> a, cnt;\n\nint solvemin(){\n\tint res = 0;\n\tforn(i, n){\n\t\tif (!cnt[i]) continue;\n\t\t++res;\n\t\ti += 2;\n\t}\n\treturn res;\n}\n\nint solvemax(){\n\tint res = 0;\n\tint dist = 2;\n\tbool right = false;\n\tforn(i, n){\n\t\tif (!cnt[i]){\n\t\t\t++dist;\n\t\t\tcontinue;\n\t\t}\n\t\tint j = i - 1;\n\t\tint sum = 0;\n\t\twhile (j + 1 < n && cnt[j + 1]){\n\t\t\t++j;\n\t\t\tsum += cnt[j];\n\t\t}\n\t\tres += (j - i + 1);\n\t\tif (sum > j - i + 1 && (!right || dist > 1)){\n\t\t\t--sum;\n\t\t\t++res;\n\t\t}\n\t\tright = false;\n\t\tif (sum > j - i + 1){\n\t\t\tright = true;\n\t\t\t++res;\n\t\t}\n\t\ti = j;\n\t\tdist = 0;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\ta.resize(n);\n\tcnt.resize(n + 1);\n\tforn(i, n){\n\t\tscanf(\"%d\", &a[i]);\n\t\t++cnt[a[i] - 1];\n\t}\n\tprintf(\"%d %d\\n\", solvemin(), solvemax());\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}