{"link": "https://codeforces.com//contest/977/problem/E", "problemId": "181256", "shortId": "977E", "contest_number": "977", "name": "E. Cyclic Components", "statement": "You are given an undirected graph consisting of  vertices and  edges. Your task is to find the number of connected components which are cycles.Here are some definitions of graph theory.An undirected graph consists of two sets: set of nodes (called vertices) and set of edges. Each edge connects a pair of vertices. All edges are bidirectional (i.e. if a vertex  is connected with a vertex , a vertex  is also connected with a vertex ). An edge can't connect vertex with itself, there is at most one edge between a pair of vertices.Two vertices  and  belong to the same connected component if and only if there is at least one path along edges connecting  and .A connected component is a cycle if and only if its vertices can be reordered in such a way that:  the first vertex is connected with the second vertex by an edge,  the second vertex is connected with the third vertex by an edge,  ...  the last vertex is connected with the first vertex by an edge,  all the described edges of a cycle are distinct. A cycle doesn't contain any other edges except described above. By definition any cycle contains three or more vertices.     ", "input": "The first line contains two integer numbers  and  (, ) \u2014 number of vertices and edges. The following  lines contains edges: edge  is given as a pair of vertices ,  (, ). There is no multiple edges in the given graph, i.e. for each pair () there no other pairs () and () in the list of edges.", "output": "Print one integer \u2014 the number of connected components which are also cycles.", "tutorial": "Let's solve this problem for each connected component of the given graph separately.It is easy to see that the connected component is a cycle iff the degree of each its vertex equals to .So the solution is to count the number of components such that every vertex in the component has degree .The connected components of the graph can be easily found by simple dfs or bfs.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 11;\n\nint n, m;\nint deg[N];\nbool used[N];\nvector<int> comp;\nvector<int> g[N];\n\nvoid dfs(int v) {\n\tused[v] = true;\n\tcomp.push_back(v);\n\t\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t\t++deg[x];\n\t\t++deg[y];\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tcomp.clear();\n\t\t\tdfs(i);\n\t\t\tbool ok = true;\n\t\t\tfor (auto v : comp) ok &= deg[v] == 2;\n\t\t\tif (ok) ++ans;\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}