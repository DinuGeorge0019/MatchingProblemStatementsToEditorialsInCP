{"link": "https://codeforces.com//contest/1311/problem/B", "problemId": "547477", "shortId": "1311B", "contest_number": "1311", "name": "B. WeirdSort", "statement": "You are given an array  of length .You are also given a set of  positions , where . The position  means that you can swap elements  and . You can apply this operation any number of times for each of the given .Your task is to determine if it is possible to sort the initial array in non-decreasing order () using only allowed swaps.For example, if  and , then we can first swap elements  and  (because position  is contained in the given set ). We get the array . Then we swap  and  (position  is also contained in ). We get the array . Finally, we swap  and  again and get the array , sorted in non-decreasing order.You can see that if  and  then you cannot sort the array.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of each test case contains two integers  and  () \u2014 the number of elements in  and the number of elements in . The second line of the test case contains  integers  (). The third line of the test case contains  integers  (, all  are distinct) \u2014 the set of positions described in the problem statement.", "output": "For each test case, print the answer \u2014 \"\" (without quotes) if you can sort the initial array in non-decreasing order () using only allowed swaps. Otherwise, print \"\".", "tutorial": "The simple simulation works here: while there is at least one inversion (such a pair of indices  and  that ) we can fix, let's fix it (we can fix this inversion if ). If there are inversions but we cannot fix any of them, the answer is \"\". Otherwise, the answer is \"\".There is also a  solution: it is obvious that we have some segments in which we can change the order of elements as we want. And it is also obvious that we cannot move elements between these \"allowed\" segments. So, each of them is independent of each other. We can just find all these segments of indices using two pointers and sort them independently. Then we just need to check if the array becomes sorted.Time complexity is  or .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tvector<int> p(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint pos;\n\t\t\tcin >> pos;\n\t\t\tp[pos - 1] = 1;\n\t\t}\n\t\twhile (true) {\n\t\t\tbool ok = false;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (p[i] && a[i] > a[i + 1]) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tswap(a[i], a[i + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) break;\n\t\t}\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tok &= a[i] <= a[i + 1];\n\t\t}\n\t\tif (ok) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}