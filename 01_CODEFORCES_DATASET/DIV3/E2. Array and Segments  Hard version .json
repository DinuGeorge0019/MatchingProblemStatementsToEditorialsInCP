{"link": "https://codeforces.com//contest/1108/problem/E2", "problemId": "286772", "shortId": "1108E2", "contest_number": "1108", "name": "E2. Array and Segments  Hard version ", "statement": ".You are given an array  consisting of  integers. The value of the -th element of the array is .You are also given a set of  segments. The -th segment is , where .You can choose some subset of the given set of segments and decrease values on each of the chosen segments by one (). For example, if the initial array  and the given segments are  and  then you can choose both of them and the array will become .You have to choose some subset of the given segments () in such a way that if you apply this subset of segments to the array  and obtain the array  then the value  will be  possible.Note that .If there are multiple answers, you can print .", "input": "The first line of the input contains two integers  and  () \u2014 the length of the array  and the number of segments, respectively. The second line of the input contains  integers  (), where  is the value of the -th element of the array . The next  lines are contain two integers each. The -th of them contains two integers  and  (), where  and  are the ends of the -th segment.", "output": "In the first line of the output print one integer  \u2014 the  possible value  if  is the array obtained by applying some subset of the given segments to the array . In the second line of the output print one integer  () \u2014 the number of segments you apply. In the third line print  distinct integers  in  () \u2014 indices of segments you apply to the array  in such a way that the value  of the obtained array  is  possible. If there are multiple answers, you can print .", "tutorial": "This tutorial is based on the previous problem (easy version) tutorial.At first, I want to say I know that this problem and this approach can be implemented in  with segment tree.So, we iterate over all supposed maximums in the array and trying to apply all segments not covering our current element. How do we can calculate the answer for  element if this element is the supposed maximum?Let's divide all segments we apply into two parts: the first part consists of segments such that their right endpoints is less than the current position and the second part consists of segments such that their left endpoints is greater than the current position. Then let's independently calculate answers for the left and for the right parts and merge them to obtain the answer.I will consider only first part of the solution (first part of segments) because the second part is absolutely symmetric with it.Let's maintain the minimum value on prefix of the array (let it be  and initially it equals to ), maintain the array  of length  (initially its values are  and  means the answer if the -th element of the array will be supposed maximum) and the array  of length , where  will be the value for which we decrease the -th element (in other words, the number of segments we apply to the -th element).What do we do for the current position ? Firstly, let's update the answer for it with the value  (in other words, set )). Then let's apply all segments with right endpoints equals to the current position straight-forward and update the value  with each new value of covered elements. Just iterate over all positions  of each segment ends in the current position, make  and set . And don't forget to update the value  with the value  after all changes (because we need to update this value with each element not covered by segments too).So then let's do the same from right to left and then  will mean the answer if the -th element is the supposed maximum in the resulting array. Then we can find any position of the maximum in the array  and apply all segments which don't cover this position.What is time complexity of the solution above? We iterate over all elements in the array, this is  and apply each segment in , so the final time complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int INF = 1e9;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\t\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tvector<pair<int, int>> b(m);\n\tvector<vector<int>> lf(n), rg(n);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> b[i].first >> b[i].second;\n\t\t--b[i].first;\n\t\t--b[i].second;\n\t\tlf[b[i].second].push_back(b[i].first);\n\t\trg[b[i].first].push_back(b[i].second);\n\t\t}\n\t\n\tvector<int> ansv(n, -INF);\n\t\n\tvector<int> add(n + 1 , 0);\n\tint mn = a[0];\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tansv[i] = max(ansv[i], a[i] - mn);\n\t\tfor (auto l : lf[i]) {\n\t\t\tfor (int j = l; j <= i; ++j) {\n\t\t\t\t--add[j];\n\t\t\t\tmn = min(mn, a[j] + add[j]);\n\t\t\t}\n\t\t}\n\t\tmn = min(mn, a[i] + add[i]);\n\t}\n\t\n\tadd = vector<int>(n + 1, 0);\n\tmn = a[n - 1];\n\t\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tansv[i] = max(ansv[i], a[i] - mn);\n\t\tfor (auto r : rg[i]) {\n\t\t\tfor (int j = i; j <= r; ++j) {\n\t\t\t\t--add[j];\n\t\t\t\tmn = min(mn, a[j] + add[j]);\n\t\t\t}\n\t\t}\n\t\tmn = min(mn, a[i] + add[i]);\n\t}\n\t\n\tint ans = *max_element(ansv.begin(), ansv.end());\n\tvector<int> res;\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (ansv[i] == ans) {\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tif (!(b[j].first <= i && i <= b[j].second)) {\n\t\t\t\t\tres.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcout << ans << endl << res.size() << endl;\n\tshuffle(res.begin(), res.end(), rnd);\n\tfor (auto it : res) cout << it + 1 << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}