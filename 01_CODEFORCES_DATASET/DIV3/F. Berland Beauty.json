{"link": "https://codeforces.com//contest/1296/problem/F", "problemId": "531588", "shortId": "1296F", "contest_number": "1296", "name": "F. Berland Beauty", "statement": "There are  railway stations in Berland. They are connected to each other by  railway sections. The railway network is connected, i.e. can be represented as an undirected tree.You have a map of that network, so for each railway section you know which stations it connects.Each of the  sections has some integer value of the . However, these values are not marked on the map and you don't know them. All these values are from  to  inclusive.You asked  passengers some questions: the -th one told you three values:  his departure station ;  his arrival station ;  minimum scenery beauty along the path from  to  (the train is moving along the shortest path from  to ). You are planning to update the map and set some value  on each railway section \u2014 the . The passengers' answers should be consistent with these values.Print any valid set of values , which the passengers' answer is consistent with or report that it doesn't exist.", "input": "The first line contains a single integer  () \u2014 the number of railway stations in Berland. The next  lines contain descriptions of the railway sections: the -th section description is two integers  and  (), where  and  are the indices of the stations which are connected by the -th railway section. All the railway sections are bidirected. Each station can be reached from any other station by the railway. The next line contains a single integer  () \u2014 the number of passengers which were asked questions. Then  lines follow, the -th line contains three integers ,  and  (; ; ) \u2014 the departure station, the arrival station and the minimum scenery beauty along his path.", "output": "If there is no answer then print a single integer . Otherwise, print  integers  (), where  is some valid scenery beauty along the -th railway section. If there are multiple answers, you can print any of them.", "tutorial": "Firstly, let's precalculate  arrays . The array  is the array of \"parents\" if we run dfs from the vertex . So,  is the vertex that is the previous one before  on the directed path . This part can be precalculated in time  and we need it just for convenience.Initially, all values  (beauties of the edges) are zeros. Let's consider queries in order of non-decreasing . For the current query, let's consider the whole path  and update the value  for each  on this path in the following way: . After processing all queries, let's replace all values  with . This part works also in time .And the last part of the solution is to check if the data we constructed isn't contradictory. We can iterate over all paths  and find the minimum value  on this path. We have to sure if it equals . If it isn't true for at least one query, then the answer is .Otherwise, we can print the resulting tree.Time complexity: , but it can be done in at least  (I hope someone can explain this solution because I am too lazy to do it now).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nvector<int> val;\nvector<vector<pair<int, int>>> g;\n\nvoid dfs(int v, int pv, int pe, vector<pair<int, int>> &p) {\n\tp[v] = make_pair(pv, pe);\n\tfor (auto it : g[v]) {\n\t\tint to = it.first;\n\t\tint idx = it.second;\n\t\tif (to == pv) continue;\n\t\tdfs(to, v, idx, p);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n;\n\tg = vector<vector<pair<int, int>>>(n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u, --v;\n\t\tg[u].push_back(make_pair(v, i));\n\t\tg[v].push_back(make_pair(u, i));\n\t}\n\t\n\tvector<vector<pair<int, int>>> p(n, vector<pair<int, int>>(n));\n\tfor (int i = 0; i < n; ++i) {\n\t\tdfs(i, -1, -1, p[i]);\n\t}\n\t\n\tval = vector<int>(n - 1, 1000000);\n\n    cin >> m;\n\tvector<pair<pair<int, int>, int>> q(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> q[i].first.first >> q[i].first.second >> q[i].second;\n\t\t--q[i].first.first;\n\t\t--q[i].first.second;\n\t}\n\tsort(q.begin(), q.end(), [&](pair<pair<int, int>, int> a, pair<pair<int, int>, int> b) {\n\t\treturn a.second < b.second;\n\t});\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tint u = q[i].first.first;\n\t\tint v = q[i].first.second;\n\t\twhile (v != u) {\n\t\t\tint pv = p[u][v].first;\n\t\t\tint pe = p[u][v].second;\n\t\t\tval[pe] = q[i].second;\n\t\t\tv = pv;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tint u = q[i].first.first;\n\t\tint v = q[i].first.second;\n\t\tint mx = 1000000;\n\t\twhile (v != u) {\n\t\t\tint pv = p[u][v].first;\n\t\t\tint pe = p[u][v].second;\n\t\t\tmx = min(mx, val[pe]);\n\t\t\tv = pv;\n\t\t}\n\t\tif (mx != q[i].second) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcout << val[i] << \" \";\n\t}\n\tcout << endl;\n\t\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}