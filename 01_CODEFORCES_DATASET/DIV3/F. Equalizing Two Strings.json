{"link": "https://codeforces.com//contest/1256/problem/F", "problemId": "459829", "shortId": "1256F", "contest_number": "1256", "name": "F. Equalizing Two Strings", "statement": "You are given two strings  and  both of length  and both consisting of lowercase Latin letters.In one move, you can choose any length  from  to  and perform the following operation:   Choose any contiguous substring of the string  of length  and reverse it;   choose any contiguous substring of the string  of length  and reverse it as well. Note that during one move you reverse  substring of the string  and  substring of the string .Also note that borders of substrings you reverse in  and in  , the only restriction is that you reverse the substrings of equal length. For example, if  and , you can reverse  and ,  and , but not  and .Your task is to say if it is possible to make strings  and  equal after some (possibly, empty) sequence of moves.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the length of  and . The second line of the test case contains one string  consisting of  lowercase Latin letters. The third line of the test case contains one string  consisting of  lowercase Latin letters. It is guaranteed that the sum of  over all test cases does not exceed  ().", "output": "For each test case, print the answer on it \u2014 \"\" (without quotes) if it is possible to make strings  and  equal after some (possibly, empty) sequence of moves and \"\" otherwise.", "tutorial": "The necessary condition to make strings equal is that the number of occurrences of each character should be the same in both strings. Let's show that if some character appears more than once, we always can make strings equal. How? Let's sort the first string by swapping adjacent characters (and it does not matter what do we do in the second string). Then let's sort the second string also by swapping adjacent characters but choose the pair of adjacent equal characters in the first string (it always exists because the first string is already sorted).Otherwise, all characters in both strings are distinct and they lengths are at most . Then the answer is  if the parity of the number of inversions (the number inversions in the array  is the number of such pairs of indices  that  but ) are the same. It can be proven in the following way: every swap of two adjacent elements changes the parity of the number of inversions.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint n;\n\t\tstring s, t;\n\t\tcin >> n >> s >> t;\n\t\tvector<int> cnts(26), cntt(26);\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t++cnts[s[j] - 'a'];\n\t\t\t++cntt[t[j] - 'a'];\n\t\t}\n\t\tbool ok = true;\n\t\tbool good = false;\n\t\tfor (int j = 0; j < 26; ++j) {\n\t\t\tok &= cnts[j] == cntt[j];\n\t\t\tgood |= cnts[j] > 1;\n\t\t}\n\t\tif (!ok) {\n\t\t\tcout << \"NO\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (good) {\n\t\t\tcout << \"YES\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint invs = 0, invt = 0;\n\t\tfor (int l = 0; l < n; ++l) {\n\t\t\tfor (int r = 0; r < l; ++r) {\n\t\t\t\tinvs += s[l] > s[r];\n\t\t\t\tinvt += t[l] > t[r];\n\t\t\t}\n\t\t}\n\t\tok &= (invs & 1) == (invt & 1);\n\t\tif (ok) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}