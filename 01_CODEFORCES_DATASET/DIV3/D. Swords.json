{"link": "https://codeforces.com//contest/1216/problem/D", "problemId": "416603", "shortId": "1216D", "contest_number": "1216", "name": "D. Swords", "statement": "There were  types of swords in the theater basement which had been used during the plays. Moreover there were   swords of each type.  people have broken into the theater basement and each of them has taken exactly  swords of some . Note that different people might have taken different types of swords. Note that the values  and  are unknown for you.The next morning the director of the theater discovers the loss. He counts all swords \u2014 exactly  swords of the -th type are left untouched.The director has no clue about the initial number of swords of each type in the basement, the number of people who have broken into the basement and how many swords each of them have taken.For example, if ,  then one of the possible situations is ,  and . Then the first three people took swords of the first type and the other two people took swords of the third type. Note that you don't know values  and  beforehand but know values of  and .Thus he seeks for your help. Determine the  number of people , which could have broken into the theater basement, and the number of swords  each of them has taken.", "input": "The first line of the input contains one integer   \u2014 the number of types of swords. The second line of the input contains the sequence  , where  equals to the number of swords of the -th type, which have remained in the basement after the theft. It is guaranteed that there exists at least one such pair of indices  that .", "output": "Print two integers  and  \u2014 the minimum number of people which could have broken into the basement and the number of swords each of them has taken.", "tutorial": "Firstly, let's notice that for the fixed value of  our problem is reduced to the following: we are given  numbers . We need to choose such values  that . And among all such values  we need to choose values in a way to minimize . And the sum of  is ! Of course, for the fixed value  the minimum sum of  can be only one.Let's start with . It is obvious that if the maximum value in the array  is  the value  equals  (for ). Assume that each  from  to  has some divisor . Then if we multiply  by  and divide each  by  the answer will only become better. How to calculate this value of  fast? We can see that this value equals to ! And it can be proven that this value of  is always optimal and we can easily determine  for such .Time complexity: .", "solution": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <iomanip>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cmath>\n\n#define forn(i, n) for(int i=0;i<n;++i)\n#define fore(i, l, r) for(int i = int(l); i <= int(r); ++i)\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y1 ________y1\n#define y second\n#define ft first\n#define sc second\n#define pt pair<int, int>\n\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\ntypedef long long li;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int INF = 1000 * 1000 * 1000;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n\nconst int N = 200 * 1000 + 13;\n\nint n;\nint a[N];\n\ninline void read() {\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n}\n\ninline int gcd(int a, int b) {\n\twhile (a != 0 && b != 0) {\n\t\tif (a > b) {\n\t\t\ta %= b;\n\t\t} else {\n\t\t\tb %= a;\n\t\t}\n\t}\n\treturn max(a, b);\n}\n\ninline void solve() {\n\tint ma = *max_element(a, a + n);\n    li sum = 0;\n    for (int i = 0; i < n; i++) {\n    \tsum += a[i];\n    }\n    int g = ma - a[0];\n    for (int i = 1; i < n; i++) {\n    \tg = gcd(g, ma - a[i]);\n    }    \n    li ans = (ma * 1ll * n - sum) / g;\n    cout << ans << ' ' << g << endl;\n}\n\nint main () {\n#ifdef fcspartakm\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    srand(time(NULL));\n    cerr << setprecision(10) << fixed;\n    \n    read();\n    solve();\n \n    //cerr << \"TIME: \" << clock() << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}