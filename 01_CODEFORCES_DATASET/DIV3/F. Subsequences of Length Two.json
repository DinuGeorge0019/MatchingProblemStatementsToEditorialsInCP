{"link": "https://codeforces.com//contest/1409/problem/F", "problemId": "716930", "shortId": "1409F", "contest_number": "1409", "name": "F. Subsequences of Length Two", "statement": "You are given two strings  and  consisting of lowercase Latin letters. The length of  is  (i.e. this string consists only of two characters).In one move, you can choose  character of  and replace it with  lowercase Latin letter. More formally, you choose some  and replace  (the character at the position ) with some character from '' to ''.You want to do   replacements in such a way that  the number of occurrences of  in  as a .Recall that a subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements.", "input": "The first line of the input contains two integers  and  (; ) \u2014 the length of  and the maximum number of moves you can make. The second line of the input contains the string  consisting of  lowercase Latin letters. The third line of the input contains the string  consisting of two lowercase Latin letters.", "output": "Print one integer \u2014 the maximum possible number of occurrences of  in  as a  if you replace no more than  characters in  optimally.", "tutorial": "I'm almost sure this problem can be solved faster and with greater constraints but this version is fine for the last problem.Consider both strings -indexed and let's do the dynamic programming . It means the maximum number of occurrences of  if we considered first  characters of , did  moves and the number of characters  is . The answer to the problem is . Initially all states are  and  is . What about transitions? There are essentially three types of them: don't change the current character, change the current character to  and change the current character to .Let's create three additional variables to make our life easier (if that were true...).  is  if  and  otherwise,  is  if  and  otherwise and  is  if  and  otherwise. Now let's make and describe our transitions: Don't change the -th character:.The expression  is just ternary if statement: if  is true, return , otherwise return . So, the number of characters  increases if  equals  and the answer increases if the -th character equals  (because we added all occurrences that end in the -th character). Change the -th character to  (possible only when ):.The number of characters  always increases and the answer increases if  equals  by the same reason as in the previous transition. Change the -th character to  (possible only when ):.The number of characters  increases only if  and the answer always increases.Note that we always increase the number of moves in the second and the third transitions even when  equals  or  because this case is handled in the first transition, so we don't care.Time complexity: .There are also some greedy approaches which work in  with pretty small constant and can be optimized even further.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tstring s, t;\n\tcin >> n >> k >> s >> t;\n\tvector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, -INF)));\n\tdp[0][0][0] = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int ck = 0; ck <= k; ++ck) {\n\t\t\tfor (int cnt0 = 0; cnt0 <= n; ++cnt0) {\n\t\t\t\tif (dp[i][ck][cnt0] == -INF) continue;\n\t\t\t\tint e0 = s[i] == t[0];\n\t\t\t\tint e1 = s[i] == t[1];\n\t\t\t\tint e01 = t[0] == t[1];\n\t\t\t\t\n\t\t\t\tdp[i + 1][ck][cnt0 + e0] = max(dp[i + 1][ck][cnt0 + e0], dp[i][ck][cnt0] + (e1 ? cnt0 : 0));\n\t\t\t\t\n\t\t\t\tif (ck < k) {\n\t\t\t\t\tdp[i + 1][ck + 1][cnt0 + 1] = max(dp[i + 1][ck + 1][cnt0 + 1], dp[i][ck][cnt0] + (e01 ? cnt0 : 0));\n\t\t\t\t\tdp[i + 1][ck + 1][cnt0 + e01] = max(dp[i + 1][ck + 1][cnt0 + e01], dp[i][ck][cnt0] + cnt0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int ck = 0; ck <= k; ++ck) {\n\t\tfor (int cnt0 = 0; cnt0 <= n; ++cnt0) {\n\t\t\tans = max(ans, dp[n][ck][cnt0]);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}