{"link": "https://codeforces.com//contest/1157/problem/D", "problemId": "336207", "shortId": "1157D", "contest_number": "1157", "name": "D. N Problems During K Days", "statement": "Polycarp has to solve exactly  problems to improve his programming skill before an important programming competition. But this competition will be held very soon, most precisely, it will start in  days. It means that Polycarp has exactly  days for training!Polycarp doesn't want to procrastinate, so he wants to solve at least one problem during each of  days. He also doesn't want to overwork, so if he solves  problems during some day, he should solve no more than  problems during the next day. And, at last, he wants to improve his skill, so if he solves  problems during some day, he should solve at least  problem during the next day.More formally: let  be the array of numbers of problems solved by Polycarp. The -th element of this array is the number of problems Polycarp solves during the -th day of his training. Then the following conditions must be satisfied:   sum of all  for  from  to  should be ;   should be  for each  from  to ;  the condition  should be satisfied for each  from  to . Your problem is to find  array  of length  satisfying the conditions above or say that it is impossible to do it.", "input": "The first line of the input contains two integers  and  () \u2014 the number of problems Polycarp wants to solve and the number of days Polycarp wants to train.", "output": "If it is impossible to find any array  of length  satisfying Polycarp's rules of training, print \"\" in the first line. Otherwise print \"\" in the first line, then print  integers  in the second line, where  should be the number of problems Polycarp should solve during the -th day. If there are multiple answers, you can print any.", "tutorial": "I suppose there are some solutions without cases handling, but I'll describe my own, it handling approximately $$$5$$$ cases.Firstly, let $$$nn = n - \\frac{k(k+1)}{2}$$$. If $$$nn < 0$$$ then the answer is \"\" already. Otherwise let's construct the array $$$a$$$, where all $$$a_i$$$ are $$$\\lfloor\\frac{nn}{k}\\rfloor$$$ (except rightmost $$$nn \\% k$$$ values, they are $$$\\lceil\\frac{nn}{k}\\rceil$$$). It is easy to see that the sum of this array is $$$nn$$$, it is sorted in non-decreasing order and the difference between the maximum and the minimum elements is not greater than $$$1$$$. Let's add $$$1$$$ to $$$a_1$$$, $$$2$$$ to $$$a_2$$$ and so on (this is what we subtract from $$$n$$$ at the beginning of the solution). Then if $$$nn \\ne k - 1$$$ or $$$k = 1$$$ then this answer is correct. Otherwise we got some array of kind $$$1, 3, \\dots, a_k$$$. How do we fix that? For $$$k=2$$$ or $$$k=3$$$ there is no answer for this case (you can try to prove it or try to find answers for cases $$$n=4, k=2$$$ and $$$n=8, k=3$$$). Otherwise $$$k > 3$$$ and we can subtract one from $$$a_2$$$ and add it to $$$a_k$$$ and this answer will be correct (this also can be proved with some easy formulas).Time complexity: $$$O(k)$$$.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tif (n < k * 1ll * (k + 1) / 2) {\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tint nn = n - k * (k + 1) / 2;\n\tvector<int> a(k);\n\tfor (int i = 0; i < k; ++i) {\n\t\ta[i] = i + 1 + (nn / k) + (i >= k - nn % k);\n\t}\n\t\n\tif (nn != k - 1) {\n\t\tcout << \"YES\" << endl;\n\t\tfor (int i = 0; i < k; ++i) cout << a[i] << \" \";\n\t\tcout << endl;\n\t} else {\n\t\tif (k > 3) {\n\t\t\t--a[1];\n\t\t\t++a[k - 1];\n\t\t}\n\t\tif (k == 2 || k == 3) {\n\t\t\tcout << \"NO\" << endl;\n\t\t} else {\n\t\t\tcout << \"YES\" << endl;\n\t\t\tfor (int i = 0; i < k; ++i) cout << a[i] << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}