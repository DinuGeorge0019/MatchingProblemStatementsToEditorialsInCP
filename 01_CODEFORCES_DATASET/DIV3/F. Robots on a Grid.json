{"link": "https://codeforces.com//contest/1335/problem/F", "problemId": "592977", "shortId": "1335F", "contest_number": "1335", "name": "F. Robots on a Grid", "statement": "There is a rectangular grid of size . Each cell of the grid is colored black ('') or white (''). The color of the cell  is . You are also given a map of directions: for each cell, there is a direction  which is one of the four characters '', '', '' and ''.  If  is '' then there is a transition from the cell  to the cell ;  if  is '' then there is a transition from the cell  to the cell ;  if  is '' then there is a transition from the cell  to the cell ;  if  is '' then there is a transition from the cell  to the cell . It is guaranteed that the top row doesn't contain characters '', the bottom row doesn't contain characters '', the leftmost column doesn't contain characters '' and the rightmost column doesn't contain characters ''.You want to place some robots in this field (at most one robot in a cell). The following conditions should be satisfied.  Firstly, each robot  every time (i.e. it cannot skip the move). .  Secondly, you have to place robots in such a way that  before which two different robots occupy the same cell (it also means that you cannot place two robots in the same cell). I.e. if the grid is \"\" (one row, two columns, colors does not matter there) then you can place two robots in cells  and , but if the grid is \"\" then you cannot place robots in cells  and  because during the first second both robots will occupy the cell . The robots make an infinite number of moves.Your task is to place the maximum number of robots to satisfy all the conditions described above and among all such ways, you have to choose one where the number of  cells occupied by robots  is the maximum possible. .You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains two integers  and  () \u2014 the number of rows and the number of columns correspondingly. The next  lines contain  characters each, where the -th character of the -th line is  ( is either '' if the cell  is black or '' if the cell  is white). The next  lines also contain  characters each, where the -th character of the -th line is  ( is '', '', '' or '' and describes the direction of the cell ). It is guaranteed that the sum of the sizes of fields does not exceed  ().", "output": "For each test case, print two integers \u2014 the maximum number of robots you can place to satisfy all the conditions described in the problem statement and the maximum number of  cells occupied by robots  if the number of robots placed is maximized. .", "tutorial": "First of all, I want to say about  solution. You can extract cycles in the graph, do some dynamic programming on trees, use some hard formulas and so on, but it is a way harder to implement than the other solution that only has an additional log, so I'll describe the one which is easier to understand and much easier to implement.Firstly, consider the problem from the other side. What is this grid? It is a functional graph (such a directed graph that each its vertex has exactly one outgoing edge). This graph seems like a set of cycles and ordered trees going into these cycles. How can it help us? Let's notice that if two robots meet after some move, then they'll go together infinitely from this moment. It means that if we try to make at least  moves from each possible cell, we will obtain some \"equivalence classes\" (it means that if endpoints of two cells coincide after  moves then you cannot place robots in both cells at once).So, if we could calculate such endpoints, then we can take for each possible endpoint the robot starting from the black cell (if such exists) and otherwise the robot starting from the white cell (if such exists).How can we calculate such endpoints? Let's number all cells from  to , where the number of the cell  is . Let the next cell after  is  (i.e. if you make a move from , you go to ). Also, let's create the two-dimensional array , where  means the number of the cell in which you will be if you start in the cell number  and make  moves. What is the upper bound of ? It is exactly .Well, we need to calculate this matrix somehow. It is obvious that if the number of the cell  is  and the number of the next cell  is  then . Then let's iterate over all degrees  from  to  and for each vertex  set . The logic behind this expresion is very simple: if we want to jump  times from  and we have all values for  calculated then let's just jump  times from  and  times from the obtained vertex. This technique is called binary lifting.Now we can jump from every cell  times in  time: just iterate over all degrees  from  to  and if  has the -th bit on, just jump from the current vertex  times (set ). The rest of solution is described above.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, lognm;\nvector<string> c, s;\nvector<vector<int>> used, nxt;\n\nvoid getnext(int x, int y, int &nx, int &ny) {\n\tif (s[x][y] == 'U') nx = x - 1, ny = y;\n\tif (s[x][y] == 'R') nx = x, ny = y + 1;\n\tif (s[x][y] == 'D') nx = x + 1, ny = y;\n\tif (s[x][y] == 'L') nx = x, ny = y - 1;\n}\n\nvoid dfs(int x, int y) {\n\tused[x][y] = 1;\n\tint nx = -1, ny = -1;\n\tgetnext(x, y, nx, ny);\n\tassert(0 <= nx && nx < n && 0 <= ny && ny < m);\n\tint v = x * m + y, to = nx * m + ny;\n\tif (!used[nx][ny]) dfs(nx, ny);\n\tnxt[v][0] = to;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tcin >> n >> m;\n\t\tlognm = 0;\n\t\tint nm = n * m;\n\t\twhile ((1 << lognm) <= nm) ++lognm;\n\t\tc = s = vector<string>(n);\n\t\tfor (auto &it : c) cin >> it;\n\t\tfor (auto &it : s) cin >> it;\n\t\t\n\t\tused = vector<vector<int>>(n, vector<int>(m));\n\t\tnxt = vector<vector<int>>(n * m, vector<int>(lognm));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tif (!used[i][j]) dfs(i, j);\n\t\t\t}\n\t\t}\n\t\tfor (int deg = 1; deg < lognm; ++deg) {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\t\tint id = i * m + j;\n\t\t\t\t\tnxt[id][deg] = nxt[nxt[id][deg - 1]][deg - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<vector<int>> black, white;\n\t\tblack = white = vector<vector<int>>(n, vector<int>(m));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tint v = i * m + j, to = v;\n\t\t\t\tfor (int deg = lognm - 1; deg >= 0; --deg) {\n\t\t\t\t\tif ((nm >> deg) & 1) to = nxt[to][deg];\n\t\t\t\t}\n\t\t\t\tif (c[i][j] == '0') ++black[to / m][to % m];\n\t\t\t\telse ++white[to / m][to % m];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint all = 0, good = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tif (black[i][j]) {\n\t\t\t\t\t++all;\n\t\t\t\t\t++good;\n\t\t\t\t} else if (white[i][j]) {\n\t\t\t\t\t++all;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << all << \" \" << good << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}