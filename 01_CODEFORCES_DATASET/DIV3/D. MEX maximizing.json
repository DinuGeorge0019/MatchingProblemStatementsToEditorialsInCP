{"link": "https://codeforces.com//contest/1294/problem/D", "problemId": "521710", "shortId": "1294D", "contest_number": "1294", "name": "D. MEX maximizing", "statement": "Recall that  of an array is a  that does not belong to the array. Examples:  for the array  MEX equals to  because numbers  and  are presented in the array and  is the minimum non-negative integer not presented in the array;  for the array  MEX equals to  because  is the minimum non-negative integer not presented in the array;  for the array  MEX equals to  because  is the minimum non-negative integer not presented in the array. You are given an empty array  (in other words, a zero-length array). You are also given a positive integer .You are also given  queries. The -th query consists of one integer  and means that you have to append one element  to the array. The array length increases by  after a query.In one move, you can choose any index  and set  or  (i.e. increase or decrease any element of the array by ). The only restriction is that . Since initially the array is empty, you can perform moves only after the first query.You have to maximize the  (minimum excluded) of the array if you can perform any number of such operations (you can even perform the operation multiple times with one element).You have to find the answer after each of  queries (i.e. the -th answer corresponds to the array of length ).", "input": "The first line of the input contains two integers  () \u2014 the number of queries and the value of . The next  lines describe queries. The -th query consists of one integer  () and means that you have to append one element  to the array.", "output": "Print the answer to the initial problem after each query \u2014 for the query  print the maximum value of  after first  queries. Note that queries are dependent (the array changes after each query) but operations are independent between queries.", "tutorial": "Firstly, let's understand what the operation does. It changes the element but holds the remainder modulo . So we can consider all elements modulo .Let  be the number of elements with the value  modulo ,  be the number of elements with the value  modulo , and so on. Let's understand, where is the \"bottleneck\" of MEX. Obviously, we can always fill exactly  full blocks, so MEX is at least . MEX will be among all elements  such that . Among all such elements MEX will be the minimum such . Let it be . So the final value of MEX is .How to deal with queries? Let's maintain the sorted set of pairs () for all  and change it with respect to appended values. During each query let's change the set correspondingly and take the answer as the first element of this set using the formula above.Time complexity: . There is also an easy linear solution that uses the same idea but in a different way.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q, x;\n\tcin >> q >> x;\n\tvector<int> mods(x);\n\t\n\tset<pair<int, int>> vals;\n\tfor (int i = 0; i < x; ++i) {\n\t\tvals.insert(make_pair(mods[i], i));\n\t}\n\t\n\tfor (int i = 0; i < q; ++i) {\n\t\tint cur;\n\t\tcin >> cur;\n\t\tcur %= x;\n\t\tvals.erase(make_pair(mods[cur], cur));\n\t\t++mods[cur];\n\t\tvals.insert(make_pair(mods[cur], cur));\n\t\tcout << vals.begin()->first * x + vals.begin()->second << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}