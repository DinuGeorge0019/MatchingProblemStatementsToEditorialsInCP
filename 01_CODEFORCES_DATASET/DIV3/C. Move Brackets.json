{"link": "https://codeforces.com//contest/1374/problem/C", "problemId": "659586", "shortId": "1374C", "contest_number": "1374", "name": "C. Move Brackets", "statement": "You are given a bracket sequence  of length , where  is even (divisible by two). The string  consists of  opening brackets '' and  closing brackets ''.In one move, you can choose  and move it to the beginning of the string or to the end of the string (i.e. you choose some index , remove the -th character of  and insert it before or after all remaining characters of ).Your task is to find the minimum number of moves required to obtain  from . It can be proved that the answer always exists under the given constraints.Recall what the regular bracket sequence is:  \"\" is regular bracket sequence;  if  is regular bracket sequence then \"\" +  + \"\" is regular bracket sequence;  if  and  are regular bracket sequences then  +  is regular bracket sequence. For example, \"\", \"\", \"\" and \"\" are regular bracket sequences, but \"\", \"\" and \"\" are not.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the length of . It is guaranteed that  is even. The second line of the test case containg the string  consisting of  opening and  closing brackets.", "output": "For each test case, print the answer \u2014 the minimum number of moves required to obtain  from . It can be proved that the answer always exists under the given constraints.", "tutorial": "Let's go from left to right over characters of  maintaining the current bracket balance (for the position  the balance is the number of opening brackets on the prefix till the -th character minus the number of closing brackets on the same prefix).If the current balance becomes less than zero, then let's just take some opening bracket after the current position (it obviously exists because the number of opening equals the number of closing brackets) and move it to the beginning (so the negative balance becomes zero again and the answer increases by one). Or we can move the current closing bracket to the end of the string because it leads to the same result.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tstring s;\n\t\tcin >> n >> s;\n\t\tint ans = 0;\n\t\tint bal = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (s[i] == '(') ++bal;\n\t\t\telse {\n\t\t\t\t--bal;\n\t\t\t\tif (bal < 0) {\n\t\t\t\t\tbal = 0;\n\t\t\t\t\t++ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}