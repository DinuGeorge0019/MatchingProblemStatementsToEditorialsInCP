{"link": "https://codeforces.com//contest/1675/problem/G", "problemId": "1389924", "shortId": "1675G", "contest_number": "1675", "name": "G. Sorting Pancakes", "statement": "Nastya baked  pancakes and spread them on  dishes. The dishes are in a row and numbered from left to right. She put  pancakes on the dish with the index .Seeing the dishes, Vlad decided to bring order to the stacks and move some pancakes. In one move, he can shift one pancake from any dish to the closest one, that is, select the dish  () and do one of the following: if , put the pancake on a dish with the previous index, after this move  and ; if , put the pancake on a dish with the following index, after this move  and .Vlad wants to make the array , after moving as few pancakes as possible. Help him find the minimum number of moves needed for this.The array  is called non-increasing if  for all  from  to .", "input": "The first line of the input contains two numbers  and  () \u2014 the number of dishes and the number of pancakes, respectively. The second line contains  numbers  (), the sum of all  is equal to .", "output": "Print a single number: the minimum number of moves required to make the array  non-increasing.", "tutorial": "For convenience, we will calculate the prefix sums on the array , we will also enter the array  containing the indexes of all pancakes and calculate the prefix sums on it.Let's use dynamic programming. Let's define  as the required number of operations to correctly lay out the -th prefix, with the final , and . Then you can go to  from  (the previous number must be greater, and the sum is fixed). To , it will be necessary to add a certain number of actions necessary to get , let's call it  (all the terrible prefix sums are needed to count it). Since  depends only on  and , we only need to choose the minimum , the choice can be optimized by suffix minima. As a result, the solution works for , that's how many states need to be processed.", "solution": "#include <bits/stdc++.h>\n\n//#define int long long\n#define mp make_pair\n#define x first\n#define y second\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n\ntypedef long double ld;\ntypedef long long ll;\n\nusing namespace std;\n\nmt19937 rnd(143);\n\nconst ll inf = 1e9 + 7;\nconst ll M = 998'244'353;\nconst ld pi = atan2(0, -1);\nconst ld eps = 1e-4;\n\nvoid solve(int test_case) {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n), pancakes(1);\n    for(int &e: a) cin >> e;\n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < a[i]; ++j){\n            pancakes.emplace_back(i);\n            int c = pancakes.size();\n            pancakes[c - 1] += pancakes[c - 2];\n        }\n        if(i > 0) a[i] += a[i - 1];\n    }\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(m + 1, vector<int>(m + 1, inf)));\n    for(int j = 0; j <= m; j++){\n        if(a[0] >= j) dp[0][j][j] = a[0] - j;//moved right\n        else dp[0][j][j] = pancakes[j];//moved from right\n    }\n    for(int j = m - 1; j >= 0; --j){\n        for(int k = j; k <= m; ++k){\n            dp[0][j][k] = min(dp[0][j][k], dp[0][j + 1][k]);\n        }\n    }\n    for(int i = 1; i < n; ++i){\n        for(int j = 0; j <= m; ++j){\n            for(int k = j; k <= m; ++k){\n                int add = 0;\n                if(a[i] >= k) add = a[i] - k;//moved to i + 1\n                else {\n                    int lend = min(j, k - a[i]);\n                    add = pancakes[k] - pancakes[k - lend] - i * (lend);//moved from greater i\n                }\n                dp[i][j][k] = dp[i - 1][j][k - j] + add;\n            }\n        }\n\n        for(int j = m - 1; j >= 0; --j){\n            for(int k = (i + 1) * j; k <= m; ++k){\n                dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k]);\n            }\n        }\n    }\n    cout << dp[n-1][0][m];\n}\n\nbool multi = false;\n\nsigned main() {\n    int t = 1;\n    if (multi) {\n        cin >> t;\n    }\n    for (int i = 1; i <= t; ++i) {\n        solve(i);\n        cout << \"\\n\";\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}