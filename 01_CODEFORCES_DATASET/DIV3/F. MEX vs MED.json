{"link": "https://codeforces.com//contest/1744/problem/F", "problemId": "1588812", "shortId": "1744F", "contest_number": "1744", "name": "F. MEX vs MED", "statement": "You are given a permutation  of length  of numbers . Count the number of subsegments  of this permutation such that . of  is the smallest non-negative integer that does not occur in . For example:    of the set  is the median of the set, i.e. the element that, after sorting the elements in non-decreasing order, will be at position number  (array elements are numbered starting from  and here  denotes rounding  down.). For example:   A sequence of  numbers is called a permutation if it contains all the numbers from  to  exactly once.", "input": "The first line of the input contains a single integer  ), the number of test cases. The descriptions of the test cases follow. The first line of each test case contains a single integer  (), the length of the permutation . The second line of each test case contains exactly  integers:  (), elements of permutation . It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case print the answer in a single line: the number of subsegments  of this permutation such that .", "tutorial": "Let's learn how to count the number of subsegments where  for a fixed value of .Let's understand on which subsegments  has such a value. We understand that the numbers  should be in this subsegment, the number \u00a0\u2014 should not, and then\u00a0\u2014 does not matter . Let \u00a0\u2014 be the index of the left-most occurrence of the numbers , and \u00a0\u2014 the right-most occurrence. Also, let  \"be the index of the number . If , then there is no subsegment with the given , otherwise let's think about how many numbers can be in a subsegment.It is stated that if the length of a segment is , then  on it, otherwise it is not true. Indeed, if the length of a segment is , then simply by the definition of the median, it will be among the first  numbers. On the other hand, if the length of the segment becomes longer, then according to the same definition of the median, it will no longer be among the first  numbers, which are equal to .It turns out that we need to count the number of subsegments of length  that contain the subsegment  inside themselves, but not . This, of course, can be done with large formulas and the like, but one more useful fact can be noticed!If we iterate over  in ascending order, and at the same time maintain  and , then let's see what happens with a fixed  and a position of  (for convenience, let's assume that , since the second case is similar). In fact, you can simply iterate over the left border of our segment from  to , and then use a simpler formula to calculate the number of good subsegments with such fixed values.Why can this left boundary be iterated for each  if  (correspondingly, if it were , then we would iterate over the right boundary) ? Let's remember that after this step,  becomes equal to . That is, if we iterate over an element, then we move the corresponding border. And we can only move it  times.", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\nint t,n;\nint a[200007],pos[200007];\nint mins,maxs,curr;\n\nlong long ans;\n\nlong long calc(int l,int r,int len){\n    len-=(r-l+1);\n    long long lt=max(l-len,1),rt=min(n-len-(r-l+1)+1,l);\n    return rt-lt+1;\n}\n\nint main(){\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin>>t;\n    for(int i=1;i<=t;i++){\n        cin>>n;\n        for(int f=1;f<=n;f++){\n            cin>>a[f];\n            pos[a[f]]=f;\n        }\n        curr=ans=0;\n        mins=n; maxs=-1;\n        for(int f=1;f<=n;f++){\n            if(f%2==1){\n                mins=min(mins,pos[curr]);\n                maxs=max(maxs,pos[curr]);\n                curr++;\n            }\n            if(maxs-mins+1>f)continue;\n            ans+=calc(mins,maxs,f);\n        }\n        cout<<ans<<\"\\n\";\n    }\n\n    return 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}