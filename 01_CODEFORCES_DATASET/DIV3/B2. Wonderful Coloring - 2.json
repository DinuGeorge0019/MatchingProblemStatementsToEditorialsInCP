{"link": "https://codeforces.com//contest/1551/problem/B2", "problemId": "1055221", "shortId": "1551B2", "contest_number": "1551", "name": "B2. Wonderful Coloring - 2", "statement": "Recently, Paul and Mary have found a new favorite sequence of integers . They want to paint it using pieces of chalk of  colors. The coloring of a sequence is called  if the following conditions are met:  each element of the sequence is either painted in one of  colors or isn't painted;  each two elements which are painted in the same color are different (i.\u2009e. there's no two equal values painted in the same color);  let's calculate for each of  colors the number of elements painted in the color \u2014 all calculated numbers must be equal;  the total number of painted elements of the sequence is the  among all colorings of the sequence which meet the first three conditions. E.\u2009g. consider a sequence  and . One of the wonderful colorings of the sequence is shown in the figure.     Help Paul and Mary to find a wonderful coloring of a given sequence .", "input": "The first line contains one integer  () \u2014 the number of test cases. Then  test cases follow. Each test case consists of two lines. The first one contains two integers  and  (, ) \u2014 the length of a given sequence and the number of colors, respectively. The second one contains  integers  (). It is guaranteed that the sum of  over all test cases doesn't exceed .", "output": "Output  lines, each of them must contain a description of a wonderful coloring for the corresponding test case. Each wonderful coloring must be printed as a sequence of  integers  () separated by spaces where   , if -th element isn't painted;  , if -th element is painted in the -th color.  Remember that you need to maximize the total count of painted elements for the wonderful coloring. If there are multiple solutions, print any one.", "tutorial": "Since we must use exactly  colors, each element that occurs in the sequence may have no more than  painted occurrences.  for each element   its occurrences where  is the number of all its occurrences in the sequence.Let  be a sequence of all elements that occur in the sequence , but in the sequence  they will occur only once. Let's create a -indexed array  in which we will add  indices of  occurrences of  in the sequence , then the selected occurrences of , and so on till . Currently,  is a set of occurrences, which wonderful coloring is a wonderful coloring of the whole sequence  because if we want to paint an occurrence outside , we can do it only by selecting an occurrence of the same element in  which we will not paint so that no more than  occurrences will be painted.We must use exactly  colors and paint for each color an equal number of occurrences, hence if we want to paint all occurrences from , we must remove from it the minimum number of occurrences so that the size of the array  will be divided by  (i. e. remove the number of occurrences equal to the remainder of dividing the size of  by ). We can remove any occurrences, for example, let's delete it from the suffix of . Currently, we can paint all occurrences from  using the following rule: the occurrence  we must paint in the color with a number  where  takes the remainder of dividing the left operand by the right operand. So all occurrences from  will be painted and all  colors will be used. Since all occurrences of one element belong to one subsegment of  and their number isn't greater than , they will be painted in different colors.It may be so that the array  before painting will be empty. In this case, the wonderful coloring of  doesn't contain any painted element.", "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 200 * 1000 + 13;\n\nint ans[MAX_N];\nmap<int, vector<int>> indices;\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tindices.clear();\n\t\tmemset(ans, 0, n * sizeof(ans[0]));\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tif (indices[x].size() < k)\n\t\t\t\tindices[x].push_back(i);\n\t\t}\n\t\tint m = 0;\n\t\tfor (auto e : indices) m += e.second.size();\n\t\tm -= m % k;\n\t\tint color = 0;\n\t\tfor (auto e : indices)\n\t\t\tfor (auto i : e.second)\n\t\t\t{\n\t\t\t\tans[i] = ++color;\n\t\t\t\tcolor %= k;\n\t\t\t\tif (--m == 0) goto _output;\n\t\t\t}\n\t_output:\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcout << ans[i] << ' ';\n\t\tcout << '\\n';\n\t}\n\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}