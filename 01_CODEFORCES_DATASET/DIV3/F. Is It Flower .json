{"link": "https://codeforces.com//contest/1811/problem/F", "problemId": "1864328", "shortId": "1811F", "contest_number": "1811", "name": "F. Is It Flower ", "statement": "Vlad found a flowerbed with graphs in his yard and decided to take one for himself. Later he found out that in addition to the usual graphs, -flowers also grew on that flowerbed. A graph is called a -flower if it consists of a simple cycle of length , through each vertex of which passes its own simple cycle of length  and these cycles do not intersect at the vertices. For example, -flower looks like this:  Note that -flower and -flower do not exist, since at least  vertices are needed to form a cycle.Vlad really liked the structure of the -flowers and now he wants to find out if he was lucky to take one of them from the flowerbed.", "input": "The first line of input contains the single integer  ()\u00a0\u2014 the number of test cases in the test. The descriptions of the cases follow. An empty string is written before each case. The first line of each case contains two integers  and  (, ) \u2014 the number of vertices and edges in the graph, respectively. The next  lines contain two integers each  and  (, ) \u2014 numbers of vertices connected by an edge. It is guaranteed that the graph does not contain multiple edges and self-loops. It is guaranteed that the sum of  over all test cases does not exceed . It is also guaranteed for the sum of  over all test cases.", "output": "Output  lines, each of which is the answer to the corresponding test case. As an answer, output \"\" if Vlad's graph is a -flower for some , and \"\" otherwise. You can output the answer in any case (for example, the strings \"\", \"\", \"\" and \"\" will be recognized as a positive answer).", "tutorial": "Note a few things:  There are exactly  vertices in the -flower, since from each of the  vertices of the main cycle comes another cycle of size ;  in the -flower, all vertices have degree , except for the vertices of the main cycle, whose degrees are ;  it follows that in -flower  edges; The listed properties do not take into account only the connectivity of the graph and the sizes of our  cycles. To check connectivity we run a bfs or dfs from any vertex and check that all vertices have been visited. To check the cycle lengths, we cut out the edges of the main one and make sure that the graph has fell apart into components of size .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint sz(int v, vector<vector<int>> &g, vector<bool> &used){\n    used[v] = true;\n    int s = 1;\n    for(int u: g[v]){\n        if(!used[u]) s += sz(u, g, used);\n    }\n    return s;\n}\n\nvoid remove(vector<int> &from, int x){\n    for(int &e: from){\n        if(e == x){\n            swap(e, from.back());\n            from.pop_back();\n            return;\n        }\n    }\n}\n\nvoid solve(int tc) {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> sl(n);\n    for(int i = 0; i < m; ++i){\n        int u, v;\n        cin >> u >> v;\n        sl[--u].emplace_back(--v);\n        sl[v].emplace_back(u);\n    }\n    int k = sqrt(n);\n    if(n != k * k || m != n + k){\n        cout << \"NO\";\n        return;\n    }\n    for(int i = 0; i < n; ++i){\n        if(sl[i].size() != 2 && sl[i].size() != 4){\n            cout << \"NO\";\n            return;\n        }\n    }\n    vector<bool> used(n);\n    if(sz(0, sl, used) != n){\n        cout << \"NO\";\n        return;\n    }\n    for(int i = 0; i < n; ++i){\n        if(sl[i].size() == 2) continue;\n        for(int j = 0; j < sl[i].size();){\n            int u = sl[i][j];\n            if(sl[u].size() > 2){\n                remove(sl[i], u);\n                remove(sl[u], i);\n            }\n            else{\n                j++;\n            }\n        }\n    }\n    used = vector<bool>(n);\n    for(int i = 0; i < n; ++i){\n        if(!used[i] && sz(i, sl, used) != k){\n            cout << \"NO\";\n            return;\n        }\n    }\n    cout << \"YES\";\n}\n\nbool multi = true;\n\nsigned main() {\n    cout.tie(nullptr);\n    int t = 1;\n    if (multi)cin >> t;\n    for (int i = 1; i <= t; ++i) {\n        solve(i);\n        cout << \"\\n\";\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}