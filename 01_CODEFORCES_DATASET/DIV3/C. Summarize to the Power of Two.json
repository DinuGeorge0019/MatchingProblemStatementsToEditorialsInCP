{"link": "https://codeforces.com//contest/1005/problem/C", "problemId": "196283", "shortId": "1005C", "contest_number": "1005", "name": "C. Summarize to the Power of Two", "statement": "A sequence  is called good if, for each element , there exists an element  () such that  is a power of two (that is,  for some non-negative integer ).For example, the following sequences are good:   (for example, for  we can choose . Note that their sum is a power of two. Similarly, such an element can be found for  and ),  ,  ,  . Note that, by definition, an empty sequence (with a length of ) is good.For example, the following sequences are not good:   (for , it is impossible to find another element  such that their sum is a power of two),   (for , it is impossible to find another element  such that their sum is a power of two),   (for , it is impossible to find another element  such that their sum is a power of two). You are given a sequence . What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.", "input": "The first line contains the integer  () \u2014 the length of the given sequence. The second line contains the sequence of integers  ().", "output": "Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all  elements, make it empty, and thus get a good sequence.", "tutorial": "You should delete only such  for which there is no such  () that  is a power of .For each value let's find the number of its occurrences. You can use simple  standard data-structure. Do  for each element .Now you can easily check that  doesn't have a pair . Let's iterate over all possible sums  and for each  find calculate . If for some :  or  &&  then a pair  exists.Note that in C++ solutions, it's better to first check that  is a key in , and only after it calculate . This needs to be done, since in C++ when you access a key using the \"square brackets\" operator, a default mapping key-value is created on the absence of the key. This increases both the running time and the memory consumption.\n", "solution": "int n;\ncin >> n;\nvector<int> a(n);\nmap<int,int> c;\nforn(i, n) {\n    cin >> a[i];\n    c[a[i]]++;\n}\nint ans = 0;\nforn(i, n) {\n    bool ok = false;\n    forn(j, 31) {\n        int x = (1 << j) - a[i];\n        if (c.count(x) && (c[x] > 1 || (c[x] == 1 && x != a[i])))\n            ok = true;\n    }\n    if (!ok)\n        ans++;\n}\ncout << ans << endl;", "interactive": false, "noSolution": false, "noTutorial": false}