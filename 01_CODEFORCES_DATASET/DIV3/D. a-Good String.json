{"link": "https://codeforces.com//contest/1385/problem/D", "problemId": "675201", "shortId": "1385D", "contest_number": "1385", "name": "D. a-Good String", "statement": "You are given a string  consisting of lowercase Latin letters. It is guaranteed that  for some integer .The string  is called  if  of the following three conditions is satisfied:  The length of  is , and it consists of the character  (i.e. ); The length of  is greater than , the first half of the string consists of only the character  (i.e. ) and the second half of the string (i.e. the string ) is a  string;  The length of  is greater than , the second half of the string consists of only the character  (i.e. ) and the first half of the string (i.e. the string ) is a  string. For example: \"\" is , \"\" is .In one move, you can choose one index  from  to  and replace  with any lowercase Latin letter (any character from '' to '').Your task is to find the minimum number of moves required to obtain an  string from  (i.e.  for  ''). It is guaranteed that the answer always exists.You have to answer  independent test cases.Another example of an  string is as follows. Consider the string \"\". It is an  string, because:  the second half of the string (\"\") consists of only the character '';  the first half of the string (\"\") is  string, because:   the second half of the string (\"\") consists of only the character '';  the first half of the string (\"\") is  string, because:   the first half of the string (\"\") consists of only the character '';  the second half of the string (\"\") is  string.   ", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the length of . It is guaranteed that  for some integer . The second line of the test case contains the string  consisting of  lowercase Latin letters. It is guaranteed that the sum of  does not exceed  ().", "output": "For each test case, print the answer \u2014 the minimum number of moves required to obtain an  string from  (i.e.  with  ''). It is guaranteed that the answer exists.", "tutorial": "Consider the problem in $$$0$$$-indexation. Define the function $$$calc(l, r, c)$$$ which finds the minimum number of changes to make the string $$$s[l \\dots r)$$$ . Let $$$mid = \\frac{l + r}{2}$$$. Then let $$$cnt_l = \\frac{r - l}{2} - count(s[l \\dots mid), c) + calc(mid, r, c + 1)$$$ and $$$cnt_r = \\frac{r - l}{2} - count(s[mid \\dots r), c) + calc(l, mid, c + 1)$$$, where $$$count(s, c)$$$ is the number of occurrences of the character $$$c$$$ in $$$s$$$. We can see that $$$cnt_l$$$ describes the second condition from the statement and $$$cnt_r$$$ describes the third one. So, $$$calc(l, r, c)$$$ returns $$$min(cnt_l, cnt_r)$$$ except one case. When $$$r - l = 1$$$, we need to return $$$1$$$ if $$$s_l \\ne c$$$ and $$$0$$$ otherwise. This function works in $$$O(n \\log n)$$$ (each element of $$$s$$$ belongs to exactly $$$\\log{n}$$$ segments, like segment tree). You can get the answer if you run $$$calc(0, n,~ 'a')$$$.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint calc(const string &s, char c) {\n\tif (s.size() == 1) {\n\t\treturn s[0] != c;\n\t}\n\tint mid = s.size() / 2;\n\tint cntl = calc(string(s.begin(), s.begin() + mid), c + 1);\n\tcntl += s.size() / 2 - count(s.begin() + mid, s.end(), c);\n\tint cntr = calc(string(s.begin() + mid, s.end()), c + 1);\n\tcntr += s.size() / 2 - count(s.begin(), s.begin() + mid, c);\n\treturn min(cntl, cntr);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tstring s;\n\t\tcin >> n >> s;\n\t\tcout << calc(s, 'a') << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}