{"link": "https://codeforces.com//contest/1607/problem/C", "problemId": "1168760", "shortId": "1607C", "contest_number": "1607", "name": "C. Minimum Extraction", "statement": "Yelisey has an array  of  integers.If  has length strictly greater than , then Yelisei can apply an operation called  to it:   First, Yelisei finds the minimal number  in the array. If there are several identical minima, Yelisey can choose any of them.  Then the selected minimal element is removed from the array. After that,  is subtracted from each remaining element. Thus, after each operation, the length of the array is reduced by .For example, if , then the minimum element in it is , which means that after this operation the array will be equal to .Since Yelisey likes big numbers, he wants the numbers in the array  to be as big as possible.Formally speaking, he wants to make the  of the numbers in array  to be  (i.e. he want to maximize a minimum). To do this, Yelisey can apply the  operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length .Help him find what maximal value can the minimal element of the array have after applying several (possibly, zero)  operations to the array.", "input": "The first line contains an integer  ()\u00a0\u2014 the number of test cases. The next  lines contain descriptions of the test cases. In the description of each test case, the first line contains an integer  ()\u00a0\u2014 the original length of the array . The second line of the description lists  space-separated integers  ()\u00a0\u2014 elements of the array . It is guaranteed that the sum of  over all test cases does not exceed .", "output": "Print  lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer\u00a0\u2014 the maximal possible minimum in , which can be obtained by several applications of the described operation to it.", "tutorial": "Note that the order of numbers in the array does not affect anything. If you swap two elements in the original array, the set of elements at each step will not change in any way. Let's sort the original array  and denote it by .We denote by  the state of array  after applying  operations of . The minimum element in  is , so the elements of array  will be equal to , and therefore the minimum of them will be .Constructing an array , we can notice that its elements are equal to . We know that the elements of  are the difference between corresponding elements of the array  and , so Thus, the elements of the array  are the differences between elements of  starting with third and , the minimum of which is . It is not difficult to show in a similar way (for example by induction) that the elements of  are equal to , the minimum of which is .So the \"candidates\" for the answer are simply differences of adjacent elements of the array . Indeed, if we look at , it will undergo changes as follows: . You can notice that the minimum elements starting with after the first operation are exactly , ,  and , respectively.Thus, to solve the problem, it was sufficient to sort the array in ascending order, then take the maximum of the original first element and the differences of all adjacent elements ", "solution": "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = sorted(list(map(int, input().split())))\n    res = a[0]\n    for i in range(n - 1):\n        res = max(res, a[i + 1] - a[i])\n    print(res)", "interactive": false, "noSolution": false, "noTutorial": false}