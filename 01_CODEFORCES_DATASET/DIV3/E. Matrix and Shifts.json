{"link": "https://codeforces.com//contest/1660/problem/E", "problemId": "1349759", "shortId": "1660E", "contest_number": "1660", "name": "E. Matrix and Shifts", "statement": "You are given a binary matrix  of size . Rows are numbered from top to bottom from  to , columns are numbered from left to right from  to . The element located at the intersection of row  and column  is called . Consider a set of  operations:  Cyclically shift all rows up. The row with index  will be written in place of the row  (), the row with index  will be written in place of the row .  Cyclically shift all rows down. The row with index  will be written in place of the row  (), the row with index  will be written in place of the row .  Cyclically shift all columns to the left. The column with index  will be written in place of the column  (), the column with index  will be written in place of the column .  Cyclically shift all columns to the right. The column with index  will be written in place of the column  (), the column with index  will be written in place of the column .      You can perform an arbitrary (possibly zero) number of operations on the matrix; the operations can be performed in any order.After that, you can perform an arbitrary (possibly zero) number of new xor-operations:  Select any element  and assign it with new value . In other words, the value of  will have to be written into element . Each application of this xor-operation costs one burl. Note that the  shift operations\u00a0\u2014 are free. These  operations can only be performed before xor-operations are performed.Output the minimum number of burles you would have to pay to make the  matrix unitary. A  is a matrix with ones on the main diagonal and the rest of its elements are zeros (that is,  if  and  otherwise).", "input": "The first line of the input contains an integer  ()\u00a0\u2014the number of test cases in the test. The descriptions of the test cases follow. Before each test case, an empty line is written in the input. The first line of each test case contains a single number  () This is followed by  lines, each containing exactly  characters and consisting only of zeros and ones. These lines describe the values in the elements of the matrix. It is guaranteed that the sum of  values over all test cases does not exceed .", "output": "For each test case, output the minimum number of burles you would have to pay to make the  matrix unitary. In other words, print the minimum number of xor-operations it will take after applying cyclic shifts to the matrix for the  matrix to become unitary.", "tutorial": "Count to the variable  the number of all ones in the matrix.Then consider pairs of diagonals, one of which starts in cell , and the other \u2014 in cell  (for ). Using cyclic shifts, we can assemble the main diagonal from this pair. Then among all such pairs (and the main diagonal), find the one that contains the maximal number of ones, and store this number in the variable .The number of zeros on the main diagonal, which should be turned into ones, is equal to .The number of ones to be turned into zeros, because they are not on the main diagonal, is calculated as .The total answer is calculated as .", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define sz(v) (int)v.size()\n#define all(v) v.begin(),v.end()\n#define eb emplace_back\n \nconst int INF = INT_MAX >> 1;\n \nvoid solve() {\n    int n; cin >> n;\n    int cnt1 = 0;\n    vector<int> cnt (n, 0);\n    for (int i = 0; i < n; i++) {\n        string s; cin >> s;\n        for (int j = 0, k = (n - i) % n; j < n; j++, k = (k + 1 == n ? 0 : k + 1)) if (s[j] == '1') {\n            cnt1++;\n            cnt[k]++;\n        }\n    }\n    int ans = INF;\n    for (int i = 0; i < sz(cnt); i++) {\n        ans = min(ans, cnt1 - cnt[i] + (n - cnt[i]));\n    }\n    cout << ans << endl;\n}\n \nint main() {\n    int t;\n    cin >> t;\n \n    forn(tt, t) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}