{"link": "https://codeforces.com//contest/1593/problem/C", "problemId": "1142163", "shortId": "1593C", "contest_number": "1593", "name": "C. Save More Mice", "statement": "There are one cat,  mice, and one hole on a coordinate line. The cat is located at the point , the hole is located at the point . All mice are located between the cat and the hole: the -th mouse is located at the point  (). At each point, many mice can be located.In one second, the following happens. First,  mouse moves to the right by . If the mouse reaches the hole, it hides (i.e. the mouse will not any more move to any point and will not be eaten by the cat). Then ( the mouse has finished its move) the cat moves to the right by . If at the new cat's position, some mice are located, the cat eats them (they will not be able to move after that). The actions are performed until any mouse hasn't been hidden or isn't eaten.In other words, the first move is made by a mouse. If the mouse has reached the hole, it's saved. Then the cat makes a move. The cat eats the mice located at the pointed the cat has reached (if the cat has reached the hole, it eats nobody).Each second, you can select a mouse that will make a move. What is the maximum number of mice that can reach the hole without being eaten?", "input": "The first line contains one integer  () \u2014 the number of test cases. Then  test cases follow. Each test case consists of two lines. The first line contains two integers  and  (, ). The second line contains  integers  () \u2014 the initial coordinates of the mice. It is guaranteed that the sum of all  given in the input doesn't exceed .", "output": "For each test case output on a separate line an integer  () \u2014 the maximum number of mice that can reach the hole without being eaten.", "tutorial": "Let's solve the problem using a linear search. Let  be the number of mice we are trying to save. Then it is more efficient to save  mice such that they are the closest ones to the hole. Let  be the distance from the -th mouse to the hole (). Denote . Let's prove that these mice will be saved if and only if .The necessary condition. Suppose we can save the mice and . Since only one mouse can be moved in one second, the following will happen:  of mice will already be saved and one mouse will have to be saved. When it's been  seconds, then the distance from the cat to the hole will be equal to , and the distance from the mouse to the hole will be equal to  (since all other mice are already in the hole, their distances to the hole are equal to , so the sum of the distances from all mice to the hole at the current time is exactly equal to the distance to the hole from one remaining mouse). Since , the distance from the mouse to the hole is greater than or equal to the distance from the cat to the hole. But this cannot be, because both the mice and the cat move only to the right, and all mice met by the cat are eaten. So, .Sufficient condition. Suppose . If , then all the mice are already in the hole, i.e. they are saved. Suppose . Let's move any mouse, then the cat. Suppose the cat ate at least one of the mice. This mouse is definitely not the one that was moved. Then the distance from it to the eaten mouse was equal to , i.e. the distance from it to the hole was equal to the distance from the eaten mouse to the hole plus . The distance from the moved mouse to the hole was at least . So, , where  is the distance from the eaten mouse to the hole,  is the distance from the moved mouse to the hole. So, , but it's false. Therefore, none of the mice will be eaten on the first move. Then the distance from the cat to the hole will be equal to , the total distance from the mice to the hole will be equal to . , i.e. now we have to solve a similar problem for smaller  and . So  will be gradually decreased to , while no mouse will be eaten. So, if , all the mice will be saved.Thus, to solve the problem, we need to find the maximum  such that the sum of the distances from the  nearest mice to the hole is less than .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\n\twhile (t--)\n\t{\n\t\tint n, k;\n\t\tcin >> n >> k;\n\n\t\tvector<int> x(k);\n\t\tfor (int i = 0; i < k; i++) cin >> x[i];\n\t\tsort(x.rbegin(), x.rend());\n\n\t\tint cnt = 0;\n\t\tlong long sum = 0;\n\n\t\twhile (cnt < x.size() && sum + n - x[cnt] < n)\n\t\t{\n\t\t\tsum += n - x[cnt++];\n\t\t}\n\n\t\tcout << cnt << '\\n';\n\t}\n\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}