{"link": "https://codeforces.com//contest/1157/problem/G", "problemId": "336210", "shortId": "1157G", "contest_number": "1157", "name": "G. Inverse of Rows and Columns", "statement": "You are given a binary matrix  of size . A binary matrix is a matrix where each element is either  or .You may perform some (possibly zero) operations with this matrix. During each operation you can inverse the row of this matrix or a column of this matrix. Formally, inverting a row is changing all values in this row to the opposite ( to ,  to ). Inverting a column is changing all values in this column to the opposite.Your task is to sort the initial matrix by some sequence of such operations. The matrix is considered  if the array  is sorted .", "input": "The first line of the input contains two integers  and  () \u2014 the number of rows and the number of columns in the matrix. The next  lines contain  integers each. The -th element in the -th line is  () \u2014 the element of  at position .", "output": "If it is impossible to obtain a  matrix, print \"\" in the first line. Otherwise print \"\" in the first line. In the second line print a string  of length . The -th character  of this string should be '' if the -th row of the matrix is inverted and '' otherwise. In the third line print a string  of length . The -th character  of this string should be '' if the -th column of the matrix is inverted and '' otherwise. If there are multiple answers, you can print any.", "tutorial": "The first observation: if we have an answer where the first row is inverted, we can inverse all rows and columns, then the matrix will remain the same, and the first row is not inverted in the new answer. So we can suppose that the first row is never inverted. Note that this will be true only for slow solution.The second observation: if we consider a sorted matrix, its first row either consists only of ''s, or has at least one '' and then all other rows consist only of ''s. This observation can be extended to the following (one user wrote a comment about it and I pinned the link to it above) which can improve time complexity of the solution a lot: in the sorted matrix either the first row consists only of ''s, or the last row consists only of ''s (the corner case is $$$n = 1$$$, but for $$$n=1$$$ we can obtain both answers).So what should we do with these observations? I will explain a slow solution, a faster solution can be obtained by mirroring one of cases of this one. Let's iterate over the number of ''s in the first row. Let it be $$$cnt$$$. Then the first $$$cnt$$$ elements of the first string should be ''s, and all others should be ''s. We can do it by inverting the columns with elements '' among first $$$cnt$$$ elements of the first row and columns with elements '' among remaining elements. So, it's case handling time!The first case (when $$$cnt < m$$$) is pretty easy. We have to check if all rows from $$$2$$$ to $$$n$$$ that they consist only of ''s or only of ''s (and if some row consists of ''s then we should invert it). If it is true then we found the answer. Otherwise the first row consists only of ''s. So we have to find the \"transitional\" row (the row with some ''s on the prefix and ''s on the suffix or vice versa). If the number of such rows among all rows from $$$2$$$ to $$$n$$$ is greater than $$$1$$$ then this configuration is bad. If the number of such rows is $$$1$$$ then let $$$idx$$$ be the index of this row. Then we should inverse all rows above it consisting only of ''s and all rows consisting only of ''s below it. And we have to check if the current row is really transitional. We know that its sum is neither $$$0$$$ nor $$$m$$$ so there is at least one '' and at least '' in it. If the first element is '' then let's inverse it. Then we just should check if this row is sorted, and if it is then we found the answer. And the last case is if there are no transitional rows in the matrix. Then we should invert all rows from $$$2$$$ to $$$n$$$ consisting only of ''s (or only of ''s, it does not matter).So, we have a solution with time complexity $$$O(n^3)$$$. Each number of ''s in the first row is processed in $$$O(n^2)$$$ and there are $$$O(n)$$$ such numbers. But we can see that if we apply the last case (when the number of '' is $$$m$$$) to the first row and then do the same, but with the last row consisting of $$$m$$$ '', we can get a solution in $$$O(n^2)$$$.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\n\nvoid invRow(vector<vector<int>> &a, int idx) {\n\tfor (int pos = 0; pos < m; ++pos) {\n\t\ta[idx][pos] ^= 1;\n\t}\n}\n\nvoid invCol(vector<vector<int>> &a, int idx) {\n\tfor (int pos = 0; pos < n; ++pos) {\n\t\ta[pos][idx] ^= 1;\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m;\n\tvector<vector<int>> a(n, vector<int>(m));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\t\n\tfor (int cnt0 = 0; cnt0 <= m; ++cnt0) {\n\t\tstring r(n, '0');\n\t\tstring c(m, '0');\n\t\tvector<vector<int>> b = a;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif ((j < cnt0 && b[0][j] == 1) || (j >= cnt0 && b[0][j] == 0)) {\n\t\t\t\tinvCol(b, j);\n\t\t\t\tc[j] = '1';\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\tif (cnt0 < m) {\n\t\t\tfor (int i = 1; i < n; ++i) {\n\t\t\t\tint sum = accumulate(b[i].begin(), b[i].end(), 0);\n\t\t\t\tif (sum != 0 && sum != m) {\n\t\t\t\t\tok = false;\n\t\t\t\t} else if (sum == 0) {\n\t\t\t\t\tinvRow(b, i);\n\t\t\t\t\tr[i] = '1';\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint idx = -1;\n\t\t\tfor (int i = 1; i < n; ++i) {\n\t\t\t\tint sum = accumulate(b[i].begin(), b[i].end(), 0);\n\t\t\t\tif (sum != 0 && sum != m) {\n\t\t\t\t\tif (idx != -1) ok = false;\n\t\t\t\t\telse idx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (idx == -1) {\n\t\t\t\tfor (int i = 1; i < n; ++i) {\n\t\t\t\t\tint sum = accumulate(b[i].begin(), b[i].end(), 0);\n\t\t\t\t\tif (sum == 0) {\n\t\t\t\t\t\tinvRow(b, i);\n\t\t\t\t\t\tr[i] = '1';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = 1; i < idx; ++i) {\n\t\t\t\t\tint sum = accumulate(b[i].begin(), b[i].end(), 0);\n\t\t\t\t\tif (sum == m) {\n\t\t\t\t\t\tinvRow(b, i);\n\t\t\t\t\t\tr[i] = '1';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (b[idx][0] == 1) {\n\t\t\t\t\tinvRow(b, idx);\n\t\t\t\t\tr[idx] = '1';\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j < m; ++j) {\n\t\t\t\t\tif (b[idx][j] < b[idx][j - 1]) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = idx + 1; i < n; ++i) {\n\t\t\t\t\tint sum = accumulate(b[i].begin(), b[i].end(), 0);\n\t\t\t\t\tif (sum == 0) {\n\t\t\t\t\t\tinvRow(b, i);\n\t\t\t\t\t\tr[i] = '1';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\tcout << \"YES\" << endl << r << endl << c << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tcout << \"NO\" << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}