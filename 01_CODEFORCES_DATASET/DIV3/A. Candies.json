{"link": "https://codeforces.com//contest/1343/problem/A", "problemId": "599887", "shortId": "1343A", "contest_number": "1343", "name": "A. Candies", "statement": "Recently Vova found  candy wrappers. He remembers that he bought  candies during the first day,  candies during the second day,  candies during the third day, ,  candies during the -th day. But there is an issue: Vova remembers neither  nor  but he is sure that  and  are positive integers and .Vova will be satisfied if you tell him  integer  so there is an integer  that . It is guaranteed that at least one solution exists. .You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The only line of the test case contains one integer  () \u2014 the number of candy wrappers Vova found. It is guaranteed that there is some positive integer  and integer  that .", "output": "Print one integer \u2014  integer value of  so there is an integer  that .", "tutorial": "Notice that $$$\\sum\\limits_{i=0}^{k-1} 2^i = 2^k - 1$$$. Thus we can replace the initial equation with the following: $$$(2^k - 1) x = n$$$. So we can iterate over all possible $$$k$$$ in range $$$[2; 29]$$$ (because $$$2^{30} - 1 > 10^9$$$) and check if $$$n$$$ is divisible by $$$2^k-1$$$. If it is then we can print $$$x = \\frac{n}{2^k-1}$$$.P.S. I know that so many participants found the formula $$$\\sum\\limits_{i=0}^{k-1} 2^i = 2^k - 1$$$ using geometric progression sum but there is the other way to understand this and it is a way more intuitive for me. Just take a look at the binary representation of numbers: we can notice that $$$2^0 = 1, 2^1 = 10, 2^2 = 100$$$ and so on. Thus $$$2^0 = 1, 2^0+2^1=11, 2^0+2^1+2^2=111$$$ and so on. And if we add one to this number consisting of $$$k$$$ ones then we get $$$2^k$$$.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int pw = 2; pw < 30; ++pw) {\n\t\t\tint val = (1 << pw) - 1;\n\t\t\tif (n % val == 0) {\n\t\t\t\tcerr << val << endl;\n\t\t\t\tcout << n / val << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}