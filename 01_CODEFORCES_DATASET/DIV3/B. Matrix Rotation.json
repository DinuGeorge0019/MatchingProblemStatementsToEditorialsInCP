{"link": "https://codeforces.com//contest/1772/problem/B", "problemId": "1699969", "shortId": "1772B", "contest_number": "1772", "name": "B. Matrix Rotation", "statement": "You have a matrix  filled with  integers. You want your matrix to become beautiful. The matrix is beautiful if the following two conditions are satisfied:  in each row, the first element is smaller than the second element;  in each column, the first element is smaller than the second element.   You can perform the following operation on the matrix any number of times: rotate it clockwise by  degrees, so the top left element shifts to the top right cell, the top right element shifts to the bottom right cell, and so on:  Determine if it is possible to make the matrix beautiful by applying zero or more operations.", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case consists of two lines. Each of those lines contains two integers \u2014 the elements of the corresponding row of the matrix. In each matrix, all four elements are distinct integers from  to .", "output": "For each test case, print  if the matrix can become beautiful, or  otherwise. You may print each letter in any case (, ,  will all be recognized as positive answer, ,  and  will all be recognized as negative answer).", "tutorial": "Sure, you can just implement the rotation operation and check all  possible ways to rotate the matrix, but it's kinda boring. The model solution does the different thing.If a matrix is beautiful, then its minimum is in the upper left corner, and its maximum is in the lower right corner (and vice versa). If you rotate it, the element from the upper left corner goes to the upper right corner, and the element from the lower right corner goes to the lower left corner \u2014 so these elements are still in the opposite corners. No matter how many times we rotate a beautiful matrix, its minimum and maximum elements will be in the opposite corners \u2014 and the opposite is true as well; if you have a  matrix with minimum and maximum elements in opposite corners, it can be rotated in such a way that it becomes beautiful.So, all we need to check is that the minimum and the maximum elements are in the opposite corners. There are many ways to do it; in my opinion, the most elegant one is to read all four elements in an array of size ; then the opposite corners of the matrix correspond either to positions  and , or to positions  and  in this array. So, we check that the sum of positions of minimum and maximum is exactly .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int t;\n    cin >> t;\n    for(int _ = 0; _ < t; _++)\n    {\n        vector<int> a(4);\n        for(int i = 0; i < 4; i++)\n            cin >> a[i];\n        int maxpos = max_element(a.begin(), a.end()) - a.begin();\n        int minpos = min_element(a.begin(), a.end()) - a.begin();\n        if(maxpos + minpos == 3)\n            puts(\"YES\");\n        else\n            puts(\"NO\");\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}