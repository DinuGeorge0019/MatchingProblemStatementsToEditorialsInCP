{"link": "https://codeforces.com//contest/999/problem/C", "problemId": "192342", "shortId": "999C", "contest_number": "999", "name": "C. Alphabetic Removals", "statement": "You are given a string  consisting of  lowercase Latin letters. Polycarp wants to remove exactly  characters () from the string . Polycarp uses the following algorithm  times:  if there is at least one letter '', remove the leftmost occurrence and stop the algorithm, otherwise go to next item;  if there is at least one letter '', remove the leftmost occurrence and stop the algorithm, otherwise go to next item;  ...  remove the leftmost occurrence of the letter '' and stop the algorithm. This algorithm removes a single letter from the string. Polycarp performs this algorithm exactly  times, thus removing exactly  characters.Help Polycarp find the resulting string.", "input": "The first line of input contains two integers  and  () \u2014 the length of the string and the number of letters Polycarp will remove. The second line contains the string  consisting of  lowercase Latin letters.", "output": "Print the string that will be obtained from  after Polycarp removes exactly  letters using the above algorithm  times. If the resulting string is empty, print nothing. It is allowed to print nothing or an empty line (line break).", "tutorial": "Let the lowercase Latin letters be indexed from  to .There are exists at least two different solutions:If  exit the program. Otherwise, count the number of occurrences of each letter  from  to . Let it be . Now, find the (alphabetically) smallest letter that will be in the resulting string. It can be done as follows: iterate over all  from  to , and if  then subtract it from , otherwise,  will be the smallest letter that will be in the resulting string. But we (possibly) need to remove some number of its leftmost occurrences. It is obvious that letters smaller than  will not appear in the resulting string. Also, the  leftmost occurrences of letter  will be removed. Now, let's iterate over all letters in string  from left to right and construct the resulting string . If the current character of  (let it be ) is smaller than , then do nothing. If  is greater than , then add it to . Otherwise . If , then decrease  by one, otherwise, add  to . The time complexity is .Another solution is the following. Let's carry the vector of pairs  where  is the -th character of  and  is its position. If we sort this vector with the standard compare function, it is easy to see that the first  elements of this vector will be removed from the input string. Then if we will sort the last  elements of this vector by its positions in the input string in increasing order, we will obtain the answer. The time complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\t\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}