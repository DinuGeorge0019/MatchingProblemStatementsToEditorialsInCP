{"link": "https://codeforces.com//contest/1560/problem/E", "problemId": "1082100", "shortId": "1560E", "contest_number": "1560", "name": "E. Polycarp and String Transformation", "statement": "Polycarp has a string . Polycarp performs the following actions until the string  is empty ( is initially an empty string):  he adds to the right to the string  the string , i.e. he does , where  is a concatenation of the strings  and ;  he selects an arbitrary letter of  and removes from  all its occurrences (). Polycarp performs this sequence of actions  in this order.Note that after Polycarp finishes the actions, the string  will be empty and the string  will be equal to some value (that is undefined and depends on the order of removing).E.g. consider =\"\" so the actions may be performed as follows:  =\"\", the letter '' is selected, then =\"\";  =\"\", the letter '' is selected, then =\"\";  =\"\", the letter '' is selected, then =\"\" (the empty string). You need to restore the initial value of the string  using only the final value of  and find the order of removing letters from .", "input": "The first line contains one integer  () \u2014 the number of test cases. Then  test cases follow. Each test case contains one string  consisting of lowercase letters of the Latin alphabet. The length of  doesn't exceed . The sum of lengths of all strings  in the test cases doesn't exceed .", "output": "For each test case output in a separate line:   , if the answer doesn't exist;  two strings separated by spaces. The first one must contain a possible initial value of . The second one must contain a sequence of letters \u2014 it's in what order one needs to remove letters from  to make the string . E.g. if the string \"\" is outputted, then, first, all occurrences of the letter '' were deleted, then all occurrences of '', and then, finally, all occurrences of ''. If there are multiple solutions, print any one. ", "tutorial": "Suppose it's given a string  for which the answer exists. Consider the last non-empty value of . Only  letter occurs in the value and the letter is the last removed letter. At the same time, the value of  is a suffix of  so the last character of  is the last removed letter. Consider the second-last non-empty value of . It contains exactly  distinct letters so that one of them is the last removed letter and the other is the second-last removed letter. The concatenation of the second-last and the last values of  is a suffix of  consisting only of the letters. Therefore, the letter which occurrence is the last of the occurrences of all letters except the last removed one is the second-last removed letter. Considering so other values, we are proving that the order of removing the letters is the order  occurrences of the letters occur in the string .Suppose  is the number of the step in which some letter was removed,  is the number of occurrences of the letter in the  value of . The letter occurs in exactly  different values of . In each of them, the letter occurs exactly  times. So the letter occurs in  exactly  times. Therefore, using the number of the step () in which the letter was removed and the number of the letter's occurrences in  (), let's calculate the number of the letter's occurrences in the string : . If  isn't completely divisible by , there's no solution.The sum of all  of all letters occurring in  is the length of the initial value of . Since the initial value is a prefix of , the possible answer is the prefix of  having the length equal to the sum of all .Before outputting the prefix, check that you can get from the supposed value of the string  the string . Checking it, you may use the algorithm from the statement. If the resulting string is equal to , the answer is correct and must be outputted, otherwise, there's no solution.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint cntsrc[26]; // don't forget to memset it but not cnt\nint* cnt = cntsrc - 'a'; // so cnt['a'] = cntsrc[0] and so on\n\npair<string, string> decrypt(string s)\n{\n\tstring order;\n\treverse(s.begin(), s.end());\n\tfor (auto c : s)\n\t{\n\t\tif (!cnt[c])\n\t\t\torder.push_back(c);\n\t\tcnt[c]++;\n\t}\n\n\tint m = order.length();\n\tint originalLength = 0;\n\tfor (int i = 0; i < m; i++)\n\t\toriginalLength += cnt[order[i]] / (m - i);\n\n\treverse(order.begin(), order.end());\n\treturn { string(s.rbegin(), s.rbegin() + originalLength), order };\n}\n\nstring encrypt(pair<string, string> p)\n{\n\tstring result = p.first;\n\n\tfor (auto c : p.second)\n\t{\n\t\tstring temp;\n\t\tfor (auto d : p.first)\n\t\t\tif (d != c)\n\t\t\t{\n\t\t\t\ttemp.push_back(d);\n\t\t\t\tresult.push_back(d);\n\t\t\t}\n\t\tp.first = temp;\n\t}\n\n\treturn result;\n}\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\n\twhile (t--)\n\t{\n\t\tmemset(cntsrc, 0, sizeof(cntsrc));\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tauto ans = decrypt(s);\n\t\tauto check = encrypt(ans);\n\n\t\tif (check == s)\n\t\t\tcout << ans.first << ' ' << ans.second << '\\n';\n\t\telse\n\t\t\tcout << \"-1\\n\";\n\t}\n\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}