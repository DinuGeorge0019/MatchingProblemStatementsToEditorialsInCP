{"link": "https://codeforces.com//contest/1108/problem/F", "problemId": "286773", "shortId": "1108F", "contest_number": "1108", "name": "F. MST Unification", "statement": "You are given an undirected weighted  graph with  vertices and  edges .The -th edge is ; the distance between vertices  and  along the edge  is  (). The graph is , i.\u2009e. for any pair of vertices, there is at least one path between them consisting only of edges of the given graph.A minimum spanning tree (MST) in case of  weights is a subset of the edges of a connected weighted undirected graph that connects all the vertices together and has minimum total cost among all such subsets (total cost is the sum of costs of chosen edges).You can modify the given graph. The only operation you can perform is the following: increase the weight of some edge by . You  increase the weight of each edge multiple (possibly, zero) times.Suppose that the initial MST cost is . Your problem is to increase weights of some edges  in such a way that the cost of MST in the obtained graph remains , but MST is  (it means that there is only one way to choose MST in the obtained graph).Your problem is to calculate the  number of operations required to do it.", "input": "The first line of the input contains two integers  and  () \u2014 the number of vertices and the number of edges in the initial graph. The next  lines contain three integers each. The -th line contains the description of the -th edge . It is denoted by three integers  and  (), where  and  are vertices connected by the -th edge and  is the weight of this edge. It is guaranteed that the given graph  (i.e. for each  from  to   and for each unordered pair of vertices  there is at most one edge connecting this pair of vertices). It is also guaranteed that the given graph is .", "output": "Print one integer \u2014 the  number of operations to unify MST of the initial graph without changing the cost of MST.", "tutorial": "The first (and the most straight-forward) approach is to construct MST with any suitable algorithm, build LCA with the maximum edge on a path with binary lifting technique and then we have to increase the answer for each edge  such that  equals to the maximum edge on a path between  and  in MST.The second (and the most pretty and easy to implement) solution is the improved Kruskal algorithm.Let's do Kruskal algorithm on the given edges. Sort them, and let's consider all edges of the same weight at once. They can be divided into two classes. The first class contains edges which connect nothing and the second class contains edges which can connect something. Let the number of edges of current weight be , edges of the current weight of the first class be  and edges with of current weight of the second class be . Okay, we can just skip the first class because it will never increase the answer. How to calculate useless edges of the second class? Let's try to merge all components connected with edges of the second class. Suppose we make  merges. Then we have to increase weights of all remaining edges by one. So we add to the answer the value  and go to the next weight.Why is this right? This is right because if the edge of the second class cannot connect anything because of the previously considered edges then the maximum on a path between endpoints of this edge equals to this edge weight. So we have to increase the weight of this edge by one. If we didn't do it we would be able to replace the edge connects these components with our edge. And it is obvious that this edge is totally useless with the weight increased by one.Time complexity is  because of edges sorting.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\nvector<int> p, rk;\n\nint getp(int v) {\n\tif (v == p[v]) return v;\n\treturn p[v] = getp(p[v]);\n}\n\nbool merge(int v, int u) {\n\tu = getp(u);\n\tv = getp(v);\n\t\n\tif (u == v) return false;\n\t\n\tif (rk[u] < rk[v]) swap(u, v);\n\t\n\trk[u] += rk[v];\n\tp[v] = u;\n\t\n\treturn true;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tios_base::sync_with_stdio(0);\n\tint n, m;\n\tcin >> n >> m;\n\t\n\tp = vector<int>(n);\n\tiota(p.begin(), p.end(), 0);\n\trk = vector<int>(n, 1);\n\t\n\tvector<pair<pair<int, int>, int>> e(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> e[i].x.x >> e[i].x.y >> e[i].y;\n\t\t--e[i].x.x;\n\t\t--e[i].x.y;\n\t}\n\t\n\tsort(e.begin(), e.end(), [](pair<pair<int, int>, int> a, pair<pair<int, int>, int> b) {\n\t\treturn a.y < b.y;\n\t});\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint j = i;\n\t\twhile (j < m && e[i].y == e[j].y) {\n\t\t\t++j;\n\t\t}\n\t\tint cnt = j - i;\n\t\tfor (int k = i; k < j; ++k) {\n\t\t\tif (getp(e[k].x.x) == getp(e[k].x.y)) {\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t\tfor (int k = i; k < j; ++k) {\n\t\t\tcnt -= merge(e[k].x.x, e[k].x.y);\n\t\t}\n\t\tans += cnt;\n\t\ti = j - 1;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}