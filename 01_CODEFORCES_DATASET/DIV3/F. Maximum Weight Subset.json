{"link": "https://codeforces.com//contest/1249/problem/F", "problemId": "447565", "shortId": "1249F", "contest_number": "1249", "name": "F. Maximum Weight Subset", "statement": "You are given a tree, which consists of  vertices. Recall that a tree is a connected undirected graph without cycles.      Vertices are numbered from  to . All vertices have weights, the weight of the vertex  is .Recall that the distance between two vertices in the tree is the number of edges on a simple path between them.Your task is to find the subset of vertices with the maximum total weight (the weight of the subset is the sum of weights of all vertices in it) such that there is no pair of vertices with the distance  or less between them in this subset.", "input": "The first line of the input contains two integers  and  () \u2014 the number of vertices in the tree and the distance restriction, respectively. The second line of the input contains  integers  (), where  is the weight of the vertex . The next  lines contain edges of the tree. Edge  is denoted by two integers  and  \u2014 the labels of vertices it connects (, ). It is guaranteed that the given edges form a tree.", "output": "Print one integer \u2014 the maximum total weight of the subset in which all pairs of vertices have distance more than .", "tutorial": "Let's solve this problem using dynamic programming on a tree. Suppose the tree is rooted and the root of the tree is . Also, let's increase  to find the subset in which any pair of vertices had distance  or greater instead of  or greater.Let  be the maximum total weight of the subset in the subtree of  if the vertex with the minimum depth we took has depth  . Then the answer is .Firstly, let's calculate this dynamic programming for all children of . Then we are ready to calculate all  for all  from  to .Let the current depth be , then there are two cases: if  then . Otherwise, let's iterate over all children of  and let  be such child of  that the vertex with the minimum depth we took is in the subtree of . Then .After we calculated all values of  for the vertex , we can notice that this is not what we wanted. The current value of  means the maximum total weight of the subset in the subtree of  if the vertex with the minimum depth we took has depth  . To fix this, let's push  to  for all depths from  to .Time complexity:  but it can be easily optimized to  using some prefix and suffix maximums.You can ask, why this is  but not  because we iterating over all vertices, then over all possible depths, and then over children of the vertex, and again over children of the vertex. But in fact, this is  because if we change the order of multiplication, we can see that we are iterating over pairs (parent, child), then over children and possible depths, and the number of such pairs is , so the complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 210;\n\nint n, k;\nvector<int> a;\nvector<vector<int>> g, dp;\n\nvoid dfs(int v, int p) {\n\tdp[v][0] = a[v];\n\tfor (auto to : g[v]) {\n\t\tif (to != p) dfs(to, v);\n\t}\n\tfor (int dep = 0; dep < N; ++dep) {\n\t\tif (dep == 0) {\n\t\t\tfor (auto to : g[v]) {\n\t\t\t\tif (to == p) continue;\n\t\t\t\tdp[v][dep] += dp[to][max(0, k - dep - 1)];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (auto to : g[v]) {\n\t\t\t\tif (to == p) continue;\n\t\t\t\tint cur = dp[to][dep - 1];\n\t\t\t\tfor (auto other : g[v]) {\n\t\t\t\t\tif (other == p || other == to) continue;\n\t\t\t\t\tcur += dp[other][max(dep - 1, k - dep - 1)];\n\t\t\t\t}\n\t\t\t\tdp[v][dep] = max(dp[v][dep], cur);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int dep = N - 1; dep > 0; --dep) {\n\t\tdp[v][dep - 1] = max(dp[v][dep - 1], dp[v][dep]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> k;\n\t++k;\n\ta = vector<int>(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tg = vector<vector<int>>(n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tdp = vector<vector<int>>(n, vector<int>(N));\n\tdfs(0, -1);\n\tcout << dp[0][0] << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}