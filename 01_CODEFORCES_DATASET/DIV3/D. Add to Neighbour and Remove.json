{"link": "https://codeforces.com//contest/1462/problem/D", "problemId": "833572", "shortId": "1462D", "contest_number": "1462", "name": "D. Add to Neighbour and Remove", "statement": "Polycarp was given an array of  of  integers. He can perform the following operation with the array  no more than  times:  Polycarp selects the index  and adds the value  to  of its neighbors. More formally, Polycarp adds the value of  to  or to  (if such a neighbor does not exist, then it is impossible to add to it).  After adding it, Polycarp removes the -th element from the  array. During this step the length of  is decreased by . The two items above together denote one single operation.For example, if Polycarp has an array , then it can perform the following sequence of operations with it:   Polycarp selects  and adds the value  to -th element: .  Polycarp selects  and adds the value  to -th element: .  Polycarp selects  and adds the value  to -th element: .  Polycarp selects  and adds the value  to -th element: . Note that Polycarp could stop performing operations at any time.Polycarp wondered how many minimum operations he would need to perform to make all the elements of  equal (i.e., he wants all  are equal to each other).", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases in the test. Then  test cases follow. The first line of each test case contains a single integer  ()\u00a0\u2014 the length of the array. The next line contains  integers  ()\u00a0\u2014 array . It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, output a single number\u00a0\u2014 the minimum number of operations that Polycarp needs to perform so that all elements of the  array are the same (equal).", "tutorial": "Let $$$k$$$\u00a0\u2014 be the number of operations performed by Polycarp. Let's see how to check if $$$k$$$ is the answer.Let's denote by $$$s$$$ the sum of numbers in the array $$$a$$$. Note that after each operation $$$s$$$ does not change. Since we know that after $$$k$$$ operations all elements must be the same and the sum of the numbers in the array does not change, then each of the remaining elements must be equal to $$$\\frac{s}{n-k}$$$.Let's check if it is possible to perform $$$k$$$ operations so that at the end all elements are equal to $$$\\frac{s}{n-k}$$$. Note that the process described in the condition is equivalent to the following process:   Choose a set of $$$n - k + 1$$$ indices $$$i_1, i_2, \\dots, i_{n-k+1}$$$ ($$$1 = i_1 < i_2 < \\dots < i_ {n - k} < i_ {n - k + 1} = n + 1$$$)\u00a0\u2014 partitions;  Create a new array $$$b$$$ of $$$n - k$$$ elements, where $$$$$$b_j = \\sum\\limits_{t=i_j}^{i_{j+1}-1} b_t$$$$$$  For example, the array $$$a$$$ of $$$8$$$ elements after $$$4$$$ operations could turn into an array $$$b = [a_1 + a_2 + a_3 + a_4, a_5, a_6 + a_7, a_8]$$$. In this case, the set of indices is $$$i = [1, 5, 6, 8, 9]$$$.   Then, to check if $$$k$$$ is the answer, it is necessary to split the $$$a$$$ array into $$$n - k$$$ subarrays, in which the sum of all elements is equal to $$$\\frac{s}{n-k}$$$. Such a check can be implemented greedily in $$$\\mathcal{O}(n)$$$. It is enough to go through the array from left to right and take an element into the current subarray until the sum in it exceeds $$$\\frac{s}{n-k}$$$.The resulting solution works in $$$\\mathcal{O}(n \\cdot \\sigma(s))$$$ or $$$\\mathcal{O}(n^2)$$$, where $$$\\sigma(s)$$$ is the number of divisors $$$s$$$.", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<ll> a(n);\n  ll sum = 0;\n  for (ll &x : a) {\n    cin >> x;\n    sum += x;\n  }\n\n  for (int i = n; i >= 1; i--) {\n    if (sum % i == 0) {\n      ll needSum = sum / i;\n      ll curSum = 0;\n      bool ok = true;\n      for (int j = 0; j < n; j++) {\n        curSum += a[j];\n        if (curSum > needSum) {\n          ok = false;\n          break;\n        } else if (curSum == needSum) {\n          curSum = 0;\n        }\n      }\n\n      if (ok) {\n        cout << n - i << endl;\n        return;\n      }\n    }\n  }\n}\n\nint main() {\n  int tests;\n  cin >> tests;\n  while (tests-- > 0) {\n    solve();\n  }\n  return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}