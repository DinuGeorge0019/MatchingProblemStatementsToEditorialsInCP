{"link": "https://codeforces.com//contest/1360/problem/H", "problemId": "629828", "shortId": "1360H", "contest_number": "1360", "name": "H. Binary Median", "statement": "Consider all binary strings of length  (). A binary string is a string that consists of the characters  and  only. For example,  is a binary string, and  is not. Obviously, there are exactly  such strings in total.The string  is lexicographically smaller than the string  (both have the same length ) if in the first position  from the left in which they differ, we have . This is exactly the way strings are compared in dictionaries and in most modern programming languages when comparing them in a standard way. For example, the string  is lexicographically smaller than the string , because the first two characters are the same, and the third character in the first string is less than that in the second.We remove from this set  ()  binary strings , each of length . Thus, the set will have  strings. Sort all strings of the resulting set in lexicographical ascending order (as in the dictionary).We number all the strings after sorting from  to . Print the string whose index is  (such an element is called ), where  is the rounding of the number down to the nearest integer.For example, if ,  and , , , then after removing the strings  and sorting, the result will take the form: , , , , . Thus, the desired median is .", "input": "The first line contains an integer  ()\u00a0\u2014 the number of test cases. Then,  test cases follow. The first line of each test case contains integers  () and  (), where  is the number of strings to remove, and  is the length of binary strings. The next  lines contain \u00a0\u2014  binary strings of length . The total length of all given binary strings in all test cases in one test does not exceed .", "output": "Print  answers to the test cases. For each test case, print a string of length \u00a0\u2014 the median of the sorted sequence of remaining strings in the corresponding test case.", "tutorial": "If we did not delete the strings, then the median would be equal to the binary notation of . After deleting  strings, the median cannot change (numerically) by more than . Let's start with the median  and each time decrease it by one if there are fewer not deleted smaller numbers than not deleted large numbers. Similarly, you need to increase the median by one, otherwise. The algorithm stops when the result is the median of the current set. All these steps will run at most  times.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ld = long double;\nusing ll = long long;\n\nvoid solve() {\n\tll m, n;\n\tcin >> n >> m;\n\tvector<ll> v(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (char c : s) {\n\t\t\tv[i] *= 2;\n\t\t\tv[i] += c - '0';\n\t\t}\n\t}\n\tll need = ((1ll << m) - n - 1) / 2 + 1;\n\tll cur = (1ll << (m - 1)) - 1;\n\twhile (true) {\n\t\tll left = cur + 1;\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tflag |= v[i] == cur;\n\t\t\tif (v[i] <= cur) {\n\t\t\t\tleft--;\n\t\t\t}\n\t\t}\n\t\tif (left == need && !flag) {\n\t\t\tstring s;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\ts += (char)(cur % 2 + '0');\n\t\t\t\tcur /= 2;\n\t\t\t}\n\t\t\treverse(s.begin(), s.end());\n\t\t\tcout << s << endl;\n\t\t\treturn;\n\t\t} else if (left < need) {\n\t\t\tcur++;\n\t\t} else {\n\t\t\tcur--;\n\t\t}\n\t}\n}\n\nint main() {\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tsolve();\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}