{"link": "https://codeforces.com//contest/1144/problem/C", "problemId": "322484", "shortId": "1144C", "contest_number": "1144", "name": "C. Two Shuffled Sequences", "statement": "Two integer sequences existed initially \u2014 one of them was  increasing, and the other one \u2014  decreasing.Strictly increasing sequence is a sequence of integers . And strictly decreasing sequence is a sequence of integers . Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing.They were merged into one sequence . After that sequence  got shuffled. For example, some of the possible resulting sequences  for an increasing sequence  and a decreasing sequence  are sequences  or .This shuffled sequence  is given in the input.Your task is to find  two suitable initial sequences. One of them should be  increasing and the other one \u2014  decreasing. Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing.If there is a contradiction in the input and it is impossible to split the given sequence  to increasing and decreasing sequences, print \"\".", "input": "The first line of the input contains one integer  () \u2014 the number of elements in . The second line of the input contains  integers  (), where  is the -th element of .", "output": "If there is a contradiction in the input and it is impossible to split the given sequence  to increasing and decreasing sequences, print \"\" in the first line. Otherwise print \"\" in the first line and  two suitable sequences. Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing. In the second line print  \u2014 the number of elements in the  sequence.  can be zero, in this case the increasing sequence is empty. In the third line print  integers  in the  order of its values () \u2014 the  sequence itself. You can keep this line empty if  (or just print the empty line). In the fourth line print  \u2014 the number of elements in the  sequence.  can be zero, in this case the decreasing sequence is empty. In the fifth line print  integers  in the  order of its values () \u2014 the  sequence itself. You can keep this line empty if  (or just print the empty line).  should be equal to  and the union of printed sequences should be a permutation of the given sequence (in case of \"\" answer).", "tutorial": "Let's count the number of occurrences of each element in the  . Because the maximum possible element is , it can be done without any data structures.Then let's check if  is greater than  for some  from  to , and if it is, then the answer is \"\", because this element should occur at least twice in one of the sequences.Now let's output the increasing sequence. The number of elements in it is the number of elements  such that . Let's iterate from left to right, print the suitable elements and decrease their .The number of elements in the decreasing sequence is just the number of elements with non-zero . So let's iterate from right to left and just print suitable elements.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> cnt(200 * 1000 + 1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++cnt[x];\n\t\tif (cnt[x] > 2) {\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tcout << \"YES\" << endl << count(cnt.begin(), cnt.end(), 2) << endl;\n\tfor (int i = 0; i <= 200 * 1000; ++i) {\n\t\tif (cnt[i] == 2) {\n\t\t\tcout << i << \" \";\n\t\t\t--cnt[i];\n\t\t}\n\t}\n\tcout << endl << count(cnt.begin(), cnt.end(), 1) << endl;\n\tfor (int i = 200 * 1000; i >= 0; --i) {\n\t\tif (cnt[i] == 1) {\n\t\t\tcout << i << \" \";\n\t\t\t--cnt[i];\n\t\t}\n\t}\n\tcout << endl;\n\t\n\tassert(count(cnt.begin(), cnt.end(), 0) == 200 * 1000 + 1);\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}