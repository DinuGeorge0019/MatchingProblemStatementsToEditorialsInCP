{"link": "https://codeforces.com//contest/1092/problem/F", "problemId": "271425", "shortId": "1092F", "contest_number": "1092", "name": "F. Tree with Maximum Cost", "statement": "You are given a tree consisting exactly of  vertices. Tree is a connected undirected graph with  edges. Each vertex  of this tree has a value  assigned to it.Let  be the distance between the vertices  and . The distance between the vertices is the number of edges on the simple path between them.Let's define the cost of the tree as the following value: firstly, let's fix some vertex of the tree. Let it be . Then the cost of the tree is .Your task is to calculate the  of the tree if you can choose  arbitrarily.", "input": "The first line contains one integer , the number of vertices in the tree (). The second line of the input contains  integers  (), where  is the value of the vertex . Each of the next  lines describes an edge of the tree. Edge  is denoted by two integers  and , the labels of vertices it connects (, ). It is guaranteed that the given edges form a tree.", "output": "Print one integer \u2014 the  of the tree if you can choose any vertex as .", "tutorial": "Firstly, let's calculate the answer (let it be ) for some fixed vertex. Let this vertex be the vertex . Just run simple  and calculate the result using the formula from the problem statement. Also let's calculate the sum of values (let the sum in the subtree of the vertex  be ) in each subtree of the given tree if its root is the vertex . It can be easily done with simple dynamic programming.And now the magic part: let's apply the technique which is called \"\" (at least we called it so). Let's maintain the correct values in subtrees at each step of our algorithm. How will values and the answer change if we will go through the edge ?The following sequence of changes will change all values correctly:   Firstly, it can be seen that  will decrease by  (because the distance to each vertex in this subtree will decrease by one);  then  will decrease by  (because we change the root of the tree) (we need this step to maintain the correct values);  then  will increase by  (because the distance to each vertex in this subtree will increase by one);  and then  will increase by  (because we change the root of the tree) (we need this step to maintain the correct values). So, we can recalculate all the values we need if we go through the edge. So now we can write another one  to try to update the answer for each vertex as a root (as the chosen vertex).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long res, ans;\n\nvector<int> a;\nvector<long long> sum;\nvector<vector<int>> g;\n\nvoid dfs(int v, int p = -1, int h = 0) {\n\tres += h * 1ll * a[v];\n\tsum[v] = a[v];\n\t\n\tfor (auto to : g[v]) {\n\t\tif (to == p) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, h + 1);\n\t\tsum[v] += sum[to];\n\t}\n}\n\nvoid go(int v, int p = -1) {\n\tans = max(ans, res);\n\t\n\tfor (auto to : g[v]) {\n\t\tif (to == p) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tres -= sum[to];\n\t\tsum[v] -= sum[to];\n\t\tres += sum[v];\n\t\tsum[to] += sum[v];\n\t\t\n\t\tgo(to, v);\n\t\t\n\t\tsum[to] -= sum[v];\n\t\tres -= sum[v];\n\t\tsum[v] += sum[to];\n\t\tres += sum[to];\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\ta = vector<int>(n);\n\tsum = vector<long long>(n);\n\tg = vector<vector<int>>(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tdfs(0);\n\tgo(0);\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}