{"link": "https://codeforces.com//contest/1157/problem/B", "problemId": "336205", "shortId": "1157B", "contest_number": "1157", "name": "B. Long Number", "statement": "You are given a long decimal number  consisting of  digits from  to . You also have a function  that maps every digit from  to  to some (possibly the same) digit from  to .You can perform the following operation : choose a non-empty  of digits in , and replace each digit  from this segment with . For example, if , , , , and you choose the segment consisting of three rightmost digits, you get  as the result.What is the maximum possible number you can obtain applying this operation no more than once?", "input": "The first line contains one integer  () \u2014 the number of digits in . The second line contains a string of  characters, denoting the number . Each character is a decimal digit from  to . The third line contains exactly  integers , , ...,  ().", "output": "Print the maximum number you can get after applying the operation described in the statement no more than once.", "tutorial": "Let's find the first digit in $$$a$$$ that becomes  greater if we replace it (obviously, if there is no such digit, then the best solution is to leave $$$a$$$ unchanged). In the optimal solution we will replace this digit and maybe some digits after this. Why is it so? It is impossible to make any of the previous digits greater (since we found the first digit that can be replaced with a greater one). Then let's analyze all digits to the right of it. We should not replace any digit with a lower digit (because it is better not to replace it and all digits to the right of it at all), but there's nothing wrong with replacing any other digits.So, the segment we need to replace begins with the first digit that can become greater after replacing (and includes this digit) and goes to the right until the first digit that becomes less after replacing (and this digit is excluded).", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint f[10];\nstring s;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tcin >> s;\n\tfor(int i = 1; i <= 9; i++)\n\t\tcin >> f[i];\n\tvector<int> diff;\n\tfor(int i = 0; i < n; i++)\n\t\tdiff.push_back(f[s[i] - '0'] - (s[i] - '0'));\n\tfor(int i = 0; i < n; i++)\n\t\tif(diff[i] > 0)\n\t\t{\n\t\t\twhile(i < n && diff[i] >= 0)\n\t\t\t{\n\t\t\t\ts[i] = char(f[s[i] - '0'] + '0');\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcout << s << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}