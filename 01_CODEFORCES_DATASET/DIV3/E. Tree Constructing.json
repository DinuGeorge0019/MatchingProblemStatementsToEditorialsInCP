{"link": "https://codeforces.com//contest/1003/problem/E", "problemId": "194985", "shortId": "1003E", "contest_number": "1003", "name": "E. Tree Constructing", "statement": "You are given three integers ,  and .Your task is to construct an undirected tree on  vertices with diameter  and degree of each vertex at most , or say that it is impossible.An undirected tree is a connected undirected graph with  edges.Diameter of a tree is the maximum length of a simple path (a path in which each vertex appears at most once) between all pairs of vertices of this tree.Degree of a vertex is the number of edges incident to this vertex (i.e. for a vertex  it is the number of edges  that belong to the tree, where  is any other vertex of a tree).", "input": "The first line of the input contains three integers ,  and  ().", "output": "If there is no tree satisfying the conditions above, print only one word \"\" (without quotes). Otherwise in the first line print \"\" (without quotes), and then print  lines describing edges of a tree satisfying the conditions above. Vertices of the tree must be numbered from  to . You can print edges and vertices connected by an edge in any order. If there are multiple answers, print any of them.1", "tutorial": "Let's construct a tree by the following algorithm: if $$$d \\ge n$$$, let's print \"\" and terminate the program. Otherwise let's keep the array $$$deg$$$ of the length $$$n$$$ which will represent degrees of vertices.The first step is to construct the diameter of the tree. Let first $$$d + 1$$$ vertices form it. Let's add $$$d$$$ edges to the answer, increase degrees of vertices corresponding to this edges, and if some vertex has degree greater than $$$k$$$, print \"\" and terminate the program.The second (and the last) step is to attach the remaining $$$n - d - 1$$$ vertices to the tree. Let's call the vertex  if its degree is less than $$$k$$$. Also let's keep all  vertices forming the diameter in some data structure which allows us to take the vertex with the minimum maximal distance to any other vertex and remove such vertices. It can be done by, for example, set of pairs ($$$dist_v, v$$$), where $$$dist_v$$$ is a maximum distance from the vertex $$$v$$$ to any other vertex. Now let's add all vertices from starting from the vertex $$$d + 1$$$ (0-indexed) to the vertex $$$n - 1$$$, let the current vertex be $$$u$$$. We get the vertex with the minimum maximal distance to any other vertex, let it be $$$v$$$. Now we increase the degree of vertices $$$u$$$ and $$$v$$$, add the edge between they, and if $$$v$$$ still be , return it to the data structure, otherwise remove it. The same with the vertex $$$u$$$ (it is obvious that its maximal distance to any other vertex will be equals $$$dist_v + 1$$$).If at any step our data structure will be empty or the minimum maximal distance will be equals $$$d$$$, the answer is \"\". Otherwise we can print the answer. See my solution to better understanding.Overall complexity: $$$O(n \\log n)$$$ or $$$O(n)$$$ (depends on implementation).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, d, k;\n\tcin >> n >> d >> k;\n\t\n\tif (d >= n) {\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tvector<int> deg(n);\n\tvector<pair<int, int>> ans;\n\tset<pair<int, int>> q;\n\t\n\tfor (int i = 0; i < d; ++i) {\n\t\t++deg[i];\n\t\t++deg[i + 1];\n\t\tif (deg[i] > k || deg[i + 1] > k) {\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tans.push_back(make_pair(i, i + 1));\n\t}\n\tfor (int i = 1; i < d; ++i)\n\t\tq.insert(make_pair(max(i, d - i), i));\n\t\n\tfor (int i = d + 1; i < n; ++i) {\n\t\twhile (!q.empty() && deg[q.begin()->second] == k)\n\t\t\tq.erase(q.begin());\n\t\tif (q.empty() || q.begin()->first == d) {\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t++deg[i];\n\t\t++deg[q.begin()->second];\n\t\tans.push_back(make_pair(i, q.begin()->second));\n\t\tq.insert(make_pair(q.begin()->first + 1, i));\n\t}\n\t\n\tassert(int(ans.size()) == n - 1);\n\tcout << \"YES\" << endl;\n\tvector<int> p(n);\n\tfor (int i = 0; i < n; i++)\n\t    p[i] = i;\n\trandom_shuffle(p.begin(), p.end());\n\tfor (int i = 0; i < n - 1; ++i)\n\t    if (rand() % 2)\n\t\t    cout << p[ans[i].first] + 1 << \" \" << p[ans[i].second] + 1 << endl;\n\t\telse\n\t\t    cout << p[ans[i].second] + 1 << \" \" << p[ans[i].first] + 1 << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}