{"link": "https://codeforces.com//contest/988/problem/E", "problemId": "186730", "shortId": "988E", "contest_number": "988", "name": "E. Divisibility by 25", "statement": "You are given an integer  from  to  without leading zeroes.In one move you can swap any two adjacent digits in the given number in such a way that the resulting number will not contain leading zeroes. In other words,  the number you have cannot contain any leading zeroes.What is the minimum number of moves you have to make to obtain a number that is divisible by ? Print  if it is impossible to obtain a number that is divisible by .", "input": "The first line contains an integer  (). It is guaranteed that the first (left) digit of the number  is not a zero.", "output": "If it is impossible to obtain a number that is divisible by , print . Otherwise print the minimum number of moves required to obtain such number. Note that you can swap only adjacent digits in the given number.", "tutorial": "Let's iterate over all pairs of digits in the number. Let the first digit in the pair be at position  and the second at position . Let's place these digits to the last two positions in the number. The first greedily goes to the last position and then the second goes to the position next to that. Now the number can contain a leading zero. Find the leftmost non-zero digit and move it to the first position. Then if the current number is divisible by  try to update the answer with the number of swaps. It is easy to show that the number of swaps is minimal in this algorithm. The only difference we can introduce is the number of times digit , digit  and the leftmost non-zero digit swap among themselves. And that is minimized. You can also notice that the order of swaps doesn't matter and you can rearrange them in such a way that no leading zero appears on any step.This solution has time complexity . You can also solve this problem with  complexity because you have to check only four options of the two last digits (, , , ). It is always optimal to choose both rightmost occurrences of the corresponding digits. You can show that even if you are required to swap the chosen ones, there will be no other pair with smaller total amount of moves.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1000 * 1000 * 1000;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tlong long n;\n\tcin >> n;\n\t\n\tstring s = to_string(n);\n\t\n\tint ans = INF;\n\t\n\tint len = s.size();\n\tfor (int i = 0; i < len; ++i) {\n\t\tfor (int j = 0; j < len; ++j) {\n\t\t\tif (i == j) continue;\n\t\t\tstring t = s;\n\t\t\tint cur = 0;\n\t\t\tfor (int k = i; k < len - 1; ++k) {\n\t\t\t\tswap(t[k], t[k + 1]);\n\t\t\t\t++cur;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int k = j - (j > i); k < len - 2; ++k) {\n\t\t\t\tswap(t[k], t[k + 1]);\n\t\t\t\t++cur;\n\t\t\t}\n\t\t\t\n\t\t\tint pos = -1;\n\t\t\tfor (int k = 0; k < len; ++k) {\n\t\t\t\tif (t[k] != '0') {\n\t\t\t\t\tpos = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int k = pos; k > 0; --k) {\n\t\t\t\tswap(t[k], t[k - 1]);\n\t\t\t\t++cur;\n\t\t\t}\n\t\t\t\n\t\t\tlong long nn = atoll(t.c_str());\n\t\t\tif (nn % 25 == 0)\n\t\t\t\tans = min(ans, cur);\n\t\t}\n\t}\n\t\n\tif (ans == INF)\n\t\tans = -1;\n\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}