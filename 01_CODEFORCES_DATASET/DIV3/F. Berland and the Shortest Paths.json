{"link": "https://codeforces.com//contest/1005/problem/F", "problemId": "196286", "shortId": "1005F", "contest_number": "1005", "name": "F. Berland and the Shortest Paths", "statement": "There are  cities in Berland. Some pairs of cities are connected by roads. All roads are bidirectional. Each road connects two different cities. There is at most one road between a pair of cities. The cities are numbered from  to .It is known that, from the capital (the city with the number ), you can reach any other city by moving along the roads.The President of Berland plans to improve the country's road network. The budget is enough to repair exactly  roads. The President plans to choose a set of  roads such that:  it is possible to travel from the capital to any other city along the  chosen roads,  if  is the number of roads needed to travel from the capital to city , moving only along the  chosen roads, then  is minimized (i.e. as minimal as possible). In other words, the set of  roads should preserve the connectivity of the country, and the sum of distances from city  to all cities should be minimized (where you can only use the  chosen roads).The president instructed the ministry to prepare  possible options to choose  roads so that both conditions above are met.Write a program that will find  possible ways to choose roads for repair. If there are fewer than  ways, then the program should output all possible valid ways to choose roads.", "input": "The first line of the input contains integers ,  and  (), where  is the number of cities in the country,  is the number of roads and  is the number of options to choose a set of roads for repair. It is guaranteed that . The following  lines describe the roads, one road per line. Each line contains two integers ,  (, ) \u2014 the numbers of the cities that the -th road connects. There is at most one road between a pair of cities. The given set of roads is such that you can reach any city from the capital.", "output": "Print  () \u2014 the number of ways to choose a set of roads for repair. Recall that you need to find  different options; if there are fewer than  of them, then you need to find all possible different valid options. In the following  lines, print the options, one per line. Print an option as a string of  characters where the -th character is equal to '' if the -th road is included in the option, and is equal to '' if the road is not included. The roads should be numbered according to their order in the input. The options can be printed in any order. All the  lines should be different. Since it is guaranteed that , the total length of all the  lines will not exceed . If there are several answers, output any of them.", "tutorial": "Use BFS to precalculate an array  \u2014 the array of the shortest path lengths from the Capital.The condition to minimize sum of distances in each tree is equal to the fact that each tree is a shortest path tree. Let's think about them as about oriented outgoing from the Capital trees. Moving along edges of such trees, you always move by shortest paths.An edge  can be included into such a tree if and only if  (since original edges are bidirectional, you should consider each of them twice: as  and as ). Let's focus only on edges for which . Call them \"red\" edges.To build a tree for each city (except the Capital) you should choose exactly one red edge finishing in this city. That's why the number of suitable trees is a product of numbers of incoming edges over all vertices (cities).But we need to find only  of such trees. Let's start from some such tree and rebuild it on each step. As initial tree you can choose the first incoming red edge into each vertex (except the City). Actually, we will do exactly increment operation for number in a mixed radix notation.To rebuild a tree iterate over vertices and if the current used red edge is not the last for the vertex, use the next and stop algorithm. Otherwise (the last red edge is used), use the first red edge for this vertex (and go to the next vertex) and continue with the next vertex. Compare this algorithm with simple increment operation for long number.\n", "solution": "int n, m, k;\ncin >> n >> m >> k;\nvector<vector<int>> g(n);\nvector<int> a(m), b(m);\nforn(i, m) {\n    cin >> a[i] >> b[i];\n    a[i]--, b[i]--;\n    g[a[i]].push_back(b[i]);\n    g[b[i]].push_back(a[i]);\n}\n\nqueue<int> q;\nq.push(0);\nvector<int> d(n, INT_MAX);\nd[0] = 0;\n\nwhile (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (int v: g[u])\n        if (d[v] == INT_MAX) {\n            d[v] = d[u] + 1;\n            q.push(v);\n        }\n}\n\nvector<vector<int>> inc(n);\nforn(i, m) {\n    if (d[a[i]] + 1 == d[b[i]])\n        inc[b[i]].push_back(i);\n    if (d[b[i]] + 1 == d[a[i]])\n        inc[a[i]].push_back(i);\n}\n\nvector<int> f(n);\nvector<string> result;\n\nforn(i, k) {\n    string s(m, '0');\n    for (int j = 1; j < n; j++)\n        s[inc[j][f[j]]] = '1';\n    result.push_back(s);\n\n    bool ok = false;\n    for (int j = 1; j < n; j++)\n        if (f[j] + 1 < inc[j].size()) {\n            ok = true;\n            f[j]++;\n            break;\n        } else\n            f[j] = 0;\n    if (!ok)\n        break;\n}\n\ncout << result.size() << endl;\nforn(i, result.size())\n    cout << result[i] << endl;", "interactive": false, "noSolution": false, "noTutorial": false}