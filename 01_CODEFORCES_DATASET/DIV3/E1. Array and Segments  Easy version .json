{"link": "https://codeforces.com//contest/1108/problem/E1", "problemId": "286771", "shortId": "1108E1", "contest_number": "1108", "name": "E1. Array and Segments  Easy version ", "statement": ".You are given an array  consisting of  integers. The value of the -th element of the array is .You are also given a set of  segments. The -th segment is , where .You can choose some subset of the given set of segments and decrease values on each of the chosen segments by one (). For example, if the initial array  and the given segments are  and  then you can choose both of them and the array will become .You have to choose some subset of the given segments () in such a way that if you apply this subset of segments to the array  and obtain the array  then the value  will be  possible.Note that .If there are multiple answers, you can print .", "input": "The first line of the input contains two integers  and  () \u2014 the length of the array  and the number of segments, respectively. The second line of the input contains  integers  (), where  is the value of the -th element of the array . The next  lines are contain two integers each. The -th of them contains two integers  and  (), where  and  are the ends of the -th segment.", "output": "In the first line of the output print one integer  \u2014 the  possible value  if  is the array obtained by applying some subset of the given segments to the array . In the second line of the output print one integer  () \u2014 the number of segments you apply. In the third line print  distinct integers  in  () \u2014 indices of segments you apply to the array  in such a way that the value  of the obtained array  is  possible. If there are multiple answers, you can print .", "tutorial": "Let's divide all segments to four classes. The first class contains segments which covers both minimum and maximum values (the answer) of the resulting array, the second class contains segments which covers only minimum value of the resulting array, the third class contains segments which covers only maximum value of the resulting array and the fourth class contains segments which covers neither maximum nor minimum of the resulting array.We can easy see that we cannot increase the answer if we apply segments of first and third classes. What is common in this two classes? Right, both of them are cover maximum value.So we can came up with the solution in  or  (depends on implementation). Let's iterate over position of the supposed maximum value and apply all segments which not cover it. It can be done in  with straight-forward implementation or in  using prefix sums. After we apply all needed segments we can try to update the answer with the value of the obtained array.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int INF = 1e9;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tvector<pair<int, int>> b(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> b[i].first >> b[i].second;\n\t\t--b[i].first;\n\t\t--b[i].second;\n\t}\n\t\n\tint ans = *max_element(a.begin(), a.end()) - *min_element(a.begin(), a.end());\n\tvector<int> res;\n\tfor (int i = 0; i < n; ++i) {\n\t\tvector<int> add(n + 1);\n\t\tvector<int> cur;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (!(b[j].first <= i && i <= b[j].second)) {\n\t\t\t\tcur.push_back(j);\n\t\t\t\tfor (int k = b[j].first; k <= b[j].second; ++k) {\n\t\t\t\t\t--add[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mn = INF, mx = -INF;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tmn = min(mn, a[j] + add[j]);\n\t\t\tmx = max(mx, a[j] + add[j]);\n\t\t}\n\t\tif (ans < mx - mn) {\n\t\t\tans = mx - mn;\n\t\t\tres = cur;\n\t\t}\n\t}\n\t\n\tcout << ans << endl << res.size() << endl;\n\tshuffle(res.begin(), res.end(), rnd);\n\tfor (auto it : res) cout << it + 1 << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}