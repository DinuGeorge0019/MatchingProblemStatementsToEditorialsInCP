{"link": "https://codeforces.com//contest/1249/problem/C2", "problemId": "447561", "shortId": "1249C2", "contest_number": "1249", "name": "C2. Good Numbers  hard version ", "statement": ".You are given a positive integer number . You really love  so you want to find the smallest  greater than or equal to .The positive integer is called  if it can be represented as a sum of  powers of  (i.e. no duplicates of powers of  are allowed).For example:   is a : ,   is a : ,   is a : ,  but  is  a : you can't represent it as a sum of distinct powers of  (),   is  a : you can't represent it as a sum of distinct powers of  (for example, the representations  are invalid),   is also  a : you can't represent it as a sum of distinct powers of  (for example, the representation  is invalid). Note, that there exist other representations of  and  as sums of powers of  but none of them consists of  powers of .For the given positive integer  find such smallest  () that  is a .You have to answer  independent queries.", "input": "The first line of the input contains one integer  () \u2014 the number of queries. Then  queries follow. The only line of the query contains one integer  ().", "output": "For each query, print such smallest integer  (where ) that  is a .", "tutorial": "Let's see the representation of  in the ternary numeral system. If it has no twos, then the answer is . Otherwise, let  be the maximum position of  in the ternary representation. Then we obviously need to replace it with  and add some power of three to the right from it. Let  be the leftmost position of  to the right from . We can add  and replace all digits from the position  to the position  with . Then the resulting number will be  because we replaced all twos with zeros and the minimum because, in fact, we added only one power of three and this power is the minimum one we could add.Time complexity is  per query.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tlong long n;\n\t\tcin >> n;\n\t\tvector<int> vals;\n\t\tint pos2 = -1;\n\t\twhile (n > 0) {\n\t\t\tvals.push_back(n % 3);\n\t\t\tif (vals.back() == 2) pos2 = int(vals.size()) - 1;\n\t\t\tn /= 3;\n\t\t}\n\t\tvals.push_back(0);\n\t\tif (pos2 != -1) {\n\t\t\tint pos0 = find(vals.begin() + pos2, vals.end(), 0) - vals.begin();\n\t\t\tvals[pos0] = 1;\n\t\t\tfor (int i = pos0 - 1; i >= 0; --i) {\n\t\t\t\tvals[i] = 0;\n\t\t\t}\n\t\t}\n\t\tlong long ans = 0;\n\t\tlong long pw = 1;\n\t\tfor (int i = 0; i < int(vals.size()); ++i) {\n\t\t\tans += pw * vals[i];\n\t\t\tpw *= 3;\n\t\t}\n\t\tif (vals.back() == 1) ans = pw / 3;\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}