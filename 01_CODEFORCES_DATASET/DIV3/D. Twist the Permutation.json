{"link": "https://codeforces.com//contest/1650/problem/D", "problemId": "1321163", "shortId": "1650D", "contest_number": "1650", "name": "D. Twist the Permutation", "statement": "Petya got an array  of numbers from  to , where .He performed  operations sequentially. In the end, he received a new state of the  array.At the -th operation, Petya chose the first  elements of the array and cyclically shifted them to the right an arbitrary number of times (elements with indexes  and more remain in their places). One cyclic shift to the right is such a transformation that the array  becomes equal to the array .For example, if  and  (that is, this is the third operation), then as a result of this operation, he could get any of these three arrays:   (makes  cyclic shifts, or any number that is divisible by );   (makes  cyclic shift, or any number that has a remainder of  when divided by );   (makes  cyclic shifts, or any number that has a remainder of  when divided by ). Let's look at an example. Let , i.e. initially . A possible scenario is described below.  : no matter how many cyclic shifts Petya makes, the array  does not change.  : let's say Petya decided to make a  cyclic shift, then the array will look like .  : let's say Petya decided to make  cyclic shift, then the array will look like .  : let's say Petya decided to make  cyclic shifts, the original array will look like .  : let's say Petya decided to make  cyclic shifts, then the array won't change.  : let's say Petya decided to make  cyclic shifts, the array will look like . You are given a final array state  after all  operations. Determine if there is a way to perform the operation that produces this result. In this case, if an answer exists, print the numbers of cyclical shifts that occurred during each of the  operations.", "input": "The first line of the input contains an integer  ()\u00a0\u2014 the number of test cases in the test. The descriptions of the test cases follow. The first line of the description of each test case contains one integer  ()\u00a0\u2014 the length of the array . The next line contains the final state of the array :  integers  () are written. All  are distinct. It is guaranteed that the sum of  values over all test cases does not exceed .", "output": "For each test case, print the answer on a separate line. Print  if the given final value  cannot be obtained by performing an arbitrary number of cyclic shifts on each operation. Otherwise, print  non-negative integers  (), where  means that during the -th operation the first  elements of the array were cyclic shifted to the right  times. If there are several possible answers, print the one where the total number of shifts is minimal (that is, the sum of  values is the smallest). If there are several such answers, print any of them.", "tutorial": "The first thing to notice\u00a0\u2014 the answer always exists. For  numbers  answer choices, as well as  permutation combinations. It remains only to restore the answer from this permutation.We will restore by performing reverse operations. On the -th () operation will be selectd the first  elements of the array and rotate them  times to the left ( elements with numbers  and more remain in their places).Where  is equal to  if , otherwise , and \u00a0\u2013 is the index of the number .Thus, for each  from right to left, performing a left cyclic shift operation, we move the number  at index .As a result, we move  numbers  times. The time complexity .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    int ans[n];\n    for (int i = n; i > 0; --i) {\n        int ind = 0;\n        for (int j = 0; j < i; ++j) {\n            ind = a[j] == i ? j : ind;\n        }\n        int b[i];\n        for (int j = 0; j < i; ++j) {\n            b[(i - 1 - ind + j) % i] = a[j];\n        }\n        for (int j = 0; j < i; ++j) {\n            a[j] = b[j];\n        }\n        ans[i - 1] = i != 1 ? (ind + 1) % i : 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        cout << ans[i] << ' ';\n    }\n    cout << '\\n';\n}\nint main() {\n    int tests;\n    cin >> tests;\n    forn(tt, tests) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}