{"link": "https://codeforces.com//contest/1234/problem/B2", "problemId": "426512", "shortId": "1234B2", "contest_number": "1234", "name": "B2. Social Network  hard version ", "statement": ".You are messaging in one of the popular social networks via your smartphone. Your smartphone can show at most  most recent conversations with your friends. Initially, the screen is empty (i.e. the number of displayed conversations equals ).Each conversation is between you and some of your friends. There is at most one conversation with any of your friends. So each conversation is uniquely defined by your friend.You (suddenly!) have the ability to see the future. You know that during the day you will receive  messages, the -th message will be received from the friend with ID  ().If you receive a message from  in the conversation which is currently displayed on the smartphone then nothing happens: the conversations of the screen do not change and do not change their order, you read the message and continue waiting for new messages.Otherwise (i.e. if there is no conversation with  on the screen):  Firstly, if the number of conversations displayed on the screen is , the last conversation (which has the position ) is removed from the screen.  Now the number of conversations on the screen is guaranteed to be less than  and the conversation with the friend  is not displayed on the screen.  The conversation with the friend  appears on the first (the topmost) position on the screen and all the other displayed conversations are shifted one position down. Your task is to find the list of conversations (in the order they are displayed on the screen) after processing all  messages.", "input": "The first line of the input contains two integers  and  ( \u2014 the number of messages and the number of conversations your smartphone can show. The second line of the input contains  integers  (), where  is the ID of the friend which sends you the -th message.", "output": "In the first line of the output print one integer  () \u2014 the number of conversations shown after receiving all  messages. In the second line print  integers , where  should be equal to the ID of the friend corresponding to the conversation displayed on the position  after receiving all  messages.", "tutorial": "The idea of this solution is the same as in the easy version, but now we need to do the same sequence of moves faster. We can notice that the smartphone screen works as a queue, so let store it as a queue! When the new message appears, we have to check if the friend with this ID is in the queue already, but we need to check it somehow fast. Let's use some logarithmic structure that stores the same information as the queue but in other order to find, add and remove elements fast. In C++ this structure is .So let's check if the current friend is in the queue, and if no, let's check if the size of the queue is . If it is so then let's remove the first element of the queue from it and the same element from the set also. Then add the current friend to the queue and to the set. After processing all messages, the reversed queue (the queue from tail to head) is the answer to the problem.Time complexity: .And don't forget that  and other standard hashmaps can work in linear time in the worst case, so you need to redefine the hash function to use them. You can read more about this issue here: https://codeforces.com/blog/entry/62393.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\t\n\tqueue<int> q;\n\tset<int> vals;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint id;\n\t\tcin >> id;\n\t\tif (!vals.count(id)) {\n\t\t\tif (int(q.size()) >= k) {\n\t\t\t\tint cur = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tvals.erase(cur);\n\t\t\t}\n\t\t\tvals.insert(id);\n\t\t\tq.push(id);\n\t\t}\n\t}\n\t\n\tvector<int> res;\n\twhile (!q.empty()) {\n\t\tres.push_back(q.front());\n\t\tq.pop();\n\t}\n\treverse(res.begin(), res.end());\n\tcout << res.size() << endl;\n\tfor (auto it : res) cout << it << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}