{"link": "https://codeforces.com//contest/1560/problem/D", "problemId": "1082099", "shortId": "1560D", "contest_number": "1560", "name": "D. Make a Power of Two", "statement": "You are given an integer . In  move, you can do one of the following actions:  erase any digit of the number (it's acceptable that the number before the operation has exactly one digit and after the operation, it is \"empty\");  add one digit . The actions may be performed in any order any number of times.Note that if, after deleting some digit from a number, it will contain leading zeroes, they will  be deleted. E.g. if you delete from the number  the digit , the result is the number  (not ).You need to perform the  number of actions to make the number any power of  (i.e. there's an integer  () such that the resulting number is equal to ). .E.g. consider . The answer is equal to . First, let's add to the right one digit  (the result will be ). Then let's erase the digit , so the result will be  which is a power of .E.g. consider . The answer is equal to . Let's erase any of the digits  three times. The result will be  which is a power of .", "input": "The first line contains one integer  () \u2014 the number of test cases. Then  test cases follow. Each test case consists of one line containing one integer  ().", "output": "For each test case, output in a separate line one integer  \u2014 the minimum number of moves to transform the number into any power of .", "tutorial": "Suppose we must turn  into some  number . In this case, we can use the following greedy algorithm. Consider the string forms \u2014  and  \u2014 of the numbers  and , respectively. Let's make a pointer  pointing at the first character of the string  and a pointer  pointing at the first character of the string . Let's initialize a variable  in which we will store a number of selected characters. Until any of the pointers points at the place that is out of the corresponding string, let's do the following procedure: if the characters to which the pointers point are equal, we will take the character (increase  by ) and move both pointers  character to the right, otherwise, the only action we must perform is to move   character to the right. The variable  will contain after the whole process the length of the longest subsequence of  equal to a prefix of , i. e. the maximum number of original characters of  that we will not erase. We must add to the resulting string all remaining characters of  to turn it into . Therefore, we must erase  digits and add  digits so the answer for this subproblem is  where  means the length of a string .Suppose we have a set  of powers of two such that it's enough to consider to get the problem's answer. The problem can be solved as follows: for each  let's calculate the answer for the subproblem described above and select the value of  as the answer.What set of powers of two we can take? Suppose the number  consists of no more than  digits. The answer for each  consisting of  digits doesn't exceed , hence we can get this value by turning the number into  in  move adding  to the right of the number, and erasing all other  digits. Suppose there's a number  such that . So it consists of no more than  digits \u2014 this value can be reached as follows: we must not erase any digit and add  digits. Therefore, if , each number  such that  consists of no more than  digits, hence .Suppose  consists of more than  digits. Then  because  according to the input format. The answer for the number doesn't exceed  \u2014 we can get this answer if we erase all  from the number to turn it into . Suppose there's a number  such that . This number can consist of no more than  digits ( digits of  plus  digits), hence .Therefore, it's enough to consider all powers of two that are less than .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll P2LIM = (ll)2e18;\n\nint solve(string s, string t)\n{\n\tint tp = 0;\n\tint sp = 0;\n\tint taken = 0;\n\n\twhile (sp < s.length() && tp < t.length())\n\t{\n\t\tif(s[sp] == t[tp])\n\t\t{\n\t\t\ttaken++;\n\t\t\ttp++;\n\t\t}\n\t\tsp++;\n\t}\n\n\treturn (int)s.length() - taken + (int)t.length() - taken;\n}\n\nvector<string> ts;\n\nint main()\n{\n\tfor (ll p2 = 1; p2 <= P2LIM; p2 *= 2)\n\t\tts.push_back(to_string(p2));\n\n\tint t;\n\tcin >> t;\n\n\twhile (t--)\n\t{\n\t\tstring n;\n\t\tcin >> n;\n\n\t\tint ans = n.length() + 1;\n\t\tfor (auto p2 : ts)\n\t\t\tans = min(ans, solve(n, p2));\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}