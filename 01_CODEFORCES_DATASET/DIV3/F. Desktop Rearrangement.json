{"link": "https://codeforces.com//contest/1674/problem/F", "problemId": "1387202", "shortId": "1674F", "contest_number": "1674", "name": "F. Desktop Rearrangement", "statement": "Your friend Ivan asked you to help him rearrange his desktop. The desktop can be represented as a rectangle matrix of size  consisting of characters '' (empty cell of the desktop) and '' (an icon).The desktop is called  if all its icons are occupying some prefix of full columns and, possibly, the prefix of the next column (and there are no icons outside this figure). In other words, some amount of first columns will be filled with icons and, possibly, some amount of first cells of the next (after the last full column) column will be also filled with icons (and all the icons on the desktop belong to this figure). This is pretty much the same as the real life icons arrangement.In one move, you can take one icon and move it to any empty cell in the desktop.Ivan loves to add some icons to his desktop and remove them from it, so he is asking you to answer  queries: what is the  number of moves required to make the desktop  after adding/removing one icon?Note that  and change the state of the desktop.", "input": "The first line of the input contains three integers ,  and  () \u2014 the number of rows in the desktop, the number of columns in the desktop and the number of queries, respectively. The next  lines contain the description of the desktop. The -th of them contains  characters '' and '' \u2014 the description of the -th row of the desktop. The next  lines describe queries. The -th of them contains two integers  and  () \u2014 the position of the cell which changes its state (if this cell contained the icon before, then this icon is removed, otherwise an icon appears in this cell).", "output": "Print  integers. The -th of them should be the  number of moves required to make the desktop  after applying the first  queries.", "tutorial": "I've seen a lot of data structures solutions for this problem, but author's solution doesn't use them and works in .Firstly, let's change our matrix to a string , because it will be easier to work with a string than with a matrix. The order of characters will be from top to bottom, from left to right (i.\u2009e. the outer cycle by columns, and the inner by rows). Then, let's calculate  \u2014 the number of icons on the desktop (the number of '' in ). Then the answer will be, obviously, the number of dots on the prefix of  of size .Now let's deal with queries. It can be shown that one query changes our answer by no more than .Let  be the position of the cell that is being changed in  (zero-indexed). Then, if , there are two cases. If  is '', then we have one more icon on our prefix, so the answer decreases by one (because we filled one empty space in the good desktop). Otherwise, it increases by one (because this icon is outside our prefix).Then let's change the corresponding character by the opposite. After that, we should move our right border () accordingly to the new number of icons. Note that this border is exclusive. If  becomes '', then we will increase the variable . But before that, if  is '', then there should be an icon, and it is not here yet, so the answer increases. Otherwise, our border will decrease. Then, if  is '', then the answer decreases (because there was a place for an icon, and now it is not needed anymore).Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstatic char buf[1010];\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n//  freopen(\"output.txt\", \"w\", stdout);\n#endif\n    \n    int n, m, q;\n    scanf(\"%d %d %d\", &n, &m, &q);\n    vector<string> tmp(n);\n    string s;\n    int sum = 0;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%s\", buf);\n        tmp[i] = buf;\n        sum += count(tmp[i].begin(), tmp[i].end(), '*');\n    }\n    \n    for (int j = 0; j < m; ++j) {\n        for (int i = 0; i < n; ++i) {\n            s += tmp[i][j];\n        }\n    }\n    int res = count(s.begin(), s.begin() + sum, '.');\n    int pos = sum;\n    for (int i = 0; i < q; ++i) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        --x, --y;\n        int p = y * n + x;\n        if (p < pos) {\n            if (s[p] == '.') {\n                --res;\n            } else {\n                ++res;\n            }\n        }\n        s[p] = (s[p] == '.' ? '*' : '.');\n        if (s[p] == '*') {\n            if (s[pos] == '.') {\n                ++res;\n            }\n            ++pos;\n        } else {\n            if (s[pos - 1] == '.') {\n                --res;\n            }\n            --pos;\n        }\n        printf(\"%d\\n\", res);\n    }\n    \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}