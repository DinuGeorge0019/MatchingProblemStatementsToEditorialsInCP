{"link": "https://codeforces.com//contest/1092/problem/D1", "problemId": "271422", "shortId": "1092D1", "contest_number": "1092", "name": "D1. Great Vova Wall  Version 1 ", "statement": "Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.The current state of the wall can be respresented by a sequence  of  integers, with  being the height of the -th part of the wall.Vova can only use  bricks to put in the wall (he has infinite supply of them, however).Vova can put bricks  on the neighboring parts of the wall of equal height. It means that if for some  the current height of part  is the same as for part , then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part  of the wall or to the right of part  of it).Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.Vova is a perfectionist, so he considers the wall completed when:  all parts of the wall has the same height;  the wall has no empty spaces inside it. Can Vova complete the wall using any amount of bricks (possibly zero)?", "input": "The first line contains a single integer  () \u2014 the number of parts in the wall. The second line contains  integers  () \u2014 the initial heights of the parts of the wall.", "output": "Print \"\" if Vova can complete the wall using any amount of bricks (possibly zero). Print \"\" otherwise.", "tutorial": "Fairly enough, solutions of both versions of the problem are pretty similar. The major difference between them are the vertical bricks. As you aren't required to minimize the total height, you can work not with the heights themselves but with their parities instead. Vertical brick now does nothing and horizontal brick changes the parity of neighbouring parts of the same parity.Now imagine the following greedy solution. While you have some segment of the same parities of even length, fill it with horizontal bricks. This operation merges this segment with one to the left and to the right. If there is a single segment left then the answer is \"\". Otherwise it's \"\". The proof is left to the readers.Implementing this as it is will be  at best. You'll need to keep the whole set of segments and the set with only even length ones.But there exists more fun approach.We don't even need the lengths of the segments \u2014 just the parities of the lengths. Then merging the even segment with something will just erase that segment and xor the length of the left and right ones. Moreover, you don't even need to erase the whole even segment, you can do it brick by brick, as this operations are now the same. Let's simulate this with a stack. When the new number comes, push its parity to the stack. If the topmost two elements of the stack have the same parity, pop them both. Now the answer is \"\" if at the end stack has no more than one element.When I heard of this problem, I actually had not that stack itself in mind but the correct bracket sequences. Like let's define parity 0 as '(' and ')' and parity 1 as '[' and ']'. Now the operations we perform with stack are \"greedily put the closing bracket if the last unclosed bracket was of the same type\" and \"put opening otherwise\". Then the stack will have like all the brackets which are still to be closed and you'll close them as early as you can. This idea helped to both prove the correctness of algo and implement it.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\nint n;\nint a[N];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n){\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i] &= 1;\n\t}\n\t\n\tvector<int> st;\n\tforn(i, n){\n\t\tif (!st.empty() && a[i] == st.back())\n\t\t\tst.pop_back();\n\t\telse\n\t\t\tst.push_back(a[i]);\n\t}\n\t\n\tputs(st.size() <= 1 ? \"YES\" : \"NO\");\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}