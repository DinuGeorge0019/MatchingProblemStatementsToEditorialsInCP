{"link": "https://codeforces.com//contest/1353/problem/F", "problemId": "620792", "shortId": "1353F", "contest_number": "1353", "name": "F. Decreasing Heights", "statement": "You are playing one famous sandbox game with the three-dimensional world. The map of the world can be represented as a matrix of size , where the height of the cell  is .You are in the cell  right now and want to get in the cell . You can move only down (from the cell  to the cell ) or right (from the cell  to the cell ). There is an additional : if the height of the current cell is  then you can move only to the cell with height . you can perform several operations. During one operation, you can decrease the height of  cell by one. I.e. you choose some cell  and assign (set) . Note that you  make heights . Also note that you  decrease the height of the cell .Your task is to find the  number of operations you have to perform to obtain at least one suitable path from the cell  to the cell . It is guaranteed that the answer exists.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains two integers  and  () \u2014 the number of rows and the number of columns in the map of the world. The next  lines contain  integers each, where the -th integer in the -th line is  () \u2014 the height of the cell . It is guaranteed that the sum of  (as well as the sum of ) over all test cases does not exceed  ().", "output": "For each test case, print the answer \u2014 the  number of operations you have to perform to obtain at least one suitable path from the cell  to the cell . It is guaranteed that the answer exists.", "tutorial": "Firstly, consider the field in -indexation. Suppose that the cell  has some fixed height. Let it be . Then we can determine what should be the height of the cell  as . In fact, it does not matter which way we choose, we actually need only the number of moves to reach the cell and the height of the cell .Then (when the height of the cell  is fixed) we can solve the problem with the following dynamic programming:  is the minimum number of operations we need to reach the cell  from the cell . Initially, all values  except . Then  can be calculated as . But one more thing: if  then this value of  is incorrect and we cannot use it. We also can't update  from the incorrect values. The answer for the problem with the fixed height of the cell  is  (only when  is correct and ). This part can be calculated in .But if we iterate over all possible heights, our solution obvious will get time limit exceeded verdict. Now we can notice one important fact: in the optimal answer, the height of some cell remains unchanged. Let this cell be . Then we can restore the height of the cell  as  and run our quadratic dynamic programming to find the answer for this height.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nconst long long INF64 = 1e18;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tvector<vector<long long>> a(n, vector<long long>(m));\n\t\tforn(i, n) forn(j, m) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t\tlong long a00 = a[0][0];\n\t\tlong long ans = INF64;\n\t\tforn(x, n) forn(y, m) {\n\t\t\tlong long need = a[x][y] - x - y;\n\t\t\tif (need > a00) continue;\n\t\t\ta[0][0] = need;\n\t\t\tvector<vector<long long>> dp(n, vector<long long>(m, INF64));\n\t\t\tdp[0][0] = a00 - need;\n\t\t\tforn(i, n) forn(j, m) {\n\t\t\t\tlong long need = a[0][0] + i + j;\n\t\t\t\tif (need > a[i][j]) continue;\n\t\t\t\tif (i > 0) dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i][j] - need);\n\t\t\t\tif (j > 0) dp[i][j] = min(dp[i][j], dp[i][j - 1] + a[i][j] - need);\n\t\t\t}\n\t\t\tans = min(ans, dp[n - 1][m - 1]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}