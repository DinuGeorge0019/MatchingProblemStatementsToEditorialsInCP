{"link": "https://codeforces.com//contest/1772/problem/G", "problemId": "1699974", "shortId": "1772G", "contest_number": "1772", "name": "G. Gaining Rating", "statement": "Monocarp is playing chess on one popular website. He has  opponents he can play with. The -th opponent has rating equal to . Monocarp's initial rating is . Monocarp wants to raise his rating to the value  ().When Monocarp is playing against one of the opponents, he will win if his  rating is bigger or equal to the opponent's rating. If Monocarp wins, his rating is increased by , otherwise it is decreased by . The rating of his opponent does not change.Monocarp wants to gain rating  playing as few games as possible. But he can't just grind it, playing against weak opponents. The website has a rule that you should play against all opponents as evenly as possible. Speaking formally, if Monocarp wants to play against an opponent , there should be no other opponent  such that Monocarp has played more games against  than against .Calculate the minimum possible number of games Monocarp needs to gain rating  or say it's impossible. Note that ratings of Monocarp's opponents  change, while Monocarp's rating does change.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains three integers ,  and  (; )\u00a0\u2014 the number of Monocarp's opponents, his initial and desired ratings. The second line contains  integers  ()\u00a0\u2014 ratings of Monocarp's opponents. Additional constraint on the input: the total sum of  over all  test cases doesn't exceed .", "output": "For each test case, print a single integer\u00a0\u2014 the minimum number of games Monocarp needs to play to gain rating , or  if it's impossible.", "tutorial": "After parsing the statement, you can understand that Monocarp plays cyclically: in one cycle, he chooses some order of opponents and play with them in that order. Then repeats again and again, until he gains desired rating at some moment.So, firstly, let's prove that (in one cycle) it's optimal to play against opponents in . Suppose you play with opponents in some order  and there is a position where , if you swap  and  you won't lose anything and may even gain extra wins. It means that the total gain after playing one cycle in increasing order in greater or equal than playing in any other order.In other words, we can sort array  and play against them cyclically in that order. Monocarp's list of games will look like several full cycles and some prefix. The problem is that there can be many cycles, and we need to skip them in a fast way.How one cycle looks? Monocarp starts with some  wins first  games and then loses all other games ( games where ). The maximum rating he gains is  and the resulting rating after all games is .We can already find several conditions of leaving a cycle: if  then Monocarp gets what he wants and stops; otherwise, if  (or ) he will never gain the desired rating, since in the next cycle the number of wins , since his starting rating .Otherwise, if  and , he will start one more cycle with rating  and will gain the desired rating , eventually. So, how to find the number of games  he will win for a starting rating ?Let's calculate two values for a given sorted skill array : for each  let's calculate \u00a0\u2014 the minimum  rating Monocarp need to win opponent  (and all opponent before) and \u00a0\u2014 the rating he'll get after winning the -th opponent.We can calculate these values in one iteration (we'll use -indexation): , ; then for each  if  then  and , otherwise  and .Now, knowing values  it's easy to find the number of wins  for a starting rating :  is equal to minimum  such that  (don't forget, -indexation). Or the first position in array  with value strictly greater than . We can search it with standard  function, since array  is sorted.Okay, we found the number of wins  for the current . Let's just calculate how many cycles  Monocarp will make with exactly  wins. There are only two conditions that should be met in order to break this cycle: either Monocarp reaches rating \u00a0\u2014 it can be written as inequality , or the number of wins increases (starting rating becomes greater or equal than ), i.e. .From the first inequality, we get minimum  and from the second one\u00a0\u2014 . As a result, we can claim that Monocarp will repeat the current cycle exactly  times and either finish in the next turn or the number of wins will change.So, we can skip these  equal cycles: we can increase answer by  and current rating by . Since we skip equal cycles, then at each step we either finish (with success or ), or the number of wins  increases. Since  is bounded by , we will make no more than  skips, and total complexity is  because of initial sorting and calls of . ", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\ntypedef long long li;\n\nint n;\nli x, y;\nvector<li> a;\n\ninline bool read() {\n    if(!(cin >> n >> x >> y))\n        return false;\n    a.resize(n);\n    fore (i, 0, n)\n        cin >> a[i];\n    return true;\n}\n\nli ceil(li a, li b) {\n    assert(a >= 0 && b >= 0);\n    return (a + b - 1) / b;\n}\n\ninline void solve() {\n    sort(a.begin(), a.end());\n    \n    vector<li> t(n), b(n);\n    fore (i, 0, n) {\n        if (i > 0 && b[i - 1] >= a[i]) {\n            t[i] = t[i - 1];\n            b[i] = b[i - 1] + 1;\n        } else {\n            t[i] = a[i] - i;\n            b[i] = a[i] + 1;\n        }\n    }\n    \n    li ans = 0;\n    while (x < y) {\n        int pos = int(upper_bound(t.begin(), t.end(), x) - t.begin());\n        \n        li p = pos, m = n - pos;\n        if (x + p >= y) {\n            cout << ans + (y - x) << endl;\n            return;\n        }\n        if (p <= m) {\n            cout << -1 << endl;\n            return;\n        }\n        \n        //1. x + k(p - m) + p >= y\n        li k = ceil(y - x - p, p - m);\n        if (pos < n) {\n            //2. x + k(p - m) >= t[pos]\n            k = min(k, ceil(t[pos] - x, p - m));\n        }\n        ans += k * n;\n        //x + k(p - m) < y, since 1. and p >= p - m\n        x += k * (p - m);\n    }\n    assert(false);\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(15);\n    \n    int t; cin >> t;\n    while (t--) {\n        read();\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}