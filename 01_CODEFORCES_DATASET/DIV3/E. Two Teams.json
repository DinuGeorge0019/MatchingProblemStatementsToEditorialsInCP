{"link": "https://codeforces.com//contest/1154/problem/E", "problemId": "331481", "shortId": "1154E", "contest_number": "1154", "name": "E. Two Teams", "statement": "There are  students standing in a row. Two coaches are forming two teams \u2014 the first coach chooses the first team and the second coach chooses the second team.The -th student has integer programming skill . All programming skills are  and between  and , inclusive.Firstly, the first coach will choose the student with maximum programming skill among all students not taken into any team,   closest students to the left of him and  closest students to the right of him (if there are less than  students to the left or to the right, all of them will be chosen). All students that are chosen leave the row and join the first team. Secondly, the second coach will make the same move (but all students chosen by him join the second team). Then again the first coach will make such move, and so on. This repeats until the row becomes empty (i.\u2009e. the process ends when each student becomes to some team).Your problem is to determine which students will be taken into the first team and which students will be taken into the second team.", "input": "The first line of the input contains two integers  and  () \u2014 the number of students and the value determining the range of chosen students during each move, respectively. The second line of the input contains  integers  (), where  is the programming skill of the -th student. It is guaranteed that all programming skills are .", "output": "Print a string of  characters; -th character should be  if -th student joins the first team, or  otherwise.", "tutorial": "Let's maintain two data structures: a queue with positions of students in order of decreasing their programming skill and a set (, note that we need exactly  set) with positions of students not taken in any team.To construct the first data structure we need to sort pairs  in decreasing order of the first element and after that push second elements in order from left to right.The second data structure can be constructed even easier \u2014 we just need to insert all values from  into it.Also let's maintain an array , where  if the -th student belongs to the first team and  otherwise, and the variable  to determine whose turn is now (initially it is ).While our set is not empty, let's repeat the following algorithm: firstly, while the head (the first element) of the queue is not in the set, pop it out. This is how we determine which student will be taken now. Let his position be . And don't forget to pop him out too. Create the additional dynamic array  which will contain all students we will add to the team during this turn.Let's find the iterator to the student with the position . Then make the following sequence of moves  times: add the element the current iterator is pointing at to the array , then if the current iterator is pointing at the first element, break the cycle, otherwise go to the iterator pointing at the previous element.Then let's find the iterator to the student next to the student with position . And then let's make almost the same sequence of moves  times: if the current iterator is pointing to the end of the set, break the cycle, otherwise add the element the current iterator is pointing at to the array  and advance to the iterator pointing at the next element.Then let's remove all values from the array  from the set, and for each student  we delete let's set . And change the variable  to  if it is  now and to  otherwise.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<pair<int, int>> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i].first;\n\t\ta[i].second = i;\n\t}\n\t\n\tsort(a.rbegin(), a.rend());\n\tqueue<int> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tq.push(a[i].second);\n\t}\n\t\n\tset<int> idx;\n\tfor (int i = 0; i < n; ++i) {\n\t\tidx.insert(i);\n\t}\n\tstring ans(n, '0');\n\tint who = 0;\n\twhile (!idx.empty()) {\n\t\twhile (!idx.count(q.front())) {\n\t\t\tq.pop();\n\t\t}\n\t\tint pos = q.front();\n\t\tq.pop();\n\t\t\n\t\tvector<int> add;\n\t\tauto it = idx.find(pos);\n\t\tfor (int i = 0; i <= k; ++i) {\n\t\t\tadd.push_back(*it);\n\t\t\tif (it == idx.begin()) break;\n\t\t\t--it;\n\t\t}\n\t\tit = next(idx.find(pos));\n\t\tfor (int i = 0; i < k; ++i) {\n\t\t\tif (it == idx.end()) break;\n\t\t\tadd.push_back(*it);\n\t\t\t++it;\n\t\t}\n\t\tfor (auto it : add) {\n\t\t\tidx.erase(it);\n\t\t\tans[it] = '1' + who;\n\t\t}\n\t\twho ^= 1;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}