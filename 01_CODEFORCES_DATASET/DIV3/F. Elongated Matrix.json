{"link": "https://codeforces.com//contest/1102/problem/F", "problemId": "280232", "shortId": "1102F", "contest_number": "1102", "name": "F. Elongated Matrix", "statement": "You are given a matrix , consisting of  rows and  columns. Each cell contains an integer in it.You can change the order of rows arbitrarily (including leaving the initial order), but you can't change the order of cells in a row. After you pick some order of rows, you traverse the whole matrix the following way: firstly visit all cells of the first column from the top row to the bottom one, then the same for the second column and so on. During the traversal you write down the sequence of the numbers on the cells in the same order you visited them. Let that sequence be . The traversal is -acceptable if for all  () .Find the maximum integer  such that there exists some order of rows of matrix  that it produces a -acceptable traversal.", "input": "The first line contains two integers  and  (, , ) \u2014 the number of rows and the number of columns, respectively. Each of the next  lines contains  integers () \u2014 the description of the matrix.", "output": "Print a single integer  \u2014 the maximum number such that there exists some order of rows of matrix  that it produces an -acceptable traversal.", "tutorial": "Really low constraints, choosing some permutation... Surely, this will be some dp on subsets!At first, let's get rid of . For each two rows calculate the minimum difference between the elements of the same columns \u2014 let's call this  for some rows , . This will be used to put row  right after row . Let's also calculate  \u2014 the minimum difference between the elements of the column  of row  and column  of row . This will be used to put row  as the last row and row  as the first one.Now let's think of choosing the permutation as choosing the traversal of the following graph. Vertices are rows and the weights of edges between the vertices are stored in . However, you can't straight up do minimum weight Hamiltonian cycle search as the edge between the first vertex and the last one should be of weight from  and not .Let's fix some starting vertex and find minimum weight Hamiltonian paths from it to all vertices. Finally, update the answer with . That will lead to  approach (minimum weight Hamiltonian path is a well-known problem solved by ).That's completely fine and it's the most intended solution.However, there exist another solution that would have worked better if the edge weight were a bit smaller.Let's do binary search, each time checking if the answer is greater or equal to . The check is simple enough. Now the graph is binary (edge exists if its weight is greater or equal to ), thus you should check for existence of Hamiltonian path, not for the minimum weight one. That can be done in , leading to  solution. The key idea of that dp is storing the vertices where the path of the current mask could have ended as a mask itself. Then it becomes  with  transitions.Overall complexity:  or .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\ntypedef long long li;\n\nconst int N = 18;\nconst int M = 100 * 1000 + 13;\nconst int INF = 1e9;\n\nint dp[1 << N][N];\n\nint n, m;\nint a[N][M];\nint mn1[N][N], mn2[N][N];\n\nint calc(int mask, int v){\n\tif (dp[mask][v] != -1)\n\t\treturn dp[mask][v];\n\tdp[mask][v] = 0;\n\tforn(u, n) if (v != u && ((mask >> u) & 1))\n\t\tdp[mask][v] = max(dp[mask][v], min(mn1[u][v], calc(mask ^ (1 << v), u)));\n\treturn dp[mask][v];\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tforn(i, n) forn(j, m)\n\t\tscanf(\"%d\", &a[i][j]);\n\t\n\tforn(i, n) forn(j, n){\n\t\tint val = INF;\n\t\tforn(k, m)\n\t\t\tval = min(val, abs(a[i][k] - a[j][k]));\n\t\tmn1[i][j] = val;\n\t\tval = INF;\n\t\tforn(k, m - 1)\n\t\t\tval = min(val, abs(a[i][k] - a[j][k + 1]));\n\t\tmn2[i][j] = val;\n\t}\n\t\n\tint ans = 0;\n\tforn(i, n){\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tforn(j, n)\n\t\t\tdp[1 << j][j] = (j == i ? INF : 0);\n\t\tforn(j, n)\n\t\t\tans = max(ans, min(mn2[j][i], calc((1 << n) - 1, j)));\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}