{"link": "https://codeforces.com//contest/1607/problem/G", "problemId": "1168764", "shortId": "1607G", "contest_number": "1607", "name": "G. Banquet Preparations 1", "statement": "A known chef has prepared  dishes: the -th dish consists of  grams of fish and  grams of meat. The banquet organizers estimate the  of  dishes as follows. The  is equal to the absolute value of the difference between the total mass of fish and the total mass of meat.Technically, the  equals to . The smaller the , the better.In order to improve the , a taster was invited. He will eat   grams of food from each dish. For each dish, the taster determines separately how much fish and how much meat he will eat. The only condition is that he should eat exactly  grams of each dish in total.Determine how much of what type of food the taster should eat from each dish so that the value of the  is as minimal as possible. If there are several correct answers, you may choose any of them.", "input": "The first line of input data contains an integer  ()\u00a0\u2014 the number of the test cases. Each test case's description is preceded by a blank line. Next comes a line that contains integers  and  (; ). The next  lines describe dishes, the -th of them contains a pair of integers  and  ()\u00a0\u2014 the masses of fish and meat in the -th dish. It is guaranteed that it is possible to eat  grams of food from each dish. In other words,  for all  from  to  inclusive. The sum of all  values over all test cases in the test does not exceed .", "output": "For each test case, print on the first line the minimal balance value that can be achieved by eating exactly  grams of food from each dish. Then print  lines that describe a way to do this: the -th line should contain two integers  and  (; ; ), where  is how many grams of fish taster should eat from the -th meal and  is how many grams of meat. If there are several ways to achieve a minimal balance, find any of them.", "tutorial": "Let's find how much meat and fish a taster can eat at most. Note that a taster can eat no more than  of fish from the -th dish (since he can't eat more than  or more than there is at all). Similarly, he can eat no more than  of meat. Let's sum the obtained values over all  and denote the resulting sums by  and \u00a0\u2014the maximum total amount of fish and meat that can be eaten.Let's denote by   the value , that is the  without module. If the taster eats as much fish as possible, he will eat  of fish and  of meat, and change the  by . Similarly, if he eats the maximum amount of meat, the  will change by . Note that the taster can achieve any  between  and  of the same oddity as both of these numbers. To do this, just take the way of eating the maximum fish and substitute eating a gram of fish for a gram of meat several times.Thus, the final   can be found as  over all  between  and  with same oddity. To do this, just check the boundaries of the resulting segment\u00a0\u2014 if they have the same sign, then it's the boundary with the smallest absolute value, otherwise we can take one of the numbers , ,  present in said set (depending on the parity of ).All that remains is to find how much of what type to eat from each dish. Having obtained the answer in the previous paragraph (the final balance), we can reconstruct how much fish and how much meat the taster has to eat to achieve it. The expected amount of fish to be eaten can be found as . Note that the taster must eat  of fish from the -th dish, since if meat , then at least  of fish is guaranteed to be eaten. Let's break down  into the sum of  (how much total fish will have to be eaten anyway) and the remaining value . Let's go through all the dishes and collect the first summand as just the sum of  over all , and the second summand with greedy algorithm, each time giving the taster as much fish beyond what he must eat anyway until the sum of such \"additions\" reaches . And knowing for each dish how much fish will be eaten from it, the amount of meat eaten can be calculated by subtracting the fish eaten from .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        vector<pii> dishes(n);\n        ll balance = 0;\n        ll max_a = 0, max_b = 0;\n        ll total_eat = static_cast<long long>(n) * m;\n\n        for (int i = 0; i < n; i++) {\n            cin >> dishes[i].first >> dishes[i].second;\n            balance += dishes[i].first - dishes[i].second;\n            max_a += min(m, dishes[i].first);\n            max_b += min(m, dishes[i].second);\n        }\n        ll max_delta = 2 * max_a - total_eat, min_delta = total_eat - 2 * max_b;\n        ll min_a = total_eat - max_b;\n\n        ll eat_a;\n        if (balance < 0) {\n            eat_a = min_a;\n            if (balance - min_delta >= 0)\n                eat_a = min(max_a, (total_eat + balance + 1) / 2);\n        } else {\n            eat_a = max_a;\n            if (balance - max_delta <= 0)\n                eat_a = min(max_a, (total_eat + balance + 1) / 2);\n        }\n        ll ans = abs(balance - 2 * eat_a + total_eat);\n\n        cout << ans << '\\n';\n        ll rest_a = eat_a - min_a;\n        for (int i = 0; i < n; i++) {\n            ll cur_a = 0;\n            if (dishes[i].second < m)\n                cur_a += m - dishes[i].second;\n            ll add = min(rest_a, min(m - cur_a, dishes[i].first - cur_a));\n            cur_a += add;\n            rest_a -= add;\n            cout << cur_a << ' ' << m - cur_a << '\\n';\n        }\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}