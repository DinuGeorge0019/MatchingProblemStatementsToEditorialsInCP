{"link": "https://codeforces.com//contest/1675/problem/F", "problemId": "1389923", "shortId": "1675F", "contest_number": "1675", "name": "F. Vlad and Unfinished Business", "statement": "Vlad and Nastya live in a city consisting of  houses and  road. From each house, you can get to the other by moving only along the roads. That is, the city is a tree.Vlad lives in a house with index , and Nastya lives in a house with index . Vlad decided to visit Nastya. However, he remembered that he had postponed for later  things that he has to do before coming to Nastya. To do the -th thing, he needs to come to the -th house, things can be done in any order. In  minute, he can walk from one house to another if they are connected by a road.Vlad does not really like walking, so he is interested what is the minimum number of minutes he has to spend on the road to do all things and then come to Nastya. Houses  he can visit in any order. He can visit any house multiple times (if he wants).", "input": "The first line of input contains an integer  () \u2014 the number of input test cases. There is an empty line before each test case. The first line of each test case contains two integers  and  () \u2014 the number of houses and things, respectively. The second line of each test case contains two integers  and  () \u2014 indices of the houses where Vlad and Nastya live, respectively. The third line of each test case contains  integers  () \u2014 indices of houses Vlad need to come to do things. The following  lines contain description of city, each line contains two integers  and  () \u2014 indices of houses connected by road . It is guaranteed that the sum of  for all cases does not exceed .", "output": "Output  lines, each of which contains the answer to the corresponding test case of input. As an answer output single integer\u00a0\u2014 the minimum number of minutes Vlad needs on the road to do all the things and come to Nastya.", "tutorial": "To begin with, we will hang the tree by the vertex . In fact, we want to go from the root to the top of , going off this path to do things and coming back. At one vertex of the path, it is advantageous to get off it in all the necessary directions and follow it further. So we will go  once for each edge leading to  and  times for each edge leading to some of the cases, but not leading to .Let's match each vertex with an edge to its ancestor. If the edge of a vertex leads to , then  is in the subtree of this vertex, similarly with vertices with cases. It is necessary for each vertex to determine whether there is a vertex  in its subtree and whether there is a vertex from the array , this can be done using a depth-first search, then we will calculate the answer according to the rules described above.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n#define ll long long\n//#define double long double\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n\nconst int MOD = 1e9 + 7;\nconst int maxN = 5e3 + 1;\nconst int INF = 2e9;\nconst int MB = 20;\n\nvector<vector<int>> g;\nvector<bool> todo, good;\n\nvoid dfs(int v, int p = -1) {\n    for (int u : g[v]) {\n        if (u != p) {\n            dfs(u, v);\n            if (todo[u]) {\n                todo[v] = true;\n            }\n            if (good[u]) {\n                good[v] = true;\n            }\n        }\n    }\n}\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    g.clear();\n    g.resize(n);\n    int x, y;\n    cin >> x >> y;\n    --x;\n    --y;\n    todo.resize(n);\n    fill(all(todo), false);\n    good.resize(n);\n    fill(all(good), false);\n    for (int i = 0; i < k; ++i) {\n        int v;\n        cin >> v;\n        --v;\n        todo[v] = true;\n    }\n    good[y] = true;\n    for (int i = 0; i < n - 1; ++i) {\n        int v, u;\n        cin >> v >> u;\n        --v;\n        --u;\n        g[v].push_back(u);\n        g[u].push_back(v);\n    }\n    dfs(x);\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i == x) {\n            continue;\n        }\n        if (good[i]) {\n            ++ans;\n        } else if (todo[i]) {\n            ans += 2;\n        }\n    }\n    cout << ans << '\\n';\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //    srand(time(0));\n    int t = 1;\n    cin >> t;\n    while (t--) solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}