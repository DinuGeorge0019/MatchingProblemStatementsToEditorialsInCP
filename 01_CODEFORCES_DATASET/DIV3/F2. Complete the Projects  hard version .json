{"link": "https://codeforces.com//contest/1203/problem/F2", "problemId": "388109", "shortId": "1203F2", "contest_number": "1203", "name": "F2. Complete the Projects  hard version ", "statement": ".Polycarp is a very famous freelancer. His current rating is  units.Some very rich customers asked him to complete some projects for their companies. To complete the -th project, Polycarp needs to have at least  units of rating; after he completes this project, his rating will change by  (his rating will increase or decrease by ) ( can be positive or negative). Polycarp's rating should not fall below zero because then people won't trust such a low rated freelancer.Polycarp can choose the order in which he completes projects. Furthermore, he can even skip some projects altogether.To gain more experience (and money, of course) Polycarp wants to choose the subset of projects  and the order in which he will complete them, so he has enough rating before starting each project, and has non-negative rating after completing each project.Your task is to calculate the maximum possible size of such subset of projects.", "input": "The first line of the input contains two integers  and  () \u2014 the number of projects and the initial rating of Polycarp, respectively. The next  lines contain projects, one per line. The -th project is represented as a pair of integers  and  (, ) \u2014 the rating required to complete the -th project and the rating change after the project completion.", "output": "Print one integer \u2014 the size of  subset (possibly, empty) of projects Polycarp can choose.", "tutorial": "To view the main idea of the problem, read the editorial of easy version. The only difference is that for non-negative  we don't need to print \"\" if we cannot take the project, we just need to skip it because we cannot take it at all. And for negative  we need to write the knapsack dynamic programming to take the maximum possible number of projects (we need to consider them in order of their sorting). Dynamic programming is pretty easy:  means that we consider  projects and our current rating is  and the value of dp is the maximum number of negative projects we can take. If the current project is the -th negative project in order of sorting, we can do two transitions:  and if  then we can make the transition . And then we just need to find the maximum value among all values of dp and add the number of positive projects we take to find the answer.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool comp(const pair<int, int>& a, const pair<int, int>& b) {\n    return a.first + a.second > b.first + b.second;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, r;\n\tcin >> n >> r;\n\tvector<pair<int, int>> pos, neg;\n\tfor (int i = 0; i < n; ++i) {\n\t\tpair<int, int> cur;\n\t\tcin >> cur.first >> cur.second;\n\t\tif (cur.second >= 0) pos.push_back(cur);\n\t\telse {\n\t\t    cur.first = max(cur.first, abs(cur.second));\n\t\t    neg.push_back(cur);\n\t\t}\n\t}\n\t\n\tsort(pos.begin(), pos.end());\n\tsort(neg.begin(), neg.end(), comp);\n\t\n\tint taken = 0;\n\tfor (int i = 0; i < int(pos.size()); ++i) {\n\t\tif (r >= pos[i].first) {\n\t\t\tr += pos[i].second;\n\t\t\t++taken;\n\t\t}\n\t}\n\t\n\tvector<vector<int>> dp(neg.size() + 1, vector<int>(r + 1, 0));\n\tdp[0][r] = taken;\n\tfor (int i = 0; i < int(neg.size()); ++i) {\n\t\tfor (int cr = 0; cr <= r; ++cr) {\n\t\t\tif (cr >= neg[i].first && cr + neg[i].second >= 0) {\n\t\t\t\tdp[i + 1][cr + neg[i].second] = max(dp[i + 1][cr + neg[i].second], dp[i][cr] + 1);\n\t\t\t}\n\t\t\tdp[i + 1][cr] = max(dp[i + 1][cr], dp[i][cr]);\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int cr = 0; cr <= r; ++cr) ans = max(ans, dp[int(neg.size())][cr]);\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}