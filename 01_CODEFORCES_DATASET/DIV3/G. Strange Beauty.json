{"link": "https://codeforces.com//contest/1475/problem/G", "problemId": "877139", "shortId": "1475G", "contest_number": "1475", "name": "G. Strange Beauty", "statement": "Polycarp found on the street an array  of  elements.Polycarp invented his criterion for the beauty of an array. He calls an array  beautiful if at least one of the following conditions must be met  :    is divisible by ;  or  is divisible by . For example, if:    and , then the  array is not beautiful (for  and , none of the conditions above is met);   and , then the  array is beautiful;   and , then the  array is not beautiful (for  and  none of the conditions above is met); Ugly arrays upset Polycarp, so he wants to remove some elements from the array  so that it becomes beautiful. Help Polycarp determine the smallest number of elements to remove to make the array  beautiful.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. Then  test cases follow. The first line of each test case contains one integer  ()\u00a0\u2014 the length of the array . The second line of each test case contains  numbers  ()\u00a0\u2014 elements of the array .", "output": "For each test case output one integer\u00a0\u2014 the minimum number of elements that must be removed to make the array  beautiful.", "tutorial": "Let's calculate for each number  how many times it occurs in the array . Let's denote this number as .Let's use the dynamic programming method. Let  be equal to the maximum number of numbers not greater than  such that for each pair of them one of the conditions above is satisfied. More formally, if , then there exists numbers  () from the array  such that for all  () one of the conditions above is satisfied.Then to calculate  you can use the following formula: .Note that to calculate  you need to go through the list of divisors of . For this, we use the sieve of Eratosthenes.", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = (int) 2e5 + 100;\n\nint dp[N];\nint cnt[N];\n\nvoid solve() {\n  int n;\n  cin >> n;\n  fill(dp, dp + N, 0);\n  fill(cnt, cnt + N, 0);\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    cnt[x]++;\n  }\n  for (int i = 1; i < N; i++) {\n    dp[i] += cnt[i];\n    for (int j = 2 * i; j < N; j += i) {\n      dp[j] = max(dp[j], dp[i]);\n    }\n  }\n  cout << (n - *max_element(dp, dp + N)) << endl;\n}\n\nint main() {\n  int test;\n  cin >> test;\n  while (test-- > 0) {\n    solve();\n  }\n  return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}