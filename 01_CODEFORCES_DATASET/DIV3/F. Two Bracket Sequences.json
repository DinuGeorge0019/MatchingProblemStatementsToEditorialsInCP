{"link": "https://codeforces.com//contest/1272/problem/F", "problemId": "494358", "shortId": "1272F", "contest_number": "1272", "name": "F. Two Bracket Sequences", "statement": "You are given two bracket sequences (not necessarily regular)  and  consisting only of characters '' and ''. You want to construct the shortest  bracket sequence that contains both given bracket sequences as  (not necessarily contiguous).Recall what is the regular bracket sequence:   is the regular bracket sequence;  if  is the regular bracket sequence, then  is a regular bracket sequence;  if  and  regular bracket sequences, then  (concatenation of  and ) is a regular bracket sequence. Recall that the subsequence of the string  is such string  that can be obtained from  by removing some (possibly, zero) amount of characters. For example, \"\", \"\", \"\" and \"\" are subsequences of \"\", but \"\" and \"\" are not.", "input": "The first line of the input contains one bracket sequence  consisting of no more than  characters '' and ''. The second line of the input contains one bracket sequence  consisting of no more than  characters '' and ''.", "output": "Print one line \u2014 the shortest  bracket sequence that contains both given bracket sequences as  (not necessarily contiguous). If there are several answers, you can print any.", "tutorial": "Firstly, notice that the length of the answer cannot exceed  ( copies of ). Now we can do some kind of simple dynamic programming. Let  be the minimum possible length of the prefix of the regular bracket sequence if we are processed first  characters of the first sequence, first  characters of the second sequence and the current balance is . Each dimension of this dp should have a size nearby .The base of this dp is , all other values .Transitions are very easy: if we want to place the opening bracket, then we increase  if the -th character of  exists and equals '', the same with the second sequence and , the balance increases by one, and the length of the answer increases by one. If we want to place the closing bracket, then we increase  if the -th character of  exists and equals '', the same with the second sequence and , the balance decreases by one, and the length of the answer increases by one. .Don't forget to maintain parents in this dp to restore the actual answer!The last problem that can be unresolved is how to write this dp? The easiest way is bfs, because every single transition increases our answer by one. Then we can restore answer from the state . You can write it recursively, but I don't sure this will look good. And you also can write it just with nested loops, if you are careful enough.Time complexity: .If you know the faster solution, please share it!", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 202;\nconst int INF = 1e9;\n\nint dp[N][N][2 * N];\npair<pair<int, int>, pair<int, char>> p[N][N][2 * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tstring s, t;\n\tcin >> s >> t;\n\tint n = s.size(), m = t.size();\n\t\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= m; ++j) {\n\t\t\tfor (int bal = 0; bal < 2 * N; ++bal) {\n\t\t\t\tdp[i][j][bal] = INF;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdp[0][0][0] = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= m; ++j) {\n\t\t\tfor (int bal = 0; bal < 2 * N; ++bal) {\n\t\t\t\tif (dp[i][j][bal] == INF) continue;\n\t\t\t\t\n\t\t\t\tint nxti = i + (i < n && s[i] == '(');\n\t\t\t\tint nxtj = j + (j < m && t[j] == '(');\n\t\t\t\tif (bal + 1 < 2 * N && dp[nxti][nxtj][bal + 1] > dp[i][j][bal] + 1) {\n\t\t\t\t\tdp[nxti][nxtj][bal + 1] = dp[i][j][bal] + 1;\n\t\t\t\t\tp[nxti][nxtj][bal + 1] = make_pair(make_pair(i, j), make_pair(bal, '('));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnxti = i + (i < n && s[i] == ')');\n\t\t\t\tnxtj = j + (j < m && t[j] == ')');\n\t\t\t\tif (bal > 0 && dp[nxti][nxtj][bal - 1] > dp[i][j][bal] + 1) {\n\t\t\t\t\tdp[nxti][nxtj][bal - 1] = dp[i][j][bal] + 1;\n\t\t\t\t\tp[nxti][nxtj][bal - 1] = make_pair(make_pair(i, j), make_pair(bal, ')'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ci = n, cj = m, cbal = 0;\n\tfor (int bal = 0; bal < 2 * N; ++bal) {\n\t\tif (dp[n][m][bal] + bal < dp[n][m][cbal] + cbal) {\n\t\t\tcbal = bal;\n\t\t}\n\t}\n\tstring res = string(cbal, ')');\n\twhile (ci > 0 || cj > 0 || cbal != 0) {\n\t\tint nci = p[ci][cj][cbal].first.first;\n\t\tint ncj = p[ci][cj][cbal].first.second;\n\t\tint ncbal = p[ci][cj][cbal].second.first;\n\t\tres += p[ci][cj][cbal].second.second;\n\t\tci = nci;\n\t\tcj = ncj;\n\t\tcbal = ncbal;\n\t}\n\treverse(res.begin(), res.end());\n\tcout << res << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}