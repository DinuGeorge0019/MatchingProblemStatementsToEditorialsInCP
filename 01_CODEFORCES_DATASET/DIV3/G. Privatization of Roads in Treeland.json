{"link": "https://codeforces.com//contest/1141/problem/G", "problemId": "316177", "shortId": "1141G", "contest_number": "1141", "name": "G. Privatization of Roads in Treeland", "statement": "Treeland consists of  cities and  roads. Each road is bidirectional and connects two distinct cities. From any city you can get to any other city by roads. Yes, you are right \u2014 the country's topology is an undirected tree.There are some private road companies in Treeland. The government decided to sell roads to the companies. Each road will belong to one company and a company can own multiple roads.The government is afraid to look unfair. They think that people in a city can consider them unfair if there is one company which owns two or more roads entering the city. The government wants to make such privatization that the number of such cities doesn't exceed  and the number of companies taking part in the privatization is minimal.Choose the number of companies  such that it is possible to assign each road to one company in such a way that the number of cities that have two or more roads of one company is at most . In other words, if for a city all the roads belong to the different companies then the city is . Your task is to find the minimal  that there is such assignment to companies from  to  that the number of cities which are not  doesn't exceed .     ", "input": "The first line contains two integers  and  () \u2014 the number of cities and the maximal number of cities which can have two or more roads belonging to one company. The following  lines contain roads, one road per line. Each line contains a pair of integers ,  (), where ,  are cities connected with the -th road.", "output": "In the first line print the required  (). In the second line print  numbers  (), where  is the company to own the -th road. If there are multiple answers, print any of them.", "tutorial": "Formally, the problem is to paint tree edges in minimal number of colors in such a way, the the number of improper vertices doesn't exceed . A vertex is improper if it has at least two incident edges of the same color.It is easy to show that  colors is always enough to paint a tree in such a way that all the vertices are proper, where  is the maximum vertex degree. Actually, it is always the truth do any bipartite graph.Indeed, if number of colors is less than the maximum degree, such vertices will have at least two edges of the same color (Dirichlet's principle). If  equals the maximum degree, you can use just depth first search tree traversal to paint edges in different colors.In this problem you can have up to  improper vertices, so just choose such minimal  that number of vertices of degree greater than  is at most . In an alternative solution, you can use a binary search to find such , but it makes the implementation harder and the solution becomes slower by  factor.After it paint edges with  colors, each time choosing the next color (skip color if it equals with the color of the traversal incoming edge).\n", "solution": "int n, k, r;\nvector<vector<pair<int,int>>> g;\nint D;\nvector<int> col;\n\nvoid dfs(int u, int p, int f) {\n    int color = 0;\n    for (auto e: g[u])\n        if (p != e.first) {\n            if (color == f) {\n                color = (color + 1) % D;\n                f = -1;\n            }\n            col[e.second] = color;\n            dfs(e.first, u, color);\n            color = (color + 1) % D;\n        }         \n}\n\nint main() {\n    cin >> n >> k;\n    g.resize(n);\n    vector<int> d(n);\n    for (int i = 0; i + 1 < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        g[x].push_back({y, i});\n        g[y].push_back({x, i});\n        d[x]++, d[y]++;\n    }\n    map<int,int> cnt;\n    for (int dd: d)\n        cnt[dd]++;\n    \n    int kk = n;\n    D = 0;\n    for (auto p: cnt)\n        if (kk > k)\n            D = p.first,\n            kk -= p.second;\n        else\n            break;\n    col = vector<int>(n - 1);\n    dfs(0, -1, -1);    \n    cout << D << endl;\n    for (int i = 0; i + 1 < n; i++)\n        cout << col[i] + 1 << \" \";\n}", "interactive": false, "noSolution": false, "noTutorial": false}