{"link": "https://codeforces.com//contest/1560/problem/F1", "problemId": "1082101", "shortId": "1560F1", "contest_number": "1560", "name": "F1. Nearest Beautiful Number  easy version ", "statement": "You are given an integer . Find the minimum integer  such that  and the number  is -.A number is called - if its decimal representation having no leading zeroes contains no more than  different digits. E.g. if , the numbers , ,  and  are - whereas the numbers ,  and  are not.", "input": "The first line contains one integer  () \u2014 the number of test cases. Then  test cases follow. Each test case consists of one line containing two integers  and  (, ).", "output": "For each test case output on a separate line  \u2014 the minimum - integer such that .", "tutorial": "Suppose the number  contains  digits. The desired number  isn't greater than the number consisting of  digits . This number is -beautiful whereas any -beautiful number is at the same time -beautiful, so  contains at most  digits. At the same time,  so  contains at least  digits. Therefore, the desired number contains exactly  digits.Suppose . There are exactly  -beautiful numbers containing exactly  digits. To get the answer fast, it's possible to consider all these numbers.Suppose . If  is already -beautiful, let's output it. Otherwise, let's initialize the answer by the value as if . Let's iterate two digits  and  such that . Let's search for the answer by considering the strings consisting only of digits  and . Let's iterate a prefix of  starting from the empty one so that the prefix will be the prefix of . This prefix must contain only the digits  and . Consider the leftmost digit that doesn't belong to the prefix. Let's try to increase it. If the digit is less than , a possible answer is a number such that it has the considered prefix and all other digits are equal to . Let's update the answer by this number (i.e. if the found number is less than the best previously found answer, let's set the answer to the found number). If the considered digit is at least  and is less than , let's update the answer by the number such that it has the considered prefix, the digit  follows the prefix, and all other digits are equal to .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring solve1(string n)\n{\n\tstring res(n.length(), '9');\n\tfor (char c = '8'; c >= '0'; c--)\n\t{\n\t\tstring t(n.length(), c);\n\t\tif (t >= n)\n\t\t\tres = t;\n\t}\n\n\treturn res;\n}\n\nstring solve2(string n)\n{\n\tstring res = solve1(n);\n\n\tfor(char a = '0'; a <= '9'; a++)\n\t\tfor (char b = a + 1; b <= '9'; b++)\n\t\t{\n\t\t\tbool n_ok = true;\n\t\t\tfor (int i = 0; i < n.length(); i++)\n\t\t\t{\n\t\t\t\tif (n[i] < b)\n\t\t\t\t{\n\t\t\t\t\tstring t = n;\n\t\t\t\t\tif (t[i] < a) t[i] = a;\n\t\t\t\t\telse t[i] = b;\n\t\t\t\t\tfor (int j = i + 1; j < n.length(); j++)\n\t\t\t\t\t\tt[j] = a;\n\t\t\t\t\tif (res > t)\n\t\t\t\t\t\tres = t;\n\t\t\t\t}\n\n\t\t\t\tif(n[i] != a && n[i] != b)\n\t\t\t\t{\n\t\t\t\t\tn_ok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (n_ok) return n;\n\t\t}\n\n\treturn res;\n}\n\nstring solve()\n{\n\tstring n;\n\tint k;\n\tcin >> n >> k;\n\n\tif (k == 1) return solve1(n);\n\telse return solve2(n);\n}\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\n\twhile (t--)\n\t\tcout << solve() << '\\n';\n\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}