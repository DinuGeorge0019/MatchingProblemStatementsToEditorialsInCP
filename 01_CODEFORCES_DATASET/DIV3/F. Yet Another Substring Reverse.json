{"link": "https://codeforces.com//contest/1234/problem/F", "problemId": "426516", "shortId": "1234F", "contest_number": "1234", "name": "F. Yet Another Substring Reverse", "statement": "You are given a string  consisting only of first  lowercase Latin letters ('', '', ..., '').Recall that the substring  of the string  is the string . For example, the substrings of \"\" are \"\", \"\", \"\", \"\", but not \"\" and \"\".You can perform the following operation : choose some substring  and  it (i.e. the string  becomes ).Your goal is to maximize the length of the maximum substring of  consisting of  (i.e. unique) characters.The string consists of  characters if no character in this string appears more than once. For example, strings \"\", \"\" and \"\" consist of distinct characters but strings \"\", \"\" do not consist of distinct characters.", "input": "The only line of the input contains one string  consisting of no more than  characters '', '', ..., '' (first  lowercase Latin letters).", "output": "Print one integer \u2014 the maximum possible length of the maximum substring of  consisting of distinct characters after reversing no more than one its substring.", "tutorial": "First of all, I wanted to offer you one little challenge: I found a solution that I can't break (and I don't sure if it can be broken) and I will be so happy if anyone will give me countertest which will break it. You can see its code below.Let's notice that we can reduce our problem to the following: find two substrings of the given string that letters in them do not intersect and the total length of these substrings is the maximum possible. Why can we make such a reduction? It is so because our answer consists of at most two non-intersecting parts: one fixed substring and at most one substring that we appended to the first one. We can always append any other substring to the first one by one reverse operation (just look at some examples to understand it).Let's iterate over all possible substrings of length at most $$$AL$$$ (where $$$AL$$$ is the size of the alphabet) which contain distinct letters. We can do it in $$$O(n AL)$$$. Let the current substring containing distinct letters be $$$s[i; j]$$$. Let's create the bitmask corresponding to this substring: the bit $$$pos$$$ is $$$1$$$ if the $$$pos$$$-th letter of the alphabet is presented in the substring and $$$0$$$ otherwise (letters are ).Store all these masks somewhere. Notice that our current problem can be reduced to the following: we have the set of masks and we need to find a pair of masks that they do not intersect and their total number of ones in them is the maximum possible. This reduction is less obvious than the previous one but you also can understand it considering some examples.So how to solve this problem? We can do it with easy bitmasks dynamic programming! Let $$$dp_{mask}$$$ be the maximum number of ones in some mask that is presented in the given string and it is the submask of $$$mask$$$. How to calculate this dynamic programming? First of all, all values $$$dp_{mask}$$$ for all masks presented in the string are equal to the number of ones in corresponding masks. Let's iterate over all masks from $$$0$$$ to $$$2^{AL} - 1$$$. Let the current mask be $$$mask$$$. Then let's try to update the answer for this mask with the answer for one of its submasks. It is obvious that because of dynamic programming we need to remove at most one bit from our mask to cover all possible submasks that can update our answer. So let's iterate over all bits in $$$mask$$$, let the current bit be $$$pos$$$. If this bit is zero then just skip it. Otherwise update $$$dp_{mask} := max(dp_{mask}, dp_{mask \\hat{} 2^{pos}})$$$, where $$$\\hat{}$$$ is the  operation.After calculating this dynamic programming we can finally calculate the answer. Let's iterate over all masks presented in the string, let the current mask be $$$mask$$$. We can update the answer with the number of ones in $$$mask$$$ plus $$$dp_{mask \\hat{} (2^{AL} - 1)}$$$ ($$$mask \\hat{} (2^{AL} - 1)$$$ is the completion of $$$mask$$$).Total complexity: $$$O(n AL + AL 2^{AL})$$$.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tstring s;\n\tcin >> s;\n\t\n\tvector<int> dp(1 << 20);\n\tfor (int i = 0; i < int(s.size()); ++i) {\n\t\tvector<bool> used(20);\n\t\tint mask = 0;\n\t\tfor (int j = 0; i + j < int(s.size()); ++j) {\n\t\t\tif (used[s[i + j] - 'a']) break;\n\t\t\tused[s[i + j] - 'a'] = true;\n\t\t\tmask |= 1 << (s[i + j] - 'a');\n\t\t\tdp[mask] = __builtin_popcount(mask);\n\t\t}\n\t}\n\t\n\tfor (int mask = 0; mask < (1 << 20); ++mask) {\n\t\tfor (int pos = 0; pos < 20; ++pos) {\n\t\t\tif ((mask >> pos) & 1) {\n\t\t\t\tdp[mask] = max(dp[mask], dp[mask ^ (1 << pos)]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < (1 << 20); ++mask) {\n\t\tif (dp[mask] == __builtin_popcount(mask)) {\n\t\t\tint comp = ~mask & ((1 << 20) - 1);\n\t\t\tans = max(ans, dp[mask] + dp[comp]);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}