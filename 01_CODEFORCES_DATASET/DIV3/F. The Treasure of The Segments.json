{"link": "https://codeforces.com//contest/1462/problem/F", "problemId": "833575", "shortId": "1462F", "contest_number": "1462", "name": "F. The Treasure of The Segments", "statement": "Polycarp found  segments on the street. A segment with the index  is described by two integers  and \u00a0\u2014 coordinates of the beginning and end of the segment, respectively. Polycarp realized that he didn't need all the segments, so he wanted to delete some of them.Polycarp believes that a set of  segments is good if there is a segment  () from the set, such that it intersects every segment from the set (the intersection must be a ). For example, a set of  segments  is good, since the segment  intersects each segment from the set. Set of  segments  is not good.Polycarp wonders, what is the minimum number of segments he has to delete so that the remaining segments form a good set?", "input": "The first line contains a single integer  ()\u00a0\u2014 number of test cases. Then  test cases follow. The first line of each test case contains a single integer  ()\u00a0\u2014 the number of segments. This is followed by  lines describing the segments. Each segment is described by two integers  and  ()\u00a0\u2014 coordinates of the beginning and end of the segment, respectively. It is guaranteed that the sum of  for all test cases does not exceed .", "output": "For each test case, output a single integer\u00a0\u2014 the minimum number of segments that need to be deleted in order for the set of remaining segments to become good.", "tutorial": "As we know from the problem statement:Polycarp believes that a set of $$$k$$$ segments is good if there is a segment $$$[l_i, r_i]$$$ ($$$1 \\leq i \\leq k$$$) from the set, such that it intersects every segment from the set (the intersection must be a ).Let's iterate over this segment (which intersects all the others) and construct a good set of the remaining segments, maximum in terms of inclusion. It is easy to understand that this set will include all segments that intersect with ours. We must delete all other segments.Two segments $$$[l_1, r_1]$$$ and $$$[l_2, r_2]$$$ intersect if $$$max(l_1, l_2) \\le min(r_1, r_2)$$$. Then if the segment that we iterate over has coordinates $$$[L, R]$$$, then we must remove all such segments $$$[l, r]$$$ for which $$$r < L$$$ or $$$R < l$$$ is satisfied (that is, the segment ends earlier than ours begins, or vice versa).Note that these two conditions cannot be fulfilled simultaneously, since $$$l \\le r$$$, and if both conditions are satisfied, then $$$r < L \\le R < l$$$. This means that we can count the number of segments suitable for these conditions independently.Each of these conditions is easy to handle. Let's create two arrays\u00a0\u2014 all the left boundaries of the segments and all the right boundaries of the segments. Let's sort both arrays. Now we can count the required quantities using the binary search or prefix sums (but in this case, we need to use the coordinate compression technique).Taking at least the number of deleted segments among all the options, we will get the answer to the problem.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nvoid solve() {\n    vector<int> L;\n    vector<int> R;\n    int n;\n    cin >> n;\n    vector<pair<int, int>> v(n);\n    for (auto &[l, r] : v) {\n        cin >> l >> r;\n        L.push_back(l);\n        R.push_back(r);\n    }\n    sort(L.begin(), L.end());\n    sort(R.begin(), R.end());\n    int ans = n - 1;\n    for (auto [l, r] : v) {\n        int left = lower_bound(R.begin(), R.end(), l) - R.begin();\n        int right = max(0, n - (int)(upper_bound(L.begin(), L.end(), r) - L.begin()));\n        ans = min(ans, left + right);\n    }\n    cout << ans << \"\\n\";\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}\n\n", "interactive": false, "noSolution": false, "noTutorial": false}