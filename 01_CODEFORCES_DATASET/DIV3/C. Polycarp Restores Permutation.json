{"link": "https://codeforces.com//contest/1141/problem/C", "problemId": "316173", "shortId": "1141C", "contest_number": "1141", "name": "C. Polycarp Restores Permutation", "statement": "An array of integers  is called a  if it contains each number from  to  exactly once. For example, the following arrays are permutations: , ,  and . The following arrays are  permutations: , , .Polycarp invented a really cool permutation  of length . It is very disappointing, but he forgot this permutation. He only remembers the array  of length , where .Given  and , help Polycarp restore the invented permutation.", "input": "The first line contains the integer  () \u2014 the length of the permutation to restore. The second line contains  integers  ().", "output": "Print the integer  if there is no such permutation of length  which corresponds to the given array . Otherwise, if it exists, print . Print any such permutation if there are many of them.", "tutorial": "Let's . Thus, =, =, ..., =.It means that the sequence of  partial sums  is the required permutation if we do  to each element. The value of  is unknown yet.Find such  that  is minimum. Thus, . Exactly this value will change  to be  after you add . So, add  to each element of  and check that now it is a permutation.Probably, you need to use  to avoid possible integer overflows.\n", "solution": "int n;\ncin >> n;\nvector<int> q(n - 1);\nlong long sum = 0;\nlong long min_val = 0;\nfor (int i = 0; i + 1 < n; i++) {\n    cin >> q[i];\n    sum += q[i];\n    if (sum < min_val)\n        min_val = sum;\n}\nvector<long long> p(n);\np[0] = 1 - min_val;\nforn(i, n - 1)\n    p[i + 1] = p[i] + q[i];\nbool ok = true;\nfor (int i = 0; i < n; i++)\n    if (p[i] < 1 || p[i] > n)\n        ok = false;\nif (ok)\n    ok = set<long long>(p.begin(), p.end()).size() == n;\nif (ok) {\n    forn(i, n)\n        cout << p[i] << \" \";\n} else\n    cout << -1 << endl;", "interactive": false, "noSolution": false, "noTutorial": false}