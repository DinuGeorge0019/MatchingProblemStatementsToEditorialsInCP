{"link": "https://codeforces.com//contest/1744/problem/E2", "problemId": "1588811", "shortId": "1744E2", "contest_number": "1744", "name": "E2. Divisible Numbers  hard version ", "statement": "You are given  positive integers , , ,  with  and . Find any pair of numbers  and  that satisfies the following conditions: , ,  is divisible by .Note that required  and  may not exist.", "input": "The first line of the input contains a single integer  ), the number of test cases. The descriptions of the test cases follow. The only line of each test case contains four integers , ,  and  (, ).", "output": "For each test case print a pair of numbers  and  such that  is divisible by . If there are multiple answers, print any of them. If there is no such pair of numbers, then print .", "tutorial": "Let's look at the slow solution first, which will lead us to the full one. Let's iterate over the number  from  to .Given a number , we want to find a  from  to  such that  is divisible by . Since  must be divisible by , the following conclusion can be drawn:  must be divisible by . Let's denote this number as . Now our task is to check if there is a multiple of  between  and . The problem can be solved in many ways, you can simply consider the largest multiple of  that does not exceed \u00a0\u2014 it is equal to  We compare this number with , and if it matches, then we have found a suitable pair.Now let's note that we do not need to iterate over all the values \u200b\u200bof , because from the number  we are only interested in \u00a0\u2014 and this is one of the divisors of !Even though the product  can be large, we can still consider all divisors of this number, since  and  themselves are up to . Let's find the divisors of  and  separately, then notice that any divisor of \u00a0\u2014 is , where \u00a0\u2014 is some divisor , and \u00a0\u2014 is some divisor .Let's calculate the running time. We need to factorize the numbers  and  into prime factors, this can be done in . Next, you need to iterate over pairs of divisors  and . Recall the estimate for the number of divisors of a number (https://oeis.org/A066150): the number  up to  has no more than  divisors. Therefore, we can sort through the pairs for . We learned how to find the optimal  for . We get that for each test case we have learned to solve the problem in .", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\nint t;\nlong long a,b,c,d,e,g,r,s,p;\nvector<long long> del1,del2;\nbool dali;\n\nint main(){\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin>>t;\n    for(int i=1;i<=t;i++){\n        cin>>a>>b>>c>>d;\n        del1.clear(); del2.clear();\n        \n        for(long long f=1;f*f<=a;f++){\n            if(a%f==0){\n                del1.push_back(f);\n                if(f!=a/f)del1.push_back(a/f);\n            }\n        }\n        for(long long f=1;f*f<=b;f++){\n            if(b%f==0){\n                del2.push_back(f);\n                if(f!=b/f)del2.push_back(b/f);\n            }\n        }\n\n        dali=false;\n\n        for(int f=0;f<del1.size();f++){\n            for(int k=0;k<del2.size();k++){\n                s=del1[f]*del2[k];\n                e=a/s+1;\n                if(e*s>c)continue;\n                p=e*s;\n\n                e=s;\n                g=a*b/e;\n                r=b/g+1;\n                if(g*r<=d){\n                    cout<<p<<\" \"<<g*r<<\"\\n\";\n                    dali=true; f=k=1000000;\n                }\n            }\n        }\n\n        if(!dali)cout<<-1<<\" \"<<-1<<\"\\n\";\n    }\n\n    return 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}