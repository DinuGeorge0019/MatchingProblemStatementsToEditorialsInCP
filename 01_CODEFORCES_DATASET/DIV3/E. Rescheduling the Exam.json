{"link": "https://codeforces.com//contest/1650/problem/E", "problemId": "1321164", "shortId": "1650E", "contest_number": "1650", "name": "E. Rescheduling the Exam", "statement": "Now Dmitry has a session, and he has to pass  exams. The session starts on day  and lasts  days. The th exam will take place on the day of  (), all \u00a0\u2014 are different.     For the session schedule, Dmitry considers a special value  \u2014 the smallest of the rest times before the exam for all exams. For example, for the image above, . In other words, for the schedule, he counts exactly  numbers \u00a0\u2014 how many days he rests between the exam  and  (for  between the start of the session and the exam ). Then it finds \u00a0\u2014 the minimum among these  numbers.Dmitry believes that he can improve the schedule of the session. He may ask to change the date of one exam (change one arbitrary value of ). Help him change the date so that all  remain different, and the value of  is as large as possible.For example, for the schedule above, it is most advantageous for Dmitry to move the second exam to the very end of the session. The new schedule will take the form:     Dmitry can leave the proposed schedule unchanged (if there is no way to move one exam so that it will lead to an improvement in the situation).", "input": "The first line of input data contains an integer  () \u2014 the number of input test cases. The descriptions of test cases follow. An empty line is written in the test before each case. The first line of each test case contains two integers  and  ()\u00a0\u2014 the number of exams and the length of the session, respectively. The second line of each test case contains  integers  (), where the -th number means the date of the -th exam. It is guaranteed that the sum of  for all test cases does not exceed .", "output": "For each test case, output the maximum possible value of  if Dmitry can move any one exam to an arbitrary day. All values of  should remain distinct.", "tutorial": "To begin with, we will learn how to find the optimal place for the exam that we want to move. Let's imagine that it is not in the schedule, in this case we have two options:  Put the exam at the end of the session so that there are  days before it.  Put it in the middle of the largest break between exams ((let its length be ), so that between it and the nearest one there is , because this is no worse than putting it in any part of any other break. That is, the answer for such an arrangement is \u00a0\u2014 the minimum of the larger of these options and the minimum break, in schedule without the moved exam.Now note that the minimum break in most variants is the same\u00a0\u2014 minimum in the initial schedule. So in order to reduce , you need to move exactly one of the two exams that form it and you need to check which of the two options is better.", "solution": "#include <bits/stdc++.h>\n\n#define int long long\n#define mp make_pair\n#define x first\n#define y second\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n\ntypedef long double ld;\ntypedef long long ll;\n\nusing namespace std;\n\nmt19937 rnd(143);\n\nconst ll inf = 1e9;\nconst ll M = 998'244'353;\nconst ld pi = atan2(0, -1);\nconst ld eps = 1e-4;\n\nint n, d;\n\nint cnt(vector<int> &schedule){\n    int mx = 0, mn = inf;\n    for(int i = 1; i < n; ++i){\n        mx = max(mx, schedule[i] - schedule[i - 1] - 1);\n        mn = min(mn, schedule[i] - schedule[i - 1] - 1);\n    }\n    return min(mn, max(d - schedule.back() - 1, (mx - 1) / 2));\n}\n\nvoid solve(int test_case) {\n    cin >> n >> d;\n    vector<int> a(n + 1);\n    int mn = d, min_pos = 0;\n    for(int i = 1; i <= n; ++i){\n        cin >> a[i];\n        if(a[i] - a[i - 1] - 1 < mn){\n            mn = a[i] - a[i - 1] - 1;\n            min_pos = i;\n        }\n    }\n    vector<int> schedule;\n    for(int i = 0; i <= n; ++i){\n        if(i != min_pos){\n            schedule.push_back(a[i]);\n        }\n    }\n    int ans = cnt(schedule);\n    if(min_pos > 1){\n        schedule[min_pos - 1] = a[min_pos];\n    }\n    ans = max(ans, cnt(schedule));\n    cout << ans;\n}\n\nbool multi = true;\n\nsigned main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"in.txt\", \"w\", stdout);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int t = 1;\n    if (multi) {\n        cin >> t;\n    }\n    for (int i = 1; i <= t; ++i) {\n        solve(i);\n        cout << \"\\n\";\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}