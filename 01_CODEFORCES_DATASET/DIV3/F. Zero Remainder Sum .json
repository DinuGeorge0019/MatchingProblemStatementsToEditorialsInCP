{"link": "https://codeforces.com//contest/1433/problem/F", "problemId": "766661", "shortId": "1433F", "contest_number": "1433", "name": "F. Zero Remainder Sum ", "statement": "You are given a matrix  of size  consisting of integers.You can choose   elements in . Your task is to choose these elements in such a way that their sum is   and this sum is the .In other words, you can choose no more than a half (rounded down) of elements in each row, you have to find the maximum sum of these elements divisible by .Note that you can choose zero elements (and the sum of such set is ).", "input": "The first line of the input contains three integers ,  and  () \u2014 the number of rows in the matrix, the number of columns in the matrix and the value of . The next  lines contain  elements each, where the -th element of the -th row is  ().", "output": "Print one integer \u2014 the maximum sum divisible by  you can obtain.", "tutorial": "This is pretty standard dynamic programming problem. Let  be the maximum possible sum we can obtain if we are at the element  right now, we took  elements in the row  and our current remainder is .Initially, all states are  except .Transitions are standard because this is a knapsack problem: we either take the element if  or don't take it. If the element  is not the last element of the row, then transitions look like that:   \u2014 we don't take the current element.   \u2014 we take the current element (this transition is only possible if ). The transitions from the last element of the row are almost the same, but the next element is  and the new value of  is always zero.The answer is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int N = 75;\nconst int INF = 1e9;\n\nint a[N][N];\nint dp[N][N][N][N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tforn(i, n) forn(j, m) {\n\t\tcin >> a[i][j];\n\t}\n\t\n\tforn(i, N) forn(j, N) forn(cnt, N) forn(rem, N) dp[i][j][cnt][rem] = -INF;\n\tdp[0][0][0][0] = 0;\n\tforn(i, n) forn(j, m) forn(cnt, m / 2 + 1) forn(rem, k) {\n\t\tif (dp[i][j][cnt][rem] == -INF) continue;\n\t\tint ni = (j == m - 1 ? i + 1 : i);\n\t\tint nj = (j == m - 1 ? 0 : j + 1);\n\t\tif (i != ni) {\n\t\t\tdp[ni][nj][0][rem] = max(dp[ni][nj][0][rem], dp[i][j][cnt][rem]);\n\t\t} else {\n\t\t\tdp[ni][nj][cnt][rem] = max(dp[ni][nj][cnt][rem], dp[i][j][cnt][rem]);\n\t\t}\n\t\tif (cnt + 1 <= m / 2) {\n\t\t\tint nrem = (rem + a[i][j]) % k;\n\t\t\tif (i != ni) {\n\t\t\t\tdp[ni][nj][0][nrem] = max(dp[ni][nj][0][nrem], dp[i][j][cnt][rem] + a[i][j]);\n\t\t\t} else {\n\t\t\t\tdp[ni][nj][cnt + 1][nrem] = max(dp[ni][nj][cnt + 1][nrem], dp[i][j][cnt][rem] + a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << max(0, dp[n][0][0][0]) << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}