{"link": "https://codeforces.com//contest/1133/problem/F1", "problemId": "308949", "shortId": "1133F1", "contest_number": "1133", "name": "F1. Spanning Tree with Maximum Degree", "statement": "You are given an undirected unweighted connected graph consisting of  vertices and  edges. It is guaranteed that there are no self-loops or multiple edges in the given graph.Your task is to find  spanning tree of this graph such that the maximum degree over all vertices is maximum possible. Recall that the degree of a vertex is the number of edges incident to it.", "input": "The first line contains two integers  and  (, ) \u2014 the number of vertices and edges, respectively. The following  lines denote edges: edge  is represented by a pair of integers ,  (, ), which are the indices of vertices connected by the edge. There are no loops or multiple edges in the given graph, i.\u2009e. for each pair () there are no other pairs () or () in the list of edges, and for each pair  the condition  is satisfied.", "output": "Print  lines describing the edges of a spanning tree such that the maximum degree over all vertices is maximum possible. Make sure that the edges of the printed spanning tree form some subset of the input edges (order doesn't matter and edge  is considered the same as the edge ). If there are multiple possible answers, print any of them.", "tutorial": "We can take  vertex with the maximum degree and all its neighbours. To implement it, just run  from  vertex with the maximum degree. See the authors solution for better understanding.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nvector<vector<int>> g;\nvector<int> deg, used;\nvector<pair<int, int>> ans;\n\nmt19937 rnd(time(NULL));\n\nvoid bfs(int s) {\n\tused = vector<int>(n);\n\tused[s] = 1;\n\tqueue<int> q;\n\tq.push(s);\n\t\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tfor (auto to : g[v]) {\n\t\t\tif (used[to]) continue;\n\t\t\tif (rnd() & 1) ans.push_back(make_pair(v, to));\n\t\t\telse ans.push_back(make_pair(to, v));\n\t\t\tused[to] = 1;\n\t\t\tq.push(to);\n\t\t}\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m;\n\tg = vector<vector<int>>(n);\n\tdeg = vector<int>(n);\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t\t++deg[x];\n\t\t++deg[y];\n\t}\n\t\n\tint pos = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (deg[pos] < deg[i]) {\n\t\t\tpos = i;\n\t\t}\n\t}\n\t\n\tbfs(pos);\n\tshuffle(ans.begin(), ans.end(), rnd);\n\tfor (auto it : ans) cout << it.first + 1 << \" \" << it.second + 1 << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}