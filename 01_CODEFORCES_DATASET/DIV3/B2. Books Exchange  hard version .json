{"link": "https://codeforces.com//contest/1249/problem/B2", "problemId": "447559", "shortId": "1249B2", "contest_number": "1249", "name": "B2. Books Exchange  hard version ", "statement": ".There are  kids, each of them is reading a unique book. At the end of any day, the -th kid will give his book to the -th kid (in case of  the kid will give his book to himself). It is guaranteed that all values of  are distinct integers from  to  (i.e.  is a permutation). The sequence  doesn't change from day to day, it is fixed.For example, if  and  then at the end of the first day the book of the -st kid will belong to the -th kid, the -nd kid will belong to the -th kid and so on. At the end of the second day the book of the -st kid will belong to the -th kid, the -nd kid will belong to the -th kid and so on.Your task is to determine the number of the day the book of the -th child is returned back to him for the first time for every  from  to .Consider the following example: . The book of the -st kid will be passed to the following kids:  after the -st day it will belong to the -th kid,  after the -nd day it will belong to the -rd kid,  after the -rd day it will belong to the -nd kid,  after the -th day it will belong to the -st kid. So after the fourth day, the book of the first kid will return to its owner. The book of the fourth kid will return to him for the first time after exactly one day.You have to answer  independent queries.", "input": "The first line of the input contains one integer  () \u2014 the number of queries. Then  queries follow. The first line of the query contains one integer  () \u2014 the number of kids in the query. The second line of the query contains  integers  (, all  are distinct, i.e.  is a permutation), where  is the kid which will get the book of the -th kid. It is guaranteed that  (sum of  over all queries does not exceed ).", "output": "For each query, print the answer on it:  integers , where  is the number of the day the book of the -th child is returned back to him for the first time in this query.", "tutorial": "In this problem, we can notice that when we calculate the answer for the kid , we also calculate the answer for kids ,  and so on. So we can a little bit modify the pseudocode from the easy version to calculate answers faster:pos = p[i]ans = 1cycle = [i]while pos != i:    cycle.append(pos)    ans += 1    pos = p[pos]for el in cycle: res[el] = ansAnd of course, we don't need to run this while for all elements for which we already calculated the answer. Total time complexity is  because you'll process each element exactly once.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> p(n);\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tcin >> p[j];\n\t\t\t--p[j];\n\t\t}\n\t\tvector<int> used(n);\n\t\tvector<int> ans(n);\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (!used[j]) {\n\t\t\t\tvector<int> cur;\n\t\t\t\twhile (!used[j]) {\n\t\t\t\t\tcur.push_back(j);\n\t\t\t\t\tused[j] = true;\n\t\t\t\t\tj = p[j];\n\t\t\t\t}\n\t\t\t\tfor (auto el : cur) ans[el] = cur.size();\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < n; ++j) cout << ans[j] << \" \";\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}