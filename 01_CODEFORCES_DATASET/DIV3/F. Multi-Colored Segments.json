{"link": "https://codeforces.com//contest/1741/problem/F", "problemId": "1580862", "shortId": "1741F", "contest_number": "1741", "name": "F. Multi-Colored Segments", "statement": "Dmitry has  segments of different colors on the coordinate axis . Each segment is characterized by three integers ,  and  (), where  and  are are the coordinates of the ends of the -th segment, and  is its color.Dmitry likes to find the minimum distances between segments. However, he considers pairs of segments of the same color uninteresting. Therefore, he wants to know for each segment the distance from this segment to the nearest  colored segment.The distance between two segments is the minimum of the distances between a point of the first segment and a point of the second segment. In particular, if the segments intersect, then the distance between them is equal to .For example, Dmitry has  segments:     The first segment intersects with the second (and these are segments of different colors), so the answers for them are equal to .  For the -rd segment, the nearest segment of a different color is the -nd segment, the distance to which is equal to .  For the -th segment, the nearest segment of a different color is the -th segment, the distance to which is equal to .  The -th segment lies inside the -nd segment (and these are segments of different colors), so the answers for them are equal to . ", "input": "The first line of the input contains an integer  () \u2014 the number of test cases in the test. The descriptions of the test cases follow. The first line of description of each test case contains one integer  () \u2014 the number of segments. The next  lines contain descriptions of the segments. Each segment is described by three integers ,  and  () \u2014 coordinates of the left and right ends of -th segment, as well as the color of this segment. It is guaranteed that there are at least  segments of different colors. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, on a separate line print  integers, where the -th number is equal to the distance from the -th segment to the nearest segment of a different color.", "tutorial": "Let's go through the segments  times: in non-decreasing coordinates of the left end, and then \u2014 in non-increasing coordinates of the right end. To walk a second time, just multiply the coordinates of the left and right borders by , and then swap them and walk from left to right.Going through the segments in non-decreasing coordinates of the left end, you need to find for each segment a segment that starts not to the right of the current one and ends as far to the right as possible. If the coordinate of its right end is not less than the coordinate of the left end of the current segment, then it intersects with it, otherwise the distance between them is equal to the distance between the coordinate of the left end of the current segment and the maximum coordinate of the right end of the segment starting to the left of ours.Note that it is enough for us to store no more than  segments: for each color we will store the maximum right coordinate of the segment of this color, which has already been considered. If we store the  colors with the largest right coordinates, then one of them is definitely not equal to the current one. When considering a segment, we add it to the list, and if the size of the list becomes , then we leave  of optimal elements.", "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nint n;\n\nvector<int> calc(vector<vector<int>> a) {\n    vector<pair<int, int>> l(n), r(n);\n    for (int i = 0; i < n; ++i) {\n        l[i] = {a[i][0], i};\n        r[i] = {a[i][1], i};\n    }\n    sort(l.begin(), l.end());\n    sort(r.begin(), r.end());\n    vector<vector<pair<int, int>>> suf(n);\n    vector<pair<int, int>> curr;\n    for (int i0 = n - 1; i0 >= 0; --i0) {\n        int xr = r[i0].first;\n        int i = r[i0].second;\n        int xl = a[i][0];\n        int c = a[i][2];\n        if (curr.empty()) {\n            curr.emplace_back(xl, c);\n        } else if (curr.size() == 1) {\n            if (curr[0].second == c) {\n                curr[0].first = min(curr[0].first, xl);\n            } else {\n                curr.emplace_back(xl, c);\n            }\n        } else {\n            if (curr[0].second == c) {\n                curr[0].first = min(curr[0].first, xl);\n            } else if (curr[1].second == c) {\n                curr[1].first = min(curr[1].first, xl);\n            } else {\n                curr.emplace_back(xl, c);\n            }\n        }\n        sort(curr.begin(), curr.end());\n        if (curr.size() == 3) {\n            curr.pop_back();\n        }\n        suf[i0] = curr;\n    }\n    vector<int> ans(n, 1e9);\n    int j = 0;\n    for (int i0 = 0; i0 < n; ++i0) {\n        int xl = l[i0].first, i = l[i0].second;\n        int xr = a[i][1], c = a[i][2];\n        while (j < n && r[j].first < xl) {\n            j++;\n        }\n        if (j < n) {\n            vector<pair<int, int>> s = suf[j];\n            if (s[0].second != c) {\n                ans[i] = min(ans[i], max(0, s[0].first - xr));\n            } else if (s.size() == 2) {\n                ans[i] = min(ans[i], max(0, s[1].first - xr));\n            }\n        }\n    }\n    return ans;\n}\n\nconst int K = 1e9 + 1;\n\nvoid solve() {\n    cin >> n;\n    vector<vector<int>> a(n, vector<int>(3)), b(n, vector<int>(3));\n    vector<pair<int, int>> l(n), r(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> a[i][j];\n            if (j == 2) {\n                b[i][j] = a[i][j];\n            } else {\n                b[i][1 - j] = K - a[i][j];\n            }\n        }\n    }\n    vector<int> ans1 = calc(a), ans2 = calc(b);\n    for (int i = 0; i < n; ++i) {\n        cout << min(ans1[i], ans2[i]) << ' ';\n    }\n    cout << '\\n';\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    int t = 1;\n    cin >> t;\n    for (int it = 0; it < t; ++it) {\n        solve();\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}