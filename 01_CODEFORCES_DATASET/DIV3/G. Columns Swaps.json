{"link": "https://codeforces.com//contest/1385/problem/G", "problemId": "675204", "shortId": "1385G", "contest_number": "1385", "name": "G. Columns Swaps", "statement": "You are given a table  of size  (i.e. two rows and  columns) consisting of integers from  to .In one move, you can choose some   () and swap values  and  in it. Each column can be chosen .Your task is to find the  number of moves required to obtain permutations of size  in both first and second rows of the table or determine if it is impossible to do that.You have to answer  independent test cases.Recall that the permutation of size  is such an array of size  that contains  from  to  exactly once (the order of elements doesn't matter).", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the number of columns in the table. The second line of the test case contains  integers  (), where  is the -th element of the first row of the table. The third line of the test case contains  integers  (), where  is the -th element of the second row of the table. It is guaranteed that the sum of  does not exceed  ().", "output": "For each test case print the answer:  if it is impossible to obtain permutation of size  in both first and the second rows of the table, or one integer  in the first line, where  is the  number of moves required to obtain permutations in both rows, and   integers  in the second line () in  \u2014 indices of columns in which you need to swap values to obtain permutations in both rows. If there are several answers, you can print any.", "tutorial": "Firstly, we can determine that the answer is  if some number has not two occurrences. Otherwise, the answer exists (and we actually don't need to prove it because we can check it later). Let's find for each number $$$i$$$ from $$$1$$$ to $$$n$$$ indices of columns in which it appears $$$c_1[i]$$$ and $$$c_2[i]$$$. Consider some number $$$i$$$. If $$$c_1[i] = c_2[i]$$$ then let's just skip it, we can't change anything by swapping values in this column. Otherwise, let $$$r_1[i]$$$ be the number of row of the number $$$i$$$ in the column $$$c_1[i]$$$ and $$$r_2[i]$$$ is the number of row of the number $$$i$$$ in the column $$$c_2[i]$$$. If $$$r_1[i] = r_2[i]$$$ then it's obvious that at exactly one of these two columns should be swapped. The same, if $$$r_1[i] \\ne r_2[i]$$$ then it's obvious that we either swap both of them or don't swap both of them. Let's build a graph consisting of $$$n$$$ vertices, when the vertex $$$v$$$ determines the state of the $$$v$$$-th column. If $$$r_1[i] = r_2[i]$$$ then let's add edge of color $$$1$$$ between vertices $$$c_1[i]$$$ and $$$c_2[i]$$$. Otherwise, let's add the edge of color $$$0$$$ between these vertices.So, we have the graph consisting of several connected components and some strange edges. Let's color it. If the edge $$$(v, to)$$$ has the color $$$1$$$ then the color of the vertex $$$to$$$ should be different from the color of the vertex $$$v$$$. The same, if the edge $$$(v, to)$$$ has the color $$$0$$$ then the color of the vertex $$$to$$$ should be the same as the color of the vertex $$$v$$$. This makes sense, because edges with color $$$1$$$ mean that exactly one of the columns connected by this edge should be swapped (and vice versa).So, after we colored the graph, we can ensure that conditions for each edge are satisfied. If it isn't so, the answer is  (but this case can't actually appear). Otherwise, we need to decide for each component independently, what is the color $$$0$$$ and the color $$$1$$$ means for it. The color $$$0$$$ can mean that the column having this color isn't swapped (and the color $$$1$$$ means that the column having this color is swapped in this case) and vice versa. We can choose greedily the minimum number of swaps for each component and print the answer.Time complexity: $$$O(n)$$$.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint cnt0, cnt1;\nvector<int> col, comp;\nvector<vector<pair<int, int>>> g;\n\nvoid dfs(int v, int c, int cmp) {\n\tcol[v] = c;\n\tif (col[v] == 0) ++cnt0;\n\telse ++cnt1;\n\tcomp[v] = cmp;\n\tfor (auto [to, change] : g[v]) {\n\t\tif (col[to] == -1) {\n\t\t\tdfs(to, c ^ change, cmp);\n\t\t}\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<vector<int>> a(2, vector<int>(n));\n\t\tvector<vector<int>> pos(n);\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\t--a[i][j];\n\t\t\t\tpos[a[i][j]].push_back(j);\n\t\t\t}\n\t\t}\n\t\tbool bad = false;\n\t\tg = vector<vector<pair<int, int>>>(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (pos[i].size() != 2) {\n\t\t\t\tbad = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint c1 = pos[i][0], c2 = pos[i][1];\n\t\t\tif (c1 == c2) continue;\n\t\t\tint r1 = a[0][c1] != i, r2 = a[0][c2] != i;\n\t\t\tg[c1].push_back({c2, r1 == r2});\n\t\t\tg[c2].push_back({c1, r1 == r2});\n\t\t}\n\t\tcol = comp = vector<int>(n, -1);\n\t\tint cnt = 0;\n\t\tvector<pair<int, int>> colcnt;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1) {\n\t\t\t\tcnt0 = cnt1 = 0;\n\t\t\t\tdfs(i, 0, cnt);\n\t\t\t\t++cnt;\n\t\t\t\tcolcnt.push_back({cnt0, cnt1});\n\t\t\t\tans += min(cnt0, cnt1);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (auto [j, diff] : g[i]) {\n\t\t\t\tif ((col[i] ^ col[j]) != diff) {\n\t\t\t\t\tbad = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bad) {\n\t\t\tcout << -1 << endl;\n\t\t} else {\n\t\t\tcout << ans << endl;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tint changeZero = colcnt[comp[i]].first < colcnt[comp[i]].second;\n\t\t\t\tif (col[i] ^ changeZero) {\n\t\t\t\t\tcout << i + 1 << \" \";\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}