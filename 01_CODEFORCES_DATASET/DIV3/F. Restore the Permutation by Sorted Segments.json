{"link": "https://codeforces.com//contest/1343/problem/F", "problemId": "599891", "shortId": "1343F", "contest_number": "1343", "name": "F. Restore the Permutation by Sorted Segments", "statement": "We guessed a permutation  consisting of  integers. The permutation of length  is the array of length  where each element from  to  appears exactly once. This permutation is a secret for you.For each position  from  to  we chose some other index  () and gave you the segment  in  order (i.e. we rearranged the elements of this segment in a way that the elements of this segment are sorted). Thus, you are given exactly  segments of the initial permutation but elements inside each segment are sorted. The segments are given to you in random order.For example, if the secret permutation is  then the possible given set of segments can be:           Your task is to find  suitable permutation (i.e. any permutation corresponding to the given input data). It is guaranteed that the input data corresponds to some permutation (i.e. such permutation exists).You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the length of the permutation. The next  lines describe given segments. The -th line contains the description of the -th segment. The line starts with the integer  () \u2014 the length of the -th segment. Then  integers follow. All integers in a line are distinct, sorted in ascending order, between  and , inclusive. It is guaranteed that the required  exists for each test case. It is also guaranteed that the sum of  over all test cases does not exceed  ().", "output": "For each test case, print the answer:  integers  (, all  should be distinct) \u2014  suitable permutation (i.e. any permutation corresponding to the test case input).", "tutorial": "Let's fix the first element and then try to restore permutation using this information. One interesting fact: if such permutation exists (with this first element) then it can be restored uniquely. Let's remove the first element from all segments containing it (we can use some logarithmic data structure for it). Then we just have a smaller problem but with one important condition: there is a segment consisting of one element (again, if such permutation exists). So, if the number of segments of length $$$1$$$ is zero or more than one by some reason then there is no answer for this first element. Otherwise, let's place this segment (a single element) in second place, remove it from all segments containing it and just solve a smaller problem again.If we succeed with restoring the permutation then we need to check if this permutation really satisfies the given input segments (see the first test case of the example to understand why this case appears). Let's just iterate over all $$$i$$$ from $$$2$$$ to $$$n$$$ and then over all $$$j$$$ from $$$i-1$$$ to $$$1$$$. If the segment $$$a_j, a_{j+1}, \\dots, a_i$$$ is in the list, remove it and go to the next $$$i$$$. If we can't find the segment for some $$$i$$$ then this permutation is wrong.Time complexity: $$$O(n^3 \\log n)$$$ (or less, maybe?)", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<set<int>> segs;\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tset<int> cur;\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\tint x;\n\t\t\t\tcin >> x;\n\t\t\t\tcur.insert(x);\n\t\t\t}\n\t\t\tsegs.push_back(cur);\n\t\t}\n\t\tfor (int fst = 1; fst <= n; ++fst) {\n\t\t\tvector<int> ans;\n\t\t\tbool ok = true;\n\t\t\tvector<set<int>> cur = segs;\n\t\t\tfor (auto &it : cur) if (it.count(fst)) it.erase(fst);\n\t\t\tans.push_back(fst);\n\t\t\tfor (int i = 1; i < n; ++i) {\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint nxt = -1;\n\t\t\t\tfor (auto  &it : cur) if (it.size() == 1) {\n\t\t\t\t\t++cnt1;\n\t\t\t\t\tnxt = *it.begin();\n\t\t\t\t}\n\t\t\t\tif (cnt1 != 1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (auto &it : cur) if (it.count(nxt)) it.erase(nxt);\n\t\t\t\tans.push_back(nxt);\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tset<set<int>> all(segs.begin(), segs.end());\n\t\t\t\tfor (int i = 1; i < n; ++i) {\n\t\t\t\t\tset<int> seg;\n\t\t\t\t\tseg.insert(ans[i]);\n\t\t\t\t\tbool found = false;\n\t\t\t\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\t\t\t\tseg.insert(ans[j]);\n\t\t\t\t\t\tif (all.count(seg)) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tall.erase(seg);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!found) ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tfor (auto it : ans) cout << it << \" \";\n\t\t\t\tcout << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}