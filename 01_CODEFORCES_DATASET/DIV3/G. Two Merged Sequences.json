{"link": "https://codeforces.com//contest/1144/problem/G", "problemId": "322488", "shortId": "1144G", "contest_number": "1144", "name": "G. Two Merged Sequences", "statement": "Two integer sequences existed initially, one of them was  increasing, and another one \u2014  decreasing.Strictly increasing sequence is a sequence of integers . And strictly decreasing sequence is a sequence of integers . Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing.Elements of increasing sequence were inserted between elements of the decreasing one (and, possibly, before its first element and after its last element) . For example, sequences  and  can produce the following resulting sequences: , . The following sequence cannot be the result of these insertions:  because the order of elements in the increasing sequence was changed.Let the obtained sequence be . This sequence  is given in the input. Your task is to find  two suitable initial sequences. One of them should be  increasing, and another one \u2014  decreasing. If there is a contradiction in the input and it is impossible to split the given sequence  into one increasing sequence and one decreasing sequence, print \"\".", "input": "The first line of the input contains one integer  () \u2014 the number of elements in . The second line of the input contains  integers  (), where  is the -th element of .", "output": "If there is a contradiction in the input and it is impossible to split the given sequence  into one increasing sequence and one decreasing sequence, print \"\" in the first line. Otherwise print \"\" in the first line. In the second line, print a sequence of  integers , where  should be either  or  for each  from  to . The -th element of this sequence should be  if the -th element of  belongs to the increasing sequence, and  otherwise. ", "tutorial": "I know about greedy solutions and other approaches, but I'll describe my solution. This is dynamic programming. I'll consider all positions -indexed.Let  be the  minimal element in the decreasing sequence, if the last element (-th) was in the increasing sequence, and  be the  maximum element in the increasing sequence, if the last element (-th) was in the decreasing sequence.Initially, all  are  and all  are  (except two values:  and ).What about transitions? Let's consider four cases:   The previous element was in the increasing sequence and we want to add the current element to the increasing sequence. We can do  if ;  the previous element was in the increasing sequence and we want to add the current element to the decreasing sequence. We can do  if ;  the previous element was in the decreasing sequence and we want to add the current element to the decreasing sequence. We can do  if ;  the previous element was in the decreasing sequence and we want to add the current element to the increasing sequence. We can do  if . The logic behind these transitions is kinda hard but understandable.If  and  then the answer is \"\". Otherwise we can restore any possible answer using parents in the dynamic programming.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tvector<vector<int>> dp(n, vector<int>({-INF, INF}));\n\tvector<vector<int>> p(n, vector<int>(2, -1));\n\tdp[0][0] = INF;\n\tdp[0][1] = -INF;\n\t\n\tfor (int i = 1; i < n; ++i) {\n\t\t{\n\t\t\tif (a[i] > a[i - 1] && dp[i][0] < dp[i - 1][0]) {\n\t\t\t\tdp[i][0] = dp[i - 1][0];\n\t\t\t\tp[i][0] = 0;\n\t\t\t}\n\t\t\tif (a[i] < dp[i - 1][0] && dp[i][1] > a[i - 1]) {\n\t\t\t\tdp[i][1] = a[i - 1];\n\t\t\t\tp[i][1] = 0;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (a[i] < a[i - 1] && dp[i][1] > dp[i - 1][1]) {\n\t\t\t\tdp[i][1] = dp[i - 1][1];\n\t\t\t\tp[i][1] = 1;\n\t\t\t}\n\t\t\tif (a[i] > dp[i - 1][1] && dp[i][0] < a[i - 1]) {\n\t\t\t\tdp[i][0] = a[i - 1];\n\t\t\t\tp[i][0] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint pos = -1;\n\tif (dp[n - 1][0] != -INF) {\n\t\tpos = 0;\n\t}\n\tif (dp[n - 1][1] != INF) {\n\t\tpos = 1;\n\t}\n\t\n\tif (pos == -1) {\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tvector<int> inInc(n);\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tif (pos == 0) {\n\t\t\tinInc[i] = 1;\n\t\t}\n\t\tpos = p[i][pos];\n\t}\n\t\n\tcout << \"YES\" << endl;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << !inInc[i] << \" \";\n\t}\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}