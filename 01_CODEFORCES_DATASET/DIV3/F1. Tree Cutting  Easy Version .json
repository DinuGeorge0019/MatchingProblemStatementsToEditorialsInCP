{"link": "https://codeforces.com//contest/1118/problem/F1", "problemId": "300361", "shortId": "1118F1", "contest_number": "1118", "name": "F1. Tree Cutting  Easy Version ", "statement": "You are given an undirected tree of  vertices. Some vertices are colored blue, some are colored red and some are uncolored. It is guaranteed that the tree contains at least one red vertex and at least one blue vertex.You choose an edge and remove it from the tree. Tree falls apart into two connected components. Let's call an edge  if neither of the resulting components contain vertices of both red and blue colors.How many  edges are there in the given tree?", "input": "The first line contains a single integer  () \u2014 the number of vertices in the tree. The second line contains  integers  () \u2014 the colors of the vertices.  means that vertex  is colored red,  means that vertex  is colored blue and  means that vertex  is uncolored. The -th of the next  lines contains two integers  and  (, ) \u2014 the edges of the tree. It is guaranteed that the given edges form a tree. It is guaranteed that the tree contains at least one red vertex and at least one blue vertex.", "output": "Print a single integer \u2014 the number of  edges in the given tree.", "tutorial": "Let's root the tree by some vertex. The edge , where  is the parent of , is now nice if and only if the subtree of  contains either all red vertices of the tree and no blue vertices or all blue vertices of the tree and no red vertices. That's because removing that edge splits the tree into the subtree of  and the component of every other vertex.Thus, the task is to calculate the number of red and blue vertices in each subtree with dfs and check a couple of conditions.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 300 * 1000 + 13;\n\nint n;\nint a[N];\nvector<int> g[N];\nint red, blue;\nint ans;\n\npair<int, int> dfs(int v, int p = -1){\n\tint r = (a[v] == 1), b = (a[v] == 2);\n\tfor (auto u : g[v]) if (u != p){\n\t\tauto tmp = dfs(u, v);\n\t\tans += (tmp.first == red && tmp.second == 0);\n\t\tans += (tmp.first == 0 && tmp.second == blue);\n\t\tr += tmp.first;\n\t\tb += tmp.second;\n\t}\n\treturn make_pair(r, b);\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\t\n\tforn(i, n){\n\t\tscanf(\"%d\", &a[i]);\n\t\tred += (a[i] == 1);\n\t\tblue += (a[i] == 2);\n\t}\n\t\n\tforn(i, n - 1){\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\t\n\tans = 0;\n\tdfs(0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}