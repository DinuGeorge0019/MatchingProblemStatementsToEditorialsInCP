{"link": "https://codeforces.com//contest/1296/problem/E1", "problemId": "531586", "shortId": "1296E1", "contest_number": "1296", "name": "E1. String Coloring  easy version ", "statement": ".You are given a string  consisting of  lowercase Latin letters.You have to color  its characters  (each character to exactly one color, the same letters can be colored the same or different colors, i.e. you can choose exactly one color for each index in ).After coloring, you can swap  two neighboring characters of the string that are colored  colors. You can perform such an operation arbitrary (possibly, zero) number of times.The goal is to make the string sorted, i.e. all characters should be in alphabetical order.Your task is to say if it is possible to color the given string so that after coloring it can become sorted by  sequence of swaps. Note that you have to restore only coloring, not the sequence of swaps.", "input": "The first line of the input contains one integer  () \u2014 the length of . The second line of the input contains the string  consisting of exactly  lowercase Latin letters.", "output": "If it is impossible to color the given string so that after coloring it can become sorted by  sequence of swaps, print \"\" (without quotes) in the first line. Otherwise, print \"\" in the first line and  correct coloring in the second line (the coloring is the string consisting of  characters, the -th character should be '' if the -th character is colored the first color and '' otherwise).", "tutorial": "Note that the actual problem is to divide the string into two subsequences that both of them are non-decreasing. You can note that this is true because you cannot the relative order of the elements colored in the same color, but you can write down subsequences of different colors in any order you want.In this problem, you can write the following dynamic programming:  is  if you can split the prefix of the string  into two non-decreasing sequences such that the first one ends with the character  and the second one \u2014 with  (characters are numbered from  to ), otherwise  is zero. Initially, only , other values are zeros. Transitions are very easy: if the current value of dp is  then we can make a transition to  if  and to  if . Then you can restore the answer by carrying parent values.But there is another very interesting solution. Let's go from left to right and carry two sequences  and . If the current character is not less than the last character of  then let's append it to , otherwise, if this character is not less than the last character of  then append it to , otherwise the answer is \"\".If the answer isn't \"\" then  and  are required sequences. The proof and other stuff will be in the editorial of the hard version.Time complexity:  or  or .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 222;\nconst int AL = 26;\n\nbool dp[N][AL][AL];\npair<pair<int, int>, int> p[N][AL][AL];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint c = s[i] - 'a';\n\t\tfor (int c1 = 0; c1 < AL; ++c1) {\n\t\t\tfor (int c2 = 0; c2 < AL; ++c2) {\n\t\t\t\tif (!dp[i][c1][c2]) continue;\n\t\t\t\tif (c >= c1) {\n\t\t\t\t\tdp[i + 1][c][c2] = 1;\n\t\t\t\t\tp[i + 1][c][c2] = make_pair(make_pair(c1, c2), 0);\n\t\t\t\t}\n\t\t\t\tif (c >= c2) {\n\t\t\t\t\tdp[i + 1][c1][c] = 1;\n\t\t\t\t\tp[i + 1][c1][c] = make_pair(make_pair(c1, c2), 1);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint x = -1, y = -1;\n\tfor (int c1 = 0; c1 < AL; ++c1) {\n\t\tfor (int c2 = 0; c2 < AL; ++c2) {\n\t\t\tif (dp[n][c1][c2]) {\n\t\t\t\tx = c1, y = c2;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (x == -1) {\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tstring res;\n\tfor (int i = n; i > 0; --i) {\n\t\tint prvx = p[i][x][y].first.first;\n\t\tint prvy = p[i][x][y].first.second;\n\t\tif (p[i][x][y].second) res += '1';\n\t\telse res += '0';\n\t\tx = prvx;\n\t\ty = prvy;\n\t}\n\t\n\treverse(res.begin(), res.end());\n\tcout << \"YES\" << endl << res << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}