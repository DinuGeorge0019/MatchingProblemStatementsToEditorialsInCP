{"link": "https://codeforces.com//contest/1512/problem/E", "problemId": "953477", "shortId": "1512E", "contest_number": "1512", "name": "E. Permutation by Sum", "statement": "A permutation is a sequence of  integers from  to , in which all the numbers occur exactly once. For example, , ,  are permutations, and , ,  are not.Polycarp was given four integers , ,  ( and  () and asked to find a permutation  of numbers from  to  that satisfies the following condition:   . For example, for , , , and , the following permutations are suitable (not all options are listed):   ;  ;  .  But, for example, there is no permutation suitable for the condition above for , , , and .Help Polycarp, for the given , , , and , find a permutation of numbers from  to  that fits the condition above. If there are several suitable permutations, print any of them.", "input": "The first line contains a single integer  (). Then  test cases follow. Each test case consist of one line with four integers  (),  (),  (),  (). It is guaranteed that the sum of  for all input data sets does not exceed .", "output": "For each test case, output on a separate line:     integers\u00a0\u2014 a permutation of length  that fits the condition above if such a permutation exists;  , otherwise.  If there are several suitable permutations, print any of them.", "tutorial": "It is easy to show that if we choose $$$k$$$ numbers from a permutation of length $$$n$$$, then the minimum sum of $$$k$$$ numbers is $$$\\frac{k(k+1)}{2}$$$, the maximum sum is $$$\\frac{k(2n+1-k)}{2}$$$ and any sum between them is achievable (that is, you can choose exactly $$$k$$$ numbers from $$$n$$$ so that their sum is equal to the desired one).This fact allows us to implement the following greedy solution:   Denote for $$$low(k)=\\sum\\limits_{i=1}^{k} i = \\frac{k(k+1)}{2}$$$, for $$$high(n, k)=\\sum\\limits_{i=n-k+1}^{n} i = \\frac{k(2n+1-k)}{2}$$$ and for $$$k=r-l+1$$$;  We will consider the numbers $$$i=n,n-1,\\ldots,1$$$ and determine whether to put them in the segment $$$[l, r]$$$ or not;  If $$$k>0$$$, $$$high(i, k) \\ge s$$$ and $$$s-i \\ge low(k-1)$$$, then put the number $$$i$$$ in the segment $$$[l, r]$$$ , decrease $$$s$$$ by $$$i$$$, decrease $$$k$$$ by $$$1$$$;  Otherwise, we will not put the number $$$i$$$ in the segment $$$[l, r]$$$. In the end, if $$$s=0$$$, then we have chosen $$$r-l+1$$$ a number with the sum of $$$s$$$, so the remaining number can be arranged in any order. If at the end $$$s>0$$$, then there is no way to select $$$r-l+1$$$ a number from $$$1,2,\\ldots,n$$$ with the sum of $$$s$$$.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nvoid solve() {\n    int n, l, r, s;\n    cin >> n >> l >> r >> s;\n    l--; r--;\n    for (int first = 1; first + (r - l) <= n; first++) {\n        int sum = 0;\n        for (int i = l; i <= r; i++) {\n            sum += first + (i - l);\n        }\n        if (sum <= s && s - sum <= r - l + 1) {\n            int needAdd = r - (s - sum) + 1;\n            vector<int> ans(n);\n            set<int> non_blocked;\n            for (int i = 1; i <= n; i++) {\n                non_blocked.insert(i);\n            }\n            for (int i = l; i <= r; i++) {\n                ans[i] = first + (i - l);\n                if (i >= needAdd) {\n                    ans[i]++;\n                }\n                non_blocked.erase(ans[i]);\n            }\n            if (ans[r] > n) {\n                continue;\n            }\n            non_blocked.erase(ans[r]);\n            for (int i = 0; i < l; i++) {\n                ans[i] = *non_blocked.begin();\n                non_blocked.erase(non_blocked.begin());\n            }\n            for (int i = r + 1; i < n; i++) {\n                ans[i] = *non_blocked.begin();\n                non_blocked.erase(non_blocked.begin());\n            }\n            for (int i : ans) {\n                cout << i << \" \";\n            }\n            cout << \"\\n\";\n            return;\n        }\n    }\n    cout << \"-1\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n    int n;\n    cin >> n;\n    while (n--) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}