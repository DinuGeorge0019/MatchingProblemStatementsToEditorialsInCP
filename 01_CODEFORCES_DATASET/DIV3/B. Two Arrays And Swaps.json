{"link": "https://codeforces.com//contest/1353/problem/B", "problemId": "620788", "shortId": "1353B", "contest_number": "1353", "name": "B. Two Arrays And Swaps", "statement": "You are given two arrays  and  both consisting of  positive (greater than zero) integers. You are also given an integer .In one move, you can choose two indices  and  () and swap  and  (i.e.  becomes  and vice versa). Note that  and  can be equal or different (in particular, swap  with  or swap  and  both are acceptable moves).Your task is to find the  possible sum you can obtain in the array  if you can do no more than (i.e. at most)  such moves (swaps).You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains two integers  and  () \u2014 the number of elements in  and  and the maximum number of moves you can do. The second line of the test case contains  integers  (), where  is the -th element of . The third line of the test case contains  integers  (), where  is the -th element of .", "output": "For each test case, print the answer \u2014 the  possible sum you can obtain in the array  if you can do no more than (i.e. at most)  swaps.", "tutorial": "Each move we can choose the minimum element in , the maximum element in  and swap them (if the minimum in  is less than maximum in ). If we repeat this operation  times, we get the answer. This can be done in ,  but authors solution is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tvector<int> b(n);\n\t\tfor (auto &it : b) cin >> it;\n\t\tsort(a.begin(), a.end());\n\t\tsort(b.rbegin(), b.rend());\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i < k) ans += max(a[i], b[i]);\n\t\t\telse ans += a[i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}