{"link": "https://codeforces.com//contest/1133/problem/F2", "problemId": "308950", "shortId": "1133F2", "contest_number": "1133", "name": "F2. Spanning Tree with One Fixed Degree", "statement": "You are given an undirected unweighted connected graph consisting of  vertices and  edges. It is guaranteed that there are no self-loops or multiple edges in the given graph.Your task is to find  spanning tree of this graph such that the  is equal to  (or say that there are no such spanning trees). Recall that the degree of a vertex is the number of edges incident to it.", "input": "The first line contains three integers ,  and  (, ) \u2014 the number of vertices, the number of edges and required degree of the first vertex, respectively. The following  lines denote edges: edge  is represented by a pair of integers ,  (, ), which are the indices of vertices connected by the edge. There are no loops or multiple edges in the given graph, i.\u2009e. for each pair () there are no other pairs () or () in the list of edges, and for each pair  the condition  is satisfied.", "output": "If there is no spanning tree satisfying the condition from the problem statement, print \"\" in the first line. Otherwise print \"\" in the first line and then print  lines describing the edges of a spanning tree such that the  is equal to . Make sure that the edges of the printed spanning tree form some subset of the input edges (order doesn't matter and edge  is considered the same as the edge ). If there are multiple possible answers, print any of them.", "tutorial": "Firstly, let's remove the vertex  from the graph. Then let's calculate the number of connected components. Let it be .The answer is  if and only if  or  is greater than the number of edges incident to the first vertex.Otherwise let's construct the answer. Firstly, let's add into the new graph spanning trees of components in the initial graph without vertex .Then let's add into the new graph  edges from vertex  \u2014 one edge to each component.Then let's add into the new graph any  remaining edges from vertex .The last thing we need is to construct a spanning tree of a new graph such that all edges incident to the vertex  are in this spanning tree (and other edges doesn't matter).How to do it? Let's run  from the vertex  in a new graph!", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, D;\nvector<vector<int>> g;\n\nint cnt;\nvector<int> p, color;\nvector<pair<int, int>> ans;\n\nmt19937 rnd(time(NULL));\n\nvoid bfs(int s, int bad) {\n\tqueue<int> q;\n\tq.push(s);\n\tcolor[s] = cnt;\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tif (p[v] != -1) {\n\t\t\tif (rnd() & 1) ans.push_back(make_pair(p[v], v));\n\t\t\telse ans.push_back(make_pair(v, p[v]));\n\t\t}\n\t\tfor (auto to : g[v]) {\n\t\t\tif (to == bad || color[to] != -1) continue;\n\t\t\tp[to] = v;\n\t\t\tcolor[to] = cnt;\n\t\t\tq.push(to);\n\t\t}\n\t}\n\t++cnt;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> D;\n\tg = vector<vector<int>>(n);\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tp = color = vector<int>(n, -1);\n\tcnt = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tif (color[i] == -1) {\n\t\t\tbfs(i, 0);\n\t\t}\n\t}\n\t\n\tif (cnt > D || D > int(g[0].size())) {\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tsort(g[0].begin(), g[0].end(), [](int a, int b) {\n\t\treturn color[a] < color[b];\n\t});\n\t\n\tfor (int i = 0; i < int(g[0].size()); ++i) {\n\t\tif (i == 0 || color[g[0][i]] != color[g[0][i - 1]]) {\n\t\t\tans.push_back(make_pair(0, g[0][i]));\n\t\t}\n\t}\n\tD -= cnt;\n\tfor (int i = 1; i < int(g[0].size()); ++i) {\n\t\tif (D == 0) break;\n\t\tif (color[g[0][i]] == color[g[0][i - 1]]) {\n\t\t\tans.push_back(make_pair(0, g[0][i]));\n\t\t\t--D;\n\t\t}\n\t}\n\t\n\tg = vector<vector<int>>(n);\n\tfor (auto it : ans) {\n\t\tg[it.first].push_back(it.second);\n\t\tg[it.second].push_back(it.first);\n\t}\n\tans.clear();\n\tp = color = vector<int>(n, -1);\n\tcnt = 0;\n\tbfs(0, -1);\n\t\n\tshuffle(ans.begin(), ans.end(), rnd);\n\tcout << \"YES\" << endl;\n\tfor (auto it : ans) {\n\t\tcout << it.first + 1 << \" \" << it.second + 1 << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}