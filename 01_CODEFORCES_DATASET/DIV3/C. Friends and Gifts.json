{"link": "https://codeforces.com//contest/1283/problem/C", "problemId": "504969", "shortId": "1283C", "contest_number": "1283", "name": "C. Friends and Gifts", "statement": "There are  friends who want to give gifts for the New Year to each other. Each friend should give  one gift and receive  one gift. The friend  give the gift to himself.For each friend the value  is known: it is either  if the -th friend doesn't know whom he wants to give the gift to or  if the -th friend wants to give the gift to the friend .You want to fill in the unknown values () in such a way that each friend gives  one gift and receives  one gift and there is  friend who gives the gift to himself. It is guaranteed that the initial information isn't contradictory.If there are several answers, you can print any.", "input": "The first line of the input contains one integer  () \u2014 the number of friends. The second line of the input contains  integers  (, , all  are distinct), where  is the either  if the -th friend doesn't know whom he wants to give the gift to or  if the -th friend wants to give the gift to the friend . It is also guaranteed that there is  values .", "output": "Print  integers , where  should be equal to  if  or the number of friend whom the -th friend wants to give the gift to. All values  should be distinct,  cannot be equal to . Each friend gives  one gift and receives  one gift and there is  friend who gives the gift to himself. If there are several answers, you can print any.", "tutorial": "In this problem, we need to print the permutation without fixed points (without values ) but some values are known in advance. Let's consider the permutation as a graph. We know that the permutation is the set of non-intersecting cycles. In this problem, we are given such a graph but some edges are removed. How to deal with it?Firstly, let's find isolated vertices in the graph. Let its number be . If  then all is ok and we skip the current step. If  then let's pin this isolated vertex to any vertex to which we can pin it. Otherwise,  and we can create the chine consisting of all isolated vertices.Now  and we can finally construct the remaining part of the graph. We can notice that we have the same number of vertices with zero incoming and zero outcoming degrees. And because we got rid of all possible loops in the graph, we can match these vertices as we want.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> f(n);\n\tvector<int> in(n), out(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> f[i];\n\t\t--f[i];\n\t\tif (f[i] != -1) {\n\t\t\t++out[i];\n\t\t\t++in[f[i]];\n\t\t}\n\t}\n\t\n\tvector<int> loops;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (in[i] == 0 && out[i] == 0) {\n\t\t\tloops.push_back(i);\n\t\t}\n\t}\n\tif (loops.size() == 1) {\n\t\tint idx = loops[0];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (in[i] == 0 && i != idx) {\n\t\t\t\tf[idx] = i;\n\t\t\t\t++out[idx];\n\t\t\t\t++in[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (loops.size() > 1) {\n\t\tfor (int i = 0; i < int(loops.size()); ++i) {\n\t\t\tint cur = loops[i];\n\t\t\tint nxt = loops[(i + 1) % int(loops.size())];\n\t\t\tf[cur] = nxt;\n\t\t\t++out[cur];\n\t\t\t++in[nxt];\n\t\t}\n\t}\n\tloops.clear();\n\tvector<int> ins, outs;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (in[i] == 0) ins.push_back(i);\n\t\tif (out[i] == 0) outs.push_back(i);\n\t}\n\tassert(ins.size() == outs.size());\n\tfor (int i = 0; i < int(outs.size()); ++i) {\n\t\tf[outs[i]] = ins[i];\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << f[i] + 1 << \" \";\n\t}\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}