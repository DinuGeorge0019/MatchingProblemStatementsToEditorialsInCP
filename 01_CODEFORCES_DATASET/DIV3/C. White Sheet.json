{"link": "https://codeforces.com//contest/1216/problem/C", "problemId": "416602", "shortId": "1216C", "contest_number": "1216", "name": "C. White Sheet", "statement": "There is a white sheet of paper lying on a rectangle table. The sheet is a rectangle with its sides parallel to the sides of the table. If you will take a look from above and assume that the bottom left corner of the table has coordinates , and coordinate axes are left and bottom sides of the table, then the bottom left corner of the white sheet has coordinates , and the top right \u2014 .After that two black sheets of paper are placed on the table. Sides of both black sheets are also parallel to the sides of the table. Coordinates of the bottom left corner of the first black sheet are , and the top right \u2014 . Coordinates of the bottom left corner of the second black sheet are , and the top right \u2014 .      Determine if some part of the white sheet can be seen from the above after the two black sheets are placed. The part of the white sheet can be seen if there is at least one point lying  the white sheet and  of both black sheets.", "input": "The first line of the input contains four integers   \u2014 coordinates of the bottom left and the top right corners of the white sheet. The second line of the input contains four integers   \u2014 coordinates of the bottom left and the top right corners of the first black sheet. The third line of the input contains four integers   \u2014 coordinates of the bottom left and the top right corners of the second black sheet. ", "output": "If some part of the white sheet can be seen from the above after the two black sheets are placed, print \"\" (without quotes). Otherwise print \"\".", "tutorial": "There are at least two solution to the problem. I'll describe both of them.The first solution: firstly let's notice that the point we search can have non-integer coordinates, but if the answer exists then there will be the answer such that its point has at most half-integer coordinates. So let's multiply all coordinates by two and solve the problem with integer coordinates. The second thing is that for some  there is only two points we need to check \u2014 top point with this  and bottom point with this . The same for some . So we can iterate over all possible values of  and check if the point  lies outside of both black rectangles. The same with point . Then do the same for points  and .  should be in range  and  should be in range . Time complexity is linear on size of the white rectangle.The second solution is most tricky but has the better time complexity. Let  be the intersection of white rectangle and the first black rectangle,  the same but with the second black rectangle and  be the intersection of  and . Then it is obvious that the answer exists if  and  doesn't cover the whole white rectangle (). Time complexity: .", "solution": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <iomanip>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cmath>\n\n#define forn(i, n) for(int i=0;i<n;++i)\n#define fore(i, l, r) for(int i = int(l); i <= int(r); ++i)\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y1 ________y1\n#define y second\n#define ft first\n#define sc second\n#define pt pair<int, int>\n\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\ntypedef long long li;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int INF = 1000 * 1000 * 1000;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n\nint x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6;\n\ninline void read() {\t\n\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> x5 >> y5 >> x6 >> y6;\n    x1 *= 2, y1 *= 2;\n    x2 *= 2, y2 *= 2;\n    x3 *= 2, y3 *= 2;\n    x4 *= 2, y4 *= 2;\n    x5 *= 2, y5 *= 2;\n    x6 *= 2, y6 *= 2;\n}\n\ninline bool ok(int x, int y, int x1, int y1, int x2, int y2) {\n\treturn x < x1 || x2 < x || y < y1 || y2 < y;\n}\n\ninline void solve() {\n\tfor (int x = x1; x <= x2; x++) {\n\t\tif (ok(x, y1, x3, y3, x4, y4) && ok(x, y1, x5, y5, x6, y6)) {\n\t\t\tcout << \"YES\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tif (ok(x, y2, x3, y3, x4, y4) && ok(x, y2, x5, y5, x6, y6)) {\n\t\t\tcout << \"YES\" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (int y = y1; y <= y2; y++) {\n\t\tif (ok(x1, y, x3, y3, x4, y4) && ok(x1, y, x5, y5, x6, y6)) {\n\t\t\tcout << \"YES\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tif (ok(x2, y, x3, y3, x4, y4) && ok(x2, y, x5, y5, x6, y6)) {\n\t\t\tcout << \"YES\" << endl;\n\t\t\treturn;\n\t\t}\t\n\t}\n\tcout << \"NO\" << endl;\n}\n\nint main () {\n#ifdef fcspartakm\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    srand(time(NULL));\n    cerr << setprecision(10) << fixed;\n    \n    read();\n    solve();\n \n    //cerr << \"TIME: \" << clock() << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}