{"link": "https://codeforces.com//contest/1029/problem/E", "problemId": "211260", "shortId": "1029E", "contest_number": "1029", "name": "E. Tree with Small Distances", "statement": "You are given an undirected tree consisting of  vertices. An undirected tree is a connected undirected graph with  edges.Your task is to add the minimum number of edges in such a way that the length of the shortest path from the vertex  to any other vertex is at most . Note that you are not allowed to add loops and multiple edges.", "input": "The first line contains one integer  () \u2014 the number of vertices in the tree. The following  lines contain edges: edge  is given as a pair of vertices  (). It is guaranteed that the given edges form a tree. ", "output": "Print a single integer \u2014 the minimum number of edges you have to add in order to make the shortest distance from the vertex  to any other vertex at most . Note that you are not allowed to add loops and multiple edges.", "tutorial": "The first idea is the following: it is always profitable to add the edges from the vertex  to any other vertex. The proof is the following: if we will add two edges  and  then the distance to the vertex  will be , the distance to the vertex  will be . But we can add edges  and  and this will be better (in fact, you cannot obtain the less answer by adding two edges in the other way).The main idea is the following. Let's carry all vertices of the tree with the distance more than  in the set. Let the vertex with the maximum distance be . What we will obtain if we will add the edge ? The distance to the vertex  will be  and the distance to the vertex  (where  is the parent of the vertex  if we will root the tree by the vertex ) will be . So we will make reachable at most two vertices (if the vertex  is already reachable then it will be not counted in the answer). Now what we will obtain if we will add the edge ? We will make reachable all the vertices adjacent to the vertex  and the vertex  (the number of such vertices is not less than  so this move won't make the answer greater instead of any other way to add the edge). After adding such edge let's remove the vertex  and all vertices adjacent to it from the set. We need to repeat this algorithm until the set will not become empty.Time complexity is .I sure that there exists the solution with the dynamic programming in the linear time, I will be very happy if someone will explain it to other participants.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 11;\n\nint p[N];\nint d[N];\nvector<int> g[N];\n\nvoid dfs(int v, int pr = -1, int dst = 0) {\n\td[v] = dst;\n\tp[v] = pr;\n\tfor (auto to : g[v]) {\n\t\tif (to != pr) {\n\t\t\tdfs(to, v, dst + 1);\n\t\t}\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tdfs(0);\n\tset<pair<int, int>> st;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (d[i] > 2) {\n\t\t\tst.insert(make_pair(-d[i], i));\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\twhile (!st.empty()) {\n\t\tint v = st.begin()->second;\n\t\tv = p[v];\n\t\t++ans;\n\t\tauto it = st.find(make_pair(-d[v], v));\n\t\tif (it != st.end()) {\n\t\t\tst.erase(it);\n\t\t}\n\t\tfor (auto to : g[v]) {\n\t\t\tauto it = st.find(make_pair(-d[to], to));\n\t\t\tif (it != st.end()) {\n\t\t\t\tst.erase(it);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}