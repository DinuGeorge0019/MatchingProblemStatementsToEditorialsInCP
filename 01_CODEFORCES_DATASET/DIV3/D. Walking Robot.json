{"link": "https://codeforces.com//contest/1154/problem/D", "problemId": "331480", "shortId": "1154D", "contest_number": "1154", "name": "D. Walking Robot", "statement": "There is a robot staying at  on the  axis. He has to walk to . You are controlling this robot and controlling how he goes. The robot has a battery and an accumulator with a solar panel.The -th segment of the path (from  to ) can be exposed to sunlight or not. The array  denotes which segments are exposed to sunlight: if segment  is exposed, then , otherwise .The robot has one battery of capacity  and one accumulator of capacity . For each segment, you should choose which type of energy storage robot will use to go to the next point (it can be either battery or accumulator). If the robot goes using the battery, the current charge of the battery is decreased by one (the robot can't use the battery if its charge is zero). And if the robot goes using the accumulator, the current charge of the accumulator is decreased by one (and the robot also can't use the accumulator if its charge is zero).If the current segment is  and the robot goes through it , the charge of the accumulator increases by one (of course, its charge can't become higher than it's maximum capacity).If accumulator is used to pass some segment, its charge decreases by 1 no matter if the segment is exposed or not.You understand that it is not always possible to walk to . You want your robot to go as far as possible. Find the maximum number of segments of distance the robot can pass if you control him optimally.", "input": "The first line of the input contains three integers  () \u2014 the robot's destination point, the battery capacity and the accumulator capacity, respectively. The second line of the input contains  integers  (), where  is  if the -th segment of distance is exposed to sunlight, and  otherwise.", "output": "Print one integer \u2014 the maximum number of segments the robot can pass if you control him optimally.", "tutorial": "Let's simulate the process of walking and maintain the current charges of the battery and the accumulator, carefully choosing which to use each time we want to pass a segment.Obviously, if at the beginning of some segment our battery is exhausted (its current charge is ), we must use the accumulator to continue, and vice versa.What if we can use both types of energy storage? If we can recharge the accumulator (the current segment is exposed  the current charge of accumulator is lower than its initial charge), let's do it \u2014 because it only consumes one charge of the battery, and there is no better way to spend it. And if we cannot recharge the accumulator, it's optimal to use it instead of the battery (suppose it's not right: our solution uses the accumulator during current moment of time  and the battery during some moment in future , but optimal solution does vice versa. Then the usage of the battery in optimal solution does not grant us any additional charges, so we can instead swap our decisions in these moments, use the accumulator right now and the battery later, and the answer won't get worse).So, what's left is to carefully implement the simulation, keeping track of charges and choosing what to use according to aforementioned rules.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint a, b, maxa;\n\nvoid use_battery(int s)\n{\n\tif(s == 1) a = min(a + 1, maxa);\n\t--b;\t\n}\n\nvoid use_accum()\n{\n\t--a;\n}\n\nint main()\n{\n\tint ans = 0;\n\tint n;\n\tcin >> n >> b >> a;\n\tmaxa = a;\n\tvector<int> s(n);\n\tfor(int i = 0; i < n; i++) cin >> s[i];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(a == 0 && b == 0)\n\t\t\tbreak;\n\t\telse if(a == 0)\n\t\t\tuse_battery(s[i]);\n\t\telse if(b == 0)\n\t\t\tuse_accum();\n\t\telse if(s[i] == 1 && a < maxa)\n\t\t\tuse_battery(s[i]);\n\t\telse use_accum();\n\t\tans++;\n\t}\n\tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}