{"link": "https://codeforces.com//contest/1462/problem/E2", "problemId": "833574", "shortId": "1462E2", "contest_number": "1462", "name": "E2. Close Tuples  hard version ", "statement": "You are given a sequence  of length  consisting of integers from  to . .Find the number of tuples of  elements such that the maximum number in the tuple differs from the minimum by no more than . Formally, you need to find the number of tuples of  indices , such thatFor example, if , , , , then there are two such triples ( and ). If , , , , then all six possible pairs are suitable..", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. Then  test cases follow. The first line of each test case contains three integers , ,  (, , )\u00a0\u2014 the length of the sequence , number of elements in the tuples and the maximum difference of elements in the tuple. The next line contains  integers  ()\u00a0\u2014 the sequence . It is guaranteed that the sum of  for all test cases does not exceed .", "output": "Output  answers to the given test cases. Each answer is the required number of tuples of  elements modulo , such that the maximum value in the tuple differs from the minimum by no more than .", "tutorial": "The key idea that allows us to move from the previous version to this one is that the values of the numbers themselves are not important to us. The main idea is to consider all numbers in the interval $$$[x, x + k]$$$.Let's also, as in the previous version, iterate over the minimum element $$$x$$$ in the tuple. Now let's find the count of numbers $$$cnt$$$ that lie in the interval $$$[x, x + k]$$$ (this can be done with a binary search, two pointers, or prefix sums using an array of occurrences). Then it remains to add to the answer the number of ways to choose $$$m - 1$$$ numbers from $$$cnt - 1$$$ (we fixed one of the numbers as the minimum). You have to sum these values over all possible values of $$$x$$$ (even the same) because now you are not fixing the value of the minimum element (as in the previous problem), but its index in the sorted array.To calculate binomial coefficients quickly, you can pre-compute all factorial values and all $$$\\frac{1}{n!}$$$ values by modulo. If you do not know how to calculate the inverse element by modulo, then you could pre-compute the part of Pascal's triangle in $$$\\mathcal{O}(nm)$$$.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nconst int N = 300500;\nconst int mod = 1000000007;\nll fact[N];\nll invFact[N];\n\nll fast_pow(ll a, ll p) {\n    ll res = 1;\n    while (p) {\n        if (p % 2 == 0) {\n            a = (a * a) % mod;\n            p /= 2;\n        } else {\n            res = (res * a) % mod;\n            p--;\n        }\n    }\n    return res;\n}\n\nll C(int n, int k) {\n    if (k > n) {\n        return 0;\n    }\n    return fact[n] * invFact[k] % mod * invFact[n - k] % mod;\n}\n\nvoid solve() {\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<ll> v(n);\n    for (ll &e : v) {\n        cin >> e;\n    }\n    sort(v.begin(), v.end());\n    ll ans = 0;\n    for (int i = 0; i < n; i++) {\n        int l = i + 1;\n        int r = upper_bound(v.begin(), v.end(), v[i] + k) - v.begin();\n        ans = (ans + C(r - l, m - 1)) % mod;\n    }\n    cout << ans << \"\\n\";\n}\n\nint main() {\n    fact[0] = invFact[0] = 1;\n    for (int i = 1; i < N; i++) {\n        fact[i] = (fact[i - 1] * i) % mod;\n        invFact[i] = fast_pow(fact[i], mod - 2);\n    }\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}