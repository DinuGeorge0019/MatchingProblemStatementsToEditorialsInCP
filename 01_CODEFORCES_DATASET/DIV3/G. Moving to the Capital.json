{"link": "https://codeforces.com//contest/1472/problem/G", "problemId": "854357", "shortId": "1472G", "contest_number": "1472", "name": "G. Moving to the Capital", "statement": "There are  cities in Berland. The city numbered  is the capital. Some pairs of cities are connected by a  road of length 1.Before the trip, Polycarp for each city found out the value of \u00a0\u2014 the shortest distance from the capital (the -st city) to the -th city.Polycarp begins his journey in the city with number  and, being in the -th city, chooses one of the following actions:   Travel from the -th city to the -th city if there is a road from the -th city to the -th and ;  Travel from the -th city to the -th city if there is a road from the -th city to the -th and ;  Stop traveling. Since the government of Berland does not want all people to come to the capital, so Polycarp  can take the second action from the list. in other words, he can perform the second action  or  time during his journey. Polycarp, on the other hand, wants to be as close to the capital as possible.  For example, if  and the cities are connected, as in the picture above, then Polycarp could have made the following travels (not all possible options):   ;  ;  . Polycarp wants for each starting city  to find out how close he can get to the capital. More formally: he wants to find the minimal value of  that Polycarp can get from the city  to the city  according to the rules described above.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. Then  test cases follow. Each test case is preceded by an empty line. The first line of each test case contains two integers  () and  ()\u00a0\u2014 number of cities and roads, respectively. This is followed by  lines describing the roads. Each road is characterized by two integers  and  ()\u00a0\u2014 the numbers of cities connected by a  road. It is guaranteed that the sums of  and  over all test cases do not exceed . It is guaranteed that for each pair of different cities  there is at most one road from  to  (but a pair of roads from  to  and from  to \u00a0\u2014 is valid). It is guaranteed that there is a path from the capital to all cities.", "output": "For each test case, on a separate line output  numbers, the -th of which is equal to the minimum possible distance from the capital to the city where Polycarp ended his journey.", "tutorial": "Find the distances to all vertices and construct a new graph that has only edges that goes from a vertex with a smaller distance to a vertex with a larger distance. Such a graph cannot contain cycles.Next, you need to run a dynamic programming similar to finding bridges in an undirected graph. First, we write the minimum distance from each vertex to the capital using no more than one edge. This distance is either equal to the distance from the capital to the vertex itself, or the distance to the vertex connected to us by one of the remote edges. We can't go through more than one remote edge.The real answer for a vertex  is the minimum of such values in all vertices reachable from  in the new graph. Since the new graph is acyclic, we can calculate the answer using dynamic programming and a depth-first search started from the capital.", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> calcDist(vector<vector<int>> const &g) {\n  vector<int> dist(g.size(), -1);\n  dist[1] = 0;\n  queue<int> pq;\n  pq.push(1);\n  while (!pq.empty()) {\n    int u = pq.front();\n    pq.pop();\n    for (int v : g[u]) {\n      if (dist[v] == -1) {\n        dist[v] = dist[u] + 1;\n        pq.push(v);\n      }\n    }\n  }\n\n  return dist;\n}\n\nvoid dfs(int u, vector<vector<int>> const &g, vector<int> const &dist, vector<int> &dp, vector<bool> &used) {\n  used[u] = true;\n  dp[u] = dist[u];\n  for (int v : g[u]) {\n    if (!used[v] && dist[u] < dist[v]) {\n      dfs(v, g, dist, dp, used);\n    }\n\n    if (dist[u] < dist[v]) {\n      dp[u] = min(dp[u], dp[v]);\n    } else {\n      dp[u] = min(dp[u], dist[v]);\n    }\n  }\n}\n\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> g(n + 1);\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    g[u].push_back(v);\n  }\n\n  vector<int> dist = calcDist(g);\n  vector<int> dp(n + 1);\n  vector<bool> used(n + 1);\n  dfs(1, g, dist, dp, used);\n  for (int i = 1; i <= n; i++) {\n    cout << dp[i] << \" \";\n  }\n  cout << endl;\n}\n\nint main() {\n  int tests;\n  cin >> tests;\n  while (tests-- > 0) {\n    solve();\n  }\n  return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}