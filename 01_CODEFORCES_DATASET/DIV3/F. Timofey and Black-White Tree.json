{"link": "https://codeforces.com//contest/1790/problem/F", "problemId": "1753651", "shortId": "1790F", "contest_number": "1790", "name": "F. Timofey and Black-White Tree", "statement": "Timofey came to a famous summer school and found a tree on  vertices. A tree is a connected undirected graph without cycles.Every vertex of this tree, except , is colored . The vertex  is colored .Timofey wants to color all the vertices of this tree in . To do this, he performs  operations. During the -th operation, he selects the vertex , which is currently , and paints it .Let's call the  of tree the minimum distance between all pairs of different  vertices in it. The distance between the vertices  and  is the number of edges on the path from  to .After each operation, Timofey wants to know the  of the current tree.", "input": "The first line contains the integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains the integers  (, )\u00a0\u2014 the number of vertices in the tree and index of the initial  vertex. The second line of each testcase contains  unique integers  (, ), where  is the vertex which is colored  during the -th operation. Each of the next  row of each testcase contains the integers  ()\u00a0\u2014 edges in the tree. It is guaranteed that the sum of  for all testcases does not exceed .", "output": "For each testcase, print  integer on a separate line. The integer with index  must be equal to  of the tree obtained by the first  operations.", "tutorial": "Let's store for each vertex the minimum distance from it to the nearest  one, let's call it . We will also store the global answer, which for obvious reasons does not increase, we will call it .Let's now color the vertex , let's set  and run a depth first search from it. This DFS will visit  the vertices  with . Let us consider the vertex  and its neighbour . If we can relax  through , let's do it and start from . Otherwise,  has a closer  neighbour, let's try to update the answer through it . Also, do not forget to update the answer via  from all  vertices  that we visited.The correctness of the algorithm is obvious, let's evaluate its time complexity. It is easy to notice that after the first  operations, . We enter only the vertices,  from which, firstly, does not exceed , and secondly, was relaxed by the parent (that is, decreased by at least ).So, we allowed ourselves a complete tree bypassing for the first  operations, and then amortized performed no more than  operations. The final asymptotics will be .", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200200;\nconst int INF = 1e9;\n\nint n, ANS = INF;\nint crr[MAXN], dist[MAXN], res[MAXN];\nbool clr[MAXN];\nvector<int> gr[MAXN];\n\nvoid init() {\n\tANS = INF;\n\tfor (int v = 0; v < n; ++v)\n\t\tgr[v].clear();\n\tfill(dist, dist + n, INF);\n\tmemset(clr, 0, n);\n}\n\nvoid dfs(int v, int p) {\n\tif (dist[v] >= ANS) return;\n\tif (clr[v]) ANS = min(ANS, dist[v]);\n\tfor (int u: gr[v]) {\n\t\tif (u == p) continue;\n\t\tif (dist[v] + 1 < dist[u]) {\n\t\t\tdist[u] = dist[v] + 1;\n\t\t\tdfs(u, v);\n\t\t} else ANS = min(ANS, dist[v] + 1 + dist[u]);\n\t}\n}\n\nvoid solve() {\n\tdist[*crr] = 0;\n\tdfs(*crr, -1);\n\tclr[*crr] = true;\n\tfor (int i = 1; i < n; ++i) {\n\t\tdist[crr[i]] = 0;\n\t\tdfs(crr[i], -1);\n\t\tclr[crr[i]] = true;\n\t\tres[i] = ANS;\n\t}\n}\n\nint main() {\n\tint gorilla; cin >> gorilla;\n\twhile (gorilla--) {\n\t\tcin >> n >> *crr, --(*crr);\n\t\tinit();\n\t\tfor (int i = 1; i < n; ++i)\n\t\t\tcin >> crr[i], --crr[i];\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tint v, u; cin >> v >> u, --v, --u;\n\t\t\tgr[v].push_back(u);\n\t\t\tgr[u].push_back(v);\n\t\t}\n\t\tsolve();\n\t\tfor (int i = 1; i < n; ++i)\n\t\t\tcout << res[i] << ' ';\n\t\tcout << '\\n';\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}