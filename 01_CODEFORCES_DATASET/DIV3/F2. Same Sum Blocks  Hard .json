{"link": "https://codeforces.com//contest/1141/problem/F2", "problemId": "316176", "shortId": "1141F2", "contest_number": "1141", "name": "F2. Same Sum Blocks  Hard ", "statement": "You are given an array of integers  A  is a sequence of contiguous (consecutive) elements  (). Thus, a block is defined by a pair of indices .Find a set of blocks  such that:  They do not intersect (i.e. they are disjoint). Formally, for each pair of blocks  and ) where  either  or .  For each block the sum of its elements is the same. Formally,     The number of the blocks in the set is maximum. Formally, there does not exist a set of blocks  satisfying the above two requirements with .      Write a program to find such a set of blocks.", "input": "The first line contains integer  () \u2014 the length of the given array. The second line contains the sequence of elements  ().", "output": "In the first line print the integer  (). The following  lines should contain blocks, one per line. In each line print a pair of indices  () \u2014 the bounds of the -th block. You can print blocks in any order. If there are multiple answers, print any of them.", "tutorial": "Let's  the same sum of blocks in the answer. Obviously,  can be represented as a sum of some adjacent elements of , i.e.  for some  and .Iterate over all possible blocks in  and for each sum store all the blocks. You can use 'map<int, vector<pair<int,int\u00bb>' to store blocks grouped by a sum. You can do it with the following code:map<int, vector<pair<int,int>>> segs;for (int r = 0; r < n; r++) {    int sum = 0;                                  for (int l = r; l >= 0; l\u2013) {        sum += a[l];        segs[sum].push_back({l, r});    }}Note, that blocks are sorted by the right end in each group.After it you can independently try each group (there are  of them) and find the maximal disjoint set of blocks of a group. You can do it greedily, each time taking into the answer segment with the smallest right end. Since in each group they are ordered by the right end, you can find the required maximal disjoint block set with one pass. Let's assume  is the current group of blocks (they are ordered by the right end), then the following code constructs the maximal disjoint set:int cur = 0;int r = -1;vector<pair<int,int>> now;for (auto seg: pp)    if (seg.first > r) {        cur++;        now.push_back(seg);        r = seg.second;    }Choose the maximum among maximal disjoint sets for the groups.\n", "solution": "int n;\ncin >> n;\nvector<int> a(n);\nfor (int i = 0; i < n; i++)\n    cin >> a[i];\nmap<int, vector<pair<int,int>>> segs;\nfor (int r = 0; r < n; r++) {\n    int sum = 0;                              \n    for (int l = r; l >= 0; l--) {\n        sum += a[l];\n        segs[sum].push_back({l, r});\n    }\n}\nint result = 0;\nvector<pair<int,int>> best;\nfor (const auto& p: segs) {\n    const vector<pair<int,int>>& pp = p.second;\n    int cur = 0;\n    int r = -1;\n    vector<pair<int,int>> now;\n    for (auto seg: pp)\n        if (seg.first > r) {\n            cur++;\n            now.push_back(seg);\n            r = seg.second;\n        }\n    if (cur > result) {\n        result = cur;\n        best = now;\n    }\n}\ncout << result << endl;\nfor (auto seg: best)\n    cout << seg.first + 1 << \" \" << seg.second + 1 << endl;", "interactive": false, "noSolution": false, "noTutorial": false}