{"link": "https://codeforces.com//contest/1077/problem/E", "problemId": "256064", "shortId": "1077E", "contest_number": "1077", "name": "E. Thematic Contests", "statement": "Polycarp has prepared  competitive programming problems. The topic of the -th problem is , and some problems' topics may coincide.Polycarp has to host several thematic contests. All problems in each contest should have the same topic, and . He may not use all the problems. It is possible that there are no contests for some topics.Polycarp wants to host competitions on consecutive days, one contest per day. Polycarp wants to host a set of contests in such a way that:  number of problems in each contest is  as much as in the previous contest (one day ago), the first contest can contain arbitrary number of problems;  the total number of problems in all the contests should be maximized. Your task is to calculate the maximum number of problems in the set of thematic contests. Note, that you should not maximize the number of contests.", "input": "The first line of the input contains one integer  () \u2014 the number of problems Polycarp has prepared. The second line of the input contains  integers  () where  is the topic of the -th problem.", "output": "Print one integer \u2014 the maximum number of problems in the set of thematic contests.", "tutorial": "The first thing: we don't need the problems, we need their counts. So let's calculate for each topic the number of problems with this topic and sort them in non-decreasing order. The counting can be done with  or another one sorting.The second thing: the answer is not exceed  (very obviously). So let's iterate over the number of problems in maximum by the number of problems thematic contest. Now we have to calculate the maximum number of problems we can take in the set of thematic contests. Let's do it greedily.The number of contests in the set don't exceed . Let the number of problems in the current contest be  (at the beginning of iteration the current contest is the maximum by the number of problems). Let's take the topic with the maximum number of problems for this contest. If we cannot do it, stop the iteration. Otherwise we can (maybe) continue the iteration. If  is even then divide it by  and continue with the rest of topics, otherwise stop the iteration. Which topic we have to choose for the second one contest? The answer is: the topic with the maximum number of problems (which isn't chosen already). So let's carry the pointer  (initially it is at the end of the array of counts) and decrease it when we add another one contest to our set. All calculations inside the iteration are very obviously.Let's notice that one iteration spends at most  operations. So overall complexity of the solution is .The last question is: why can we take the maximum by the number of problems topic each time? Suppose we have two contests with numbers of problems  and , correspondingly. Let's consider the case when . Let the number of problems of the first contest topic be  and the number of problems of the second contest topic be . The case  don't break our assumptions. The only case which can break our assumptions is . So if it is then we can swap these topics (because  and ) and all will be okay. So this greedy approach works.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tmap<int, int> cnt;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++cnt[x];\n\t}\n\t\n\tvector<int> cnts;\n\tfor (auto it : cnt) {\n\t\tcnts.push_back(it.second);\n\t}\n\tsort(cnts.begin(), cnts.end());\n\t\n\tint ans = 0;\n\tfor (int i = 1; i <= cnts.back(); ++i) {\n\t\tint pos = int(cnts.size()) - 1;\n\t\tint cur = i;\n\t\tint res = cur;\n\t\twhile (cur % 2 == 0 && pos > 0) {\n\t\t\tcur /= 2;\n\t\t\t--pos;\n\t\t\tif (cnts[pos] < cur) break;\n\t\t\tres += cur;\n\t\t}\n\t\tans = max(ans, res);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}