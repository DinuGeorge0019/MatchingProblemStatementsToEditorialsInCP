{"link": "https://codeforces.com//contest/1790/problem/G", "problemId": "1753652", "shortId": "1790G", "contest_number": "1790", "name": "G. Tokens on Graph", "statement": "You are given an undirected connected graph, some vertices of which contain tokens and/or bonuses. Consider a game involving one player \u00a0\u2014 you.You can move tokens according to the following rules:  At the beginning of the game, you can make exactly one turn: move any token to any adjacent vertex.  If the movement of the token ended on the bonus, then you are allowed to make another turn with any  token. You can use different bonuses in any order. The same bonus can be used an unlimited number of times. Bonuses do not move during the game.There can be several tokens in one vertex at the same time, but initially there is no more than one token in each vertex.The vertex with number  is the finish vertex, and your task is to determine whether it is possible to hit it with any token by making turns with the tiles according to the rules described above. If a token is initially located at the vertex of , then the game is considered already won.      For example, for a given graph, you can reach the finish line with a chip from the th vertex by making the following sequence of turns:   Move from the -th vertex to the -th.  Move from the -th vertex to the -th.  Move from the -th vertex to the -th.  Move from the -th vertex to the -th.  Move from the -th vertex to the -nd.  Move from the -th vertex to the -th.  Move from the -nd vertex to the -st vertex, which is the finish. ", "input": "The first line of input data contains a single integer  ()\u00a0\u2014 number of test cases in the test. The descriptions of the test cases follow. The first line of the description of each test case contains two integers  and  (, )\u00a0\u2014 the number of vertices and edges in the graph, respectively. The second line of the description of each test case contains two integers  and  ()\u00a0\u2014 the number of tokens and bonuses, respectively. The third line of the description of each test case contains  different integers from  to  \u2014 the indices of the vertices in which the tokens are located. The fourth line of the description of each input data set contains  different integers from  to  \u2014 the indices of the vertices in which the bonuses are located. Note that the value of  can be equal to . In this case, this line is empty. There can be both a token and a bonus in one vertex at the same time. The next  lines of the description of each test case contain two integers  and  (, ) \u2014 vertices connected by the -th edge. There is at most one edge between each pair of vertices. The given graph is connected, that is, from any vertex you can get to any one by moving along the edges. The test cases are separated by an empty string. It is guaranteed that the sum of  over all test cases does not exceed . Similarly, it is guaranteed that the sum of  over all input data sets does not exceed .", "output": "For each test case, print  in a separate line if you can reach the finish with some token, and  otherwise. You can output  and  in any case (for example, the strings , ,  and  will be recognized as a positive response).", "tutorial": "Let's calculate the shortest paths to the finish along the vertices containing bonuses.We will try to reach the finish line with the chip that is closest to it, and mark it. If there is none, we lose.Other chips will give her extra moves.Find all connected components from vertices containing bonuses. Then, for each component, we find all the tokens that are not selected, located at the vertex of this component, and at the vertices adjacent to at least one vertex of this component.Consider the size of the connectivity component. If it is equal to , then the chip located in the neighboring vertex gives  an additional move. Otherwise, the chip located at the top of the component or at the neighboring vertex, as well as the selected chip, will be able to move indefinitely in turn, which gives us a victory. Otherwise, you need to count the number of extra moves and compare it with the shortest distance to the finish line.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<int> token(n), boni(n);\n    vector<vector<int>> g(n);\n    vector<int> good(n);\n    int m;\n    cin >> m;\n    int p, b;\n    cin >> p >> b;\n    for(int i = 0; i < p; i++)\n    {\n        int x;\n        cin >> x;\n        --x;\n        token[x] = 1;\n    }\n    for(int i = 0; i < b; i++)\n    {\n        int x;\n        cin >> x;\n        --x;\n        boni[x] = 1;\n    }\n    for(int i = 0; i < m; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        --x;\n        --y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    for(int i = 0; i < n; i++)\n        for(auto x : g[i])\n            if(boni[i] && boni[x]) good[i] = 1;\n    set<int> good_tokens;\n    set<int> not_so_good_tokens;\n    for(int i = 0; i < n; i++)\n        for(auto x : g[i])\n        {\n            if(token[i] && good[x]) good_tokens.insert(i);\n            else if(token[i] && boni[x]) not_so_good_tokens.insert(i);\n        }\n    vector<int> d(n, int(1e9));\n    queue<int> q;\n    d[0] = 0;\n    q.push(0);\n    while(!q.empty())\n    {\n        int k = q.front();\n        q.pop();\n        for(auto x : g[k])\n        {\n            if(d[x] > d[k] + 1)\n            {\n                d[x] = d[k] + 1;\n                if(boni[x]) q.push(x);\n            }\n        }\n    }\n    bool has_ans = false;\n    for(int i = 0; i < n; i++)\n    {\n        if(!token[i] || d[i] > n) continue;\n        has_ans |= (!good_tokens.empty() && (*good_tokens.begin() != i || *good_tokens.rbegin() != i));\n        int cnt = not_so_good_tokens.size();\n        if(not_so_good_tokens.count(i)) cnt--;\n        has_ans |= d[i] <= 1 + cnt;\n    }\n    cout << (has_ans ? \"YES\" : \"NO\") << endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    int tc = 1;\n    cin >> tc;\n    for(int i = 0; i < tc; i++)\n    {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}