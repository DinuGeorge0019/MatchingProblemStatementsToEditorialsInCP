{"link": "https://codeforces.com//contest/1800/problem/G", "problemId": "1805850", "shortId": "1800G", "contest_number": "1800", "name": "G. Symmetree", "statement": "Kid was gifted a tree of  vertices with the root in the vertex . Since he really like  objects, Kid wants to find out if this tree is .      Formally, a tree is  if there exists an order of children such that:  The subtree of the leftmost child of the root is a mirror image of the subtree of the rightmost child;  the subtree of the second-left child of the root is a mirror image of the subtree of the second-right child of the root;  ...  if the number of children of the root is odd, then the subtree of the middle child should be . ", "input": "The first line of input data contains single integer  ()\u00a0\u2014 the number of test cases in the test. The first line of each case contains an integer  ()\u00a0\u2014 the number of vertices in the tree. The following  lines contain two integers each  and  (, ) \u2014 indices of vertices connected by an edge. It is guaranteed that the sum of  over all cases does not exceed .", "output": "Output  strings, each of which is the answer to the corresponding test case. As an answer, output \"\" if this tree is , and \"\" otherwise. You can output the answer in any case (for example, the strings \"\", \"\", \"\" and \"\" will be recognized as a positive answer).", "tutorial": "Note that if one subtree is a mirror image of another, then they are isomorphic (that is, equal without taking into account the vertex numbers). To check the subtrees for isomorphism, we use .Now we just have to learn how to check trees for symmetry. To do this, let's calculate how many children of each type our vertex has (let's denote the hash of its subtree by the vertex type). In order for the vertex subtree to be symmetric, each child must have a pair of the same type, except perhaps one, which must also be symmetric. We can calculate the symmetry of the subtrees while counting their hash to simplify this task.", "solution": "#include <bits/stdc++.h>\n\n#define int long long\n#define pb emplace_back\n#define mp make_pair\n#define x first\n#define y second\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n\ntypedef long double ld;\ntypedef long long ll;\n\nusing namespace std;\n\nmt19937 rnd(time(nullptr));\n\nconst int inf = 2e18;\nconst ll M = 1e9;\nconst ld pi = atan2(0, -1);\nconst ld eps = 1e-6;\n\nint last;\nmap<vector<int>, int> eq;\nmap<int, bool> symmetrical;\n\nint dfs(int v, int p, vector<vector<int>> &sl){\n    vector<int> children;\n    for(int u: sl[v]){\n        if(u == p) continue;\n        children.emplace_back(dfs(u, v, sl));\n    }\n    sort(all(children));\n    if(!eq.count(children)){\n        map<int, int> cnt;\n        for(int e: children){\n            cnt[e]++;\n        }\n        int odd = 0, bad = 0;\n        for(auto e: cnt){\n            if(e.y & 1){\n                odd++;\n                bad += !symmetrical[e.x];\n            }\n        }\n        eq[children] = last;\n        symmetrical[last] = odd < 2 && bad == 0;\n        last++;\n    }\n    return eq[children];\n}\n\nvoid solve(int tc){\n    int n;\n    cin >> n;\n    eq.clear();\n    symmetrical.clear();\n    eq[vector<int>(0)] = 0;\n    symmetrical[0] = true;\n    last = 1;\n    vector<vector<int>> sl(n);\n    for(int i = 1; i < n; ++i){\n        int u, v;\n        cin >> u >> v;\n        sl[--u].emplace_back(--v);\n        sl[v].emplace_back(u);\n    }\n    cout << (symmetrical[dfs(0, 0, sl)]? \"YES\" : \"NO\");\n}\n\nbool multi = true;\n\nsigned main() {\n    int t = 1;\n    if (multi)cin >> t;\n    for (int i = 1; i <= t; ++i) {\n        solve(i);\n        cout << \"\\n\";\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}