{"link": "https://codeforces.com//contest/1409/problem/E", "problemId": "716928", "shortId": "1409E", "contest_number": "1409", "name": "E. Two Platforms", "statement": "There are  points on a plane. The -th point has coordinates . You have two horizontal platforms, both of length . Each platform can be placed anywhere on a plane but it should be placed  (on the same -coordinate) and have . If the left border of the platform is  then the right border is  and all points between borders (including borders) belong to the platform.Note that platforms can share common points (overlap) and it is not necessary to place both platforms on the same -coordinate.When you place both platforms on a plane, all points start falling down decreasing their -coordinate. If a point collides with some platform at some moment, the point stops and is . Points which never collide with any platform are lost.Your task is to find the maximum number of points you can  if you place both platforms optimally.You have to answer  independent test cases.For better understanding, please read the  section below to see a picture for the first test case.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains two integers  and  (; ) \u2014 the number of points and the length of each platform, respectively. The second line of the test case contains  integers  (), where  is -coordinate of the -th point. The third line of the input contains  integers  (), where  is -coordinate of the -th point. All points are distinct (there is no pair  such that  and ). It is guaranteed that the sum of  does not exceed  ().", "output": "For each test case, print the answer: the maximum number of points you can save if you place both platforms optimally.", "tutorial": "Firstly, we obviously don't need -coordinates at all because we can place both platforms at . Let's sort all -coordinates in non-decreasing order.Calculate for each point  two values  and , where  is the number of points to the left from the point  (including ) that are not further than  from the -th point (i.e. the number of such points  that ). And  is the number of points to the right from the point  (including ) that are not further than  from the -th point. Both these parts can be done in  using two pointers.Then let's build suffix maximum array on  and prefix maximum array on . For , just iterate over all  from  to  and do . For , just iterate over all  from  to  and do .The question is: what? What did we do? We did the following thing: the answer always can be represented as two non-intersecting segments of length  such that at least one endpoint of each segment is some input point ( ). Now, let's fix this border between segments. Iterate over all  from  to  and update the answer with . So we took  segment that starts at some point to the left from  (including ) and goes to the left and took some segment that starts further than  (including ) and goes to the right. With this model, we considered all optimal answers that can exist.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tvector<int> x(n), y(n);\n\t\tfor (auto &it : x) cin >> it;\n\t\tfor (auto &it : y) cin >> it;\n\t\tsort(x.begin(), x.end());\n\t\tint j = n - 1;\n\t\tvector<int> l(n), r(n);\n\t\tfor (int i = n - 1; i >= 0; --i) {\n\t\t\twhile (x[j] - x[i] > k) --j;\n\t\t\tr[i] = j - i + 1;\n\t\t\tif (i + 1 < n) r[i] = max(r[i], r[i + 1]);\n\t\t}\n\t\tj = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\twhile (x[i] - x[j] > k) ++j;\n\t\t\tl[i] = i - j + 1;\n\t\t\tif (i > 0) l[i] = max(l[i], l[i - 1]);\n\t\t}\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tans = max(ans, r[i + 1] + l[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}