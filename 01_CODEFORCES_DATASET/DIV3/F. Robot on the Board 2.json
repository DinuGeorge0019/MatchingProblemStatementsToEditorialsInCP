{"link": "https://codeforces.com//contest/1607/problem/F", "problemId": "1168763", "shortId": "1607F", "contest_number": "1607", "name": "F. Robot on the Board 2", "statement": "The robot is located on a checkered rectangular board of size  ( rows,  columns). The rows in the board are numbered from  to  from top to bottom, and the columns\u00a0\u2014 from  to  from left to right.The robot is able to move from the current cell to one of the four cells adjacent by side.Each cell has one of the symbols '', '', '' or '' written on it, indicating the direction in which the robot will move when it gets in that cell\u00a0\u2014 left, right, down or up, respectively.The robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move.   If the robot moves beyond the edge of the board, it falls and breaks.  If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).", "input": "The first line contains an integer  ()\u00a0\u2014 the number of test cases in the test. Each test case's description is preceded by a blank line. Next is a line that contains integers  and  (; )\u00a0\u2014 the height and width of the board. This line followed by  lines, the -th of which describes the -th line of the board. Each of them is exactly  letters long and consists of symbols '', '', '' and ''. It is guaranteed that the sum of sizes of all boards in the input does not exceed .", "output": "For each test case, output three integers ,  and  (; ; ), which denote that the robot should start moving from cell  to make the maximum number of moves . If there are several answers, output any of them.", "tutorial": "Let's start moving from an arbitrary cell of the table, for example, from . Movement from each cell is specified by the direction given in that cell, so you can run a loop with a stopping condition \"exit from the board border or get to the already visited cell\". Create a separate array \u00a0\u2014 how many commands the robot will execute, starting the movement from the cell ; we will also use it to check whether the cell has already been visited or not (not visited if  is not yet positive).Finishing the movement from  let's consider two cases.   Either we have gone beyond the boundary of the array, then we can say for sure that for the -th cell from the end of the sequence  the answer is .  Or we came to the already visited cell, let it be the -th from the end in our path. Then at the end of the path, there is a cycle of length : starting the movement at any cell of this cycle, the robot will walk exactly  steps until it arrives at the already visited cell. Thus, for  distance will be equal to , and for all others it will be, as in the first case, . Let us run the same algorithm from the next cell, which we have not yet considered. There will be three cases of robot stopping the execution of the commands: the first two repeat those already considered above, and the third case is that the robot will come to the cell  already visited on some of the previous iterations of our algorithm. In this case we know that starting from , the robot will make exactly  steps, so for the -th cell from the end on the current path  will hold. The first two cases are handled completely in the same way as described above. Each of the cases is eventually reduced to another iteration over the cells visited in the current path. Let's visit all the cells in reverse and mark all values of .Such algorithm is enough to repeat until each cell is processed, after which for each cell of the table its  will be known and we'll only have to choose the maximal value of  among all .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        vector<string> dir(n);\n        for (int i = 0; i < n; i++)\n            cin >> dir[i];\n\n        vector<vi> res(n, vi(m, 0));\n        int opt = 0, optr = 0, optc = 0;\n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < m; c++) {\n                if (res[r][c] > 0)\n                    continue;\n\n                int nr = r, nc = c;\n                int depth = 0;\n                vector<pii> path;\n                auto ok = [&n, &m](int row, int col) {\n                    return row > -1 && row < n && col > -1 && col < m;\n                };\n\n                do {\n                    res[nr][nc] = --depth;\n                    path.emplace_back(nr, nc);\n                    if (dir[nr][nc] == 'L')\n                        nc--;\n                    else if (dir[nr][nc] == 'R')\n                        nc++;\n                    else if (dir[nr][nc] == 'U')\n                        nr--;\n                    else\n                        nr++;\n                } while (ok(nr, nc) && res[nr][nc] == 0);\n\n                int start = 1;\n                if (ok(nr, nc)) {\n                    if (res[nr][nc] < 0) {\n                        int cycle = res[nr][nc] - depth + 1;\n                        for (int i = 0; i < cycle; i++) {\n                            auto p = path.back();\n                            path.pop_back();\n                            res[p.first][p.second] = cycle;\n                        }\n                    }\n                    start = res[nr][nc] + 1;\n                }\n                while (!path.empty()) {\n                    auto p = path.back();\n                    path.pop_back();\n                    res[p.first][p.second] = start++;\n                }\n\n                if (res[r][c] > opt) {\n                    opt = res[r][c];\n                    optr = r;\n                    optc = c;\n                }\n            }\n        }\n\n        cout << optr + 1 << ' ' << optc + 1 << ' ' << opt << '\\n';\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}