{"link": "https://codeforces.com//contest/999/problem/E", "problemId": "192344", "shortId": "999E", "contest_number": "999", "name": "E. Reachability from the Capital", "statement": "There are  cities and  roads in Berland. Each road connects a pair of cities. The roads in Berland are one-way.What is the minimum number of new roads that need to be built to make all the cities reachable from the capital?New roads will also be one-way.", "input": "The first line of input consists of three integers ,  and  () \u2014 the number of cities, the number of roads and the index of the capital. Cities are indexed from  to . The following  lines contain roads: road  is given as a pair of cities ,  (, ). For each pair of cities , there can be at most one road from  to . Roads in opposite directions between a pair of cities are allowed (i.e. from  to  and from  to ).", "output": "Print one integer \u2014 the minimum number of extra roads needed to make all the cities reachable from city . If all the cities are already reachable from , print .", "tutorial": "This problem is (almost) equivalent to the following: count the number of sources (the vertices with indegree equal to ) in the given graph's condensation. Thus, there exist solutions with complexity . However, the constraints in the problem are small, so solutions with complexity  also pass.One of these solutions is the following: first, let's mark all the vertices reachable from  as , using a simple DFS. Then, for each bad vertex , count the number of  vertices reachable from  (it also can be done by simple DFS). Let this number be . Now, iterate over all bad vertices in non-increasing order of . For the current bad vertex , if it is still not marked as , run a DFS from it, marking all the reachable vertices as , and increase the answer by  (in fact, we are implicitly adding the edge ). It can be proved that this solution gives an optimal answer.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\t\n\tdfs1(s);\n\t\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\t\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}