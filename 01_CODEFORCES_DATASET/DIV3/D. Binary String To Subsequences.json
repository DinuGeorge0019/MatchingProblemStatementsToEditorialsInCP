{"link": "https://codeforces.com//contest/1399/problem/D", "problemId": "691719", "shortId": "1399D", "contest_number": "1399", "name": "D. Binary String To Subsequences", "statement": "You are given a binary string  consisting of  zeros and ones.Your task is to divide the given string into the  number of  in such a way that  of the string belongs to exactly  and each subsequence looks like \"\" or \"\" (i.e. the subsequence should not contain two adjacent zeros or ones).Recall that a subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements. For example, subsequences of \"\" are \"\", \"\", \"\", \"\", \"\", \"\", but not \"\", \"\" and \"\".You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the length of . The second line of the test case contains  characters '' and '' \u2014 the string . It is guaranteed that the sum of  does not exceed  ().", "output": "For each test case, print the answer: in the first line print one integer  () \u2014 the minimum number of subsequences you can divide the string  to. In the second line print  integers  (), where  is the number of subsequence the -th character of  belongs to. If there are several answers, you can print any.", "tutorial": "Let's iterate over all characters of  from left to right, maintaining two arrays  and , where  stores indices of all subsequences which end with '' and  stores indices of all subsequences which end with ''. If we met '', then the best choice is to append it to some existing subsequence which ends with ''. If there are no such sequences, we need to create new one which ends with ''. Otherwise we need to convert one of ''-sequences to ''-sequence. The same works with characters ''. So, when we don't need to create the new sequence, we try to don't do that. And values in arrays  and  help us to determine the number of sequence we assign to each character.And also, there is a cute proof of this solution from Gassa: let  be the difference between the number of '' and the number of '' on the prefix of  of length . We claim that the answer is  and let's show why is it true. Let's build a function on a plane with points . Then we can match each  between  and  with some subsequence.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tstring s;\n\t\tcin >> n >> s;\n\t\tvector<int> ans(n);\n\t\tvector<int> pos0, pos1;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint newpos = pos0.size() + pos1.size();\n\t\t\tif (s[i] == '0') {\n\t\t\t\tif (pos1.empty()) {\n\t\t\t\t\tpos0.push_back(newpos);\n\t\t\t\t} else {\n\t\t\t\t\tnewpos = pos1.back();\n\t\t\t\t\tpos1.pop_back();\n\t\t\t\t\tpos0.push_back(newpos);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (pos0.empty()) {\n\t\t\t\t\tpos1.push_back(newpos);\n\t\t\t\t} else {\n\t\t\t\t\tnewpos = pos0.back();\n\t\t\t\t\tpos0.pop_back();\n\t\t\t\t\tpos1.push_back(newpos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans[i] = newpos;\n\t\t}\n\t\tcout << pos0.size() + pos1.size() << endl;\n\t\tfor (auto it : ans) cout << it + 1 << \" \";\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}