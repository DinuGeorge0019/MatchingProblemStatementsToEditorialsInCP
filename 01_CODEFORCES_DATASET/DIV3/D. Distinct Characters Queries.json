{"link": "https://codeforces.com//contest/1234/problem/D", "problemId": "426514", "shortId": "1234D", "contest_number": "1234", "name": "D. Distinct Characters Queries", "statement": "You are given a string  consisting of lowercase Latin letters and  queries for this string.Recall that the substring  of the string  is the string . For example, the substrings of \"\" are \"\", \"\", \"\", \"\", but not \"\" and \"\".There are two types of queries:    (,  is lowercase Latin letter): replace  with  (set );   (): calculate the number of distinct characters in the substring . ", "input": "The first line of the input contains one string  consisting of no more than  lowercase Latin letters. The second line of the input contains one integer  () \u2014 the number of queries. The next  lines contain queries, one per line. Each query is given in the format described in the problem statement. It is guaranteed that there is at least one query of the second type.", "output": "For each query of the second type print the answer for it \u2014 the number of distinct characters in the required substring in this query.", "tutorial": "Let's store for each letter all positions in which it appears in some data structure. We need such a data structure that can add, remove and find the next element greater than or equal to our element, fast enough. Suddenly, this data structure is  again (in C++).When we meet the first type query, let's just modify two elements of corresponding sets (one remove, one add). When we meet the second type query, let's iterate over all letters. If the current letter is in the segment  then the first element greater than or equal to  in the corresponding set should exist and be less than or equal to . If it is so, let's increase the answer by one. After iterating over all letters just print the answer.Time complexity: , when  is the size of the alphabet.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tstring s;\n\tcin >> s;\n\tvector<set<int>> poss(26);\n\tfor (int i = 0; i < int(s.size()); ++i) {\n\t\tposs[s[i] - 'a'].insert(i);\n\t}\n\t\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint tp;\n\t\tcin >> tp;\n\t\tif (tp == 1) {\n\t\t\tint pos;\n\t\t\tchar c;\n\t\t\tcin >> pos >> c;\n\t\t\t--pos;\n\t\t\tposs[s[pos] - 'a'].erase(pos);\n\t\t\ts[pos] = c;\n\t\t\tposs[s[pos] - 'a'].insert(pos);\n\t\t} else {\n\t\t\tint l, r;\n\t\t\tcin >> l >> r;\n\t\t\t--l, --r;\n\t\t\tint cnt = 0;\n\t\t\tfor (int c = 0; c < 26; ++c) {\n\t\t\t\tauto it = poss[c].lower_bound(l);\n\t\t\t\tif (it != poss[c].end() && *it <= r) ++cnt;\n\t\t\t}\n\t\t\tcout << cnt << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}