{"link": "https://codeforces.com//contest/1611/problem/E2", "problemId": "1202189", "shortId": "1611E2", "contest_number": "1611", "name": "E2. Escape The Maze  hard version ", "statement": ".Vlad built a maze out of  rooms and  bidirectional corridors. From any room  any other room  can be reached through a sequence of corridors. Thus, the room system forms an undirected tree.Vlad invited  friends to play a game with them.Vlad starts the game in the room  and wins if he reaches a room other than , into which exactly one corridor leads. Friends are placed in the maze: the friend with number  is in the room , and no two friends are in the same room (that is,  for all ). Friends win if one of them meets Vlad in any room or corridor before he wins.For one unit of time, each participant of the game can go through one corridor. All participants move at the same time. Participants may not move. Each room can fit all participants at the same time.Friends know the plan of a maze and intend to win. They don't want to waste too much energy. They ask you to determine if they can win and if they can, what  number of friends must remain in the maze so that they can always catch Vlad.In other words, you need to determine the size of the minimum (by the number of elements) subset of friends who can catch Vlad or say that such a subset does not exist.", "input": "The first line of the input contains an integer  () \u2014 the number of test cases in the input. The input contains an empty string before each test case. The first line of the test case contains two numbers  and  () \u2014 the number of rooms and friends, respectively. The next line of the test case contains  integers  () \u2014 numbers of rooms with friends. All  are different. The next  lines contain descriptions of the corridors, two numbers per line  and  () \u2014 numbers of rooms that connect the  corridor. All corridors are bidirectional. From any room, you can go to any other by moving along the corridors. It is guaranteed that the sum of the values  over all test cases in the test is not greater than .", "output": "Print  lines, each line containing the answer to the corresponding test case. The answer to a test case should be  if Vlad wins anyway and a minimal number of friends otherwise.", "tutorial": "Let's learn how to find an answer for the subtree rooted in vertex . At first, it is obvious from E1 tutorial that if the nearest to  vertex with a friend from this subtree is no further from it than the root of the entire tree from , then the answer for the entire subtree is  since a friend can come to  and catch Vlad in it not allowing him to go to any leaf of this subtree. Else we will find the answer leaning on its children. If a solution does not exist for at least one child, then it does not exist for the entire subtree, because after reaching  Vlad will be able to go to such child and reach any exit. Otherwise, the answer for  is the sum of the answers of its children, since we need to beat it in each subtree to win, and for each subtree, we have found the minimum answer.", "solution": "#include <bits/stdc++.h>\n \n#define int long long\n#define mp make_pair\n#define x first\n#define y second\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n \n/*#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native\")\n#pragma GCC optimize(\"fast-math\")\n*/\ntypedef long double ld;\ntypedef long long ll;\n \nusing namespace std;\n \nmt19937 rnd(143);\n \nconst int inf = 1e10;\nconst int M = 998244353;\nconst ld pi = atan2(0, -1);\nconst ld eps = 1e-4;\n \nvector<vector<int>> sl;\nvector<int> nearest;\n \nint count(int v, int dist, int p = -1){\n    bool children = true;\n    int s = 0;\n    for(int u: sl[v]){\n        if(u == p) continue;\n        int c = count(u, dist + 1, v);\n        if(c < 0) children = false;\n        nearest[v] = min(nearest[v], nearest[u] + 1);\n        s += c;\n    }\n    if(nearest[v] <= dist) return 1;\n    if(s == 0 || !children) return -1;\n    return s;\n}\n \nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    sl.assign(n, vector<int>(0));\n    nearest.assign(n, n);\n    for(int i = 0; i < k; ++i){\n        int x;\n        cin >> x;\n        --x;\n        nearest[x] = 0;\n    }\n    for(int i = 1; i  < n; ++i){\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        sl[u].emplace_back(v);\n        sl[v].emplace_back(u);\n    }\n    cout << count(0, 0);\n}\n \nbool multi = true;\n \nsigned main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"in.txt\", \"w\", stdout);\n    /*ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);*/\n    int t = 1;\n    if (multi) {\n        cin >> t;\n    }\n    for (; t != 0; --t) {\n        solve();\n        cout << \"\\n\";\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}