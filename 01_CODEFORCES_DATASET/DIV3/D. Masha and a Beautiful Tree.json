{"link": "https://codeforces.com//contest/1741/problem/D", "problemId": "1580860", "shortId": "1741D", "contest_number": "1741", "name": "D. Masha and a Beautiful Tree", "statement": "The girl named Masha was walking in the forest and found a complete binary tree of height  and a permutation  of length .A complete binary tree of height  is a rooted tree such that every vertex except the leaves has exactly two sons, and the length of the path from the root to any of the leaves is . The picture below shows the complete binary tree for .A permutation is an array consisting of  different integers from  to . For example, [] is a permutation, but [] is not ( occurs twice), and [] is also not a permutation (, but there is  in the array).Let's enumerate  leaves of this tree from left to right. The leaf with the number  contains the value  ().For example, if , , the tree will look like this:  Masha considers a tree  if the values in its leaves are ordered from left to right in increasing order.In one operation, Masha can choose any non-leaf vertex of the tree and swap its left and right sons (along with their subtrees).For example, if Masha applies this operation to the root of the tree discussed above, it will take the following form:  Help Masha understand if she can make a tree  in a certain number of operations. If she can, then output the minimum number of operations to make the tree .", "input": "The first line contains single integer  ()\u00a0\u2014 number of test cases. In each test case, the first line contains an integer  (), which is a power of two \u00a0\u2014 the size of the permutation . The second line contains  integers:  ()\u00a0\u2014 the permutation . It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case in a separate line, print the minimum possible number of operations for which Masha will be able to make the tree  or , if this is not possible.", "tutorial": "Let some vertex be responsible for a segment of leaves . Then her left son is responsible for the segment , and the right for the segment . Note that if we do not apply the operation to this vertex, then it will not be possible to move some element from the right son's segment to the left son's segment. It remains to understand when we need to apply the operation to the vertex. Let the maximum on the segment  be , the minimum on the same segment is . Then if  lies in the right son, and  in the left, then we should obviously apply the operation, for the reason described above. In the case when  lies in the left son, and  in the right, the application of the operation will definitely not allow you to get a solution. Let's continue to act in a similar way recursively from the children of the current vertex. At the end, we should check whether we have received a sorted permutation. The above solution works for , since there are  levels in the tree and at each level, vertexes are responsible for  sheets in total. You can optimize this solution to  if you pre-calculate the maximum and minimum for each vertex.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXM = 300300;\n\nint n, m;\nint arr[MAXM];\n\nint solve(int l, int r) {\n\tif (r - l == 1) return 0;\n\tint mid = (l + r) >> 1;\n\tint mal = *max_element(arr + l, arr + mid);\n\tint mar = *max_element(arr + mid, arr + r);\n\tint ans = 0;\n\tif (mal > mar) {\n\t\t++ans;\n\t\tfor (int i = 0; i < (mid - l); ++i)\n\t\t\tswap(arr[l + i], arr[mid + i]);\n\t}\n\treturn solve(l, mid) + solve(mid, r) + ans;\n}\n\nint solve() {\n\tint ans = solve(0, m);\n\tif (is_sorted(arr, arr + m))\n\t\treturn ans;\n\treturn -1;\n}\n\nint main() {\n\tint t; cin >> t;\n\twhile (t--) {\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; ++i)\n\t\t\tcin >> arr[i];\n\t\tcout << solve() << endl;\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}