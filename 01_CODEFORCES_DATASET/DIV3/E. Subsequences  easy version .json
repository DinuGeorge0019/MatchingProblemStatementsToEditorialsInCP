{"link": "https://codeforces.com//contest/1183/problem/E", "problemId": "363545", "shortId": "1183E", "contest_number": "1183", "name": "E. Subsequences  easy version ", "statement": ".A subsequence is a string that can be derived from another string by deleting some or no symbols without changing the order of the remaining symbols. Characters to be deleted are not required to go successively, there can be any gaps between them. For example, for the string \"\" the following strings are subsequences: \"\", \"\", \"\", \"\" and \"\" (empty string). But the following strings are not subsequences: \"\", \"\" and \"\".You are given a string  consisting of  lowercase Latin letters.In one move you can take  subsequence  of the given string and add it to the set . The set  can't contain duplicates. This move costs , where  is the length of the added subsequence (i.e. the price equals to the number of the deleted characters).Your task is to find out the minimum possible total cost to obtain a set  of size  or report that it is impossible to do so.", "input": "The first line of the input contains two integers  and  () \u2014 the length of the string and the size of the set, correspondingly. The second line of the input contains a string  consisting of  lowercase Latin letters.", "output": "Print one integer \u2014 if it is impossible to obtain the set  of size , print . Otherwise, print the minimum possible total cost to do it.", "tutorial": "The topic of this problem is BFS. Let strings be the vertices of the graph and there is a directed edge from string  to string  if and only if we can obtain  from  by removing exactly one character.In this interpretation we have to find first  visited vertices if we start our BFS from the initial string. And then the answer will be just  minus the sum of length of visited strings. The last thing to mention: instead of standard queue of integers we need to maintain the queue of strings and instead of array of visited vertices we have to maintain the set of visited strings. Don't forget to stop BFS when you obtain exactly  strings.If the number of distinct subsequences is less than  then the answer is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\t\n\tint ans = 0;\n\tqueue<string> q;\n\tset<string> st;\n\tq.push(s);\n\tst.insert(s);\n\twhile (!q.empty() && int(st.size()) < k) {\n\t\tstring v = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < int(v.size()); ++i) {\n\t\t\tstring nv = v;\n\t\t\tnv.erase(i, 1);\n\t\t\tif (!st.count(nv) && int(st.size()) + 1 <= k) {\n\t\t\t\tq.push(nv);\n\t\t\t\tst.insert(nv);\n\t\t\t\tans += n - nv.size();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (int(st.size()) < k) cout << -1 << endl;\n\telse cout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}