{"link": "https://codeforces.com//contest/1611/problem/D", "problemId": "1202187", "shortId": "1611D", "contest_number": "1611", "name": "D. Weights Assignment For Tree Edges", "statement": "You are given a rooted tree consisting of  vertices. Vertices are numbered from  to . Any vertex can be the root of a tree.A  is a connected undirected graph without cycles. A  is a tree with a selected vertex, which is called the .The tree is specified by an array of ancestors  containing  numbers:  is an ancestor of the vertex with the number . The  of a vertex  is a vertex that is the next vertex on a simple path from  to the root. For example, on the simple path from  to  (the root), the next vertex would be , so the ancestor of  is .The root has no ancestor, so for it, the value of  is  (the root is the only vertex for which ).For example, if  and , then the tree looks like this.     You are given an array \u00a0\u2014 a permutation of the vertices of the tree. If it is possible, assign any  integer weights on the edges, so that the vertices sorted by distance from the root would form the given permutation .In other words, for a given permutation of vertices , it is necessary to choose such edge weights so that the condition  is true for each  from  to .  is a sum of the weights of the edges on the path from the root to . In particular,  if the vertex  is the root of the tree.For example, assume that . In this case, the following edge weights satisfy this permutation:  the edge () has a weight of ;  the edge () has weight of ;  the edge () has a weight of ;  the edge () has a weight of . The array of distances from the root looks like: . The vertices sorted by increasing the distance from the root form the given permutation .Print the required edge weights or determine that there is no suitable way to assign weights. If there are several solutions, then print any of them.", "input": "The first line of input data contains an integer  () \u2014 the number of input data sets in the test. Each test case consists of three lines. The first of them contains an integer  (). It is the number of vertices in the tree. The second line contains  integers  (). It is guaranteed that the  array encodes some rooted tree. The third line contains the given permutation :  of different integers  (). It is guaranteed that the sum of the values  over all test cases in the test does not exceed .", "output": "For each set of input data print the answer on a separate line. If the solution exists, print an array of  integers , where  is the weight of the edge that leads from  to . For the root there is no such edge, so use the value . For all other vertices, the values of  must satisfy the inequality . There can be equal numbers among  values, but all sums of weights of edges from the root to vertices must be different and satisfy the given permutation. If there are several solutions, output any of them. If no solution exists, output .", "tutorial": "Consider the cases when it is impossible to form a given permutation :1. . For root  it is true that . For any other vertex  the value of  will be positive, since there is at least one edge of positive weight on the path to it.2. . In a rooted tree there is exactly one path from the root to any vertex , and it goes through its parent , so it must always be true .Let us start filling the array , where . Consider a vertex , (). The vertex whose distance at the current time is maximal is . Then  is at least . We assign a value to , remembering to check that  has already been counted.After counting all  values, we can output the lengths of the edges: .", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nvoid solve(){\n    int n;\n    cin >> n;\n    vector<int> b(n + 1), p(n + 1), dist(n + 1, -1);\n \n    for(int i = 1; i <= n; i++)\n        cin >> b[i];\n    for(int i = 1; i <= n; i++)\n        cin >> p[i];\n \n    if (b[p[1]] != p[1]){\n        cout << -1 << '\\n';\n        return;\n    }\n \n    dist[p[1]] = 0;\n    for(int i = 2; i <= n; i++){\n        if(dist[b[p[i]]] == -1){\n            cout << -1 << '\\n';\n            return;\n        }\n        dist[p[i]] = dist[p[i - 1]] + 1;\n    }\n \n    for(int i = 1; i <= n; i++) {\n        cout << dist[i] - dist[b[i]] << ' ';\n    }\n    cout << '\\n';\n}\n \nint main() {\n    int t;\n    cin >> t;\n    while(t-- > 0) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}