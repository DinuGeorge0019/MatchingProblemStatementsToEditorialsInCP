{"link": "https://codeforces.com//contest/1006/problem/F", "problemId": "198030", "shortId": "1006F", "contest_number": "1006", "name": "F. Xor-Paths", "statement": "There is a rectangular grid of size . Each cell has a number written on it; the number on the cell () is . Your task is to calculate the number of paths from the upper-left cell () to the bottom-right cell () meeting the following constraints:  You can move to the right or to the bottom only. Formally, from the cell () you may move to the cell () or to the cell (). The target cell can't be outside of the grid.  The  of all the numbers on the path from the cell () to the cell () must be equal to  ( operation is the bitwise exclusive OR, it is represented as '' in Java or C++ and \"\" in Pascal). Find the number of such paths in the given grid.", "input": "The first line of the input contains three integers ,  and  (, ) \u2014 the height and the width of the grid, and the number . The next  lines contain  integers each, the -th element in the -th line is  ().", "output": "Print one integer \u2014 the number of paths from () to () with  sum equal to .", "tutorial": "This is a typical problem on the  technique.The number of moves we will made equals . So if  would be small enough (25 is the upper bound, I think), then we can just run recursive backtracking in  or in  to iterate over all binary masks of lengths  containing exactly  ones and check each path described by such mask ( in this mask is the move to the bottom and  is the move to the right) if its  is .But it is too slow. So let's split this mask of  bits into two parts \u2014 the left part will consist of  bits and the right part will consist of  bits. Note that each left mask (and each right mask too) uniquely describes the endpoint of the path and the path itself.Let's carry  associative arrays  where  for the endpoint  and   will denote the number of paths which end in the cell  having  .Let's run recursive backtracking which will iterate over paths starting from the cell  and move to the right or to the bottom and maintain  of the path. If we made  moves and we are currently in the cell  with   right now, set  and return from the function. Otherwise try to move to the bottom or to the right changing  as needed.Let's run another recursive backtracking which will iterate over paths starting from the cell  and move to the left or to the top and maintain  of the path except the last cell. The same, if we made  moves and we are currently in the cell  with   right now, let's add  to the answer (obvious, that way we \"complement\" our  from the right part of the path with the suitable  from the left part of the path). Otherwise try to move to the left or to the top changing  as needed.So, this is the  technique (at least the way I code it).Overall complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 20;\n\nmap<long long, int> v[N][N];\n\nint n, m;\nint half;\nlong long k;\nlong long a[N][N];\nlong long ans;\n\nvoid calclf(int x, int y, long long val, int cnt) {\n\tval ^= a[x][y];\n\tif (cnt == half) {\n\t\t++v[x][y][val];\n\t\treturn;\n\t}\n\tif (x + 1 < n)\n\t\tcalclf(x + 1, y, val, cnt + 1);\n\tif (y + 1 < m)\n\t\tcalclf(x, y + 1, val, cnt + 1);\n}\n\nvoid calcrg(int x, int y, long long val, int cnt) {\n\tif (cnt == n + m - 2 - half) {\n\t\tif (v[x][y].count(k ^ val))\n\t\t\tans += v[x][y][k ^ val];\n\t\treturn;\n\t}\n\tif (x > 0)\n\t\tcalcrg(x - 1, y, val ^ a[x][y], cnt + 1);\n\tif (y > 0)\n\t\tcalcrg(x, y - 1, val ^ a[x][y], cnt + 1);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> k;\n\thalf = (n + m - 2) / 2;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\t\n\tcalclf(0, 0, 0, 0);\n\tcalcrg(n - 1, m - 1, 0, 0);\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}