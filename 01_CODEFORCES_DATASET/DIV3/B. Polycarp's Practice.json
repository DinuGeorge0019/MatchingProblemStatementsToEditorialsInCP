{"link": "https://codeforces.com//contest/1006/problem/B", "problemId": "198026", "shortId": "1006B", "contest_number": "1006", "name": "B. Polycarp's Practice", "statement": "Polycarp is practicing his problem solving skill. He has a list of  problems with difficulties , respectively. His plan is to practice for exactly  days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all  problems in exactly  days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in  days he will solve all the  problems.The  of the -th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the -th day (i.e. if he solves problems with indices from  to  during a day, then the  of the day is ). The  of his practice is the sum of the  over all  days of his practice.You want to help Polycarp to get the maximum possible  over all valid ways to solve problems. Your task is to distribute all  problems between  days satisfying the conditions above in such a way, that the  is maximum.For example, if  and , one of the possible distributions with maximum  is: . Here the  equals .", "input": "The first line of the input contains two integers  and  () \u2014 the number of problems and the number of days, respectively. The second line of the input contains  integers  () \u2014 difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).", "output": "In the first line of the output print the maximum possible . In the second line print exactly  positive integers  ( must equal ), where  means the number of problems Polycarp will solve during the -th day in order to achieve the maximum possible  of his practice. If there are many possible answers, you may print any of them.", "tutorial": "The maximum possible  you can obtain is the sum of the  largest values of the given array. This is obvious because we can always separate these  maximums and then extend the segments corresponding to them to the left or to the right and cover the entire array. I suggest the following: extract  largest values of the given array and place a separator right after each of them (except the rightmost one).Overall complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin); \n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<pair<int, int>> res(n);\n\tvector<int> a(n); \n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> res[i].first;\n\t\ta[i] = res[i].first;\n\t\tres[i].second = i + 1;\n\t}\n\t\n\tsort(res.begin(), res.end());\n\treverse(res.begin(), res.end());\n\tsort(res.begin(), res.begin() + k, [&](pair<int, int> a, pair<int, int> b) { return a.second < b.second; });\n\t\n\tint lst = 0, sum = 0;\n\tfor (int i = 0; i < k - 1; ++i) {\n\t    sum += *max_element(a.begin() + lst, a.begin() + res[i].second);\n\t\tlst = res[i].second;\t\n\t}\n\tsum += *max_element(a.begin() + lst, a.end());\n\tcout << sum << endl;\n\t\n\n\tlst = 0;\n\tfor (int i = 0; i < k - 1; ++i) {\n\t\tcout << res[i].second - lst << \" \";\n\t\tlst = res[i].second;\t\n\t}\n\tcout << n - lst << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}