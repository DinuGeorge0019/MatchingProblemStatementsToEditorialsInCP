{"link": "https://codeforces.com//contest/1551/problem/E", "problemId": "1055225", "shortId": "1551E", "contest_number": "1551", "name": "E. Fixed Points", "statement": "Consider a sequence of integers . In one move, you can select any element of the sequence and delete it. After an element is deleted, all elements to the right are shifted to the left by  position, so there are no empty spaces in the sequence. So after you make a move, the sequence's length decreases by . The indices of the elements after the move are recalculated.E.\u2009g. let the sequence be . Let's select the element  in a move. Then after the move the sequence will be equal to , so the -rd element of the new sequence will be  and the -th element will be .You are given a sequence  and a number . You need to find the minimum number of moves you have to make so that in the resulting sequence there will be   elements that are equal to their indices, i.\u2009e. the resulting sequence  will contain at least  indices  such that .", "input": "The first line contains one integer  () \u2014 the number of test cases. Then  test cases follow. Each test case consists of two consecutive lines. The first line contains two integers  and  (). The second line contains a sequence of integers  (). The numbers in the sequence are not necessarily different. It is guaranteed that the sum of  over all test cases doesn't exceed .", "output": "For each test case output in a single line:    if there's no desired move sequence;  otherwise, the integer  () \u2014 the minimum number of the moves to be made so that the resulting sequence will contain at least  elements that are equal to their indices. ", "tutorial": "Let's use the concept of dynamic programming. Let's create an array  (-indexed) with size of .  will contain the maximal number of the elements equal to their indices if we have considered the first  elements of the sequence  and have   elements.Let's fill the array with zeroes, then we will increase the elements of the array for different  and . Let's start the -loop with parameter  from  to  and the internal one with parameter  from  to . Consider an element . We can delete or not delete it.If we delete this element, the number of the elements equal to their indices will not be increased and the number of the non-deleted element will not be increased, too. It means that the answer for  may be updated with . Since we are interested in a maximum answer, we rewrite  only if  is greater than .Suppose we don't delete this element. We haven't deleted previously  elements so  will have the index  and there will be  non-deleted elements if we consider  elements so we must update . If  (i. e. an element equal to its index is found), let's update  with . Otherwise, we should update it with . Remember that update may be done only if we rewrite the less value with the greater value.Let's build the answer as follows. We need to minimize the number of deleted elements (maximize the number of non-deleted elements) so that the number of the elements equal to their indices is at least . Consider only the elements of  having the first index . Let's start a -loop in the descending order of . If ,  is the maximum number of elements that we will not delete, so the answer is . If we will not find  such that , there's no desired sequence of moves so the answer is .The algorithm works in .", "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 6000;\n\nint dp[MAX_N][MAX_N];\nint a[MAX_N];\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tfor (int j = 0; j <= i; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j <= i; j++)\n\t\t\t{\n\t\t\t\tdp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);\n\t\t\t\tdp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + ((a[i + 1] == j + 1) ? 1 : 0));\n\t\t\t}\n\t\tint ans = -1;\n\t\tfor(int i = n; i >= 0; i--)\n\t\t\tif (dp[n][i] >= k)\n\t\t\t{\n\t\t\t\tans = n - i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}