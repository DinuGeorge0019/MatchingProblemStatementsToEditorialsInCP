{"link": "https://codeforces.com//contest/999/problem/B", "problemId": "192341", "shortId": "999B", "contest_number": "999", "name": "B. Reversing Encryption", "statement": "A string  of length  can be encrypted by the following algorithm:  iterate over all divisors of  in decreasing order (i.e. from  to ),  for each divisor , reverse the substring  (i.e. the substring which starts at position  and ends at position ). For example, the above algorithm applied to the string =\"\" leads to the following changes: \"\"  \"\"  \"\"  \"\"  \"\" (obviously, the last reverse operation doesn't change the string because ).You are given the encrypted string . Your task is to decrypt this string, i.e., to find a string  such that the above algorithm results in string . It can be proven that this string  always exists and is unique.", "input": "The first line of input consists of a single integer  () \u2014 the length of the string . The second line of input consists of the string . The length of  is , and it consists only of lowercase Latin letters.", "output": "Print a string  such that the above algorithm results in .", "tutorial": "To solve the problem, we can implement the encryption algorithm with a single change: we have to iterate over all divisors of  in increasing order.Time complexity \u2014 , where  is a divisor count function for . For example, .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}