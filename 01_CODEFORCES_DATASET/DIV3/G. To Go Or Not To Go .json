{"link": "https://codeforces.com//contest/1520/problem/G", "problemId": "976803", "shortId": "1520G", "contest_number": "1520", "name": "G. To Go Or Not To Go ", "statement": "Dima overslept the alarm clock, which was supposed to raise him to school.Dima wonders if he will have time to come to the first lesson. To do this, he needs to know the  it will take him to get from home to school.The city where Dima lives is a rectangular field of  size. Each cell  on this field is denoted by one number :  The number  means that the passage through the cell is prohibited;  The number  means that the cell is free and Dima can walk though it.  The number  () means that the cell contains a portal with a cost of . A cell with a portal is also considered free. From any portal, Dima can go to any other portal, while the time of moving from the portal  to the portal  corresponds to the sum of their costs .In addition to moving between portals, Dima can also move between unoccupied cells adjacent to one side in time . In particular, he can enter a cell with a portal and not use it.Initially, Dima is in the upper-left cell , and the school is in the lower right cell .", "input": "The first line contains three integers ,  and  (, ), where  and  are city size,  is time during which Dima moves between unoccupied cells. The next  lines each contain  numbers ()\u00a0\u2014 descriptions of cells. It is guaranteed that the cells  and  are free.", "output": "Output the minimum time it will take for Dima to get to school. If he cannot get to school at all, then output \"\".", "tutorial": "There is no point in using two transitions between portals, because if you want to go from portal $$$A$$$ to portal $$$B$$$, and then from portal $$$C$$$ to portal $$$D$$$, then you can immediately go from portal $$$A$$$ to portal $$$D$$$ for less.Then there are two possible paths.First\u00a0\u2014 do not use portals. Here it is enough to find the shortest path between two points.The second\u00a0\u2014 use a single transition. Let's choose a portal from which we should teleport. Obviously, this is a portal with a minimum distance to it and the cost of the transition. Similarly, the portal in which we should teleport is selected.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing cd = complex<ld>;\n\nconst int MAX_N = 2010;\n\nint dd[4][2] = {\n        {1, 0},\n        {0, 1},\n        {-1, 0},\n        {0, -1}\n};\n\nvoid bfs(int sx, int sy, vector<vector<int>> &d, vector<vector<int>> &a) {\n    int n = d.size();\n    int m = d[0].size();\n    queue<pair<int, int>> q;\n    q.push({sx, sy});\n    d[sx][sy] = 1;\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        for (auto [dx, dy] : dd) {\n            int tx = x + dx;\n            int ty = y + dy;\n            if (tx >= 0 && ty >= 0 && tx < n && ty < m && d[tx][ty] == 0 && a[tx][ty] != -1) {\n                d[tx][ty] = d[x][y] + 1;\n                q.push({tx, ty});\n            }\n        }\n    }\n    for (auto &e : d) {\n        for (auto &i : e) {\n            i--;\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m, w;\n    cin >> n >> m >> w;\n    vector<vector<int>> a(n, vector<int>(m));\n    vector<vector<int>> d1(n, vector<int>(m));\n    vector<vector<int>> d2(n, vector<int>(m));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> a[i][j];\n        }\n    }\n    bfs(0, 0, d1, a);\n    bfs(n - 1, m - 1, d2, a);\n    ll bestFinish = 1e18;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (d2[i][j] != -1 && a[i][j] >= 1) {\n                bestFinish = min(bestFinish, a[i][j] + w * 1ll * d2[i][j]);\n            }\n        }\n    }\n    ll ans = w * 1ll * d1[n - 1][m - 1];\n    if (d1[n - 1][m - 1] == -1) {\n        ans = 1e18;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (d1[i][j] != -1 && a[i][j] >= 1 && bestFinish != 1e18) {\n                ans = min(ans, w * 1ll * d1[i][j] + a[i][j] + bestFinish);\n            }\n        }\n    }\n    if (ans == 1e18) {\n        cout << -1;\n    } else {\n        cout << ans;\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}