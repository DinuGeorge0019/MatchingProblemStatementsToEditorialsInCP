{"link": "https://codeforces.com//contest/1203/problem/D2", "problemId": "388106", "shortId": "1203D2", "contest_number": "1203", "name": "D2. Remove the Substring  hard version ", "statement": ".You are given a string  and a string , both consisting only of lowercase Latin letters. It is guaranteed that  can be obtained from  by removing some (possibly, zero) number of characters (not necessary contiguous) from  without changing order of remaining characters (in other words, it is guaranteed that  is a subsequence of ).For example, the strings \"\", \"\", \"\", \"\" and \"\" are subsequences of the string \"\". But the strings \"\", \"\", \"\" are not subsequences of the string \"\".You want to remove some substring (contiguous subsequence) from  of  such that after removing this substring  will remain a subsequence of .If you want to remove the substring  then the string  will be transformed to  (where  is the length of ).Your task is to find the maximum possible length of the substring you can remove so that  is still a subsequence of .", "input": "The first line of the input contains one string  consisting of at least  and at most  lowercase Latin letters. The second line of the input contains one string  consisting of at least  and at most  lowercase Latin letters. It is guaranteed that  is a subsequence of .", "output": "Print one integer \u2014 the maximum possible length of the substring you can remove so that  is still a subsequence of .", "tutorial": "Let  be such rightmost position  in  that the substring  is the subsequence of . We need values  for all  from  to . We can calculate it just iterating from right to left over all characters of  and maintaining the pointer to the string  as in easy version.Then let's iterate over all positions  from  to  and maintain the pointer  as in the easy version which tells us the maximum length of the prefix of  we can obtain using only the substring  (exclusively!). Suppose we want to remove the substring of  starting from . Then if  then let  be , otherwise let  be .  tells us the farthest rightmost character of the substring we can remove. So we can update the answer with the value  and go to the next position (and don't forget to increase  if needed).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tstring s, t;\n\tcin >> s >> t;\n\tvector<int> rg(t.size());\n\t\n\tfor (int i = int(t.size()) - 1; i >= 0; --i) {\n\t\tint pos = int(s.size()) - 1;\n\t\tif (i + 1 < int(t.size())) pos = rg[i + 1] - 1;\n\t\twhile (s[pos] != t[i]) --pos;\n\t\trg[i] = pos;\n\t}\n\t\n\tint ans = 0;\n\tint pos = 0;\n\tfor (int i = 0; i < int(s.size()); ++i) {\n\t\tint rpos = int(s.size()) - 1;\n\t\tif (pos < int(t.size())) rpos = rg[pos] - 1;\n\t\tans = max(ans, rpos - i + 1);\n\t\tif (pos < int(t.size()) && t[pos] == s[i]) ++pos;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}