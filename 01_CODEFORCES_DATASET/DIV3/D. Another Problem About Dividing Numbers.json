{"link": "https://codeforces.com//contest/1538/problem/D", "problemId": "1011924", "shortId": "1538D", "contest_number": "1538", "name": "D. Another Problem About Dividing Numbers", "statement": "You are given two integers  and . In one turn, you can do one of the following operations:   Take an integer  ( and ) and replace  with ;  Take an integer  ( and ) and replace  with . Your goal is to make  equal to  using exactly  turns.For example, the numbers  and  can be made equal in  moves:   , divide  by   , ;  , divide  by   , ;  , divide  by   , ;  , divide  by   , . For the given numbers  and , determine whether it is possible to make them equal using exactly  turns.", "input": "The first line contains one integer  (). Then  test cases follow. Each test case is contains three integers ,  and  ().", "output": "For each test case output:    \"\", if it is possible to make the numbers  and  equal in   turns;  \"\" otherwise.  The strings \"\" and \"\" can be output in any case.", "tutorial": "Let's denote for  the maximum number of moves for which the numbers  and  can be made equal. It is easy to understand that the number of moves is maximum when  and each time we divided  or  by a prime number. That is,  sum of exponents of prime divisors of  sum of exponents of prime divisors of .Let's denote by  the minimum number of moves for which the numbers  and  can be made equal. Consider a few cases:   If , then ;  If  or , then ;  Otherwise, then . Then, the answer \"\" is possible in the following cases:    and  and ,  or,  and . ", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing cd = complex<ld>;\n\nconst int N = 50'000;\n\nbool isPrime[N];\nvector<int> primes;\n\nvoid precalc() {\n  fill(isPrime + 2, isPrime + N, true);\n  for (int i = 2; i * i < N; i++) {\n    for (int j = i * i; j < N; j += i) {\n      isPrime[j] = false;\n    }\n  }\n  for (int i = 2; i < N; i++) {\n    if (isPrime[i]) {\n      primes.push_back(i);\n    }\n  }\n}\n\nint calcPrime(int n) {\n  int res = 0;\n  for (int i : primes) {\n    if (i * i > n) {\n      break;\n    }\n    while (n % i == 0) {\n      n /= i;\n      res++;\n    }\n  }\n  if (n > 1) {\n    res++;\n  }\n  return res;\n}\n\nmap<int, int> decompose(int n) {\n  map<int, int> a;\n  for (int i : primes) {\n    if (i * i > n) {\n      break;\n    }\n    int p = 0;\n    while (n % i == 0) {\n      n /= i;\n      p++;\n    }\n    if (p > 0) {\n      a[i] = p;\n    }\n  }\n  if (n > 1) {\n    a[n] = 1;\n  }\n  return a;\n}\n\nbool check(const map<int, int> &divs,\n           map<int, int>::const_iterator it,\n           map<int, int> &divsA,\n           map<int, int> &divsB,\n           int low,\n           int high,\n           int k) {\n  if (it == divs.end()) {\n    return __builtin_popcount(low) <= k && k <= high;\n  }\n  for (int p = 0; p <= it->second; p++) {\n    int pa = divsA[it->first];\n    int pb = divsB[it->first];\n    int nextLow = low;\n    if (p != pa) {\n      nextLow |= 1;\n    }\n    if (p != pb) {\n      nextLow |= 2;\n    }\n    if (check(divs, next(it), divsA, divsB, nextLow, high + pa + pb - 2 * p, k)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid solve() {\n  int a, b, k;\n  cin >> a >> b >> k;\n  int g = __gcd(a, b);\n  int low = 0;\n  int high = 0;\n  {\n    int t;\n    int ta = 1;\n    while ((t = __gcd(a, g)) != 1) {\n      a /= t;\n      ta *= t;\n    }\n    high += calcPrime(a);\n    if (a != 1) {\n      low |= 1;\n    }\n    a = ta;\n  }\n  {\n    int t;\n    int tb = 1;\n    while ((t = __gcd(b, g)) != 1) {\n      b /= t;\n      tb *= t;\n    }\n    high += calcPrime(b);\n    if (b != 1) {\n      low |= 2;\n    }\n    b = tb;\n  }\n  auto divs = decompose(g);\n  auto divsA = decompose(a);\n  auto divsB = decompose(b);\n  cout << (check(divs, divs.begin(), divsA, divsB, low, high, k) ? \"YES\" : \"NO\") << endl;\n}\n\nint main() {\n  precalc();\n\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n\n  return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}