{"link": "https://codeforces.com//contest/1650/problem/F", "problemId": "1321165", "shortId": "1650F", "contest_number": "1650", "name": "F. Vitaly and Advanced Useless Algorithms", "statement": "Vitaly enrolled in the course Advanced Useless Algorithms. The course consists of  tasks. Vitaly calculated that he has  hours to do the task  from the day he enrolled in the course. That is, the deadline before the -th task is  hours. The array  is sorted in ascending order, in other words, the job numbers correspond to the order in which the assignments are turned in.Vitaly does everything conscientiously, so he wants to complete  task by  percent, . Initially, his completion rate for each task is  percent.Vitaly has  training options, each option can be used  once. The th option is characterized by three integers:  and . If Vitaly uses the th option, then after  hours (from the current moment) he will increase the progress of the task  by  percent. For example, let Vitaly have  of tasks to complete. Let the array  have the form: . Suppose Vitaly has  of options: , , , , . Then, if Vitaly prepares in the following way, he will be able to complete everything in time:   Vitaly chooses the -th option. Then in  hour, he will complete the -st task at  percent. He still has  hours left before the deadline for the -st task.  Vitaly chooses the -rd option. Then in  hours, he will complete the -nd task in its entirety. He has another  hour left before the deadline for the -st task and  hours left before the deadline for the -rd task.  Vitaly chooses the -st option. Then after  hour, he will complete the -st task for  percent, which means that he will complete the -st task just in time for the deadline.  Vitaly chooses the -th option. He will complete the -rd task for  hours, and after another  hour, Vitaly will complete the -rd task in its entirety. Thus, Vitaly has managed to complete the course completely and on time, using the  options.Help Vitaly\u00a0\u2014 print the options for Vitaly to complete the tasks in the correct order. Please note: each option can be used  once. If there are several possible answers, it is allowed to output any of them.", "input": "The first line of input data contains an integer  ()\u00a0\u2014the number of input test cases in the test. The descriptions of the input test case follow. The first line of each test case description contains two integers  and  ()\u00a0\u2014the number of jobs and the number of training options, respectively. The next line contains  numbers  ()\u00a0\u2014 the time before the deadline of job . The array values\u00a0\u2014 are non-decreasing, that is . The following  lines contain triples of numbers  (, , )\u00a0\u2014 if Vitaly chooses this option, then after  hours he will increase the progress of the task  by  percent. The options are numbered from  to  in order in the input data. It is guaranteed that the sum of  on all test cases does not exceed .", "output": "For each test case, print on the first line the number , meaning that for  of options, Vitaly will be able to complete each task by  percent or more on time. The options should not be repeated. Or print  if Vitaly is unable to complete all tasks in time. If there is an answer, on the next line print  of different integers from  to \u00a0\u2014 the numbers of the options in the order you want. If there is more than one answer, it is allowed to print  of them.", "tutorial": "Note that it is always advantageous for us to complete the task that has an earlier deadline first. Only then will we proceed to the next task. Then we can solve each problem independently for each exam. Then it remains to score  percent on the task on the available options. This is a typical knapsack problem with an answer recovery.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<class T> bool ckmin(T &a, T b) {return a > b ? a=b, true : false;}\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define sz(v) (int)v.size()\n#define all(v) v.begin(),v.end()\n\nstruct option {\n    int t, p, id;\n    option(int _t,int _p, int _id) : t(_t), p(_p), id(_id) {\n    }\n};\n\nconst int INF = INT_MAX >> 1;\n\nvector<int> get_ans(vector<option> &v) {\n    int n = sz(v);\n    vector<vector<int>> dp(101, vector<int>(n+1, INF));\n    dp[0][0] = 0;\n    for (int k = 1; k <= n; k++) {\n        auto [t,p,id] = v[k-1];\n        dp[0][k] = 0;\n        for (int i = 100; i > 0; i--) {\n            int prev = max(0,i - p);\n            dp[i][k] = dp[i][k-1];\n            ckmin(dp[i][k], dp[prev][k-1] + t);\n        }\n    }\n    vector<int> ans;\n    int t = dp[100][n];\n\n    if (t == INF) return {-1};\n    for (int i = 100, k = n; k >= 1; k--) {\n        if (dp[i][k] == dp[i][k-1]) {\n            continue;\n        }\n        ans.emplace_back(v[k-1].id);\n        i = max(0, i - v[k-1].p);\n    }\n\n    reverse(all(ans));\n    ans.emplace_back(t);\n    return ans;\n}\n\nvoid solve(bool flag=true) {\n\n\n    int n,m; cin >> n >> m;\n    vector<int> a(n);\n    forn(i, n) {\n        cin >> a[i];\n    }\n    for (int i = n-1; i > 0; i--) {\n        a[i] -= a[i-1];\n    }\n\n    vector<vector<option>> v(n);\n    forn(j, m) {\n        int e,t,p; cin >> e >> t >> p, e--;\n        v[e].emplace_back(t, p, j+1);\n    }\n    vector<int> ans;\n    forn(i, n) {\n        vector<int> cur = get_ans(v[i]);\n        if (sz(cur) == 1 && cur[0] == -1) {\n            cout << \"-1\\n\";\n            return;\n        }\n        int t = cur.back();\n        if (t > a[i]) {\n            cout << \"-1\\n\";\n            return;\n        }\n        cur.pop_back();\n        if (i+1 < n) a[i+1] += a[i] - t;\n\n        ans.insert(ans.end(), all(cur));\n    }\n\n\n    cout << sz(ans) << '\\n';\n    for (auto e:ans) cout << e << ' ';\n    cout << '\\n';\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    forn(tt, t) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}