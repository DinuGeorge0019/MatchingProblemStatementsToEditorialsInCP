{"link": "https://codeforces.com//contest/1272/problem/B", "problemId": "494354", "shortId": "1272B", "contest_number": "1272", "name": "B. Snow Walking Robot", "statement": "Recently you have bought a snow walking robot and brought it home. Suppose your home is a cell  on an infinite grid.You also have the sequence of instructions of this robot. It is written as the string  consisting of characters '', '', '' and ''. If the robot is in the cell  right now, he can move to one of the adjacent cells (depending on the current instruction).  If the current instruction is '', then the robot can move to the left to ;  if the current instruction is '', then the robot can move to the right to ;  if the current instruction is '', then the robot can move to the top to ;  if the current instruction is '', then the robot can move to the bottom to . You've noticed the warning on the last page of the manual: if the robot visits some cell ( ) twice then it breaks.So the sequence of instructions is valid if the robot starts in the cell , performs the given instructions, visits no cell other than  two or more times and ends the path in the cell . Also cell  should be visited  two times: at the beginning and at the end (if the path is empty then it is visited only once). For example, the following sequences of instructions are considered valid: \"\", \"\", \"\", and the following are considered invalid: \"\" (the endpoint is not ) and \"\" (the cell  is visited twice).The initial sequence of instructions, however, might be not valid. You don't want your robot to break so you decided to reprogram it in the following way: you will remove some (possibly, all or none) instructions from the initial sequence of instructions, then rearrange the remaining instructions as you wish and turn on your robot to move. Your task is to remove as few instructions from the initial sequence as possible and rearrange the remaining ones so that the sequence is valid. Report the valid sequence of the maximum length you can obtain.Note that you can choose  order of remaining instructions (you don't need to minimize the number of swaps or any other similar metric).You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. The next  lines contain test cases. The -th test case is given as the string  consisting of at least  and no more than  characters '', '', '' and '' \u2014 the initial sequence of instructions. It is guaranteed that the sum of  (where  is the length of ) does not exceed  over all test cases ().", "output": "For each test case print the answer on it. In the first line print the maximum number of remaining instructions. In the second line print the valid sequence of remaining instructions  the robot has to perform. The moves are performed from left to right in the order of the printed sequence. If there are several answers, you can print any. If the answer is , you are allowed to print an empty line (but you can don't print it).", "tutorial": "Let  be the number of occurrences of the character '' in the initial string,  \u2014 the number of occurrences of the character '',  and  are the same things for remaining characters.It is obvious that in every answer the number of '' equals the number of '' and the same for '' and ''. The maximum theoretic answer we can obtain has length . And... We almost always can obtain this answer! If there is at least one occurrence of each character, then we can construct some kind of rectangular path:  moves right, then  moves up, and the completing part.But there are some corner cases when some characters are missing. If  then our answer is empty or (if it is possible) it is \"\". The same if .Time complexity:  per test case.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string MOVES = \"LRUD\";\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tmap<char, int> cnt;\n\t\tfor (auto c : MOVES) cnt[c] = 0;\n\t\tfor (auto c : s) ++cnt[c];\n\t\tint v = min(cnt['U'], cnt['D']);\n\t\tint h = min(cnt['L'], cnt['R']);\n\t\tif (min(v, h) == 0) {\n\t\t\tif (v == 0) {\n\t\t\t\th = min(h, 1);\n\t\t\t\tcout << 2 * h << endl << string(h, 'L') + string(h, 'R') << endl;\n\t\t\t} else {\n\t\t\t\tv = min(v, 1);\n\t\t\t\tcout << 2 * v << endl << string(v, 'U') + string(v, 'D') << endl;\n\t\t\t}\n\t\t} else {\n\t\t\tstring res;\n\t\t\tres += string(h, 'L');\n\t\t\tres += string(v, 'U');\n\t\t\tres += string(h, 'R');\n\t\t\tres += string(v, 'D');\n\t\t\tcout << res.size() << endl << res << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}