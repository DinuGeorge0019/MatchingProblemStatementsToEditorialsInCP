{"link": "https://codeforces.com//contest/1157/problem/A", "problemId": "336204", "shortId": "1157A", "contest_number": "1157", "name": "A. Reachable Numbers", "statement": "Let's denote a function  in such a way: we add  to , then, while there is at least one trailing zero in the resulting number, we remove that zero. For example,   : ;  : ;  : ;  : . We say that some number  is  from  if we can apply function  to  some (possibly zero) times so that we get  as a result. For example,  is reachable from  because ; and any number is reachable from itself.You are given a number ; your task is to count how many different numbers are reachable from .", "input": "The first line contains one integer  ().", "output": "Print one integer: the number of different numbers that are reachable from .", "tutorial": "The key fact in this problem is that the answer is not very large (in fact, it's not greater than $$$91$$$). Why is it so? Every $$$10$$$ times we apply function $$$f$$$ to our current number, it gets divided by $$$10$$$ (at least), and the number of such divisions is bounded as $$$O(\\log n)$$$.So we can just do the following: store all reachable numbers somewhere, and write a loop that adds current number $$$n$$$ to reachable numbers, and sets $$$n = f(n)$$$ (we should end this loop when $$$n$$$ already belongs to reachable numbers). The most convenient way to store reachable numbers is to use any data structure from your favourite programming language that implemenets a set, but, in fact, the constrains were so small that it was possible to store all reachable numbers in an array.", "solution": "def f(x):\n\tx += 1\n\twhile(x % 10 == 0):\n\t\tx //= 10\n\treturn x\n\na = set()\nn = int(input())\n\nwhile(not(n in a)):\n\ta.add(n)\n\tn = f(n)\n\nprint(len(a))", "interactive": false, "noSolution": false, "noTutorial": false}