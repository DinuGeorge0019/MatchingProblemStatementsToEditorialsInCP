{"link": "https://codeforces.com//contest/1399/problem/E2", "problemId": "691721", "shortId": "1399E2", "contest_number": "1399", "name": "E2. Weights Division  hard version ", "statement": ".You are given a weighted rooted tree, vertex  is the root of this tree. .A tree is a connected graph without cycles. A rooted tree has a special vertex called the root. A parent of a vertex  is the last different from  vertex on the path from the root to the vertex . Children of vertex  are all vertices for which  is the parent. A vertex is a leaf if it has no children. The weighted tree is such a tree that each edge of this tree has some weight.The weight of the path is the sum of edges weights on this path. The weight of the path from the vertex to itself is .You can make a sequence of zero or more moves. On each move, you select an edge and divide its weight by  rounding down. More formally, during one move, you choose some edge  and divide its weight by  rounding down ().Each edge  has an associated cost  which is either  or  coins. Each move with edge  costs  coins.Your task is to find the minimum total  to make the  from the root to each leaf at most . In other words, if  is the weight of the path from the vertex  to the vertex , then you have to make , where  is the list of all leaves.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains two integers  and  () \u2014 the number of vertices in the tree and the maximum possible sum of weights you have to obtain. The next  lines describe edges of the tree. The edge  is described as four integers , ,  and  (), where  and  are vertices the edge  connects,  is the weight of this edge and  is the cost of this edge. It is guaranteed that the sum of  does not exceed  ().", "output": "For each test case, print the answer: the minimum total  required to make the sum of weights paths from the root to each leaf at most .", "tutorial": "Read the easy version editorial first, because almost all solution is the solution to the easy version with little changes.Firstly, let's simulate the greedy process we used to solve the easy version problem, for edges with cost  and edges with cost , independently. But we don't stop when our sum reach something, let's simulate until our sum becomes  and store each intermediate result in the array  for edges with cost  and  for edges with cost . So, the array  contains the initial total impact of edges of cost , then the impact after making one move, two moves, and so on... The same with  but for edges with cost .Now let's fix how many moves on edges with cost  we do. Let it be  (and arrays  and  are -indexed). Then the sum we obtain from the -cost edges is . So we need to find the minimum number of moves  we can do on -cost edges so that . This can be done using binary search or moving pointer (if we iterate over  in increasing order, place  at the end of  and move it to the left while ). Then, if , we can update the answer with the value .Time complexity is actually the same as in easy version of the problem: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint n;\nvector<int> w, c, cnt;\nvector<vector<pair<int, int>>> g;\n\nlong long getdiff(int i) {\n\treturn w[i] * 1ll * cnt[i] - (w[i] / 2) * 1ll * cnt[i];\n}\n\nvoid dfs(int v, int p = -1) {\n\tif (g[v].size() == 1) cnt[p] = 1;\n\tfor (auto [to, id] : g[v]) {\n\t\tif (id == p) continue;\n\t\tdfs(to, id);\n\t\tif (p != -1) cnt[p] += cnt[id];\n\t}\n}\n\nvector<long long> get(int clr) {\n\tset<pair<long long, int>> st;\n\tlong long cur = 0;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tif (c[i] == clr) {\n\t\t\tst.insert({getdiff(i), i});\n\t\t\tcur += w[i] * 1ll * cnt[i];\n\t\t}\n\t}\n\tvector<long long> res;\n\tres.push_back(cur);\n\twhile (cur > 0 && !st.empty()) {\n\t\tint id = st.rbegin()->second;\n\t\tst.erase(prev(st.end()));\n\t\tcur -= getdiff(id);\n\t\tres.push_back(cur);\n\t\tw[id] /= 2;\n\t\tst.insert({getdiff(id), id});\n\t}\n\treturn res;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tlong long s;\n\t\tcin >> n >> s;\n\t\tw = c = cnt = vector<int>(n - 1);\n\t\tg = vector<vector<pair<int, int>>>(n);\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y >> w[i] >> c[i];\n\t\t\t--x, --y;\n\t\t\tg[x].push_back({y, i});\n\t\t\tg[y].push_back({x, i});\n\t\t}\n\t\tdfs(0);\n\t\tvector<long long> v1 = get(1), v2 = get(2);\n\t\tint pos = int(v2.size()) - 1;\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < int(v1.size()); ++i) {\n\t\t\twhile (pos > 0 && v1[i] + v2[pos - 1] <= s) --pos;\n\t\t\tif (v1[i] + v2[pos] <= s) {\n\t\t\t\tans = min(ans, i + pos * 2);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}