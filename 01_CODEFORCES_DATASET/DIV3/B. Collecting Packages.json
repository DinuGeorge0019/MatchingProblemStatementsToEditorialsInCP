{"link": "https://codeforces.com//contest/1294/problem/B", "problemId": "521708", "shortId": "1294B", "contest_number": "1294", "name": "B. Collecting Packages", "statement": "There is a robot in a warehouse and  packages he wants to collect. The warehouse can be represented as a coordinate grid. Initially, the robot stays at the point . The -th package is at the point . It is guaranteed that there are no two packages at the same point. It is also guaranteed that the point  doesn't contain a package.The robot is semi-broken and only can move up ('') and right (''). In other words, in one move the robot can go from the point  to the point () or to the point .As we say above, the robot wants to collect all  packages (). He wants to do it with the minimum possible number of moves. If there are several possible traversals, the robot wants to choose the lexicographically smallest path.The string  of length  is lexicographically less than the string  of length  if there is some index  that for all  from  to   and . It is the standard comparison of string, like in a dictionary. Most programming languages compare strings in this way.", "input": "The first line of the input contains an integer  () \u2014 the number of test cases. Then test cases follow. The first line of a test case contains one integer  () \u2014 the number of packages. The next  lines contain descriptions of packages. The -th package is given as two integers  and  () \u2014 the -coordinate of the package and the -coordinate of the package. It is guaranteed that there are no two packages at the same point. It is also guaranteed that the point  doesn't contain a package. The sum of all values  over test cases in the test doesn't exceed .", "output": "Print the answer for each test case. If it is impossible to collect all  packages in some order starting from (), print \"\" on the first line. Otherwise, print \"\" in the first line. Then print the  path \u2014 a string consisting of characters '' and ''. Among all such paths choose the lexicographically smallest path. .", "tutorial": "It is obvious that if there is a pair of points  and  such that  and  then the answer is \"\". It means that if the answer is \"\" then there is some ordering of points such that  and  because we can only move right or up. But what is this ordering? it is just sorted order of points (firstly by  then by ).So we can sort all points, check if this ordering is valid and traverse among all these points. For each  from  to  firstly do  moves to the right then do  moves to the up (because this order minimizing the answer lexicographically).Time complexity:  or .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t;\n    cin >> t;\n    \n    for (int tt = 0; tt < t; tt++) {\n     \tint n;\n    \tcin >> n;\n    \tvector<pair<int, int>> a(n);\n    \tfor (int i = 0; i < n; ++i) {\n    \t\tcin >> a[i].first >> a[i].second;\n    \t}\n    \tsort(a.begin(), a.end());\n    \tpair<int, int> cur = make_pair(0, 0);\n    \tstring ans;\n    \tbool ok = true;\n    \tfor (int i = 0; i < n; ++i) {\n    \t\tint r = a[i].first - cur.first;\n    \t\tint u = a[i].second - cur.second;\n    \t\tif (r < 0 || u < 0) {\n    \t\t\tcout << \"NO\" << endl;\n    \t\t\tok = false;\n    \t\t\tbreak;\n    \t\t}\n    \t\tans += string(r, 'R');\n    \t\tans += string(u, 'U');\n    \t\tcur = a[i];\n    \t}\n    \t\n    \tif (ok)\n    \t    cout << \"YES\" << endl << ans << endl;\n   }\n\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}