{"link": "https://codeforces.com//contest/1029/problem/D", "problemId": "211259", "shortId": "1029D", "contest_number": "1029", "name": "D. Concatenated Multiples", "statement": "You are given an array , consisting of  positive integers.Let's call a concatenation of numbers  and  the number that is obtained by writing down numbers  and  one right after another without changing the order. For example, a concatenation of numbers  and  is a number .Count the number of ordered pairs of positions  () in array  such that the concatenation of  and  is divisible by .", "input": "The first line contains two integers  and  (, ). The second line contains  integers  ().", "output": "Print a single integer \u2014 the number of ordered pairs of positions  () in array  such that the concatenation of  and  is divisible by .", "tutorial": "Let's rewrite concatenation in a more convenient form. , where  is the number of digits in . Then this number is divisible by  if and only if the sum of () and () is either  or .Let's calculate  arrays of remainders . For each   adds () to . That's the first term of the sum.Now iterate over the second term, for  and for  you binary search for () in . The number of its occurrences should be added to answer.You also might have calculated some pairs , iterate over them and subtract them naively.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\ntypedef long long li;\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int LOGN = 11;\n\nint n, k;\nint a[N];\nint len[N];\nvector<int> rems[LOGN];\nint pw[LOGN];\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tforn(i, n) scanf(\"%d\", &a[i]);\n\t\n\tpw[0] = 1;\n\tforn(i, LOGN - 1)\n\t\tpw[i + 1] = pw[i] * 10 % k;\n\t\n\tforn(i, n){\n\t\tint x = a[i];\n\t\twhile (x > 0){\n\t\t\t++len[i];\n\t\t\tx /= 10;\n\t\t}\n\t\trems[len[i]].push_back(a[i] % k);\n\t}\n\t\n\tforn(i, LOGN)\n\t\tsort(rems[i].begin(), rems[i].end());\n\t\n\tli ans = 0;\n\tforn(i, n){\n\t\tfor (int j = 1; j < LOGN; ++j){\n\t\t\tint rem = (a[i] * li(pw[j])) % k;\n\t\t\tint xrem = (k - rem) % k;\n\t\t\tauto l = lower_bound(rems[j].begin(), rems[j].end(), xrem);\n\t\t\tauto r = upper_bound(rems[j].begin(), rems[j].end(), xrem);\n\t\t\tans += (r - l);\n\t\t\tif (len[i] == j && (rem + a[i] % k) % k == 0)\n\t\t\t\t--ans;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}