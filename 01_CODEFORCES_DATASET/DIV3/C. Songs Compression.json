{"link": "https://codeforces.com//contest/1015/problem/C", "problemId": "203548", "shortId": "1015C", "contest_number": "1015", "name": "C. Songs Compression", "statement": "Ivan has  songs on his phone. The size of the -th song is  bytes. Ivan also has a flash drive which can hold at most  bytes in total. Initially, his flash drive is empty.Ivan wants to copy all  songs to the flash drive. He can compress the songs. If he compresses the -th song, the size of the -th song reduces from  to  bytes ().Ivan can compress any subset of the songs (possibly empty) and copy all the songs to his flash drive if the sum of their sizes is at most . He can compress  subset of the songs (not necessarily contiguous).Ivan wants to find the minimum number of songs he needs to compress in such a way that all his songs fit on the drive (i.e. the sum of their sizes is less than or equal to ).If it is impossible to copy all the songs (even if Ivan compresses all the songs), print \"\". Otherwise print the minimum number of songs Ivan needs to compress.", "input": "The first line of the input contains two integers  and  () \u2014 the number of the songs on Ivan's phone and the capacity of Ivan's flash drive. The next  lines contain two integers each: the -th line contains two integers  and  (, ) \u2014 the initial size of the -th song and the size of the -th song after compression.", "output": "If it is impossible to compress a subset of the songs in such a way that all songs fit on the flash drive, print \"\". Otherwise print the minimum number of the songs to compress.", "tutorial": "If we will no compress songs, the sum of the sizes will be equal . Let it be . Now, if we will compress the -th song, how do  will change? It will decrease by . This suggests that the optimal way to compress the songs is the compress it in non-increasing order of . Let's create the array  of size , where . Let's sort it in non-increasing order, and then iterate over all  from  to . If at the current step , we print  and terminate the program. Otherwise we set . After all we have to check again if  then print  otherwise print \"\".Time complexity is  because of sorting.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pair<int, int>> a(n);\n\tlong long sum = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i].first >> a[i].second;\n\t\tsum += a[i].first;\n\t}\n\t\n\tsort(a.begin(), a.end(), [&](pair<int, int> a, pair<int, int> b) { return a.first - a.second > b.first - b.second; });\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (sum <= m) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsum -= a[i].first - a[i].second;\n\t}\n\t\n\tif (sum <= m)\n\t\tcout << n << endl;\n\telse\n\t\tcout << -1 << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}