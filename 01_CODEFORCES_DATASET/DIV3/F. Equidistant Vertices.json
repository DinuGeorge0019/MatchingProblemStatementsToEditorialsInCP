{"link": "https://codeforces.com//contest/1551/problem/F", "problemId": "1055226", "shortId": "1551F", "contest_number": "1551", "name": "F. Equidistant Vertices", "statement": "A tree is an undirected connected graph without cycles.You are given a tree of  vertices. Find the number of ways to choose exactly  vertices in this tree (i.\u2009e. a -element subset of vertices) so that all pairwise distances between the selected vertices are equal (in other words, there exists an integer  such that for all  (,  are in selected vertices) , where  is the distance from  to ).Since the answer may be very large, you need to output it modulo .", "input": "The first line contains one integer  () \u2014 the number of test cases. Then  test cases follow. Each test case is preceded by an empty line. Each test case consists of several lines. The first line of the test case contains two integers  and  () \u2014 the number of vertices in the tree and the number of vertices to be selected, respectively. Then  lines follow, each of them contains two integers  and  (, ) which describe a pair of vertices connected by an edge. It is guaranteed that the given graph is a tree and has no loops or multiple edges.", "output": "For each test case output in a separate line a single integer \u2014 the number of ways to select exactly  vertices so that for all pairs of selected vertices the distances between the vertices in the pairs are equal, modulo  (in other words, print the remainder when divided by ).", "tutorial": "If , any set of two vertices may be taken so the answer is  modulo .Suppose . Consider three vertices , ,  such that . If this equality is true, there's a vertex  that belongs to all three paths, otherwise, either one of the vertices belongs to the path between two others or there is more than one simple path (i. e. path having distinct edges) between any of the vertices so the graph isn't a tree. Hence, the following equalities are true:  Then  hence, .Suppose . Let's select vertices , , ,  that is a correct desired set of four vertices, for the triple of paths , ,  let's select a common vertex  and for the triple , ,  \u2014 . Because  is the same vertex as . The same procedure we can do for all other pairs of triples of vertices. The situation will not be another if we add a new vertex in the set if the set will still meet the problem's conditions. So if , a vertex  exists such that all vertices of the set are equidistant from it.Note that for each set only one such  exists. Let's iterate over all vertices taking them as  and \"hang\" the tree by . The set of  vertices equidistant from  meets the problem's condition if and only if the vertices of the set are placed in different subtrees of vertices adjacent to  (in other words, the paths from them to  must intersect only in ). Let's calculate the number of desired sets for a given  and a layer of equidistant vertices. Let  be the number of vertices adjacent to  (and it's the number of subtrees, too). Let's create an array  (-indexed) of size  so that the -th element will contain the number of the vertices of the layer in the -th subtree. For the layer of vertices adjacent to , this array will be filled with . For the other layers, we can update the array as follows: let's mark  and vertices adjacent to  as used, then for every vertex of the current layer let's decrease  by  if  is the index of the subtree of the vertex, then let's increase  by the number of the vertices adjacent to the current one but not used. Then let's mark the vertices as used. After the iteration, the array  will correspond to the new layer. Using the array, let's calculate the number of the desired sets of  vertices using the concept of dynamic programming. Let's create an array  (-indexed) of size .  will contain a number of found sets of  vertices if only  subtrees have been considered. Let's fill the array with  except . Let's start a -loop with parameter  from  to  and the internal one with parameter  from  to . In every step, we can either take a vertex from -th subtree or take nothing.If we take a vertex from the subtree (it's possible only if ), then we have  ways to select  vertices considering  subtrees so that the last vertex belongs to the -th subtree. This value we must add to  that must contain all ways to select  vertices from  subtrees.If we ignore the subtree, the number of ways to select  vertices from  subtrees ignoring the -th subtree is . It must be added to the number of ways to select  vertices from  subtrees \u2014 .The answer for the current  and the current layer of equidistant vertices is . The answer for the whole tree is the sum of the answers for all  and for all layers of equidistant vertices. Remember that all arithmetical operations must be done modulo .The number of possible central vertices is . For every central vertex and every layer we perform two actions: recalculate the array  and calculate the number of the corresponding sets using the concept of dynamic programming. The recalculation of  works in , it's just BFS starting from  so for every central vertex it works in O(n). The dynamic programming for the current  and the current layer works in , for the current  and all layers \u2014 in . The summary time corresponding to the current  is .The total algorithm work time is . The sum of all  is a total number of the adjacent vertices to all vertices, it's just a double number of edges \u2014 . So the total work time is .", "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 128;\n\ntypedef long long ll;\nconst ll mod = 1000 * 1000 * 1000 + 7;\n\nll add(ll x, ll y) { return (x + y) % mod; }\nll mul(ll x, ll y) { return x * y % mod; }\n\nvector<int> g[MAX_N];\nbool used[MAX_N];\nint cnt[MAX_N];\nll dp[MAX_N][MAX_N];\n\nll rundp(int m, int k)\n{\n\tfor (int i = 0; i <= m; i++)\n\t\tfor (int j = 0; j <= k; j++)\n\t\t\tdp[i][j] = 0;\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j <= k; j++)\n\t\t{\n\t\t\tdp[i + 1][j] = add(dp[i + 1][j], dp[i][j]);\n\t\t\tdp[i + 1][j + 1] = add(dp[i + 1][j + 1], mul(dp[i][j], cnt[i]));\n\t\t}\n\treturn dp[m][k];\n}\n\nvoid solve()\n{\n\tint n, k;\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++)\n\t\tg[i].clear();\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tg[--a].push_back(--b);\n\t\tg[b].push_back(a);\n\t}\n\tif (k == 2)\n\t{\n\t\tcout << n * (n - 1LL) / 2 % mod << '\\n';\n\t\treturn;\n\t}\n\tll ans = 0;\n\tfor (int center = 0; center < n; center++)\n\t{\n\t\tmemset(used, 0, n);\n\t\tused[center] = true;\n\n\t\tvector<pair<int, int>> layer;\n\t\tint m = g[center].size();\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tint y = g[center][i];\n\t\t\tlayer.emplace_back(y, i);\n\t\t\tcnt[i] = 1;\n\t\t\tused[y] = true;\n\t\t}\n\t\twhile (!layer.empty())\n\t\t{\n\t\t\tans = add(ans, rundp(m, k));\n\t\t\tvector<pair<int, int>> newlayer;\n\t\t\tfor (auto p : layer)\n\t\t\t{\n\t\t\t\tcnt[p.second]--;\n\t\t\t\tfor (auto y : g[p.first])\n\t\t\t\t\tif (!used[y])\n\t\t\t\t\t{\n\t\t\t\t\t\tnewlayer.emplace_back(y, p.second);\n\t\t\t\t\t\tused[y] = true;\n\t\t\t\t\t\tcnt[p.second]++;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tlayer = newlayer;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\twhile (t--) solve();\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}