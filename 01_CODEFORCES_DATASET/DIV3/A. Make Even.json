{"link": "https://codeforces.com//contest/1611/problem/A", "problemId": "1202184", "shortId": "1611A", "contest_number": "1611", "name": "A. Make Even", "statement": "Polycarp has an integer  that doesn't contain the digit . He can do the following operation with his number several (possibly zero) times: Reverse the prefix of length  (in other words,  leftmost digits) of . So, the leftmost digit is swapped with the -th digit from the left, the second digit from the left swapped with ()-th left, etc. For example, if  and , then the new value of  will be .Note that for different operations, the values of  can be different. The number  can be equal to the length of the number \u00a0\u2014 in this case, the whole number  is reversed.Polycarp loves even numbers. Therefore, he wants to make his number even. At the same time, Polycarp is very impatient. He wants to do as few operations as possible.Help Polycarp. Determine the minimum number of operations he needs to perform with the number  to make it even or determine that this is impossible.You need to answer  independent test cases.", "input": "The first line contains the number  ()\u00a0\u2014 the number of test cases. Each of the following  lines contains one integer  (). It is guaranteed that the given number doesn't contain the digit .", "output": "Print  lines. On each line print one integer\u00a0\u2014 the answer to the corresponding test case. If it is impossible to make an even number, print .", "tutorial": "If the number is already even, then nothing needs to be done, so the answer in this case is .Now let's recall the divisibility by : a number is divisible by  if and only if its last digit is divisible by .It follows that if there are no even digits in our number, then the answer is .Let's take a look at our operation. What is going on? The first digit always changes with the digit numbered . In particular, when we reverse the entire number, the first digit is swapped with the last. Note that no other digit, except for the first one at the current moment, can't be the last.Therefore, you can do this: if the first digit of a number is divisible by , then we reverse the whole number. The first digit will become the last, and the number will become even. Therefore, you only need to do one operation.Now, what if the first digit of a number is odd? In this case, we can find the first even digit in the number (let it be at position ), and reverse the prefix of length  (in one operation). Now the first digit of our number has become even, and we can use the previous case (one more operation). Thus, we will do only  operations.", "solution": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    while(t--) {\n        string n;\n        cin >> n;\n        if((n.back() - '0') % 2 == 0) {\n            cout << \"0\\n\";\n            continue;\n        }\n        if((n[0] - '0') % 2 == 0) {\n            cout << \"1\\n\";\n            continue;\n        }\n        int count_2 = count(n.begin(), n.end(), '2');\n        int count_4 = count(n.begin(), n.end(), '4');\n        int count_6 = count(n.begin(), n.end(), '6');\n        int count_8 = count(n.begin(), n.end(), '8');\n        if(count_2 > 0 || count_4 > 0 || count_6 > 0 || count_8 > 0) {\n            cout << \"2\\n\";\n            continue;\n        }\n        cout << \"-1\\n\";\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}