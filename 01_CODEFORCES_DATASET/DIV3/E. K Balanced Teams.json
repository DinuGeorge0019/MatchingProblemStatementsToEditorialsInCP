{"link": "https://codeforces.com//contest/1133/problem/E", "problemId": "308948", "shortId": "1133E", "contest_number": "1133", "name": "E. K Balanced Teams", "statement": "You are a coach at your local university. There are  students under your supervision, the programming skill of the -th student is .You have to form  teams for yet another new programming competition. As you know, the more students are involved in competition the more probable the victory of your university is! So you have to form no more than  (and at least one)  teams so that the  number of students in them is maximized. But you also know that  team should be . It means that the programming skill of each pair of students in  team should differ by no more than . Teams are independent from one another (it means that the difference between programming skills of two students from two different teams does not matter).It is possible that some students not be included in any team at all.Your task is to report the maximum possible  number of students in no more than  (and at least one)   teams.", "input": "The first line of the input contains two integers  and  () \u2014 the number of students and the maximum number of teams, correspondingly. The second line of the input contains  integers  (), where  is a programming skill of the -th student.", "output": "Print one integer \u2014 the maximum possible  number of students in no more than  (and at least one)   teams.", "tutorial": "Firstly, let's sort all students in order of non-decreasing their programming skill.Then let's calculate the following dynamic programming:  is the maximum number of students in at most  non-empty teams if we consider first  students.How to do transitions from ? The first transition is pretty intuitive: just skip the -th (-indexed) student. Then we can set .The second possible transition is to take some team starting from the -th student.The only assumption we need to do it is the following: take the maximum by number of students team starting from the -th student is always optimally. Why it is so?If we consider the student with the maximum programming skill in the team, we can take him to this team instad of forming the new team with this student because this is always not worse.So the second transition is the following: let  be the number of students in a team if the -th student is the first in it. We can calculate this part in  naively or in  using two pointers.We can set .Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tsort(a.begin(), a.end());\n\tvector<int> cnt(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\twhile (i + cnt[i] < n && a[i + cnt[i]] - a[i] <= 5) {\n\t\t\t++cnt[i];\n\t\t}\n\t}\n\t\n\tvector<vector<int>> dp(n + 1, vector<int>(k + 1));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= k; ++j) {\n\t\t\tdp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);\n\t\t\tif (j + 1 <= k) {\n\t\t\t\tdp[i + cnt[i]][j + 1] = max(dp[i + cnt[i]][j + 1], dp[i][j] + cnt[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << dp[n][k] << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}