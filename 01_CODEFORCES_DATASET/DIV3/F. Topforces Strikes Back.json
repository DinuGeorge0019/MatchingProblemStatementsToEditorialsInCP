{"link": "https://codeforces.com//contest/1183/problem/F", "problemId": "363546", "shortId": "1183F", "contest_number": "1183", "name": "F. Topforces Strikes Back", "statement": "One important contest will take place on the most famous programming platform (Topforces) very soon!The authors have a pool of  problems and should choose  of them into this contest. The prettiness of the -th problem is . The authors have to compose the most pretty contest (in other words, the cumulative prettinesses of chosen problems should be ).But there is one important thing in the contest preparation: because of some superstitions of authors, the prettinesses of problems cannot divide each other. In other words, if the prettinesses of chosen problems are , then  should be divisible by neither , nor ,  should be divisible by neither , nor  and  should be divisible by neither , nor . If the prettinesses of chosen problems are  and  then neither  should be divisible by  nor  should be divisible by . Any contest composed from one problem is considered good.Your task is to find out the maximum possible total prettiness of the contest composed of  problems from the given pool.You have to answer  independent queries.", "input": "The first line of the input contains one integer  () \u2014 the number of queries. The first line of the query contains one integer  () \u2014 the number of problems. The second line of the query contains  integers  (), where  is the prettiness of the -th problem. It is guaranteed that the sum of  over all queries does not exceed .", "output": "For each query print one integer \u2014 the maximum possible cumulative prettiness of the contest composed of  problems from the given pool of problems in the query.", "tutorial": "I know about some solutions that are trying to iterate over almost all possible triples, but I have a better and more interesting one. Possibly, it was already mentioned in comments, but I need to explain it.Let's solve the problem greedily. Let's sort the initial array. The first number we would like to choose is the maximum element. Then we need to pop out some maximum elements that are divisors of the maximum. Then there are two cases: the array becomes empty, or we have some maximum number that does not divide the chosen number. Let's take it and repeat the same procedure again, but now we have to find the number that does not divide neither the first taken number nor the second taken number.So we have at most three numbers after this procedure. Let's update the answer with their sum. This solution is almost correct. Almost! What have we forgotten? Let's imagine that the maximum element is divisible by ,  and  and there are three following numbers in the array: maximum divided by , by  and by . Then their sum is greater than the maximum (and may be greater than the answer we have!) because . So if these conditions are satisfied, let's update the answer with the sum of these three numbers.It can be shown that this is the only possible triple that can break our solution. The triple  does not match because the maximum divided by  divides the maximum divided by . The triple  is bad for the same reason. And the triple  has sum less than the maximum element.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint n;\n\t\tcin >> n;\n\t\tset<int> st;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tst.insert(x);\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tint mx = *st.rbegin();\n\t\tif (mx % 2 == 0 && mx % 3 == 0 && mx % 5 == 0) {\n\t\t\tif (st.count(mx / 2) && st.count(mx / 3) && st.count(mx / 5)) {\n\t\t\t\tans = max(ans, mx / 2 + mx / 3 + mx / 5);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<int> res;\n\t\twhile (!st.empty() && int(res.size()) < 3) {\n\t\t\tint x = *st.rbegin();\n\t\t\tst.erase(prev(st.end()));\n\t\t\tbool ok = true;\n\t\t\tfor (auto it : res) ok &= (it % x != 0);\n\t\t\tif (ok) res.push_back(x);\n\t\t}\n\t\t\n\t\tans = max(ans, accumulate(res.begin(), res.end(), 0));\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}