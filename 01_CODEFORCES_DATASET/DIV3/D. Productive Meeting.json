{"link": "https://codeforces.com//contest/1579/problem/D", "problemId": "1123869", "shortId": "1579D", "contest_number": "1579", "name": "D. Productive Meeting", "statement": "An important meeting is to be held and there are exactly  people invited. At any moment, any two people can step back and talk in private. The same two people can talk several (as many as they want) times per meeting.Each person has limited . The sociability of the -th person is a non-negative integer . This means that after exactly  talks this person leaves the meeting (and does not talk to anyone else anymore). If , the -th person leaves the meeting immediately after it starts.A meeting is considered most  if the maximum possible number of talks took place during it.You are given an array of sociability , determine which people should talk to each other so that the total number of talks is as large as possible.", "input": "The first line contains an integer  ()\u00a0\u2014 the number of test cases. The next  lines contain descriptions of the test cases. The first line of each test case description contains an integer  ()\u00a0\u2014the number of people in the meeting. The second line consists of  space-separated integers  ()\u00a0\u2014 the sociability parameters of all people.  It is guaranteed that the sum of  over all test cases does not exceed . It is also guaranteed that the sum of all  (over all test cases and all ) does not exceed .", "output": "Print  answers to all test cases. On the first line of each answer print the number \u00a0\u2014 the maximum number of talks possible in a meeting. On each of the next  lines print two integers  and  ( and )\u00a0\u2014 the numbers of people who will have another talk. If there are several possible answers, you may print any of them.", "tutorial": "For the first conversation let's choose two people  and  with maximal values of sociability. Note that after this conversation takes place, we move on to a similar problem, but in which  and  are decreased by . After decreasing  and  by , we repeat the choice of the two people with the maximum values of sociability. Let us repeat such iterations while at least two people with positive sociability parameters remain.Let us prove that this solution leads to the optimal answer. Let's denote the sum  by  and consider two fundamentally different cases:   The maximal element  is greater than or equal to the sum of all remaining elements. That is, there exists  such that . In this case, note that the -th person can not possibly have more than  conversations, because by that point all other people already reached their sociability limits and left the meeting. Thus, if , the answer cannot be more than . Note that this estimation is accurate since an example exists in which -th person talks to all other people as many times as possible (that is,  times with -th person for all ). And the algorithm described above will just choose the th person as one of the participants of a conversation every time, because for every conversation both  and  decrease by exactly , so the inequality holds and it follows that   Otherwise, we can prove that the maximum number of conversations is always . Obviously, it is impossible to get more than this number, since each conversation requires exactly two units of sociability (one from two people), while a larger answer would mean that  which is obviously wrong. Let us prove that this answer is achieved by the described algorithm. Let's look at the last conversation held. If there are at least two more people left in the meeting after it, we can hold another conversation, which means there is a more optimal answer. If there are zero people left in the meeting, then an estimate of  of conversations has been achieved. And if there is one person with a remaining sociability , then an estimate of  of conversations has been achieved. If there is exactly one remaining person  with a sociability residual , then we can guarantee that this person has participated in all previous conversations. Indeed, let's look at the last conversation\u00a0\u2014 it was held between two people with the maximum parameters of the remaining sociability. But the -th person has at least  sociability remaining, so it couldn't have been the other two people with residuals of  who left right after that. Thus, analyzing all conversations in reverse order, we can prove that at any time , which means that it is in fact the case considered above. We have proven that the described greedy algorithm works. This algorithm can be implemented by using any balanced search tree, such as . By storing pairs of elements  in it, we could for  each time choose the next two people to talk to and update the sociability values.The time complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        auto cmp = [](pii const &x, pii const &y) {\n            return x > y;\n        };\n        set<pii, decltype(cmp)> a(cmp);\n        vector<pii> answer;\n        for (int i = 0; i < n; i++) {\n            int ai;\n            cin >> ai;\n            if (ai > 0)\n                a.emplace(ai, i + 1);\n        }\n        while (a.size() > 1) {\n            auto p1 = *a.begin();\n            a.erase(a.begin());\n            auto p2 = *a.begin();\n            a.erase(a.begin());\n            answer.emplace_back(p1.second, p2.second);\n            if (p1.first > 1) a.emplace(p1.first - 1, p1.second);\n            if (p2.first > 1) a.emplace(p2.first - 1, p2.second);\n        }\n        cout << answer.size() << '\\n';\n        for (auto &p : answer) {\n            cout << p.first << ' ' << p.second << '\\n';\n        }\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}