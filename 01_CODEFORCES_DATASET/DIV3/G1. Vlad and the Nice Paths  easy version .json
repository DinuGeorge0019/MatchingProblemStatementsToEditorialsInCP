{"link": "https://codeforces.com//contest/1811/problem/G1", "problemId": "1864329", "shortId": "1811G1", "contest_number": "1811", "name": "G1. Vlad and the Nice Paths  easy version ", "statement": ".Vlad found a row of  tiles and the integer . The tiles are indexed from left to right and the -th tile has the color . After a little thought, he decided what to do with it.You can start from any tile and jump to any number of tiles , forming the path . Let's call the path  of length   if:   can be divided into blocks of length exactly , that is,  is divisible by ;  ;  ;    ; Your task is to find the number of  paths of  length. Since this number may be too large, print it modulo .", "input": "The first line of each test contains the integer  ()\u00a0\u2014 the number of test cases in the test. The first line of each test case contains two integers  and  () \u2014 the number of tiles in a row and the length of the block. The second line of each test case contains  integers  () \u2014 tile colors. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "Print  numbers, each of which is the answer to the corresponding test case\u00a0\u2014 the number of  paths of maximum length modulo .", "tutorial": "Let's use the dynamic programming. Let  be the number of paths on the prefix  of  blocks of the same color. To make transitions in such dynamics, for the position , we will iterate over the position  in which the block started. Denote as  the number of the same elements as  and  between them, then such a transition creates  combinations. This solution works in  complexity.", "solution": "M = 10 ** 9 + 7\n\n\ndef pw(a, n):\n    if n == 0:\n        return 1\n    b = pw(a, n // 2)\n    return b * b % M * (a if n % 2 == 1 else 1) % M\n\n\ndef obr(x):\n    return pw(x, M - 2)\n\n\ndef cnk(n, k):\n    return fact[n] * obr(fact[k]) % M * obr(fact[n - k]) % M\n\n\ndef solve():\n    n, k = map(int, input().split())\n    c = [-1] + [int(x) for x in input().split()]\n    if k == 1:\n        print(1)\n        return\n    dp = [[0] * (n // k + 1) for i in range(n + 1)]  # dp[i][j] = number for i prefix with j blocks\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(0, n // k + 1):\n            if j > 0:\n                sz = 1\n                for s in range(i - 1, - 1, -1):\n                    if c[s] == c[i]:\n                        sz += 1\n                        if sz >= k:\n                            dp[i][j] += dp[s - 1][j - 1] * cnk(sz - 2, k - 2) % M\n                            dp[i][j] %= M\n            dp[i][j] += dp[i - 1][j]\n            dp[i][j] %= M\n    for j in range(n // k, -1, -1):\n        if dp[n][j] > 0:\n            print(dp[n][j])\n            return\n\n\nt = int(input())\nfact = [1] * 101\nfor i in range(1, 101):\n    fact[i] = fact[i - 1] * i % M\nfor _ in range(t):\n    solve()", "interactive": false, "noSolution": false, "noTutorial": false}