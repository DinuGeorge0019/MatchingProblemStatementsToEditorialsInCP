{"link": "https://codeforces.com//contest/1593/problem/E", "problemId": "1142166", "shortId": "1593E", "contest_number": "1593", "name": "E. Gardener and Tree", "statement": "A tree is an undirected connected graph in which there are no cycles. This problem is about non-rooted trees. A leaf of a tree is a vertex that is connected to  vertex.The gardener Vitaly grew a tree from  vertices. He decided to trim the tree. To do this, he performs a number of operations. In one operation, he removes  leaves of the tree.   For example, consider the tree shown in the figure above. The figure below shows the result of applying exactly one operation to the tree.   Note the special cases of the operation:  applying an operation to an empty tree (of  vertices) does not change it;  applying an operation to a tree of one vertex removes this vertex (this vertex is treated as a leaf);  applying an operation to a tree of two vertices removes both vertices (both vertices are treated as leaves). Vitaly applied  operations sequentially to the tree. How many vertices remain?", "input": "The first line contains one integer  () \u2014 the number of test cases. Then  test cases follow. Each test case is preceded by an empty line. Each test case consists of several lines. The first line of the test case contains two integers  and  (, ) \u2014 the number of vertices in the tree and the number of operations, respectively. Then  lines follow, each of them contains two integers  and  (, ) which describe a pair of vertices connected by an edge. It is guaranteed that the given graph is a tree and has no loops or multiple edges. It is guaranteed that the sum of  from all test cases does not exceed .", "output": "For each test case output on a separate line a single integer \u2014 the number of vertices that remain in the tree after applying  operations.", "tutorial": "Let's create two arrays of length . The element of the array  will contain the operation number at which the vertex which is the index of the array will be deleted. The  array will contain the number of neighbors of a given vertex at a certain time. This array must be initialized with the number of neighbors in the original tree.Initially, we will suppose that the gardener performs an infinite number of operations, and we will simply calculate for each vertex the number of the operation on which it will be deleted. Let's create a queue , which will store the order of deleting vertices. The queue will contain only those vertices whose neighbors, except, maybe, one, have been removed (i.e. ). Let's add all leaves of the original tree to it, for each of them let's store the value  in the array  (because all original leaves will be removed during the first operation).Next, we will take sequentially one vertex from the queue and update the data about its neighbors. Consider the neighbors. Since we are deleting the current vertex, we need to update  of its neighbors. If the neighbor's  is equal to , then it's already in the queue and it doesn't need to be considered right now. Otherwise, we will decrease the neighbor's  by . If it becomes equal to , then the neighbor must be added to the queue. The number of the operation during which the neighbor will be deleted is equal to the number of the operation during which the current vertex will be deleted plus .After we calculate the numbers of operations for all vertices, we need to select among them those that will not be deleted during operations with numbers . Thus, the answer is the number of vertices  such that .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\n\twhile (t--)\n\t{\n\t\tint n, k;\n\t\tcin >> n >> k;\n\n\t\tvector<vector<int>> g(n, vector<int>());\n\t\tvector<int> rem(n, 0);\n\t\tvector<int> layer(n, 0);\n\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tg[x].push_back(y);\n\t\t\tg[y].push_back(x);\n\t\t\trem[x]++;\n\t\t\trem[y]++;\n\t\t}\n\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (rem[i] == 1)\n\t\t\t{\n\t\t\t\tq.push(i);\n\t\t\t\tlayer[i] = 1;\n\t\t\t}\n\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int v : g[u])\n\t\t\t{\n\t\t\t\tif (rem[v] != 1)\n\t\t\t\t{\n\t\t\t\t\trem[v]--;\n\t\t\t\t\tif (rem[v] == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tlayer[v] = layer[u] + 1;\n\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (layer[i] > k)\n\t\t\t\tans++;\n\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}\n\n", "interactive": false, "noSolution": false, "noTutorial": false}