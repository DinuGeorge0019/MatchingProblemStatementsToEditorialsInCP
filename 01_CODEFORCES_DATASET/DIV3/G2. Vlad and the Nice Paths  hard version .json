{"link": "https://codeforces.com//contest/1811/problem/G2", "problemId": "1864330", "shortId": "1811G2", "contest_number": "1811", "name": "G2. Vlad and the Nice Paths  hard version ", "statement": ".Vlad found a row of  tiles and the integer . The tiles are indexed from left to right and the -th tile has the color . After a little thought, he decided what to do with it.You can start from any tile and jump to any number of tiles , forming the path . Let's call the path  of length   if:   can be divided into blocks of length exactly , that is,  is divisible by ;  ;  ;    ; Your task is to find the number of  paths of  length. Since this number may be too large, print it modulo .", "input": "The first line of each test contains the integer  ()\u00a0\u2014 the number of test cases in the test. The first line of each test case contains two integers  and  () \u2014 the number of tiles in a row and the length of the block. The second line of each test case contains  integers  () \u2014 tile colors. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "Print  numbers, each of which is the answer to the corresponding test case\u00a0\u2014 the number of  paths of maximum length modulo .", "tutorial": "To solve the hard version, let's modify the simple version solution. Note that the  parameter can be discarded, since we only need paths of maximum length on each prefix. Now, as , we denote a pair of the number of maximum paths and the number of blocks in them. For the position , we will find the position closest to the left, from which we can start a block, and so we will find out what is the maximum for . We will update  until the maximum of the position being sorted is suitable for us.", "solution": "from sys import stdin\ninput = lambda: stdin.readline().strip()\n\n\nM = 10 ** 9 + 7\ncnk = [[0] * (5000 + 1) for i in range(5000 + 1)]\n\n\ndef solve():\n    n, k = map(int, input().split())\n    c = [-1] + [int(x) for x in input().split()]\n    if k == 1:\n        print(1)\n        return\n    dp = [[0, 0] for i in range(n + 1)]  # dp[i] = [number, max] for i prefix\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        sz = 1\n        for s in range(i - 1, - 1, -1):\n            if c[s] == c[i]:\n                sz += 1\n                if sz == k:\n                    dp[i][1] = dp[s - 1][1] + 1\n                if sz >= k:\n                    if dp[s - 1][1] < dp[i][1] - 1:\n                        break\n                    dp[i][0] += dp[s - 1][0] * cnk[sz - 2][k - 2] % M\n                    dp[i][0] %= M\n        if dp[i][1] < dp[i - 1][1]:\n            dp[i] = [0, dp[i - 1][1]]\n        if dp[i][1] == dp[i - 1][1]:\n            dp[i][0] += dp[i - 1][0]\n            dp[i][0] %= M\n    print(dp[n][0])\n\n\nfor i in range(5000 + 1):\n    cnk[i][0] = 1\nfor i in range(1, 5000 + 1):\n    for j in range(1, i + 1):\n        cnk[i][j] = (cnk[i - 1][j] + cnk[i - 1][j - 1]) % M\n\nt = int(input())\nfor _ in range(t):\n    solve()", "interactive": false, "noSolution": false, "noTutorial": false}