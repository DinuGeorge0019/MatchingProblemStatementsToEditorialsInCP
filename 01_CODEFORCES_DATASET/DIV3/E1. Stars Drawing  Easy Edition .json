{"link": "https://codeforces.com//contest/1015/problem/E1", "problemId": "203550", "shortId": "1015E1", "contest_number": "1015", "name": "E1. Stars Drawing  Easy Edition ", "statement": "A  is a figure of the following type: an asterisk character '' in the center of the figure and four rays (to the left, right, top, bottom) of the same positive length. The size of a  is the length of its rays. The size of a star must be a positive number (i.e. rays of length  are not allowed).Let's consider empty cells are denoted by '', then the following figures are :   You are given a rectangular grid of size  consisting only of asterisks '' and periods (dots) ''. Rows are numbered from  to , columns are numbered from  to . Your task is to draw this grid using  number of  or find out that it is impossible.  can intersect, overlap or even coincide with each other. The number of  in the output can't exceed . Each star should be completely inside the grid. You can use stars of same and arbitrary sizes.", "input": "The first line of the input contains two integers  and  () \u2014 the sizes of the given grid. The next  lines contains  characters each, the -th line describes the -th row of the grid. It is guaranteed that grid consists of characters '' and '' only.", "output": "If it is impossible to draw the given grid using  only, print \"\". Otherwise in the first line print one integer  () \u2014 the number of  needed to draw the given grid. The next  lines should contain three integers each \u2014 ,  and , where  is the row index of the central  character,  is the column index of the central  character and  is the size of the . Each  should be completely inside the grid.", "tutorial": "Since we are almost unlimited in the number of  in the answer, the following solution will works. We iterate over all possible  centers and try to extend rays of the current  as large as possible. It can be done by the simple iterating and checking in . If the size of the current  is non-zero, let's add it to the answer. It is obvious that the number of  in such answer will not exceed . Then let's try to draw all these  on the empty grid. Drawing of each  is also can be done in . If after drawing our grid equals to the input grid, the answer is \"\" and our set of  is the correct answer. Otherwise the answer is \"\".Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nconst int dx[] = {1, 0, -1,  0};\nconst int dy[] = {0, 1,  0, -1};\nconst int N = 1001;\n\nint n, m;\nvector<string> f;\nint d[N][N][4];\nint r[N][N], a[N][N], b[N][N];\n\nint getd(int i, int j, int k) {\n    int dxk = dx[k];\n    int dyk = dy[k];\n    int result = 0;\n    while (i >= 0 && i < n && j >= 0 && j < m && f[i][j] == '*')\n        result++, i += dxk, j += dyk;\n    return result;\n}\n\nint main() {\n    cin >> n >> m;\n    f = vector<string>(n);\n    forn(i, n)\n        cin >> f[i];\n    \n    memset(d, -1, sizeof(d));\n    int result = 0;\n    for (int i = 1; i + 1 < n; i++)\n        for (int j = 1; j + 1 < m; j++)\n            if (f[i][j] == '*') {\n                bool around = true;\n                forn(k, 4)\n                    around = around && (f[i + dx[k]][j + dy[k]] == '*');\n                if (around) {\n                    r[i][j] = INT_MAX;\n                    forn(k, 4)\n                        r[i][j] = min(r[i][j], getd(i, j, k) - 1);\n                    result++;\n                    a[i][j - r[i][j]] = max(a[i][j - r[i][j]], 2 * r[i][j] + 1);\n                    b[i - r[i][j]][j] = max(b[i - r[i][j]][j], 2 * r[i][j] + 1);\n                }\n            }\n\n    vector<string> g(n, string(m, '.'));\n    forn(i, n) {\n        int v = 0;\n        forn(j, m) {\n            v = max(v - 1, a[i][j]);\n            if (v > 0)\n                g[i][j] = '*';\n        }\n    }\n    forn(j, m) {\n        int v = 0;\n        forn(i, n) {\n            v = max(v - 1, b[i][j]);\n            if (v > 0)\n                g[i][j] = '*';\n        }\n    }\n    \n    if (f == g) {\n        cout << result << endl;\n        forn(i, n)\n            forn(j, m)\n                if (r[i][j] > 0)\n                    cout << i + 1 << \" \" << j + 1 << \" \" << r[i][j] << endl;\n    } else\n        cout << -1 << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}