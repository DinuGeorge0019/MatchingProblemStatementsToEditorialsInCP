{"link": "https://codeforces.com//contest/1272/problem/C", "problemId": "494355", "shortId": "1272C", "contest_number": "1272", "name": "C. Yet Another Broken Keyboard", "statement": "Recently, Norge found a string  consisting of  lowercase Latin letters. As an exercise to improve his typing speed, he decided to type all substrings of the string . Yes, all  of them!A substring of  is a non-empty string  (). For example, \"\" and \"\" are substrings of \"\".Shortly after the start of the exercise, Norge realized that his keyboard was broken, namely, he could use only  Latin letters  out of .After that, Norge became interested in how many substrings of the string  he could still type using his broken keyboard. Help him to find this number.", "input": "The first line contains two space-separated integers  and  (, ) \u2014 the length of the string  and the number of Latin letters still available on the keyboard. The second line contains the string  consisting of exactly  lowercase Latin letters. The third line contains  space-separated distinct lowercase Latin letters  \u2014 the letters still available on the keyboard.", "output": "Print a single number \u2014 the number of substrings of  that can be typed using only available letters .", "tutorial": "Let's replace all characters of  with zeros and ones (zero if the character is unavailable and one otherwise). Then we have the binary string and we have to calculate the number of contiguous segments of this string consisting only of ones. It can be done with two pointers approach.If we are staying at the position  and its value is zero, just skip it. Otherwise, let's find the leftmost position  such that  and the -th value is zero. Then we have to add to the answer the value  and set .Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\tset<char> st;\n\tfor (int i = 0; i < k; ++i) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tst.insert(c);\n\t}\n\t\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint j = i;\n\t\twhile (j < n && st.count(s[j])) ++j;\n\t\tint len = j - i;\n\t\tans += len * 1ll * (len + 1) / 2;\n\t\ti = j;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}