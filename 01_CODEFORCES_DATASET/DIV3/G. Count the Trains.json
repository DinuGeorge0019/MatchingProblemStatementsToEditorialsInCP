{"link": "https://codeforces.com//contest/1690/problem/G", "problemId": "1423055", "shortId": "1690G", "contest_number": "1690", "name": "G. Count the Trains", "statement": "There are  of independent carriages on the rails. The carriages are numbered from left to right from  to . The carriages are not connected to each other. The carriages move to the left, so that the carriage with number  moves ahead of all of them.The -th carriage has its own engine, which can accelerate the carriage to  km/h, but the carriage cannot go faster than the carriage in front of it. See example for explanation.All carriages start moving to the left at the same time, and they naturally form . We will call \u00a0\u2014 consecutive moving carriages having the same speed.For example, we have  carriages and array . Then the final speeds of the carriages will be . Respectively,  of the train will be formed.There are also messages saying that some engine has been corrupted:  message \"\" means that the speed of the -th carriage has decreased by  (that is, there has been a change in the maximum speed of the carriage ).  Messages arrive sequentially, the processing of the next message takes into account the changes from all previous messages.After each message determine the number of formed trains.", "input": "The first line of input data contains a single integer  ()\u00a0\u2014the number of input test cases. This is followed by descriptions of the test cases. The first line of each test case is empty. The second line of the test case contains two integers  and  ()\u00a0\u2014the number of carriages and the number of messages to slow down the carriage, respectively. The third line contains  integers:  ()\u00a0\u2014 the number  means that the carriage with number  can reach a speed of  km/h.  The next  lines contain two integers  and  (, )\u00a0\u2014this is the message that the speed of the carriage with number  has decreased by . In other words, there has been a change in its maximum speed . Note that at any time the speed of each carriage is non-negative. In other words, , where \u00a0\u2014is the sum of such  that . It is guaranteed that the sum of  over all test cases does not exceed . Similarly, it is guaranteed that the sum of  over all test cases does not exceed .", "output": "Print  lines. On each line print the answer for the corresponding test case. For each test case print  numbers: the number of trains formed after each message.", "tutorial": "In the set we will keep the indices that start the trains. That is, if the array \u00a0\u2014 the real speeds of the carriages, then we will store in the network such values  that . As well as the value of . Thus, the size of the set\u00a0\u2014is the answer to the problem. Consider now the operation to reduce the speed of the carriage: find such maximal index  in the set, if the value , then we should add the value  to the set, since it will start a new train. Then we should remove all subsequent indexes  from the set such that . Thus, for all operations we will add no more than  elements to the array, and remove in total no more than  elements from the set. We obtain the asymptotic .", "solution": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        vector<int> a(n);\n        set<int> tmp;\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n            if (tmp.empty() || a[i] < a[*tmp.rbegin()]) {\n                tmp.insert(i);\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            int j, d;\n            cin >> j >> d;\n            j--;\n            a[j] -= d;\n            auto it = tmp.upper_bound(j);\n            if (it != tmp.begin()) {\n                it = prev(it);\n                if (*it == j || a[*it] > a[j]) {\n                    tmp.insert(j);\n                }\n            } else {\n                tmp.insert(j);\n            }\n            while (1) {\n                it = tmp.upper_bound(j);\n                if (it != tmp.end() && a[*it] >= a[j]) {\n                    tmp.erase(it);\n                } else {\n                    break;\n                }\n            }\n            cout << (int) tmp.size() << \" \";\n        }\n        cout << '\\n';\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}