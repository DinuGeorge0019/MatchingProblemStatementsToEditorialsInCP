{"link": "https://codeforces.com//contest/1196/problem/B", "problemId": "377791", "shortId": "1196B", "contest_number": "1196", "name": "B. Odd Sum Segments", "statement": "You are given an array  consisting of  integers . You want to split it into exactly   such that each subsegment has odd sum (i.\u2009e. for each subsegment, the sum of all elements that belong to this subsegment is odd). It is impossible to rearrange (shuffle) the elements of a given array. Each of the  elements of the array  must belong to exactly one of the  subsegments.Let's see some examples of dividing the array of length  into  subsegments (not necessarily with odd sums):  is the initial array, then all possible ways to divide it into  non-empty non-intersecting subsegments are described below:  ;  ;  ;  ;  ;  . Of course, it can be impossible to divide the initial array into exactly  subsegments in such a way that each of them will have odd sum of elements. In this case print \"\". Otherwise, print \"\" and  possible division of the array. See the output format for the detailed explanation.You have to answer  independent queries.", "input": "The first line contains one integer  () \u2014 the number of queries. Then  queries follow. The first line of the query contains two integers  and  () \u2014 the number of elements in the array and the number of subsegments, respectively. The second line of the query contains  integers  (), where  is the -th element of . It is guaranteed that the sum of  over all queries does not exceed  ().", "output": "For each query, print the answer to it. If it is impossible to divide the initial array into exactly  subsegments in such a way that each of them will have odd sum of elements, print \"\" in the first line. Otherwise, print \"\" in the first line and  possible division of the array in the second line. The division can be represented as  integers , , ...,  such that , where  is the right border of the -th segment (the index of the last element that belongs to the -th segment), so the array is divided into subsegments . . ", "tutorial": "Firstly, let  be the number of odd elements in the array. Note that even elements are don't matter at all because they cannot change the parity of the sum.If  then it is obviously impossible to split the given array into  subsegments with odd sum. And if  then it is impossible to split the array into  subsegments with odd sum also because at least one of  segments will have even number of odd elements (so will have odd sum).In other cases the answer is always \"\" and you can print  leftmost positions of odd elements and  as right borders of segments (it means that when you find one odd element, you end one segment). Because  now, the last segment will have odd number of odd elements so it will have odd sum also.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tvector<int> a(n);\n\t\tint cntodd = 0;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tcin >> a[j];\n\t\t\tcntodd += a[j] % 2;\n\t\t}\n\t\tif (cntodd < k || cntodd % 2 != k % 2) {\n\t\t\tcout << \"NO\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << \"YES\" << endl;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (k == 1) break;\n\t\t\tif (a[j] % 2 == 1) {\n\t\t\t\tcout << j + 1 << \" \";\n\t\t\t\t--k;\n\t\t\t}\n\t\t}\n\t\tcout << n << endl;\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}