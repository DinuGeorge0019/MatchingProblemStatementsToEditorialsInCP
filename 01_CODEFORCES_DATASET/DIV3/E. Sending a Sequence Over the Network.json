{"link": "https://codeforces.com//contest/1741/problem/E", "problemId": "1580861", "shortId": "1741E", "contest_number": "1741", "name": "E. Sending a Sequence Over the Network", "statement": "The sequence  is sent over the network as follows:  sequence  is split into segments (each element of the sequence belongs to exactly one segment, each segment is a group of consecutive elements of sequence);  for each segment, its length is written next to it, either to the left of it or to the right of it;  the resulting sequence  is sent over the network. For example, we needed to send the sequence . Suppose it was split into segments as follows: . Then we could have the following sequences:   ,  ,  ,  . If a different segmentation had been used, the sent sequence might have been different.The sequence  is given. Could the sequence  be sent over the network? In other words, is there such a sequence  that converting  to send it over the network could result in a sequence ?", "input": "The first line of input data contains a single integer  ()\u00a0\u2014 the number of test cases. Each test case consists of two lines. The first line of the test case contains an integer  ()\u00a0\u2014 the size of the sequence . The second line of test case contains  integers  ()\u00a0\u2014 the sequence  itself. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case print on a separate line:    if sequence  could be sent over the network, that is, if sequence  could be obtained from some sequence  to send  over the network.   otherwise.  You can output  and  in any case (for example, strings , ,  and  will be recognized as positive response).", "tutorial": "Let's introduce the dynamics.  if on the prefix  the answer is . Then in this sequence  the numbers corresponding to the sizes of the segments from the partition  into subsegments will be called .A number at position  in the sequence , if it is , is either to the right or to the left of the segment.   If it is to the left of the segment, it can only be interesting if . Then .  If it is on the right side of the segment, then if , then . The answer for the whole sequence is  if .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define sz(v) (int)v.size()\n#define all(v) v.begin(),v.end()\n#define eb emplace_back\n\n\n\nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n+1);\n    for (int i = 1; i <= n; ++i) {\n        cin >> a[i];\n    }\n\n    vector<bool> dp(n+1, false);\n    dp[0] = true;\n    for (int i = 1; i <= n; ++i) {\n        if (i + a[i] <= n && dp[i-1]) dp[i + a[i]] = true;\n        if (i - a[i] - 1 >= 0 && dp[i - a[i] - 1]) dp[i] = true;\n    }\n    cout << (dp[n] ? \"YES\" : \"NO\") << '\\n';\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    forn(tt, t) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}