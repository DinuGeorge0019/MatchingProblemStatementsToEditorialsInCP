{"link": "https://codeforces.com//contest/1005/problem/E1", "problemId": "196329", "shortId": "1005E1", "contest_number": "1005", "name": "E1. Median on Segments  Permutations Edition ", "statement": "You are given a permutation . A permutation of length  is a sequence such that each integer between  and  occurs exactly once in the sequence.Find the number of pairs of indices  () such that the value of the median of  is exactly the given number .The median of a sequence is the value of the element which is in the middle of the sequence after sorting it in non-decreasing order. If the length of the sequence is even, the left of two middle elements is used.For example, if  then its median is  since after sorting the sequence, it will look like  and the left of two middle elements is equal to . The median of  equals  since after sorting, the value  will be in the middle of the sequence.Write a program to find the number of pairs of indices  () such that the value of the median of  is exactly the given number .", "input": "The first line contains integers  and  (, ) \u2014 the length of the given sequence and the required value of the median. The second line contains a permutation  (). Each integer between  and  occurs in  exactly once.", "output": "Print the required number.", "tutorial": "The segment  has median equals  if and only if  belongs to it and  or , where  is number of elements in  that strictly less than  and  is number of elements in  that strictly greater than . Here we've used a fact that  is a permutation (on  there is exactly one occurrence of ).In other words,  belongs  and the value  equals  or .Calculate prefix sums , where  the value  on the prefix of the length  (i.e. on the subarray ). For fixed value  it is easy to calculate number of such  that  is suitable. At first, check that  met on . Valid values  are such indices that: no  on  and  or .Let's maintain number of prefix sums  to the left of  for each value. We can use just a map , where  is number of such indices  that  and  is to the left of .So for each  that  contains  do , where  is the current value .Time complexity is  if a standard map is used or  if classical array for  is used (remember about possible negative indices, just use an offset).\n", "solution": "int n, m;\ncin >> n >> m;\nvector<int> p(n);\nforn(i, n)\n    cin >> p[i];\nmap<int,int> c;\nc[0] = 1;\nbool has = false;\nint sum = 0;\nlong long ans = 0;\nfor (int r = 0; r < n; r++) {\n    if (p[r] < m)\n        sum--;\n    else if (p[r] > m)\n        sum++;\n\n    if (p[r] == m)\n        has = true;\n    if (has)\n        ans += c[sum] + c[sum - 1];\n    else\n        c[sum]++;\n}\ncout << ans << endl;", "interactive": false, "noSolution": false, "noTutorial": false}