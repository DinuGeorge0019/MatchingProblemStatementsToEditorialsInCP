{"link": "https://codeforces.com//contest/1118/problem/F2", "problemId": "300362", "shortId": "1118F2", "contest_number": "1118", "name": "F2. Tree Cutting  Hard Version ", "statement": "You are given an undirected tree of  vertices. Some vertices are colored one of the  colors, some are uncolored. It is guaranteed that the tree contains at least one vertex of each of the  colors. There might be no uncolored vertices.You choose a subset of  and remove it from the tree. Tree falls apart into  connected components. Let's call this subset of edges  if none of the resulting components contain vertices of different colors.How many  subsets of edges are there in the given tree? Two subsets are considered different if there is some edge that is present in one subset and absent in the other.The answer may be large, so print it modulo .", "input": "The first line contains two integers  and  (, ) \u2014 the number of vertices in the tree and the number of colors, respectively. The second line contains  integers  () \u2014 the colors of the vertices.  means that vertex  is uncolored, any other value means the vertex  is colored that color. The -th of the next  lines contains two integers  and  (, ) \u2014 the edges of the tree. It is guaranteed that the given edges form a tree. It is guaranteed that the tree contains at least one vertex of each of the  colors. There might be no uncolored vertices.", "output": "Print a single integer \u2014 the number of  subsets of edges in the given tree. Two subsets are considered different if there is some edge that is present in one subset and absent in the other. The answer may be large, so print it modulo .", "tutorial": "Okay, this solution is really complicated and I would like to hear nicer approaches from you in comments if you have any. However, I still feel like it's ok to have this problem in a contest specifically as a harder version of F1.Let's start with the following thing. Root the tree by some vertex. For each color take all vertices of this color and paint their lowest common ancestor the same color as them. The purpose of that will come clear later. Why can we do this? The case with lca = some vertex of that color is trivial. Now, take a look at the edges from lca to its subtrees. At least two of them contain a vertex of that color. You can't cut the edges to these subtrees because this will make vertices of the same color belong to different components. Thus, lca will always be in the same component as these vertices. If lca is already painted the other color then the answer is 0. That's because lca once again make vertices of the same color belong to different components.Now everything will be calculated in a single dfs. Let  return one of the following values:  , if there is no colored vertex in the subtree of ;  , if there exists some color  such that vertex  has vertices of color  in its subtree and vertex  has ancestors of color  (not necesserily direct parent);  , otherwise. I claim that if there are multiple suitable colors for some vertex  then the answer is 0. Let's take a look at any two of them and call them colors  and . For both colors take a path from arbitrary vertex of that color in subtree to arbitrary vertex of that color that is ancestor of . You can't cut any edge on these paths because that will divide the vertices of the same color. Now, either path for color  contains vertex of color  or path for color  contains vertex of color . That vertex is the upper end of the corresponding path. That means that component of one color includes the vertex of the other color, which is impossible.Moreover, that's the last specific check for the answer being 0. The step with lca helped us to move to the ancestor instead of any vertex in the upper subtree of . I truly believe that you can avoid lca in this solution, however, that will make both implementation and proof harder.Now let's do  \u2014 the number of ways to cut some edges in the subtree of  so that: 0 \u2014 the component with vertex  has no colored vertices in it, 1 \u2014 has some colored vertices. Generally, the color itself for 1 doesn't matter. If for some child  of :  returned color  then it must be color  in that component, otherwise the color doesn't matter. For  all vertices of each color presented in the subtree of  are contained within the subtree of .The transitions will be of form \"do we cut the edge from  to  or not\" for all children  of . That is the most tedious part so I'm sorry if I mess up something the way I did with my author solution :DHere from now I'll ignore the children that returned  (if I say all children, I will mean all non-zero returning children) as they add nothing to the answer. If there are no children, then the vertices with  will have ,  and the other vertices will have , .Basically, there are two main cases. I would recommend to follow the code in attachment while reading this, tbh.  and all children dfs returned . Then for each edge to the child you can either cut it if there are colored vertices (take ) or don't cut it if it has no colored vertices (take ). So . For  to have some color you'll need to push that color from exactly one of the children. You can't choose two subtrees because they are guaranteed to have different colors in them (otherwise they wouldn't return ). So . To calculate that fast enough you'll need to precalculate prefix and suffix products of .  or  but some children returned the same value . Then you are required to make  the part of component with vertices of color . That means that  for that case. For children, who returned , you don't cut their edge (take ). For the other children you can either cut it if there are colored vertices (take ) or don't cut it if it has no colored vertices (take ). Thus, .The answer will be stored in  after that.Overall complexity:  but I'm sure this can be rewritten in such a manner that it becomes .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 300 * 1000 + 13;\nconst int LOGN = 19;\nconst int MOD = 998244353;\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\tif (a < 0)\n\t\ta += MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * 1ll * b % MOD;\n}\n\nint a[N];\nvector<int> g[N];\nint up[N][LOGN];\nint d[N];\n\nvoid init(int v, int p = -1){\n\tfor (auto u : g[v]) if (u != p){\n\t\tup[u][0] = v;\n\t\tfor (int i = 1; i < LOGN; ++i)\n\t\t\tup[u][i] = up[up[u][i - 1]][i - 1];\n\t\td[u] = d[v] + 1;\n\t\tinit(u, v);\n\t}\n}\n\nint lca(int v, int u){\n\tif (d[v] < d[u]) swap(v, u);\n\tfor (int i = LOGN - 1; i >= 0; --i)\n\t\tif (d[up[v][i]] >= d[u])\n\t\t\tv = up[v][i];\n\tif (v == u) return v;\n\tfor (int i = LOGN - 1; i >= 0; --i)\n\t\tif (up[v][i] != up[u][i]){\n\t\t\tv = up[v][i];\n\t\t\tu = up[u][i];\n\t\t}\n\treturn up[v][0];\n}\n\nint l[N];\nint dp[N][2];\n\nint dfs(int v, int p = -1){\n\tvector<pair<int, int>> cur;\n\tfor (auto u : g[v]) if (u != p){\n\t\tint c = dfs(u, v);\n\t\tif (c != 0)\n\t\t\tcur.push_back(make_pair(c, u));\n\t}\n\t\n\tvector<int> vals;\n\tforn(i, cur.size()) if (cur[i].first > 0)\n\t\tvals.push_back(cur[i].first);\n\t\n\tsort(vals.begin(), vals.end());\n\tvals.resize(unique(vals.begin(), vals.end()) - vals.begin());\n\t\n\tif (int(vals.size()) > 1){\n\t\tputs(\"0\");\n\t\texit(0);\n\t}\n\t\n\tif (a[v] != 0 && !vals.empty() && vals[0] != a[v]){\n\t\tputs(\"0\");\n\t\texit(0);\n\t}\n\t\n\tif (a[v] == 0 && cur.empty())\n\t\treturn 0;\n\t\n\tif (a[v] == 0 && vals.empty()){\t\t\n\t\tvector<int> pr(1, 1), su(1, 1);\n\t\tforn(i, cur.size())\n\t\t\tpr.push_back(mul(pr.back(), add(dp[cur[i].second][0], dp[cur[i].second][1])));\n\t\tfor (int i = int(cur.size()) - 1; i >= 0; --i)\n\t\t\tsu.push_back(mul(su.back(), add(dp[cur[i].second][0], dp[cur[i].second][1])));\n\t\treverse(su.begin(), su.end());\n\t\tdp[v][1] = 0;\n\t\tforn(i, cur.size())\n\t\t\tdp[v][1] = add(dp[v][1], mul(mul(pr[i], su[i + 1]), dp[cur[i].second][1]));\n\t\tdp[v][0] = add(dp[v][0], pr[cur.size()]);\n\t\treturn -1;\n\t}\n\t\n\tdp[v][1] = 1;\n\tfor (auto it : cur){\n\t\tif (it.first == -1)\n\t\t\tdp[v][1] = mul(dp[v][1], add(dp[it.second][0], dp[it.second][1]));\t\n\t\telse\n\t\t\tdp[v][1] = mul(dp[v][1], dp[it.second][1]);\n\t}\n\t\n\tif (a[v] == 0)\n\t\treturn vals[0];\n\t\n\treturn (l[a[v]] == v ? -1 : a[v]);\n}\n\nint main() {\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\t\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tforn(i, n - 1){\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\t\n\tinit(0);\n\t\n\tmemset(l, -1, sizeof(l));\n\tforn(i, n) if (a[i] != 0)\n\t\tl[a[i]] = (l[a[i]] == -1 ? i : lca(l[a[i]], i));\n\t\n\tfor (int i = 1; i <= k; ++i){\n\t\tif (a[l[i]] != 0 && a[l[i]] != i){\n\t\t\tputs(\"0\");\n\t\t\texit(0);\n\t\t}\n\t\ta[l[i]] = i;\n\t}\n\t\n\tdfs(0);\n\t\n\tprintf(\"%d\\n\", dp[0][1]);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}