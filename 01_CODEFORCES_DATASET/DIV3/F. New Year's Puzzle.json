{"link": "https://codeforces.com//contest/1472/problem/F", "problemId": "854356", "shortId": "1472F", "contest_number": "1472", "name": "F. New Year's Puzzle", "statement": "Polycarp got the following problem: given a grid strip of size , some cells of it are blocked. You need to check if it is possible to tile all free cells using the  and  tiles (dominoes).For example, if  and the strip looks like this (black cells are blocked):  Then it can be tiled, for example, using two vertical and two horizontal tiles, as in the picture below (different tiles are marked by different colors).  And if  and the strip looks like this:  It is impossible to tile free cells.Polycarp easily solved this task and received his New Year's gift. Can you solve it?", "input": "The first line contains an integer  ()\u00a0\u2014 the number of test cases. Then  test cases follow. Each test case is preceded by an empty line. The first line of each test case contains two integers  and  (, )\u00a0\u2014 the length of the strip and the number of blocked cells on it. Each of the next  lines contains two integers  ()\u00a0\u2014 numbers of rows and columns of blocked cells. It is guaranteed that all blocked cells are different, i.e. . It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, print on a separate line:    \"\", if it is possible to tile all unblocked squares with the  and  tiles;  \"\" otherwise.  You can output \"\" and \"\" in any case (for example, the strings , ,  and  will be recognized as positive).", "tutorial": "If the first column is empty, we can always cover it with a vertical tile:   if the next column is also empty, then we will have to put either two vertical or two horizontal tiles, but they are obtained from each other by rotating;  if the next column contains at least one blocked cell, then we have no other options but to cover the column with a vertical board. If the first column is fully blocked, then we can just skip it.Remove such columns from the beginning, reducing the problem. Now the first column contains one empty and one blocked cell. Obviously, in place of an empty cell, we will have to place a horizontal tile. If this did not work, then the tiling does not exist. Otherwise there are two cases:   if the next column is empty, it will turn into a column with one occupied cell. Then we continue to put horizontal tiles;  if the next column contains one blocked cell, then it becomes fully blocked and we return to the first step. It turns out the following greedy algorithm, we sort all columns with at least one cell blocked (there are no more than  such columns) by number. Now, if we see a column with one occupied cell, then the next one must also be with one occupied cell (we skipped the empty columns), but this cell must have a different color in the chess coloring (so that we can tile the space between them with horizontal boards. This check is easy to do after sorting the columns.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  map<int, int> v;\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    v[y] |= (1 << (x - 1));\n  }\n  const int FULL = 3;\n  v[2e9] = FULL;\n  int hasLast = 0, lastColor = 0;\n  for (auto[x, mask] : v) {\n    if (mask != FULL && hasLast) {\n      int color = (x + mask) % 2;\n      if (lastColor == color) {\n        cout << \"NO\\n\";\n        return;\n      } else {\n        hasLast = false;\n      }\n    } else if (mask == FULL && hasLast) {\n        cout << \"NO\\n\";\n        return;\n    } else if (mask != FULL) {\n      lastColor = (x + mask) % 2;\n      hasLast = true;\n    }\n  }\n  cout << \"YES\\n\";\n}\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}