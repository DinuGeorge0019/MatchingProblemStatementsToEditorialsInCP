{"link": "https://codeforces.com//contest/1311/problem/F", "problemId": "547481", "shortId": "1311F", "contest_number": "1311", "name": "F. Moving Points", "statement": "There are  points on a coordinate axis . The -th point is located at the integer point  and has a speed . It is guaranteed that no two points occupy the same coordinate. All  points move with the constant speed, the coordinate of the -th point at the moment  ( ) is calculated as .Consider two points  and . Let  be the minimum possible distance between these two points over any possible moments of time (even ). It means that if two points  and  coincide at some moment, the value  will be .Your task is to calculate the value   (the sum of minimum distances over all pairs of points).", "input": "The first line of the input contains one integer  () \u2014 the number of points. The second line of the input contains  integers  (), where  is the initial coordinate of the -th point. It is guaranteed that all  are distinct. The third line of the input contains  integers  (), where  is the speed of the -th point.", "output": "Print one integer \u2014 the value   (the sum of minimum distances over all pairs of points).", "tutorial": "Let's understand when two points  and  coincide. Let . Then they are coincide when . Otherwise, these two points will never coincide and the distance between them will only increase.So, we need to consider only the initial positions of points. Let's sort all points by  and consider them one by one from left to right. Let the -th point be the rightmost in the pair of points that we want to add to the answer.We need to find the number of points  such that  and  and the sum of  for such points as well. We can do this using two BITs (Fenwick trees) if we compress coordinates (all values ) and do some kind of \"scanline\" by values . Let the number of such points be  and the sum of coordinates of such points be . Then we can increase the answer by  and add our current point to the Fenwick trees (add  to the position  in the first tree and  to the position  in the second tree). When we want to find the number of required points and the sum of its coordinates, we just need to find the sum on the prefix two times in Fenwick trees. Note that you can use any \"online\" logarithmic data structure you like in this solution (such as treap and segment tree).There is also another solution that uses pbds. Let's do the same thing, but there is one problem. Such data structure does not have \"sum on prefix\" function, so we have to replace it somehow. To do this, let's calculate only  part when we go from left to right. Then let's clear our structure, go among all points again but from right to left and calculate the same thing, but with the opposite sign (find the number of points  such that  and ). When we go from right to left, we need to decrease the answer by . It is some kind of \"contribution to the sum\" technique.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long get(vector<long long> &f, int pos) {\n\tlong long res = 0;\n\tfor (; pos >= 0; pos = (pos & (pos + 1)) - 1)\n\t\tres += f[pos];\n\treturn res;\n}\n\nvoid upd(vector<long long> &f, int pos, int val) {\n\tfor (; pos < int(f.size()); pos |= pos + 1) {\n\t\tf[pos] += val;\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tvector<pair<int, int>> p(n);\n\tfor (auto &pnt : p) cin >> pnt.first;\n\tfor (auto &pnt : p) cin >> pnt.second;\n\tsort(p.begin(), p.end());\n\t\n\tvector<int> vs;\n\tfor (auto &pnt : p) vs.push_back(pnt.second);\n\tsort(vs.begin(), vs.end());\n\tvs.resize(unique(vs.begin(), vs.end()) - vs.begin());\n\t\n\tlong long ans = 0;\n\tvector<long long> cnt(vs.size()), xs(vs.size());\n\tfor (auto &pnt : p) {\n\t\tint pos = lower_bound(vs.begin(), vs.end(), pnt.second) - vs.begin();\n\t\tans += get(cnt, pos) * 1ll * pnt.first - get(xs, pos);\n\t\tupd(cnt, pos, 1);\n\t\tupd(xs, pos, pnt.first);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}