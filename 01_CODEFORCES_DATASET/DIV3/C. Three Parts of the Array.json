{"link": "https://codeforces.com//contest/1006/problem/C", "problemId": "198027", "shortId": "1006C", "contest_number": "1006", "name": "C. Three Parts of the Array", "statement": "You are given an array  consisting of  integer numbers.Your task is to split this array into three parts (some of which may be empty) in such a way that each element of the array belongs to exactly one of the three parts, and each of the parts forms a consecutive contiguous subsegment (possibly, empty) of the original array. Let the sum of elements of the first part be , the sum of elements of the second part be  and the sum of elements of the third part be . Among all possible ways to split the array you have to choose a way such that  and  is maximum possible.More formally, if the first part of the array contains  elements, the second part of the array contains  elements and the third part contains  elements, then:  The sum of an empty array is .Your task is to find a way to split the array such that  and  is maximum possible.", "input": "The first line of the input contains one integer  () \u2014 the number of elements in the array . The second line of the input contains  integers  () \u2014 the elements of the array .", "output": "Print a single integer \u2014 the maximum possible value of , considering that the condition  must be met. Obviously, at least one valid way to split the array exists (use  and ).", "tutorial": "Since the given array consists of positive integers, for each value of , there can be at most one value of  such that . We can use binary search on the array of prefix sums of  to find the correct value of , given that it exists. If it does exist and , this is a candidate solution so we store it. Alternatively, we can use the two pointers trick \u2013 when  increases,  cannot decrease. Be careful to use 64 bit integers to store sums.Overall complexity is  or . ", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\t\n\tset<long long> sum;\n\tlong long l = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tl += a[i];\n\t\tsum.insert(l);\n\t}\n\t\n\tlong long ans = 0;\n\tlong long r = 0;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tsum.erase(l);\n\t\tl -= a[i];\n\t\tr += a[i];\n\t\tif (sum.count(r))\n\t\t\tans = max(ans, r);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}