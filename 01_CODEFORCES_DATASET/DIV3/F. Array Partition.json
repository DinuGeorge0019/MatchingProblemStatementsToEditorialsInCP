{"link": "https://codeforces.com//contest/1454/problem/F", "problemId": "808365", "shortId": "1454F", "contest_number": "1454", "name": "F. Array Partition", "statement": "You are given an array  consisting of  integers.Let  be the minimum value among  and  be the maximum value among .Your task is to choose three  (greater than ) integers ,  and  such that:  ;  . In other words, you have to split the array  into three consecutive non-empty parts that cover the whole array and the maximum in the first part equals the minimum in the second part and equals the maximum in the third part (or determine it is impossible to find such a partition).Among all such triples (partitions), you can choose any.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the length of . The second line of the test case contains  integers  (), where  is the -th element of . It is guaranteed that the sum of  does not exceed  ().", "output": "For each test case, print the answer:  in the only line if there is no such partition of  that satisfies the conditions from the problem statement. Otherwise, print  in the first line and three integers ,  and  () in the second line. If there are several answers, you can print any.", "tutorial": "Let's fix the length of the first block (iterate through $$$i$$$ from $$$0$$$ to $$$n-3$$$). Let's also try to maximize the length of the third block using the second pointer. So, initially the length of the first block is $$$1$$$ and the maximum in the block is $$$a_0$$$ (after that, its length will be $$$2$$$ and the maximum will be $$$max(a_0, a_1)$$$, and so on). Let's move the left border of the third block $$$r$$$ while $$$a_r \\le a_0$$$ and the second block have at least one element.After we expanded the third block, consider some cases: if its maximum is less than $$$a_0$$$, then we don't need to consider this partition (we expanded the third block as much as we can but didn't find the required maximum). Otherwise, its maximum fits our conditions. Then let's find the minimum in the second block. Let it be $$$mn$$$. If $$$mn < mx$$$, this partition is also bad. If $$$mn = mx$$$, this partition is good, and we can just print it. Otherwise, $$$mn > mx$$$, and we need to fix the second block somehow. I claim that we only need to expand it by at most one element. Let's see why is it true. Consider we want to expand it to the right (the other case just uses the same logic). If we expanded our block by one element to the right and the new value in it is less than $$$mx$$$, then this partition is bad, and we can not use it (this is also the reason why we are trying to maximize the length of the third block). Otherwise, this value is always $$$mx$$$, because the first and the third blocks didn't have values greater than $$$mx$$$.There are some cases in the implementation we need to consider carefully: first, we need to find the minimum in the second block fast enough. This can be done if we store it as a multiset (set with repetitions). Second, we can remove the only maximum in the third (or the first) block by expanding the second one. This can be handled easily if we just store all three blocks (not only the second one) as multisets. And the last case is that we sometimes need to move the left border of the third block to the right. This happens when we expand the first block and the second block becomes empty. So, this happens only $$$O(n)$$$ times in total.Total time complexity of this solution is $$$O(n \\log n)$$$.There is also another solution from Gassa:Let us start solving by asking the following question: in which segments will the maximal values end up?Consider the maximum value $$$m$$$ in the whole array. If there are at least three of them, a valid answer is to pick any maximum except the first and the last as the middle segment. For example, \"\" ($$$m = 3$$$) can be partitioned as \"\" or as \"\", where the middle segment is marked with square brackets. Otherwise, all $$$m$$$ should end up in the middle segment, so that maximums to the left and to the right are less. For example, in \"\", we have to put both threes into the middle segment.Let us now calculate the minimum value $$$v$$$ on the middle segment, considering the numbers between those equal to $$$m$$$. For example, in \"\" the value $$$v = \\min (3, 1, 3) = 1$$$. All numbers greater than $$$v$$$ should also go into the middle segment, and everything between them, which can result in $$$v$$$ decreasing even more. We have to expand the borders of the middle segment until the minimum value is such $$$v$$$ that there are only values not greater than $$$v$$$ left outside. Continuing with the example, we see that in \"\", the middle segment should be expanded to \"\". Conversely, if the maximum $$$m$$$ was unique, then $$$v = m$$$, and we didn't have to expand the middle segment at this stage. For example, in \"\", the current state is \"\".If the maximums to the left and to the right are exactly $$$v$$$, we found an answer. Otherwise, any possible middle segment contains the middle segment that we now got. So we have to expand the middle segment, either to the left or to the right. As a result, the value $$$v$$$ may become smaller, which can cause another expansion.What's left is to decide where to expand when we have a choice. We would like to do it greedily. Indeed, consider three values: the minimum on middle segment $$$v$$$, the maximum on left segment $$$u$$$ and the maximum on right segment $$$w$$$. When we expand the middle segment, each of them can only decrease. And if we find an answer, the equation $$$u = v = w$$$ will be satisfied. So, as we make the minimum of these three values smaller, we have less and less opportunities to make them equal. Thus we can pick the side of expansion after which the value $$$\\min (u, v, w)$$$ is larger, and if these are equal, pick any.For example, in the state \"\", we have $$$u = 3$$$, $$$v = 4$$$, and $$$w = 3$$$. If we expand to the left, we get \"\" where $$$u = 1$$$, $$$v = 3$$$, and $$$w = 3$$$. If we expand to the right, we get \"\" where $$$u = 3$$$, $$$v = 2$$$, and $$$w = 3$$$. Our algorithm will pick expanding to the right, however, there is no valid answer in this example anyway.Implementation: let us precalculate the maximums on all prefixes and all suffixes of the array. Then we can expand the middle segment by one element in $$$O (1)$$$, and the total running time is linear.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool found;\n\nvoid shift(multiset<int> &l, multiset<int> &r, int val) {\n\tl.erase(l.find(val));\n\tr.insert(val);\n}\n\nvoid check(const multiset<int> &lf, const multiset<int> &mid, const multiset<int> &rg) {\n\tif (found || lf.empty() || mid.empty() || rg.empty()) {\n\t\treturn;\n\t}\n\tif (*lf.rbegin() == *mid.begin() && *mid.begin() == *rg.rbegin()) {\n\t\tfound = true;\n\t\tcout << \"YES\" << endl;\n\t\tcout << lf.size() << \" \" << mid.size() << \" \" << rg.size() << endl;\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\t\n\t\tfound = false;\n\t\tmultiset<int> lf, mid(a.begin(), a.end()), rg;\n\t\tint r = n - 1;\n\t\tfor (int l = 0; l < n - 2; ++l) {\n\t\t\tshift(mid, lf, a[l]);\n\t\t\twhile (r - 1 >= l && a[r] <= *lf.rbegin()) {\n\t\t\t\tshift(mid, rg, a[r]);\n\t\t\t\t--r;\n\t\t\t}\n\t\t\t\n\t\t\twhile (r - 1 < l) {\n\t\t\t\tshift(rg, mid, a[r + 1]);\n\t\t\t\t++r;\n\t\t\t}\n\t\t\t\n\t\t\tcheck(lf, mid, rg);\n\t\t\t\n\t\t\tshift(lf, mid, a[l]);\n\t\t\tcheck(lf, mid, rg);\n\t\t\tshift(mid, lf, a[l]);\n\t\t\t\n\t\t\tif (rg.empty()) continue;\n\t\t\t\n\t\t\tshift(rg, mid, a[r + 1]);\n\t\t\tcheck(lf, mid, rg);\n\t\t\tshift(mid, rg, a[r + 1]);\n\t\t}\n\t\tif (!found) {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}