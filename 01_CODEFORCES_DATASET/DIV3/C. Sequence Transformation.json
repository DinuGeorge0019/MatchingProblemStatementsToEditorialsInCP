{"link": "https://codeforces.com//contest/1454/problem/C", "problemId": "808362", "shortId": "1454C", "contest_number": "1454", "name": "C. Sequence Transformation", "statement": "You are given a sequence , initially consisting of  integers.You want to transform this sequence so that all elements in it  (i.\u00a0e. it contains several occurrences of the same element).To achieve this, you choose some integer  , and then perform the following operation any number of times (possibly zero): choose some segment  of the sequence and remove it. But there is one exception: . More formally, you choose some contiguous subsequence  such that  if , and remove it. After removal, the numbering of elements to the right of the removed segment changes: the element that was the -th is now -th, the element that was -th is now -th, and so on (i.\u00a0e. the remaining sequence just collapses).Note that you   after you chose it.For example, suppose , . Then one of the ways to transform it in two operations is to choose , then:  choose , , so the resulting sequence is ;  choose , , so the resulting sequence is . Note that choosing  is not an operation. Also, note that you  remove any occurrence of .Your task is to find the  number of operations required to transform the sequence in a way described above.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the number of elements in . The second line of the test case contains  integers  (), where  is the -th element of . It is guaranteed that the sum of  does not exceed  ().", "output": "For each test case, print the answer \u2014 the  number of operations required to transform the given sequence in a way described in the problem statement. It can be proven that it is always possible to perform a finite sequence of operations so the sequence is transformed in the required way.", "tutorial": "Firstly, let's remove all consecutive equal elements (just keep one occurrence of each such element). For example, the array $$$[1, 1, 2, 3, 3, 3, 2]$$$ becomes $$$[1, 2, 3, 2]$$$.Now, the answer for each $$$a_i$$$ is  the number of its occurrences plus one. Why is it so? Because we need to remove all segments of elements between every pair of consecutive occurrences of $$$a_i$$$. The number of such segments is the number of occurrences of $$$a_i$$$ minus one. There is also a segment before the first occurrence of $$$a_i$$$ and a segment after the last occurrence of $$$a_i$$$. But the first segment doesn't exist for the first element and the last segment doesn't exist for the last element.So, after removing consecutive elements, let's calculate for each $$$a_i$$$ the number of its occurrences plus one, subtract one from the value of the first element and from the value of the last element. Then the answer is the minimum among these values for all $$$a_i$$$.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tvector<int> res(n + 1, 1);\n\t\tn = unique(a.begin(), a.end()) - a.begin();\n\t\ta.resize(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tres[a[i]] += 1;\n\t\t}\n\t\tres[a[0]] -= 1;\n\t\tres[a[n - 1]] -= 1;\n\t\tint ans = 1e9;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tans = min(ans, res[a[i]]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}