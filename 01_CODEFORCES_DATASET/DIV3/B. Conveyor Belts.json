{"link": "https://codeforces.com//contest/1811/problem/B", "problemId": "1864324", "shortId": "1811B", "contest_number": "1811", "name": "B. Conveyor Belts", "statement": "Conveyor matrix  is matrix of size , where  is an  number. The matrix consists of concentric ribbons moving clockwise.In other words, the conveyor matrix for  is simply a matrix , whose cells form a cycle of length  clockwise. For any natural , the matrix  is obtained by adding to the matrix  an outer layer forming a clockwise cycle.    .   You are standing in a cell with coordinates  and you want to get into a cell with coordinates . A cell has coordinates  if it is located at the intersection of the th row and the th column.Standing on some cell, every second you will move to the cell next in the direction of movement of the tape on which you are. You can also move to a neighboring cell by spending one unit of energy. Movements happen instantly and you can make an unlimited number of them at any time.Your task is to find the minimum amount of energy that will have to be spent to get from the cell with coordinates  to the cell with coordinates .For example,  initially you are in a cell with coordinates  and you want to get into a cell with coordinates . You can immediately make  movements, once you are in a cell with coordinates , and then after  seconds you will be in the right cell.", "input": "The first line contains an integer  () \u2014 the number of test cases. The descriptions of the test cases follow. The description of each test case consists of one string containing five integers , , ,  and  () \u2014 matrix size and the coordinates of the start and end cells. It is guaranteed that the number  is even.", "output": "For each test case, print one integer in a separate line \u2014 the minimum amount of energy that will have to be spent to get from the cell with coordinates  to the cell with coordinates .", "tutorial": "Note that the conveyor matrix  consists of  cycles, through each of which we can move without wasting energy. Now you need to find the distance between the cycles where the start and end cells are located. In one step from any cycle, you can go either to the cycle that is closer to the edge of the matrix, or to the cycle that is further from the edge of the matrix. It turns out that it is enough to find on which cycles there are cells on the edge and take their difference modulo.", "solution": "def layer(n, x, y):\n    return min([x, y, n + 1 - x, n + 1 - y])\n\n\ndef solve():\n    n, x1, y1, x2, y2 = map(int, input().split())\n    print(abs(layer(n, x1, y1) - layer(n, x2, y2)))\n\n\nt = int(input())\nfor _ in range(t):\n    solve()", "interactive": false, "noSolution": false, "noTutorial": false}