{"link": "https://codeforces.com//contest/1619/problem/G", "problemId": "1234628", "shortId": "1619G", "contest_number": "1619", "name": "G. Unusual Minesweeper", "statement": "Polycarp is very fond of playing the game Minesweeper. Recently he found a similar game and there are such rules.There are mines on the field, for each the coordinates of its location are known (). Each mine has a lifetime in seconds, after which it will explode. After the explosion, the mine also detonates all mines vertically and horizontally at a distance of  (two perpendicular lines). As a result, we get an explosion on the field in the form of a \"plus\" symbol (''). Thus, one explosion can cause new explosions, and so on.Also, Polycarp can detonate anyone mine every second, starting from zero seconds. After that, a chain reaction of explosions also takes place. Mines explode  and also  detonate other mines according to the rules described above.Polycarp wants to set a new record and asks you to help him calculate in what minimum number of seconds all mines can be detonated.", "input": "The first line of the input contains an integer  () \u2014 the number of test cases in the test. An empty line is written in front of each test suite. Next comes a line that contains integers  and  (, ) \u2014 the number of mines and the distance that hit by mines during the explosion, respectively. Then  lines follow, the -th of which describes the  and  coordinates of the -th mine and the time until its explosion (, ). It is guaranteed that all mines have different coordinates. It is guaranteed that the sum of the values  over all test cases in the test does not exceed .", "output": "Print  lines, each of the lines must contain the answer to the corresponding set of input data \u00a0\u2014 the minimum number of seconds it takes to explode all the mines.", "tutorial": "Our first task is to separate mines into components. We will store in the hashmap  at the  coordinate all the  coordinates where there is a mine. Let's do the same with the  hashmap. Thus, going through the available arrays in  and , we connect adjacent elements into one component, if , also with .As a result, we have components, where if you detonate one mine in the 's component, then all the mines belonging to this component will also explode.Further, we find a mine with a minimum timer in each component. Finding the minimum for each component, we store it conditionally in the array . Now we know at what minimum time some component will explode if it is left unaffected.To answer, it remains to find in the sorted array  such a minimum index   that  is min.And the general asymptotic behavior is .", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\n \n#define forn(i, n) for (int i = 0; i < int(n); i++)\n \nint k;\n \nmap <int, vector<int>> mx;\nmap <int, vector<int>> my;\nmap <pair<int ,int>, bool> used;\nmap <pair<int, int>, int> time_of;\n \nint dfs(int x, int y) {\n    used[{x, y}] = true;\n    int _min_ = time_of[{x, y}];\n \n    auto i = lower_bound(mx[x].begin(), mx[x].end(), y);\n    auto j = lower_bound(my[y].begin(), my[y].end(), x);\n \n    if (++i != mx[x].end() && !used[{x, *i}] && abs(*i - y) <= k) {\n        _min_ = min(_min_, dfs(x, *i));\n    }\n    --i;\n    if (i != mx[x].begin() && !used[{x, *(--i)}] && abs(*i - y) <= k) {\n        _min_ = min(_min_, dfs(x, *i));\n    }\n \n    if (++j != my[y].end() && !used[{*j, y}] && abs(*j - x) <= k) {\n        _min_ = min(_min_, dfs(*j, y));\n    }\n    --j;\n    if (j != my[y].begin() && !used[{*(--j), y}] && abs(*j - x) <= k) {\n        _min_ = min(_min_, dfs(*j, y));\n    }\n \n    return _min_;\n}\n \nvoid solve() {\n    mx.clear();\n    my.clear();\n    used.clear();\n \n    int n;\n    cin >> n >> k;\n    vector <pair<int, int>> a(n);\n    int x, y, timer;\n \n    for (int i = 0; i < n; ++i) {\n        cin >> x >> y >> timer;\n        a[i] = {x, y};\n        time_of[{x, y}] = timer;\n        mx[x].push_back(y);\n        my[y].push_back(x);\n    }\n    vector<int> res;\n \n    for (auto now: mx) {\n        sort(mx[now.first].begin(), mx[now.first].end());\n    }\n    for (auto now: my) {\n        sort(my[now.first].begin(), my[now.first].end());\n    }\n \n    for (auto now: a) {\n        if (!used[now]) {\n            res.push_back(dfs(now.first, now.second));\n        }\n    }\n    sort(res.begin(), res.end());\n \n    int ans = res.size() - 1;\n    for (int i = 0; i < res.size(); ++i) {\n        ans = min(ans, max((int)res.size() - i - 2, res[i]));\n    }\n    cout << ans << '\\n';\n}\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n    int tests;\n    cin >> tests;\n    forn(tt, tests) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}