{"link": "https://codeforces.com//contest/1611/problem/G", "problemId": "1202191", "shortId": "1611G", "contest_number": "1611", "name": "G. Robot and Candies", "statement": "Polycarp has a rectangular field of  cells (the size of the  field does not exceed  cells, ), in each cell of which there can be candy. There are  rows and  columns in the field.Let's denote a cell with coordinates  vertically and  horizontally by . Then the top-left cell will be denoted as , and the bottom-right cell will be denoted as .If there is candy in the cell, then the cell is marked with the symbol '', otherwise\u00a0\u2014 with the symbol ''.Polycarp made a Robot that can collect candy. The Robot can move from  either to , or to . If the Robot is in a cell that contains candy, it takes it.While there is at least one candy on the field, the following procedure is executed:   Polycarp puts the Robot in an arbitrary cell on the  of the field. He himself chooses in which cell to place the Robot. It is allowed to put the Robot in the same cell multiple times.  The Robot moves across the field and collects candies. He controls the Robot.  When the Robot leaves the field, Polycarp takes it. If there are still candies left, Polycarp repeats the procedure. Find the  number of times Polycarp needs to put the Robot on the topmost row of the field in order to collect all the candies. It is guaranteed that Polycarp can always collect all the candies.", "input": "The first line of input data contains an integer  () \u2014 the number of input data sets in the test. Before each input data, there is a blank line in the test. Next is a line that contains integers  and  (, ) \u2014 field sizes. This is followed by  lines, -th of which describes the -th line of the field. Each of them is a string of size  characters: the symbol '' corresponds to a cell with candy, the symbol ''\u00a0\u2014 an empty cell. It is guaranteed that the sum of  values for all input data sets in the test does not exceed .", "output": "Print  lines, each line should contain the answer to the corresponding set of input data: the minimum number of times Polycarpus needs to put the Robot on the topmost row of the field in order to collect all the candies.", "tutorial": "Note first that we can solve the two subtasks independently if we consider the coloring as on a chessboard, since at any move of the robot the parity of  does not change.Now replace the moves ,  with moves ,  respectively. This can be done because we simply shifted the rows by some value, with the Robot walking on the same cells it walked on in the original board.Let's look at the even numbered (gray) cells:     Then we'll go through the columns from left to right, keeping the minimum(by size) set of cells the Robot should be in. Then the transition to the next column will be as follows. Go through the cells from bottom to top, which contain the candy. For each cell, find the closest cell of our set (find the Robot) that is above the current cell. Then we change the square from the set to the current square. If there is no robot for the square in the array, then we need to increase the answer by  and add the robot to our current square (you can think of it as adding the robot to the very top square in the column and getting all the candies that were above).In the picture, the red circles indicate the cells where we will put the robot as needed. The pink cells mean that this cell is contained in the set.The final asymptotic depends on the implementation (you can use a set as data structure, or you can use a vector with two pointers):  and , respectively.", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define sz(v) (int)v.size()\n \nconst int N = 1e6 + 50;\nstring a[N];\n \nint n,m;\nint ans;\n \nvoid solve(int sum0) {\n    vector<int> v;\n    for (int sum = sum0, ad = 0, pref = 0; sum < n + m; sum += 2, ad++) {\n        vector<int> cur;\n        int li = max(0, sum - m + 1), ri = min(n - 1, sum);\n        if (li > ri) continue;\n \n        for (int i = li; i <= ri; i++) {\n            int j = sum - i;\n \n            if (a[i][j] == '1')\n                cur.emplace_back(i);\n        }\n \n        while (pref != sz(v) && v[pref] + ad > ri) {\n            pref++;\n        }\n        for (int i = pref; i < sz(v); i++) {\n            int new_val = v[i];\n            while (!cur.empty() && cur.back() - ad >= v[i]) {\n                new_val = max(new_val, cur.back() - ad);\n                cur.pop_back();\n            }\n            v[i] = new_val;\n        }\n        if (!cur.empty()) {\n            v.emplace_back(cur.back() - ad);\n            ans++;\n        }\n    }\n}\n \nint main() {\n    int t;\n    cin >> t;\n \n    forn(tt, t) {\n        cin >> n >> m;\n \n        forn(i, n) {\n            string s; \n            cin >> a[i];\n        }\n \n        ans = 0;\n        solve(0);\n        solve(1);\n        \n        cout << ans << '\\n';\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}