{"link": "https://codeforces.com//contest/1196/problem/D2", "problemId": "377794", "shortId": "1196D2", "contest_number": "1196", "name": "D2. RGB Substring  hard version ", "statement": ".You are given a string  consisting of  characters, each character is '', '' or ''.You are also given an integer . Your task is to change the minimum number of characters in the initial string  so that after the changes there will be a string of length  that is a substring of , and is also a substring of the infinite string \"\".A string  is a substring of string  if there exists a positive integer  such that , , , ..., . For example, strings \"\", \"\", \"\" are substrings of the infinite string \"\" while \"\", \"\" and \"\" are not.You have to answer  independent queries.", "input": "The first line of the input contains one integer  ()\u00a0\u2014 the number of queries. Then  queries follow. The first line of the query contains two integers  and  ()\u00a0\u2014 the length of the string  and the length of the substring. The second line of the query contains a string  consisting of  characters '', '' and ''. It is guaranteed that the sum of  over all queries does not exceed  ().", "output": "For each query print one integer\u00a0\u2014 the minimum number of characters you need to change in the initial string  so that after changing there will be a substring of length  in  that is also a substring of the infinite string \"\".", "tutorial": "In this problem you should make the same as in the previous one but faster. Let's consider three offsets of string \"\": \"\", \"\" and \"\". Let's copy the current offset of the string so that it will has the length  (possibly, without some trailing characters) and save it in the string .Then let's compare the string  with this offset of length  and build an array  of length  where  if . Then let's iterate over all possible continuous subsegments of this array  and maintain the variable  denoting the current answer.Firstly, for the current position  let's add  to . Then if the current position  is greater than or equal to  (-indexed) let's decrease  by . So now we have the continuous subsegment of the array  of length no more than . Then if the current position  is greater than or equal to  (-indexed again) (the current subsegment has the length ) then let's update the answer with . Then let's do the same with two remaining offsets.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tconst string t = \"RGB\";\n\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint n, k;\n\t\tstring s;\n\t\tcin >> n >> k >> s;\n\t\tint ans = 1e9;\n\t\tfor (int offset = 0; offset < 3; ++offset) {\n\t\t\tvector<int> res(n);\n\t\t\tint cur = 0;\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tres[j] = (s[j] != t[(j + offset) % 3]);\n\t\t\t\tcur += res[j];\n\t\t\t\tif (j >= k) cur -= res[j - k];\n\t\t\t\tif (j >= k - 1) ans = min(ans, cur);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}