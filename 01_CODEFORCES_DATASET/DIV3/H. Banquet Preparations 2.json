{"link": "https://codeforces.com//contest/1607/problem/H", "problemId": "1168765", "shortId": "1607H", "contest_number": "1607", "name": "H. Banquet Preparations 2", "statement": "The chef has cooked  dishes yet again: the -th dish consists of  grams of fish and  grams of meat. Banquet organizers consider two dishes  and  equal if  and  at the same time.The banquet organizers estimate the  of  dishes as follows. The  of a set of dishes is equal to the number of different dishes in it. The   is, the .In order to reduce the , a taster was invited. He will eat   grams of food from each dish. For each dish, the taster determines separately how much fish and how much meat he will eat. The only condition is that he will eat exactly  grams of the -th dish in total.Determine how much of what type of food the taster should eat from each dish so that the value of  is the minimum possible. If there are several correct answers, you may output any of them.", "input": "The first line of input data contains an integer  ()\u00a0\u2014 the number of test cases. Each test case's description is preceded by a blank line. Next comes a line that contains an integer  ()\u00a0\u2014 the number of dishes. Then follows  lines, -th of which contains three integers ,  and  (; )\u00a0\u2014 the mass of fish in -th dish, the mass of meat in -th dish and how many grams in total the taster should eat in -th dish. The sum of all  values for all input data sets in the test does not exceed .", "output": "For each test case, print on the first line the minimum value of  that can be achieved by eating exactly  grams of food (for all  from  to ) from a dish . Then print  lines that describe a way to do this: the -th line should contain two integers  and  (; ; ), where  is how many grams of fish the taster should eat from -th dish, and  is how many grams of meat. If there are several ways to achieve a minimum balance, print any of them.", "tutorial": "Note that dishes can become equal if and only if they have equal values of , that is, how much fish and meat remain in them in total after \"tasting\". Let's calculate this value for each dish and group all the dishes with equal calculated values.The minimum amount of fish that can remain in the -th dish is  in case where the maximum possible mass of fish is eaten. Similarly, the maximum amount of fish that can remain is  in case where the maximum possible mass of meat is eaten. Consider one of the groups  in which there are all the dishes with equal values . We sill assign each dish a corresponding segment on the coordinate line between  and . This segment specifies all possible values of the remaining mass of fish in the dish; any value on it is achievable by replacing eating some mass of fish with the same mass of meat. And since  is common, the same amount of remaining fish will imply the same amount of remaining meat, thus, equality.Let us solve the problem for each group independently. Within a group, the problem is reduced to choosing as few points as possible that \"cover\" all the segments described in the last paragraph (that is, that there should be a point inside each segment). Each selected point will correspond to the resulting dish, and it being inside a segment will mean that such a resulting dish can be obtained from the corresponding starting one. Such a problem is solved as follows:   we choose a segment with the minimal right end; because it must contain at least one chosen point we'll greedily choose it equal to its right end;  there's no point in choosing a point to the left from it, since it will not cover more segments than the right end of the segment in question;  we'll mark all segments containing this point as covered, and repeat the algorithm for the next unprocessed segment with the minimal right end. For this algorithm, it is sufficient to sort the segments by their right ends within each group and iterate through the segments, greedily selecting points in the manner described above. The set of points obtained at the end will be the answer, and its size and the information about the point selected within each segment should be printed in the output. If for a dish  a point  is chosen inside its corresponding segment, then there should be exactly  of fish left in it, that is, you should output the numbers  and  in the answer.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nstruct seg {\n    int a, b, m;\n    int index;\n};\n\nint n, ans;\nvector<seg> segments;\nmap<int, vector<seg>> diags;\n\nvoid erase(multiset<pair<pair<int,int>, int>>& lr, int l, int r, int index) {\n    pair<pair<int,int>,int> plr = make_pair(make_pair(l, r), index);\n    auto i = lr.find(plr);\n    assert(i != lr.end());\n    lr.erase(i);\n}\n\nvoid erase(multiset<pair<pair<int,int>, int>>& lr, multiset<pair<pair<int,int>, int>>& rl, int l, int r, int index) {\n    erase(lr, l, r, index);\n    erase(rl, r, l, index);\n}\n\nmap<int, pair<int,int>> dd;\n\nvoid setup_dd(int index, int value) {\n    assert(dd.count(index) == 0);\n    int x = segments[index].a - value;\n    int y = segments[index].m - x;\n    assert(segments[index].a - x >= 0);\n    assert(segments[index].b - y >= 0);\n    assert(x + y == segments[index].m);\n    dd[index] = make_pair(x, y);\n}\n\nint solve(vector<seg> s) {\n    int n = s.size();\n    multiset<pair<pair<int,int>, int>> lr;\n    multiset<pair<pair<int,int>, int>> rl;\n    forn(i, n) {\n        int min_d = max(s[i].m - s[i].b, 0);\n        int max_d = min(s[i].a, s[i].m);\n        lr.insert(make_pair(make_pair(s[i].a - max_d, s[i].a - min_d), s[i].index));\n        rl.insert(make_pair(make_pair(s[i].a - min_d, s[i].a - max_d), s[i].index));\n    }\n\n    int result = 0;\n    while (!rl.empty()) {\n        result++;\n        auto min_r_iterator = rl.begin();\n        int r = min_r_iterator->first.first;\n        int l = min_r_iterator->first.second;\n        int index = min_r_iterator->second;\n        erase(lr, rl, l, r, index);\n        setup_dd(index, r);\n\n        while (!lr.empty()) {\n            auto min_l_iterator = lr.begin();\n            int ll = min_l_iterator->first.first;\n            int rr = min_l_iterator->first.second;\n            int ii = min_l_iterator->second;\n            if (ll <= r) {\n                erase(lr, rl, ll, rr, ii);\n                setup_dd(ii, r);\n            } else\n                break;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    forn(tt, t) {\n        cin >> n;\n        diags.clear();\n        dd.clear();\n        segments = vector<seg>(n);\n        forn(i, n) {\n            seg s;\n            s.index = i;\n            cin >> s.a >> s.b >> s.m;\n            diags[s.a + s.b - s.m].push_back(s);\n            segments[i] = s;\n        }\n        int sum = 0;\n        for (auto p: diags)\n            sum += solve(p.second);\n        cout << sum << '\\n';\n        forn(i, n)\n            cout << dd[i].first << \" \" << dd[i].second << '\\n';\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}