{"link": "https://codeforces.com//contest/1547/problem/C", "problemId": "1041927", "shortId": "1547C", "contest_number": "1547", "name": "C. Pair Programming", "statement": "Monocarp and Polycarp are learning new programming techniques. Now they decided to try pair programming.It's known that they have worked together on the same file for  minutes. Every minute exactly one of them made one change to the file. Before they started, there were already  lines written in the file.Every minute exactly one of them does one of two actions: adds a new line to the end of the file or changes one of its lines.Monocarp worked in total for  minutes and performed the sequence of actions . If , then he adds a new line to the end of the file. If , then he changes the line with the number . Monocarp performed actions strictly in this order: , then , ..., .Polycarp worked in total for  minutes and performed the sequence of actions . If , then he adds a new line to the end of the file. If , then he changes the line with the number . Polycarp performed actions strictly in this order: , then , ..., .Restore their common sequence of actions of length  such that all actions would be correct \u2014 there should be no changes to lines that do not yet exist. Keep in mind that in the common sequence Monocarp's actions should form the subsequence  and Polycarp's \u2014 subsequence . They can replace each other at the computer any number of times.Let's look at an example. Suppose . Monocarp first changed the line with the number  and then added a new line (thus, ). Polycarp first added a new line and then changed the line with the number  (thus, ).Since the initial length of the file was , in order for Polycarp to change line number  two new lines must be added beforehand. Examples of correct sequences of changes, in this case, would be  and . Changes  (wrong order of actions) and  (line  cannot be edited yet) are not correct.", "input": "The first line contains an integer  (). Then  test cases follow. Before each test case, there is an empty line. Each test case contains three lines. The first line contains three integers , ,  (, )\u00a0\u2014 the initial number of lines in file and lengths of Monocarp's and Polycarp's sequences of changes respectively. The second line contains  integers  (). The third line contains  integers  ().", "output": "For each test case print any correct common sequence of Monocarp's and Polycarp's actions of length  or  if such sequence doesn't exist.", "tutorial": "The solution is that if we can do something, let's do it. It doesn't make sense not to act, because neither adding a new row nor modifying an existing one can prevent the existing row from being changed in the future. Therefore, we will iterate over the actions and eagerly act Monocarp or Polycarp.Let's create two pointers  and  in arrays  and \u00a0\u2014 index of possible action of Monocarp and Polycarp and \u00a0\u2014 the current length of the file.Suppose that  or  on current iteration. Then we take the appropriate zero element and increase  by one. We can do that because appending a new line cannot make a new answer prefix incorrect if the previous prefix was correct.Suppose that  and . If  and  then there is no answer because we can potentially do only two actions and both make the answer incorrect. If one number is greater than  and the other is less than or equals then we take the one that less than or equals .If one of the sequences  or  ends then only one potential action needs to be checked at each iteration.", "solution": "#include <iostream>\n#include <vector>\n\ntypedef std::vector<int> vi;\n\nint main() {\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int k, n, m;\n        std::cin >> k >> n >> m;\n\n        vi a(n), b(m);\n        for (int i = 0; i < n; i++)\n            std::cin >> a[i];\n        for (int i = 0; i < m; i++)\n            std::cin >> b[i];\n\n        int pos1 = 0, pos2 = 0;\n        vi res;\n        bool ok = true;\n        while (pos1 != n || pos2 != m) {\n            if (pos1 != n && a[pos1] == 0) {\n                res.push_back(0);\n                k++;\n                pos1++;\n            } else if (pos2 != m && b[pos2] == 0) {\n                res.push_back(0);\n                k++;\n                pos2++;\n            } else if (pos1 != n && a[pos1] <= k) {\n                res.push_back(a[pos1++]);\n            } else if (pos2 != m && b[pos2] <= k) {\n                res.push_back(b[pos2++]);\n            } else {\n                std::cout << -1 << '\\n';\n                ok = false;\n                break;\n            }\n        }\n\n        if (ok) {\n            for (int cur : res)\n                std::cout << cur << ' ';\n            std::cout << std::endl;\n        }\n    }\n\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}