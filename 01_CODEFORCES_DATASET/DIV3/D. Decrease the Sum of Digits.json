{"link": "https://codeforces.com//contest/1409/problem/D", "problemId": "717432", "shortId": "1409D", "contest_number": "1409", "name": "D. Decrease the Sum of Digits", "statement": "You are given a positive integer . In one move, you can increase  by one (i.e. make ). Your task is to find the minimum number of moves you need to perform in order to make the sum of digits of  be less than or equal to .You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The only line of the test case contains two integers  and  (; ).", "output": "For each test case, print the answer: the minimum number of moves you need to perform in order to make the sum of digits of  be less than or equal to .", "tutorial": "Firstly, let's check if the initial  fits the conditions. If it is, print  and continue. Otherwise, let's solve the problem greedily. At first, let's try to set the last digit to zero. Let . We need exactly  moves to do that. Let's add this number to  and to the answer and check if the current  fits the conditions. If it isn't, let's try to set the previous last digit to zero. Let . Then we need  moves to do that. Let's add this number to  and to the answer and check if the current  fits the conditions. If it isn't, repeat the same with the third digit and so on. This cycle can do no more than  iterations. And we can fing the sum of digits of  in at most  iterations too (decimal logarithm of ).So, the total time complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint sum(long long n) {\n\tint res = 0;\n\twhile (n > 0) {\n\t\tres += n % 10;\n\t\tn /= 10;\n\t}\n\treturn res;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tlong long n;\n\t\tint s;\n\t\tcin >> n >> s;\n\t\tlong long ans = 0;\n\t\tif (sum(n) <= s) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tlong long pw = 1;\n\t\tfor (int i = 0; i < 18; ++i) {\n\t\t\tint digit = (n / pw) % 10;\n\t\t\tlong long add = pw * ((10 - digit) % 10);\n\t\t\tn += add;\n\t\t\tans += add;\n\t\t\tif (sum(n) <= s) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpw *= 10;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}