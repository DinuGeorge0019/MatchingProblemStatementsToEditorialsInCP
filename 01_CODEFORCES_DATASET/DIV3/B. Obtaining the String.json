{"link": "https://codeforces.com//contest/1015/problem/B", "problemId": "203547", "shortId": "1015B", "contest_number": "1015", "name": "B. Obtaining the String", "statement": "You are given two strings  and . Both strings have length  and consist of lowercase Latin letters. The characters in the strings are numbered from  to .You can successively perform the following move any number of times (possibly, zero):  swap any two adjacent (neighboring) characters of  (i.e. for any  you can swap  and . You can't apply a move to the string . The moves are applied to the string  one after another.Your task is to obtain the string  from the string . Find any way to do it with at most  such moves.", "input": "The first line of the input contains one integer  () \u2014 the length of strings  and . The second line of the input contains the string  consisting of  lowercase Latin letters. The third line of the input contains the string  consisting of  lowercase Latin letters.", "output": "If it is impossible to obtain the string  using moves, print \"\". Otherwise in the first line print one integer  \u2014 the number of moves to transform  to . Note that  must be an integer number between  and  inclusive. In the second line print  integers  (), where  means that on the -th move you swap characters  and . If you do not need to apply any moves, print a single integer  in the first line and either leave the second line empty or do not print it at all.", "tutorial": "This problem can be solved using the next greedy approach: let's iterate over all  from  to . If , go further. Otherwise let's find any position  such that  and move the character from the position  to the position . If there is no such position in , the answer is \"\".Upper bound on time complexity (and the size of the answer) of this solution is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s, t;\n\tcin >> n >> s >> t;\n\t\n\tvector<int> ans;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (s[i] == t[i]) continue;\n\t\tint pos = -1;\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tif (s[j] == t[i]) {\n\t\t\t        pos = j;\n\t\t\t        break;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int j = pos - 1; j >= i; --j) {\n\t\t\tswap(s[j], s[j + 1]);\n\t\t\tans.push_back(j);\n\t\t}\n\t}\n\t\n\tassert(s == t);\n\t\n\tcout << ans.size() << endl;\n\tfor (auto it : ans) cout << it + 1 << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}