{"link": "https://codeforces.com//contest/1335/problem/E2", "problemId": "592976", "shortId": "1335E2", "contest_number": "1335", "name": "E2. Three Blocks Palindrome  hard version ", "statement": ".You are given a sequence  consisting of  positive integers.Let's define a  as the sequence, consisting of  distinct elements (let these elements are  and ,  can be equal ) and is as follows: . There  are integers greater than or equal to . For example, sequences , , , ,  and  are  but ,  and  are not.Your task is to choose the maximum by length  of  that is a .You have to answer  independent test cases.Recall that the sequence  is a a subsequence of the sequence  if  can be derived from  by removing zero or more elements without changing the order of the remaining elements. For example, if , then possible subsequences are: ,  and , but not  and .", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the length of . The second line of the test case contains  integers  (), where  is the -th element of . . It is guaranteed that the sum of  over all test cases does not exceed  ().", "output": "For each test case, print the answer \u2014 the maximum possible length of some subsequence of  that is a .", "tutorial": "I'll take some definitions from the solution of the easy version, so you can read it first if you don't understand something. Let  be the number of occurrences of  on the segment .We will try to do almost the same solution as in the easy version. The only difference is how do we iterate over all segments corresponding to the second block of the required palindrome. Consider some number which we want to use as the number for the first and third blocks. If we take  occurrences in the first block then we also take  occurrences in the third block. Let's take these occurrences greedily! If we take  elements in the first block (and also in the third block) then it is obviously better to take  leftmost and  rightmost elements correspondingly.Define  be the position of the -th occurrence of the number  (-indexed). So, if  is the array of length  and contains all occurrences of  in order from left to right then let's iterate over its left half and fix the amount of numbers  we will take in the first block (and also in the third block). Let it be . Then the left border of the segment for the second block is  and the right border is . So let  and  and we can update the answer with .It is easy to see that the total number of segments we consider is  so the total time complexity is  (there are also solutions not depending on the size of the alphabet, at least Mo's algorithm in , but all of them are pretty hard to implement so I won't describe them here).And I'm also interested in  solution, so if you know it, share it with us!", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(a) int((a).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tvector<vector<int>> cnt(200, vector<int>(n + 1));\n\t\tvector<vector<int>> pos(200);\n\t\tforn(i, n) {\n\t\t\tforn(j, 200) cnt[j][i + 1] = cnt[j][i];\n\t\t\t++cnt[a[i] - 1][i + 1];\n\t\t\tpos[a[i] - 1].push_back(i);\n\t\t}\n\t\tint ans = 0;\n\t\tforn(i, 200) {\n\t\t\tans = max(ans, sz(pos[i]));\n\t\t\tforn(p, sz(pos[i]) / 2) {\n\t\t\t\tint l = pos[i][p] + 1, r = pos[i][sz(pos[i]) - p - 1] - 1;\n\t\t\t\tforn(el, 200) {\n\t\t\t\t\tint sum = cnt[el][r + 1] - cnt[el][l];\n\t\t\t\t\tans = max(ans, (p + 1) * 2 + sum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}