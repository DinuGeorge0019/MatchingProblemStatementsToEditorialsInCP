{"link": "https://codeforces.com//contest/1579/problem/F", "problemId": "1123872", "shortId": "1579F", "contest_number": "1579", "name": "F. Array Stabilization  AND version ", "statement": "You are given an array  of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.In one step, the array  is replaced by another array of length  according to the following rules:   First, a new array  is defined as a cyclic shift of the array  to the right by  cells. The elements of this array can be defined as , where  is the remainder of integer division of  by .  It means that the whole array  can be represented as a sequence   Then each element of the array  is replaced by , where  is a logical \"AND\" operator. For example, if  and , then  and the value of  after the first step will be , that is .The process ends when the array stops changing. For a given array , determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.", "input": "The first line contains an integer  ()\u00a0\u2014 the number of test cases. The next  lines contain descriptions of the test cases.  The first line of each test case description contains two integers:  ()\u00a0\u2014 array size and  ()\u00a0\u2014 cyclic shift offset. The second line of the description contains  space-separated integers  ()\u00a0\u2014 elements of the array. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "Print  lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer\u00a0\u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to  in the array after the end of the process, print .", "tutorial": "We'll consider an arbitrary index of the array  and see what changes happen to  during several steps of the described algorithm. Let's denote by  the value of the array after  steps of the algorithm and prove by induction that  is the logical \"AND\" of  elements of the array , starting from  with step  to the left, that is Base of induction: for  the element of the original array  is . For clarity we can also show that the statement is true for : during the first step  is replaced by  by the definition of cyclic shift by  to the right.For simplicity, we will omit the \"\" operation in the following formulas but will keep it in mind implicitly. That is,  will imply .Induction step: let the above statement be true for , let us prove it for . By the definition of cyclic shift . And by the induction assumption, these two numbers are equal to   Since the logical \"AND\" is an idempotent operation, that is, it does not change its result when repeatedly applied to any argument, then  that is equal to their logical \"AND\" is also equal to  which is what we wanted to prove.It follows from this formula that  turns to zero after the -th step if and only if , , ..., , and . Up to the -th step all elements will be equal to , and so their logical \"AND\" will also be equal to . As soon as  appears in the sequence in question, the logical \"AND\" will also become zero. Thus, we reduced the problem to finding the maximal block of elements equal to  of the pattern . Note that by shifts of  the array splits into  cyclic sequences of this kind, each of length . Let's look at these cyclic sequences independently from each other and iterate over each of them in linear time complexity to find the maximal block of consecutive elements equal to \u00a0\u2014 this will be the answer to the problem.Remember to check that if at least one of these sequences consists entirely of elements equal to , its elements will never zero out, and the answer in such case is .The time complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, d;\n        cin >> n >> d;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++)\n            cin >> a[i];\n        vector<bool> used(n, false);\n        bool fail = false;\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (used[i])\n                continue;\n            int cur = i, pref = 0, last = 0, iter = 0, ans = 0;\n            do {\n                used[cur] = true;\n                if (a[cur] == 0) {\n                    ans = max(ans, last);\n                    last = 0;\n                } else {\n                    last++;\n                    if (iter == pref) {\n                        pref++;\n                    }\n                }\n                cur = (cur + d) % n;\n                iter++;\n            } while (cur != i);\n            if (iter != pref)\n                ans = max(ans, pref + last);\n            else {\n                fail = true;\n                break;\n            }\n            res = max(res, ans);\n        }\n        if (fail)\n            cout << \"-1\\n\";\n        else\n            cout << res << '\\n';\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}