{"link": "https://codeforces.com//contest/1066/problem/F", "problemId": "235864", "shortId": "1066F", "contest_number": "1066", "name": "F. Yet another 2D Walking", "statement": "Maksim walks on a Cartesian plane. Initially, he stands at the point  and in one move he can go to any of four adjacent points (left, right, up, down). For example, if Maksim is currently at the point , he can go to any of the following points in one move:   ;  ;  ;  . There are also   key points at this plane. The -th point is . It is guaranteed that  and  and there is no key point .Let the first level points be such points that , the second level points be such points that  and so on. Maksim wants to visit all the key points. But he shouldn't visit points of level  if he does not visit all the points of level . He starts visiting the points from the minimum level of point from the given set.The distance between two points  and  is  where  is the absolute value of .Maksim wants to visit all the key points in such a way that the total distance he walks will be minimum possible. Your task is to find this distance.", "input": "The first line of the input contains one integer  () \u2014 the number of key points. Each of the next  lines contains two integers ,  () \u2014 -coordinate of the key point  and -coordinate of the key point . It is guaranteed that all the points are distinct and the point  is not in this set.", "output": "Print one integer \u2014 the minimum possible total distance Maksim has to travel if he needs to visit all key points in a way described above.", "tutorial": "The main idea is that we don't need more than  border points on each level. So if we consider than the point  is less than point  when  or  and  then let's distribute all the points by their levels using  or something like it, sort points on each level by the comparator above and remain the first one and the last one on each level. Also let's add the fictive level  with the point . It is always true to remain at most  points and can be easily proved but this fact is very intuitive I think. Now let's do dynamic programming on the points.  means that now we are at the level  and stay in the first point (if ) or in the last point (if ) and we are already visit all the points on the level . The value of this dynamic programming is the minimum possible total distance to reach this state. Initially, , other values are equal to . Let's calculate this dynamic programming in order of increasing levels. Let  be the first key point at the level  and  be the last key point at the level . Now if we are at the level  and the previous level is , these  transitions are sufficient to calculate states of dynamic programming on the current level:   ;  ;  ;  . There  means the distance between points  and .Let last level we have be . After calculating this dynamic programming the answer is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\t\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\t\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\t\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\t\t\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\t\t\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\t\t\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\t\t\n\t\tprv = it.first;\n\t}\n\t\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}