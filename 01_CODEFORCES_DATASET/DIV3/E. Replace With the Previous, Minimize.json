{"link": "https://codeforces.com//contest/1675/problem/E", "problemId": "1389922", "shortId": "1675E", "contest_number": "1675", "name": "E. Replace With the Previous, Minimize", "statement": "You are given a string  of lowercase Latin letters. The following operation can be used:   select one character (from '' to '') that occurs at least once in the string. And replace all such characters in the string with the previous one in alphabetical order on the loop. For example, replace all '' with '' or replace all '' with ''. And you are given the integer \u00a0\u2014 the maximum number of operations that can be performed. Find the minimum lexicographically possible string that can be obtained by performing no more than  operations.The string  is lexicographically smaller than the string  if there exists an index  () such that , , ..., , but .", "input": "The first line contains a single integer  ()\u00a0\u2014the number of test cases in the test. This is followed by descriptions of the test cases. The first line of each test case contains two integers  and  (, )\u00a0\u2014 the size of the string  and the maximum number of operations that can be performed on the string . The second line of each test case contains a string  of length  consisting of lowercase Latin letters.  It is guaranteed that the sum  over all test cases does not exceed .", "output": "For each test case, output the lexicographically minimal string that can be obtained from the string  by performing  than  operations.", "tutorial": "Greedy idea. To minimize the string, we will go from left to right and maintain a variable  = maximal character, from which we will reduce everything to 'a'. Initially it is 'a' and we spend  of operations on it. Then, at the next symbol, we can either reduce it to 'a' in no more than  operations, or reduce to 'a' the prefix we have already passed and minimize the next character in the remaining operations. ", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define sz(v) (int)v.size()\n#define all(v) v.begin(),v.end()\n#define eb emplace_back\n\ntemplate <class T> bool ckmax(T &a, T b) {return a<b ? a=b, true : false;}\n\n\nvoid solve() {\n    int n,k; cin >> n >> k;\n    string s; cin >> s;\n\n    char mn = 'a';\n    for (int i = 0; i < n; i++) if(s[i] > mn) {\n        if (s[i] - 'a' > k) {\n            k -= mn - 'a';\n            int to = s[i] - k;\n            for (char c = s[i]; c > to; c--) {\n                for (char &e:s) if (e == c) {\n                    e = char(c-1);\n                }\n            }\n            break;\n        } else ckmax(mn, s[i]);\n    }\n    for (char &e:s) if (e <= mn) {\n        e = 'a';\n    }\n    cout << s << endl;\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    forn(tt, t) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}