{"link": "https://codeforces.com//contest/1426/problem/F", "problemId": "741035", "shortId": "1426F", "contest_number": "1426", "name": "F. Number of Subsequences", "statement": "You are given a string  consisting of lowercase Latin letters \"\", \"\" and \"\" and question marks \"\".Let the number of question marks in the string  be . Let's replace each question mark with one of the letters \"\", \"\" and \"\". Here we can obtain all  possible strings consisting only of letters \"\", \"\" and \"\". For example, if \"\" then we can obtain the following strings: \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\".Your task is to count the total number of subsequences \"\" in all resulting strings. Since the answer can be very large, print it modulo .A subsequence of the string  is such a sequence that can be derived from the string  after removing some (possibly, zero) number of letters without changing the order of remaining letters. For example, the string \"\" contains two subsequences \"\" \u2014 a subsequence consisting of letters at positions  and a subsequence consisting of letters at positions .", "input": "The first line of the input contains one integer   \u2014 the length of . The second line of the input contains the string  of length  consisting of lowercase Latin letters \"\", \"\" and \"\" and question marks\"\".", "output": "Print the total number of subsequences \"\" in all strings you can obtain if you replace all question marks with letters \"\", \"\" and \"\", modulo .", "tutorial": "There are several more or less complicated combinatorial solutions to this problem, but I will describe a dynamic programming one which, I think, is way easier to understand and to implement.Suppose we have fixed the positions of ,  and  that compose the subsequence (let these positions be ,  and ). How many strings contain the required subsequence on these positions? Obviously, if some of these characters is already not a question mark and does not match the expected character on that position, the number of strings containing the subsequence on that position is . Otherwise, since we have fixed three characters, all question marks on other positions can be anything we want \u2014 so the number of such strings is , where  is the number of question marks on positions other than ,  and . It allows us to write an  solution by iterating on ,  and , and for every such triple, calculating the number of strings containing the required subsequence on those positions.But that's too slow. Let's notice that, for every such subsequence, the number of strings containing it is , where  is the number of positions from  that contain a question mark. So, for each integer  from  to , let's calculate the number of subsequences matching  that contain exactly  question marks \u2014 and that will allow us to solve the problem faster.How can we calculate the required number of subsequences for every ? In my opinion, the simplest way is dynamic programming: let  be the number of subsequences of  that end up in position , match  first characters of  and contain  question marks. The transitions in this dynamic programming are quadratic (since we have to iterate on the next/previous position from the subsequence), but can be sped up to linear if we rewrite  as the number of subsequences of  that end up in position , match  first characters of  and contain  question marks. Each transition is either to take the current character or to skip it, so they can be modeled in , and overall this dynamic programming solution works in .", "solution": "#include <bits/stdc++.h>\n                            \nusing namespace std;\n\nconst int MOD = int(1e9) + 7;\nconst int N = 200043;\nconst int K = 4;\n\nint add(int x, int y)\n{\n \tx += y;\n \twhile(x >= MOD) x -= MOD;\n \twhile(x < 0) x += MOD;\n \treturn x;\n}\n\nint mul(int x, int y)\n{\n \treturn (x * 1ll * y) % MOD;\n}\n\nint n;\nstring s;\nint dp[N][K][K];\nchar buf[N];\nint pow3[N];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tint cntQ = 0;\n\tfor(auto c : s)\n\t\tif(c == '?')\n\t\t\tcntQ++;\n\tpow3[0] = 1;\n\tfor(int i = 1; i < N; i++)\n\t\tpow3[i] = mul(pow3[i - 1], 3);\n\tdp[0][0][0] = 1;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j <= 3; j++)\n\t\t\tfor(int k = 0; k <= 3; k++)\n\t\t\t{\n\t\t\t \tif(!dp[i][j][k]) continue;\n\t\t\t \tdp[i + 1][j][k] = add(dp[i + 1][j][k], dp[i][j][k]);\n\t\t\t \tif(j < 3 && (s[i] == '?' || s[i] - 'a' == j))\n\t\t\t \t{\n\t\t\t \t \tint nk = (s[i] == '?' ? k + 1 : k);\n\t\t\t \t \tdp[i + 1][j + 1][nk] = add(dp[i + 1][j + 1][nk], dp[i][j][k]);\n\t\t\t \t}\n\t\t   \t}\n\tint ans = 0;\n\tfor(int i = 0; i <= 3; i++)\n\t\tif(cntQ >= i)\n\t\t\tans = add(ans, mul(dp[n][3][i], pow3[cntQ - i]));\n\tprintf(\"%d\\n\", ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}