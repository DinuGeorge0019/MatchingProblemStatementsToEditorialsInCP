{"link": "https://codeforces.com//contest/1154/problem/G", "problemId": "331483", "shortId": "1154G", "contest_number": "1154", "name": "G. Minimum Possible LCM", "statement": "You are given an array  consisting of  integers .Your problem is to find such pair of indices  () that  is minimum possible. is the least common multiple of  and  (minimum positive number such that both  and  are divisors of this number).", "input": "The first line of the input contains one integer  () \u2014 the number of elements in . The second line of the input contains  integers  (), where  is the -th element of .", "output": "Print two integers  and  () such that the value of  is minimum among all valid pairs . If there are multiple answers, you can print any.", "tutorial": "I've heard about some very easy solutions with time complexity , where  is the maximum value of , but I will describe my solution with time complexity , where  is the maximum number of divisors of .A very good upper-bound approximation of the number of divisors of  is  so my solution works in .Firstly, let's talk about the idea. The main idea is the following: for each number from  to , we want to find two minimum numbers in the array which are divisible by this number. Then we can find the answer among all such divisors that have at least two multiples in the array.Let's write a function  which will try to add the number  to all its divisors. The easiest way to do it is iterate over all divisors in time  and add it somehow. But it is too slow. Let's improve it somehow. How can we skip numbers that aren't divisors of ? Let's build an Eratosthenes sieve (I highly recommended one with time complexity  because the sieve with time complexity  is about twice slower on such constraints) which will maintain the minimum divisor for each number from  to  (the linear sieve builds this array automatically in its implementation). Then we can factorize the number in  and iterate over all its divisors using simple recursive function.And the last thing I should notice \u2014 this solution can give TLE and require some constant optimizations. I recommended to use pair of integers (or arrays of size two) for each divisor and to add numbers using a few -statements.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 10 * 1000 * 1000 + 11;\n\nint n;\nvector<int> a;\n\nint mind[N];\n\npair<int, int> mins[N];\nvector<pair<int, int>> divs;\n\nvoid build_sieve() {\n\tvector<int> pr;\n\tmind[0] = mind[1] = 1;\n\tfor (int i = 2; i < N; ++i) {\n\t\tif (mind[i] == 0) {\n\t\t\tpr.push_back(i);\n\t\t\tmind[i] = i;\n\t\t}\n\t\tfor (int j = 0; j < int(pr.size()) && pr[j] <= mind[i] && i * pr[j] < N; ++j) {\n\t\t\tmind[i * pr[j]] = pr[j];\n\t\t}\n\t}\n}\n\n\nvoid add_to_mins(int curd, int idx) {\n    if(mins[curd].first == -1)\n        mins[curd].first = idx;\n    else if(mins[curd].second == -1)\n        mins[curd].second = idx;\n}\n\nvoid rec(int pos, int curd, int idx) {\n\tif (pos == int(divs.size())) {\n\t\tadd_to_mins(curd, idx);\n\t\treturn;\n\t}\n\tint curm = 1;\n\tfor (int i = 0; i <= divs[pos].second; ++i) {\n\t\trec(pos + 1, curd * curm, idx);\n\t\tcurm *= divs[pos].first;\n\t}\n}\n\nvoid add(int idx) {\n\tint value = a[idx];\n\tdivs.clear();\n\twhile (value > 1) {\n\t\tint d = mind[value];\n\t\tif (!divs.empty() && divs.back().first == d) {\n\t\t\t++divs.back().second;\n\t\t} else {\n\t\t\tdivs.push_back(make_pair(d, 1));\n\t\t}\n\t\tvalue /= d;\n\t}\n\trec(0, 1, idx);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n;\n\ta.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor(int i = 0; i < N; i++)\n\t    mins[i] = make_pair(-1, -1);\n\tbuild_sieve();\n\t\n\tvector<pair<int, int> > vals;\n\tfor(int i = 0; i < n; i++)\n\t    vals.push_back(make_pair(a[i], i));\n\tsort(vals.begin(), vals.end());\n\tfor (int i = 0; i < n; ++i) {\n\t    if(i > 1 && vals[i].first == vals[i - 2].first) continue;\n\t\tadd(vals[i].second);\n\t}\n\t\n\tlong long l = INF * 1ll * INF;\n\tint ansi = -1, ansj = -1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpair<int, int> idxs = mins[i];\n\t\tif (idxs.second == -1) continue;\n\t\tlong long curl = a[idxs.first] * 1ll * a[idxs.second] / i;\n\t\tif (l > curl) {\n\t\t\tl = curl;\n\t\t\tansi = min(idxs.first, idxs.second);\n\t\t\tansj = max(idxs.first, idxs.second);\n\t\t}\n\t}\n\t\n\tcout << ansi + 1 << \" \" << ansj + 1 << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}