{"link": "https://codeforces.com//contest/1066/problem/D", "problemId": "235862", "shortId": "1066D", "contest_number": "1066", "name": "D. Boxes Packing", "statement": "Maksim has  objects and  boxes, each box has size exactly . Objects are numbered from  to  in order from left to right, the size of the -th object is .Maksim wants to pack his objects into the boxes and he will pack objects by the following algorithm: he takes one of the empty boxes he has, goes from left to right through the objects, and if the -th object fits in the current box (the remaining size of the box is greater than or equal to ), he puts it in the box, and the remaining size of the box decreases by . Otherwise he takes the new empty box and continues the process above. If he has no empty boxes and there is at least one object not in some box then Maksim cannot pack the chosen set of objects.Maksim wants to know the maximum number of objects he can pack by the algorithm above. To reach this target, . Your task is to say the maximum number of objects Maksim can pack in boxes he has.Each time when Maksim tries to pack the objects into the boxes, he will make empty all the boxes he has before do it (and the relative order of the remaining set of objects will not change).", "input": "The first line of the input contains three integers , ,  (, ) \u2014 the number of objects, the number of boxes and the size of each box. The second line of the input contains  integers  (), where  is the size of the -th object.", "output": "Print the maximum number of objects Maksim can pack using the algorithm described in the problem statement.", "tutorial": "The first solution is some kind of a straight-forward understanding the problem. Let's do binary search on the answer. So our problem is to find the smallest  such that the suffix of the array  starting from the position  can be packed in boxes. It is easy to see that if we can do it for some  then we always can do it for . And to find the answer for the fixed  we have to simulate the process described in the problem statement starting from the position . Okay, this is  solution.The second solution is more interesting than the first one. The approach is to reverse the initial array, simulate the process from the first position of reversed array and then all the objects we can pack are in the best answer and there is no better answer at all.Why it works?Let's take a look on the last box in the best answer if we will go from left to right in the initial array. Let objects in this box be . What do we see? . So all these objects are fit in the last box (obviously). Now if we will iterate over objects from right to left, these objects will fit also! It means that we cannot do worse by such a transform (reversing) at least for the last box.But what will happen if we can put some of the previous objects in this box? Well, it will not make worse for this box, but what about next boxes (previous boxes in straight notation)? Let objects in the penultimate box be . What do we see? These objects are fit in this box (obviously again). What will happen if we will put in the last box one or more objects of this box? Then the  border of objects which we will put in it will not increase because we  the number of object in this box. So we can see that for previous boxes this condition is also satisfied.So we can solve the problem with this approach. Time complexity of this solution is .", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n    int ans = n - pos + 1;\n    int used = 0;\n    while(used < m && pos <= n){\n        int t = k;\n        while(pos <= n && ar[pos] <= t){\n            t -= ar[pos++];\n        }\n        used++;\n    }\n    return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 1; i <= n; i++){\n        cin >> ar[i];\n    }\n    int ans = 0;\n    int l = 1, r = n;\n    while(l <= r){\n        int x = (l + r) >> 1;\n        if(find(x)){\n            ans = max(ans, n - x + 1);\n            r = x - 1;\n        }else{\n            l = x + 1;\n        }\n    }\n    cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}