{"link": "https://codeforces.com//contest/1029/problem/F", "problemId": "211261", "shortId": "1029F", "contest_number": "1029", "name": "F. Multicolored Markers", "statement": "There is an infinite board of square tiles. Initially all tiles are white.Vova has a red marker and a blue marker. Red marker can color  tiles. Blue marker can color  tiles. If some tile isn't white then you can't use marker of any color on it. Each marker must be drained completely, so at the end there should be exactly  red tiles and exactly  blue tiles across the board.Vova wants to color such a set of tiles that:  they would form a , consisting of exactly  colored tiles;  all tiles of at least one color would also form a . Here are some examples of correct colorings:  Here are some examples of incorrect colorings:  Among all correct colorings Vova wants to choose the one with the minimal perimeter. What is the minimal perimeter Vova can obtain?It is guaranteed that there exists at least one correct coloring.", "input": "A single line contains two integers  and  () \u2014 the number of tiles red marker should color and the number of tiles blue marker should color, respectively.", "output": "Print a single integer \u2014 the minimal perimeter of a colored rectangle Vova can obtain by coloring exactly  tiles red and exactly  tiles blue. It is guaranteed that there exists at least one correct coloring.", "tutorial": " should be area of the outer rectangle. It means that its sides are divisors of . The same holds for the inner rectangle. Let's assume that red color forms a rectangle, we'll try it and then swap  with  and solve the same problem again. Write down all the divisors of  up to , these are the possible smaller sides of the inner rectangle. Divisors of  up to  are possible smaller sides of the outer rectangle. Let's put inner rectangle to the left bottom corner of the outer rectangle and choose smaller sides of both of them as bottom and top ones. Iterate over the divisors  of , for each of them choose the greatest divisor  of  smaller or equal to it and check that . Update the answer with  if it holds.You can use both binary search or two pointers, both get AC pretty easily.The number of divisors of  can usually be estimated as .Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\ntypedef long long li;\n\nusing namespace std;\n\nconst int N = 1000 * 1000;\n\nint lens[N];\nint k;\n\nli solve(li a, li b){\n\tk = 0;\n\tfor (li i = 1; i * i <= b; ++i)\n\t\tif (b % i == 0)\n\t\t\tlens[k++] = i;\n\t\n\tli ans = 2 * (a + b) + 2;\n\tli x = a + b;\n\tint l = 0;\n\tfor (li i = 1; i * i <= x; ++i){\n\t\tif (x % i == 0){\n\t\t\twhile (l + 1 < k && lens[l + 1] <= i)\n\t\t\t\t++l;\n\t\t\tif (b / lens[l] <= x / i)\n\t\t\t\tans = min(ans, (i + x / i) * 2);\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tli a, b;\n\tscanf(\"%lld%lld\", &a, &b);\n\tprintf(\"%lld\\n\", min(solve(a, b), solve(b, a)));\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}