{"link": "https://codeforces.com//contest/1272/problem/E", "problemId": "494357", "shortId": "1272E", "contest_number": "1272", "name": "E. Nearest Opposite Parity", "statement": "You are given an array  consisting of  integers. In one move, you can jump from the position  to the position  (if ) or to the position  (if ).For each position  from  to  you want to know the minimum the number of moves required to reach any position  such that  has the opposite parity from  (i.e. if  is odd then  has to be even and vice versa).", "input": "The first line of the input contains one integer  () \u2014 the number of elements in . The second line of the input contains  integers  (), where  is the -th element of .", "output": "Print  integers , where  is the minimum the number of moves required to reach any position  such that  has the opposite parity from  (i.e. if  is odd then  has to be even and vice versa) or  if it is impossible to reach such a position.", "tutorial": "In this problem, we have directed graph consisting of  vertices (indices of the array) and at most  edges. Some vertices have the value , some have the value . Our problem is to find for every vertex the nearest vertex having the opposite parity. Let's try to solve the problem for odd numbers and then just run the same algorithm with even numbers.We have multiple odd vertices and we need to find the nearest even vertex for each of these vertices. This problem can be solved with the standard and simple but pretty idea. Let's inverse our graph and run a multi-source breadth-first search from all even vertices. The only difference between standard bfs and multi-source bfs is that the second one have many vertices at the first step (vertices having zero distance).Now we can notice that because of bfs every odd vertex of our graph has the distance equal to the minimum distance to some even vertex in the initial graph. This is exactly what we need. Then just run the same algorithm for even numbers and print the answer.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint n;\nvector<int> a;\nvector<int> ans;\nvector<vector<int>> g;\n\nvoid bfs(const vector<int> &start, const vector<int> &end) {\n\tvector<int> d(n, INF);\n\tqueue<int> q;\n\tfor (auto v : start) {\n\t\td[v] = 0;\n\t\tq.push(v);\n\t}\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tfor (auto to : g[v]) {\n\t\t\tif (d[to] == INF) {\n\t\t\t\td[to] = d[v] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto v : end) {\n\t\tif (d[v] != INF) {\n\t\t\tans[v] = d[v];\n\t\t}\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n;\n\ta = vector<int>(n);\n\tg = vector<vector<int>>(n);\n\tvector<int> even, odd;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tif (a[i] & 1) odd.push_back(i);\n\t\telse even.push_back(i);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint lf = i - a[i];\n\t\tint rg = i + a[i];\n\t\tif (0 <= lf) g[lf].push_back(i);\n\t\tif (rg < n) g[rg].push_back(i);\n\t}\n\t\n\tans = vector<int>(n, -1);\n\tbfs(odd, even);\n\tbfs(even, odd);\n\tfor (auto it : ans) cout << it << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}