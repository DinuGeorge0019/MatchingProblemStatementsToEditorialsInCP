{"link": "https://codeforces.com//contest/1234/problem/E", "problemId": "426515", "shortId": "1234E", "contest_number": "1234", "name": "E. Special Permutations", "statement": "Let's define  as the following permutation: . This means that the -th permutation is  (i.e. which maps every element to itself) permutation but the element  is on the first position. Examples:  ;  ;  ;  . You are given an array  ().Let  be the position of the element  in . So, .Let's define a function , where  is the absolute value of . This function means the sum of distances between adjacent elements of  in .Your task is to calculate .", "input": "The first line of the input contains two integers  and  () \u2014 the number of elements in each permutation and the number of elements in . The second line of the input contains  integers ()  (), where  is the -th element of . Elements of  can repeat and appear in arbitrary order.", "output": "Print  integers: .", "tutorial": "Let's calculate the answer for the first permutation  naively in . Then let's recalculate the answer somehow and then maybe prove that it works in linear time.Which summands will change when we try to recalculate the function  using ? First of all, let's notice that each pair of adjacent elements of  is the segment on the permutation. To calculate  fast, let's firstly notice that all segments that cover the element  (but  is not their endpoint) will change their length by minus one after placing  at the first position (because  will be removed from all such segments).This part can be calculated in . Let's use the standard trick with prefix sums and segments. Let  be the array of length . For each pair of adjacent elements  and  for all  from  to  let's do the following sequence of moves: if  then there are no points that covered by this segment not being its endpoints, so let's just skip this segment. Otherwise let's increase the value of  by one and decrease the value of  by one. After this, let's build prefix sums on this array (make  for all  from  to ). And now  equals to the number of segments covering the element .The second part that will change is such segments that  is their endpoint. Let's store the array of arrays  of length  and  will store all elements adjacent to  in the array  for all  from  to . But one important thing: we don't need to consider such pairs  and  that  (it broke my solution somehow so this part is important).Knowing these two parts we can easily calculate  using . Firstly, let's initialize the result as . Then we need to recalculate lengths of such segments that  is their endpoint. Let's iterate over all elements  in , set  (remove the old segment) and set  (add the length of the segment from  to ) and increase  by one if  (it means that  and  change their relative order and the length of the segment from  to  increases by one).Now we can see that after iterating over all  from  to  we make at most  moves because each pair of adjacent elements in  was considered at most twice.Total complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> a(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> a[i];\n\t\t--a[i];\n\t}\n\t\n\tvector<long long> res(n);\n\tfor (int j = 0; j < m - 1; ++j) {\n\t\tres[0] += abs(a[j] - a[j + 1]);\n\t}\n\t\n\tvector<int> cnt(n);\n\tvector<vector<int>> adj(n);\n\tfor (int i = 0; i < m - 1; ++i) {\n\t\tint l = a[i], r = a[i + 1];\n\t\tif (l != r) {\n\t\t\tadj[l].push_back(r);\n\t\t\tadj[r].push_back(l);\n\t\t}\n\t\tif (l > r) swap(l, r);\n\t\tif (r - l < 2) continue;\n\t\t++cnt[l + 1];\n\t\t--cnt[r];\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcnt[i + 1] += cnt[i];\n\t}\n\t\n\tfor (int i = 1; i < n; ++i) {\n\t\tres[i] = res[0] - cnt[i];\n\t\tfor (auto j : adj[i]) {\n\t\t\tres[i] -= abs(i - j);\n\t\t\tres[i] += j + (j < i);\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << res[i] << \" \";\n\t}\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}