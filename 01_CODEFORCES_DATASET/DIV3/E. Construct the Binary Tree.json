{"link": "https://codeforces.com//contest/1311/problem/E", "problemId": "547480", "shortId": "1311E", "contest_number": "1311", "name": "E. Construct the Binary Tree", "statement": "You are given two integers  and . You need to construct a rooted binary tree consisting of  vertices with a root at the vertex  and the sum of depths of all vertices equals to .A tree is a connected graph without cycles. A rooted tree has a special vertex called the root. A parent of a vertex  is the last different from  vertex on the path from the root to the vertex . The depth of the vertex  is the length of the path from the root to the vertex . Children of vertex  are all vertices for which  is the parent. The binary tree is such a tree that no vertex has more than  children.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. The only line of each test case contains two integers  and  () \u2014 the number of vertices in the tree and the required sum of depths of all vertices. It is guaranteed that the sum of  and the sum of  both does not exceed  ().", "output": "For each test case, print the answer. If it is impossible to construct such a tree, print \"\" (without quotes) in the first line. Otherwise, print \"{YES}\" in the first line. Then print  integers  in the second line, where  is the parent of the vertex . Note that the sequence of parents you print should describe some binary tree.", "tutorial": "This problem has an easy constructive solution. We can find lower and upper bounds on the value of  for the given . If the given  does not belong to this segment, then the answer is \"\". Otherwise, the answer is \"\" for any  in this segment.How to construct it? Let's start from the chain. The answer for the chain is the upper bound of  and it is . Then let's try to decrease the answer by  in one move. Let's take some leaf  (the vertex without children) with the smallest depth that is not  and try to move it up. The definition of badness will be below. To do this, let's find such vertex  that its depth is less than the depth of  by  and it has less than  children. If we found such vertex  then let's make  the child of  and decrease the answer by one.If we didn't find such vertex , I claim that the vertex  has the minimum possible depth it can have and we should not consider it in the future. Let's mark this vertex as  and continue our algorithm.If at some moment we cannot find any not  leaf , then the answer is \"\". Otherwise, the answer is \"\".Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, d;\n\t\tcin >> n >> d;\n\t\tint ld = 0, rd = n * (n - 1) / 2;\n\t\tfor (int i = 1, cd = 0; i <= n; ++i) {\n\t\t\tif (!(i & (i - 1))) ++cd;\n\t\t\tld += cd - 1;\n\t\t}\n\t\tif (!(ld <= d && d <= rd)) {\n\t\t\tcout << \"NO\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\n\t\tvector<int> par(n);\n\t\tiota(par.begin(), par.end(), -1);\n\t\t\n\t\tvector<int> cnt(n, 1);\n\t\tcnt[n - 1] = 0;\n\t\t\n\t\tvector<int> bad(n);\n\t\t\n\t\tvector<int> dep(n);\n\t\tiota(dep.begin(), dep.end(), 0);\n\t\t\n\t\tint cur = n * (n - 1) / 2;\n\t\twhile (cur > d) {\n\t\t\tint v = -1;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (!bad[i] && cnt[i] == 0 && (v == -1 || dep[v] > dep[i])) {\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(v != -1);\n\t\t\tint p = -1;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (cnt[i] < 2 && dep[i] < dep[v] - 1 && (p == -1 || dep[p] < dep[i])) {\n\t\t\t\t\tp = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p == -1) {\n\t\t\t\tbad[v] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tassert(dep[v] - dep[p] == 2);\n\t\t\t--cnt[par[v]];\n\t\t\t--dep[v];\n\t\t\t++cnt[p];\n\t\t\tpar[v] = p;\n\t\t\t--cur;\n\t\t}\n\t\n\t\tcout << \"YES\" << endl;\n\t\tfor (int i = 1; i < n; ++i) cout << par[i] + 1 << \" \";\n\t\tcout << endl;\n\t}\n\t\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}