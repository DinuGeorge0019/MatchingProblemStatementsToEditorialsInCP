{"link": "https://codeforces.com//contest/1454/problem/E", "problemId": "808364", "shortId": "1454E", "contest_number": "1454", "name": "E. Number of Simple Paths", "statement": "You are given an  graph consisting of  vertices and  edges. It is guaranteed that the given graph is  (i.\u00a0e. it is possible to reach any vertex from any other vertex) and there are no self-loops and multiple edges in the graph.Your task is to calculate the number of  of length   in the given graph. Note that paths that differ only by their direction are considered the same (i.\u00a0e. you have to calculate the number of  paths). For example, paths  and  are considered the same.You have to answer  independent test cases.Recall that a path in the graph is a sequence of vertices  such that each pair of adjacent (consecutive) vertices in this sequence is connected by an edge. The length of the path is the number of edges in it. A  is such a path that all vertices in it are distinct.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the number of vertices (and the number of edges) in the graph. The next  lines of the test case describe edges: edge  is given as a pair of vertices ,  (, ), where  and  are vertices the -th edge connects. For each pair of vertices , there is at most one edge between  and . There are no edges from the vertex to itself. So, there are no self-loops and multiple edges in the graph. The graph is , i.\u00a0e. all its edges are bidirectional. The graph is connected, i.\u00a0e. it is possible to reach any vertex from any other vertex by moving along the edges of the graph. It is guaranteed that the sum of  does not exceed  ().", "output": "For each test case, print one integer: the number of  of length   in the given graph. Note that paths that differ only by their direction are considered the same (i.\u00a0e. you have to calculate the number of  paths).", "tutorial": "Because our graph is just a tree with an additional edge, consider it as a cycle with trees hanged on cycle vertices.Consider some tree hung on a vertex $$$v$$$ on a cycle. There is only one path between each pair of its vertices (including the root which is a vertex $$$v$$$). So, if the tree has $$$cnt_v$$$ vertices, then $$$\\frac{cnt_v(cnt_v-1)}{2}$$$ paths are added to the answer. What about paths that go out of a tree? Let's assume that there are $$$cnt_v \\cdot (n - cnt_v)$$$ such paths (yeah, we counted only a half of actual paths from this component but this is fine). When we consider other trees, we will take into account the other half of paths.This information can lead us to the conclusion that the only information we need to know about trees hanged on cycle vertices is the number of vertices in these trees. So, if we know $$$cnt_v$$$ for each vertex on a cycle, we can just calculate the answer as $$$\\sum\\limits_{v \\in cycle} \\frac{cnt_v(cnt_v-1)}{2} + cnt_v \\cdot (n - cnt_v)$$$. So how to find values $$$cnt_v$$$?Of course, there is a simple and straight-forward solution \"just extract and mark all cycle vertices and run dfs from every vertex of a cycle\", but there is another approach without any graph algorithms that works very well for such kind of graphs. Initially, let $$$cnt_v = 1$$$ for each $$$v$$$ from $$$1$$$ to $$$n$$$. Let's create a queue containing all leafs of the graph. Let's take the leaf $$$x$$$, get its parent $$$p$$$, add $$$cnt_p := cnt_p + cnt_x$$$ and remove the vertex $$$x$$$ with all edges incident to it. After that, if $$$p$$$ became a leaf, let's add it to the queue.We can see that after processing all leafs only cycle vertices remain in the graph, and $$$cnt_v$$$ is exactly the number of the vertices in a tree (and we can just calculate the answer using the formula above).This approach can be implemented in $$$O(n \\log n)$$$ or in $$$O(n)$$$, there is almost no difference, but $$$O(n \\log n)$$$ one can be written a bit simpler than a linear one.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<set<int>> g(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\t--x, --y;\n\t\t\tg[x].insert(y);\n\t\t\tg[y].insert(x);\n\t\t}\n\t\tvector<int> val(n, 1);\n\t\tqueue<int> leafs;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (g[i].size() == 1) {\n\t\t\t\tleafs.push(i);\n\t\t\t}\n\t\t}\n\t\twhile (!leafs.empty()) {\n\t\t\tint v = leafs.front();\n\t\t\tleafs.pop();\n\t\t\tint to = *g[v].begin();\n\t\t\tval[to] += val[v];\n\t\t\tval[v] = 0;\n\t\t\tg[v].clear();\n\t\t\tg[to].erase(v);\n\t\t\tif (g[to].size() == 1) {\n\t\t\t\tleafs.push(to);\n\t\t\t}\n\t\t}\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tans += val[i] * 1ll * (val[i] - 1) / 2;\n\t\t\tans += val[i] * 1ll * (n - val[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}