{"link": "https://codeforces.com//contest/1092/problem/C", "problemId": "271421", "shortId": "1092C", "contest_number": "1092", "name": "C. Prefixes and Suffixes", "statement": "Ivan wants to play a game with you. He picked some string  of length  consisting only of lowercase Latin letters. You don't know this string. Ivan has informed you about all its improper prefixes and suffixes (i.e. prefixes and suffixes of lengths from  to ), but he didn't tell you which strings are prefixes and which are suffixes.Ivan wants you to guess which of the given  strings are prefixes of the given string and which are suffixes. It may be impossible to guess the string Ivan picked (since multiple strings may give the same set of suffixes and prefixes), but Ivan will accept your answer if there is at least one string that is consistent with it. Let the game begin!", "input": "The first line of the input contains one integer number  () \u2014 the length of the guessed string . The next  lines are contain prefixes and suffixes, one per line. Each of them is the string of length from  to  consisting only of lowercase Latin letters. They can be given in arbitrary order. It is guaranteed that there are exactly  strings of each length from  to . It is also guaranteed that these strings are prefixes and suffixes of some existing string of length .", "output": "Print one string of length  \u2014 the string consisting only of characters '' and ''. The number of characters '' should be equal to the number of characters ''. The -th character of this string should be '' if the -th of the input strings is the prefix and '' otherwise. If there are several possible answers, you can print .", "tutorial": "The first observation: if we will take two strings of length  then we  can restore the initial string. Why ? Because there are two possible options: when the first string of length  is a prefix and the second one is the suffix and vice versa.Let's write a function  which will check if the first string can be the prefix of the guessed string and the second one can be the suffix. After we write this function, we can run it two times (depending on the order of strings of length ) and find any suitable answer.If the first string () is the prefix and the second one () is the suffix then the whole string  (-indexed) where '' is the concatenation of strings. Let's check if we have all prefixes and suffixes of this string in the input. We can easy do it with two nested loops and some boolean array which can say us if some string is already used or not. Firstly, let's iterate over the length of the prefix or suffix and inside let's find any string from the input matching to the current prefix or suffix. If we find all  strings then the current string is one of the guessed and we can print the answer.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nvector<string> v;\n\nstring res;\n\nbool check(const string &pref, const string &suf) {\n\tstring s = pref + suf.substr(n - 2);\n\tmultiset<string> vv, sPref, sSuf;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tsPref.insert(s.substr(0, n - i - 1));\n\t\tvv.insert(s.substr(0, n - i - 1));\n\t\tsSuf.insert(s.substr(i + 1));\n\t\tvv.insert(s.substr(i + 1));\n\t}\n\tif (vv == multiset<string>(v.begin(), v.end())) {\n\t\tfor (int i = 0; i < 2 * n - 2; ++i) {\n\t\t\tif (sPref.count(v[i])) {\n\t\t\t\tres += 'P';\n\t\t\t\tsPref.erase(sPref.find(v[i]));\n\t\t\t} else if (sSuf.count(v[i])) {\n\t\t\t\tres += 'S';\n\t\t\t\tsSuf.erase(sSuf.find(v[i]));\n\t\t\t} else {\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n;\n\tv = vector<string>(2 * n - 2);\n\tvector<string> big;\n\tfor (int i = 0; i < 2 * n - 2; ++i) {\n\t\tcin >> v[i];\n\t\tif (int(v[i].size()) == n - 1) {\n\t\t\tbig.push_back(v[i]);\n\t\t}\n\t}\n\t\n\tif (check(big[0], big[1])) {\n\t\tcout << res << endl;\n\t} else {\n\t\tcheck(big[1], big[0]);\n\t\tcout << res << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}