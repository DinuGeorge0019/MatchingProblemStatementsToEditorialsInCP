{"link": "https://codeforces.com//contest/1611/problem/E1", "problemId": "1202188", "shortId": "1611E1", "contest_number": "1611", "name": "E1. Escape The Maze  easy version ", "statement": ".Vlad built a maze out of  rooms and  bidirectional corridors. From any room  any other room  can be reached through a sequence of corridors. Thus, the room system forms an undirected tree.Vlad invited  friends to play a game with them.Vlad starts the game in the room  and wins if he reaches a room other than , into which exactly one corridor leads.Friends are placed in the maze: the friend with number  is in the room , and no two friends are in the same room (that is,  for all ). Friends win if one of them meets Vlad in any room or corridor before he wins.For one unit of time, each participant of the game can go through one corridor. All participants move at the same time. Participants may not move. Each room can fit all participants at the same time. Friends know the plan of a maze and intend to win. Vlad is a bit afraid of their ardor. Determine if he can guarantee victory (i.e. can he win in any way friends play).In other words, determine if there is such a sequence of Vlad's moves that lets Vlad win in any way friends play.", "input": "The first line of the input contains an integer  () \u2014 the number of test cases in the input. The input contains an empty string before each test case. The first line of the test case contains two numbers  and  () \u2014 the number of rooms and friends, respectively. The next line of the test case contains  integers  () \u2014 numbers of rooms with friends. All  are different. The next  lines contain descriptions of the corridors, two numbers per line  and  () \u2014 numbers of rooms that connect the  corridor. All corridors are bidirectional. From any room, you can go to any other by moving along the corridors. It is guaranteed that the sum of the values  over all test cases in the test is not greater than .", "output": "Print  lines, each line containing the answer to the corresponding test case. The answer to a test case should be \"\" if Vlad can guarantee himself a victory and \"\" otherwise. You may print every letter in any case you want (so, for example, the strings \"\", \"\", \"\" and \"\" will all be recognized as positive answers).", "tutorial": "First, we need to understand when it is not possible to get to some exit . Let's fix a friend who is at the vertex  and try to understand if he can interfere with us. The paths from  to  and from  to  have a common part, let it start at the vertex . Then, if the path from  to  is not more than from  to , it can prevent us from reaching this exit by blocking the vertex . Since the path from  to  is common, the previous condition is equivalent to the condition that the path from  to  is not greater than from  to . Note that if there is more than one such vertex , then  can overlap each of them, simply by going as close to the root as possible.  Thus, Vlad can win if there is such a leaf (which, by condition, exits) for which the distance to the root is less than the distance to any of the friends.By running a breadth-first search at the same time from each vertex with a friend, we can find the shortest distance to any friend from each vertex and by running from the root\u00a0\u2014 the distance to the root. Now let's just go through all the leaves and check if there is one among them that the distance to the root is less.We can also run from the vertices with friends and from the root at the same time, assigning them different colors, then the color will correspond to what is closer: the root or some friend. this solution is attached to the tutorial.There is also another solution, which is a simplified version of the one we will use in E2.", "solution": "//\n// Created by Vlad on 16.11.2021.\n//\n \n#include <bits/stdc++.h>\n \n#define int long long\n#define mp make_pair\n#define x first\n#define y second\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n \ntypedef long double ld;\ntypedef long long ll;\n \nusing namespace std;\n \nmt19937 rnd(143);\n \nconst int inf = 1e10;\nconst int M = 998244353;\nconst ld pi = atan2(0, -1);\nconst ld eps = 1e-4;\n \nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> color(n, -1);\n    deque<int> q;\n    for(int i = 0; i < k; ++i){\n        int x;\n        cin >> x;\n        color[--x] = 0;\n        q.push_back(x);\n    }\n    color[0] = 1;\n    q.push_back(0);\n    vector<vector<int>> g(n);\n    for(int i = 0; i < n - 1; ++i){\n        int u, v;\n        cin >> u >> v;\n        g[--u].push_back(--v);\n        g[v].push_back(u);\n    }\n    while(!q.empty()){\n        int v = q.front();\n        q.pop_front();\n        for(int u: g[v]){\n            if(color[u] == -1){\n                color[u] = color[v];\n                q.push_back(u);\n            }\n        }\n    }\n    for(int v = 1; v < n; ++v){\n        if(g[v].size() == 1 && color[v] == 1){\n            cout << \"YES\";\n            return;\n        }\n    }\n    cout << \"NO\";\n}\n \nbool multi = true;\n \nsigned main() {\n    int t = 1;\n    if (multi) {\n        cin >> t;\n    }\n    for (; t != 0; --t) {\n        solve();\n        cout << \"\\n\";\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}