{"link": "https://codeforces.com//contest/1675/problem/D", "problemId": "1389921", "shortId": "1675D", "contest_number": "1675", "name": "D. Vertical Paths", "statement": "You are given a rooted tree consisting of  vertices. Vertices are numbered from  to . Any vertex can be the root of a tree.A  is a connected undirected graph without cycles. A  is a tree with a selected vertex, which is called the .The tree is specified by an array of parents  containing  numbers:  is a parent of the vertex with the index . The  of a vertex  is a vertex that is the next vertex on the shortest path from  to the root. For example, on the simple path from  to  (the root), the next vertex would be , so the parent of  is .The root has no parent, so for it, the value of  is  (the root is the only vertex for which ).Find such a set of paths that:  each vertex belongs to exactly one path, each path can contain one or more vertices;  in each path each next vertex\u00a0\u2014 is a son of the current vertex (that is, paths always lead down\u00a0\u2014 from parent to son);  number of paths is . For example, if  and , then the tree can be divided into three paths:    (path of  vertices),   (path of  vertices).   (path of  vertices).      ", "input": "The first line of input data contains an integer  () \u2014 the number of test cases in the test. Each test case consists of two lines. The first of them contains an integer  (). It is the number of vertices in the tree. The second line contains  integers  (). It is guaranteed that the  array encodes some rooted tree. It is guaranteed that the sum of the values  over all test cases in the test does not exceed .", "output": "For each test case on the first line, output an integer  \u2014 the minimum number of non-intersecting leading down paths that can cover all vertices of the tree. Then print  pairs of lines containing path descriptions. In the first of them print the length of the path, in the second \u2014 the sequence of vertices specifying that path in the order from top to bottom. You can output the paths in any order. If there are several answers, output any of them.", "tutorial": "Let's find a set of leaves of a given tree. From each leaf we will climb up the tree until we meet a vertex already visited. Having met such a vertex, start a new path from the next leaf. The sequence of vertices in the found paths must be deduced in reverse order, because the paths must go from bottom to top. It also follows from this solution that the number of paths will always be equal to the number of leaves in the tree.", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<int>b(n + 1);\n    vector<bool>leaf(n + 1, true);\n    for(int i = 1; i <= n; i++) {\n        cin >> b[i];\n        leaf[b[i]] = false;\n    }\n\n    if(n == 1){\n        cout << \"1\\n1\\n1\\n\\n\";\n        return;\n    }\n\n    vector<int>paths[n + 1];\n    vector<bool>used(n + 1, false);\n    int color = 0;\n\n    for(int i = 1; i <= n; i++){\n        if(!leaf[i]) continue;\n        used[i] = true;\n        paths[color].emplace_back(i);\n\n        int v = i;\n        while (b[v] != v && !used[b[v]]){\n            v = b[v];\n            used[v] = true;\n            paths[color].emplace_back(v);\n        }\n        color++;\n    }\n\n    cout << color << '\\n';\n    for(auto &path : paths){\n        if(path.empty()) continue;\n        cout << (int)path.size() << '\\n';\n        reverse(path.begin(), path.end());\n        for(auto &v: path) cout << v << ' ';\n        cout << '\\n';\n    }\n    cout << '\\n';\n}\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}