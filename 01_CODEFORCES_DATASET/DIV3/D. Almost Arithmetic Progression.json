{"link": "https://codeforces.com//contest/978/problem/D", "problemId": "182879", "shortId": "978D", "contest_number": "978", "name": "D. Almost Arithmetic Progression", "statement": "Polycarp likes arithmetic progressions. A sequence  is called an arithmetic progression if for each  () the value  is the same. For example, the sequences , ,  and  are arithmetic progressions, but ,  and  are not.It follows from the definition that any sequence of length one or two is an arithmetic progression.Polycarp found some sequence of positive integers . He agrees to change each element by at most one. In the other words, for each element there are exactly three options: an element can be decreased by , an element can be increased by , an element can be left unchanged.Determine a minimum possible number of elements in  which can be changed (by exactly one), so that the sequence  becomes an arithmetic progression, or report that it is impossible.It is possible that the resulting sequence contains element equals .", "input": "The first line contains a single integer   \u2014 the number of elements in . The second line contains a sequence  .", "output": "If it is impossible to make an arithmetic progression with described operations, print . In the other case, print non-negative integer \u2014 the minimum number of elements to change to make the given sequence becomes an arithmetic progression. The only allowed operation is to add/to subtract one from an element (can't use operation twice to the same position).", "tutorial": "If  we can print , because each such sequence is an arithmetic progression.Note, that an arithmetic progression is uniquely determined by the first two terms. So we should brute  from  to  \u2014 the change of the first element of the given sequence, and  from  to  \u2014 the change of the second element of the given sequence. Then  and . Also we will store  \u2014 the number of changed elements in the sequence. Initially . Now we need to iterate through the sequence from the third element to -th. Let current element in the position . It should be equals to . If , then such arithmetic progression is unreachable. Else, if  we should increase  on one. After we considered all elements we should update the answer with the value of , if for all  it was true that .", "solution": "#include <bits/stdc++.h>\n#define DIM 100007\n#define INF 1000000007\nusing namespace std;\n\nlong long n,b[DIM];\nint main()\n{\n    cin>>n;\n    for(int i = 1;i<=n;++i)\n        cin>>b[i];\n\n    long long res = INF;\n\n    for(int k1 = -1; k1<=1;++k1)\n        for(int k2 = -1;k2<=1;++k2)\n    {\n        long long d = b[2]+k2 - b[1] - k1,last = b[2] +k2,curr = 0;\n        if(k1!=0) curr++;\n        if(k2!=0) curr++;\n\n        for(int i = 3;i<=n;++i)\n        {\n            long long need = last + d;\n            if(abs(need - b[i])>1)\n            {\n                curr = INF;\n                break;\n            }\n            if(need != b[i])\n                curr++;\n\n            last = need;\n        }\n\n        res = min(res,curr);\n    }\n\n    if(res == INF) cout<<-1;\n    else cout<<res;\n    return 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}