{"link": "https://codeforces.com//contest/1077/problem/F2", "problemId": "256066", "shortId": "1077F2", "contest_number": "1077", "name": "F2. Pictures with Kittens  hard version ", "statement": "Vova likes pictures with kittens. The news feed in the social network he uses can be represented as an array of  consecutive pictures (with kittens, of course). Vova likes all these pictures, but some are more beautiful than the others: the -th picture has beauty .Vova wants to repost exactly  pictures in such a way that:   each segment of the news feed of at least  consecutive pictures has at least one picture reposted by Vova;  the sum of beauty values of reposted pictures is maximum possible. For example, if  then Vova has to repost all the pictures in the news feed. If  then Vova can skip some pictures, but between every pair of consecutive pictures Vova has to repost at least one of them.Your task is to calculate the maximum possible sum of values of reposted pictures if Vova follows conditions described above, or say that there is no way to satisfy all conditions.", "input": "The first line of the input contains three integers  and  () \u2014 the number of pictures in the news feed, the minimum length of segment with at least one repost in it and the number of pictures Vova is ready to repost. The second line of the input contains  integers  (), where  is the beauty of the -th picture.", "output": "Print  if there is no way to repost some pictures to satisfy all the conditions in the problem statement. Otherwise print one integer \u2014 the maximum sum of values of reposted pictures if Vova follows conditions described in the problem statement.", "tutorial": "Let's use dynamic programming described in the previous tutorial to solve this problem too. But its complexity is  so we have to improve some part of the solution.Let's see how we do transitions in this dp: for  . What can we do to optimize it?  is the constant and we have to take the maximum value among . You will say \"segment tree\"! I say no. Not a segment tree. Not a sparse table. Not a cartesian tree or some other logarithmic data structures. If you want to spend a lot of time to fit such solution in time and memory limits \u2014 okay, it is your choice. I prefer the queue with supporting the maximum on it.The last part of this tutorial will be a small guide about how to write and use the queue with supporting the maximum on it.The first part of understanding this data structure is the stack with the maximum. How do we support the stack with the maximum on it? That's pretty easy: let's maintain the stack of pairs, when the first value of pair is the value in the stack and the second one is the maximum on the stack if this element will be the topmost. Then when we push some value  in it, the first element of pair will be  and the second one will be  (if  is our stack and  is the topmost element). When we pop the element we don't need any special hacks to do it. Just pop it. And the maximum on the stack is always .Okay, the second part of understanding this data structure is the queue on two stacks. Let's maintain two stacks  and  and try to implement the queue using it. We will push elements only to  and pop elements only from . Then how to maintain the queue using such stacks? The push is pretty easy \u2014 just push it in . The main problem is pop. If  is not empty then we have to pop it from . But what do we do if  is empty? No problems: let's just transfer elements of  to  (pop from , push to ) in order from top to bottom. And don't forget to pop the element after this transfer!Okay, if we will join these two data structures, we can see that we obtain exactly what we want! Just two stacks with maximums! That's pretty easy to understand and implement it.The last part of the initial solution is pretty easy \u2014 just apply this data structure (in fact,  data structures) to do transitions in our dynamic programming. The implementation of this structure can be found in the authors solution.Total complexity of the solution is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n\ntypedef long long li;\ntypedef pair<li, li> pll;\n\nconst li INF64 = 1e18;\n\nstruct myQueue {\n\tstack<pll> s1, s2;\n\t\n\tint size() {\n\t\treturn s1.size() + s2.size();\n\t}\n\t\n\tbool isEmpty() {\n\t\treturn size() == 0;\n\t}\n\t\n\tlong long getMax() {\n\t\tif (isEmpty()) {\n\t\t\treturn -INF64;\n\t\t}\n\t\tif (!s1.empty() && !s2.empty()) {\n\t\t\treturn max(s1.top().y, s2.top().y);\n\t\t}\n\t\tif (!s1.empty()) {\n\t\t\treturn s1.top().y;\n\t\t}\n\t\treturn s2.top().y;\n\t}\n\t\n\tvoid push(long long val) {\n\t\tif (s2.empty()) {\n\t\t\ts2.push(mp(val, val));\n\t\t} else {\n\t\t\ts2.push(mp(val, max(val, s2.top().y)));\n\t\t}\n\t}\n\t\n\tvoid pop() {\n\t\tif (s1.empty()) {\n\t\t\twhile (!s2.empty()) {\n\t\t\t\tif (s1.empty()) {\n\t\t\t\t\ts1.push(mp(s2.top().x, s2.top().x));\n\t\t\t\t} else {\n\t\t\t\t\ts1.push(mp(s2.top().x, max(s2.top().x, s1.top().y)));\t\n\t\t\t\t}\n\t\t\t\ts2.pop();\n\t\t\t}\n\t\t}\n\t\tassert(!s1.empty());\n\t\ts1.pop();\n\t}\n};\n\nint n, k, x;\nvector<int> a;\n\nvector<myQueue> q;\nvector<queue<int>> pos;\nvector<vector<long long>> dp;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> k >> x;\n\ta = vector<int>(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tq = vector<myQueue>(x + 1);\n\tpos = vector<queue<int>>(x + 1);\n\tdp = vector<vector<long long>>(n + 1, vector<long long>(x + 1, -INF64));\n\t\n\tdp[0][x] = 0;\n\tpos[x].push(-1);\n\tq[x].push(0ll);\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j <= x; ++j) {\n\t\t\twhile (!pos[j].empty() && pos[j].front() < i - k - 1) {\n\t\t\t\tq[j].pop();\n\t\t\t\tpos[j].pop();\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < x; ++j) {\n\t\t\tif (!q[j + 1].isEmpty()) {\n\t\t\t\tdp[i][j] = max(dp[i][j], q[j + 1].getMax() + a[i - 1]);\n\t\t\t\tq[j].push(dp[i][j]);\n\t\t\t\tpos[j].push(i - 1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long ans = -INF64;\n\tfor (int i = n - k + 1; i <= n; ++i) {\n\t\tans = max(ans, *max_element(dp[i].begin(), dp[i].end()));\n\t}\n\tif (ans == -INF64) ans = -1;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}