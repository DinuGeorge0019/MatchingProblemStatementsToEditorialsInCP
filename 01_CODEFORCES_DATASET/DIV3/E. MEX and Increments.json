{"link": "https://codeforces.com//contest/1619/problem/E", "problemId": "1234626", "shortId": "1619E", "contest_number": "1619", "name": "E. MEX and Increments", "statement": "Dmitry has an array of  non-negative integers .In one operation, Dmitry can choose any index  () and increase the value of the element  by . He can choose the same index  multiple times.For each  from  to , determine whether Dmitry can make the  of the array equal to exactly . If it is possible, then determine the minimum number of operations to do it.The  of the array is equal to the minimum non-negative integer that is not in the array. For example, the  of the array  is equal to , and the array  is equal to .", "input": "The first line of input data contains a single integer  ()\u00a0\u2014 the number of test cases in the input.  The descriptions of the test cases follow. The first line of the description of each test case contains a single integer  ()\u00a0\u2014 the length of the array . The second line of the description of each test case contains  integers  ()\u00a0\u2014 elements of the array . It is guaranteed that the sum of the values  over all test cases in the test does not exceed .", "output": "For each test case, output  integer\u00a0\u2014 -th number is equal to the minimum number of operations for which you can make the array  equal to  (), or  if this cannot be done.", "tutorial": "First, let's sort the array. Then we will consider its elements in non-decreasing order. To make MEX equal to , you need to increase all zeros. To make MEX at least , you first need to make MEX at least , and then, if the number  is missing in the array, you need to get it. If there are no extra values less than , then this and all subsequent MEX values cannot be obtained. Otherwise, you can use the maximum of the extra array values. To do this, you can use a data structure such as a stack. If an element occurs more than once in the array, put its extra occurrences on the stack.", "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n \nusing namespace std;\n \ntypedef long long ll;\nconst int MAX_N = 2e5;\n \nint main() {\n    int t;\n    cin >> t;\n    for (int _ = 0; _ < t; ++_) {\n        int n;\n        cin >> n;\n        vector<int> a(n), cnt(n + 1);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n            cnt[a[i]]++;\n        }\n        sort(a.begin(), a.end());\n        stack<int> st;\n        vector<ll> ans(n + 1, -1);\n        ll sum = 0;\n        for (int i = 0; i <= n; ++i) {\n            if (i > 0 && cnt[i - 1] == 0) {\n                if (st.empty()) {\n                    break;\n                }\n                int j = st.top();\n                st.pop();\n                sum += i - j - 1;\n            }\n            ans[i] = sum + cnt[i];\n            while (i > 0 && cnt[i - 1] > 1) {\n                cnt[i - 1]--;\n                st.push(i - 1);\n            }\n        }\n        for (ll x : ans) {\n            cout << x << ' ';\n        }\n        cout << '\\n';\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}