{"link": "https://codeforces.com//contest/1472/problem/C", "problemId": "854353", "shortId": "1472C", "contest_number": "1472", "name": "C. Long Jumps", "statement": "Polycarp found under the Christmas tree an array  of  elements and instructions for playing with it:   At first, choose index  ()\u00a0\u2014 starting position in the array. Put the chip at the index  (on the value ).  While , add  to your score and move the chip  positions to the right (i.e. replace  with ).  If , then Polycarp ends the game. For example, if  and , then the following game options are possible:   Polycarp chooses . Game process: . The score of the game is: .  Polycarp chooses . Game process: . The score of the game is: .  Polycarp chooses . Game process: . The score of the game is: .  Polycarp chooses . Game process: . The score of the game is: .  Polycarp chooses . Game process: . The score of the game is: . Help Polycarp to find out the maximum score he can get if he chooses the starting index in an optimal way.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. Then  test cases follow. The first line of each test case contains one integer  ()\u00a0\u2014 the length of the array . The next line contains  integers  ()\u00a0\u2014 elements of the array . It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, output on a separate line one number\u00a0\u2014 the maximum score that Polycarp can get by playing the game on the corresponding array according to the instruction from the statement. Note that Polycarp chooses any starting position from  to  in such a way as to maximize his result.", "tutorial": "Let  be the result of the game if we chose  as the starting position.Let's look at some starting position . After making a move from it, we will get  points and move to the position , continuing the same game. This means that by choosing the position , we can assume that we will get a result  more than if we chose the position . Formally, .Let's calculate all the results of  and store them in an array. Let's start iterating through the positions from the end, then being in the position  we will know  for all . Using the formula above, we can calculate  in one operation. It remains only to choose the maximum of all such values.", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int &x : a) {\n    cin >> x;\n  }\n\n  vector<int> dp(n);\n  for (int i = n - 1; i >= 0; i--) {\n    dp[i] = a[i];\n    int j = i + a[i];\n    if (j < n) {\n      dp[i] += dp[j];\n    }\n  }\n  cout << *max_element(dp.begin(), dp.end()) << endl;\n}\n\nint main() {\n  int tests;\n  cin >> tests;\n  while (tests-- > 0) {\n    solve();\n  }\n  return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}