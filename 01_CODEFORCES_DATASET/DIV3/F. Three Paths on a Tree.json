{"link": "https://codeforces.com//contest/1294/problem/F", "problemId": "521712", "shortId": "1294F", "contest_number": "1294", "name": "F. Three Paths on a Tree", "statement": "You are given an unweighted tree with  vertices. Recall that a tree is a connected undirected graph without cycles.Your task is to choose  vertices  on this tree such that the number of edges which belong to  one of the simple paths between  and ,  and , or  and  is the maximum possible. See the notes section for a better understanding.The simple path is the path that visits each vertex at most once.", "input": "The first line contains one integer number  () \u2014 the number of vertices in the tree.  Next  lines describe the edges of the tree in form  (, , ). It is guaranteed that given graph is a tree.", "output": "In the first line print one integer  \u2014 the maximum number of edges which belong to  one of the simple paths between  and ,  and , or  and . In the second line print three integers  such that  and . If there are several answers, you can print any.", "tutorial": "There is some obvious dynamic programming solution that someone can describe in the comments, but I will describe another one, that, in my opinion, much easier to implement.Firstly, let's find some diameter of the tree. Let  and  be the endpoints of this diameter (and first two vertices of the answer). You can prove yourself why it is always good to take the diameter and why any diameter can be taken in the answer. Then there are two cases: the length of the diameter is  or the length of the diameter is less than . In the first case, you can take any other vertex as the third vertex of the answer , it will not affect the answer anyway. Otherwise, we can run multi-source bfs from all vertices of the diameter and take the farthest vertex as the third vertex of the answer. It is always true because we can take any diameter and the farthest vertex will increase the answer as much as possible.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\nvector<int> p;\nvector<vector<int>> g;\n\npair<int, int> dfs(int v, int par = -1, int dist = 0) {\n\tp[v] = par;\n\tpair<int, int> res = make_pair(dist, v);\n\tfor (auto to : g[v]) {\n\t\tif (to == par) continue;\n\t\tres = max(res, dfs(to, v, dist + 1));\n\t}\n\treturn res;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tp = vector<int>(n);\n\tg = vector<vector<int>>(n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\t\n\t}\n\t\n\t\n\tpair<int, int> da = dfs(0);\n\tpair<int, int> db = dfs(da.y);\n\tvector<int> diam;\n\tint v = db.y;\n\twhile (v != da.y) {\n\t\tdiam.push_back(v);\n\t\tv = p[v];\n\t}\n\tdiam.push_back(da.y);\n\t\n\tif (int(diam.size()) == n) {\n\t\tcout << n - 1 << \" \" << endl << diam[0] + 1 << \" \" << diam[1] + 1 << \" \" << diam.back() + 1 << endl;\n\t} else {\n\t\tqueue<int> q;\n\t\tvector<int> d(n, -1);\n\t\tfor (auto v : diam) {\n\t\t\td[v] = 0;\n\t\t\tq.push(v);\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\tfor (auto to : g[v]) {\n\t\t\t\tif (d[to] == -1) {\n\t\t\t\t\td[to] = d[v] + 1;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int, int> mx = make_pair(d[0], 0);\n\t\tfor (int v = 1; v < n; ++v) {\n\t\t\tmx = max(mx, make_pair(d[v], v));\n\t\t}\n\t\tcout << int(diam.size()) - 1 + mx.x << endl << diam[0] + 1 << \" \" << mx.y + 1 << \" \" << diam.back() + 1 << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}