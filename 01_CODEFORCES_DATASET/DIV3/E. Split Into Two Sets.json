{"link": "https://codeforces.com//contest/1702/problem/E", "problemId": "1456430", "shortId": "1702E", "contest_number": "1702", "name": "E. Split Into Two Sets", "statement": "Polycarp was recently given a set of  (number \u00a0\u2014 even) dominoes. Each domino contains two integers from  to .Can he divide all the dominoes into two sets so that all the numbers on the dominoes of each set are different? Each domino must go into exactly one of the two sets.For example, if he has  dominoes: , ,  and , then Polycarp will be able to divide them into two sets in the required way. The first set can include the first and third dominoes ( and ), and the second set\u00a0\u2014 the second and fourth ones ( and ).", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The descriptions of the test cases follow. The first line of each test case contains a single even integer  () \u2014 the number of dominoes. The next  lines contain pairs of numbers  and  () describing the numbers on the -th domino. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case print:   , if it is possible to divide  dominoes into two sets so that the numbers on the dominoes of each set are different;   if this is not possible.  You can print  and  in any case (for example, the strings , ,  and  will be recognized as a positive answer).", "tutorial": "Polycarp has  dominoes, on each domino there are  numbers\u00a0\u2014 it turns out, there will be  numbers in total.We need to divide  numbers (each number from  to ) into two sets so that all numbers in each set are different\u00a0\u2014 each set will consist of  numbers. It turns out that all numbers from  to  must occur exactly  times, no more and no less.Let's imagine it all as a bipartite graph, where there are vertices from  to , and dominoes are edges. Since each number occurs exactly  times, then we have a lot of cycles. In which the edges of each number must be included in different sets, in other words, the cycles must be of even length.This can be checked in  by a simple enumeration.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nmap<int, vector<int>> m;\nvector<bool> used;\n\nint go(int v) {\n    used[v] = true;\n    for (auto now : m[v]) {\n        if (!used[now]) {\n            return go(now) + 1;\n        }\n    }\n    return 1;\n}\n\nvoid solve() {\n\n    int n, x, y;\n    cin >> n;\n\n    m.clear();\n    used.clear();\n    used.resize(n + 1, false);\n\n    bool fault = false;\n    forn(i, n) {\n        cin >> x >> y;\n        m[x].push_back(y);\n        m[y].push_back(x);\n        if (x == y || m[x].size() > 2 || m[y].size() > 2) fault = true;\n    }\n\n    if (fault) {\n        cout << \"NO\\n\";\n        return;\n    }\n\n    forn(i, n) {\n        if (!used[i + 1]) {\n            if (go(i + 1) % 2) {\n                cout << \"NO\\n\";\n                return;\n            }\n        }\n    }\n\n    cout << \"YES\\n\";\n}\nint main() {\n    int tests;\n    cin >> tests;\n    forn(tt, tests) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}