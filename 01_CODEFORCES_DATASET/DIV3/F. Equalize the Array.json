{"link": "https://codeforces.com//contest/1490/problem/F", "problemId": "898528", "shortId": "1490F", "contest_number": "1490", "name": "F. Equalize the Array", "statement": "Polycarp was gifted an array  of length . Polycarp considers an array beautiful if there exists a number , such that each number in the array occurs either zero or  times. Polycarp wants to remove some elements from the array  to make it beautiful.For example, if  and , then the following options are possible to make the array  array beautiful:   Polycarp removes elements at positions  and , array  becomes equal to ;  Polycarp removes elements at positions  and , array  becomes equal to ;  Polycarp removes elements at positions  and , array  becomes equal to ; Help Polycarp determine the minimum number of elements to remove from the array  to make it beautiful.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. Then  test cases follow. The first line of each test case consists of one integer  ()\u00a0\u2014 the length of the array . The second line of each test case contains  integers  ()\u00a0\u2014 array . It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, output one integer\u00a0\u2014 the minimum number of elements that Polycarp has to remove from the array  to make it beautiful.", "tutorial": "Let's calculate the value of \u00a0\u2014 how many times the number  occurs in the array . We will iterate over the value of  and look for the minimum number of moves necessary for each number to appear in the  array either  times, or  times. Note that if there is no such number  that , then such a value of  will not give the minimum answer (because we have removed unnecessary elements).Then, for a specific , the answer is calculated as follows: Since the number of candidates for the value of  is no more than , this method works in .Then there are two ways to optimize our solution:   you can consider only unique values of  (there are no more than ), and get a solution in ;  you can sort the values  and use prefix sums, this solution works for  or for  (if you use counting sort). ", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  map<int, int> cnt;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    cnt[x]++;\n  }\n  map<int, int> groupedByCnt;\n  for (auto[x, y] : cnt) {\n    groupedByCnt[y]++;\n  }\n\n  int res = n;\n  int left = 0, right = n, rightCnt = (int) cnt.size();\n  for (auto[x, y] : groupedByCnt) {\n    res = min(res, left + right - rightCnt * x);\n    left += x * y;\n    right -= x * y;\n    rightCnt -= y;\n  }\n  cout << res << endl;\n}\n\nint main() {\n  int tests;\n  cin >> tests;\n  while (tests-- > 0) {\n    solve();\n  }\n  return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}