{"link": "https://codeforces.com//contest/1579/problem/E1", "problemId": "1123870", "shortId": "1579E1", "contest_number": "1579", "name": "E1. Permutation Minimization by Deque", "statement": "A permutation  of size  is given. A  of size  is an array of size  in which each integer from  to  occurs exactly once. For example,  and  are correct permutations while  and  are not.Let us consider an empty deque (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements  currently in the deque, adding an element  to the beginning will produce the sequence , and adding same element to the end will produce .The elements of the permutation are sequentially added to the initially empty deque, starting with  and finishing with . Before adding each element to the deque, you may choose whether to add it to the beginning or the end.For example, if we consider a permutation , one of the possible sequences of actions looks like this:  1.add  to the end of the deque:deque has a sequence  in it; 2.add  to the beginning of the deque:deque has a sequence  in it; 3.add  to the end of the deque:deque has a sequence  in it; 4.add  to the end of the deque:deque has a sequence  in it;Find the lexicographically smallest possible sequence of elements in the deque after the entire permutation has been processed. A sequence  is  than the sequence  if there exists such  that , , ,  and . In other words, if the sequences  and  have some (possibly empty) matching prefix, and the next element of the sequence  is strictly smaller than the corresponding element of the sequence . For example, the sequence  is smaller than the sequence  because after the two matching elements  in the start the first sequence has an element  which is smaller than the corresponding element  in the second sequence.", "input": "The first line contains an integer  ()\u00a0\u2014 the number of test cases. The next  lines contain descriptions of the test cases.  The first line of each test case description contains an integer  ()\u00a0\u2014 permutation size. The second line of the description contains  space-separated integers  (; all  are all unique)\u00a0\u2014 elements of the permutation. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "Print  lines, each line containing the answer to the corresponding test case. The answer to a test case should contain  space-separated integer numbers\u00a0\u2014 the elements of the lexicographically smallest permutation that is possible to find in the deque after executing the described algorithm.", "tutorial": "We'll process the permutation elements one by one.For the first element, it doesn't matter which side of the deque we add it to, the result of its addition will be the same\u00a0\u2014 there will be a sequence of one element (equal to the first permutation element) in the deque.Now let's consider adding the -th element of a permutation to the deque. First  will be considered, then , and so on up to . Let us describe the general algorithm for choosing the side of the deque for each step. Note that if the elements  are now in the deque, then all final permutations that can be obtained in the deque from the current state can be broken down into pairs of the form   where the beginning and the end of the final permutations, hidden behind \"\", are obtained by the same sequences of all the following choices and thus are equal between the first and the second.Note that when  the first permutation will always be lexicographically smaller than the second one, and vice versa. Therefore, regardless of the following choices, if  then the second permutation will never be minimal, and if  then the first permutation will never be minimal.This means that we can make a choice about the side of the deque to add the -th element to based only on its relation to : if , then  is added to the beginning of the deque, otherwise\u00a0\u2014 to the end.The time complexity is . Alternative solutions, which also fit in the time limit, involved finding a lexicographically minimal increasing sequence in the reversed original permutation and could be implemented either with  time complexity or with  time complexity if the permutation's definition was taken into consideration.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, a;\n        cin >> n;\n        deque<int> d;\n        for (int i = 0; i < n; i++) {\n            cin >> a;\n            if (d.empty() || a < d[0])\n                d.push_front(a);\n            else\n                d.push_back(a);\n        }\n        for (int x : d)\n            cout << x << ' ';\n        cout << '\\n';\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}