{"link": "https://codeforces.com//contest/1283/problem/D", "problemId": "504970", "shortId": "1283D", "contest_number": "1283", "name": "D. Christmas Trees", "statement": "There are  Christmas trees on an infinite number line. The -th tree grows at the position . All  are guaranteed to be distinct.Each  point can be either occupied by the Christmas tree, by the human or not occupied at all. Non-integer points cannot be occupied by anything.There are  people who want to celebrate Christmas. Let  be the positions of people (note that all values  should be  and all  should be ). You want to find such an arrangement of people that the value  is the minimum possible (in other words, the sum of distances to the nearest Christmas tree for all people should be minimized).In other words, let  be the distance from the -th human to the nearest Christmas tree (). Then you need to choose such positions  that  is the minimum possible.", "input": "The first line of the input contains two integers  and  () \u2014 the number of Christmas trees and the number of people. The second line of the input contains  integers  (), where  is the position of the -th Christmas tree. It is guaranteed that all  are distinct.", "output": "In the first line print one integer  \u2014 the minimum possible value of  (in other words, the sum of distances to the nearest Christmas tree for all people). In the second line print  integers  (), where  is the position of the -th human. All  should be distinct and all values  should be . If there are multiple answers, print any of them.", "tutorial": "In this problem, we first need to consider all points adjacent to at least one Christmas tree, then all points at the distance two from the nearby Christmas tree and so on... What it looks like? Yes, well-known multi-source bfs.Let's maintain a queue of positions and the set of used positions (and the distance to each vertex, of course). In the first step, we add all positions of the Christmas tree with a zero distance as initial vertices. Let the current vertex is . If  (this is the Christmas tree) then just add  and  to the queue (if these vertices aren't added already) and continue. Otherwise, increase the answer by  and add  to the array of positions of people. When the length of this array reaches , interrupt bfs and print the answer.Don't forget about some special cases as using  in Java or using  in C++ because this can lead to the quadratic complexity.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> x(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> x[i];\n\t}\n\tqueue<int> q;\n\tmap<int, int> d;\n\tfor (int i = 0; i < n; ++i) {\n\t\td[x[i]] = 0;\n\t\tq.push(x[i]);\n\t}\n\tlong long ans = 0;\n\tvector<int> res;\n\twhile (!q.empty()) {\n\t\tif (int(res.size()) == m) break;\n\t\tint cur = q.front();\n\t\tq.pop();\n\t\tif (d[cur] != 0) {\n\t\t\tans += d[cur];\n\t\t\tres.push_back(cur);\n\t\t}\n\t\tif (!d.count(cur - 1)) {\n\t\t\td[cur - 1] = d[cur] + 1;\n\t\t\tq.push(cur - 1);\n\t\t}\n\t\tif (!d.count(cur + 1)) {\n\t\t\td[cur + 1] = d[cur] + 1;\n\t\t\tq.push(cur + 1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\tshuffle(res.begin(), res.end(), rnd);\n\tfor (auto it : res) cout << it << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}