{"link": "https://codeforces.com//contest/1005/problem/E2", "problemId": "196330", "shortId": "1005E2", "contest_number": "1005", "name": "E2. Median on Segments  General Case Edition ", "statement": "You are given an integer sequence .Find the number of pairs of indices  () such that the value of median of  is exactly the given number .The median of a sequence is the value of an element which is in the middle of the sequence after sorting it in non-decreasing order. If the length of the sequence is even, the left of two middle elements is used.For example, if  then its median is  since after sorting the sequence, it will look like  and the left of two middle elements is equal to . The median of  equals  since after sorting, the value  will be in the middle of the sequence.Write a program to find the number of pairs of indices  () such that the value of median of  is exactly the given number .", "input": "The first line contains integers  and  () \u2014 the length of the given sequence and the required value of the median. The second line contains an integer sequence  ().", "output": "Print the required number.", "tutorial": "Let's define a function greaterCount() \u2014 number of subarrays with median greater or equal than . In this case, the answer on the problem is greaterCount()  greaterCount().The subarray  has median greater or equal than , if and only if , where  is the number equal or greater than  elements, and  is the number of less than  elements.In other words, instead of processing  you can use the sequence  containing  or/and . An element , if . An element , if . Now, the median of  is greater or equal than  if and only if .Let's iterate over  from left to right. Maintain the current partial sum . Additionally, in the array  let's maintain the number of partial sum for each its value. It means that before increase of  you should do . So if  is the index of the right endpoint of a subarray (i.e. ), then number of suitable indices  is number of such  that . In other words, find sum of all , where  \u2014 it is exactly number of indices with partial sum less than .Each time partial sum changes on  or . So the value \"sum of all , where \" is easy to recalculate on each change. If you decrease , just subtract the value . If you increase , before increasing just add .Since indices in  can be from  to , you can use 0-based indices using an array . In this case, initialize  as  but not as  (it makes  to be non-negative on each step).This solution works in .\n", "solution": "long long greaterCount(int m) {\n    vector<int> s(2 * n + 1);\n    int sum = n;\n    long long result = 0;\n    s[sum] = 1;\n    long long add = 0;\n    forn(i, n) {\n        if (a[i] < m)\n            sum--, add -= s[sum];\n        else\n            add += s[sum], sum++;\n        result += add;\n        s[sum]++;\n    }\n    return result;\n}\n\ncin >> n >> m;\na = vector<int>(n);\nforn(i, n)\n    cin >> a[i];\ncout << greaterCount(m) - greaterCount(m + 1) << endl;", "interactive": false, "noSolution": false, "noTutorial": false}