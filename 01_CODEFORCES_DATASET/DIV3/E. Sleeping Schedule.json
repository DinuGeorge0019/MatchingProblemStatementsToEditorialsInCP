{"link": "https://codeforces.com//contest/1324/problem/E", "problemId": "560264", "shortId": "1324E", "contest_number": "1324", "name": "E. Sleeping Schedule", "statement": "Vova had a pretty weird sleeping schedule. There are  hours in a day. Vova will sleep exactly  times. The -th time he will sleep exactly after  hours from the time he woke up. You can assume that Vova woke up exactly at the beginning of this story (the initial time is ). Each time Vova sleeps  (in other words,  hours).Vova thinks that the -th sleeping time is  if he starts to sleep between hours  and  inclusive.Vova can control himself and before the -th time can choose between two options: go to sleep after  hours or after  hours.Your task is to say the maximum number of  sleeping times Vova can obtain if he acts optimally.", "input": "The first line of the input contains four integers  and  () \u2014 the number of times Vova goes to sleep, the number of hours in a day and the segment of the  sleeping time. The second line of the input contains  integers  (), where  is the number of hours after which Vova goes to sleep the -th time.", "output": "Print one integer \u2014 the maximum number of  sleeping times Vova can obtain if he acts optimally.", "tutorial": "This is a very standard dynamic programming problem. Let  be the maximum number of  sleeping times if Vova had a sleep  times already and the number of times he goes to sleep earlier by one hour is exactly . Then the value  will be the answer. Initially, all  and .What about transitions? Let the current state of the dynamic programming be  and . Then we can don't go to sleep earlier and make the first transition: . The sign  is modulo operation and the notation  is the boolean result of the expression  ( if  is true and  otherwise). And the second transition if we go to sleep earlier: .Don't forget to don't make transitions from unreachable states.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool in(int x, int l, int r) {\n\treturn l <= x && x <= r;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, h, l, r;\n\tcin >> n >> h >> l >> r;\n\tvector<int> a(n);\n\tfor (auto &it : a) cin >> it;\n\tvector<vector<int>> dp(n + 1, vector<int>(n + 1, INT_MIN));\n\tdp[0][0] = 0;\n\tint sum = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tsum += a[i];\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tdp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + in((sum - j) % h, l, r));\n\t\t\tif (j < n) dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + in((sum - j - 1) % h, l, r));\n\t\t}\n\t}\n\t\n\tcout << *max_element(dp[n].begin(), dp[n].end()) << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}