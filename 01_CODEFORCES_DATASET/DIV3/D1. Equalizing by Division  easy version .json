{"link": "https://codeforces.com//contest/1213/problem/D1", "problemId": "399402", "shortId": "1213D1", "contest_number": "1213", "name": "D1. Equalizing by Division  easy version ", "statement": ".You are given an array  consisting of  integers. In one move you can choose any  and divide it by  rounding down (in other words, in one move you can set ).You can perform such an operation  (possibly, zero) number of times with  .Your task is to calculate the minimum possible number of operations required to obtain at least  equal numbers in the array..", "input": "The first line of the input contains two integers  and  () \u2014 the number of elements in the array and the number of equal numbers required. The second line of the input contains  integers  (), where  is the -th element of .", "output": "Print one integer \u2014 the minimum possible number of operations required to obtain at least  equal numbers in the array.", "tutorial": "Let  be the number such that after some sequence of moves there will be at least  elements  in the array. We can see that there is always  possible candidates because all values  are among all possible values of  for some  from  to . So we need to check each candidate separately and try to update the answer with it. How to do this?Let the current number we trying to obtain is . Then let's iterate over all  in any order. Let  be the current value of . Let's divide it by  while its value is greater than  and carry the number of divisions we made . If after all divisions  then let's remember the value of  in some array . If after iterating over all  elements of  the size of  is greater than or equal to  then let's sort it and update the answer with the sum of  smallest values of .Time complexity:  or , depends on sorting method.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tvector<int> poss;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x = a[i];\n\t\twhile (x > 0) {\n\t\t\tposs.push_back(x);\n\t\t\tx /= 2;\n\t\t}\n\t}\n\t\n\tint ans = 1e9;\n\tfor (auto res : poss) {\n\t\tvector<int> cnt;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x = a[i];\n\t\t\tint cur = 0;\n\t\t\twhile (x > res) {\n\t\t\t\tx /= 2;\n\t\t\t\t++cur;\n\t\t\t}\n\t\t\tif (x == res) {\n\t\t\t\tcnt.push_back(cur);\n\t\t\t}\n\t\t}\n\t\tif (int(cnt.size()) < k) continue;\n\t\tsort(cnt.begin(), cnt.end());\n\t\tans = min(ans, accumulate(cnt.begin(), cnt.begin() + k, 0));\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}