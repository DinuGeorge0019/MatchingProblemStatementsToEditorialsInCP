{"link": "https://codeforces.com//contest/1249/problem/C1", "problemId": "447560", "shortId": "1249C1", "contest_number": "1249", "name": "C1. Good Numbers  easy version ", "statement": ".You are given a positive integer number . You really love  so you want to find the smallest  greater than or equal to .The positive integer is called  if it can be represented as a sum of  powers of  (i.e. no duplicates of powers of  are allowed).For example:   is a : ,   is a : ,   is a : ,  but  is  a : you can't represent it as a sum of distinct powers of  (),   is  a : you can't represent it as a sum of distinct powers of  (for example, the representations  are invalid),   is also  a : you can't represent it as a sum of distinct powers of  (for example, the representation  is invalid). Note, that there exist other representations of  and  as sums of powers of  but none of them consists of  powers of .For the given positive integer  find such smallest  () that  is a .You have to answer  independent queries.", "input": "The first line of the input contains one integer  () \u2014 the number of queries. Then  queries follow. The only line of the query contains one integer  ().", "output": "For each query, print such smallest integer  (where ) that  is a .", "tutorial": "As you can see from the example, the maximum answer doesn't exceed . So we can run some precalculation before all queries, which will find all  less than . The number is  if it has no  in the ternary numeral system. When you read the next query, you can increase  until you find some precalculated . Time complexity is .You also can implement the solution which doesn't use any precalculations and just increase  each time in each query and checks if the number is  inside this loop. Then time complexity will be .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint n;\n\t\tcin >> n;\n\t\twhile (true) {\n\t\t\tbool ok = true;\n\t\t\tint cur = n;\n\t\t\twhile (cur > 0) {\n\t\t\t\tif (ok && cur % 3 == 2) ok = false;\n\t\t\t\tcur /= 3;\n\t\t\t}\n\t\t\tif (ok) break;\n\t\t\t++n;\n\t\t}\n\t\tcout << n << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}