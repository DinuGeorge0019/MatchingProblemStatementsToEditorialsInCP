{"link": "https://codeforces.com//contest/1203/problem/D1", "problemId": "388105", "shortId": "1203D1", "contest_number": "1203", "name": "D1. Remove the Substring  easy version ", "statement": ".You are given a string  and a string , both consisting only of lowercase Latin letters. It is guaranteed that  can be obtained from  by removing some (possibly, zero) number of characters (not necessary contiguous) from  without changing order of remaining characters (in other words, it is guaranteed that  is a subsequence of ).For example, the strings \"\", \"\", \"\", \"\" and \"\" are subsequences of the string \"\". But the strings \"\", \"\", \"\" are not subsequences of the string \"\".You want to remove some substring (contiguous subsequence) from  of  such that after removing this substring  will remain a subsequence of .If you want to remove the substring  then the string  will be transformed to  (where  is the length of ).Your task is to find the maximum possible length of the substring you can remove so that  is still a subsequence of .", "input": "The first line of the input contains one string  consisting of at least  and at most  lowercase Latin letters. The second line of the input contains one string  consisting of at least  and at most  lowercase Latin letters. It is guaranteed that  is a subsequence of .", "output": "Print one integer \u2014 the maximum possible length of the substring you can remove so that  is still a subsequence of .", "tutorial": "In this problem we can just iterate over all possible substrings and try to remove each of them. After removing the substring we can check if  remains the subsequence of  in linear time.Let we remove the substring . Let's maintain a pointer  (the initial value of the pointer is ) and iterate over all possible  from  to . If  and  let's increase  by one. If after all iterations  then let's update the answer with the length of the current substring.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tstring s, t;\n\tcin >> s >> t;\n\tint ans = 0;\n\tfor (int i = 0; i < int(s.size()); ++i) {\n\t\tfor (int j = i; j < int(s.size()); ++j) {\n\t\t\tint pos = 0;\n\t\t\tfor (int p = 0; p < int(s.size()); ++p) {\n\t\t\t\tif (i <= p && p <= j) continue;\n\t\t\t\tif (pos < int(t.size()) && t[pos] == s[p]) ++pos;\n\t\t\t}\n\t\t\tif (pos == int(t.size())) ans = max(ans, j - i + 1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}