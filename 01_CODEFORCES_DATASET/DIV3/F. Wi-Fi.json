{"link": "https://codeforces.com//contest/1216/problem/F", "problemId": "416606", "shortId": "1216F", "contest_number": "1216", "name": "F. Wi-Fi", "statement": "You work as a system administrator in a dormitory, which has  rooms one after another along a straight hallway. Rooms are numbered from  to .You have to connect all  rooms to the Internet.You can connect each room to the Internet directly, the cost of such connection for the -th room is  coins. Some rooms also have a spot for a router. The cost of placing a router in the -th room is also  coins. You cannot place a router in a room which does not have a spot for it. When you place a router in the room , you connect all rooms with the numbers from  to  inclusive to the Internet, where  is the range of router. The value of  is the same for all routers. Calculate the minimum total cost of connecting all  rooms to the Internet. You can assume that the number of rooms which have a spot for a router is not greater than the number of routers you have.", "input": "The first line of the input contains two integers  and  () \u2014 the number of rooms and the range of each router. The second line of the input contains one string  of length , consisting only of zeros and ones. If the -th character of the string equals to '' then there is a spot for a router in the -th room. If the -th character of the string equals to '' then you cannot place a router in the -th room.", "output": "Print one integer \u2014 the minimum total cost of connecting all  rooms to the Internet.", "tutorial": "Firstly, I know that this problem has very pretty linear solution and its author can describe it if he wants. I'll describe my own solution without any data structures but .Let  be the total cost to connect all rooms from  to  to the Internet (-indexed). Initially , all other values are . Let's iterate over all  from  to  and make some transitions. After all the answer will be .The first transition is the easier: update  with  (just connect the current room directly). To do other transitions, let's carry two sets  and  and one array of vectors  of length . Set  carries all values . Initially it carries . Set  carries the minimum cost to cover some suffix of rooms that also covers the room . Array of vectors  helps us to carry the set  efficiently. First of all, if  then let's remove  from . Then let's remove all values of  from . Then if  is not empty, let's update  with the minimum value of . Then if  '' then let  be the minimum value of  plus . Update  with  and insert  into . Also let's add  into  if . And after we make all we need with the current , add the value  to the set .Time complexity: .It can be optimized to  solution with some advanced data structures as a queue with minimums.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<long long> dp(n + 1);\n\tmultiset<long long> mins, vals;\n\tmins.insert(0);\n\tvector<vector<long long>> del(n);\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tdp[i] = i + 1 +  dp[i + 1];\n\t\tif (i + k + 2 <= n) mins.erase(mins.find(dp[i + k + 2]));\n\t\tfor (auto it : del[i]) vals.erase(vals.find(it));\n\t\tif (!vals.empty()) dp[i] = min(dp[i], *vals.begin());\n\t\tif (s[i] == '1') {\n\t\t\tlong long val = (mins.empty() ? 0 : *mins.begin()) + i + 1;\n\t\t\tdp[i] = min(dp[i], val);\n\t\t\tvals.insert(val);\n\t\t\tif (i - k - 1 >= 0) del[i - k - 1].push_back(val);\n\t\t}\n\t\tmins.insert(dp[i]);\n\t}\n\t\n\tcout << dp[0] << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}