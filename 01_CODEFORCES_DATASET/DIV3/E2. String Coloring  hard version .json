{"link": "https://codeforces.com//contest/1296/problem/E2", "problemId": "531587", "shortId": "1296E2", "contest_number": "1296", "name": "E2. String Coloring  hard version ", "statement": ".You are given a string  consisting of  lowercase Latin letters.You have to color  its characters  (each character to exactly one color, the same letters can be colored the same or different colors, i.e. you can choose exactly one color for each index in ).After coloring, you can swap  two neighboring characters of the string that are colored  colors. You can perform such an operation arbitrary (possibly, zero) number of times.The goal is to make the string sorted, i.e. all characters should be in alphabetical order.Your task is to find the minimum number of colors which you have to color the given string in so that after coloring it can become sorted by  sequence of swaps. Note that you have to restore only coloring, not the sequence of swaps.", "input": "The first line of the input contains one integer  () \u2014 the length of . The second line of the input contains the string  consisting of exactly  lowercase Latin letters.", "output": "In the first line print one integer  () \u2014 the minimum number of colors in which you have to color the given string so that after coloring it can become sorted by  sequence of swaps. In the second line print  possible coloring that can be used to sort the string using some sequence of swaps described in the problem statement. The coloring is the array  of length , where  and  means the color of the -th character.", "tutorial": "The solution of this problem is based on Dilworth's theorem. You can read about it on Wikipedia. In two words, this theorem says that the minimum number of non-decreasing sequences we need to cover the whole sequence equals the length of longest decreasing subsequence.Let's calculate the dynamic programming  \u2014 the length of longest decreasing sequence that ends in the position . To recalculate this dynamic, let's carry the array  of length , where  means the maximum value of  for the character  on the prefix we already considered. So, initially all  are ones, all values of  are zeros. For the position  we update  with  and update  with .Okay, how to restore the answer? That's pretty easy. The color of the -th character is exactly . Why it is so? If  becomes greater than  then we surely need to use the new color for this character because we cannot append it to the end of any existing sequence. Otherwise, we will append it to some existing sequence (with the maximum possible number) and because it has the maximum number and we didn't update the value of  with the number of this sequence plus one, the current character is not less than the last in this sequence.Time complexity:  or .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\t\n\tvector<int> maxdp(26);\n\tvector<int> dp(n, 1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int c = 25; c > s[i] - 'a'; --c) {\n\t\t\tdp[i] = max(dp[i], maxdp[c] + 1);\n\t\t}\n\t\tmaxdp[s[i] - 'a'] =  max(maxdp[s[i] - 'a'], dp[i]);\n\t}\n\t\n\tcout << *max_element(maxdp.begin(), maxdp.end()) << endl;\n\tfor (int i = 0; i < n; ++i) cout << dp[i] << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}