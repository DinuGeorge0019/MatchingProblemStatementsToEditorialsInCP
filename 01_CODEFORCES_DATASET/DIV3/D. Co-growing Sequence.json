{"link": "https://codeforces.com//contest/1547/problem/D", "problemId": "1041928", "shortId": "1547D", "contest_number": "1547", "name": "D. Co-growing Sequence", "statement": "A sequence of non-negative integers  is called  if for all  from  to  all ones (of binary representation) in  are in the places of ones (of binary representation) in  (in other words, , where  denotes bitwise AND). If  then the sequence is considered  as well.For example, the following four sequences are growing:    \u2014 in binary it's ;   \u2014 in binary it's ;   \u2014 in binary it's ;   \u2014 in binary it's . The following three sequences are non-growing:    \u2014 in binary it's ;   \u2014 in binary it's ;   \u2014 in binary it's . Consider two sequences of non-negative integers  and . Let's call this pair of sequences  if the sequence  is  where  denotes bitwise XOR.You are given a sequence of integers . Find the lexicographically minimal sequence  such that sequences  and  are co-growing.The sequence  is lexicographically smaller than the sequence  if there exists  such that  for any  but .", "input": "The first line contains an integer  (). Then  test cases follow. The first line of each test case contains an integer  () \u2014 length of the sequence . The second line contains  integers  () \u2014 elements of the sequence . It is guaranteed that the sum of  overall all test cases doesn't exceed .", "output": "For each test case, print  integers  () \u2014 lexicographically minimal sequence such that such that it's co-growing with given sequence .", "tutorial": "In order to build lexicographically minimal co-growing with  sequence, it is enough to build its elements iteratively, beginning from  and minimizing the -th element assuming that  have already been found.Assign . According to the statement, all elements of the sequence are non-negative, so  cannot be less than zero. It turns out that  is the minimal possible first element. The existence of an answer with  follows from the construction algorithm described below.Let's use mathematical induction and construct  under the assumption that all the previous elements of the sequence have already been constructed. In order to satisfy the condition for the growth of the final sequence, the number  must contain one bits at all places (but not necessarily limited to them), on which there are one bits in the number . Let's denote  for  and find out what bits can be in  to satisfy this condition:   If in  stands  bit then independently from  in  at the same spot we can place any bit because there is no limit on the corresponding bit in ;  If in  stands  bit and in \u00a0\u2014  then the corresponding bit in  should be equal , so that in  the corresponding bit also equals one;  If in  and in  stands  bit then in  should be  bit at the corresponding place for the same reasons. The bit transformation described above can be given by the expression . Indeed, this expression gives us bit 'one' at the fixed position if and only if at that place in  stands  bit and in  stands  bit. For the full solution, it remains only to apply this formula in a loop from  to .", "solution": "def f(x, y):\n    return x & ~y\n\nt = int(input())\nfor tt in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    ans = [0] * n\n    for i in range(1, n):\n        ans[i] = f(ans[i - 1] ^ a[i - 1], a[i])\n    print(\" \".join(map(str, ans)))", "interactive": false, "noSolution": false, "noTutorial": false}