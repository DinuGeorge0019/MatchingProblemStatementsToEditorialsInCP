{"link": "https://codeforces.com//contest/1385/problem/F", "problemId": "675203", "shortId": "1385F", "contest_number": "1385", "name": "F. Removing Leaves", "statement": "You are given a tree (connected graph without cycles) consisting of  vertices. The tree is unrooted \u2014 it is just a connected undirected graph without cycles.In one move, you can choose exactly  leaves (leaf is such a vertex that is connected to only one another vertex) connected  and remove them with edges incident to them. I.e. you choose such leaves  that there are edges , , ,  and remove these leaves and these edges.Your task is to find the  number of moves you can perform if you remove leaves optimally.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains two integers  and  (; ) \u2014 the number of vertices in the tree and the number of leaves you remove in one move, respectively. The next  lines describe edges. The -th edge is represented as two integers  and  (), where  and  are vertices the -th edge connects. It is guaranteed that the given set of edges forms a tree. It is guaranteed that the sum of  does not exceed  ().", "output": "For each test case, print the answer \u2014 the  number of moves you can perform if you remove leaves optimally.", "tutorial": "This is mostly implementation problem. We can notice that all leaves are indistinguishable for us. So if we have some vertex with at least $$$k$$$ leaves attached to it, we can choose it, remove these leaves from the tree and continue the algorithm. The rest is just an implementation: let's maintain for each vertex $$$v$$$ the list of all leaves which are connected to it $$$leaves_v$$$ and the set of vertices which is sorted by the size of $$$leaves_v$$$. So let's take any vertex which Is connected with at least $$$k$$$ leaves (we can just take the vertex with the maximum value in the set) and remove any $$$k$$$ leaves attached to it. If it has zero leaves after the current move, let's mark is as a leaf and append it to the list of the corresponding vertex (you also need to remove edges from the graph fast to find the required vertex, so you may need to maintain the graph as the list of sets). And don't forget about the case $$$k=1$$$ because it may be special for your solution so you could handle it in a special way.Time complexity: $$$O(n \\log{n})$$$.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, k, ans;\nvector<set<int>> g;\nvector<set<int>> leaves;\n\nstruct comp {\n\tbool operator() (int a, int b) const {\n\t\tif (leaves[a].size() == leaves[b].size()) return a < b;\n\t\treturn leaves[a].size() > leaves[b].size();\n\t}\n};\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tcin >> n >> k;\n\t\tg = leaves = vector<set<int>>(n);\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\t--x, --y;\n\t\t\tg[x].insert(y);\n\t\t\tg[y].insert(x);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (g[i].size() == 1) {\n\t\t\t\tleaves[*g[i].begin()].insert(i);\n\t\t\t}\n\t\t}\n\t\tset<int, comp> st;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tst.insert(i);\n\t\t}\n\t\tint ans = 0;\n\t\twhile (true) {\n\t\t\tint v = *st.begin();\n\t\t\tif (int(leaves[v].size()) < k) break;\n\t\t\tfor (int i = 0; i < k; ++i) {\n\t\t\t\tint leaf = *leaves[v].begin();\n\t\t\t\tg[leaf].erase(v);\n\t\t\t\tg[v].erase(leaf);\n\t\t\t\tst.erase(v);\n\t\t\t\tst.erase(leaf);\n\t\t\t\tleaves[v].erase(leaf);\n\t\t\t\tif (leaves[leaf].count(v)) leaves[leaf].erase(v);\n\t\t\t\tif (g[v].size() == 1) {\n\t\t\t\t\tint to = *g[v].begin();\n\t\t\t\t\tst.erase(to);\n\t\t\t\t\tleaves[to].insert(v);\n\t\t\t\t\tst.insert(to);\n\t\t\t\t}\n\t\t\t\tst.insert(v);\n\t\t\t\tst.insert(leaf);\n\t\t\t\t\n\t\t\t}\n\t\t\tans += 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}