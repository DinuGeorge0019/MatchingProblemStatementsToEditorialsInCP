{"link": "https://codeforces.com//contest/1385/problem/C", "problemId": "675200", "shortId": "1385C", "contest_number": "1385", "name": "C. Make It Good", "statement": "You are given an array  consisting of  integers. You have to find the length of the smallest (shortest)  of elements you need to erase from  to make it a  array. Recall that the prefix of the array  is a subarray consisting several first elements: the prefix of the array  of length  is the array  ().The array  of length  is called , if you can obtain a  array  () from it, repeating the following operation  times (initially,  is empty):  select either the first or the last element of , remove it from , and append it to the end of the array . For example, if we do  operations: take , then , then  and at last , then  becomes  and .Consider the following example: . This array is  because we can obtain  array  from it by the following sequence of operations:  take the first element of , so , ;  take the last element of , so , ;  take the last element of , so , ;  take the first element of , so , ;  take the first element of , so , ;  take the last element of , so , ;  take the only element of , so , \u00a0\u2014  is non-decreasing. Note that the array consisting of one element is .Print the length of the shortest prefix of  to delete (erase), to make  to be a  array. Note that the required length can be .You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the length of . The second line of the test case contains  integers  (), where  is the -th element of . It is guaranteed that the sum of  does not exceed  ().", "output": "For each test case, print the answer: the length of the shortest  of elements you need to erase from  to make it a  array.", "tutorial": "Consider the maximum element $$$a_{mx}$$$ of the good array $$$a$$$ of length $$$k$$$. Then we can notice that the array $$$a$$$ looks like $$$[a_1 \\le a_2 \\le \\dots \\le a_{mx} \\ge \\dots \\ge a_{k-1} \\ge a_k]$$$. And this is pretty obvious that if the array doesn't have this structure, then it isn't good (you can see it yourself). So we need to find the longest such suffix. It's pretty easy doable with pointer: initially, the pointer $$$pos$$$ is at the last element. Then, while $$$pos > 1$$$ and $$$a_{pos - 1} \\ge a_{pos}$$$, decrease $$$pos$$$ by one. If we're done with the previous step, we do the same, but while $$$pos > 1$$$ and $$$a_{pos - 1} \\le a_{pos}$$$. The answer is $$$pos-1$$$.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tint pos = n - 1;\n\t\twhile (pos > 0 && a[pos - 1] >= a[pos]) --pos;\n\t\twhile (pos > 0 && a[pos - 1] <= a[pos]) --pos;\n\t\tcout << pos << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}