{"link": "https://codeforces.com//contest/1095/problem/E", "problemId": "275105", "shortId": "1095E", "contest_number": "1095", "name": "E. Almost Regular Bracket Sequence", "statement": "You are given a bracket sequence  consisting of  opening '' and closing '' brackets.A  bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters '' and '' between the original characters of the sequence. For example, bracket sequences \"\", \"\" are regular (the resulting expressions are: \"\", \"\"), and \"\" and \"\" are not.You can change the type of some bracket . It means that if  '' then you can change it to '' and vice versa.Your task is to calculate the number of positions  such that if you change the type of the -th bracket, then the resulting bracket sequence becomes .", "input": "The first line of the input contains one integer  () \u2014 the length of the bracket sequence. The second line of the input contains the string  consisting of  opening '' and closing '' brackets.", "output": "Print one integer \u2014 the number of positions  such that if you change the type of the -th bracket, then the resulting bracket sequence becomes .", "tutorial": "In this problem we have to calculate the number () of positions such that if we change the type of the bracket at this position then the obtained bracket sequence will become regular.Let's calculate the balance of each prefix of the bracket sequence and store it in the array . Just iterate from left to right over the string and if the current bracket is opening then increase the current balance by one, otherwise decrease it by one.For each prefix let's also calculate whether it can be a prefix of a regular bracket sequence (RBS) and store it in the array . The prefix of length  can be the prefix of RBS if and only if the prefix of length  can be the prefix of RBS and .Let's calculate the same arrays for all suffixes (and call they  and  correspondingly), but now the closing bracket will increase the balance by one and the opening will decrease it by one and we consider the characters from right to left.Now if we have these arrays, let's iterate over all positions in the initial bracket sequence. If we now at the position  then let's do the following things: firstly, if  or  then skip this position. Otherwise if the current bracket is opening then we have to increase the answer if  and  (only in this case the bracket sequence will become regular). And if the current bracket is closing then we have to increase the answer if .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\t\n\tstring rs(s.rbegin(), s.rend());\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rs[i] == '(') {\n\t\t\trs[i] = ')';\n\t\t} else {\n\t\t\trs[i] = '(';\n\t\t}\n\t}\n\t\n\tvector<int> pref(n + 1), suf(n + 1);\n\tvector<bool> okp(n + 1), oks(n + 1);\n\tokp[0] = oks[n] = true;\n\tfor (int i = 0; i < n; ++i) {\n\t\tpref[i + 1] = pref[i] + (s[i] == '(' ? +1 : -1);\n\t\tokp[i + 1] = okp[i] & (pref[i + 1] >= 0);\n\t\tsuf[n - i - 1] = suf[n - i] + (rs[i] == '(' ? +1 : -1);\n\t\toks[n - i - 1] = oks[n - i] & (suf[n - i - 1] >= 0);\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!okp[i] || !oks[i + 1]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == '(') {\n\t\t\tif (pref[i] > 0 && pref[i] - 1 - suf[i + 1] == 0) {\n\t\t\t\t++ans;\n\t\t\t}\n\t\t} else {\n\t\t\tif (pref[i] + 1 - suf[i + 1] == 0) {\n\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}