{"link": "https://codeforces.com//contest/1374/problem/F", "problemId": "659590", "shortId": "1374F", "contest_number": "1374", "name": "F. Cyclic Shifts Sorting", "statement": "You are given an array  consisting of  integers.In one move, you can choose some index  () and shift the segment  cyclically to the right (i.e. replace the segment  with ). Your task is to sort the initial array by  or say that it is impossible to do that.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the length of . The second line of the test case contains  integers  (), where  is the -th element . It is guaranteed that the sum of  does not exceed .", "output": "For each test case, print the answer:  on the only line if it is impossible to sort the given array using operations described in the problem statement, or the number of operations  on the first line and  integers  (), where  is the index of left border of the segment for the -th operation. You should print indices .", "tutorial": "Firstly, let's solve the easier version of the problem. Assume we are given a permutation, not an array. Notice that the given operation applied to some segment of the permutation cannot change the parity of number of inversions (the number of inversions is the number of such pairs of indices  that  and ). So if the number of inversions in the given permutation is odd then we can't sort this permutation (we can't obtain zero inversions).But if the number of inversions is even then we can always sort the permutation with the following greedy algorithm: let's find the minimum element and move it to the first position. If its position is  then we can apply the operation to the segment  and our element will move by two positions to the left. So, after all, our element is either at the first or at the second position. If it's at the second position, let's just apply two additional operations to the segment . Then let's just cut off the first element and solve the problem without it. At the end we have only two numbers that can be not sorted and we can check all three possibilities and choose one which is suitable for us (it's always exists because the number of inversions is even).How do we solve the problem if we are given the array, not the permutation? First of all, we can prove that if the array contains at least two equal elements, we can always sort it (we will prove it by construction). Let's just renumerate the elements of the given array in a way to obtian the permutation with the even number of inversions. Thus, if  then let's find such a permutation  that . We can find this permutation easily if we sort the array of pairs  in increasing order. But there can be one problem: this permutation can have odd number of inversions. Then we need to find two consecutive pairs with the same first values and swap these two elements in the permutation. Because in fact these two numbers are equal in the array and have consecutive values in the permutation, we guaranteed change the parity of number of inversions. Then we can apply our algorithm for permutations and solve the problem for the array. If we failed then the answer is . Otherwise the number of operations always does not exceed  (because this sort works like a bubble sort) so our answer is suitable.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tauto make = [](vector<int> &a, int pos) {\n\t\tswap(a[pos + 1], a[pos + 2]);\n\t\tswap(a[pos], a[pos + 1]);\n\t};\n\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tvector<pair<int, int>> res(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> a[i];\n\t\t\tres[i] = { a[i], i };\n\t\t}\n\t\tsort(res.begin(), res.end());\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ta[res[i].second] = i;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\tcnt += a[j] < a[i];\n\t\t\t}\n\t\t}\n\t\tif (cnt & 1) {\n\t\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\t\tif (res[i].first == res[i + 1].first) {\n\t\t\t\t\tswap(a[res[i].second], a[res[i + 1].second]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> ans;\n\t\tfor (int i = 0; i < n - 2; ++i) {\n\t\t\tint pos = min_element(a.begin() + i, a.end()) - a.begin();\n\t\t\twhile (pos > i + 1) {\n\t\t\t\tmake(a, pos - 2);\n\t\t\t\tans.push_back(pos - 2);\n\t\t\t\tpos -= 2;\n\t\t\t}\n\t\t\tif (pos != i) {\n\t\t\t\tmake(a, i);\n\t\t\t\tmake(a, i);\n\t\t\t\tans.push_back(i);\n\t\t\t\tans.push_back(i);\n\t\t\t\tpos = i;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tif (is_sorted(a.begin(), a.end())) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmake(a, n - 3);\n\t\t\tans.push_back(n - 3);\n\t\t}\n\t\tif (!is_sorted(a.begin(), a.end())) {\n\t\t\tcout << -1 << endl;\n\t\t} else {\n\t\t\tcout << ans.size() << endl;\n\t\t\tfor (auto it : ans) cout << it + 1 << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}