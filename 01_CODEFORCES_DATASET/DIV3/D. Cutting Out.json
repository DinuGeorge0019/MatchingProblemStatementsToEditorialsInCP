{"link": "https://codeforces.com//contest/1077/problem/D", "problemId": "256063", "shortId": "1077D", "contest_number": "1077", "name": "D. Cutting Out", "statement": "You are given an array  consisting of  integers.You have to find  array  of length  such that you can cut out maximum number of copies of array  from array .Cutting out the copy of  means that for each element  of array  you have to find  in  and remove it from . If for some  you cannot find such element in , then you cannot cut out one more copy of . The both arrays can contain duplicate elements.For example, if  and  then one of the possible answers is . This array  can be cut out  times.   To cut out the first copy of  you can use the elements  (use the highlighted elements). After cutting out the first copy of  the array  can look like .  To cut out the second copy of  you can use the elements . After cutting out the second copy of  the array  will be . Your task is to find such array  that you can cut out the copy of  from  maximum number of times. If there are multiple answers, you may choose  of them.", "input": "The first line of the input contains two integers  and  () \u2014 the number of elements in  and the desired number of elements in , respectively. The second line of the input contains exactly  integers  ().", "output": "Print  integers \u2014 the elements of array  such that you can cut out maximum possible number of copies of this array from . If there are multiple answers, print  of them. The required array  can contain duplicate elements. All the elements of  () should satisfy the following condition: .", "tutorial": "Let's solve the problem using binary search by the answer. It is easy to see that if we can construct the answer for some number of copies  then we also can do it for . The only thing we need is to write the function  which will say can we cut off  copies of some array  from  or not.Let's imagine  copies of string  as a matrix of size . Obviously, each row of this matrix should be equal to each other row. Let's fill not rows but columns of this matrix. For some element  of  we can easy notice that we can take exactly  columns containing this element where  is the number of such elements in . So, overall number of columns we can fill in this matrix will be . If this value is greater than or equal to  then  is true otherwise it is false.It is easy to construct the answer using all things we described above.Overall complexity is  where  is the size of the alphabet.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 200 * 1000 + 1;\n\nint n, k;\nvector<int> s, t;\nvector<int> cnts(MAX);\n\nbool can(int cnt) {\n\tt.clear();\n\tfor (int i = 0; i < MAX; ++i) {\n\t\tint need = min(cnts[i] / cnt, k - int(t.size()));\n\t\tfor (int j = 0; j < need; ++j) {\n\t\t\tt.push_back(i);\n\t\t}\n\t}\n\treturn int(t.size()) == k;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> k;\n\ts = vector<int>(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> s[i];\n\t}\n\tfor (auto c : s) {\n\t\t++cnts[c];\n\t}\n\t\n\tint l = 0, r = n;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (can(mid)) {\n\t\t\tl = mid;\n\t\t} else {\n\t\t\tr = mid;\n\t\t}\n\t}\n\tif (!can(r)) can(l);\n\tfor (auto it : t) cout << it << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}