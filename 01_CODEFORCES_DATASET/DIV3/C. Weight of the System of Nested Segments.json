{"link": "https://codeforces.com//contest/1650/problem/C", "problemId": "1321162", "shortId": "1650C", "contest_number": "1650", "name": "C. Weight of the System of Nested Segments", "statement": "On the number line there are  points, -th of which has integer coordinate  and integer weight . The coordinates of all points are different, and the points are numbered from  to .A sequence of  segments  is called  if for each pair  () the condition  is satisfied. In other words, the second segment is strictly inside the first one, the third segment is strictly inside the second one, and so on.For a given number , find a system of nested segments such that:  both ends of each segment are one of  given points;  the sum of the weights  of the points used as ends of the segments is . For example, let . The given points are marked in the picture, their weights are marked in red, their coordinates are marked in blue. Make a system of three nested segments:  weight of the first segment:   weight of the second segment:   weight of the third segment:   sum of the weights of all the segments in the system:       ", "input": "The first line of input data contains an integer  ()\u00a0\u2014the number of input test cases. An empty line is written before each test case. The first line of each test case contains two positive integers  () and  ().  The next  lines contain pairs of integers  () and  () \u2014 coordinate and weight of point number  () respectively. All  are different. It is guaranteed that the sum of  values over all test cases does not exceed .", "output": "For each test case, output  lines: in the first of them, output the weight of the composed system, and in the next  lines output exactly two numbers \u00a0\u2014 the indices of the points which are the endpoints of the -th segment (). The order in which you output the endpoints of a segment is not important \u2014 you can output the index of the left endpoint first and then the number of the right endpoint, or the other way around. If there are several ways to make a system of nested segments with minimal weight, output any of them.", "tutorial": "We create a structure that stores for each point its coordinate, weight, and index in the input data. Sort the  array by increasing weight. The sum of weights of the first  points will be minimal, so we use them to construct a system of  nested segments. We save the weights of the first  points in the variable  and remove the remaining  points from the array. Now sort the points in ascending order of coordinates and form a system of nested segments such that the endpoints of th segment are  and  for . Thus, the endpoints of the first segment are  and , the endpoints of the th segment are  and .For each test case we first output , then \u2014  pairs of numbers ,  () \u2014 the indices under which the endpoints of the current segment were written in the input data.", "solution": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nstruct point{\n    int weight, position, id;\n};\n\nvoid solve(){\n    int n, m;\n    cin >> n >> m;\n    vector<point>points(m);\n\n    forn(i, m) {\n        cin >>  points[i].position >> points[i].weight;\n        points[i].id = i + 1;\n    }\n\n    sort(points.begin(), points.end(), [] (point a, point b){\n        return a.weight < b.weight;\n    });\n\n    int sum = 0;\n    forn(i, m){\n        if(i < 2 * n) sum += points[i].weight;\n        else points.pop_back();\n    }\n\n    sort(points.begin(), points.end(), [] (point a, point b){\n        return a.position < b.position;\n    });\n\n    cout << sum << endl;\n    forn(i, n){\n        cout << points[i].id << ' ' << points[2 * n - i - 1].id << endl;\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while(t--){\n        solve();\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}