{"link": "https://codeforces.com//contest/1714/problem/G", "problemId": "1490433", "shortId": "1714G", "contest_number": "1714", "name": "G. Path Prefixes", "statement": "You are given a rooted tree. It contains  vertices, which are numbered from  to . The root is the vertex .Each edge has two positive integer values. Thus, two positive integers  and  are given for each edge.Output  numbers , where  is defined as follows.Consider the path from the root (vertex ) to  (). Let the sum of the costs of  along this path be . Then  is equal to the length of the maximum prefix of this path such that the sum of  along this prefix does not exceed .     Consider an example. In this case:  , since the path to  has an amount of  equal to , only the prefix of this path of length  has a smaller or equal amount of ; , since the path to  has an amount of  equal to , the prefix of length  of this path has a sum of  equal to  ( the number is ); , since the path to  has an amount of  equal to , the prefix of length  of this path has an amount of  equal to  (this is the longest suitable prefix, since the prefix of length  already has an amount of  equal to , which is more than ); , since the path to  has an amount of  equal to , the prefix of length  of this path has a sum of  equal to  (this is the longest suitable prefix, since the prefix of length  already has an amount of  equal to , what is more than ); , since the path up to  has an amount of  equal to , the prefix of length  of this path has an amount of  equal to ; , since the path to  has an amount of  equal to , the prefix of length  of this path has an amount of  equal to  (this is the longest suitable prefix, since the prefix of length  already has an amount of  equal to , which is more than ); , since the path up to  has an amount of  equal to , the prefix of length  of this path has an amount of  equal to ; , since the path to  has an amount of  equal to , the prefix of length  of this path has a sum of  equal to .", "input": "The first line contains an integer  () \u2014 the number of test cases in the test. The descriptions of test cases follow. Each description begins with a line that contains an integer  () \u2014 the number of vertices in the tree. This is followed by  string, each of which contains three numbers  (; ) \u2014 the ancestor of the vertex , the first and second values an edge that leads from  to . The value of  runs through all values from  to  inclusive. It is guaranteed that each set of input data has a correct hanged tree with a root at the vertex . It is guaranteed that the sum of  over all input test cases does not exceed .", "output": "For each test case, output  integer in one line: .", "tutorial": "Note that all  are positive, which means that the amount on the prefix only increases. This allows us to use binary search to find the answer for the vertex. It remains only to learn how to quickly find the sum of  on the path prefix. Let's run a depth-first search and store the prefix sums of the current path in stack: going to the vertex, add the sum to the end of the path and delete it when exiting.", "solution": "#pragma GCC optimize(\"O3\",\"unroll-loops\")\n#pragma GCC target(\"avx2\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\n\nconst int maxn=2e5+5;\nvector<int> ch[maxn];\nint a[maxn];\nint b[maxn];\nint ans[maxn];\nvector<int> vb;\nint curb=0;\nint cura=0;\n\nvoid dfs(int x){\n    curb+=b[x];\n    cura+=a[x];\n    vb.push_back(curb);\n    ans[x]=upper_bound(vb.begin(),vb.end(),cura)-vb.begin();\n    for(int v:ch[x]){\n        dfs(v);\n    }\n    curb-=b[x];\n    cura-=a[x];\n    vb.pop_back();\n}\nint32_t main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);cout.tie(0);\n    int t;\n    cin>>t;\n    while(t--){\n        int n;cin>>n;\n        for(int i=0;i<n;++i) ch[i].clear();\n        for(int i=1;i<n;++i){\n            int pr,a1,b1;\n            cin>>pr>>a1>>b1;\n            --pr;\n            ch[pr].push_back(i);\n            a[i]=a1;\n            b[i]=b1;\n        }\n        dfs(0);\n        for(int i=1;i<n;++i) cout<<ans[i]-1<<' ';\n        cout<<'\\n';\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}