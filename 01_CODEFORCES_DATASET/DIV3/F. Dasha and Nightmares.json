{"link": "https://codeforces.com//contest/1800/problem/F", "problemId": "1805849", "shortId": "1800F", "contest_number": "1800", "name": "F. Dasha and Nightmares", "statement": "Dasha, an excellent student, is studying at the best mathematical lyceum in the country. Recently, a mysterious stranger brought  words consisting of small latin letters  to the lyceum. Since that day, Dasha has been tormented by .Consider some pair of integers  ().  is a string for which it is true:  It is obtained by concatenation ;  Its length is ;  The number of different letters in it is  ;  The number of occurrences of each letter that is in the word is . For example, if  \"abcdefg\" and  \"ijklmnopqrstuvwxyz\", the pair  creates a .Dasha will stop having  if she counts their number. There are too many , so Dasha needs your help. Count the number of different . are called different if the corresponding pairs  are different. The pairs  and  are called different if   .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of words. The following  lines contain the words , consisting of small latin letters. It is guaranteed that the total length of words does not exceed .", "output": "Print a single integer\u00a0\u2014 the number of different .", "tutorial": "Observation : the product of odd numbers is odd, so the condition for the length of  is automatically completed.Denote by  the number of ones in binary representation of . Let's enumerate the letters of the Latin alphabet from  to .Observation : for each word, it is enough to know the set of letters included in it and the evenness of their numbers. There are only  letters in the alphabet, so it is convenient to store the word characteristic  as a pair of masks . The bit with the number  in  will be responsible for the availability of the letter  in . The bit with the number  in  will be responsible for the evenness of the number of letters  in .Observation : strings  creates  if and only if .Let's fix the number \u00a0\u2014 the index of the letter that will not be in . Let's throw out all the words with the letter , now we can look at the words in turn and look for a pair of them among those already considered. It is easy to see that the condition  follows from the condition  if one letter is banned.To count the number of pairs that include our word, we need to count the number of words with the characteristic . We can do this by bin-searching through a sorted array of  or using standard data structures. We got the solution for .", "solution": "#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx2,avx,fma,bmi2\")\n\n#include <bits/stdc++.h>\n#include <immintrin.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define endl '\\n'\n//#define int long long\n#define all(arr) arr.begin(), arr.end()\n#define multitest() int _gorilla_silverback; cin >> _gorilla_silverback; while (_gorilla_silverback --> 0)\n#define pikachu push_back\n#define ls(id) (id << 1 | 1)\n#define rs(id) ((id << 1) + 2)\n#define sqr(x) ((x) * (x))\n#define dlg(x) (31 - __builtin_clz(x))\n#define ulg(x) (32 - __builtin_clz(x))\n\ntypedef pair<int, int> ipair;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> treap;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MAXN = 200200;\nconst int L = 26;\n\nint n;\nstring srr[MAXN];\nint arr[MAXN], brr[MAXN], crr[MAXN];\n\nvoid build() {\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (char c: srr[i]) {\n\t\t\tarr[i] ^= (1 << (c - 'a'));\n\t\t\tbrr[i] |= (1 << (c - 'a'));\n\t\t}\n\t}\n}\n\nlong long calc(int c) {\n\tint k = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (brr[i] >> c & 1 ^ 1) crr[k++] = arr[i];\n\tsort(crr, crr + k);\n\tint mask = -1 & ((1 << L) - 1) ^ (1 << c);\n\tlong long ans = 0;\n\tfor (int i = 0; i < k; ++i) {\n\t\tauto itl = lower_bound(crr, crr + k, crr[i] ^ mask);\n\t\tauto itr = upper_bound(crr, crr + k, crr[i] ^ mask);\n\t\tans += itr - itl;\n\t}\n\treturn ans >> 1LL;\n}\n\nlong long solve() {\n\tlong long ans = 0;\n\tfor (int c = 0; c < L; ++c)\n\t\tans += calc(c);\n\treturn ans;\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> srr[i];\n\tbuild();\n\tcout << solve() << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}