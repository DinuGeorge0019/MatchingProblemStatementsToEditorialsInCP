{"link": "https://codeforces.com//contest/1108/problem/B", "problemId": "286768", "shortId": "1108B", "contest_number": "1108", "name": "B. Divisors of Two Integers", "statement": "Recently you have received two  integer numbers  and . You forgot them, but you remembered a  list containing all divisors of  (including  and ) and all divisors of  (including  and ). If  is a divisor of both numbers  and  at the same time, there are two occurrences of  in the list.For example, if  and  then the given list can be any permutation of the list . Some of the possible lists are: ,  or .Your problem is to restore suitable  integer numbers  and  that would yield the same list of divisors (possibly in different order).It is guaranteed that the answer exists, i.e. the given list of divisors corresponds to some  integers  and .", "input": "The first line contains one integer  () \u2014 the number of divisors of  and . The second line of the input contains  integers  (), where  is either divisor of  or divisor of . If a number is divisor of both numbers  and  then there are two copies of this number in the list.", "output": "Print two  integer numbers  and  \u2014 such numbers that merged list of their divisors is the permutation of the given list of integers. It is guaranteed that the answer exists.", "tutorial": "Let's take a look on the maximum element of the given array. Suddenly, this number is  (or , the order doesn't matter). Okay, what would we do if we know  and merged list of divisors of  and ? Let's remove all divisors of  and see what we got. The maximum element in the remaining array is . So, the problem is solved.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tmultiset<int> a;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\ta.insert(x);\n\t}\n\t\n\tint x = *prev(a.end());\n\tfor (int i = 1; i <= x; ++i) {\n\t\tif (x % i == 0) {\n\t\t\ta.erase(a.find(i));\n\t\t}\n\t}\n\t\n\tcout << x << \" \" << *prev(a.end()) << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}