{"link": "https://codeforces.com//contest/1593/problem/G", "problemId": "1142168", "shortId": "1593G", "contest_number": "1593", "name": "G. Changing Brackets", "statement": "A sequence of round and square brackets is given. You can change the sequence by performing the following operations:  change the direction of a bracket from opening to closing and vice versa without changing the form of the bracket: i.e. you can change '' to '' and '' to ''; you can change '' to '' and '' to ''. The operation costs  burles. change any  bracket to  bracket having the same direction: i.e. you can change '' to '' but  from '' to ''; similarly, you can change '' to '' but  from '' to ''. The operation costs  burle. The operations can be performed in any order any number of times.You are given a string  of the length  and  queries of the type \"\" where . For every substring , find the minimum cost to pay to make it a correct bracket sequence. It is guaranteed that the substring  has an even length.The queries must be processed independently, i.e. the changes made in the string for the answer to a question  don't affect the queries  (). In other words, for every query, the substring  is given from the initially given string .A correct bracket sequence is a sequence that can be built according the following rules:  an empty sequence is a correct bracket sequence;  if \"\" is a correct bracket sequence, the sequences \"\" and \"\" are correct bracket sequences.  if \"\" and \"\" are correct bracket sequences, the sequence \"\" (the concatenation of the sequences) is a correct bracket sequence. E.g. the sequences \"\", \"\", \"\" and \"\" are correct bracket sequences whereas \"\", \"\" and \"\" are not.", "input": "The first line contains one integer  () \u2014 the number of test cases. Then  test cases follow. For each test case, the first line contains a non-empty string  containing only round ('', '') and square ('', '') brackets. The length of the string doesn't exceed . The string contains at least  characters. The second line contains one integer  () \u2014 the number of queries. Then  lines follow, each of them contains two integers  and  ( where  is the length of ). It is guaranteed that the substring  has even length. It is guaranteed that the sum of the lengths of all strings given in all test cases doesn't exceed . The sum of all  given in all test cases doesn't exceed .", "output": "For each test case output in a separate line for each query one integer  () \u2014 the minimum cost to pay to make the given substring a correct bracket sequence.", "tutorial": "Consider a substring . Let's call square brackets located in odd positions in the substring  brackets, and square brackets located in even positions  brackets. Let  be the number of odd brackets,  be the number of even brackets,  be the number of all square brackets. Let's prove that the string  can be turned into a correct bracket sequence for  burles if and only if .Let's prove the necessary condition. Suppose the initial substring has been turned into a correct bracket sequence. Since we have paid  burles, there's no bracket which form has been changed. Therefore,  for the new sequence is the same as  for the initial sequence, the similar situation happens with .Let's say that two square brackets form a pair if the left one is an opening bracket and the right one is a closing bracket and the substring between them is a correct bracket sequence. A pair can be formed only by one odd bracket and one even bracket because between them is placed an even number of brackets (since it's a correct bracket sequence) so the difference between their indices is odd. In a correct bracket sequence, each square bracket has a pairwise bracket. Therefore, a correct bracket sequence contains  pairs of brackets so .Let's prove the sufficient condition. Suppose the initial substring contains equal numbers of odd and even brackets. Let's prove by induction that the substring may be turned into a correct bracket sequence for  burles.Suppose . So the initial substring contains only round brackets. Let's make the first  brackets opening and the other brackets closing. The resulting sequence is a correct bracket sequence whereas we haven't changed the form of any bracket so the cost is equal to .A correct bracket sequence has two important properties:  after deleting its substring being a correct bracket sequence, the resulting string is a correct bracket sequence;  after inserting at any place any correct bracket sequence, the resulting string is a correct bracket sequence. These properties can be applied to an incorrect bracket sequence, too: after deleting a substring being a correct bracket subsequence from an incorrect bracket sequence or inserting a correct bracket sequence into an incorrect one, the resulting sequence is an incorrect bracket sequence.Consider a substring  such that . Suppose we have proved before that each substring  having  decreased by  can be turned into a correct bracket sequence for  burles. Let's find two square brackets such that one of them is odd and another one is even and there are no square brackets between them. There's an even number of round brackets between them that can be turned into a correct bracket sequence for  burles. Let's make the left found bracket opening and the right one closing. Then the substring starting at the left found bracket and ending at the right found bracket is a correct bracket sequence. Let's remove it from . The resulting string contains  odd brackets and  even brackets so, by the assumption of induction, it can be turned into a correct bracket sequence for  burles. Let's do it and then insert the removed string into its place. Since we insert a correct bracket sequence into a correct bracket sequence, the resulting string is a correct bracket sequence.Actually, the operations of inserting and removing are not allowed, they have been used for clarity, the string can be turned into a correct bracket sequence without these operations as follows: let's turn the substring we have removed into a correct bracket sequence (as it was described above), then change the other brackets of the string the same way as it was done with the string that was the result after removing. The resulting string is a correct bracket sequence. Therefore, the illegal operations of inserting and removing are not necessary, all other operations cost  burles so the substring  can be turned into a correct bracket sequence for  burles.Therefore, to turn a substring into a correct bracket sequence, we need to get a sequence such that . Suppose, initiallly, . Let's pay  burles to replace  odd brackets with round brackets. If , let's replace  even brackets with round brackets. Anyway, we must pay  burles. We cannot pay less than this value because for a correct bracket sequence, . But there's no need to pay more than this value, because, if we turn the initial substring into a sequence with , we can turn it into a correct bracket sequence for free. Therfore, the answer for a given question is .Since we must answer the queries fast, let's use a concept of prefix sums. If the given string  contains  brackets, let's create arrays  and  with the length .  will contain the number of odd brackets on the prefix of the string  with the length ,  \u2014 the same value for even brackets. Let's initialize  and then iterate  from  to . Let's initialize  and . If the -th bracket is round, then the current values are correct. Otherwise, let's find out what bracket is it. If  is odd, the bracket is odd so we must increase  by . If  is even, the bracket is even so we must increase  by .To get the answer for a current  and , let's calculate  and .  is a number of odd brackets that belong to the prefix with the length  but not to the prefix with the length  so . Similarly, . The remaining thing is to output .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1'000'000;\n\nint psumOdd[MAX_N + 1];\nint psumEven[MAX_N + 1];\n\nvoid solve()\n{\n\tstring s;\n\tint q;\n\tcin >> s >> q;\n\tint n = s.length();\n\n\tpsumOdd[0] = psumEven[0] = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tpsumOdd[i + 1] = psumOdd[i];\n\t\tpsumEven[i + 1] = psumEven[i];\n\n\t\tif (s[i] == '[' || s[i] == ']')\n\t\t{\n\t\t\tif (i & 1)\n\t\t\t\tpsumOdd[i + 1]++;\n\t\t\telse\n\t\t\t\tpsumEven[i + 1]++;\n\t\t}\n\t}\n\n\twhile (q--)\n\t{\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tint odd = psumOdd[r] - psumOdd[l];\n\t\tint even = psumEven[r] - psumEven[l];\n\t\tcout << abs(odd - even) << '\\n';\n\t}\n}\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\twhile (t--)\n\t\tsolve();\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}