{"link": "https://codeforces.com//contest/1593/problem/F", "problemId": "1142167", "shortId": "1593F", "contest_number": "1593", "name": "F. Red-Black Number", "statement": "It is given a non-negative integer , the decimal representation of which contains  digits. You need to color  its digit in red or black, so that the number formed by the red digits is divisible by , and the number formed by the black digits is divisible by . digit must be colored in each of two colors. Consider, the count of digits colored in red is  and the count of digits colored in black is . Among all possible colorings of the given number , you need to output any such that the value of  is .Note that the number  and the numbers formed by digits of each color, .   The figure above shows an example of painting the number  of  digits for  and . The red digits form the number , which is divisible by , and the black ones \u2014 , which is divisible by . Note that the absolute value of the difference between the counts of red and black digits is , it is impossible to achieve a smaller value.", "input": "The first line contains one integer  () \u2014 the number of test cases. Then  test cases follow. Each test case consists of two lines. The first line contains three integers , ,  (, ). The second line contains a non-negative integer  containing exactly  digits and probably containing leading zeroes.", "output": "For each test case, output in a separate line:    if the desired coloring does not exist;  a string  of  characters, each of them is a letter '' or ''. If the -th digit of the number  is colored in red, then the -th character of the string  must be the letter '', otherwise the letter ''.  The number formed by digits colored red should divisible by . The number formed by digits colored black should divisible by . The value  should be minimal, where  is the count of red digits,  is the count of black digits. If there are many possible answers, print any of them.", "tutorial": "The number  is divisible by the number  if and only if  modulo .To solve this problem, let's use the concept of dynamic programming. There will be four states: the number of considered digits of the number , the number of such considered digits that we have colored red, the remainder from dividing the red number by  and the black one by . The value corresponding to the state will be described by three parameters: the possibility of a situation described by the states, the color of the last digit, and the parent state. Let's assume that the number that contains  digits is equal to .Initially, let's mark the state in which  digits are considered, of which  are red digits, and both remainders are equal to , as possible. Next, let's iterate over all states in the following order: first by the number of considered digits, then by the number of considered red digits, then by the remainder of the division by  and by . From the current state, if it is possible (i.e. the corresponding mark is set), you can make two transitions to new states. At the first transition, we paint the last digit in red, at the second one in black. We need also to store the current state in the new states as the previous one.A solution exists if and only if some state in which exactly  digits are considered, of which at least  and at most  red digits, and the remainders are equal to , is marked as possible. Let's find such a state. Using the stored information about the color of the last digit and the previous state, we can restore the colors of all digits of the number .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 64;\n\nbool dp[MAX_N][MAX_N][MAX_N][MAX_N]; // (taken, red, mod A, mod B) -> may be\npair<bool, int> sert[MAX_N][MAX_N][MAX_N][MAX_N]; // the same -> (true (red) | false(black), prev red/black)\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\n\twhile (t--)\n\t{\n\t\tint n, a, b;\n\t\tstring x;\n\t\tcin >> n >> a >> b >> x;\n\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\tfor (int k = 0; k < a; k++)\n\t\t\t\t\tfor (int l = 0; l < b; l++)\n\t\t\t\t\t\tdp[i][j][k][l] = false;\n\n\t\tdp[0][0][0][0] = true;\n\n\t\tfor(int taken = 0; taken < n; taken++)\n\t\t\tfor(int red = 0; red <= taken; red++)\n\t\t\t\tfor(int remA = 0; remA < a; remA++)\n\t\t\t\t\tfor(int remB = 0; remB < b; remB++)\n\t\t\t\t\t\tif (dp[taken][red][remA][remB])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// red transition\n\t\t\t\t\t\t\tdp[taken + 1][red + 1][(remA * 10 + (x[taken] - '0')) % a][remB] = true;\n\t\t\t\t\t\t\tsert[taken + 1][red + 1][(remA * 10 + (x[taken] - '0')) % a][remB] = { true, remA };\n\n\t\t\t\t\t\t\t// black transition\n\t\t\t\t\t\t\tdp[taken + 1][red][remA][(remB * 10 + (x[taken] - '0')) % b] = true;\n\t\t\t\t\t\t\tsert[taken + 1][red][remA][(remB * 10 + (x[taken] - '0')) % b] = { false, remB };\n\t\t\t\t\t\t}\n\n\t\tint bestRed = 0;\n\n\t\tfor (int red = 1; red < n; red++)\n\t\t\tif (dp[n][red][0][0] && abs(red - (n - red)) < abs(bestRed - (n - bestRed)))\n\t\t\t\tbestRed = red;\n\n\t\tif (bestRed == 0)\n\t\t{\n\t\t\tcout << \"-1\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint taken = n;\n\t\t\tint red = bestRed;\n\t\t\tint remA = 0;\n\t\t\tint remB = 0;\n\t\t\tstring ans = \"\";\n\t\t\t\n\t\t\twhile (taken > 0)\n\t\t\t{\n\t\t\t\tauto way = sert[taken][red][remA][remB];\n\t\t\t\tif (way.first)\n\t\t\t\t{\n\t\t\t\t\tred--;\n\t\t\t\t\tremA = way.second;\n\t\t\t\t\tans.push_back('R');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tremB = way.second;\n\t\t\t\t\tans.push_back('B');\n\t\t\t\t}\n\t\t\t\ttaken--;\n\t\t\t}\n\n\t\t\treverse(ans.begin(), ans.end());\n\t\t\tcout << ans << '\\n';\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}