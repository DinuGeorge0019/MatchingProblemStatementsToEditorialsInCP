{"link": "https://codeforces.com//contest/1328/problem/D", "problemId": "573970", "shortId": "1328D", "contest_number": "1328", "name": "D. Carousel", "statement": "The round carousel consists of  figures of animals. Figures are numbered from  to  in order of the carousel moving. Thus, after the -th figure the figure with the number  follows. Each figure has its own type \u2014 the type of the animal corresponding to this figure (the horse, the tiger and so on). The type of animal of the -th figure equals .    . You want to color each figure in one of the colors. You think that it's boring if the carousel contains two different figures (with the distinct types of animals) going one right after another and colored in the same color.Your task is to color the figures in such a way that the number of distinct colors used is the minimum possible and there are no figures of the different types going one right after another and colored in the same color. If you use exactly  distinct colors, then the colors of figures should be denoted with integers from  to .", "input": "The input contains one or more test cases. The first line contains one integer  () \u2014 the number of test cases in the test. Then  test cases follow. One test case is given on two lines. The first line of the test case contains one integer  () \u2014 the number of figures in the carousel. Figures are numbered from  to  in order of carousel moving. Assume that after the -th figure the figure  goes. The second line of the test case contains  integers  (), where  is the type of the animal of the -th figure. The sum of  over all test cases does not exceed .", "output": "Print  answers, for each test case print two lines. In the first line print one integer  \u2014 the minimum possible number of distinct colors of figures. In the second line print  integers  (), where  is the color of the -th figure. If there are several answers, you can print any.", "tutorial": "The answer to this problem is at most . Let's prove it by construction.Firstly, if all  are equal then the answer is . Otherwise, there are at least two different values in the array  so the answer is at least . If  is even then the answer is always  because you can color figures in the following way: . If  is odd then consider two cases. The first case is when some pair of adjacent figures have the same type. Then the answer is  because you can merge these two values into one and get the case of even . Otherwise, all pairs of adjacent figures have different types and if you consider this cyclic array as a graph (cycle of length ) then you can notice that it isn't bipartite so you need at least  colors to achieve the answer (color all vertices in such a way that any two adjacent vertices have different colors). And the answer looks like .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint solve() {\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tif (count(a.begin(), a.end(), a[0]) == n) {\n\t\tcout << 1 << endl;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcout << 1 << \" \";\n\t\t}\n\t\tcout << endl;\n\t\treturn 0;\n\t}\n\t\n\tif (n % 2 == 0) {\n\t\tcout << 2 << endl;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcout << i % 2 + 1 << \" \";\n\t\t}\n\t\tcout << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (a[i] == a[(i + 1) % n]) {\n\t\t\tvector<int> ans(n);\n\t\t\tfor (int j = 0, pos = i + 1; pos < n; ++pos, j ^= 1) {\n\t\t\t\tans[pos] = j + 1;\n\t\t\t}\n\t\t\tfor (int j = 0, pos = i; pos >= 0; --pos, j ^= 1) {\n\t\t\t\tans[pos] = j + 1;\n\t\t\t}\n\t\t\tcout << 2 << endl;\n\t\t\tfor (int pos = 0; pos < n; ++pos) {\n\t\t\t\tcout << ans[pos] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tcout << 3 << endl;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcout << i % 2 + 1 << \" \";\n\t}\n\tcout << 3 << endl;\n    return 0;    \n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\nint q;\ncin >> q;\nfor (int qq = 0; qq < q; qq++) {\n    solve();\n}\n\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}