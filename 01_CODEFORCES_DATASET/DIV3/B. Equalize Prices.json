{"link": "https://codeforces.com//contest/1183/problem/B", "problemId": "363542", "shortId": "1183B", "contest_number": "1183", "name": "B. Equalize Prices", "statement": "There are  products in the shop. The price of the -th product is . The owner of the shop wants to equalize the prices of all products. However, he wants to change prices smoothly.In fact, the owner of the shop can change the price of some product  in such a way that the difference between the old price of this product  and the new price  is at most . In other words, the condition  should be satisfied ( is the absolute value of ).He can change the price for each product . Note that he can leave the old prices for some products. The new price  of each product  should be positive (i.e.  should be satisfied for all  from  to ).Your task is to find out the  possible  price  of  productts with the restriction that for all products the condiion  should be satisfied (where  is the old price of the product and  is the same new price of all products) or report that it is impossible to find such price ..You should answer  independent queries.", "input": "The first line of the input contains one integer  () \u2014 the number of queries. Each query is presented by two lines. The first line of the query contains two integers  and  () \u2014 the number of products and the value . The second line of the query contains  integers  (), where  is the price of the -th product.", "output": "Print  integers, where the -th integer is the answer  on the -th query. If it is impossible to equalize prices of  given products with restriction that for all products the condition  should be satisfied (where  is the old price of the product and  is the new equal price of all products), print . Otherwise print the  possible equal price of  products.", "tutorial": "It is very intuitive that the maximum price we can obtain is  where  is the minimum value in the array. For this price we should check that we can change prices of all products to it. It can be done very easily: we can just check if each segment  covers the point . But this is not necessary because if we can change the price of the maximum to this value () then we can change each price in the segment  to this value. So we just need to check that  and if it is then print  otherwise print .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tvector<int> a(n);\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tcin >> a[j];\n\t\t}\n\t\tint mn = *min_element(a.begin(), a.end());\n\t\tint mx = *max_element(a.begin(), a.end());\n\t\tif (mx - mn > 2 * k) cout << -1 << endl;\n\t\telse cout << mn + k << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}