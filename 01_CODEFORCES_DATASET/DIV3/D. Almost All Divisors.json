{"link": "https://codeforces.com//contest/1165/problem/D", "problemId": "344205", "shortId": "1165D", "contest_number": "1165", "name": "D. Almost All Divisors", "statement": "We guessed some integer number . You are given a list of  its divisors.  means that there are  in the list.Your task is to find the minimum possible integer  that can be the guessed number, or say that the input data is contradictory and it is impossible to find such number.You have to answer  independent queries.", "input": "The first line of the input contains one integer  () \u2014 the number of queries. Then  queries follow. The first line of the query contains one integer  () \u2014 the number of divisors in the list. The second line of the query contains  integers  (), where  is the -th divisor of the guessed number. It is guaranteed that all values  are .", "output": "For each query print the answer to it. If the input data in the query is contradictory and it is impossible to find such number  that the given list of divisors is the list of  its divisors, print . Otherwise print the minimum possible .", "tutorial": "Suppose the given list of divisors is a list of  divisors of some  (in other words, suppose that the answer exists). Then the minimum divisor multiplied by maximum divisor should be . This is true because if we have a divisor  we also have a divisor . Let's sort all divisors and let .Now we need to check if all divisors of  except  and  are the permutation of the array  (check that our answer is really correct). We can find all divisors of  in , sort them and compare with the array . If arrays are equal then the answer is  otherwise the answer is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint t;\n\tcin >> t;\n\tfor (int i = 0; i < t; ++i) {\n\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<long long> d(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> d[i];\n\t\t}\n\t\tsort(d.begin(), d.end());\n\t\tlong long x = d[0] * d[n - 1];\n\t\t\n\t\tvector<long long> dd;\n\t\tfor (int i = 2; i * 1ll * i <= x; ++i) {\n\t\t\tif (x % i == 0) {\n\t\t\t\tdd.push_back(i);\n\t\t\t\tif (i != x / i) {\n\t\t\t\t\tdd.push_back(x / i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(dd.begin(), dd.end());\n\t\t\n\t\tif (dd == d) {\n\t\t\tcout << x << endl;\n\t\t} else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}