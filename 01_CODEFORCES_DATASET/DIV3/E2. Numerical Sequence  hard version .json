{"link": "https://codeforces.com//contest/1216/problem/E2", "problemId": "416605", "shortId": "1216E2", "contest_number": "1216", "name": "E2. Numerical Sequence  hard version ", "statement": ".You are given an  sequence of form \"\" which consist of blocks of all consecutive positive integers written one after another. The first block consists of all numbers from  to , the second one \u2014 from  to , the third one \u2014 from  to , , the -th block consists of all numbers from  to . So the first  elements of the sequence are \"\". Elements of the sequence are numbered from one. For example, the -st element of the sequence is , the -rd element of the sequence is , the -th element of the sequence is , the -th element is , the -th element of the sequence is .Your task is to answer  independent queries. In the -th query you are given one integer . Calculate the digit at the position  of the sequence.", "input": "The first line of the input contains one integer  () \u2014 the number of queries. The -th of the following  lines contains one integer   \u2014 the description of the corresponding query.", "output": "Print  lines. In the -th line print one digit   \u2014 the answer to the query , i.e.  should be equal to the element at the position  of the sequence.", "tutorial": "This problem idea is not very hard. Now  can be up to  so we need to find the number of block  faster. Let's do binary search on it! Now using some  pretty formulas we can determine if the total sum of lengths of blocks from  to  is greater than or equal to  or not.And more about these formulas: let's iterate over all possible length of numbers from  to  and carry the sum of lengths  of numbers with length less than the current length . We know that the number of numbers (he-he) of length  is exactly  ( for ). Let's add  to the total sum of lengths and increase  by .What does  means? This formula means that we have exactly  blocks ending with numbers of length  and we need to add sum of lengths of all numbers with length less than  exactly  times. And what does  means? It is the sum sums of lengths of all numbers of length  (i.e. previously we added sum of lengths of numbers with length less than  and now we add sum of sums of lengths of numbers with length ).When we found the number of block , let's decrease  by the total length of all blocks from  to  and continue solving the problem. This part was pretty hard to understand. And the easiest part: when we determined the number of block  we can easily determine the number  from  to  such that our answer lies in the number . Let's iterate over all lengths from  to  (here we go again) and for the current length  let  ( for ). And now all we need is to increase the sum of lengths by .After determining  decrease  by sum of lengths of numbers from  to  and print .Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long get(long long r) {\n\treturn (r + 1) * r / 2;\n}\n\nlong long sumto(long long r, int need) {\n\tlong long pw = 1;\n\tlong long sum = 0;\n\tlong long add = 0;\n\tfor (int len = 1; ; ++len) {\n\t\tif (pw * 10 - 1 < r) {\n\t\t\tlong long cnt = pw * 10 - pw;\n\t\t\tif (need) {\n\t\t\t\tsum += add * cnt + get(cnt) * len;\n\t\t\t\tadd += cnt * len;\n\t\t\t} else {\n\t\t\t\tsum += cnt * len;\n\t\t\t}\n\t\t} else {\n\t\t\tlong long cnt = r - pw + 1;\n\t\t\tif (need) {\n\t\t\t\tsum += add * cnt + get(cnt) * len;\n\t\t\t} else {\n\t\t\t\tsum += cnt * len;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tpw *= 10;\n\t}\n\treturn sum;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tlong long k;\n\t\tcin >> k;\n\t\t--k;\n\t\t\n\t\tlong long l = 1\t, r = 1e9;\n\t\tlong long res = -1;\n\t\twhile (r - l >= 0) {\n\t\t\tlong long mid = (l + r) >> 1;\n\t\t\tif (sumto(mid, 1) > k) {\n\t\t\t\tres = mid;\n\t\t\t\tr = mid - 1;\n\t\t\t} else {\n\t\t\t\tl = mid + 1;\n\t\t\t}\n\t\t}\n\t\tk -= sumto(res - 1, 1);\n\t\t\n\t\tl = 1, r = res;\n\t\tlong long num = -1;\n\t\twhile (r - l >= 0) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (sumto(mid, 0) > k) {\n\t\t\t\tnum = mid;\n\t\t\t\tr = mid - 1;\n\t\t\t} else {\n\t\t\t\tl = mid + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << to_string(num)[k - sumto(num - 1, 0)] << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}