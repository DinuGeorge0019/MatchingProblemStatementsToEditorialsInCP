{"link": "https://codeforces.com//contest/1092/problem/D2", "problemId": "271423", "shortId": "1092D2", "contest_number": "1092", "name": "D2. Great Vova Wall  Version 2 ", "statement": "Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.The current state of the wall can be respresented by a sequence  of  integers, with  being the height of the -th part of the wall.Vova can only use  bricks to put in the wall (he has infinite supply of them, however).Vova can put bricks  on the neighbouring parts of the wall of equal height. It means that if for some  the current height of part  is the same as for part , then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part  of the wall or to the right of part  of it).Vova is a perfectionist, so he considers the wall completed when:  all parts of the wall has the same height;  the wall has no empty spaces inside it. Can Vova complete the wall using any amount of bricks (possibly zero)?", "input": "The first line contains a single integer  () \u2014 the number of parts in the wall. The second line contains  integers  () \u2014 the initial heights of the parts of the wall.", "output": "Print \"\" if Vova can complete the wall using any amount of bricks (possibly zero). Print \"\" otherwise.", "tutorial": "Fairly enough, solutions of both versions of the problem are pretty similar.Read the second part of the previous tutorial first.This problem can also be implemented in the strightforward manner. The greedy solution now is searching for the first minimum in array and putting a brick in there. If it's impossible then the answer is \"\". This can also be simulated with sets, a bit more tedious but still ok and also .Now back to the stack approach. Here you can't go to parities of the numbers (like tests  and  lead to different results). You push the number itself. However, you will also need an extra condition on the stack. You can't push to it the number greater than the current topmost element. The only problem with this are maximums of array. Obviously, the resulting wall (if the answer exists) will be of height equal to the maximum initial height. And it means that you shouldn't care about the ability to match all maximums in stack. They way I suggest to take around the issue is to process separately each segment between two consecutive maximums.One can easily prove the correctness of it by construction.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 1000 * 1000 + 13;\n\nint n;\nint a[N];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n) scanf(\"%d\", &a[i]);\n\tvector<int> st;\n\t\n\tint mx = *max_element(a, a + n);\n\t\n\tforn(i, n){\n\t\tif (a[i] == mx) continue;\n\t\t\n\t\tint j = i - 1;\n\t\twhile (j + 1 < n && a[j + 1] != mx){\n\t\t\t++j;\n\t\t\tif (!st.empty() && st.back() == a[j]){\n\t\t\t\tst.pop_back();\n\t\t\t}\n\t\t\telse if (st.empty() || st.back() > a[j]){\n\t\t\t\tst.push_back(a[j]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!st.empty()){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\ti = j;\n\t}\n\t\n\tputs(\"YES\");\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}