{"link": "https://codeforces.com//contest/1702/problem/G2", "problemId": "1456433", "shortId": "1702G2", "contest_number": "1702", "name": "G2. Passable Paths  hard version ", "statement": "Polycarp grew a tree from  vertices. We remind you that a tree of  vertices is an undirected connected graph of  vertices and  edges that does not contain cycles.He calls a set of vertices  if there is such a path in the tree that passes through each vertex of this set without passing through any edge twice. The path can visit other vertices (not from this set).In other words, a set of vertices is called  if there is a simple path that passes through all the vertices of this set (and possibly some other).For example, for a tree below sets , ,  are , and ,  are not.  Polycarp asks you to answer  queries. Each query is a set of vertices. For each query, you need to determine whether the corresponding set of vertices is .", "input": "The first line of input contains a single integer  () \u2014 number of vertices. Following  lines a description of the tree.. Each line contains two integers  and  (, ) \u2014 indices of vertices connected by an edge. Following line contains single integer  ()\u00a0\u2014 number of queries. The following  lines contain descriptions of sets. The first line of the description contains an integer  () \u2014 the size of the set. The second line of the description contains  of distinct integers  () \u2014 indices of the vertices of the set. It is guaranteed that the sum of  values for all queries does not exceed .", "output": "Output  lines, each of which contains the answer to the corresponding query. As an answer, output \"\" if the set is , and \"\" otherwise. You can output the answer in any case (for example, the strings \"\", \"\", \"\" and \"\" will be recognized as a positive answer).", "tutorial": "Recall that the path in the rooted tree\u00a0\u2014 ascends from one end to the least common ancestor () of the ends and descends to the other end (possibly by 0). Then our set is divided into two simple ways.To check this, you only need to count .We will first calculate the depths, as for solving an easy version of the problem. We will go along the vertices according to the non-growth of the depths, if  of the deepest vertex and the current one is equal to the current one, then it is the ancestor of the deepest one, we will mark it. Next, we will find the deepest unmarked vertex and do the same, if there is no such vertex, then the whole path goes down and the answer is .If there are unmarked vertices, then there are vertices outside of those two ascents and the answer is . Now we need to check that the two ascents do not intersect or intersect only at the  of ends, for this we just make sure that  is not deeper than the shallowest vertex of the set.", "solution": "#include <bits/stdc++.h>\n\n#define int long long\n#define pb emplace_back\n#define mp make_pair\n#define x first\n#define y second\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n\ntypedef long double ld;\ntypedef long long ll;\n\nusing namespace std;\n\nmt19937 rnd(143);\n\nconst int inf = 1e15;\nconst int M = 1e9 + 7;\nconst ld pi = atan2(0, -1);\nconst ld eps = 1e-6;\n\nint n, sz;\nvector<vector<int>> sl, up;\nvector<int> d;\n\nvoid precalc(int v, int p){\n    d[v] = d[p] + 1;\n    up[v][0] = p;\n    for(int i = 1; i <= sz; ++i){\n        up[v][i] = up[up[v][i - 1]][i - 1];\n    }\n    for(int u: sl[v]){\n        if(u == p) continue;\n        precalc(u, v);\n    }\n}\n\nint lca(int u, int v){\n    if(d[u] < d[v]){\n        swap(u, v);\n    }\n    for(int cur = sz; cur >= 0; --cur){\n        if (d[u] - (1 << cur) >= d[v]) {\n            u = up[u][cur];\n        }\n    }\n    for(int cur = sz; cur >= 0; --cur){\n        if (up[u][cur] != up[v][cur]) {\n            u = up[u][cur];\n            v = up[v][cur];\n        }\n    }\n    return u == v ? u : up[u][0];\n}\n\nvoid solve(){\n    cin >> n;\n    sz = 0;\n    while ((1 << sz) < n) sz++;\n    d.assign(n, -1);\n    up.assign(n, vector<int>(sz + 1));\n    sl.assign(n, vector<int>(0));\n    for(int i = 1; i < n; ++i){\n        int u, v;\n        cin >> u >> v;\n        sl[--u].push_back(--v);\n        sl[v].push_back(u);\n    }\n    precalc(0, 0);\n    int q;\n    cin >> q;\n    for(; q; --q){\n        int k;\n        cin >> k;\n        vector<int> p(k);\n        for(int &e: p) {\n            cin >> e;\n            --e;\n        }\n        sort(all(p), [](int a, int b) {\n            return d[a] > d[b];\n        });\n        vector<bool> used(k);\n        for(int i = 0; i < k; ++i){\n            if(lca(p[0], p[i]) == p[i]) used[i] = true;\n        }\n        int f = 0;\n        while (f < k && used[f]) f++;\n        if(f == k){\n            cout << \"YES\\n\";\n            continue;\n        }\n        bool ans = true;\n        for(int i = f; i < k; ++i){\n            if(lca(p[f], p[i]) == p[i]) used[i] = true;\n        }\n        for(bool e: used){\n            ans &= e;\n        }\n        ans &= d[lca(p[0], p[f])] <= d[p.back()];\n        if(ans) cout << \"YES\\n\";\n        else cout << \"NO\\n\";\n    }\n}\n\nbool multi = false;\n\nsigned main() {\n    int t = 1;\n    if (multi)cin >> t;\n    for (; t; --t) {\n        solve();\n        //cout << endl;\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}