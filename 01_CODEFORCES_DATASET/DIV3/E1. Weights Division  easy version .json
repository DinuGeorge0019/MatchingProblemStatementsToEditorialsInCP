{"link": "https://codeforces.com//contest/1399/problem/E1", "problemId": "691720", "shortId": "1399E1", "contest_number": "1399", "name": "E1. Weights Division  easy version ", "statement": ".You are given a weighted rooted tree, vertex  is the root of this tree.A tree is a connected graph without cycles. A rooted tree has a special vertex called the root. A parent of a vertex  is the last different from  vertex on the path from the root to the vertex . Children of vertex  are all vertices for which  is the parent. A vertex is a leaf if it has no children. The weighted tree is such a tree that each edge of this tree has some weight.The weight of the path is the sum of edges weights on this path. The weight of the path from the vertex to itself is .You can make a sequence of zero or more moves. On each move, you select an edge and divide its weight by  rounding down. More formally, during one move, you choose some edge  and divide its weight by  rounding down ().Your task is to find the minimum number of  required to make the  from the root to each leaf at most . In other words, if  is the weight of the path from the vertex  to the vertex , then you have to make , where  is the list of all leaves.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains two integers  and  () \u2014 the number of vertices in the tree and the maximum possible sum of weights you have to obtain. The next  lines describe edges of the tree. The edge  is described as three integers ,  and  (), where  and  are vertices the edge  connects and  is the weight of this edge. It is guaranteed that the sum of  does not exceed  ().", "output": "For each test case, print the answer: the minimum number of  required to make the sum of weights of paths from the root to each leaf at most .", "tutorial": "Let's define  as the number of leaves in the subtree of the -th edge (of course, in terms of vertices, in the subtree of the lower vertex of this edge). Values of  can be calculated with pretty standard and simple dfs and dynamic programming.Then we can notice that our edges are independent and we can consider the initial answer (sum of weights of paths) as . Let  be the difference between the current impact of the -th edge and the impact of the -th edge if we divide its weight by . . This value means how the sum of weights decreases if we divide the weight of the -th edge by .Create ordered set which contains pairs . Then the following greedy solution works: let's take the edge with maximum  and divide its weight by . Then re-add it into the set with new value . When the sum becomes less than or equal to , just stop and print the number of divisions we made.The maximum number of operations can reach  so the solution complexity is  (each operation takes  time because the size of the set is ).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> w, cnt;\nvector<vector<pair<int, int>>> g;\n\nlong long getdiff(int i) {\n\treturn w[i] * 1ll * cnt[i] - (w[i] / 2) * 1ll * cnt[i];\n}\n\nvoid dfs(int v, int p = -1) {\n\tif (g[v].size() == 1) cnt[p] = 1;\n\tfor (auto [to, id] : g[v]) {\n\t\tif (id == p) continue;\n\t\tdfs(to, id);\n\t\tif (p != -1) cnt[p] += cnt[id];\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tlong long s;\n\t\tcin >> n >> s;\n\t\tw = cnt = vector<int>(n - 1);\n\t\tg = vector<vector<pair<int, int>>>(n);\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y >> w[i];\n\t\t\t--x, --y;\n\t\t\tg[x].push_back({y, i});\n\t\t\tg[y].push_back({x, i});\n\t\t}\n\t\tdfs(0);\n\t\tset<pair<long long, int>> st;\n\t\tlong long cur = 0;\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tst.insert({getdiff(i), i});\n\t\t\tcur += w[i] * 1ll * cnt[i];\n\t\t}\n\t\tcerr << cur << endl;\n\t\tint ans = 0;\n\t\twhile (cur > s) {\n\t\t\tint id = st.rbegin()->second;\n\t\t\tst.erase(prev(st.end()));\n\t\t\tcur -= getdiff(id);\n\t\t\tw[id] /= 2;\n\t\t\tst.insert({getdiff(id), id});\n\t\t\t++ans;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}