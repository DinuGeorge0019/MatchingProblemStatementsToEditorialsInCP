{"link": "https://codeforces.com//contest/1006/problem/E", "problemId": "198029", "shortId": "1006E", "contest_number": "1006", "name": "E. Military Problem", "statement": "In this problem you will have to help Berland army with organizing their command delivery system.There are  officers in Berland army. The first officer is the commander of the army, and he does not have any superiors. Every other officer has exactly one direct superior. If officer  is the direct superior of officer , then we also can say that officer  is a direct subordinate of officer .Officer  is considered to be a subordinate (direct or indirect) of officer  if one of the following conditions holds:  officer  is the direct superior of officer ;  the direct superior of officer  is a subordinate of officer . For example, on the picture below the subordinates of the officer  are: .The structure of Berland army is organized in such a way that every officer, except for the commander, is a subordinate of the commander of the army.Formally, let's represent Berland army as a tree consisting of  vertices, in which vertex  corresponds to officer . The parent of vertex  corresponds to the direct superior of officer . The root (which has index ) corresponds to the commander of the army.Berland War Ministry has ordered you to give answers on  queries, the -th query is given as , where  is some officer, and  is a positive integer.To process the -th query imagine how a command from  spreads to the subordinates of . Typical DFS (depth first search) algorithm is used here.Suppose the current officer is  and he spreads a command. Officer  chooses  \u2014 one of his direct subordinates (i.e. a child in the tree) who has not received this command yet. If there are many such direct subordinates, then  chooses the one having minimal index. Officer  gives a command to officer . Afterwards,  uses exactly the same algorithm to spread the command to its subtree. After  finishes spreading the command, officer  chooses the next direct subordinate again (using the same strategy). When officer  cannot choose any direct subordinate who still hasn't received this command, officer  finishes spreading the command.Let's look at the following example:  If officer  spreads a command, officers receive it in the following order: .If officer  spreads a command, officers receive it in the following order: .If officer  spreads a command, officers receive it in the following order: .If officer  spreads a command, officers receive it in the following order: .To answer the -th query , construct a sequence which describes the order in which officers will receive the command if the -th officer spreads it. Return the -th element of the constructed list or  if there are fewer than  elements in it.You should process queries independently. A query doesn't affect the following queries.", "input": "The first line of the input contains two integers  and  () \u2014 the number of officers in Berland army and the number of queries. The second line of the input contains  integers  (), where  is the index of the direct superior of the officer having the index . The commander has index  and doesn't have any superiors. The next  lines describe the queries. The -th query is given as a pair () (), where  is the index of the officer which starts spreading a command, and  is the index of the required officer in the command spreading sequence.", "output": "Print  numbers, where the -th number is the officer at the position  in the list which describes the order in which officers will receive the command if it starts spreading from officer . Print \"\" if the number of officers which receive the command is less than . You should process queries independently. They do not affect each other.", "tutorial": "Let's form the following vector : we run DFS from the first vertex and push the vertex  to the vector when entering this vertex. Let  be the position of the vertex  in the vector  (the size of the vector  in moment we call DFS from the vertex ) and  be the position of the first vertex pushed to the vector after leaving the vertex  (the size of the vector  in moment when we return from DFS from the vertex ). Then it is obvious that the subtree of the vertex  lies in half-interval .After running such DFS we can answer the queries. Let  (answering the -th query). If  is greater than or equal to  then answer to the -th query is \"\".We need to check if the vertex  lies in the subtree of the vertex . The vertex  is in the subtree of the vertex  if and only if .If the vertex  is not in the subtree of the vertex  then answer is \"\". Otherwise the answer is .Overall complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, q;\nvector<vector<int>> tree;\n\nint current_preorder;\nvector<int> preorder, max_preorder;\nvector<int> sorted_by_preorder;\n\nvoid Dfs(int w) {\n  sorted_by_preorder[current_preorder] = w;\n  preorder[w] = current_preorder++;\n  for (int c : tree[w]) {\n    Dfs(c);\n  }\n  max_preorder[w] = current_preorder - 1;\n}\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> q;\n  assert(2 <= n);\n  assert(1 <= q);\n  tree.resize(n);\n  for (int i = 1; i < n; i++) {\n    int p;\n    cin >> p;\n    p--;\n    assert(0 <= p and p < n);\n    tree[p].push_back(i);\n  }\n\n  preorder.resize(n);\n  max_preorder.resize(n);\n  sorted_by_preorder.resize(n);\n  current_preorder = 0;\n  Dfs(0);\n\n  for (int i = 0; i < q; i++) {\n    int u, k;\n    cin >> u >> k;\n    u--; k--;\n    assert(0 <= u and u < n);\n    assert(0 <= k and k < n);\n    k += preorder[u];\n    int answer = -1;\n    if (k <= max_preorder[u]) {\n      answer = sorted_by_preorder[k] + 1;\n      assert(1 <= answer and answer <= n);\n    }\n    cout << answer << '\\n';\n  }\n  return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}