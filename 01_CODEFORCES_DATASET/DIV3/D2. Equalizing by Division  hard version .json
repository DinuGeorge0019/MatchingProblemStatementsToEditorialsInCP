{"link": "https://codeforces.com//contest/1213/problem/D2", "problemId": "399403", "shortId": "1213D2", "contest_number": "1213", "name": "D2. Equalizing by Division  hard version ", "statement": ".You are given an array  consisting of  integers. In one move you can choose any  and divide it by  rounding down (in other words, in one move you can set ).You can perform such an operation  (possibly, zero) number of times with  .Your task is to calculate the minimum possible number of operations required to obtain at least  equal numbers in the array..", "input": "The first line of the input contains two integers  and  () \u2014 the number of elements in the array and the number of equal numbers required. The second line of the input contains  integers  (), where  is the -th element of .", "output": "Print one integer \u2014 the minimum possible number of operations required to obtain at least  equal numbers in the array.", "tutorial": "In this problem we need to write almost the same solution as in the previous one (easy version) but faster. Observe that we calculate the value of  too many times. Let  for all  from  to  be the array of numbers of divisions we need to obtain  from every possible  from which we can. We can calculate these arrays in time . How? Let's iterate over all  and divide it by  while it is positive (and carry the number of divisions ). Then let's add to the array  the number  before each division.Then we can see that we obtain the array  from the tutorial of the previous problem for each  from  to . Let's iterate over all possible values of  and try to update the answer with the sum of  smallest values of  if there is at least  elements in this array.Time complexity:  or , depends on sorting method.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tvector<vector<int>> vals(200 * 1000 + 11);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x = a[i];\n\t\tint cur = 0;\n\t\twhile (x > 0) {\n\t\t\tvals[x].push_back(cur);\n\t\t\tx /= 2;\n\t\t\t++cur;\n\t\t}\n\t}\n\t\n\tint ans = 1e9;\n\tfor (int i = 0; i <= 200 * 1000; ++i) {\n\t\tsort(vals[i].begin(), vals[i].end());\n\t\tif (int(vals[i].size()) < k) continue;\n\t\tans = min(ans, accumulate(vals[i].begin(), vals[i].begin() + k, 0));\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}