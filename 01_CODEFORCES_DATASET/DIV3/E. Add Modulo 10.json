{"link": "https://codeforces.com//contest/1714/problem/E", "problemId": "1490431", "shortId": "1714E", "contest_number": "1714", "name": "E. Add Modulo 10", "statement": "You are given an array of  integers You can apply the following operation an arbitrary number of times:   select an index  () and replace the value of the element  with the value , where  is the remainder of the integer dividing  by . For a single index (value ), this operation can be applied multiple times. If the operation is applied repeatedly to the same index, then the current value of  is taken into account each time. For example, if  then after the first operation we get , and after the second operation we get .Check if it is possible to make  array elements equal by applying multiple (possibly zero) operations.For example, you have an array .   Let's apply this operation to the first element of the array. Let's replace  with . We get the array .  Then apply this operation to the second element of the array. Let's replace  with . We get the array . Thus, by applying  operations, you can make all elements of an array equal.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. What follows is a description of each test case. The first line of each test case contains one integer  ()\u00a0\u2014 the size of the array. The second line of each test case contains  integers  ()\u00a0\u2014 array elements. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case print:    if it is possible to make all array elements equal;   otherwise.  You can print  and  in any case (for example, the strings , ,  and  will be recognized as a positive answer) .", "tutorial": "Let's see which remainders modulo  change into which ones.If the array contains a number divisible by , then it cannot be changed. If there is a number that has a remainder of  modulo , then it can only be replaced once.Thus, if the array contains a number divisible by , then we apply this operation to all elements of the array once and check that all its elements are equal.The remaining odd balances () immediately turn into even ones. The even remainders () change in a cycle, while the array element increases by  in  operations. Thus, we will apply the operation to each element of the array until its remainder modulo  becomes, for example, , and then check that the array does not contain both remainders  and  modulo .", "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nint next(int x) {\n    return x + x % 10;\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    bool flag = false;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n        if (a[i] % 5 == 0) {\n            flag = true;\n            a[i] = next(a[i]);\n        }\n    }\n    if (flag) {\n        cout << (*min_element(a.begin(), a.end()) == *max_element(a.begin(), a.end()) ? \"Yes\": \"No\") << '\\n';\n    } else {\n        bool flag2 = false, flag12 = false;\n        for (int i = 0; i < n; ++i) {\n            int x = a[i];\n            while (x % 10 != 2) {\n                x = next(x);\n            }\n            if (x % 20 == 2) {\n                flag2 = true;\n            } else {\n                flag12 = true;\n            }\n        }\n        cout << ((flag2 & flag12) ? \"No\" : \"Yes\") << '\\n';\n    }\n}\n\nint main() {\n    int t = 1;\n    cin >> t;\n    for (int it = 0; it < t; ++it) {\n        solve();\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}