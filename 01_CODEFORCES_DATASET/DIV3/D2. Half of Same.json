{"link": "https://codeforces.com//contest/1593/problem/D2", "problemId": "1142165", "shortId": "1593D2", "contest_number": "1593", "name": "D2. Half of Same", "statement": "Polycarp has an array of  ( is even) integers . Polycarp conceived of a positive integer . After that, Polycarp began performing the following operations on the array: take an index  () and reduce the number  by .After Polycarp performed some (possibly zero) number of such operations, it turned out that  of the numbers in the array became the same. Find the maximum  at which such a situation is possible, or print  if such a number can be arbitrarily large.", "input": "The first line contains one integer  () \u2014 the number of test cases. Then  test cases follow. Each test case consists of two lines. The first line contains an even integer  () ( is even). The second line contains  integers  (). It is guaranteed that the sum of all  specified in the given test cases does not exceed .", "output": "For each test case output on a separate line an integer  () \u2014 the maximum possible number that Polycarp used in operations on the array, or , if such a number can be arbitrarily large.", "tutorial": " can be arbitrarily large if and only if at least half of the numbers in the array are the same. In this case, we can choose any number  and subtract it from all numbers, for example, exactly once.Let's iterate over the element , it will be the minimum among the numbers that we want to make the same. Let's calculate the number of numbers in the array that are equal to this element. If this number is at least , then the answer is . Otherwise, we will iterate over numbers  which are strictly greater than the selected minimum, and, for each number, we will iterate over the divisors of the number . For each of the found divisors, let's calculate the number of  for which this divisor was found. Among all such divisors for which the sum of the found number and the number of numbers equal to  is greater than or equal to , we will choose the maximum one. The greatest found divisor will be the desired . This solution works in  (where  is the absolute value of the maximum on the array).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nset<int> divs(int n) {  \n    set<int> d;\n    for (int dd = 1; dd * dd <= n; dd++)\n        if (n % dd == 0) {\n            d.insert(n / dd);\n            d.insert(dd);\n        }\n    return d;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    forn(tt, t) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        forn(i, n)\n            cin >> a[i];\n        int k = -1;\n\n        forn(i, n) {\n            int minv = a[i];\n            int same = 0;\n            vector<int> d;\n            forn(j, n) {\n                if (a[j] == minv)\n                    same++;\n                else if (a[j] > minv)\n                    d.push_back(a[j] - minv);\n            }\n            if (same >= n / 2) {\n                k = INT_MAX;\n                continue;\n            }\n            map<int,int> div_counts;\n            for (int di: d)\n                for (int dd: divs(di))\n                    div_counts[dd]++;\n            for (auto p: div_counts)\n                if (p.second >= n / 2 - same)\n                    k = max(k, p.first);\n        }\n\n        cout << (k == INT_MAX ? -1 : k) << endl;\n    }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}