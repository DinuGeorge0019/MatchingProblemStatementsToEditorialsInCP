{"link": "https://codeforces.com//contest/1141/problem/E", "problemId": "316174", "shortId": "1141E", "contest_number": "1141", "name": "E. Superhero Battle", "statement": "A superhero fights with a monster. The battle consists of rounds, each of which lasts exactly  minutes. After a round ends, the next round starts immediately. This is repeated over and over again.Each round has the same scenario. It is described by a sequence of  numbers:  (). The -th element means that monster's hp (hit points) changes by the value  during the -th minute of each round. Formally, if before the -th minute of a round the monster's hp is , then after the -th minute it changes to .The monster's initial hp is . It means that before the battle the monster has  hit points. Print the first minute after which the monster dies. The monster dies if its hp is less than or equal to . Print  if the battle continues infinitely.", "input": "The first line contains two integers  and  (, ). The second line contains the sequence of integers  (), where  is the value to change monster's hp in the -th minute of a round.", "output": "Print  if the superhero can't kill the monster and the battle will last infinitely. Otherwise, print the positive integer  such that  is the first minute after which the monster is dead.", "tutorial": "In general the answer looks like: some number of complete (full) round cycles plus some prefix the the round.Check corner case that there are no complete (full) rounds at all (just check the first round in naive way). If no solution found, the answer has at least one complete (full) cycle and some prefix.If total sum in one round is not negative, then a complete (full) cycle doesn't help and it is again the no solution case.Let's find number of complete (full) cycles. We need such number of cycles  that if your multiple  by total sum and add some prefix, the result (with negative sign, because it is not a damage) will be greater or equal than . So, to find  just add with  the minimal prefix partial sum and divide the result by minus total sum. Now you know the number of complete (full) cycles, just iterate over the last round in naive way to find the answer.\n", "solution": "long long H;\nint n;\ncin >> H >> n;\nvector<long long> a(n);\nlong long sum = 0;\nlong long gap = 0;\nlong long h = H;\nfor (int i = 0; i < n; i++) {\n    cin >> a[i];\n    sum -= a[i];\n    h += a[i];\n    if (h <= 0) {\n        cout << i + 1 << endl;\n        return 0;\n    }\n    gap = max(gap, sum);\n}\nif (sum <= 0) {\n    cout << -1 << endl;\n    return 0;\n}\n\nlong long whole = (H - gap) / sum;\nH -= whole * sum;\nlong long result = whole * n;\n\nfor (int i = 0;; i++) {\n    H += a[i % n];\n    result++;\n    if (H <= 0) {\n        cout << result << endl;\n        break;\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}