{"link": "https://codeforces.com//contest/1729/problem/C", "problemId": "1538784", "shortId": "1729C", "contest_number": "1729", "name": "C. Jumping on Tiles", "statement": "Polycarp was given a row of tiles. Each tile contains one lowercase letter of the Latin alphabet. The entire sequence of tiles forms the string .In other words, you are given a string  consisting of lowercase Latin letters.Initially, Polycarp is on the  tile of the row and wants to get to the  tile by jumping on the tiles. Jumping from -th tile to -th tile has a cost equal to , where  is the index of the letter  in the alphabet (for example, '', '', ..., '') .Polycarp wants to get to the -th tile for the minimum total cost, but at the same time make  number of jumps.In other words, among all possible ways to get to the last tile for the  total cost, he will choose the one with the  number of jumps.Polycarp can visit each tile .Polycarp asks you to help\u00a0\u2014 print the sequence of indices of string  on which he should jump.", "input": "The first line of the input contains an integer  () \u2014 the number of test cases in the test. Each test case is given by the string  (), where \u00a0\u2014 is the length of string . The string  consists of lowercase Latin letters. It is guaranteed that the sum of string lengths  over all test cases does not exceed .", "output": "The answer to each test case consists of two lines. In the first line print two integers , , where  is the minimum total cost of the path, and  is the maximum number of visited tiles Polycarp can make to get to -th tiles for the minimum total cost  (i.e. the number of jumps is ). In the next line print  different numbers  ()\u00a0\u2014 the sequence of indices of the tiles Polycarp will jump on. The first number in the sequence must be  (that is, ) and the last number must be the value of  (that is, ). If there are multiple answers, print any of them.", "tutorial": "It's worth knowing that ways like ('' -> '') and ('' -> '' -> '') have the same cost. That is, first you need to understand the letter on the first tile and the last one (conditionally, the letters  and ).Then you just need to find all such tiles on which the letters are between the letters  and  inclusive.We go through each letter from  to  and for each letter we visit every tile that has a given letter (but we must not forget to start exactly at tile  and end at tile ).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nvoid solve() {\n\n    string s;\n    cin >> s;\n\n    int n = s.size();\n    map<char, vector<int>> let_to_ind;\n\n    for (int i = 0; i < n; ++i) {\n        let_to_ind[s[i]].push_back(i);\n    }\n\n    int direction = (s[0] < s[n - 1]) ? 1 : -1;\n    vector<int> ans;\n\n    for (char c = s[0]; c != s[n - 1] + direction; c += direction) {\n        for (auto now : let_to_ind[c]) {\n            ans.push_back(now);\n        }\n    }\n\n    int cost = 0;\n    for (int i = 1; i < ans.size(); i++)\n        cost += abs(s[ans[i]] - s[ans[i - 1]]);\n\n    cout << cost << \" \" << ans.size() << '\\n';\n    for (auto now : ans) {\n        cout << now + 1 << \" \";\n    }\n    cout << '\\n';\n}\nint main() {\n    int tests;\n    cin >> tests;\n    forn(tt, tests) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}