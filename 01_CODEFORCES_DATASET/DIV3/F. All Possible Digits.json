{"link": "https://codeforces.com//contest/1759/problem/F", "problemId": "1648494", "shortId": "1759F", "contest_number": "1759", "name": "F. All Possible Digits", "statement": "A positive number  of length  in base  () is written on the blackboard. The number  is given as a sequence  () \u2014 the digits of  in order from left to right (most significant to least significant).Dmitry is very fond of all the digits of this number system, so he wants to see each of them at least once.In one operation, he can:   take any number  written on the board, increase it by , and write the new value  on the board. For example,  and .  Initially, the board contains the digits ,  and ;  Dmitry increases the number  by  and writes down the number . On the board there are digits ;  Dmitry increases the number  by  and writes down the number . Now the board contains all the digits from  to . Your task is to determine the minimum number of operations required to make all the digits from  to  appear on the board at least once.", "input": "The first line of the input contains a single integer  ()\u00a0\u2014 the number of test cases. The descriptions of the input test cases follow. The first line of description of each test case contains two integers  () and  () \u2014 the length of the number and the base of the number system. The second line of the description of each test case contains  integers  () \u2014 digits of  in number system with base  It is guaranteed that the number  does not contain leading zeros (that is, ).", "output": "For each test case print a single integer \u2014 the minimum number of operations required for Dmitry to get all the digits on the board from  to . It can be shown that this always requires a finite number of operations.", "tutorial": "If all digits from  to  are initially present in the number, then the answer is .Each time we will increase the number by . If the last digit is less than , then only it will change. Otherwise, all digits equal to  at the end will become equal to , and the previous one will increase by  (or a new digit equal to  will be added if all digits were equal to ).For a  operation, the last digit will run through all possible values. However, we can get all the numbers earlier. We will solve the problem using binary search, sorting through the number of operations.We can have 2 options: whether  was at the end or not. Depending on this, one or two subsegments of the segment  \u2014 a subsegment in the middle or a prefix and a suffix remained uncovered by the last digit of the number. They need to be completely covered with numbers that were already in positions, except for the last one \u2014 these are the original numbers and, in case there was  at the end, the number into which the transfer was made. There are at most  of them.", "solution": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tree<pair<int, int>, null_type, less<>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nint newDigit = -1;\n\nbool check(set<int> digits, int l, int r, bool useNewDigit) {\n    for (int i = l; i <= r; ++i) {\n        if (useNewDigit && i == newDigit) {\n            continue;\n        }\n        if (!digits.count(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid solve() {\n    int n, p;\n    cin >> n >> p;\n    vector<int> a(n + 1);\n    set<int> digits;\n    for (int i = 1; i <= n; ++i) {\n        cin >> a[i];\n        digits.insert(a[i]);\n    }\n    if (digits.size() == p) {\n        cout << \"0\\n\";\n        return;\n    }\n    for (int i = n - 1; i >= 0; --i) {\n        if (a[i] < p - 1) {\n            newDigit = a[i] + 1;\n            break;\n        }\n    }\n    int l = 0, r = p - 1;\n    int x = a[n];\n    while (l < r) {\n        int m = (l + r) >> 1;\n        bool res = false;\n        if (x + m >= p) {\n            if (check(digits, x + m + 1 - p, x - 1, true)) {\n                res = true;\n            }\n        } else {\n            if (check(digits, 0, x - 1, false) && check(digits, x + m + 1, p - 1, false)) {\n                res = true;\n            }\n        }\n        if (res) {\n            r = m;\n        } else {\n            l = m + 1;\n        }\n    }\n    cout << l << '\\n';\n}\n\nbool multitest = true;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(25);\n    size_t number_of_tests = 1;\n    if (multitest) {\n        cin >> number_of_tests;\n    }\n    for (size_t _ = 0; _ < number_of_tests; ++_) {\n        solve();\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}