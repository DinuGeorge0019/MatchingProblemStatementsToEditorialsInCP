{"link": "https://codeforces.com//contest/1066/problem/C", "problemId": "235861", "shortId": "1066C", "contest_number": "1066", "name": "C. Books Queries", "statement": "You have got a shelf and want to put some books on it.You are given  queries of three types:    \u2014 put a book having index  on the shelf to the left from the leftmost existing book;    \u2014 put a book having index  on the shelf to the right from the rightmost existing book;    \u2014 calculate the minimum number of books you need to pop from the left or from the right in such a way that the book with index  will be leftmost or rightmost. You can assume that the first book you will put can have any position (it does not matter) and queries of type  are always valid (it is guaranteed that the book in each such query is already placed). You can also assume that you don't put the same book on the shelf twice, so s don't repeat in queries of first two types.Your problem is to answer all the queries of type  in order they appear in the input.Note that after answering the query of type  all the books remain on the shelf and the relative order of books does not change.", "input": "The first line of the input contains one integer  () \u2014 the number of queries. Then  lines follow. The -th line contains the -th query in format as in the problem statement. It is guaranteed that queries are always valid (for query type , it is guaranteed that the book in each such query is already placed, and for other types, it is guaranteed that the book was not placed before). It is guaranteed that there is at least one query of type  in the input. In each query the constraint  is met.", "output": "Print answers to queries of the type  in order they appear in the input.", "tutorial": "Let imagine our shelf as an infinite array. Let's carry the rightmost free position from the left of our shelf (let it be  and initially it equals to ) and the leftmost free position from the right of our shelf (let it be  and initially it equals to ). Also let's carry the array  of length  where  will be equal to the position in our imaginary array of the book with a number .Let's put the first book to the position . Also let's save that  (where  is the number of the first book) equals to . How will change  and ?  will become  and  will become . Now let's process queries one by one. If now we have the query of type  with a book with a number , then let's set  and set . The query of type  can be processed similarly. Now what about queries of type ? The answer to this query equals to , where  is the absolute value of .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\t\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\t\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}