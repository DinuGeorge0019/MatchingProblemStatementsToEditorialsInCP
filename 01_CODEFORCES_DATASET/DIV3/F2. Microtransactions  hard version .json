{"link": "https://codeforces.com//contest/1165/problem/F2", "problemId": "344207", "shortId": "1165F2", "contest_number": "1165", "name": "F2. Microtransactions  hard version ", "statement": ".Ivan plays a computer game that contains some microtransactions to make characters look cooler. Since Ivan wants his character to be really cool, he wants to use some of these microtransactions \u2014 and he won't start playing until he gets all of them.Each day (during the ) Ivan earns exactly one burle.There are  types of microtransactions in the game. Each microtransaction costs  burles usually and  burle if it is on sale. Ivan has to order exactly  microtransactions of the -th type (he orders microtransactions during the ).Ivan can order  (possibly zero) number of microtransactions of  types during any day (of course, ). If the microtransaction he wants to order is on sale then he can buy it for  burle and otherwise he can buy it for  burles.There are also  special offers in the game shop. The -th offer  means that microtransactions of the -th type are on sale during the -th day.Ivan wants to order all microtransactions as soon as possible. Your task is to calculate the minimum day when he can buy all microtransactions he want and actually start playing.", "input": "The first line of the input contains two integers  and  () \u2014 the number of types of microtransactions and the number of special offers in the game shop. The second line of the input contains  integers  (), where  is the number of copies of microtransaction of the -th type Ivan has to order. It is guaranteed that . The next  lines contain special offers. The -th of these lines contains the -th special offer. It is given as a pair of integers  () and means that microtransactions of the -th type are on sale during the -th day.", "output": "Print one integer \u2014 the minimum day when Ivan can order all microtransactions he wants and actually start playing.", "tutorial": "The main idea of this problem is the same as in the easy version. The only thing we should replace is the search method. Replacing linear search with binary search leads to reducing time complexity from  to . And it is obvious that we can apply binary search here because if we can order all microtransactions during some day  then we can order all of them during day  (even using the answer for  days and doing nothing during day ).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nvector<int> k;\nvector<pair<int, int>> q(200001);\n\nbool can(int day) {\n\tvector<int> lst(n, -1);\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (q[i].first <= day) {\n\t\t\tlst[q[i].second] = max(lst[q[i].second], q[i].first);\n\t\t}\n\t}\n\tvector<vector<int>> off(200001);\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (lst[i] != -1) {\n\t\t\toff[lst[i]].push_back(i);\n\t\t}\n\t}\n\tvector<int> need = k;\n\tint cur_money = 0;\n\tfor (int i = 0; i <= day; ++i) {\n\t\t++cur_money;\n\t\tif (i > 200000) continue;\n\t\tfor (auto it : off[i]) {\n\t\t\tif (cur_money >= need[it]) {\n\t\t\t\tcur_money -= need[it];\n\t\t\t\tneed[it] = 0;\n\t\t\t} else {\n\t\t\t\tneed[it] -= cur_money;\n\t\t\t\tcur_money = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn accumulate(need.begin(), need.end(), 0) * 2 <= cur_money;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m;\n\tk = vector<int>(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> k[i];\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> q[i].first >> q[i].second;\n\t\t--q[i].first;\n\t\t--q[i].second;\n\t}\n\t\n\tint l = 0, r = 400000;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (can(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tfor (int i = l; i <= r; ++i) {\n\t\tif (can(i)) {\n\t\t\tcout << i + 1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tassert(false);\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}