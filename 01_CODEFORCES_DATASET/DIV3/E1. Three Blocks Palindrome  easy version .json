{"link": "https://codeforces.com//contest/1335/problem/E1", "problemId": "592975", "shortId": "1335E1", "contest_number": "1335", "name": "E1. Three Blocks Palindrome  easy version ", "statement": ".You are given a sequence  consisting of  positive integers.Let's define a  as the sequence, consisting of  distinct elements (let these elements are  and ,  can be equal ) and is as follows: . There  are integers greater than or equal to . For example, sequences , , , ,  and  are  but ,  and  are not.Your task is to choose the maximum by length  of  that is a .You have to answer  independent test cases.Recall that the sequence  is a a subsequence of the sequence  if  can be derived from  by removing zero or more elements without changing the order of the remaining elements. For example, if , then possible subsequences are: ,  and , but not  and .", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the length of . The second line of the test case contains  integers  (), where  is the -th element of . . It is guaranteed that the sum of  over all test cases does not exceed  ().", "output": "For each test case, print the answer \u2014 the maximum possible length of some subsequence of  that is a .", "tutorial": "Let's precalculate for each number  (-indexed) the array  of length , where  is the number of occurrences of the number  on the prefix of length . This can be done with easy dynamic programming (just compute prefix sums). Also let  be  and it's meaning is the number of occurrences of the number  on the segment  (-indexed).Firstly, let's update the answer with  (we can always take all occurrences of the same element as the answer). Then let's iterate over all possible segments of the array. Let the current segment be . Consider that all occurrences of the element in the middle block belong to . Then we can just take the most frequent number on this segment (). We also have to choose the number for the first and the last blocks. It is obvious that for the number  the maximum amount of such numbers we can take is . So . And we can update the answer with .Time complexity: , where  is the size of alphabet (the maximum value of ).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(a) int((a).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i < int(r); ++i)\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tvector<vector<int>> cnt(26, vector<int>(n + 1));\n\t\tforn(i, n) {\n\t\t\tforn(j, 26) cnt[j][i + 1] = cnt[j][i];\n\t\t\t++cnt[a[i] - 1][i + 1];\n\t\t}\n\t\tint ans = 0;\n\t\tforn(i, 26) ans = max(ans, cnt[i][n - 1]);\n\t\tforn(l, n) fore(r, l, n) {\n\t\t\tint cntin = 0, cntout = 0;\n\t\t\tforn(el, 26) {\n\t\t\t\tcntin = max(cntin, cnt[el][r + 1] - cnt[el][l]);\n\t\t\t\tcntout = max(cntout, min(cnt[el][l], cnt[el][n] - cnt[el][r + 1]) * 2);\n\t\t\t}\n\t\t\tans = max(ans, cntin + cntout);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}