{"link": "https://codeforces.com//contest/1213/problem/F", "problemId": "399405", "shortId": "1213F", "contest_number": "1213", "name": "F. Unstable String Sort", "statement": "Authors have come up with the string  consisting of  lowercase Latin letters.You are given two permutations of its indices (not necessary equal)  and  (both of length ). Recall that the permutation is the array of length  which contains each integer from  to  exactly once.For all  from  to  the following properties hold:  and . It means that if you will write down all characters of  in order of permutation indices, the resulting string will be sorted in the non-decreasing order.Your task is to restore  such string  of length  consisting of  which suits the given permutations.If there are multiple answers, you can print any of them.", "input": "The first line of the input contains two integers  and  () \u2014 the length of the string and the number of distinct characters required. The second line of the input contains  integers  (, all  are distinct integers from  to ) \u2014 the permutation . The third line of the input contains  integers  (, all  are distinct integers from  to ) \u2014 the permutation .", "output": "If it is impossible to find the suitable string, print \"\" on the first line. Otherwise print \"\" on the first line and string  on the second line. It should consist of  lowercase Latin letters, contain at least  distinct characters and suit the given permutations. If there are multiple answers, you can print any of them.", "tutorial": "Because if we write down all characters of  in order of both permutations and this string will be sorted, it is obvious that these two strings are equal. Let's try the maximum possible number of distinct characters and then replace extra characters with ''. How to find the maximum number of distinct characters?Let's iterate over all values of  (and ) in order from left to right. If we staying at the position  now, let's add to the set  the value  and to the set  the value . And when these sets become equal the first time, let's say that the block of positions  such that values  are in the set right now, have the same letter, and then clear both sets. We can see that this segment of positions is the minimum by inclusion set that can contain equal letters. We don't need to compare sets naively and clear them naively, you can see implementation details in author's solution.If the number of such segments is less than  then the answer is \"\", otherwise the answer is \"\" and we can fill the string  with letters in order of these segments (if the segment is  then all characters of  with indices  has the same letter, the first segment has the letter '', the second one has the letter '', and so on, all segments after -th has the letter '').Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> p1(n), p2(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> p1[i];\n\t\t--p1[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> p2[i];\n\t\t--p2[i];\n\t}\n\t\n\tset<int> vals1, vals2;\n\tvector<int> rb;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (vals2.count(p1[i])) {\n\t\t\tvals2.erase(p1[i]);\n\t\t} else {\n\t\t\tvals1.insert(p1[i]);\n\t\t}\n\t\tif (vals1.count(p2[i])) {\n\t\t\tvals1.erase(p2[i]);\n\t\t} else {\n\t\t\tvals2.insert(p2[i]);\n\t\t}\n\t\tif (vals1.empty() && vals2.empty()) {\n\t\t\trb.push_back(i);\n\t\t}\n\t}\n\t\n\tif (int(rb.size()) < k) {\n\t\tcout << \"NO\" << endl;\n\t} else {\n\t\tstring s(n, ' ');\n\t\tint l = 0;\n\t\tfor (int it = 0; it < int(rb.size()); ++it) {\n\t\t\tint r = rb[it];\n\t\t\tchar c = 'a' + min(it, 25);\n\t\t\tfor (int i = l; i <= r; ++i) {\n\t\t\t\ts[p1[i]] = c;\n\t\t\t}\n\t\t\tl = r + 1;\n\t\t}\n\t\tcout << \"YES\" << endl << s << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}