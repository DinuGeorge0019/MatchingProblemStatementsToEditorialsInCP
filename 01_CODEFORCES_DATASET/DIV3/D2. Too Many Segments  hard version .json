{"link": "https://codeforces.com//contest/1249/problem/D2", "problemId": "447563", "shortId": "1249D2", "contest_number": "1249", "name": "D2. Too Many Segments  hard version ", "statement": ".You are given  segments on the coordinate axis . Segments can intersect, lie inside each other and even coincide. The -th segment is  () and it covers all integer points  such that .The integer point is called  if it is covered by  than  segments.Your task is to remove the minimum number of segments so that there are no  points at all.", "input": "The first line of the input contains two integers  and  () \u2014 the number of segments and the maximum number of segments by which each integer point can be covered. The next  lines contain segments. The -th line contains two integers  and  () \u2014 the endpoints of the -th segment.", "output": "In the first line print one integer  () \u2014 the minimum number of segments you need to remove so that there are no  points. In the second line print   integers  () \u2014 indices of segments you remove in any order. If there are multiple answers, you can print any of them.", "tutorial": "In this problem, we need to implement the same greedy solution as in the easy version, but faster. Firstly, let's calculate for each point the number of segments covering it. We can do it using standard trick with prefix sums: increase , decrease  and build prefix sums on the array .Let's maintain the set of segments that cover the current point, sorted by the right endpoint. We can do this with almost the same trick: append to the array  the index  that says us that in the point  the -th segment is opened. And add to the  the index  that says us that in the point  the -th segment is closed. Note that you need to add -indexed values  because  and  are the same thing actually. We can change the array  to carry the number of segments covering each point using some structure, but we don't need to do it. Let's maintain the variable  that will say us the number of segments covering the current point that was already removed. Also, let's carry another one array  which will say us when we need to decrease the variable .So, we calculated the array of arrays , the array  and we can solve the problem now. For the point , let's remove and add all segments we need, using the array  and add  to . Now we know that the set of segments is valid,  is also valid and we can fix the current point if needed. While , let's repeat the following sequence of operations: take the segment with the maximum right border  from the set, remove it, increase  by one and decrease  by one.Note that when we remove segments from the set at the beginning of the sequence of moves for the point , we don't need to remove segments that we removed by fixing some previous points, and we need to pay attention to it.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200200;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<pair<int, int>> segs(n);\n\tvector<int> cnt(N);\n\tvector<vector<int>> ev(N);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> segs[i].first >> segs[i].second;\n\t\t++cnt[segs[i].first];\n\t\t--cnt[segs[i].second + 1];\n\t\tev[segs[i].first].push_back(i + 1);\n\t\tev[segs[i].second + 1].push_back(-i - 1);\n\t}\n\t\n\tfor (int i = 0; i + 1 < N; ++i) {\n\t\tcnt[i + 1] += cnt[i];\n\t}\n\t\n\tvector<int> ans(n), sub(N);\n\tset<pair<int, int>> curSegs;\n\tint curSub = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfor (int i = 0; i < N; ++i) {\n\t\tcurSub += sub[i];\n\t\tfor (auto it : ev[i]) {\n\t\t\tif (it > 0) {\n\t\t\t\tcurSegs.insert(make_pair(segs[it - 1].second, it - 1));\n\t\t\t} else {\n\t\t\t\tauto iter = curSegs.find(make_pair(segs[-it - 1].second, -it - 1));\n\t\t\t\tif (iter != curSegs.end()) curSegs.erase(iter);\n\t\t\t}\n\t\t}\n\t\twhile (cnt[i] - curSub > k) {\n\t\t\tassert(!curSegs.empty());\n\t\t\tint pos = curSegs.rbegin()->second;\n\t\t\tcurSegs.erase(prev(curSegs.end()));\n\t\t\t++curSub;\n\t\t\t--sub[segs[pos].second + 1];\n\t\t\tans[pos] = 1;\n\t\t}\n\t}\n\t\n\tcout << accumulate(ans.begin(), ans.end(), 0) << endl;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (ans[i]) cout << i + 1 << \" \";\n\t}\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}