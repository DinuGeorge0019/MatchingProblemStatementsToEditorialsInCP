{"link": "https://codeforces.com//contest/1343/problem/E", "problemId": "599892", "shortId": "1343E", "contest_number": "1343", "name": "E. Weights Distributing", "statement": "You are given an undirected unweighted graph consisting of  vertices and  edges (which represents the map of Bertown) and the array of prices  of length . It is guaranteed that there is a path between each pair of vertices (districts).Mike has planned a trip from the vertex (district)  to the vertex (district)  and then from the vertex (district)  to the vertex (district) . He can visit the same district twice or more. But there is one issue: authorities of the city want to set a price for using the road so if someone goes along the road then he should pay the price corresponding to this road (). The list of prices that will be used  is ready and they just want to distribute it between all roads in the town in such a way that each price from the array corresponds to exactly one road.You are a good friend of Mike (and suddenly a mayor of Bertown) and want to help him to make his trip as cheap as possible. So, your task is to distribute prices between roads in such a way that if Mike chooses the optimal path then the price of the trip is the  possible. .You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains five integers  and  (, , ) \u2014 the number of vertices, the number of edges and districts in Mike's trip. The second line of the test case contains  integers  (), where  is the -th price from the array. The following  lines of the test case denote edges: edge  is represented by a pair of integers ,  (, ), which are the indices of vertices connected by the edge. There are no loops or multiple edges in the given graph, i.\u2009e. for each pair () there are no other pairs () or () in the array of edges, and for each pair  the condition  is satisfied. It is guaranteed that the given graph is connected. It is guaranteed that the sum of  (as well as the sum of ) does not exceed  (, ).", "output": "For each test case, print the answer \u2014 the  possible price of Mike's trip if you distribute prices between edges optimally.", "tutorial": "If we distribute costs optimally, then this pair of paths ($$$a \\rightarrow b$$$ and $$$b \\rightarrow c$$$) can look like just a straight path that doesn't visit the same vertex twice or like three straight paths with one intersection point $$$x$$$. The first case is basically a subcase of the second one (with the intersection point $$$a, b$$$ or $$$c$$$). So, if we fix the intersection point $$$x$$$ then these two paths ($$$a \\rightarrow b$$$ and $$$b \\rightarrow c$$$) become four paths ($$$a \\rightarrow x$$$, $$$x \\rightarrow b$$$, $$$b \\rightarrow x$$$ and $$$x \\rightarrow c$$$). We can notice that each path we denoted should be the shortest possible because if it isn't the shortest one then we used some prices that we couldn't use.Let the length of the shortest path from $$$u$$$ to $$$v$$$ be $$$dist(u, v)$$$. Then it is obvious that for the fixed intersection point $$$x$$$ we don't need to use more than $$$dist(a, x) + dist(b, x) + dist(c, x)$$$ smallest costs. Now we want to distribute these costs between these three paths somehow. We can see that the path from $$$b$$$ to $$$x$$$ is used twice so it is more optimally to distribute the smallest costs along this part. So, let $$$pref_i$$$ be the sum of the first $$$i$$$ smallest costs (just prefix sums on the sorted array $$$p$$$). Then for the intersection point $$$x$$$ the answer is $$$pref_{dist(b, x)} + pref_{dist(a, x) + dist(b, x) + dist(c, x)}$$$ (if $$$dist(a, x) + dist(b, x) + dist(c, x) \\le m$$$). We can calculate distances from $$$a$$$, $$$b$$$ and $$$c$$$ to each vertex with three runs of bfs.Time complexity: $$$O(m \\log m)$$$.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nvector<vector<int>> g;\n\nvoid bfs(int s, vector<int> &d) {\n\td[s] = 0;\n\tqueue<int> q;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tfor (auto to : g[v]) {\n\t\t\tif (d[to] == INF) {\n\t\t\t\td[to] = d[v] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, m, a, b, c;\n\t\tcin >> n >> m >> a >> b >> c;\n\t\t--a, --b, --c;\n\t\t\n\t\tvector<int> p(m);\n\t\tfor (auto &it : p) cin >> it;\n\t\tsort(p.begin(), p.end());\n\t\tvector<long long> pref(m + 1);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tpref[i + 1] = pref[i] + p[i];\n\t\t}\n\t\t\n\t\tg = vector<vector<int>>(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\t--x, --y;\n\t\t\tg[x].push_back(y);\n\t\t\tg[y].push_back(x);\n\t\t}\n\t\t\n\t\tvector<int> da(n, INF), db(n, INF), dc(n, INF);\n\t\tbfs(a, da);\n\t\tbfs(b, db);\n\t\tbfs(c, dc);\n\t\t\n\t\tlong long ans = 1e18;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (da[i] + db[i] + dc[i] > m) continue;\n\t\t\tans = min(ans, pref[db[i]] + pref[da[i] + db[i] + dc[i]]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}