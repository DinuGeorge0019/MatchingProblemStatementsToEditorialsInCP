{"link": "https://codeforces.com//contest/1399/problem/B", "problemId": "691717", "shortId": "1399B", "contest_number": "1399", "name": "B. Gifts Fixing", "statement": "You have  gifts and you want to give all of them to children. Of course, you don't want to offend anyone, so all gifts should be equal between each other. The -th gift consists of  candies and  oranges.During one move, you can choose some gift  and do one of the following operations:  eat exactly  from this gift (decrease  by one);  eat exactly  from this gift (decrease  by one);  eat exactly  and exactly  from this gift (decrease both  and  by one). Of course, you can not eat a candy or orange if it's not present in the gift (so neither  nor  can become less than zero).As said above, all gifts should be equal. This means that after some sequence of moves the following two conditions should be satisfied:  and  (and  equals  is ).Your task is to find the  number of moves required to equalize all the given gifts.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the number of gifts. The second line of the test case contains  integers  (), where  is the number of candies in the -th gift. The third line of the test case contains  integers  (), where  is the number of oranges in the -th gift.", "output": "For each test case, print one integer: the  number of moves required to equalize all the given gifts.", "tutorial": "At first, consider the problems on candies and oranges independently. Then it's pretty obvious that for candies the optimal way is to decrease all  to the value  (we need obtain at least this value to equalize all the elements and there is no point to decrease elements further). The same works for the array . Then, if we unite these two problems, we need to take the maximum moves we need for each , because we need exactly that amount of moves to decrease  to  and  to  simultaneously.So, the answer is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n), b(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tfor (auto &it : b) cin >> it;\n\t\tint mna = *min_element(a.begin(), a.end());\n\t\tint mnb = *min_element(b.begin(), b.end());\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tans += max(a[i] - mna, b[i] - mnb);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}