{"link": "https://codeforces.com//contest/1624/problem/G", "problemId": "1256443", "shortId": "1624G", "contest_number": "1624", "name": "G. MinOr Tree", "statement": "Recently, Vlad has been carried away by spanning trees, so his friends, without hesitation, gave him a connected weighted undirected graph of  vertices and  edges for his birthday.Vlad defined the  of a spanning tree as the bitwise OR of all its weights, and now he is interested in what is the minimum possible  that can be achieved by choosing a certain spanning tree. A spanning tree is a connected subgraph of a given graph that does not contain cycles.In other words, you want to keep  edges so that the graph remains connected and the bitwise OR weights of the edges are as small as possible. You have to find the minimum bitwise OR itself.", "input": "The first line of the input contains an integer  () \u2014 the number of test cases in the input. An empty line is written in front of each test case. This is followed by two numbers  and  () \u2014 the number of vertices and edges of the graph, respectively. The next  lines contain the description of the edges. Line  contains three numbers ,  and  (, , ) \u2014 the vertices that the edge connects and its weight. It is guaranteed that the sum  and the sum  over all test cases does not exceed  and each test case contains a connected graph.", "output": "Print  lines, each of which contains the answer to the corresponding set of input data\u00a0\u2014 the minimum possible spanning tree .", "tutorial": "We need to minimize the result of the bitwise operation, so for convenience, we represent the answer as a mask. Firstly, let's assume that this mask is composed entirely of ones.Let's go from the most significant bit to the least significant one and try to reduce the answer. To understand whether it is possible to remove the -th bit, remove it and check if the graph, in which all the weights are submasks of the current answer, is connected, for this, you can use depth-first search or a disjoint sets union. If the graph is connected, then the bit can obviously be thrown out, and if not it cannot and must be returned.", "solution": "#include <bits/stdc++.h>\n\n#define int long long\n#define mp make_pair\n#define x first\n#define y second\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n\ntypedef long double ld;\ntypedef long long ll;\n\nusing namespace std;\n\nmt19937 rnd(143);\n\nconst int inf = 1e9;\nconst int M = 998244353;\nconst ld pi = atan2(0, -1);\nconst ld eps = 1e-4;\n\nint n, cur;\nvector<vector<pair<int, int>>> sl;\n\nvoid dfs(int v, vector<bool> &used){\n    used[v] = true;\n    for(auto e: sl[v]){\n        int u = e.x, w = e.y;\n        if(!used[u] && (cur | w) == cur){\n            dfs(u, used);\n        }\n    }\n}\n\nvoid cnt(int pw){\n    if(pw < 0) return;\n    int d = (ll) 1 << pw;\n    cur -= d;\n    vector<bool> used(n);\n    dfs(0, used);\n    for(bool b: used){\n        if(!b) {\n            cur += d;\n            break;\n        }\n    }\n    cnt(pw - 1);\n}\n\nvoid solve() {\n    int m;\n    cin >> n >> m;\n    sl.assign(n, vector<pair<int, int>>(0));\n    for(int i = 0; i < m; ++i){\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u, --v;\n        sl[u].emplace_back(v, w);\n        sl[v].emplace_back(u, w);\n    }\n    cur = 1;\n    int bit = 0;\n    for(; cur < inf; bit++){\n        cur = 2 * cur + 1;\n    }\n    cnt(bit);\n    cout << cur;\n}\n\nbool multi = true;\n\nsigned main() {\n    int t = 1;\n    if (multi) {\n        cin >> t;\n    }\n    for (; t != 0; --t) {\n        solve();\n        cout << \"\\n\";\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}