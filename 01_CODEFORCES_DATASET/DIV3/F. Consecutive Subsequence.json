{"link": "https://codeforces.com//contest/977/problem/F", "problemId": "181257", "shortId": "977F", "contest_number": "977", "name": "F. Consecutive Subsequence", "statement": "You are given an integer array of length .You have to choose some subsequence of this array of maximum length such that this subsequence forms a increasing sequence of consecutive integers. In other words the required sequence should be equal to  for some value  and length .Subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. You can erase any elements, not necessarily going successively. The remaining elements preserve their order. For example, for the array  the following arrays are subsequences: , , , but the array  is not.", "input": "The first line of the input containing integer number  () \u2014 the length of the array. The second line of the input containing  integer numbers  () \u2014 the array itself.", "output": "On the first line print  \u2014 the maximum length of the subsequence of the given array that forms an increasing sequence of consecutive integers. On the second line print the sequence of the indices of the  maximum length subsequence of the given array that forms an increasing sequence of consecutive integers.", "tutorial": "Let  be the answer for our problem if the last element of our subsequence equals to .Then we have an easy solution: let's store  as a \"\" (C++) or \"\" (Java). Initially for each  . Then let's iterate over all  in order of input and try to update  with a  ().Then the maximum element of  will be our answer. Let it be . Then let's find any  such that . Let it be . Then for restoring the answer we need to iterate over all elements of our array in reverse order and if the current element  then push  to the array of positions of our subsequence and make .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tmap<int, int> dp;\n\t\n\tint ans = 0;\n\tint lst = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x = a[i];\n\t\tdp[x] = dp[x - 1] + 1;\n\t\tif (ans < dp[x]) {\n\t\t\tans = dp[x];\n\t\t\tlst = x;\n\t\t}\n\t}\n\t\n\tvector<int> res;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tif (a[i] == lst) {\n\t\t\tres.push_back(i);\n\t\t\t--lst;\n\t\t}\n\t}\n\treverse(res.begin(), res.end());\n\t\n\tprintf(\"%d\\n\", ans);\n\tfor (auto it : res)\n\t\tprintf(\"%d \", it + 1);\n\tputs(\"\");\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}