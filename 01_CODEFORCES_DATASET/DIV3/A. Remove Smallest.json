{"link": "https://codeforces.com//contest/1399/problem/A", "problemId": "691716", "shortId": "1399A", "contest_number": "1399", "name": "A. Remove Smallest", "statement": "You are given the array  consisting of  positive (greater than zero) integers.In one move, you can choose two indices  and  () such that the absolute difference between  and  is no more than one () and remove the smallest of these two elements. If two elements are equal, you can remove any of them (but exactly one).Your task is to find if it is possible to obtain the array consisting of  using several (possibly, zero) such moves or not.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the length of . The second line of the test case contains  integers  (), where  is the -th element of .", "output": "For each test case, print the answer: \"\" if it is possible to obtain the array consisting of  using several (possibly, zero) moves described in the problem statement, or \"\" otherwise.", "tutorial": "Firstly, let's sort the initial array. Then it's obvious that the best way to remove elements is from smallest to biggest. And if there is at least one  such that  and  then the answer is \"\", because we have no way to remove . Otherwise, the answer is \"\".", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tsort(a.begin(), a.end());\n\t\tbool ok = true;\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tok &= (a[i] - a[i - 1] <= 1);\n\t\t}\n\t\tif (ok) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}