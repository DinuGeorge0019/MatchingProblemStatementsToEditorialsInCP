{"link": "https://codeforces.com//contest/1618/problem/F", "problemId": "1227955", "shortId": "1618F", "contest_number": "1618", "name": "F. Reverse", "statement": "You are given two positive integers  and . You can perform the following operation with : write it in its binary form without leading zeros, add  or  to the right of it, reverse the binary form and turn it into a decimal number which is assigned as the new value of .For example:    can be turned into  via one operation: the binary form of  is , if you add , reverse it and remove leading zeros, you will get , which is the binary form of .   can be turned into  via one operation: the binary form of  is , if you add , reverse it and remove leading zeros, you will get , which is the binary form of .   can be turned into  via one operation: the binary form of  is , if you add , reverse it and remove leading zeros, you will get , which is the binary form of .   can be turned into  via two operations: first you turn  into  and then  into . Your task is to find out whether  can be turned into  after a certain number of operations (possibly zero).", "input": "The only line of the input contains two integers  and  ().", "output": "Print  if you can make  equal to  and  if you can't.", "tutorial": "There are two main approaches to this problem.. Let's analyze how the binary representation of  changes after the operation. If there are no zeroes at the end of it, appending  just reverses the binary representation; if there are any trailing zeroes, we remove them and reverse the binary representation. If we append , we just reverse the binary representation and add  at the beginning. No matter which action we choose on the first step, the resulting binary representation will have  at its beginning and  at its end, so no bits can be removed from it (no zero from the resulting binary representation can become leading). It means that every number we can obtain from  will have the following form: several ones (maybe none), then , then several ones (again, maybe none), where  is one of the following four strings:  the binary representation of  after appending  in the first operation;  the binary representation of  after appending  in the first operation;  one of the aforementioned representations, but reversed. We can check that  meets one of these four templates, but since we only considered the case when we apply at least one operation, we also have to verify if .. Run something like implicit BFS or DFS to generate all possible values you can obtain, pruning when the length of the binary representation we get becomes too large (say, greater than ). Why does this work fast? As we have shown in our first approach, the numbers we can get from  have a very specific form, and if we limit their lengths to , we will consider only about  different numbers. Note that if you try this approach, you have to store the obtained numbers in some associative data structure (I use a set of strings in my solution).", "solution": "a, b = map(int, input().split())\ns = bin(b)[2:]\nt = bin(a)[2:]\nif s == t:\n    print(\"YES\")\n    exit(0)\nfor q in [t + '1', t.strip('0')]:\n    for l in range(len(s) - len(q) + 1):\n        r = len(s) - len(q) - l\n        if '1' * l + q + '1' * r == s or '1' * l + q[::-1] + '1' * r == s:\n            print(\"YES\")\n            exit(0)\nprint(\"NO\")", "interactive": false, "noSolution": false, "noTutorial": false}