{"link": "https://codeforces.com//contest/1560/problem/F2", "problemId": "1082102", "shortId": "1560F2", "contest_number": "1560", "name": "F2. Nearest Beautiful Number  hard version ", "statement": "You are given an integer . Find the minimum integer  such that  and the number  is -.A number is called - if its decimal representation having no leading zeroes contains no more than  different digits. E.g. if , the numbers , ,  and  are - whereas the numbers ,  and  are not.", "input": "The first line contains one integer  () \u2014 the number of test cases. Then  test cases follow. Each test case consists of one line containing two integers  and  (, ).", "output": "For each test case output on a separate line  \u2014 the minimum - integer such that .", "tutorial": "Suppose the number  contains  digits and its decimal representation is . The desired number  isn't greater than the number consisting of  digits . This number is -beautiful whereas any -beautiful number is at the same time -beautiful, so  contains at most  digits. At the same time,  so  contains at least  digits. Therefore, the desired number contains exactly  digits.Since we search for the minimum , we need to minimize first of all the first digit, only then the second digit, etc. Therefore, we need to find a prefix of the decimal representation of  such that is a prefix of the decimal representation of . Let's do it greedily.Let's find the maximum prefix of  such that contains no more than  distinct numbers. Suppose the prefix has the length . If , then  is already -beautiful, let's output it. Otherwise, let's increase the prefix like a number by , e.g. if  and , then we increase  by , the resulting prefix is . All other digits (), let's set to zeroes (e.g. if  and , then  will be turned into ). The answer for the old  is the answer for the new . To get the answer for the new , let's start the described procedure once again preparing the new .Let's find the maximum prefix of  such that contains no more than  distinct numbers. It's possible to do using a  in which for each digit (the key) the number of its occurrences in the prefix is stored. For an empty prefix, the  is empty. If we increase the prefix length by , we need to check that  contains no more than  keys and add a new key with the value  or increase the value of an existing key. If the length of the found prefix is equal to the length of the whole decimal representation, the given number is already -beautiful so the answer is .Otherwise, the found prefix may not be a prefix of the desired number. Let's change the digits of the decimal representation of  to turn it into the desired number . Let's start the following procedure: suppose we consider a prefix with the length equal to . First, let's find out, is it possible to increase the first element out of the prefix (i. e. ). We need to do it because if we consider the length , then the prefix with the length  cannot be unchanged so the element  must be changed whereas it cannot be decreased because, in this case, we will get the number which is less than . If we can increase the element  so that the prefix with the length  has at most  distinct digits, the only thing that is remained to do is to fill the remaining digits  somehow greedily and output the result. If we cannot increase the element , let's decrease the length of the considered prefix  by  updating the  (let's decrease the value corresponding to the key  by , then, if it's equal to , we remove the key  from the ).Consider, how and under what conditions we can change  and the following digits:  If , it's impossible.  Suppose the considered prefix contains less than  distinct digits (the number of the keys in the  is less than ). In this case, we can replace the digit  with the value  so the prefix with the length  will not contain more than  distinct elements because the prefix with the length  doesn't contain more than  distinct elements. If the prefix with the length  still contains less than  distinct numbers, let's replace the remaining digits (, , etc) with . Otherwise, we can replace them with the minimum digit that occurs in the prefix with the length  (it may be ).  Suppose the considered prefix contains exactly  distinct digits. So let's find the minimum digit that occurs in the prefix with the length  and is greater than . If such digit exists, let's replace  with it, and all following digits with the minimum digit that occurs in the prefix with the length . Otherwise, the element  cannot be increased.The converted by the procedure  is the answer.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring solve()\n{\n\tstring n;\n\tint k;\n\tcin >> n >> k;\n\n\twhile (true)\n\t{\n\t\tset<char> s;\n\t\tfor (auto c : n) s.insert(c);\n\t\tif (s.size() <= k) return n;\n\n\t\ts.clear();\n\t\tint ptr = 0;\n\t\tfor (; ; ptr++)\n\t\t{\n\t\t\ts.insert(n[ptr]);\n\t\t\tif (s.size() > k)\n\t\t\t{\n\t\t\t\twhile (n[ptr] == '9')\n\t\t\t\t\tptr--;\n\t\t\t\tn[ptr]++;\n\t\t\t\tfor (int i = ptr + 1; i < n.size(); i++)\n\t\t\t\t\tn[i] = '0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\n\twhile (t--)\n\t\tcout << solve() << '\\n';\n\t\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}