{"link": "https://codeforces.com//contest/988/problem/D", "problemId": "186729", "shortId": "988D", "contest_number": "988", "name": "D. Points and Powers of Two", "statement": "There are  distinct points on a coordinate line, the coordinate of -th point equals to . Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.In other words, you have to choose the maximum possible number of points  such that for each pair ,  it is true that  where  is some non-negative integer number (not necessarily the same for each pair of points).", "input": "The first line contains one integer  () \u2014 the number of points. The second line contains  pairwise distinct integers  () \u2014 the coordinates of points.", "output": "In the first line print  \u2014 the maximum possible number of points in a subset that satisfies the conditions described above. In the second line print  integers \u2014 the coordinates of points in the subset you have chosen. If there are multiple answers, print any of them.", "tutorial": "Firstly, let's prove that the size of the answer is not greater than . Suppose that the answer equals to . Let  be coordinates of the points in the answer (and ). Let  and . Then  (because of the condition). It means that . Conditions must hold for a triple  too. Now it is easy to see that if  then  that is not a power of two. So the size of the answer is not greater than .Firstly, let's check if the answer is . Iterate over all middle elements of the answer and over all powers of two from  to  inclusively. Let  be the middle element of the answer and  \u2014 the current power of two. Then if there are elements  and  in the array then the answer is . Now check if the answer is . Do the same as in the previous solution, but now we have left point  and right point .If we did not find answer of lengths  or  then print any element of the array.The solution above have time complexity  (because of we can check if the element is in the array with some data structure in ).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> x(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> x[i];\n\t}\n\t\n\tsort(x.begin(), x.end());\n\tvector<int> res = { x[0] };\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < 31; ++j) {\n\t\t\tint lx = x[i] - (1 << j);\n\t\t\tint rx = x[i] + (1 << j);\n\t\t\tbool isl = binary_search(x.begin(), x.end(), lx);\n\t\t\tbool isr = binary_search(x.begin(), x.end(), rx);\n\t\t\tif (isl && isr && int(res.size()) < 3) {\n\t\t\t\tres = { lx, x[i], rx };\n\t\t\t}\n\t\t\tif (isl && int(res.size()) < 2) {\n\t\t\t\tres = { lx, x[i] };\n\t\t\t}\n\t\t\tif (isr && int(res.size()) < 2) {\n\t\t\t\tres = { x[i], rx };\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << int(res.size()) << endl;\n\tfor (auto it : res)\n\t\tcout << it << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}