{"link": "https://codeforces.com//contest/1006/problem/D", "problemId": "198028", "shortId": "1006D", "contest_number": "1006", "name": "D. Two Strings Swaps", "statement": "You are given two strings  and  consisting of lowercase English letters, both of length . The characters of both strings have indices from  to , inclusive. You are allowed to do the following :   Choose any index  () and swap characters  and ;  Choose any index  () and swap characters  and ;  Choose any index  () and swap characters  and . Note that if  is odd, you are formally allowed to swap  with  (and the same with the string ) but this move is useless. Also you can swap two equal characters but this operation is useless as well.You have to make these strings equal by applying any number of  described above, in any order. But it is obvious that it may be impossible to make two strings equal by these swaps.In one  you can replace a character in  with another character. In other words, in a single  you can choose any index  (), any character  and set .Your task is to find the minimum number of  to apply in such a way that after them you can make strings  and  equal by applying some number of  described in the list above.Note that the number of  you make after the  does not matter. Also note that you cannot apply  to the string  or make any  after the first  is made.", "input": "The first line of the input contains one integer  () \u2014 the length of strings  and . The second line contains the string  consisting of exactly  lowercase English letters. The third line contains the string  consisting of exactly  lowercase English letters.", "output": "Print a single integer \u2014 the minimum number of  to apply before , so that it is possible to make the string  equal to string  with a sequence of  from the list above.", "tutorial": "Let's divide all characters of both strings into groups in such a way that characters in each group can be swapped with each other with . So, there will be following groups: ,  and so on. Since these groups don't affect each other, we can calculate the number of  in each group and then sum it up.How to determine if a group does not need any preprocess moves? For a group consisting of  characters (there will be one such group if  is odd, it will contain  and ), that's easy \u2014 if the characters in this group are equal, the answer is , otherwise it's .To determine the required number of preprocess moves for a group consising of four characters, we may use the following fact: this group doesn't require preprocess moves iff the characters in this group can be divided into pairs. So if the group contains four equal characters, or two pairs of equal characters, then the answer for this group is . Otherwise we may check that replacing only one character of  and  will be enough; if so, then the answer is , otherwise it's .Overall complexity is .", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define sqr(a) ((a) * (a))\n#define sz(a) int(a.size())\n#define all(a) a.begin(), a.end()\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n \ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n \ntemplate <class A, class B> ostream& operator << (ostream& out, const pair<A, B> &a) {\n\treturn out << \"(\" << a.x << \", \" << a.y << \")\";\n}\n \ntemplate <class A> ostream& operator << (ostream& out, const vector<A> &v) {\n\tout << \"[\";\n\tforn(i, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n \nmt19937 rnd(time(NULL));\n \nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst int MOD = INF + 7;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n \nint n;\nstring s, t;\n\nbool read() {\n\tif (!(cin >> n >> s >> t))\n\t\treturn false;\n\treturn true;\n}\n\nvoid solve() {\n\tint ans = 0;\n\tforn(i, n / 2) {\n\t\tmap<char, int> a;\n\t\ta[s[i]]++; a[s[n - i - 1]]++;\n\t\ta[t[i]]++; a[t[n - i - 1]]++;\n\t\tif (sz(a) == 4)\n\t\t\tans += 2;\n\t\telse if (sz(a) == 3)\n\t\t\tans += 1 + (s[i] == s[n - i - 1]);\n\t\telse if (sz(a) == 2)\n\t\t\tans += a[s[i]] != 2;\n\t}\n\t\n\tif (n % 2 == 1 && s[n / 2] != t[n / 2])\n\t\tans++;\n\t\t\n\tcout << ans << endl;\n}\n \nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n \n\tint tt = clock();\n \n#endif\n \n\tcerr.precision(15);\n\tcout.precision(15);\n\tcerr << fixed;\n\tcout << fixed;\n\t\n#ifdef _DEBUG\n\twhile (read()) {\t\n#else\n\tif (read()) {\n#endif\n\t\tsolve();\n \n#ifdef _DEBUG\n\tcerr << \"TIME = \" << clock() - tt << endl;\n\ttt = clock();\n#endif\n \n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}