{"link": "https://codeforces.com//contest/1490/problem/B", "problemId": "898524", "shortId": "1490B", "contest_number": "1490", "name": "B. Balanced Remainders", "statement": "You are given a number  () and an array . In one move, you can increase any of the array elements by one. Formally, you choose the index  () and   with . You can choose the same index  multiple times for different moves.Let's denote by ,  and  the number of numbers from the array  that have remainders ,  and  when divided by the number , respectively. Let's say that the array  has balanced remainders if ,  and  are equal.For example, if  and , then the following sequence of moves is possible:   initially ,  and , these values are not equal to each other. Let's increase , now the array ;  ,  and , these values are not equal. Let's increase , now the array ;  ,  and , these values are not equal. Let's increase , now the array ;  ,  and , these values are equal to each other, which means that the array  has balanced remainders. Find the minimum number of moves needed to make the array  have balanced remainders.", "input": "The first line contains one integer  (). Then  test cases follow. The first line of each test case contains one integer  ()\u00a0\u2014 the length of the array . It is guaranteed that the number  is divisible by . The next line contains  integers  (). It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, output one integer\u00a0\u2014 the minimum number of moves that must be made for the  array to make it have balanced remainders.", "tutorial": "Note that the numbers in the  array are not important to us, so initially we will calculate the values of , , . Now applying a move for the number  is equivalent to:   decreasing  by ;  and increasing  by ; We will perform the following greedy algorithm:   while the array  have no balanced remainders, find any  () such that ;  we apply the move for , that is, replace  with , and  with . It is easy to prove the correctness of this greedy algorithm by cyclically shifting the values , , and  so that the first element is equal to the maximum of them.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int &x : a) {\n    cin >> x;\n  }\n\n  int res = 0;\n  vector<int> cnt(3);\n  for (int x = 0; x <= 2; x++) {\n      for (int i = 0; i < n; i++) {\n          if (a[i] % 3 == x) {\n              cnt[x]++;\n          }\n      }\n  }\n  \n  while (*min_element(cnt.begin(), cnt.end()) != n / 3) {\n      for (int i = 0; i < 3; i++) {\n          if (cnt[i] > n / 3) {\n              res++;\n              cnt[i]--;\n              cnt[(i + 1) % 3]++;\n          }\n      }\n  }\n  cout << res << endl;\n}\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}