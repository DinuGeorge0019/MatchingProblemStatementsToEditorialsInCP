{"link": "https://codeforces.com//contest/1800/problem/E2", "problemId": "1805848", "shortId": "1800E2", "contest_number": "1800", "name": "E2. Unforgivable Curse  hard version ", "statement": "The chief wizard of the Wizengamot once caught the evil wizard Drahyrt, but the evil wizard has returned and wants revenge on the chief wizard. So he stole   from his student Harry.The \u00a0\u2014 is a -length string of lowercase Latin letters.Drahyrt wants to replace  with an unforgivable curse\u00a0\u2014 string .Dragirt, using ancient magic, can swap letters at a distance  or  in  as many times as he wants. In other words, Drahyrt can change letters in positions  and  in   if  or .For example, if  \"\" and  \"\", Drahyrt can act as follows:  swap the letters at positions  and  to get  \"\".  swap the letters at positions  and  to get  \"\". You are given   and . Can Drahyrt change   to ?", "input": "The first line of input gives a single integer  ()\u00a0\u2014 the number of test cases in the test. Descriptions of the test cases are follow. The first line contains two integers  (, )\u00a0\u2014 the length  and the number  such that Drahyrt can change letters in a spell at a distance  or . The second line gives  \u00a0\u2014 a string of length  consisting of lowercase Latin letters. The third line gives  \u00a0\u2014 a string of length  consisting of lowercase Latin letters. It is guaranteed that the sum of  values over all test cases does not exceed . Note that there is no limit on the sum of  values over all test cases.", "output": "For each test case, output on a separate line \"\" if Drahyrt can change   to  and \"\" otherwise. You can output the answer in any case (for example, lines \"\", \"\", \"\" and \"\" will be recognized as positive answer).", "tutorial": "The solution of the problem  hints to us that with the help of such operations, it is possible to move the symbol in the right direction by  using two operations. Then we can show that among the symbols that we can swap with at least one other symbol, we can get any permutation.For example, you can apply such a greedy solution: we will build an answer from the boundaries of the string  to the middle. Since we can move the symbol by a distance of , we can move it to the border and thus we can build any string .Thus, it is enough to check that the sets of characters that can be swapped with some other match. And for the rest of the characters, check that they just match.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(v) (int)v.size()\n#define all(v) v.begin(),v.end()\n#define eb emplace_back\n\nvoid solve() {\n    int n, k; cin >> n >> k;\n    string s; cin >> s;\n    string t; cin >> t;\n    vector<int> cnt(26, 0);\n\n    bool ok = true;\n    for (int i = 0; i < n; ++i) {\n        if (i >= k || i+k < n){\n            cnt[s[i] - 'a']++;\n            cnt[t[i] - 'a']--;\n        } else {\n            ok &= s[i] == t[i];\n        }\n    }\n\n    cout << (ok && count(all(cnt), 0) == 26 ? \"YES\" : \"NO\") << '\\n';\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}