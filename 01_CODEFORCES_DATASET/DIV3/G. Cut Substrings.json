{"link": "https://codeforces.com//contest/1729/problem/G", "problemId": "1538788", "shortId": "1729G", "contest_number": "1729", "name": "G. Cut Substrings", "statement": "You are given two non-empty strings  and , consisting of Latin letters.In one move, you can choose an occurrence of the string  in the string  and replace it with dots.Your task is to remove all occurrences of the string  in the string  in the minimum number of moves, and also calculate how many  sequences of moves of the minimum length exist.Two sequences of moves are considered different if the sets of indices at which the removed occurrences of the string  in  begin differ. For example, the sets  and  are considered different, the sets  and  \u2014 too, but sets  and  \u2014 not.For example, let the string  \"\" and the string  \"\". We can remove all occurrences of the string  in  moves by cutting out the occurrences of the string  at the th and th positions. In this case, the string  is an example of the form \"\". It is also possible to cut occurrences of the string  at the th and th positions. There are two different sequences of minimum length moves.Since the answer can be large, output it modulo .", "input": "The first line of the input contains a single integer  ()\u00a0\u2014 the number of test cases. The descriptions of the sets follow. The first line of each set contains a non-empty string  () consisting of lowercase Latin letters. The second line of each set contains a non-empty string  () consisting of lowercase Latin letters. It is guaranteed that the sum of string lengths  over all test cases does not exceed . Similarly, it is guaranteed that the sum of string lengths  over all test cases does not exceed .", "output": "For each test case print two integers \u2014 the minimum number of moves and the number of different optimal sequences, modulo .", "tutorial": "First, find all occurrences of  in  as substrings. This can be done using the prefix function.To find the minimum number of times we need to cut substrings, consider all indexes of occurrences. Having considered the index of the occurrence, we cut out the rightmost occurrence that intersects with it. After that, we find the leftmost occurrence that does not intersect with the cut one. If it doesn't, we end the loop.The number of optimal sequences of moves will be calculated using dynamic programming.For each occurrence, we can count how many ways we can cut out all occurrences of  in the suffix  starting with this occurrence in the minimum number of moves. Considering the occurrence, we find the leftmost occurrence that does not intersect with it, and then iterate over the occurrences with which we can remove it.", "solution": "#include<cstdio>\n#include<cstring>\nconst int N=505;\nconst int Mod=1e9+7;\nchar s[N],t[N];\nint n,m;\nint f[N],g[N];\nint p[N],tot;\ninline void Init(){\n\tscanf(\"%s\",s+1);\n\tscanf(\"%s\",t+1);\n\tn=strlen(s+1);\n\tm=strlen(t+1);\n\ttot=0;\n\tfor(int i=1;i+m-1<=n;i++){\n\t\tbool flg=1;\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tif(s[i+j-1]!=t[j]) flg=0;\n\t\tif(flg) p[++tot]=i;\n\t}\n\treturn ;\n}\ninline int addv(int x,int y){\n\tint s=x+y;\n\tif(s>=Mod) s-=Mod;\n\treturn s;\n}\ninline int subv(int x,int y){\n\tint s=x-y;\n\tif(s<0) s+=Mod;\n\treturn s;\n}\ninline void add(int&x,int y){\n\tx=addv(x,y);\n\treturn ;\n}\ninline void sub(int&x,int y){\n\tx=subv(x,y);\n\treturn ;\n}\ninline void Solve(){\n\tmemset(f,0x3f,sizeof(f));\n\tmemset(g,0,sizeof(g));\n\tp[0]=-N;\n\tf[0]=0;\n\tg[0]=1;\n\tp[++tot]=n+m;\n\tfor(int i=0;i<tot;i++){\n\t\tint j=i+1;\n\t\twhile(j<=tot&&p[j]<=p[i]+m-1) j++;\n\t\tfor(int k=j;p[j]+m-1>=p[k]&&k<=tot;k++){\n\t\t\tif(f[i]+1<f[k]){\n\t\t\t\tf[k]=f[i]+1;\n\t\t\t\tg[k]=g[i];\n\t\t\t}\n\t\t\telse if(f[i]+1==f[k]) add(g[k],g[i]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",f[tot]-1,g[tot]);\n\treturn ;\n}\nint T;\nint main(){\n\tfor(scanf(\"%d\",&T);T;T--){\n\t\tInit();\n\t\tSolve();\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}