{"link": "https://codeforces.com//contest/1472/problem/E", "problemId": "854355", "shortId": "1472E", "contest_number": "1472", "name": "E. Correct Placement", "statement": "Polycarp has invited  friends to celebrate the New Year. During the celebration, he decided to take a group photo of all his friends. Each friend can stand or lie on the side.Each friend is characterized by two values  (their height) and  (their width). On the photo the -th friend will occupy a rectangle  (if they are standing) or  (if they are lying on the side).The -th friend can be placed in front of the -th friend on the photo if his rectangle is lower and narrower than the rectangle of the -th friend. Formally,  of the following conditions must be fulfilled:     (both friends are standing or both are lying);     (one of the friends is standing and the other is lying). For example, if ,  and , then:  the first friend can be placed in front of the second:  and  (one of the them is standing and the other one is lying);  the third friend can be placed in front of the second:  and  (both friends are standing or both are lying). In other cases, the person in the foreground will overlap the person in the background.Help Polycarp for each  find any , such that the -th friend can be located in front of the -th friend (i.e. at least one of the conditions above is fulfilled).Please note that you do not need to find the arrangement of all people for a group photo. You just need to find for each friend  any other friend  who can be located in front of him. Think about it as you need to solve  separate independent subproblems.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. Then  test cases follow. The first line of each test case contains one integer  ()\u00a0\u2014 the number of friends. This is followed by  lines, each of which contains a description of the corresponding friend. Each friend is described by two integers  and  ()\u00a0\u2014 height and width of the -th friend, respectively. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case output  integers on a separate line, where the -th number is the index of a friend that can be placed in front of the -th. If there is no such friend, then output . If there are several answers, output any.", "tutorial": "Let's sort all people by their height in descending order.Now let's go through all the people and look for the position of the person in the sorted array, the height of which is strictly less than ours (for example, by binary search). Obviously, only those people who are in the sorted array later than the found person can stand in front of us (all of them have a height strictly less than ours).Among all these people, it is more profitable for us to take a person with minimum width. In order to find such a person quickly, we can find a person with the minimum width for each suffix of the sorted array.To handle a situation where a person is lying down, we need to swap the width and height and repeat the algorithm above.", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nstruct man {\n  int h, w, id;\n};\n\nbool operator<(const man &a, const man &b) {\n  return tie(a.h, a.w, a.id) < tie(b.h, b.w, b.id);\n}\n\nstruct my_min {\n  pii mn1, mn2;\n};\n\nvector<pair<int, my_min>> createPrefMins(const vector<man>& a) {\n  vector<pair<int, my_min>> prefMin;\n  my_min curMin{pii(INT_MAX, -1), pii(INT_MAX, -1)};\n  for (auto x : a) {\n    if (x.w < curMin.mn1.first) {\n      curMin.mn2 = curMin.mn1;\n      curMin.mn1 = pii(x.w, x.id);\n    } else {\n      curMin.mn2 = min(curMin.mn2, pii(x.w, x.id));\n    }\n    prefMin.emplace_back(x.h, curMin);\n  }\n  return prefMin;\n}\n\nint findAny(const vector<pair<int, my_min>> &mins, int h, int w, int id) {\n  int l = -1, r = (int) mins.size();\n  while (r - l > 1) {\n    int m = (l + r) / 2;\n    if (mins[m].first < h) {\n      l = m;\n    } else {\n      r = m;\n    }\n  }\n  if (l == -1) {\n    return -1;\n  }\n\n  auto mn1 = mins[l].second.mn1;\n  auto mn2 = mins[l].second.mn2;\n  if (mn1.second != id) {\n    return mn1.first < w ? mn1.second + 1 : -1;\n  }\n  return mn2.first < w ? mn2.second + 1 : -1;\n}\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<man> hor, ver;\n  vector<pii> a;\n  for (int i = 0; i < n; i++) {\n    int h, w;\n    cin >> h >> w;\n    hor.push_back({h, w, i});\n    ver.push_back({w, h, i});\n    a.emplace_back(h, w);\n  }\n\n  sort(hor.begin(), hor.end());\n  sort(ver.begin(), ver.end());\n\n  auto horMins = createPrefMins(hor);\n  auto verMins = createPrefMins(ver);\n\n  for (int i = 0; i < n; i++) {\n    auto[h, w] = a[i];\n    int id = findAny(horMins, h, w, i);\n    if (id == -1) {\n      id = findAny(verMins, h, w, i);\n    }\n    cout << id << \" \";\n  }\n  cout << endl;\n}\n\nint main() {\n  int tests;\n  cin >> tests;\n  while (tests-- > 0) {\n    solve();\n  }\n  return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}