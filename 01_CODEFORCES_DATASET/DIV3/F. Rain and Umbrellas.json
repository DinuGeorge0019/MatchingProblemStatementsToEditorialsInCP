{"link": "https://codeforces.com//contest/988/problem/F", "problemId": "186731", "shortId": "988F", "contest_number": "988", "name": "F. Rain and Umbrellas", "statement": "Polycarp lives on a coordinate line at the point . He goes to his friend that lives at the point . Polycarp can move only from left to right, he can pass one unit of length each second.Now it's raining, so some segments of his way are in the rain. Formally, it's raining on  non-intersecting segments, the -th segment which is in the rain is represented as  ().There are  umbrellas lying on the line, the -th umbrella is located at point  () and has weight . When Polycarp begins his journey, he doesn't have any umbrellas.During his journey from  to  Polycarp can pick up and throw away umbrellas. Polycarp picks up and throws down any umbrella instantly. He can carry any number of umbrellas at any moment of time. Because Polycarp doesn't want to get wet, he must carry at least one umbrella while he moves from  to  if a segment  is in the rain (i.e. if there exists some  such that  and ).The condition above is the only requirement. For example, it is possible to go without any umbrellas to a point where some rain segment starts, pick up an umbrella at this point and move along with an umbrella. Polycarp can swap umbrellas while he is in the rain.Each unit of length passed increases Polycarp's fatigue by the sum of the weights of umbrellas he carries while moving.Can Polycarp make his way from point  to point ? If yes, find the minimum total fatigue after reaching , if Polycarp picks up and throws away umbrellas optimally.", "input": "The first line contains three integers ,  and  () \u2014 the point at which Polycarp's friend lives, the number of the segments in the rain and the number of umbrellas. Each of the next  lines contains two integers  and  () \u2014 the borders of the -th segment under rain. . In other words, for each pair of segments  and  either  or . Each of the next  lines contains two integers  and  (, ) \u2014 the location and the weight of the -th umbrella.", "output": "Print \"\" (without quotes) if Polycarp can't make his way from point  to point . Otherwise print one integer \u2014 the minimum total fatigue after reaching , if Polycarp picks up and throws away umbrellas optimally.", "tutorial": "Any experienced contestant can easily guess that the problem can be solved with dynamic programming. Coordinates are not really large so you can precalculate the array , where  is a boolean value \u2014  if there exists some segment of rain to cover the segment between positions  and  and  otherwise. This can be done in  with the most straightforward algorithm. You can also precalculate another array , where  is the index of the umbrella of minimal weight at position  or  if there is no such umbrella.Now let  be the minimal total fatigue you can take if you are holding umbrella number  on the end of the walk up to position . If  then you hold no umbrella. Initially all the values are  and  is . You can either hold your umbrella, drop it or pick up the best one lying there (and drop the current one if any) when going from some position  to . So here are the transitions for these cases:   if ;   if ;   if . The answer is equal to . If it is  then there is no answer.So you have  states and all the transitions are .Overall complexity: .There is also a solution in  with Convex Hull Trick using Li Chao tree. You can probably even achieve  with some coordinate compression. Obviously this wasn't required for the problem as the constraints are small enough.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1000 * 1000 * 1000;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint a, n, m;\n\tcin >> a >> n >> m;\n\tvector<int> rain(a + 1);\n\tvector<pair<int, int>> umb(a + 1, make_pair(INF, -1));\n\tvector<int> costs(m);\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tfor (int j = l; j < r; ++j)\n\t\t\train[j] = 1;\n\t}\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, p;\n\t\tcin >> x >> p;\n\t\tcosts[i] = p;\n\t\tumb[x] = min(umb[x], make_pair(p, i));\n\t}\n\t\n\tvector<vector<int>> dp(a + 1, vector<int>(m + 1, INF));\n\tdp[0][m] = 0;\n\tfor (int i = 0; i < a; ++i) {\n\t\tfor (int j = 0; j <= m; ++j) {\n\t\t\tif (dp[i][j] == INF)\n\t\t\t\tcontinue;\n\t\t\tif (rain[i] == 0)\n\t\t\t\tdp[i + 1][m] = min(dp[i + 1][m], dp[i][j]);\n\t\t\tif (j < m)\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + costs[j]);\n\t\t\tif (umb[i].first != INF)\n\t\t\t\tdp[i + 1][umb[i].second] = min(dp[i + 1][umb[i].second], dp[i][j] + umb[i].first);\n\t\t}\n\t}\n\t\n\tint ans = INF;\n\tfor (int i = 0; i <= m; ++i)\n\t\tans = min(ans, dp[a][i]);\n\tif (ans == INF)\n\t\tans = -1;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}