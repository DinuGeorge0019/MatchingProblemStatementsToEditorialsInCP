{"link": "https://codeforces.com//contest/1619/problem/C", "problemId": "1234624", "shortId": "1619C", "contest_number": "1619", "name": "C. Wrong Addition", "statement": "Tanya is learning how to add numbers, but so far she is not doing it correctly. She is adding two numbers  and  using the following algorithm:  If one of the numbers is shorter than the other, Tanya adds leading zeros so that the numbers are the same length.  The numbers are processed from right to left (that is, from the least significant digits to the most significant).  In the first step, she adds the last digit of  to the last digit of  and writes their sum in the answer.  At each next step, she performs the same operation on each pair of digits in the same place and writes the result to the  side of the answer.  For example, the numbers  and  Tanya adds up as follows:  calculates the sum of  and writes  in the answer.  calculates the sum of  and writes the result to the left side of the answer to get .  calculates the sum of  and writes the result to the left side of the answer to get .  calculates the sum of , and writes the result to the left side of the answer to get .  calculates the sum of  and writes the result to the left side of the answer and get . As a result, she gets .You are given two positive integers  and . Find the number  such that by adding  and  as described above, Tanya will get . Or determine that no suitable  exists.", "input": "The first line of input data contains an integer  () \u2014 the number of test cases. Each test case consists of a single line containing two positive integers  and  () separated by a space.", "output": "For each test case print the answer on a separate line. If the solution exists, print a single positive integer . The answer must be written without leading zeros. If multiple answers exist, print any of them. If no suitable number  exists, output .", "tutorial": "Let's compute the answer to the array , where  is the digit at the  position in the number we are looking for. Let  be the position of the last digit in number ,  be the position of the last digit in number . Then denote , , and consider the cases:   if , then the sum of  was exactly , then .  if , then the sum  was greater than  and we need to look at the next digit of the number . If there isn't one, we can't get the answer \u2014 we'll output . Otherwise we recalculate  and reduce  by one.  if now  and , then . Otherwise, we deduce , since we cannot get more than  when adding two digits, and the cases where  have already been considered before.  After considering the cases, reduce  and  by one and repeat the checks as long as  or . In the situation where , but , we will still have uncheked digits of number , so we will also output . Otherwise, we output an array with the answer without leading zeros.", "solution": "#include<bits/stdc++.h>\n#define len(s) (int)s.size()\nusing namespace std;\nusing ll = long long;\n \nvoid solve(){\n    ll a, s;\n    cin >> a >> s;\n    vector<int>b;\n    while(s){\n        int x = a % 10;\n        int y = s % 10;\n        if(x <= y) b.emplace_back(y - x);\n        else{\n            s /= 10;\n            y += 10 * (s % 10);\n            if(x < y && y >= 10 && y <= 19) b.emplace_back(y - x);\n            else{\n                cout << -1 << '\\n';\n                return;\n            }\n        }\n        a /= 10;\n        s /= 10;\n    }\n    if(a) cout << -1 << '\\n';\n    else{\n        while (b.back() == 0) b.pop_back();\n        for(int i = len(b) - 1; i >= 0; i--) cout << b[i];\n        cout << '\\n';\n    }\n}\n \nint main(){\n    ios_base ::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    int t;\n    cin >> t;\n    while (t){\n        solve();\n        t--;\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}