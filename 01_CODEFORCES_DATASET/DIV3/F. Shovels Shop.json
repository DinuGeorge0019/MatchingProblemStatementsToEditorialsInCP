{"link": "https://codeforces.com//contest/1154/problem/F", "problemId": "331482", "shortId": "1154F", "contest_number": "1154", "name": "F. Shovels Shop", "statement": "There are  shovels in the nearby shop. The -th shovel costs  bourles.Misha has to buy   shovels. Each shovel can be bought .Misha can buy shovels by several purchases. During one purchase he can choose any subset of remaining (non-bought) shovels and buy this subset.There are also  special offers in the shop. The -th of them is given as a pair , and it means that if Misha buys   shovels  then   of them are for free (i.e. he will not pay for  most cheapest shovels during the current purchase).Misha can use any offer any (possibly, zero) number of times, but he cannot use  offer during  (but he can buy shovels without using any offers).Your task is to calculate the minimum cost of buying  shovels, if Misha buys them optimally.", "input": "The first line of the input contains three integers  and  () \u2014 the number of shovels in the shop, the number of special offers and the number of shovels Misha has to buy, correspondingly. The second line of the input contains  integers  (), where  is the cost of the -th shovel. The next  lines contain special offers. The -th of them is given as a pair of integers  () and means that if Misha buys exactly  shovels during some purchase, then he can take  most cheapest of them for free.", "output": "Print one integer \u2014 the minimum cost of buying  shovels if Misha buys them optimally.", "tutorial": "First of all, since we are going to buy exactly  shovels, we may discard  most expensive shovels from the input and set  (and solve the problem which requires us to buy all the shovels). Also, let's add an offer which allows us to buy  shovel and get  cheapest of them for free, to simulate that we can buy shovels without using offers.Now we claim that if we sort all the shovels by their costs, it's optimal to divide the array of costs into some consecutive subarrays and buy each subarray using some offer. Why should the sets of shovels for all purchases be consecutive subarrays? Suppose it's not so: let's pick two purchases such that they are \"mixed\" in the array of costs, i.\u2009e. there exists at least one shovel  bought in the first purchase such that there exists a shovel  cheaper than it and a shovel  more expensive than it, both bought in the second purchase. If shovel  is for free, then we may \"swap\" shovels  and , otherwise we may swap shovels  and , and the answer won't become worse. So, we can do it until all purchases correspond to subsegments in the array of costs.Then it's easy to see that we can make purchases in such a way that we always buy some amount of cheapest shovels. And now the problem can be solved by knapsack-like dynamic programming: let  be the minimum cost to buy exactly  cheapest shovels.  is , and for each offer  we can update  by the value of , where  is the sum of costs of all shovels in the sorted order from shovel on position  to shovel on position , inclusive (these sums can be calculated in  using partial sums method).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tsort(a.begin(), a.end());\n\ta.resize(k);\n\treverse(a.begin(), a.end());\n\t\n\tvector<int> offers(k + 1);\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif (x <= k) {\n\t\t\toffers[x] = max(offers[x], y);\n\t\t}\n\t}\n\t\n\tvector<int> pref(k + 1);\n\tfor (int i = 0; i < k; ++i) {\n\t\tpref[i + 1] = pref[i] + a[i];\n\t}\n\t\n\tvector<int> dp(k + 1, INF);\n\tdp[0] = 0;\n\tfor (int i = 0; i < k; ++i) {\n\t\tdp[i + 1] = min(dp[i + 1], dp[i] + a[i]);\n\t\tfor (int j = 1; j <= k; ++j) {\n\t\t\tif (offers[j] == 0) continue;\n\t\t\tif (i + j > k) break;\n\t\t\tdp[i + j] = min(dp[i + j], dp[i] + pref[i + j - offers[j]] - pref[i]);\n\t\t}\n\t}\n\t\n\tcout << dp[k] << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}