{"link": "https://codeforces.com//contest/1433/problem/G", "problemId": "766662", "shortId": "1433G", "contest_number": "1433", "name": "G. Reducing Delivery Cost", "statement": "You are a mayor of Berlyatov. There are  districts and  two-way roads between them. The -th road connects districts  and . The cost of travelling along this road is . There is some path between each pair of districts, so the city is connected.There are  delivery routes in Berlyatov. The -th route is going from the district  to the district . There is one courier on each route and the courier will always choose the  (minimum by total cost) path from the district  to the district  to deliver products.The route can go from the district to itself, some couriers routes can coincide ().You can make at most one road to have cost zero (i.e. you choose at most one road and change its cost with ).Let  be the cheapest cost of travel between districts  and .Your task is to find the minimum total courier routes cost you can achieve, if you optimally select the some road and change its cost with . In other words, you have to find the minimum possible value of  after applying the operation described above optimally.", "input": "The first line of the input contains three integers ,  and  (; ; ) \u2014 the number of districts, the number of roads and the number of courier routes. The next  lines describe roads. The -th road is given as three integers ,  and  (; ; ), where  and  are districts the -th road connects and  is its cost. It is guaranteed that there is some path between each pair of districts, so the city is connected. It is also guaranteed that there is at most one road between each pair of districts. The next  lines describe courier routes. The -th route is given as two integers  and  () \u2014 the districts of the -th route. The route can go from the district to itself, some couriers routes can coincide ().", "output": "Print one integer \u2014 the  total courier routes cost you can achieve (i.e. the minimum value , where  is the cheapest cost of travel between districts  and ) if you can make some () road cost zero.", "tutorial": "If we would naively solve the problem, we would just try to replace each edge's cost with zero and run Dijkstra algorithm  times to get the cheapest paths. But this is too slow.Let's try to replace each edge's cost with zero anyway but use some precalculations to improve the speed of the solution. Let's firstly run Dijkstra  times to calculate all cheapest pairwise paths. Then, let's fix which edge we \"remove\" .There are three cases for the path : this edge was not on the cheapest path before removing and is not on the cheapest path after removing. Then the cost of this path is . The second case is when this edge was not on the cheapest path before removing but it is on the cheapest path after removing. Then the cost of this path is . So we are just going from  to  using the cheapest path, then going through the zero edge and then going from  to  using the cheapest path also (or vice versa, from  to  and from  to ). And the third case is when this edge was already on the cheapest path between  and  but this case is essentially the same as the second one.So, if we fix the edge , then the answer for this edge is . Taking the minimum over all edges, we will get the answer.The precalculating part works in  and the second part works in .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint n;\nvector<vector<int>> d;\nvector<vector<pair<int, int>>> g;\n\nvoid dijkstra(int s, vector<int> &d) {\n\td = vector<int>(n, INF);\n\td[s] = 0;\n\tset<pair<int, int>> st;\n\tst.insert({d[s], s});\n\twhile (!st.empty()) {\n\t\tint v = st.begin()->second;\n\t\tst.erase(st.begin());\n\t\tfor (auto [to, w] : g[v]) {\n\t\t\tif (d[to] > d[v] + w) {\n\t\t\t\tauto it = st.find({d[to], to});\n\t\t\t\tif (it != st.end()) st.erase(it);\n\t\t\t\td[to] = d[v] + w;\n\t\t\t\tst.insert({d[to], to});\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint m, k;\n\tcin >> n >> m >> k;\n\tg = vector<vector<pair<int, int>>>(n);\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\t--x, --y;\n\t\tg[x].push_back({y, w});\n\t\tg[y].push_back({x, w});\n\t}\n\t\n\tvector<pair<int, int>> r(k);\n\tfor (auto &[a, b] : r) {\n\t\tcin >> a >> b;\n\t\t--a, --b;\n\t}\n\t\n\td = vector<vector<int>>(n);\n\tfor (int v = 0; v < n; ++v) {\n\t\tdijkstra(v, d[v]);\n\t}\n\t\n\tint ans = INF;\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto [to, w] : g[v]) {\n\t\t\tint cur = 0;\n\t\t\tfor (auto [a, b] : r) {\n\t\t\t\tcur += min({d[a][b], d[a][v] + d[to][b], d[a][to] + d[v][b]});\n\t\t\t}\n\t\t\tans = min(ans, cur);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}