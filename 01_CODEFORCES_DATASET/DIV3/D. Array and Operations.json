{"link": "https://codeforces.com//contest/1618/problem/D", "problemId": "1227952", "shortId": "1618D", "contest_number": "1618", "name": "D. Array and Operations", "statement": "You are given an array  of  integers, and another integer  such that .You have to perform   operations with this array. In one operation, you have to choose two elements of the array (let them be  and ; they can be equal or different, but ), remove them from the array, and add  to your , where  is the maximum integer not exceeding .Initially, your  is . After you perform exactly  operations, you add all the remaining elements of the array to the .Calculate the minimum possible  you can get.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Each test case consists of two lines. The first line contains two integers  and  (; ). The second line contains  integers  ().", "output": "Print one integer \u2014 the minimum possible  you can get.", "tutorial": "It's kinda obvious that we have to choose the  greatest elements of the array as the denominators in the operations: suppose we haven't chosen one of them, but have chosen a lesser element as a denominator; if we swap them, the total score won't decrease.It is a bit harder to prove that the numerators of the fractions should be the next  greatest elements (the elements on positions from  to  in sorted order). It can be proved as follows: each fraction we will get in such a way rounds down to either  or to , and if we choose a lesser element as a numerator, we can decrease a fraction from  to , but we'll increase the sum of elements that remain in the array, so this is not optimal.All that's left is to pair the numerators and denominators. A fraction with numerator equal to denominator rounds down to , any other fraction will round down to , so our goal is to minimize the number of fractions having the numerator equal to the denominator. It can be done by pairing the numbers into fractions in the following way: , , ...,  (assuming  is sorted).So, the solution of the problem is the following: sort the array , then calculate .", "solution": "def solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    a = sorted(a)\n    cost = sum(a[0:n-2*k]) + sum(map(lambda x: a[x+n-2*k] // a[x+n-k], range(0, k)))\n    print(cost)\n    \nt = int(input())\nfor i in range(t):\n    solve()", "interactive": false, "noSolution": false, "noTutorial": false}