{"link": "https://codeforces.com//contest/1551/problem/C", "problemId": "1055222", "shortId": "1551C", "contest_number": "1551", "name": "C. Interesting Story", "statement": "Stephen Queen wants to write a story. He is a very unusual writer, he uses only letters '', '', '', '' and ''!To compose a story, Stephen wrote out  words consisting of the first  lowercase letters of the Latin alphabet. He wants to select the  number of  to make an  story.Let a story be a sequence of words that are not necessarily different. A story is called  if there exists a letter which occurs among all words of the story more times than all other letters together.For example, the story consisting of three words \"\", \"\", \"\" is interesting (the letter '' occurs  times, all other letters occur  times in total). But the story consisting of two words \"\", \"\" is not (no such letter that it occurs more than all other letters in total).You are given a sequence of  words consisting of letters '', '', '', '' and ''. Your task is to choose the maximum number of them to make an interesting story. If there's no way to make a non-empty story, output .", "input": "The first line contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of each test case contains one integer  () \u2014 the number of the words in the sequence. Then  lines follow, each of them contains a word \u2014 a non-empty string consisting of lowercase letters of the Latin alphabet. The words in the sequence may be non-distinct (i.\u2009e. duplicates are allowed). Only the letters '', '', '', '' and '' may occur in the words. It is guaranteed that the sum of  over all test cases doesn't exceed ; the sum of the lengths of all words over all test cases doesn't exceed .", "output": "For each test case, output the maximum number of words that compose an interesting story. Print  if there's no way to make a non-empty interesting story.", "tutorial": "Let  be the number of the occurrences of the letter  in the word  minus the number of the occurrences of all other letters in total. Since for each two words  and  the number of the occurrences of a letter in the word  is the sum of the numbers of its occurrences in  and , the equality  is true ( means the concatenation of  and ).Consider a sequence of words . A story consisting of words  is interesting if and only if there's a letter  such that  \u2014 it exactly means that there's a letter which occurs more times than all other in total. So we are interested in searching for a letter  such that exists a positive integer  \u2014 a maximal number of words  such that .Suppose we have a set of words that form an interesting story and where  is the letter having more occurrences than all other letters in total. Suppose we can add to it one of few words. We had better add a word  such that  is maximal to be able to add more words in the future.So the problem has the following solution: for each letter  of the Latin alphabet and for each word  let's calculate . Then let's iterate over all letters , take a sequence  and sort it in descending order. Let's initialize an interesting story by a set of a single word corresponding to the first element of the sequence. If there's no word  such that , then there's no non-empty interesting story containing some words of the given set. Otherwise, let's take the next elements of the sequence sequentially until the sum of  over all taken words  is greater than zero. Let's select a letter such that the corresponding taken set is maximal over all letters. Finally, we should print the set's size.The solution consists of two phases: the calculation of all  (works in  where  is the alphabet's size,  is the lengths of a string ) and building a maximal interesting story for each letter  (sorting and a greedy algorithm \u2014 ).", "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 2 * 100 * 1000 + 13;\nconst int L = 26;\n\nvector<int> balance[L];\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < L; i++)\n\t\t\tbalance[i].clear();\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tint initBalance = -(int)s.length();\n\t\t\tfor (int j = 0; j < L; j++)\n\t\t\t\tbalance[j].push_back(initBalance);\n\t\t\tfor (auto c : s)\n\t\t\t\tbalance[c - 'a'].back() += 2;\n\t\t}\n\t\tint bestCount = 0;\n\t\tint bestLetter = 0;\n\t\tfor (int i = 0; i < L; i++)\n\t\t{\n\t\t\tauto& b = balance[i];\n\t\t\tsort(b.begin(), b.end());\n\t\t\treverse(b.begin(), b.end());\n\t\t\tif (b[0] <= 0) continue;\n\t\t\tint sumBalance = b[0];\n\t\t\tint j = 1;\n\t\t\tfor (; j < n && sumBalance > 0; j++)\n\t\t\t\tsumBalance += b[j];\n\t\t\tif (sumBalance <= 0) j--;\n\t\t\tif (j > bestCount)\n\t\t\t{\n\t\t\t\tbestCount = j;\n\t\t\t\tbestLetter = i;\n\t\t\t}\n\t\t}\n\n\t\tcout << bestCount << endl;\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}