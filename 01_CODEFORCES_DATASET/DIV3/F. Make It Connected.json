{"link": "https://codeforces.com//contest/1095/problem/F", "problemId": "275106", "shortId": "1095F", "contest_number": "1095", "name": "F. Make It Connected", "statement": "You are given an undirected graph consisting of  vertices. A number is written on each vertex; the number on vertex  is . Initially there are no edges in the graph.You may add some edges to this graph, but you have to pay for them. The cost of adding an edge between vertices  and  is  coins. There are also  special offers, each of them is denoted by three numbers ,  and , and means that you can add an edge connecting vertices  and  and pay  coins for it. You don't have to use special offers: if there is a pair of vertices  and  that has a special offer associated with it, you still may connect these two vertices paying  coins for it.What is the minimum number of coins you have to spend to make the graph connected? Recall that a graph is connected if it's possible to get from any vertex to any other vertex using only the edges belonging to this graph.", "input": "The first line contains two integers  and  (, ) \u2014 the number of vertices in the graph and the number of special offers, respectively. The second line contains  integers  () \u2014 the numbers written on the vertices. Then  lines follow, each containing three integers ,  and  (, , ) denoting a special offer: you may add an edge connecting vertex  and vertex , and this edge will cost  coins.", "output": "Print one integer \u2014 the minimum number of coins you have to pay to make the graph connected.", "tutorial": "Suppose we have found all the edges of the graph explicitly, sorted them, and start running Kruskal on the sorted list of edges. Each time we add some edge to MST, it is either a special edge given in the input, or an edge which was generated with cost  (whichever costs less). Let's try to analyze how can we find the cheapest edge of each type that connects two components. For special edges, we may just maintain the number of special edges we already added or skipped, and when choosing a new edge, we skip some more (possibly zero) special edges that don't connect anything, until we find an edge that connects something. And for the other type of edges, we may find two components having minimum numbers on the vertices in those components as small as possible, and just connect the minimum vertex in the first component with the minimum vertex in the second component. We may simulate this by maintaining a data structure (for example, a multiset), where for each component we will store the vertex having minimum  in this component, and pick two minimums from this set. We also have to be able to check if two vertices are connected (this can be done with DSU) and merge two components.But this solution can be made easier. Every time we add a \"non-special\" edge, one of the ends of this edge is the vertex with minimum . So we may just find this vertex, generate all edges connecting this vertex to all other vertices, merge this set of edges with the set of special edges, and run any MST algorithm on the resulting set of edges. If there are multiple minimums in the array , then we may pick any of them because in Kruskal algorithm it doesn't matter which of the edges with equal costs we try to add first.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n\ntypedef pair<long long, pair<int, int> > edge;\n\nconst int N = 200043;\n\nint p[N];\nlong long a[N];\n\nint get_leader(int x)\n{\n\treturn (x == p[x] ? x : (p[x] = get_leader(p[x])));\n}\n\nbool merge(int x, int y)\n{\n\tx = get_leader(x);\n\ty = get_leader(y);\n\tif(x == y) return false;\n\tp[x] = y;\n\treturn true;\n}\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%lld\", &a[i]);\n\tvector<edge> es(m);\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tscanf(\"%d %d %lld\", &es[i].y.x, &es[i].y.y, &es[i].x);\n\t\tes[i].y.x--;\n\t\tes[i].y.y--;\n\t}\n\tint z = min_element(a, a + n) - a;\n\tfor(int i = 0; i < n; i++)\n\t\tif(i != z)\n\t\t\tes.push_back(mp(a[i] + a[z], mp(i, z)));\n\tsort(es.begin(), es.end());\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tp[i] = i;\n\tfor(auto e : es)\n\t\tif(merge(e.y.x, e.y.y))\n\t\t\tans += e.x;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\t\t\n}", "interactive": false, "noSolution": false, "noTutorial": false}