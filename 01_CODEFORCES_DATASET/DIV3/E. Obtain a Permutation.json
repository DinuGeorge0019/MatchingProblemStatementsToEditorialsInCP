{"link": "https://codeforces.com//contest/1294/problem/E", "problemId": "521711", "shortId": "1294E", "contest_number": "1294", "name": "E. Obtain a Permutation", "statement": "You are given a rectangular matrix of size  consisting of integers from  to .In one move, you can:  choose  of the matrix and change its value to  integer between  and , inclusive;  take  and shift it one cell up cyclically (see the example of such cyclic shift below). A cyclic shift is an operation such that you choose some  () and set  .  Example of cyclic shift of the first column You want to perform the minimum number of moves to make this matrix look like this:  In other words, the goal is to obtain the matrix, where  (i.e. ) with the  performed.", "input": "The first line of the input contains two integers  and  () \u2014 the size of the matrix. The next  lines contain  integers each. The number at the line  and position  is  ().", "output": "Print one integer \u2014 the minimum number of moves required to obtain the matrix, where  ().", "tutorial": "At first, let's decrease all elements by one and solve the problem in -indexation.The first observation is that we can solve the problem independently for each column.Consider the column  . It consists of elements . Now consider some element  . We don't need to replace it with some other number in only one case: if we shift the column such that  will coincide with the corresponding number of the required matrix. Obviously, there is only one cyclic shift of the column that can rid us of replacing . So, the idea is the following: let's calculate for each cyclic shift the number of elements we don't need to replace if we use this cyclic shift. Let for the -th cyclic shift (-indexed) it be . Then the answer for this column can be taken as .How to calculate for the element  the corresponding cyclic shift? Firstly, if  ( is modulo operation) then there is no such cyclic shift. Otherwise, let . If  then there is such cyclic shift ( can be greater than or equal to  because  can be up to ) and the number of such cyclic shift is . So let's increase  and continue. After considering all elements of this column take the answer by the formula above and go to the next column.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>> a(n, vector<int>(m));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t\t--a[i][j];\t\n\t\t}\n\t}\n\t\n\tlong long ans = 0;\n\tfor (int j = 0; j < m; ++j) {\n\t\tvector<int> cnt(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (a[i][j] % m == j) {\n\t\t\t\tint pos = a[i][j] / m;\n\t\t\t\tif (pos < n) {\n\t\t\t\t\t++cnt[(i - pos + n) % n];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cur = n - cnt[0];\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tcur = min(cur, n - cnt[i] + i);\n\t\t}\n\t\tans += cur;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}