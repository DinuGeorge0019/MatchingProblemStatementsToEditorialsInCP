{"link": "https://codeforces.com//contest/1003/problem/F", "problemId": "194986", "shortId": "1003F", "contest_number": "1003", "name": "F. Abbreviation", "statement": "You are given a text consisting of  space-separated words. There is exactly one space character between any pair of adjacent words. There are no spaces before the first word and no spaces after the last word. The length of text is the number of letters and spaces in it.  is the -th word of text. All words consist only of lowercase Latin letters.Let's denote a segment of words  as a sequence of words . Two segments of words  and  are considered  if , , , and for every  . For example, for the text \"\" the segments  and  are equal, they correspond to the words \"\".An abbreviation is a replacement of some segments of words with their first  letters. In order to perform an abbreviation, you have to choose  non-intersecting equal segments of words, and replace each chosen segment with the string consisting of first letters of the words in the segment (written in uppercase). For example, for the text \"\" you can replace segments of words  and  with an abbreviation \"\" and obtain the text \"\", or you can replace segments of words  and  with an abbreviation \"\" and obtain the text \"\".What is the minimum length of the text after at most one abbreviation?", "input": "The first line of the input contains one integer  () \u2014 the number of words in the text. The next line contains  space-separated words of the text . Each word consists only of lowercase Latin letters. It is guaranteed that the length of text does not exceed .", "output": "Print one integer \u2014 the minimum length of the text after at most one abbreviation.", "tutorial": "Let $$$eq_{i, j}$$$ equals true if words $$$s_i$$$ and $$$s_j$$$ are equal, otherwise it will be equals false. We can iterate over all pairs of words and compare they just using standard string comparator (constraints are really small so we can do it naively).The next step is to calculate dynamic programming $$$dp_{i, j}$$$, which will be equal to the maximum length of coinciding segments of words which starts in positions $$$i$$$ and $$$j$$$, respectively. In other words, if $$$dp_{i, j}$$$ equals $$$k$$$, then $$$s[i..i+k-1] = s[j..j+k-1]$$$, word by word. We can calculate this dynamic programming in reverse order ($$$i := n - 1 .. 0, j := n - 1 .. 0$$$) and $$$dp_{i, j} := 0$$$ if $$$s_i \\ne s_j$$$, else if $$$i < n - 1$$$ and $$$j < n - 1$$$, then $$$dp_{i, j} := dp_{i + 1, j + 1} + 1$$$, otherwise $$$dp_{i, j} := 1$$$.Let's keep the length of the text in the variable $$$allsum$$$. Then iterate over all starting positions of the possible abbreviation and all its possible lengths. Let the current starting position will be equals $$$i$$$ (0-indexed) and its length will be equal $$$j$$$. Then we need to calculate the number of possible replacements by its abbreviation. Let it be $$$cnt$$$ and now it equals $$$1$$$. Let's iterate over all positions $$$pos$$$, at the beginning $$$pos = i + j$$$ (0-indexed). If $$$dp_{i, pos} \\ge j$$$ then we can replace the segment of words which starts at the position $$$pos$$$ with its abbreviation, so $$$cnt := cnt + 1$$$ and $$$pos := pos + j$$$ (because we cannot replace intersecting segments), otherwise $$$pos := pos + 1$$$.After this we need to update the answer. The length of the segment of words $$$s[i..j]$$$ can be calculated easily, let it be $$$seglen$$$. Also let $$$segcnt$$$ be the number of words in the current segment of words. Then we can update the answer with the value $$$allsum - seglen * cnt + cnt * segcnt$$$.Overall complexity is $$$O(n^3 + n \\cdot \\sum\\limits_{i = 0}^{n - 1}|s_i|)$$$, where $$$|s_i|$$$ is the length of the $$$i$$$-th word.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 303;\n\nint n;\nbool eq[N][N];\nint dp[N][N];\nstring s[N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tint allsum = n - 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> s[i];\n\t\tallsum += s[i].size();\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\teq[i][i] = true;\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\teq[i][j] = eq[j][i] = s[i] == s[j];\n\t\t}\n\t}\n\t\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tif (eq[i][j]) {\n\t\t\t\tif (i + 1 < n && j + 1 < n)\n\t\t\t\t\tdp[i][j] = dp[i + 1][j + 1] + 1;\n\t\t\t\telse\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = allsum;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint sum = 0;\n\t\tfor (int j = 0; i + j < n; ++j) {\n\t\t\tsum += s[i + j].size();\n\t\t\tint cnt = 1;\n\t\t\tfor (int pos = i + j + 1; pos < n; ++pos) {\n\t\t\t\tif (dp[i][pos] > j) {\n\t\t\t\t\t++cnt;\n\t\t\t\t\tpos += j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cur = allsum - sum * cnt + (j + 1) * cnt - j * cnt;\n\t\t\tif (cnt > 1 && ans > cur) {\n\t\t\t\tans = cur;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}