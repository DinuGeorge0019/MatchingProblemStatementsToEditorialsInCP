{"link": "https://codeforces.com//contest/1015/problem/F", "problemId": "203552", "shortId": "1015F", "contest_number": "1015", "name": "F. Bracket Substring", "statement": "You are given a bracket sequence  (not necessarily a regular one). A bracket sequence is a string containing only characters '' and ''.A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters '' and '' between the original characters of the sequence. For example, bracket sequences \"\" and \"\" are regular (the resulting expressions are: \"\" and \"\"), and \"\", \"\" and \"\" are not.Your problem is to calculate the number of regular bracket sequences of length  containing the given bracket sequence  as a substring (consecutive sequence of characters) modulo  ().", "input": "The first line of the input contains one integer  () \u2014 the half-length of the resulting regular bracket sequences (the resulting sequences must have length equal to ). The second line of the input contains one string  () \u2014 the string  that should be a substring in each of the resulting regular bracket sequences ( is the length of ).", "output": "Print only one integer \u2014 the number of regular bracket sequences containing the given bracket sequence  as a substring. Since this number can be huge, print it modulo  ().", "tutorial": "At first, let's calculate the matrix  of size . Let  will denote the maximum length of the prefix of  which equals to the suffix of the prefix of  of length  with the additional character '' if  and '' otherwise. In other words,  is denote which maximum length of the prefix of  we can reach if now we have the prefix of  of length  and want to add the character '' if  and '' otherwise, and only one possible move is to remove characters from the beginning of this prefix with an additional character. This matrix can be easily calculated in  without any dynamic programming. It can be also calculated in  using prefix-function and dynamic programming.Now let's calculate the following dynamic programming . It means that now we have gained  characters of the regular bracket sequence, the balance of this sequence is , the last  characters of the gained prefix is the prefix of  of length  and  equals to  if we obtain the full string  at least once and  otherwise. The stored value of the  is the number of ways to reach this state.Initially, , all other values equal .The following recurrence works: try to add to the current prefix character '' if the current balance is less than , then we will move to the state .  is the length of  and  is  operation (if at least one is true then the result is true). Let's add to the number of ways to reach the destination state the number of ways to reach the current state.The same with the character ''. Try to add to the current prefix character '' if the current balance is greater than , then we will move to the state . Also add to the number of ways to reach the destination state the number of ways to reach the current state.After calculating this dynamic programming, the answer is .Time complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 203;\nconst int MOD = 1e9 + 7;\n\nint n, ssz;\nstring s;\nint len[N][2];\nint dp[N][N][N][2];\n\nint calc(const string &t) {\n\tint tsz = t.size();\n\tfor (int i = tsz; i > 0; --i) {\n\t\tif (s.substr(0, i) == t.substr(tsz - i, i))\n\t\t\treturn i;\n\t}\n\treturn 0;\n}\n\nvoid add(int &a, int b) {\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\tif (a < 0)\n\t\ta += MOD;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> s;\n\tssz = s.size();\n\t\n\tif (s[0] == '(')\n\t\tlen[0][0] = 1;\n\telse\n\t\tlen[0][1] = 1;\n\t\n\tstring pref;\n\tfor (int i = 0; i < ssz; ++i) {\n\t\tpref += s[i];\n\t\tpref += '(';\n\t\tlen[i + 1][0] = calc(pref);\n\t\tpref.pop_back();\n\t\tpref += ')';\n\t\tlen[i + 1][1] = calc(pref);\n\t\tpref.pop_back();\n\t}\n\t\n\tdp[0][0][0][0] = 1;\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tfor (int pos = 0; pos <= ssz; ++pos) {\n\t\t\t\tfor (int f = 0; f < 2; ++f) {\n\t\t\t\t\tif (dp[i][j][pos][f] == 0) continue;\n\t\t\t\t\tif (j + 1 <= n)\n\t\t\t\t\t\tadd(dp[i + 1][j + 1][len[pos][0]][f | (len[pos][0] == ssz)], dp[i][j][pos][f]);\n\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\tadd(dp[i + 1][j - 1][len[pos][1]][f | (len[pos][1] == ssz)], dp[i][j][pos][f]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i <= ssz; ++i)\n\t\tadd(ans, dp[2 * n][0][i][1]);\n\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}