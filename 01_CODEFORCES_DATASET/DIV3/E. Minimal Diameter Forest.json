{"link": "https://codeforces.com//contest/1092/problem/E", "problemId": "271424", "shortId": "1092E", "contest_number": "1092", "name": "E. Minimal Diameter Forest", "statement": "You are given a forest \u2014 an undirected graph with  vertices such that each its connected component is a tree.The diameter (aka \"longest shortest path\") of a connected undirected graph is the maximum number of edges in the  path between any pair of its vertices.You task is to add some edges (possibly zero) to the graph so that it becomes a tree and the diameter of the tree is minimal possible.If there are multiple correct answers, print any of them.", "input": "The first line contains two integers  and  (, ) \u2014 the number of vertices of the graph and the number of edges, respectively. Each of the next  lines contains two integers  and  (, ) \u2014 the descriptions of the edges. It is guaranteed that the given graph is a forest.", "output": "In the first line print the diameter of the resulting tree. Each of the next  lines should contain two integers  and  (, ) \u2014 the descriptions of the . The resulting graph should be a tree and its diameter should be minimal possible. For  no edges are added, thus the output consists of a single integer \u2014 diameter of the given tree. If there are multiple correct answers, print any of them.", "tutorial": "Let's start with the solution and then proceed to the proof.For each tree in a forest find such a vertex that the maximal distance from it to any vertex is minimal possible (a center of a tree). Tree may include two centers, take any of them in that case. Find the the tree with the maximum diameter. Connect the centers of other trees with its center.Overall complexity is the complexity of looking for a diameter:  or .  The center is the best vertex in a tree to connect to. The diameter of merging two trees  and  by  in  and  in  with  being the maximum shortest path from  to any other vertex in ,  being the same for  in  is . Thus minimizing both  and  will produce the best result.  The most optimal structure is a star. The center tree will be connected directly to any other tree. The other trees will be connected through a single vertex among each other, which leads to the answer no more than 1 worse than connecting them directly. And building the answer the other way will exceed this difference as some tree will be connected to the center tree of the star through one vertex as well.  The previous fact implies that the center tree of the star should have the maximal diameter among all trees. ", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int INF = 1000000000;\n\nint n, m;\nvector<int> g[N];\n\nint bfs(int x, int dist[N]){\n\tqueue<int> q;\n\tq.push(x);\n\tdist[x] = 0;\n\tint lst = -1;\n\twhile (!q.empty()){\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tlst = v;\n\t\tfor (auto u : g[v]) if (dist[u] > dist[v] + 1){\n\t\t\tdist[u] = dist[v] + 1;\n\t\t\tq.push(u);\n\t\t}\n\t}\n\treturn lst;\n}\n\nint distx[N], disty[N];\nbool used[N];\nvector<int> cur;\n\nvoid dfs(int v){\n\tused[v] = true;\n\tcur.push_back(v);\n\tfor (auto u : g[v]) if (!used[u])\n\t\tdfs(u);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tforn(i, m){\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\t\n\tforn(i, n) distx[i] = disty[i] = INF;\n\t\n\tvector<pair<int, int>> comps;\n\tforn(i, n) if (!used[i]){\n\t\tcur.clear();\n\t\tdfs(i);\n\t\tint x = bfs(i, distx);\n\t\tint y = bfs(x, disty);\n\t\tfor (auto v : cur) distx[v] = INF;\n\t\tbfs(y, distx);\n\t\tint d = disty[y], center;\n\t\tfor (auto v : cur) if (distx[v] == d / 2 && disty[v] == d - d / 2)\n\t\t\tcenter = v;\n\t\tcomps.push_back({d, center});\n\t}\n\t\n\tvector<pair<int, int>> ans;\n\tnth_element(comp.begin(), comp.end() - 1, comp.end());\n\tforn(i, int(comps.size()) - 1){\n\t\tg[comps[i].second].push_back(comps.back().second);\n\t\tg[comps.back().second].push_back(comps[i].second);\n\t\tans.push_back({comps[i].second, comps.back().second});\n\t}\n\t\n\tforn(i, n) distx[i] = disty[i] = INF;\n\tint y = bfs(bfs(comps.back().second, distx), disty);\n\t\n\tprintf(\"%d\\n\", disty[y]);\n\tfor (auto it : ans)\n\t\tprintf(\"%d %d\\n\", it.first + 1, it.second + 1);\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}