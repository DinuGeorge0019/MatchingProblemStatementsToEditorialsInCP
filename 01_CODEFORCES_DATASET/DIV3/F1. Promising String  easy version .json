{"link": "https://codeforces.com//contest/1660/problem/F1", "problemId": "1349760", "shortId": "1660F1", "contest_number": "1660", "name": "F1. Promising String  easy version ", "statement": "We will call a non-empty string  if it contains the same number of plus and minus signs. For example: strings \"\" and \"\" are balanced, and strings \"\", \"\" and \"\" are not balanced.We will call a string  if the string can be made balanced by several (possibly zero) uses of the following operation:  replace two  minus signs with one plus sign. In particular, every balanced string is promising. However, the converse is not true: not every promising string is balanced.For example, the string \"\" is promising, because you can replace two adjacent minuses with plus and get a balanced string \"\", or get another balanced string \"\".How many non-empty substrings of the given string  are promising? Each non-empty promising substring must be counted in the answer as many times as it occurs in string .Recall that a substring is a sequence of consecutive characters of the string. For example, for string \"\" its substring are: \"\", \"\", \"\", \"\" (the string is a substring of itself) and some others. But the following strings are not its substring: \"\", \"\", \"\".", "input": "The first line of the input contains an integer  ()\u00a0\u2014the number of test cases in the test. Then the descriptions of test cases follow. Each test case of input data consists of two lines. The first line consists of the number  (): the length of . The second line of the test case contains the string  of length , consisting only of characters \"\" and \"\". It is guaranteed that the sum of values  over all test cases does not exceed .", "output": "For each test case, print a single number: the number of the promising non-empty substrings of string . Each non-empty promising substring must be counted in the answer as many times as it occurs in string .", "tutorial": "Note the fact that if the number of minus signs is greater than the number of plus signs by at least , then there is sure to be a pair of standing next to minus signs (according to the Dirichlet principle). When we apply the operation of replacing two adjacent minus signs with a plus sign, the balance (the difference of plus signs and minus signs) increases by . Then we need to find the number of subsections such that the balance on them is a multiple of  and non-positive (then we can apply the operations until the balance is ). The balance value on the segment equals the balance value on the right boundary minus the balance value on the left boundary, i.e. we can find  by prefix sums.", "solution": "tst = int(input())\nfor _ in range(tst):\n    n = int(input())\n    s = input()\n    b = [0 for i in range(n+1)]\n    bal = n\n    b[0] = bal\n    ans = 0\n    for i in range(1,n+1):\n        if s[i-1] == '+':\n            bal += 1\n        else:\n            bal -= 1\n        b[i] = bal\n        for j in range(i):\n            if b[j] >= b[i] and (b[j] - b[i]) % 3 == 0:\n                ans += 1\n    print(ans)", "interactive": false, "noSolution": false, "noTutorial": false}