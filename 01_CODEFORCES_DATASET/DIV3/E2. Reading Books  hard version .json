{"link": "https://codeforces.com//contest/1374/problem/E2", "problemId": "659589", "shortId": "1374E2", "contest_number": "1374", "name": "E2. Reading Books  hard version ", "statement": ".Summer vacation has started so Alice and Bob want to play and joy, but... Their mom doesn't think so. She says that they have to read   books before all entertainments. Alice and Bob will read each book  to end this exercise faster.There are  books in the family library. The -th book is described by three integers:  \u2014 the amount of time Alice and Bob need to spend to read it,  (equals  if Alice likes the -th book and  if not), and  (equals  if Bob likes the -th book and  if not).So they need to choose   books from the given  books in such a way that:  Alice likes   books from the chosen set and Bob likes   books from the chosen set;  the total reading time of these  books is  (they are children and want to play and joy as soon a possible). The set they choose is  for both Alice an Bob (it's shared between them) and they read all books , so the total reading time is the sum of  over all books that are in the chosen set.Your task is to help them and find any suitable set of books or determine that it is impossible to find such a set.", "input": "The first line of the input contains three integers ,  and  (). The next  lines contain descriptions of books, one description per line: the -th line contains three integers ,  and  (, ), where:    \u2014 the amount of time required for reading the -th book;   equals  if Alice likes the -th book and  otherwise;   equals  if Bob likes the -th book and  otherwise. ", "output": "If there is no solution, print only one integer . If the solution exists, print  in the first line \u2014 the minimum total reading time of the suitable set of books. In the second line print  distinct integers from  to  in any order \u2014 indices of books which are in the set you found. If there are several answers, print any of them.", "tutorial": "A little explanation: this editorial will be based on the easy version editorial so I'll use some definitions from it.Here we go, the most beautiful problem of the contest is waiting us.Well, the key idea of this problem almost the same with the easy version idea. Let's iterate over the number of elements in -group, we need to take the cheapest ones again. If the number of elements we take from -group is  then we need to take  elements from  and -groups. But one more thing: let's iterate over  not from zero but from the smallest possible number which can give us any correct set of books (the numeric value of the answer doesn't matter) . The value of  can be calculated using  and sizes of groups by formula or even simple loop. If we can't find any suitable value of , the answer is .Let's call  elements from -group and  elements from  and -groups we take . Other elements of the whole set of books are  (but  - ). Let's create the set  which contains all free elements (and fill it beforehand). So, now we took some necessary elements, but we need to take some free elements to complete our set. Let's create the other set  which contains free elements we take to the answer (and maintain the variable  describing the sum of elements of ). How do we recalculate ? Before the start of the first iteration our set  is already filled with some elements, let's update  using them.Update is such an operation (function) that tosses the elements between  and . It will do the following things (repeatedly, and stop when it cannot do anything):  While the size of  is greater than needed (so we take more than  books in total), let's remove the most expensive element from  and add it to ;  while the size of  is less than needed (so we take less than  books in total), let's remove the cheapest element from  and add it to ;  while the cheapest element from  is cheaper than the most expensive element form , let's swap them. Note that during updates you need to recalculate  as well.So, we go over all possible values , updating  before the first iteration and after each iteration. The size of both sets changes pretty smooth: if we go from  to , we need to remove at most one element from  (because we take one element from -group during each iteration) and we need to add at most two elements to  and  (because we remove at most two elements from  and -groups during one iteration).To restore the answer, let's save such a value  that the answer is minimum with this value  (let it be ). Then let's just run the same simulation once more from the beginning but stop when we reach . Then  will contain free elements we need to take to the answer,  describes the number of elements we need to take from -group and  describes which elements from  and -groups we need to take.Of course, there are some really tough technical things like case-handling (there is a lot of cases, for example, the size of  can be negative at some moment and you need to carefully handle that, and  can be negative after some number of iterations and there are other cases because of that, and so on).Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 2e9 + 1;\n\n#define size(a) int((a).size())\n\nvoid updateSt(set<pair<int, int>> &st, set<pair<int, int>> &fr, int &sum, int need) {\n\tneed = max(need, 0);\n\twhile (true) {\n\t\tbool useful = false;\n\t\twhile (size(st) > need) {\n\t\t\tsum -= st.rbegin()->first;\n\t\t\tfr.insert(*st.rbegin());\n\t\t\tst.erase(prev(st.end()));\n\t\t\tuseful = true;\n\t\t}\n\t\twhile (size(st) < need && size(fr) > 0) {\n\t\t\tsum += fr.begin()->first;\n\t\t\tst.insert(*fr.begin());\n\t\t\tfr.erase(fr.begin());\n\t\t\tuseful = true;\n\t\t}\n\t\twhile (!st.empty() && !fr.empty() && fr.begin()->first < st.rbegin()->first) {\n\t\t\tsum -= st.rbegin()->first;\n\t\t\tsum += fr.begin()->first;\n\t\t\tfr.insert(*st.rbegin());\n\t\t\tst.erase(prev(st.end()));\n\t\t\tst.insert(*fr.begin());\n\t\t\tfr.erase(fr.begin());\n\t\t\tuseful = true;\n\t\t}\n\t\tif (!useful) break;\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<pair<int, int>> times[4];\n\tvector<int> sums[4];\n\tfor (int i = 0; i < n; ++i) {\n\t\tint t, a, b;\n\t\tcin >> t >> a >> b;\n\t\ttimes[a * 2 + b].push_back({t, i});\n\t}\n\tfor (int i = 0; i < 4; ++i) {\n\t\tsort(times[i].begin(), times[i].end());\n\t\tsums[i].push_back(0);\n\t\tfor (auto it : times[i]) {\n\t\t\tsums[i].push_back(sums[i].back() + it.first);\n\t\t}\n\t}\n\t\n\tint ans = INF;\n\tint pos = INF;\n\tset<pair<int, int>> st;\n\tset<pair<int, int>> fr;\n\tint sum = 0;\n\tvector<int> res;\n\tfor (int iter = 0; iter < 2; ++iter) {\n\t\tst.clear();\n\t\tfr.clear();\n\t\tsum = 0;\n\t\tint start = 0;\n\t\twhile (k - start >= size(sums[1]) || k - start >= size(sums[2]) || m - start - (k - start) * 2 < 0) {\n\t\t\t++start;\n\t\t}\n\t\tif (start >= size(sums[3])) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint need = m - start - (k - start) * 2;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tfor (int p = size(times[i]) - 1; p >= (i == 0 ? 0 : k - start); --p) {\n\t\t\t\tfr.insert(times[i][p]);\n\t\t\t}\n\t\t}\n\t\tupdateSt(st, fr, sum, need);\n\t\tfor (int cnt = start; cnt < (iter == 0 ? size(sums[3]) : pos); ++cnt) {\n\t\t\tif (k - cnt >= 0) {\t\n\t\t\t\tif (cnt + (k - cnt) * 2 + size(st) == m) {\n\t\t\t\t\tif (ans > sums[3][cnt] + sums[1][k - cnt] + sums[2][k - cnt] + sum) {\n\t\t\t\t\t\tans = sums[3][cnt] + sums[1][k - cnt] + sums[2][k - cnt] + sum;\n\t\t\t\t\t\tpos = cnt + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (cnt + size(st) == m) {\n\t\t\t\t\tif (ans > sums[3][cnt] + sum) {\n\t\t\t\t\t\tans = sums[3][cnt] + sum;\n\t\t\t\t\t\tpos = cnt + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iter == 1 && cnt + 1 == pos) break;\n\t\t\tneed -= 1;\n\t\t\tif (k - cnt > 0) {\n\t\t\t\tneed += 2;\n\t\t\t\tfr.insert(times[1][k - cnt - 1]);\n\t\t\t\tfr.insert(times[2][k - cnt - 1]);\n\t\t\t}\n\t\t\tupdateSt(st, fr, sum, need);\n\t\t}\n\t\tif (iter == 1) {\n\t\t\tfor (int i = 0; i + 1 < pos; ++i) res.push_back(times[3][i].second);\n\t\t\tfor (int i = 0; i <= k - pos; ++i) {\n\t\t\t\tres.push_back(times[1][i].second);\n\t\t\t\tres.push_back(times[2][i].second);\n\t\t\t}\n\t\t\tfor (auto [value, position] : st) res.push_back(position);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tfor (auto it : res) cout << it + 1 << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}