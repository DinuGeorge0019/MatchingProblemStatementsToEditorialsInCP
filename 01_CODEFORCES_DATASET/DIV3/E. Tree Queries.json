{"link": "https://codeforces.com//contest/1328/problem/E", "problemId": "573971", "shortId": "1328E", "contest_number": "1328", "name": "E. Tree Queries", "statement": "You are given a rooted tree consisting of  vertices numbered from  to . The root of the tree is a vertex number .A tree is a connected undirected graph with  edges.You are given  queries. The -th query consists of the set of  distinct vertices . Your task is to say if there is a path from the root to some vertex  such that each of the given  vertices is either belongs to this path or has the distance  to some vertex of this path.", "input": "The first line of the input contains two integers  and  (, ) \u2014 the number of vertices in the tree and the number of queries. Each of the next  lines describes an edge of the tree. Edge  is denoted by two integers  and , the labels of vertices it connects ). It is guaranteed that the given edges form a tree. The next  lines describe queries. The -th line describes the -th query and starts with the integer  () \u2014 the number of vertices in the current query. Then  integers follow:  (), where  is the -th vertex of the -th query. It is guaranteed that all vertices in a single query are distinct. It is guaranteed that the sum of  does not exceed  ().", "output": "For each query, print the answer \u2014 \"\", if there is a path from the root to some vertex  such that each of the given  vertices is either belongs to this path or has the distance  to some vertex of this path and \"\" otherwise.", "tutorial": "Firstly, let's choose some deepest (farthest from the root) vertex  in the query (among all such vertices we can choose any). It is obvious that every vertex in the query should either belong to the path from the root to  or the distance to some vertex of this path should be at most one. Now there are two ways: write some LCA algorithms and other hard stuff which is unnecessary in this problem or write about  lines of code and solve the problem.Let's take every non-root vertex (except ) and replace it with its parent. So, what's next? Now the answer is \"\" if  vertex (after transformation) belongs to the path from root to . Now we just need to check if it is true.We can do this using the very standard technique: firstly, let's run dfs from the root and calculate for each vertex the first time we visited it () and the last time we visited it ().We can do this using the following code: void dfs(int v, int par = -1) {    tin[v] = T++;    for (auto to : g[v]) {        if (to == par) continue;        dfs(to, v);    }    tout[v] = T++;}Initially,  equals zero. Now we have a beautiful structure giving us so much information about the tree. Consider all segments . We can see that there is no pair of intersecting segments. The pair of segments  and  is either non-intersecting at all or one segment lies inside the other one. The second beautiful fact is that for each vertex  in the subtree of  the segment  lies inside the segment .So, we can check if one vertex is the parent of the other: the vertex  is the parent of the vertex  if and only if  and  (the vertex is the parent of itself).How do we check if the vertex  lies on the path from the root to the vertex ? It lies on this path if the root is the parent of  (it is always true) and  is the parent of . This approach can be used for each  path (such a path from  to  that  is either  or ).Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T;\nvector<int> p, d;\nvector<int> tin, tout;\nvector<vector<int>> g;\n\nvoid dfs(int v, int par = -1, int dep = 0) {\n\tp[v] = par;\n\td[v] = dep;\n\ttin[v] = T++;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) continue;\n\t\tdfs(to, v, dep + 1);\n\t}\n\ttout[v] = T++;\n}\n\nbool isAnc(int v, int u) {\n\treturn tin[v] <= tin[u] && tout[u] <= tout[v];\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tT = 0;\n\tp = d = vector<int>(n);\n\ttin = tout = vector<int>(n);\n\tg = vector<vector<int>>(n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tdfs(0);\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tint k;\n\t\tcin >> k;\n\t\tvector<int> v(k);\n\t\tfor (auto &it : v) {\n\t\t\tcin >> it;\n\t\t\t--it;\n\t\t}\n\t\t\n\t\tint u = v[0];\n\t\tfor (auto it : v) if (d[u] < d[it]) u = it;\n\t\tfor (auto &it : v) {\n\t\t\tif (it == u) continue;\n\t\t\tif (p[it] != -1) it = p[it];\n\t\t}\n\t\tbool ok = true;\n\t\tfor (auto it : v) ok &= isAnc(it, u);\n\t\tif (ok) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}