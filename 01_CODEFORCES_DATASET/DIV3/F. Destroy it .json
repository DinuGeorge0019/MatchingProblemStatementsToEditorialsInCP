{"link": "https://codeforces.com//contest/1176/problem/F", "problemId": "356088", "shortId": "1176F", "contest_number": "1176", "name": "F. Destroy it ", "statement": "You are playing a computer card game called Splay the Sire. Currently you are struggling to defeat the final boss of the game.The boss battle consists of  turns. During each turn, you will get several cards. Each card has two parameters: its cost  and damage . You may play some of your cards during each turn in some sequence (you choose the cards and the exact order they are played), as long as . After playing some (possibly zero) cards, you end your turn, and . Note that you can use each card .Your character has also found an artifact that boosts the damage of some of your actions: every -th card you play deals double damage.What is the maximum possible damage you can deal during  turns?", "input": "The first line contains one integer  () \u2014 the number of turns. Then  blocks of input follow, the -th block representing the cards you get during the -th turn. Each block begins with a line containing one integer  () \u2014 the number of cards you get during -th turn. Then  lines follow, each containing two integers  and  (, ) \u2014 the parameters of the corresponding card. It is guaranteed that .", "output": "Print one integer \u2014 the maximum damage you may deal.", "tutorial": "The first (and crucial) observation is that we don't need all the cards that we get during each turn. In fact, since the total cost is limited to , we may leave three best cards of cost , one best card of cost  and one best card of cost , and all other cards may be discarded. So, the problem is reduced: we get only  cards each turn.The problem may be solved with dynamic programming:  is the maximum damage we may deal if we played  turns and the last card we played had remainder  modulo . Processing each turn may be done with auxiliary dp:  \u2014 the maximum damage we can deal during the turn if we play  cards, and  denotes whether some card (there will be only one such card, obviously) deals double damage. To calculate this auxiliary dp, we may do almost anything since we are limited to  cards during each turn. It is possible to calculate it in a fast way using some casework, but it is easier, for example, to try all possible permutations of  cards and play some prefix of a fixed permutation.By combining these two techniques, we get a solution.", "solution": "#define _CRT_SECURE_NO_WARNINGS\n\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nconst int N = 200043;\nvector<int> cards[N][4];\nli dp[N][10];\nint n;\nli dp2[4][2];\n\nint main()\n{\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tfor(int i = 0; i < N; i++)\n\t\tfor(int j = 0; j < 10; j++)\n\t\t\tdp[i][j] = -INF64;\n\tdp[0][0] = 0;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c, d;\n\t\t\tscanf(\"%d %d\", &c, &d);\n\t\t\tcards[i][c].push_back(d);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 1; j <= 3; j++)\n\t\t{\n\t\t\tint s = (j == 1 ? 3 : 1);\n\t\t\tsort(cards[i][j].begin(), cards[i][j].end());\n\t\t\treverse(cards[i][j].begin(), cards[i][j].end());\n\t\t\twhile (cards[i][j].size() > s)\n\t\t\t\tcards[i][j].pop_back();\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < 4; j++)\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\tdp2[j][k] = -INF64;\n\t\tdp2[0][0] = 0;\n\t\tvector<pair<int, int> > cur;\n\t\tfor (int j = 1; j <= 3; j++)\n\t\t\tfor (auto x : cards[i][j])\n\t\t\t\tcur.push_back(make_pair(j, x));\n\t\tsort(cur.begin(), cur.end());\n\t\tdo\n\t\t{\n\t\t\tint mana = 3;\n\t\t\tli score = 0;\n\t\t\tli mx = 0;\n\t\t\tint cnt = 0;\n\t\t\tfor (auto x : cur)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tif (mana < x.first)\n\t\t\t\t\tbreak;\n\t\t\t\tmana -= x.first;\n\t\t\t\tmx = max(mx, li(x.second));\n\t\t\t\tscore += x.second;\n\t\t\t\tdp2[cnt][0] = max(dp2[cnt][0], score);\n\t\t\t\tdp2[cnt][1] = max(dp2[cnt][1], score + mx);\n\t\t\t}\n\t\t} while (next_permutation(cur.begin(), cur.end()));\n\t\tfor(int j = 0; j < 10; j++)\n\t\t\tfor (int k = 0; k <= 3; k++)\n\t\t\t{\n\t\t\t\tint nxt = (j + k) % 10;\n\t\t\t\tint f = (j + k >= 10 ? 1 : 0);\n\t\t\t\tdp[i + 1][nxt] = max(dp[i + 1][nxt], dp[i][j] + dp2[k][f]);\n\t\t\t}\n\t}\n\tli ans = 0;\n\tfor (int i = 0; i <= 9; i++)\n\t\tans = max(ans, dp[n][i]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}