{"link": "https://codeforces.com//contest/1328/problem/C", "problemId": "573969", "shortId": "1328C", "contest_number": "1328", "name": "C. Ternary XOR", "statement": "A number is  if it contains only digits ,  and . For example, the following numbers are ternary: , , , .You are given a long ternary number . The first (leftmost) digit of  is guaranteed to be , the other digits of  can be ,  or .Let's define the ternary XOR operation  of two ternary numbers  and  (both of length ) as a number  of length , where  (where  is modulo operation). In other words, add the corresponding digits and take the remainders of the sums when divided by . For example, .Your task is to find such ternary numbers  and  both of length  and both without leading zeros that  and  is the minimum possible.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the length of . The second line of the test case contains ternary number  consisting of  digits  or . It is guaranteed that the first digit of  is . It is guaranteed that the sum of  over all test cases does not exceed  ().", "output": "For each test case, print the answer \u2014 two ternary integers  and  both of length  and both without leading zeros such that  and  is the minimum possible. If there are several answers, you can print any.", "tutorial": "Let's iterate from left to right over the digits of . If the current digit is either  or  then we can set  or  correspondingly. There are no better choices. And if the current digit  is  then the optimal choise is to set  and . What happens after the first occurrence of ? Because of this choice  is greater than  even if all remaining digits in  are . So for each  set  and  and print the answer. The case without  is even easier and in fact we handle it automatically.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tstring x;\n\t\tcin >> n >> x;\n\t\tstring a(n, '0'), b(n, '0');\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (x[i] == '1') {\n\t\t\t\ta[i] = '1';\n\t\t\t\tb[i] = '0';\n\t\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\t\tb[j] = x[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ta[i] = b[i] = '0' + (x[i] - '0') / 2;\n\t\t\t}\n\t\t}\n\t\tcout << a << endl << b << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}