{"link": "https://codeforces.com//contest/1650/problem/G", "problemId": "1321166", "shortId": "1650G", "contest_number": "1650", "name": "G. Counting Shortcuts", "statement": "Given an undirected connected graph with  vertices and  edges. The graph contains no loops (edges from a vertex to itself) and multiple edges (i.e. no more than one edge between each pair of vertices). The vertices of the graph are numbered from  to . Find the number of paths from a vertex  to  whose length differs from the shortest path from  to  by no more than . It is necessary to consider all suitable paths, even if they pass through the same vertex or edge more than once (i.e. they are not simple).     For example, let , ,  and , and let the graph look like the figure above. Then the length of the shortest path from  to  is . Consider all paths whose length is at most .   . The length of the path is .  . Path length is .  . Path length is .  . Path length is . There is a total of  of matching paths.", "input": "The first line of test contains the number  ()\u00a0\u2014the number of test cases in the test. Before each test case, there is a blank line.  The first line of test case contains two numbers  (, )\u00a0\u2014the number of vertices and edges in the graph.  The second line contains two numbers  and  (, )\u00a0\u2014the numbers of the start and end vertices of the path. The following  lines contain descriptions of edges: the th line contains two integers ,  ()\u00a0\u2014 the numbers of vertices that connect the th edge. It is guaranteed that the graph is connected and does not contain loops and multiple edges. It is guaranteed that the sum of values  on all test cases of input data does not exceed . Similarly, it is guaranteed that the sum of values  on all test cases of input data does not exceed .", "output": "For each test case, output a single number\u00a0\u2014 the number of paths from  to  such that their length differs from the length of the shortest path by no more than . Since this number may be too large, output it modulo .", "tutorial": "Note that in any shortest path, we cannot return to the previous vertex. Since if the current vertex , the previous . The current distance  (the shortest distance to vertex ), the shortest distance to vertex \u00a0\u2014 . Then, if we return to the vertex , the shortest distance from it to  is . If we add to the current distance, we get: . Thus, we get a path at least  longer than the shortest one. Thus, our answer consists of only simple paths.If the answer consists only of simple paths, then we will simply add vertices to the queue when traversing bfs twice (on the first visit, and on the next visit, when the distance to the vertex is equal to the shortest ). And we will also count the number of ways to get to that vertex. Then we can output the answer as soon as we get to the vertex  the second time for processing. After that we can terminate the loop. The asymptotic will be  since we only need bfs.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define sz(v) (int)v.size()\n#define eb emplace_back\n#define mt make_tuple\n\nconst int INF = INT_MAX >> 1;\nconst int mod = 1e9 + 7;\n\nvoid csum(int &a,int b) {\n    a = (a + b) % mod;\n}\n\nint s, t;\nvector<int> us;\nvector<int> dist;\nvector<int> dp[2];\nint bfs(vector<vector<int>> &g) {\n    queue<tuple<int,int,int>> q;\n    q.push(mt(s, 0, 0)); //[v, dist, count]\n\n    int ans = 0, mnd = INF;\n    us[s] = 1;\n    dp[0][s] = 1;\n    dist[s] = 0;\n    while(!q.empty()) {\n        auto [v,d, x] = q.front(); q.pop();\n        // cerr << v << ' ' << d << ' ' << dp[x][v] << endl;\n        if (v == t) {\n            if (mnd == INF) {\n                mnd = d;\n            }\n            csum(ans, dp[x][v]);\n        }\n        if (d == mnd + 1) continue;\n        for (int to : g[v]) if(d <= dist[to]) {\n            dist[to] = min(dist[to], d+1);\n            csum(dp[d - dist[to] + 1][to], dp[x][v]);\n            // cerr << \"TO: \" <<  to << ' ' << dist[to] << ' ' << d << endl;\n            if(us[to] == 0 || (us[to] == 1 && dist[to] == d)) q.push(mt(to, d+1, us[to]++));\n        }\n    }\n    return ans;\n}\n\n\nvoid solve() {\n    int n,m; cin >> n >> m;\n    cin >> s >> t;\n    us.resize(n+1);\n    dp[0].resize(n+1);\n    dp[1].resize(n+1);\n    dist.resize(n+1);\n    forn(i, n+1) {\n        us[i] = dp[0][i] = dp[1][i] = 0;\n        dist[i] = INF;\n    }\n\n    vector<vector<int>> g(n+1);\n    forn(i, m) {\n        int a,b; cin >> a >> b;\n        g[a].eb(b);\n        g[b].eb(a);\n    }\n\n    cout << bfs(g) << '\\n';\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    forn(tt, t) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}