{"link": "https://codeforces.com//contest/1547/problem/F", "problemId": "1041930", "shortId": "1547F", "contest_number": "1547", "name": "F. Array Stabilization  GCD version ", "statement": "You are given an array of positive integers  ().In one step, the array  is replaced with another array of length , in which each element is the greatest common divisor (GCD) of two neighboring elements (the element itself and its right neighbor; consider that the right neighbor of the -th element is the -th element).Formally speaking, a new array  is being built from array  such that  , where  is the greatest common divisor of  and , and  is the remainder of  dividing by . In one step the array  is built and then the array  is replaced with  (that is, the assignment    is taking place).For example, if  then , , ,  . Thus, after one step the array  will be equal to .For a given array , find the minimum number of steps after which all values  become equal (that is, ). If the original array  consists of identical elements then consider the number of steps is equal to .", "input": "The first line contains an integer  (). Then  test cases follow. Each test case contains two lines. The first line contains an integer  () \u2014 length of the sequence . The second line contains  integers  (). It is guaranteed that the sum of  over all test cases doesn't exceed .", "output": "Print  numbers \u2014 answers for each test case.", "tutorial": "First, note that the array stabilizes if and only if it consists of equal elements, and the number the array  will be consisted of is . Indeed, at the -th step a number equal to  will be written at the -th position in the array.This is easy to prove by induction: if at the previous step the adjacent elements in the array were equal to  of the numbers on adjacent segments of length  in the original array, then their greatest common divisor will be the greatest common divisor of the union of these two segments (GCD is an idempotent operation).Thus, the algorithm will stop in no more than  steps, since after  steps all numbers will be equal exactly to . If we divide all the numbers  by  before starting the algorithm, then the number of steps won't change, but the array will stabilize at the number .Since the numbers in the array after the -th step will be exactly equal to  of all segments of length  of the original array , it follows that the number of steps after which all values become the same is exactly equal to the length of the maximum segment of the original array on which .There are several ways to find the length of such a segment. For example, you can use range GCD query and binary search. The following method is based on the factorization of numbers, in other words, on their decomposition into prime factors. Factorization in this problem could be done using both the sieve of Eratosthenes or factoring each number independently in .After all the numbers have been factorized, iterate over each  and each prime  in its factorization. In linear time we can go left and right from , finding the maximum segment of numbers that contain the same factor . Then we can update the answer with the length of this segment and move onto the next prime in the factorization of  or go to , if all primes have already been iterated through.Note that if a segment of numbers divisible by  contains indices from  to , then we iterate through it  times. In order to avoid reiteration on each segment, we remove  from the factorizations of all numbers on the segment after considering only one.The resulting solution works in , where \u00a0\u2014 the maximum number of different primes in factoriztion of . Considering that , , so the solution fits into the time limit.", "solution": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst unsigned int MAX_A = 1'000'000;\nvector<unsigned int> sieve(MAX_A + 1);\nvector<unsigned int> prime;\n\nunsigned int gcd(unsigned int a, unsigned int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nunsigned int solve() {\n\n    unsigned int n;\n    cin >> n;\n    vector<unsigned int> a(n);\n    for (unsigned int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    unsigned int common = a[0];\n    vector<set<unsigned int>> facts(n);\n    for (unsigned int i = 1; i < n; i++) {\n        common = gcd(common, a[i]);\n    }\n    for (unsigned int i = 0; i < n; i++) {\n        unsigned int t = a[i] / common;\n        while (t != 1) {\n            facts[i].insert(sieve[t]);\n            t /= sieve[t];\n        }\n    }\n\n    unsigned int answer = 0;\n    for (unsigned int i = 0; i < n; i++) {\n        for (unsigned int p : facts[i]) {\n            int l = (i + n - 1) % n, r = i;\n            unsigned int cnt = 0;\n            while (facts[l].count(p) > 0) {\n                facts[l].erase(p);\n                l--; cnt++;\n                if (l < 0) {\n                    l = n - 1;\n                }\n            }\n            while (facts[r].count(p) > 0) {\n                if (r != i) {\n                    facts[r].erase(p);\n                }\n                ++r %= n; cnt++;\n            }\n            answer = max(answer, cnt);\n        }\n        facts[i].clear();\n    }\n\n    return answer;\n\n}\n\nint main() {\n\n    sieve[1] = 1;\n    for (unsigned int i = 2; i <= MAX_A; i++) {\n        if (sieve[i] == 0) {\n            sieve[i] = i;\n            prime.push_back(i);\n        }\n        for (unsigned int j = 0; j < prime.size() && prime[j] <= sieve[i] && i * prime[j] <= MAX_A; j++) {\n            sieve[i * prime[j]] = prime[j];\n        }\n    }\n\n    unsigned int t;\n    cin >> t;\n    for (unsigned int i = 0; i < t; i++) {\n        cout << solve() << '\\n';\n    }\n\n}", "interactive": false, "noSolution": false, "noTutorial": false}