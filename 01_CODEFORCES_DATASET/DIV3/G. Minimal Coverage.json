{"link": "https://codeforces.com//contest/1579/problem/G", "problemId": "1123873", "shortId": "1579G", "contest_number": "1579", "name": "G. Minimal Coverage", "statement": "You are given  lengths of segments that need to be placed on an infinite axis with coordinates.The first segment is placed on the axis so that one of its endpoints lies at the point with coordinate . Let's call this endpoint the \"\" of the first segment and let's call its \"\" as that endpoint that is not the start. The \"start\" of each following segment must coincide with the \"end\" of the previous one. Thus, if the length of the next segment is  and the \"end\" of the previous one has the coordinate , the segment can be placed either on the coordinates , and then the coordinate of its \"end\" is , or on the coordinates , in which case its \"end\" coordinate is .The total  of the axis by these segments is defined as their overall union which is basically the set of points covered by at least one of the segments. It's easy to show that the coverage will also be a segment on the axis. Determine the minimal possible length of the coverage that can be obtained by placing all the segments on the axis without changing their order.", "input": "The first line contains an integer  ()\u00a0\u2014 the number of test cases. The next  lines contain descriptions of the test cases.  The first line of each test case description contains an integer  ()\u00a0\u2014 the number of segments. The second line of the description contains  space-separated integers  ()\u00a0\u2014 lengths of the segments in the same order they should be placed on the axis. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "Print  lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer\u00a0\u2014 the minimal possible length of the axis coverage.", "tutorial": "One possible solution involves the method of dynamic programming. As a state of DP we will use the number of already placed segments , and the distance  from the \"end\" of the last segment to the current left boundary of the coverage, and in the DP we will store the minimal possible distance from the \"end\" of the last segment to the current right boundary of the coverage.We can prove that the answer never exceeds , where  is the maximal length of the segments. To do this, let us define a region of length , specifically the segment . If the \"end\" of the last segment has a coordinate , we put the next segment to the left, otherwise, we put it to the right. With this algorithm, none of the \"end\" endpoints of the segments will go beyond the marked boundaries, because to do so, the segment must be placed from the coordinate of one sign beyond the boundary of the opposite sign, and thus must have a length greater than  which contradicts how we defined .Using this fact, we will consider the DP  for  and  as the minimum distance between the \"end\" of the -th segment and the right boundary of the axis coverage of the first  segments when the distance to the left boundary of the coverage equals to . The \"end of the -th segment\" here is the \"beginning\" of the first one, that is, the point .The base of DP is , since when no segments are placed, the coverage boundaries and the current point  are all coincident. Next, we consider the forward dynamic programming relaxation: for every  there are two cases to consider, the case of the next segment being placed to the left and the case of it being placed to the right (value  below refers to the distance to the right boundary of the coverage and is an alias for ):   If a segment of length  is placed to the left side, then the new distance to the left boundary will be equal to , and distance to the right boundary will always be , which gives us the relaxation formula   If a segment of length  is placed to the right side, then the new distance to the right boundary will be equal to , and distance to the left boundary will always be , which gives us the relaxation formula  The values in array  can be calculated in ascending order by . Then the answer for the problem can be found as the minimum sum of  and  in the last row of , that is .The time complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        int maxl = 0;\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n            maxl = max(maxl, a[i]);\n        }\n        vector<vector<int>> dp(n + 1, vector<int>(2 * maxl + 1, INF));\n        dp[0][0] = 0;\n        for (int i = 0; i < n; i++) {\n            for (int left = 0; left <= 2 * maxl; left++) {\n                if (dp[i][left] == INF)\n                    continue;\n                dp[i + 1][max(left - a[i], 0)] = min(dp[i + 1][max(left - a[i], 0)], dp[i][left] + a[i]);\n                if (left + a[i] < dp[i + 1].size()) {\n                    dp[i + 1][left + a[i]] = min(dp[i + 1][left + a[i]], max(dp[i][left] - a[i], 0));\n                }\n            }\n        }\n\n        int ans = 2 * maxl + 1;\n        for (int left = 0; left <= 2 * maxl; left++)\n            ans = min(ans, left + dp[n][left]);\n        cout << ans << '\\n';\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}