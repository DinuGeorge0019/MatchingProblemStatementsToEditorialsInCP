{"link": "https://codeforces.com//contest/1213/problem/G", "problemId": "399406", "shortId": "1213G", "contest_number": "1213", "name": "G. Path Queries", "statement": "You are given a weighted tree consisting of  vertices. Recall that a tree is a connected graph without cycles. Vertices  and  are connected by an edge with weight .You are given  queries. The -th query is given as an integer . In this query you need to calculate the number of pairs of vertices  () such that the maximum weight of an edge on a simple path between  and  doesn't exceed .", "input": "The first line of the input contains two integers  and  () \u2014 the number of vertices in the tree and the number of queries. Each of the next  lines describes an edge of the tree. Edge  is denoted by three integers ,  and  \u2014 the labels of vertices it connects (, ) and the weight of the edge (). It is guaranteed that the given edges form a tree. The last line of the input contains  integers  (), where  is the maximum weight of an edge in the -th query.", "output": "Print  integers \u2014 the answers to the queries. The -th value should be equal to the number of pairs of vertices  () such that the maximum weight of an edge on a simple path between  and  doesn't exceed . .", "tutorial": "Let's carry the value  that means the answer for the current set of edges. Initially it is . Let's sort all edges by their weight and all queries by their weight also (both in non-decreasing order).Let's merge components of the tree using  (disjoint set union). We need to carry sizes of components also (it is easy if we use ). Then let's iterate over all queries in order of non-decreasing their weights. If the current query has weight  then let's merge all components connected by edges with weight . When we merge two components with sizes  and , the answer changes like that: . The value  equals to . It is so because we subtract all old paths corresponding to these components and add all new paths in the obtained component. So the answer for the current query will be  after all required merges.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> p, rk;\n\nint getp(int v) {\n\tif (v == p[v]) return v;\n\treturn p[v] = getp(p[v]);\n}\n\nlong long res;\n\nlong long get(int cnt) {\n\treturn cnt * 1ll * (cnt - 1) / 2;\n}\n\nvoid merge(int u, int v) {\n\tu = getp(u);\n\tv = getp(v);\n\t\n\tif (rk[u] < rk[v]) swap(u, v);\n\t\n\tres -= get(rk[u]);\n\tres -= get(rk[v]);\n\t\n\trk[u] += rk[v];\n\t\n\tres += get(rk[u]);\n\t\n\tp[v] = u;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\t\n\tres = 0;\n\tp = rk = vector<int>(n, 1);\n\tiota(p.begin(), p.end(), 0);\n\t\n\tvector<pair<int, pair<int, int>>> e(n - 1);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcin >> e[i].second.first >> e[i].second.second >> e[i].first;\n\t\t--e[i].second.first;\n\t\t--e[i].second.second;\n\t}\n\t\n\tvector<pair<int, int>> q(m);\n\tvector<long long> ans(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> q[i].first;\n\t\tq[i].second = i;\n\t}\n\t\n\tsort(e.begin(), e.end());\n\tsort(q.begin(), q.end());\n\t\n\tint pos = 0;\n\tfor (int i = 0; i < m; ++i) {\n\t\twhile (pos < n - 1 && e[pos].first <= q[i].first) {\n\t\t\tint u = e[pos].second.first;\n\t\t\tint v = e[pos].second.second;\n\t\t\tmerge(u, v);\n\t\t\t++pos;\n\t\t}\n\t\tans[q[i].second] = res;\n\t}\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}