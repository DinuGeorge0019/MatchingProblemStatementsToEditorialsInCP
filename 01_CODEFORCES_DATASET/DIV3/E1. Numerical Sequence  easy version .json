{"link": "https://codeforces.com//contest/1216/problem/E1", "problemId": "416604", "shortId": "1216E1", "contest_number": "1216", "name": "E1. Numerical Sequence  easy version ", "statement": ".You are given an  sequence of form \"\" which consist of blocks of all consecutive positive integers written one after another. The first block consists of all numbers from  to , the second one \u2014 from  to , the third one \u2014 from  to , , the -th block consists of all numbers from  to . So the first  elements of the sequence are \"\". Elements of the sequence are numbered from one. For example, the -st element of the sequence is , the -rd element of the sequence is , the -th element of the sequence is , the -th element is , the -th element of the sequence is .Your task is to answer  independent queries. In the -th query you are given one integer . Calculate the digit at the position  of the sequence.", "input": "The first line of the input contains one integer  () \u2014 the number of queries. The -th of the following  lines contains one integer   \u2014 the description of the corresponding query.", "output": "Print  lines. In the -th line print one digit   \u2014 the answer to the query , i.e.  should be equal to the element at the position  of the sequence.", "tutorial": "Let's take a look on the upper bound of the number , where  is the maximum possible number of block which can be asked. If we assume that each number has length  then the sum of lengths will be equal to . And as we know this value equals . So the maximum value of  is not greater than .Now we can just iterate over all  from  to  (where  is no more than ) and carry the length of the last block. If this length is greater than or equal to  (-indexed) then let's decrease  by this length, increase the length of the last block and continue. Otherwise our answer lies in the current block. So then let's iterate over all  from  to  and if the decimal length of  is greater than or equal to  then decrease  by this length otherwise our answer lies in the current number  and we just need to print  (-indexed).Time complexity:  per query.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\t\n\twhile (q--) {\n\t\tlong long k;\n\t\tcin >> k;\n\t\t--k;\n\t\tlong long lst = 0;\n\t\tlong long nxtpw = 1;\n\t\tint numlen = 0;\n\t\tfor (long long i = 1; ; ++i) {\n\t\t\tif (i == nxtpw) {\n\t\t\t\t++numlen;\n\t\t\t\tnxtpw *= 10;\n\t\t\t}\n\t\t\tlst += numlen;\n\t\t\tif (k >= lst) {\n\t\t\t\tk -= lst;\n\t\t\t} else {\n\t\t\t\tlong long nxtpw = 1;\n\t\t\t\tint numlen = 0;\n\t\t\t\tfor (long long j = 1; j <= i; ++j) {\n\t\t\t\t\tif (j == nxtpw) {\n\t\t\t\t\t\t++numlen;\n\t\t\t\t\t\tnxtpw *= 10;\n\t\t\t\t\t}\n\t\t\t\t\tif (k >= numlen) {\n\t\t\t\t\t\tk -= numlen;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcout << to_string(j)[k] << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}