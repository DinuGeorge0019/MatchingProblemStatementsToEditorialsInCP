{"link": "https://codeforces.com//contest/1624/problem/E", "problemId": "1256441", "shortId": "1624E", "contest_number": "1624", "name": "E. Masha-forgetful", "statement": "Masha meets a new friend and learns his phone number\u00a0\u2014 . She wants to remember it as soon as possible. The phone number\u00a0\u2014 is a string of length  that consists of digits from  to . The phone number may start with .Masha already knows  phone numbers (all numbers have the same length ). It will be easier for her to remember a new number if the  is represented as segments of numbers she already knows. Each such segment must be of length , otherwise there will be too many segments and Masha will get confused.For example, Masha needs to remember the number:  '' and she already knows  numbers: '', '', '', ''. You can represent  as a  segment: '' of number one, '' of number two, and '' of number three. There are other ways to represent .Masha asks you for help, she asks you to break the string  into segments of length  or more of the numbers she already knows. If there are several possible answers, print  of them.", "input": "The first line of input data contains an integer  ()\u00a0\u2014the number of test cases. Before each test case there is a blank line. Then there is a line containing integers  and  ()\u00a0\u2014the number of phone numbers that Masha knows and the number of digits in each phone number. Then follow  line, -th of which describes the -th number that Masha knows. The next line contains the phone number of her new friend . Among the given  phones, there may be duplicates (identical phones). It is guaranteed that the sum of  ( multiplied by ) values over all input test cases does not exceed .", "output": "You need to print the answers to  test cases. The first line of the answer should contain one number , corresponding to the number of segments into which you split the phone number . Print  if you cannot get such a split. If the answer is yes, then follow  lines containing triples of numbers . Such triplets mean that the next  digits of number  are equal to a segment (substring) with boundaries  of the phone under number . Both the phones and the digits in them are numbered from . Note that  for all  lines.", "tutorial": "The key idea is that any string of length greater than 3 can be obtained by concatenating strings of length  or . Then when reading the data, remember all occurring substring of length  and . There are at most . Now we will count the dynamics on the prefix:  if we can get the prefix of length  of phone  by segments of length  and  of the known phones Masha. Then for the transition we need to look through the lengths  and , then take a substring of the corresponding length and find out whether such a string occurred in the phones known to Masha.Then it will take  or  time to recalculate the dynamics, depending on the implementation. But it will still take more time to read the data, so the final asymptotic will be  or .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define sz(v) (int)v.size()\n\nconst int N = 1e4;\nmap<string, bool> have;\nmap<string, tuple<int,int,int>> pos;\n\nvoid solve() {\n    int n, m; cin >> n >> m;\n    vector<bool> dp(m+1, false);\n    vector<int> pr(m+1);\n    vector<string> cache;\n    dp[0] = true;\n\n    forn(i, n) {\n        string s; cin >> s;\n        forn(j, m) {\n            string t;\n            t += s[j];\n            for(int k = 1; k <= 2; k++) {\n                if (k + j >= m) break;\n                t += s[j+k];\n\n                if (!have[t]) {\n                    have[t] = true;\n                    pos[t] = make_tuple(j, j+k, i);\n                    cache.push_back(t);\n                }\n            }\n        }\n    }\n\n    string s; cin >> s;\n    forn(i, m) {\n        string t;\n        t += s[i];\n        for (int k = 1; k <= 2; k++) {\n            if (i - k < 0) break;\n            t = s[i-k] + t;\n            if (have[t] && dp[i-k]) {\n                dp[i+1] = true;\n                pr[i+1] = i-k;\n            }\n            if (dp[i+1]) break;\n        }\n    }\n    for (string t : cache) {\n        have[t] = false;\n    }\n\n    if (!dp[m]) {\n        cout << \"-1\\n\";\n        return;\n    }\n    vector<tuple<int,int,int>> ans;\n\n    for (int k = m; k > 0; ) {\n        int p = pr[k];\n        string t = s.substr(p, k - p);\n        ans.emplace_back(pos[t]);\n        k = p;\n    }\n\n    cout << sz(ans) << '\\n';\n    reverse(ans.begin(), ans.end());\n    for (auto [l,r,i] : ans) cout << l+1 << ' ' << r+1 << ' ' << i+1 << '\\n';\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    forn(tt, t) {\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}