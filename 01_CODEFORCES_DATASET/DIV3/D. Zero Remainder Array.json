{"link": "https://codeforces.com//contest/1374/problem/D", "problemId": "659587", "shortId": "1374D", "contest_number": "1374", "name": "D. Zero Remainder Array", "statement": "You are given an array  consisting of  positive integers.Initially, you have an integer . During one move, you can do one of the following two operations:  Choose   from  to  and increase  by  (), then increase  by  ().  Just increase  by  (). The first operation can be applied  to each  from  to .Your task is to find the minimum number of moves required to obtain such an array that each its element is   (the value  is given).You have to answer  independent test cases. ", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains two integers  and  () \u2014 the length of  and the required divisior. The second line of the test case contains  integers  (), where  is the -th element of . It is guaranteed that the sum of  does not exceed  ().", "output": "For each test case, print the answer \u2014 the minimum number of moves required to obtain such an array that each its element is  .", "tutorial": "Firstly, we can understand that during each full cycle of  from  to  we can fix each remainder only once. Notice that when we add some  then we fix the remainder  (and we don't need to fix elements which are already divisible by ). So, let  be the number of such elements for which the condition  holds (i.e. the number of such elements that we can fix if we add the value  to them). We can count this using some logarithmic data structure (like  in C++).So, what's the number of full cycles? It equals to the amount of most frequent element in  minus one. So, the answer is at least . And there can be one last cycle which will be incomplete. So what is the remanining number of moves? It equals to the maximum possible  among all . So if  is the maximum such  that  then the answer is .Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tmap<int, int> cnt;\n\t\tint mx = 0;\n\t\tfor (auto &it : a) {\n\t\t\tif (it % k == 0) continue;\n\t\t\t++cnt[k - it % k];\n\t\t\tmx = max(mx, cnt[k - it % k]);\n\t\t}\n\t\tlong long ans = 0;\n\t\tfor (auto [key, value] : cnt) {\n\t\t\tif (value == mx) {\n\t\t\t\tans = k * 1ll * (value - 1) + key + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}