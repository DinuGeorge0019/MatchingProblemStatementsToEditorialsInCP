{"link": "https://codeforces.com//contest/1426/problem/E", "problemId": "741034", "shortId": "1426E", "contest_number": "1426", "name": "E. Rock, Paper, Scissors", "statement": "Alice and Bob have decided to play the game \"Rock, Paper, Scissors\". The game consists of several rounds, each round is independent of each other. In each round, both players show one of the following things at the same time: rock, paper or scissors. If both players showed the same things then the round outcome is a draw. Otherwise, the following rules applied:  if one player showed rock and the other one showed scissors, then the player who showed rock is considered the winner and the other one is considered the loser;  if one player showed scissors and the other one showed paper, then the player who showed scissors is considered the winner and the other one is considered the loser;  if one player showed paper and the other one showed rock, then the player who showed paper is considered the winner and the other one is considered the loser. Alice and Bob decided to play exactly  rounds of the game described above. Alice decided to show rock  times, show scissors  times and show paper  times. Bob decided to show rock  times, show scissors  times and show paper  times. Though, both Alice and Bob  the sequence in which they show things. It is guaranteed that  and .Your task is to find two numbers:  the minimum number of round Alice can win;  the maximum number of rounds Alice can win. ", "input": "The first line of the input contains one integer  () \u2014 the number of rounds. The second line of the input contains three integers  () \u2014 the number of times Alice will show rock, scissors and paper, respectively. It is guaranteed that . The third line of the input contains three integers  () \u2014 the number of times Bob will show rock, scissors and paper, respectively. It is guaranteed that .", "output": "Print two integers: the minimum and the maximum number of rounds Alice can win.", "tutorial": "The maximum number of rounds Alice can win is pretty easy to calculate greedily: . What about the minimum number of rounds?It can be shown that if we started using some combination we are better to end it before using the other one. There are six possible combinations to not win the round:   and .   and .   and .   and .   and .   and . We can iterate over all permutations of these combinations (there are  possible permutations) and greedily apply them. Use the first while it is possible, then the second, and so on, and find the best answer.It is also possible that the order of these combinations does not matter, but we didn't prove that fact.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n#define pb push_back\n#define ft first\n#define sc second\n\nusing namespace std;\n\nint n;\nvector<int> a, b;\n\ninline void read() {\n\tcin >> n;\n\ta.resize(3);\n\tb.resize(3);\n\tfor (int i = 0; i < 3; i++) cin >> a[i];\n\tfor (int i = 0; i < 3; i++) cin >> b[i];\n}\n\t\ninline void solve() {\n\tint ans1 = INT_MAX;\n\tvector<pair<int, int> > ord;\n\tord.pb({0, 0});\n\tord.pb({0, 2});\n\tord.pb({1, 1});\n\tord.pb({1, 0});\n\tord.pb({2, 2});\n\tord.pb({2, 1});\n\tsort(all(ord));\n\tdo {\n\t\tvector<int> a1 = a, b1 = b;\n\t\tfor (int i = 0; i < sz(ord); i++) {\n\t\t\tint cnt = min(a1[ord[i].ft], b1[ord[i].sc]);\n\t\t\ta1[ord[i].ft] -= cnt;\n\t\t\tb1[ord[i].sc] -= cnt;\t\t\t\n\t\t}\n\t\tint cur = min(a1[0], b1[1]) + min(a1[1], b1[2]) + min(a1[2], b1[0]);\n\t\tans1 = min(ans1, cur);\n\t} while(next_permutation(all(ord)));\n\tint ans2 = min(a[0], b[1]) + min(a[1], b[2]) + min(a[2], b[0]);\n\tcout << ans1 << ' ' << ans2 << endl;\n}\n\nint main () {\n    read();\n    solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}