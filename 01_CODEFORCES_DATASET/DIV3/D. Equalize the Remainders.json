{"link": "https://codeforces.com//contest/999/problem/D", "problemId": "192343", "shortId": "999D", "contest_number": "999", "name": "D. Equalize the Remainders", "statement": "You are given an array consisting of  integers , and a positive integer . It is guaranteed that  is a divisor of .In a single move, you can choose any position  between  and  and increase  by .Let's calculate  ( \u2014 the number of elements having remainder  when divided by . In other words, for each remainder, let's find the number of corresponding elements in  with that remainder.Your task is to change the array in such a way that .Find the minimum number of moves to satisfy the above requirement.", "input": "The first line of input contains two integers  and  (). It is guaranteed that  is a divisor of . The second line of input contains  integers  (), the elements of the array.", "output": "In the first line, print a single integer \u2014 the minimum number of moves required to satisfy the following condition: for each remainder from  to , the number of elements of the array having this remainder equals . In the second line, print  array satisfying the condition and can be obtained from the given array . The values of the elements of the resulting array must not exceed .", "tutorial": "For each  from  to , find all elements of the array that are congruent to  modulo , and store their indices in a list. Also, create a vector called , and let  be .We have to cycle from  to  twice. For each  from  to , if there are in list too many (i.e., ) elements congruent to  modulo , remove the extra elements from this list and add them to . If instead there are too few (i.e., ) elements congruent to  modulo , remove the last few elements from the vector . For every removed index , increase  by . After doing so (after two passes), we print the total increase and the updated array.It is obvious that after the first  iterations, every list will have size at most , and after  more iterations, all lists will have the same sizes. It can be easily proved that this algorithm produces an optimal answer.The time complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\t\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}