{"link": "https://codeforces.com//contest/1462/problem/E1", "problemId": "833573", "shortId": "1462E1", "contest_number": "1462", "name": "E1. Close Tuples  easy version ", "statement": "You are given a sequence  of length  consisting of integers from  to . .Find the number of tuples of  elements such that the maximum number in the tuple differs from the minimum by no more than . Formally, you need to find the number of triples of indices  such thatFor example, if  and , then there are two such triples ( and ). If  and , then all four possible triples are suitable.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. Then  test cases follow. The first line of each test case contains an integer  ()\u00a0\u2014 the length of the sequence . The next line contains  integers  ()\u00a0\u2014 the sequence . It is guaranteed that the sum of  for all test cases does not exceed .", "output": "Output  answers to the given test cases. Each answer is the required number of triples of elements, such that the maximum value in the triple differs from the minimum by no more than . Note that in difference to the hard version of the problem, you  to output the answer by modulo. You must output the exact value of the answer.", "tutorial": "In the easy version of the problem, you can count how many times each number occurs (the numbers themselves do not exceed $$$n$$$). Note that we do not have very many options for which triples of numbers can be included in the answer.Let's iterate over $$$x$$$\u00a0\u2013 the minimum number in the triples. Then there are the following options:   [$$$x$$$, $$$x + 1$$$, $$$x + 2$$$];  [$$$x$$$, $$$x + 1$$$, $$$x + 1$$$];  [$$$x$$$, $$$x + 2$$$, $$$x + 2$$$];  [$$$x$$$, $$$x$$$, $$$x + 1$$$];  [$$$x$$$, $$$x$$$, $$$x + 2$$$];  [$$$x$$$, $$$x$$$, $$$x$$$]. In each option, you need to multiply the number of ways to choose one, two or three numbers from all occurrences of this number. This is done using binomial coefficients. Formally, if $$$cnt[x]$$$\u00a0\u2014 is the number of occurrences of the number $$$x$$$, then the formulas corresponding to the options in the list above are as follows:  $$$cnt[x] \\cdot cnt[x + 1] \\cdot cnt[x + 2]$$$;  $$$cnt[x] \\cdot \\frac{cnt[x + 1] \\cdot (cnt[x + 1] - 1)}{2}$$$;  $$$cnt[x] \\cdot \\frac{cnt[x + 2] \\cdot (cnt[x + 2] - 1)}{2}$$$;  $$$\\frac{cnt[x] \\cdot (cnt[x] - 1)}{2} \\cdot cnt[x + 1]$$$;  $$$\\frac{cnt[x] \\cdot (cnt[x] - 1)}{2} \\cdot cnt[x + 2]$$$;  $$$\\frac{cnt[x] \\cdot (cnt[x] - 1) \\cdot (cnt[x] - 2)}{6}$$$. If we sum these values over all $$$x$$$ from $$$1$$$ to $$$n$$$, then we get the answer to the problem.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<ll> cnt(n + 1);\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    cnt[x]++;\n  }\n  ll ans = 0;\n  for (int i = 2; i < n; i++) {\n    ans += cnt[i - 1] * cnt[i] * cnt[i + 1];\n  }\n  for (int i = 1; i < n; i++) {\n    ans += cnt[i] * (cnt[i] - 1) / 2 * cnt[i + 1];\n  }\n  for (int i = 2; i <= n; i++) {\n    ans += cnt[i - 1] * cnt[i] * (cnt[i] - 1) / 2;\n  }\n  for (int i = 2; i < n; i++) {\n    ans += cnt[i - 1] * cnt[i + 1] * (cnt[i + 1] - 1) / 2;\n  }\n  for (int i = 2; i < n; i++) {\n    ans += cnt[i + 1] * cnt[i - 1] * (cnt[i - 1] - 1) / 2;\n  }\n  for (int i = 1; i <= n; i++) {\n    ans += cnt[i] * (cnt[i] - 1) * (cnt[i] - 2) / 6;\n  }\n  cout << ans << \"\\n\";\n}\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}