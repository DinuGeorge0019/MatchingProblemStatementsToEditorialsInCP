{"link": "https://codeforces.com//contest/1618/problem/G", "problemId": "1227956", "shortId": "1618G", "contest_number": "1618", "name": "G. Trader Problem", "statement": "Monocarp plays a computer game (yet again!). This game has a unique trading mechanics.To trade with a character, Monocarp has to choose one of the items he possesses and trade it for some item the other character possesses. Each item has an integer price. If Monocarp's chosen item has price , then he can trade it for any item  with price not greater than .Monocarp initially has  items, the price of the -th item he has is . The character Monocarp is trading with has  items, the price of the -th item they have is . Monocarp can trade with this character as many times as he wants (possibly even zero times), each time exchanging one of his items with one of the other character's items according to the aforementioned constraints. Note that if Monocarp gets some item during an exchange, he can trade it for another item (since now the item belongs to him), and vice versa: if Monocarp trades one of his items for another item, he can get his item back by trading something for it.You have to answer  queries. Each query consists of one integer, which is the value of , and asks you to calculate the maximum possible total cost of items Monocarp can have after some sequence of trades, assuming that he can trade an item of cost  for an item of cost not greater than  during each trade. Note that the queries are independent: the trades do not actually occur, Monocarp only wants to calculate the maximum total cost he can get.", "input": "The first line contains three integers ,  and  (). The second line contains  integers  () \u2014 the prices of the items Monocarp has. The third line contains  integers  () \u2014 the prices of the items the other character has. The fourth line contains  integers, where the -th integer is the value of  for the -th query ().", "output": "For each query, print one integer \u2014 the maximum possible total cost of items Monocarp can have after some sequence of trades, given the value of  from the query.", "tutorial": "Suppose we have fixed the value of , so we can trade an item with price  for an item with price  if . We can see that it's never optimal to trade an item with higher price for an item with lower price, and we could just simulate the trading process as follows: try to find an item owned by Polycarp and a more expensive item owned by the other character which can be traded, repeat until we cannot find any suitable pair.Unfortunately, it is too slow. Instead, let's try to analyze: for a given value of , how to verify that an item of price  can be traded for an item of price  (maybe not right away, but with intermediate trades)?You can build a graph of  vertices representing items, where two vertices representing items with prices  and  are connected by an edge if and only if . Then, the edges of the graph represent possible trades, and the paths in the graph represent sequences of trades. So, one item can be traded for another item (possibly with intermediate trades) if the vertices representing the items belong to the same component.For a fixed value of , we can build this graph, find all of its components, calculate the number of Monocarp's items in each component and add this number of most expensive vertices from the component to the answer. There are two problems though.The first one is that the graph may have up to  edges. But if we sort all items according to their prices, we are only interested in edges between vertices which represent adjacent items in sorted order, so the size of the graph is decreased to .Another problem is that there are multiple queries for different values of . To handle it, we can sort the values of  in ascending order and go in sorted order while maintaining the graph for the current value of . A data structure like DSU or a method like small-to-large merging can be helpful to update the components as they merge.The last trick: to quickly recalculate the number of items Monocarp has in a component and the sum of most expensive several items, you can build two prefix sum arrays \u2014 one over the array storing the costs of the items, and another one over the array which stores values  or  depending on who owns the respective item (the items should still be considered in sorted order). Since each component is a segment of costs of items, prefix sums allow us to calculate the required values in .By the way, knowing that each component is a segment, we can get rid of the graph and the structure that stores it altogether and just maintain a set of segments of items representing the components.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n\nconst int N = 400 * 1000 + 13;\n\nint n, m, k;\nint a[N], b[N];\nint q[N];\n\nint p[N];\nmultiset<int> wst[N], bst[N];\nlong long sum;\n\nint getp(int a){\n\treturn a == p[a] ? a : p[a] = getp(p[a]);\n}\n\nvoid unite(int a, int b){\n\ta = getp(a), b = getp(b);\n\tif (wst[a].size() + bst[a].size() < wst[b].size() + bst[b].size()) swap(a, b);\n\tfor (auto it : wst[b])\n\t\twst[a].insert(it);\n\tfor (auto it : bst[b])\n\t\tbst[a].insert(it);\n\twst[b].clear();\n\tbst[b].clear();\n\twhile (!bst[a].empty() && !wst[a].empty() && *bst[a].begin() < *wst[a].rbegin()){\n\t\tsum -= *bst[a].begin();\n\t\tsum += *wst[a].rbegin();\n\t\tbst[a].insert(*wst[a].rbegin());\n\t\twst[a].insert(*bst[a].begin());\n\t\tbst[a].erase(bst[a].begin());\n\t\twst[a].erase(--wst[a].end());\n\t}\n\tp[b] = a;\n}\n\nlong long ans[N];\n\nstruct event{\n\tint x, t, i;\n};\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\tforn(i, m)\n\t\tscanf(\"%d\", &b[i]);\n\tforn(i, k)\n\t\tscanf(\"%d\", &q[i]);\n\tvector<pair<int, int>> tot;\n\tforn(i, n) tot.push_back({a[i], 1});\n\tforn(i, m) tot.push_back({b[i], 0});\n\tsort(tot.begin(), tot.end());\n\tsum = accumulate(a, a + n, 0ll);\n\tforn(i, n + m){\n\t\tp[i] = i;\n\t\twst[i].clear();\n\t\tbst[i].clear();\n\t\tif (tot[i].second) bst[i].insert(tot[i].first);\n\t\telse wst[i].insert(tot[i].first);\n\t}\n\tvector<event> ev;\n\tforn(i, n + m - 1) ev.push_back({tot[i + 1].first - tot[i].first, 0, i});\n\tforn(i, k) ev.push_back({q[i], 1, i});\n\tsort(ev.begin(), ev.end(), [](const event &a, const event &b){\n\t\tif (a.x != b.x) return a.x < b.x;\n\t\treturn a.t < b.t;\n\t});\n\tfor (auto it : ev){\n\t\tif (it.t == 0)\n\t\t\tunite(it.i, it.i + 1);\n\t\telse\n\t\t\tans[it.i] = sum;\n\t}\n\tforn(i, k) printf(\"%lld\\n\", ans[i]);\n}", "interactive": false, "noSolution": false, "noTutorial": false}