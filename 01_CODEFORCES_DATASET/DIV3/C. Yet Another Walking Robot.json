{"link": "https://codeforces.com//contest/1296/problem/C", "problemId": "531584", "shortId": "1296C", "contest_number": "1296", "name": "C. Yet Another Walking Robot", "statement": "There is a robot on a coordinate plane. Initially, the robot is located at the point . Its path is described as a string  of length  consisting of characters '', '', '', ''.Each of these characters corresponds to some move:   '' (left): means that the robot moves from the point  to the point ;  '' (right): means that the robot moves from the point  to the point ;  '' (up): means that the robot moves from the point  to the point ;  '' (down): means that the robot moves from the point  to the point . The company that created this robot asked you to optimize the path of the robot somehow. To do this, you can remove  of the path. But this company doesn't want their customers to notice the change in the robot behavior. It means that if before the optimization the robot ended its path at the point , then after optimization (i.e. removing some single substring from ) the robot also ends its path at the point .This optimization is a low-budget project so you need to remove  possible  substring to optimize the robot's path such that the endpoint of his path doesn't change. It is possible that you can't optimize the path. Also, it is possible that after the optimization the target path is an empty string (i.e. deleted substring is the whole string ).Recall that the substring of  is such string that can be obtained from  by removing some amount of characters (possibly, zero) from the prefix and some amount of characters (possibly, zero) from the suffix. For example, the substrings of \"\" are \"\", \"\", \"\", \"\", but not \"\" and \"\".You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. The next  lines describe test cases. Each test case is given on two lines. The first line of the test case contains one integer  () \u2014 the length of the robot's path. The second line of the test case contains one string  consisting of  characters '', '', '', '' \u2014 the robot's path. It is guaranteed that the sum of  over all test cases does not exceed  ().", "output": "For each test case, print the answer on it. If you cannot remove such  substring that the endpoint of the robot's path doesn't change, print . Otherwise, print two integers  and  such that  \u2014 endpoints of the substring you remove. The value  should be minimum possible. If there are several answers, print any of them.", "tutorial": "Formally, the problem asks you to remove the shortest cycle from the robot's path. Because the endpoint of the path cannot be changed, the number of ''s should be equal to the number of ''s and the same with '' and ''.How to find the shortest cycle? Let's create the associative array  ( for C++) which will say for each point of the path the maximum number of operations  such that if we apply first  operations we will stay at this point. Initially, this array will contain only the point  with the value . Let's go over all characters of  in order from left to right. Let the current point be  (we applied first  operations, -indexed). If this point is in the array already, let's try to update the answer with the value  and left and right borders with values  and  correspondingly. Then let's assign  and continue.If there were no updates of the answer, the answer is . Otherwise, you can print any substring you found.Time complexity:  per test case.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tstring s;\n\t\tcin >> n >> s;\n\t\tint l = -1, r = n;\n\t\tmap<pair<int, int>, int> vis;\n\t\tpair<int, int> cur = {0, 0};\n\t\tvis[cur] = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (s[i] == 'L') --cur.first;\n\t\t\tif (s[i] == 'R') ++cur.first;\n\t\t\tif (s[i] == 'U') ++cur.second;\n\t\t\tif (s[i] == 'D') --cur.second;\n\t\t\tif (vis.count(cur)) {\n\t\t\t\tif (i - vis[cur] + 1 < r - l + 1) {\n\t\t\t\t\tl = vis[cur];\n\t\t\t\t\tr = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvis[cur] = i + 1;\n\t\t}\n\t\tif (l == -1) {\n\t\t\tcout << -1 << endl;\n\t\t} else {\n\t\t\tcout << l + 1 << \" \" << r + 1 << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}