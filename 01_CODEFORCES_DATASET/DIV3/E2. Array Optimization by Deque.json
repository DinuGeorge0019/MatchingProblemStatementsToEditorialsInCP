{"link": "https://codeforces.com//contest/1579/problem/E2", "problemId": "1123871", "shortId": "1579E2", "contest_number": "1579", "name": "E2. Array Optimization by Deque", "statement": "You are given an integer array .Let us consider an empty deque (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements  currently in the deque, adding an element  to the beginning will produce the sequence , and adding the same element to the end will produce .The elements of the array are sequentially added to the initially empty deque, starting with  and finishing with . Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.For example, if we consider an array , one of the possible sequences of actions looks like this:  1.add  to the beginning of the deque:deque has a sequence  in it; 2.add  to the end of the deque:deque has a sequence  in it; 3.add  to the end of the deque:deque has a sequence  in it; 4.add  to the beginning of the deque:deque has a sequence  in it;Find the minimal possible number of inversions in the deque after the whole array is processed. An  in sequence  is a pair of indices  such that  and . For example, the array  has exactly two inversions\u00a0\u2014  and , since  and .", "input": "The first line contains an integer  ()\u00a0\u2014 the number of test cases. The next  lines contain descriptions of the test cases.  The first line of each test case description contains an integer  ()\u00a0\u2014 array size. The second line of the description contains  space-separated integers  ()\u00a0\u2014 elements of the array. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "Print  lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer\u00a0\u2014 the minimal possible number of inversions in the deque after executing the described algorithm.", "tutorial": "Let's process the array elements one by one.For the first element, it doesn't matter which side of the deque we add it to, the result of its addition will be the same\u00a0\u2014 there will be a sequence of one element (equal to the first array element) in the deque.Now let's consider adding the th element of an array into the deck. First  will be considered, then , and so on up to . Let us describe the general algorithm for choosing the side of the dec for each step. Note that if the elements  now lie in the deck, then all final sequences that can be obtained in the deck from the current state can be broken down into pairs of the form   where the beginning and the end of the final sequences hidden behind \"\" are obtained by the same sequences of all the following choices and, respectively, coincide.Note that since the prefix and suffix hidden behind the dots completely coincide in the two sequences under consideration, as well as the set of numbers in the central part coincides, the numbers of inversions also coincide:   inside the prefix and inside the suffix;  between elements of the prefix and elements of the suffix;  between elements of the prefix or suffix and elements of the central part. The difference between the number of inversions in the first and second sequence consists only of the difference between the number of inversions in their central part. So, we can determine at the stage of adding  to the deque, which direction of its addition is guaranteed not to lead to the optimal answer and choose the opposite one.If  is added to the beginning of the deque, the number of inversions in the central part will increase by the number of elements in the deque strictly smaller than , and if we add it to the end of the deque, it will increase by the number of elements in the deque strictly larger than . Let us make a choice such that the number of inversions increases by the minimum of these two values.To quickly find the number of elements smaller or larger than , we will store all already processed array elements in a structure that supports the element order search operation, such as . Besides using this structure specifically, you can   write any balanced binary search tree (such as a Cartesian tree);  sort all numbers in the input array and compress them to values , preserving the \"\" relation, then build a segment tree on them, storing in the node  the number of array numbers already processed by the deque with values between  and . Requests to update and get an order in such structures take  time, and the construction takes at worst , so the time complexity of the algorithm is .", "solution": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef pair<int, int> node;\ntypedef tree<node, null_type, less<node>,\n            rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        ordered_set s;\n        long long cnt = 0;\n        for (int i = 0; i < n; i++) {\n            int a;\n            cin >> a;\n            int less = s.order_of_key(node(a, 0)),\n                    greater = i - s.order_of_key(node(a, n));\n            cnt += min(less, greater);\n            s.insert(node(a, i));\n        }\n        cout << cnt << '\\n';\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}