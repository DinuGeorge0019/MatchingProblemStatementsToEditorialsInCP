{"link": "https://codeforces.com//contest/1283/problem/F", "problemId": "504972", "shortId": "1283F", "contest_number": "1283", "name": "F. DIY Garland", "statement": "Polycarp has decided to decorate his room because the New Year is soon. One of the main decorations that Polycarp will install is the garland he is going to solder himself.Simple garlands consisting of several lamps connected by one wire are too boring for Polycarp. He is going to solder a garland consisting of  lamps and  wires. Exactly one lamp will be connected to power grid, and power will be transmitted from it to other lamps by the wires. Each wire connectes exactly two lamps; one lamp is called  for this wire (the one that gets power from some other wire and transmits it to this wire), the other one is called  (the one that gets power from this wire). Obviously, each lamp has at most one wire that brings power to it (and this lamp is the auxiliary lamp for this wire, and the main lamp for all other wires connected directly to it).Each lamp has a brightness value associated with it, the -th lamp has brightness . We define the  of the wire as the sum of brightness values over all lamps that become disconnected from the grid if the wire is cut (and all other wires are still working).Polycarp has drawn the scheme of the garland he wants to make (the scheme depicts all  lamp and  wires, and the lamp that will be connected directly to the grid is marked; the wires are placed in such a way that the power can be transmitted to each lamp). After that, Polycarp calculated the importance of each wire, enumerated them from  to  in descending order of their importance, and then wrote the index of the main lamp for each wire (in the order from the first wire to the last one).The following day Polycarp bought all required components of the garland and decided to solder it \u2014 but he could not find the scheme. Fortunately, Polycarp found the list of indices of main lamps for all wires. Can you help him restore the original scheme?", "input": "The first line contains one integer  () \u2014 the number of lamps. The second line contains  integers , , ...,  (), where  is the index of the main lamp for the -th wire (wires are numbered in descending order of importance).", "output": "If it is impossible to restore the original scheme, print one integer . Otherwise print the scheme as follows. In the first line, print one integer  () \u2014 the index of the lamp that is connected to the power grid. Then print  lines, each containing two integers  and  (, ) \u2014 the indices of the lamps connected by some wire. The descriptions of the wires (and the lamps connected by a wire) can be printed in any order. The printed description must correspond to a scheme of a garland such that Polycarp could have written the list , , ...,  from it. If there are multiple such schemes, output any of them.", "tutorial": "First of all, we don't like the fact that importance values can be integers up to  (it is kinda hard to work with them). Let's rephrase the problem.The highest bit set to  in the importance value denotes the maximum in the subtree rooted at the auxiliary lamp for the wire. So, we sort the wires according to the maximums in their subtrees. To break ties, we could consider the second maximum, then the third maximum \u2014 but that's not convenient. We can use something much easier: suppose there are two vertices with the same maximum in their subtrees; these vertices belong to the path from the root to the maximum in their subtrees, and the one which is closer to the root has the greater importance value. So, to get the order described in the problem statement, we could sort the vertices according to the maximum in their subtrees, and use depth as the tie-breaker.What does this imply? All vertices of some prefix are ancestors of vertex , so some prefix denotes the path from the root to  (excluding  itself). Then there are some values describing the path from some already visited vertex to  (if  was not met before), then to , and so on.How can we use this information to restore the original tree?  is the root, obviously. Then the sequence can be separated into several subsegments, each representing a vertical path in the tree (and each vertex is the parent of the next vertex in the sequence, if they belong to the same subsegment). How can we separate these vertices into subsegments, and how to find the parents for vertices which did not appear in the sequence at all? Suppose some vertex appears several times in our sequence. The first time it appeared in the sequence, it was in the middle of some vertical path, so the previous vertex is its parent; and every time this vertex appears again, it means that we start a new path \u2014 and that's how decomposition into paths is done.Determining the parents of vertices that did not appear in the sequence is a bit harder, but can also be done. Let's recall that our sequence is decomposed into paths from root to , from some visited vertex to , from some visited vertex to , and so on; so, each time the path changes, it means that we have found the maximum vertex (among unvisited ones). So we should keep track of the maximum vertex that was not introduced in the sequence while we split it into paths, and each time a path breaks, it means that we found the vertex we were keeping track of.Overall, this solution can be implemented in .", "solution": "#define _CRT_SECURE_NO_WARNINGS\n\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> a(n - 1);\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\tint root = a[0];\n\tint last = -1;\n\tvector<int> used(n, 0);\n\tprintf(\"%d\\n\", root + 1);\n\tint cur = n - 1;\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tused[a[i]] = 1;\n\t\twhile (used[cur])\n\t\t\tcur--;\n\t\tif (i == n - 2 || used[a[i + 1]])\n\t\t{\n\t\t\tprintf(\"%d %d\\n\", a[i] + 1, cur + 1);\n\t\t\tused[cur] = 1;\n\t\t}\n\t\telse\n\t\t\tprintf(\"%d %d\\n\", a[i + 1] + 1, a[i] + 1);\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}