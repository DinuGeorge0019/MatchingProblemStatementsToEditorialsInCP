{"link": "https://codeforces.com//contest/1579/problem/B", "problemId": "1123867", "shortId": "1579B", "contest_number": "1579", "name": "B. Shifting Sort", "statement": "The new generation external memory contains an array of integers .This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array,  (rotate) it by any offset and insert it back into the same place.Technically, each cyclic shift consists of two consecutive actions:   You may select arbitrary indices  and  () as the boundaries of the segment.  Then you replace the segment  with it's  to the  by an arbitrary offset . The concept of a  can be also explained by following relations: the sequence  is a cyclic shift of the sequence  to the left by the offset  and the sequence  is a cyclic shift of the sequence  to the left by the offset . For example, if , then choosing ,  and  yields a segment . This segment is then shifted by the offset  to the , and you get a segment  which then takes the place of of the original elements of the segment. In the end you get .Sort the given array  using no more than  cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires  or less cyclic shifts will be accepted.", "input": "The first line contains an integer  ()\u00a0\u2014 the number of test cases. The next  lines contain the descriptions of the test cases.  The first line of each test case description contains an integer  ()\u00a0\u2014 the length of the array. The second line consists of space-separated elements of the array  (). Elements of array  may repeat and don't have to be unique.", "output": "Print  answers to all input test cases.  The first line of the answer of each test case should contain an integer  ()\u00a0\u2014 the number of actions to sort the array. The next  lines should contain descriptions of the actions formatted as \"\" (without quotes) where  and  () are the boundaries of the segment being shifted, while  () is the offset value. Please remember that only the cyclic shifts  are considered so the chosen segment will be shifted by the offset  to the . Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed  will be accepted. If the given array  is already sorted, one of the possible answers is  and an empty sequence of cyclic shifts. If there are several possible answers, you may print any of them.", "tutorial": "In this problem, it was enough to implement an analogue of standard  or . Here is an example of a solution based on selection sort.Let's find the minimum element in the array by simply iterating over it. Let's denote its index in the array by . If we apply a shift \"\" to it, the following happens:  Once again, please note that all shifts are made in the left direction, so shifting by  to the left will put the element that was previously at index  in the first place.Let us perform a similar shift for the second-largest element of the array, putting it in second place, for the third-largest element of the array, putting it in third place, and so on. More formally, let's describe the -th iteration as follows:   At the beginning of the -th iteration, the first  elements of the array are its  minimal elements, already in their correct places in sorted order.  During the -th iteration, the -th largest element of the array is placed in the -th place in the array.  Since the first  minimal elements are already in their places, the -th largest element of the array is simply the smallest element among . Let's find it by iterating over these elements and denote its index in the array  by .  Make a shift \"\". The first  elements will not change, and the element from the -th place in the array will move to the -th:  It is worth noting that the output format forbids shifting segments with . Regarding this case, we should check the equality  separately. If these two indexes coincide, then the -th element is already in its place, and no shift should be done on this iteration. Let us repeat this algorithm for , , ..., . At each iteration, the new element will be shifted into its place in sorted order, and each iteration performs no more than one shift operation. Thus, in strictly less than  shifts, the array will be completely sorted.The time complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        vector<pii> actions;\n        for (int i = 0; i < n; i++)\n            cin >> a[i];\n\n        for (int i = 0; i < n - 1; i++) {\n            int min_pos = i;\n            for (int j = i + 1; j < n; j++)\n                if (a[j] < a[min_pos])\n                    min_pos = j;\n\n            if (min_pos > i) {\n                actions.push_back({i, min_pos});\n                int opt = a[min_pos];\n                for (int j = min_pos; j > i; j--)\n                    a[j] = a[j - 1];\n                a[i] = opt;\n            }\n        }\n\n        cout << actions.size() << '\\n';\n        for (auto &lr: actions) {\n            cout << lr.first + 1 << ' ' << lr.second + 1 << ' ' << lr.second - lr.first << '\\n';\n        }\n    }\n\n}", "interactive": false, "noSolution": false, "noTutorial": false}