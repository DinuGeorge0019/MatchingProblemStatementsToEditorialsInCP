{"link": "https://codeforces.com//contest/1741/problem/B", "problemId": "1580858", "shortId": "1741B", "contest_number": "1741", "name": "B. Funny Permutation", "statement": "A sequence of  numbers is called  if it contains all numbers from  to  exactly once. For example, the sequences , [] and  are permutations, but ,  and  are not.For a given number  you need to make a permutation  such that two requirements are satisfied at the same time:  For each element , at least one of its neighbors has a value that differs from the value of  by one. That is, for each element  (), at least one of its neighboring elements (standing to the left or right of ) must be , or .  the permutation must have no fixed points. That is, for every  (),  must be satisfied. Let's call the permutation that satisfies these requirements .For example, let . Then [] is a  permutation, since:   to the right of  is ;  to the left of  is ;  to the right of  is ;  to the left of  is .  for all  is . For a given positive integer , output   permutation of length , or output  if  permutation of length  does not exist.", "input": "The first line of input data contains a single integer  ()\u00a0\u2014 the number of test cases. The description of the test cases follows. Each test case consists of f single line containing one integer  (). It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, print on a separate line:      permutation  of length ;  or the number  if the permutation you are looking for does not exist. ", "tutorial": "We cannot make a funny permutation only when , because one of the neighboring elements of  must be equal to . Any permutation made in this way will not satisfy the conditions:   The permutation [] will have a fixed point .  The permutation [] will have a fixed point .  The permutation [] will not have a neighbor equal to  for . For the remaining values of , make the following observations:   For , the only funny permutation is [].  When , permutations of the form [] will always be funny because all elements  will have a neighbor equal to  or , and the permutation will have no fixed points (, , and for  will always be true ). ", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nvoid solve(){\n    int n;\n    cin >> n;\n    if(n == 3){\n        cout << -1 << endl;\n    }\n    else{\n        for(int i = 3; i <= n; i++) cout << i << ' ';\n        cout << 2 << ' ' << 1 << endl;\n    }\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}