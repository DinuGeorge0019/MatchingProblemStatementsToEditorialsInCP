{"link": "https://codeforces.com//contest/1256/problem/C", "problemId": "459826", "shortId": "1256C", "contest_number": "1256", "name": "C. Platforms Jumping", "statement": "There is a river of width . The left bank of the river is cell  and the right bank is cell  (more formally, the river can be represented as a sequence of  cells numbered from  to ). There are also  wooden platforms on a river, the -th platform has length  (so the -th platform takes  consecutive cells of the river). It is guaranteed that the sum of lengths of platforms does not exceed .You are standing at  and want to reach  somehow. If you are standing at the position , you can jump to any position in the range .  you don't really like the water so you can jump only to such cells that belong to some wooden platform. For example, if , you can jump only to the next position (if it belongs to the wooden platform). .You want to know if it is possible to reach  from  if you can move any platform to the left or to the right arbitrary number of times (possibly, zero) as long as they do not intersect each other (but two platforms can touch each other). It also means that you cannot change the relative order of platforms. (in other words, you first move the platforms and then start jumping).For example, if , ,  and , then one of the ways to reach  from  is follow:     ", "input": "The first line of the input contains three integers ,  and  () \u2014 the width of the river, the number of platforms and the maximum distance of your jump, correspondingly. The second line of the input contains  integers  (), where  is the length of the -th platform.", "output": "If it is impossible to reach  from , print  in the first line. Otherwise, print  in the first line and the array  of length  in the second line \u2014 the sequence of river cells (excluding cell  and cell ). If the cell  does not belong to any platform,  should be . Otherwise, it should be equal to the index of the platform (-indexed, platforms are numbered from  to  in order of input) to which the cell  belongs.  all  equal to  should form a contiguous subsegment of the array  of length , all  equal to  should form a contiguous subsegment of the array  of length , ..., all  equal to  should form a contiguous subsegment of the array  of length . The leftmost position of  in  should be greater than the rightmost position of , the leftmost position of  in  should be greater than the rightmost position of , ..., the leftmost position of  in  should be greater than the rightmost position of . See example outputs for better understanding.", "tutorial": "This problem has a very easy idea but requires terrible implementation. Firstly, let's place all platforms as rightmost as we can. Thus, we will have the array, in which the first  elements are zeros and other elements are , , ..., .Now, let's start the algorithm. Firstly, we need to jump to the position  or less. If we could jump to the position  then we don't need to jump to some position to the left from . But if we cannot do it, let's take the leftmost platform to the right from the position  and move it in such a way that its left border will be at the position . Now we can jump to the position  and then jump by  right to reach the position . Let's repeat the same algorithm and continue jumping.If after some move we can jump to the position at least  then we are done.Time complexity:  but I'm sure it can be implemented in  or .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, d;\n\tcin >> n >> m >> d;\n\tvector<int> c(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> c[i];\n\t}\n\t\n\tvector<int> ans(n + 2);\n\tfor (int i = m - 1, pos = n; i >= 0; --i) {\n\t\tfor (int len = 0; len < c[i]; ++len) {\n\t\t\tans[pos - len] = i + 1;\n\t\t}\n\t\tpos -= c[i];\n\t}\n\t\n\tint now = 0;\n\twhile (true) {\n\t\twhile (now + 1 < n + 1 && ans[now + 1] > 0) ++now;\n\t\tif (now + d >= n + 1) break;\n\t\tif (ans[now + d] == 0) {\n\t\t\tint lpos = -1;\n\t\t\tfor (int i = now + d; i < n + 2; ++i) {\n\t\t\t\tif (ans[i] != 0) {\n\t\t\t\t\tlpos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lpos == -1) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint rpos = -1;\n\t\t\tfor (int i = lpos; i < n + 2; ++i) {\n\t\t\t\tif (ans[i] == ans[lpos]) rpos = i;\n\t\t\t}\n\t\t\twhile (ans[now + d] == 0) {\n\t\t\t\tswap(ans[lpos - 1], ans[rpos]);\n\t\t\t\t--lpos, --rpos;\n\t\t\t}\n\t\t}\n\t\tnow += d;\n\t}\n\t\n\tcout << \"YES\" << endl;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}