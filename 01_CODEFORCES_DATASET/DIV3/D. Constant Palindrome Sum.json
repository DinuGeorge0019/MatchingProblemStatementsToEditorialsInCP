{"link": "https://codeforces.com//contest/1343/problem/D", "problemId": "599890", "shortId": "1343D", "contest_number": "1343", "name": "D. Constant Palindrome Sum", "statement": "You are given an array  consisting of  integers (it is guaranteed that  is even, i.e. divisible by ). All  does not exceed some integer .Your task is to replace the  number of elements (replacement is the following operation: choose some index  from  to  and replace  with some integer in range ) to satisfy the following conditions:  after all replacements, all  are positive integers not greater than ;  for all  from  to  the following equation is true: , where  should be  for all  pairs of elements. You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains two integers  and  () \u2014 the length of  and the maximum possible value of some  correspondingly. It is guratanteed that  is even (i.e. divisible by ). The second line of the test case contains  integers  (), where  is the -th element of . It is guaranteed that the sum of  (as well as the sum of ) over all test cases does not exceed  (, ).", "output": "For each test case, print the answer \u2014 the  number of elements you have to replace in  to satisfy the conditions from the problem statement.", "tutorial": "It is obvious that if we fix the value of $$$x$$$ then there are three cases for the pair of elements:  We don't need to change anything in this pair;  we can replace one element to fix this pair;  we need to replace both elements to fix this pair. The first part can be calculated easily in $$$O(n+k)$$$, we just need to create the array of frequencies $$$cnt$$$, where $$$cnt_x$$$ is the number of such pairs $$$(a_i, a_{n-i+1})$$$ that $$$a_i + a_{n-i+1} = x$$$.The second part is a bit tricky but still doable in $$$O(n+k)$$$. For each pair, let's understand the minimum and the maximum sum we can obtain using at most one replacement. For the $$$i$$$-th pair, all such sums belong to the segment $$$[min(a_i, a_{n-i+1})+1; max(a_i, a_{n-i+1})+k]$$$. Let's make $$$+1$$$ on this segment using prefix sums (make $$$+1$$$ in the left border, $$$-1$$$ in the right border plus one and then just compute prefix sums on this array). Let this array be $$$pref$$$. Then the value $$$pref_x$$$ tells the number of such pairs that we need to replace  element in this pair to make it sum equals $$$x$$$.And the last part can be calculated as $$$\\frac{n}{2} - pref_x$$$. So, for the sum $$$x$$$ the answer is $$$(pref_x - cnt_x) + (\\frac{n}{2} - pref_x) \\cdot 2$$$. We just need to take the minimum such value among all possible sums from $$$2$$$ to $$$2k$$$.There is another one solution that uses scanline, not depends on $$$k$$$ and works in $$$O(n \\log n)$$$ but it has no cool ideas to explain it here (anyway the main idea is almost the same as in the solution above).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tvector<int> cnt(2 * k + 1);\n\t\tfor (int i = 0; i < n / 2; ++i) {\n\t\t\t++cnt[a[i] + a[n - i - 1]];\n\t\t}\n\t\tvector<int> pref(2 * k + 2);\n\t\tfor (int i = 0; i < n / 2; ++i) {\n\t\t\tint l1 = 1 + a[i], r1 = k + a[i];\n\t\t\tint l2 = 1 + a[n - i - 1], r2 = k + a[n - i - 1];\n\t\t\tassert(max(l1, l2) <= min(r1, r2));\n\t\t\t++pref[min(l1, l2)];\n\t\t\t--pref[max(r1, r2) + 1];\n\t\t}\n\t\tfor (int i = 1; i <= 2 * k + 1; ++i) {\n\t\t\tpref[i] += pref[i - 1];\n\t\t}\n\t\tint ans = 1e9;\n\t\tfor (int sum = 2; sum <= 2 * k; ++sum) {\n\t\t\tans = min(ans, (pref[sum] - cnt[sum]) + (n / 2 - pref[sum]) * 2);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}