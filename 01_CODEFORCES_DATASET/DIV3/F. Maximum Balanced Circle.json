{"link": "https://codeforces.com//contest/1157/problem/F", "problemId": "336209", "shortId": "1157F", "contest_number": "1157", "name": "F. Maximum Balanced Circle", "statement": "There are  people in a row. The height of the -th person is . You can choose  subset of these people and try to arrange them into a .A  is such an order of people that the difference between heights of any adjacent people is no more than . For example, let heights of chosen people be , where  is the number of people you choose. Then the condition  should be satisfied for all  from  to  and the condition  should be also satisfied.  means the absolute value of . It is obvious that the circle consisting of one person is balanced.Your task is to choose the maximum number of people and construct a  consisting of all chosen people. It is obvious that the circle consisting of one person is balanced so the answer always exists.", "input": "The first line of the input contains one integer  () \u2014 the number of people. The second line of the input contains  integers  (), where  is the height of the -th person.", "output": "In the first line of the output print  \u2014 the number of people in the maximum . In the second line print  integers , where  is the  of the -th person in the maximum . The condition  should be satisfied for all  from  to  and the condition  should be also satisfied.", "tutorial": "Let's realize what we need to construct the   with heights from $$$l$$$ to $$$r$$$. We can represent it as $$$l, l + 1, \\dots, r - 1, r, r - 1, \\dots, l + 1$$$. As we can see, we need one occurrence of $$$l$$$ and $$$r$$$ and two occurrences of all other heights from $$$l + 1$$$ to $$$r - 1$$$. How can we find the   using this information? We can find the  segment of neighboring heights with at least two occurrences using the array of frequencies $$$cnt$$$, sorted array of unique heights $$$b$$$ and two pointers technique. For the current left border $$$l$$$ we should increase $$$r$$$ (initially it is $$$l + 1$$$ and it is an excluded border) while $$$b_r - b_{r - 1}=1$$$ and $$$cnt_{b_r} \\ge 2$$$. Then for the current left and right borders we can try to extend the segment to the left if $$$b_l - b_{l - 1} = 1$$$ and to the right if $$$b_{r + 1} - b_r = 1$$$ and try to update the answer with the the current segment (and go to the next segment). There may be some corner cases like $$$n = 1$$$ or all $$$cnt$$$ are $$$1$$$, but you can avoid them if you will implement the solution carefully. There are almost no corner cases in my solution, you can see details of implementation in authors code.Time complexity: $$$O(n \\log n)$$$ or $$$O(n)$$$ (depends on sorting method).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tvector<int> cnt(200 * 1000 + 1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\t++cnt[a[i]];\n\t}\n\t\n\tsort(a.begin(), a.end());\n\ta.resize(unique(a.begin(), a.end()) - a.begin());\n\t\n\tint l = 0, r = 0;\n\tint ans = cnt[a[0]];\n\tfor (int i = 0; i < int(a.size()); ++i) {\n\t\tint j = i + 1;\n\t\tint sum = cnt[a[i]];\n\t\twhile (a[j] - a[j - 1] == 1 && cnt[a[j]] > 1) {\n\t\t\tsum += cnt[a[j]];\n\t\t\t++j;\n\t\t}\n\t\tint cr = j - 1;\n\t\tif (j < n && a[j] - a[j - 1] == 1) {\n\t\t\tsum += cnt[a[j]];\n\t\t\tcr = j;\n\t\t}\n\t\tif (ans < sum) {\n\t\t\tans = sum;\n\t\t\tl = i;\n\t\t\tr = cr;\n\t\t}\n\t\ti = j - 1;\n\t}\n\t\n\tcout << ans << endl;\n\tfor (int c = 0; c < cnt[a[l]]; ++c) cout << a[l] << \" \";\n\tfor (int i = l + 1; i < r; ++i) {\n\t\tfor (int c = 0; c < cnt[a[i]] - 1; ++c) cout << a[i] << \" \";\n\t}\n\tfor (int c = 0; l != r && c < cnt[a[r]]; ++c) cout << a[r] << \" \";\n\tfor (int i = r - 1; i > l; --i) cout << a[i] << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}