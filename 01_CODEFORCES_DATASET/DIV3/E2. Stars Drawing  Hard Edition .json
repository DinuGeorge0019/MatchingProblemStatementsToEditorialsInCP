{"link": "https://codeforces.com//contest/1015/problem/E2", "problemId": "203551", "shortId": "1015E2", "contest_number": "1015", "name": "E2. Stars Drawing  Hard Edition ", "statement": "A  is a figure of the following type: an asterisk character '' in the center of the figure and four rays (to the left, right, top, bottom) of the same positive length. The size of a  is the length of its rays. The size of a star must be a positive number (i.e. rays of length  are not allowed).Let's consider empty cells are denoted by '', then the following figures are :   You are given a rectangular grid of size  consisting only of asterisks '' and periods (dots) ''. Rows are numbered from  to , columns are numbered from  to . Your task is to draw this grid using  number of  or find out that it is impossible.  can intersect, overlap or even coincide with each other. The number of  in the output can't exceed . Each star should be completely inside the grid. You can use stars of same and arbitrary sizes.", "input": "The first line of the input contains two integers  and  () \u2014 the sizes of the given grid. The next  lines contains  characters each, the -th line describes the -th row of the grid. It is guaranteed that grid consists of characters '' and '' only.", "output": "If it is impossible to draw the given grid using  only, print \"\". Otherwise in the first line print one integer  () \u2014 the number of  needed to draw the given grid. The next  lines should contain three integers each \u2014 ,  and , where  is the row index of the central  character,  is the column index of the central  character and  is the size of the . Each  should be completely inside the grid.", "tutorial": "I am sorry that some  solutions pass tests in this problem also. I was supposed to increase constraints or decrease time limit.The general idea of this problem is the same as in the previous problem. But now we should do all what we were doing earlier faster. The solution is divided by two parts.The first part. Let's calculate four matrices of size  \u2014 , ,  and .  will denote the distance to the nearest dot character to the top from the current position. The same,  will denote the distance to the nearest dot character to the bottom from the current position,  \u2014 to the left and  \u2014 to the right. We can calculate all these matrices in  using easy dynamic programming. If we will iterate over all possible  from  to  and  from  to , we can easy see the next: if the current character is dot, then . Otherwise if  then , and if  then . Rest two matrices can be calculated the as well as these two matrices but we should iterate over all  from  to  and  from  to . So, this part of the solution works in .After calculating all these matrices the maximum possible length of rays of the  with center in position  is .The second part is to draw all  in . Let's calculate another two matrices of size  \u2014  and . Let's iterate over all  in our answer. Let the center of the current  is  and its size is . Let's increase  by one and decrease  by one (if ). The same with the matrix . Increase  and decrease  (if ). Then let's iterate over all possible  from  to  and  from  to . If  then set  and if  set .How to know that the character at the position  is asterisk character or dot character? If either  or  greater than zero, then the character at the position  in our matrix will be the asterisk character. Otherwise it is the dot character. This part works also in .Time complexity of the solution: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nvector<string> s;\n\nvector<string> draw(const vector<pair<pair<int, int>, int>> &r) {\n\tvector<string> f(n, string(m, '.'));\n\tvector<vector<int>> h(n, vector<int>(m));\n\tvector<vector<int>> v(n, vector<int>(m));\n\tfor (auto it : r) {\n\t\tint x = it.first.first;\n\t\tint y = it.first.second;\n\t\tint len = it.second;\n\t\t++v[x - len][y];\n\t\tif (x + len + 1 < n)\n\t\t\t--v[x + len + 1][y];\n\t\t++h[x][y - len];\n\t\tif (y + len + 1 < m)\n\t\t\t--h[x][y + len + 1];\t\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (i > 0) v[i][j] += v[i - 1][j];\n\t\t\tif (j > 0) h[i][j] += h[i][j - 1];\n\t\t\tif (v[i][j] > 0 || h[i][j] > 0)\n\t\t\t\tf[i][j] = '*';\n\t\t}\n\t}\n\treturn f;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m;\n\ts = vector<string>(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> s[i];\n\t}\n\t\n\tvector<vector<int>> l(n, vector<int>(m));\n\tvector<vector<int>> r(n, vector<int>(m));\n\tvector<vector<int>> u(n, vector<int>(m));\n\tvector<vector<int>> d(n, vector<int>(m));\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (i > 0) {\n\t\t\t\tif (s[i][j] != '.')\n\t\t\t\t\tu[i][j] = u[i - 1][j] + 1;\n\t\t\t} else {\n\t\t\t\tu[i][j] = s[i][j] != '.';\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tif (s[i][j] != '.')\n\t\t\t\t\tl[i][j] = l[i][j - 1] + 1;\n\t\t\t} else {\n\t\t\t\tl[i][j] = s[i][j] != '.';\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tfor (int j = m - 1; j >= 0; --j) {\n\t\t\tif (i < n - 1) {\n\t\t\t\tif (s[i][j] != '.')\n\t\t\t\t\td[i][j] = d[i + 1][j] + 1;\n\t\t\t} else {\n\t\t\t\td[i][j] = s[i][j] != '.';\n\t\t\t}\n\t\t\tif (j < m - 1) {\n\t\t\t\tif (s[i][j] != '.')\n\t\t\t\t\tr[i][j] = r[i][j + 1] + 1;\n\t\t\t} else {\n\t\t\t\tr[i][j] = s[i][j] != '.';\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<pair<pair<int, int>, int>> ans;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (s[i][j] == '*') {\n\t\t\t\tint len = min(min(u[i][j], l[i][j]), min(d[i][j], r[i][j])) - 1;\n\t\t\t\tif (len != 0) {\n\t\t\t\t\tans.push_back(make_pair(make_pair(i, j), len));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (draw(ans) != s) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << ans.size() << endl;\n\t\tfor (auto it : ans) {\n\t\t\tcout << it.first.first + 1 << \" \" << it.first.second + 1 << \" \" << it.second << endl; \n\t\t}\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}