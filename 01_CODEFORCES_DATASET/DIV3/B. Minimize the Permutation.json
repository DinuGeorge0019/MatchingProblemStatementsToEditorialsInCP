{"link": "https://codeforces.com//contest/1256/problem/B", "problemId": "459825", "shortId": "1256B", "contest_number": "1256", "name": "B. Minimize the Permutation", "statement": "You are given a permutation of length . Recall that the permutation is an array consisting of  distinct integers from  to  in arbitrary order. For example,  is a permutation, but  is not a permutation ( appears twice in the array) and  is also not a permutation ( but there is  in the array).You can perform at most  operations with the given permutation (it is possible that you don't perform any operations at all). The -th operation allows you to swap elements of the given permutation on positions  and . . The operations can be performed in arbitrary order.Your task is to find the lexicographically minimum possible permutation obtained by performing some of the given operations in some order.You can see the definition of the lexicographical order in the notes section.You have to answer  independent test cases.For example, let's consider the permutation . The minimum possible permutation we can obtain is  and we can do it in the following way:  perform the second operation (swap the second and the third elements) and obtain the permutation ;  perform the fourth operation (swap the fourth and the fifth elements) and obtain the permutation ;  perform the third operation (swap the third and the fourth elements) and obtain the permutation .  perform the first operation (swap the first and the second elements) and obtain the permutation ; Another example is . The minimum possible permutation we can obtain is  by performing the third operation (swap the third and the fourth elements).", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the number of elements in the permutation. The second line of the test case contains  distinct integers from  to  \u2014 the given permutation.", "output": "For each test case, print the answer on it \u2014 the lexicograhically minimum possible permutation obtained by performing some of the given operations in some order.", "tutorial": "The following greedy solution works: let's take the minimum element and move it to the leftmost position we can. With this algorithm, all forbidden operations are form the prefix of operations: (), , ..., and so on. So we can carry the position of the leftmost operation we can perform . Initially, it is . We repeat the algorithm until . Let's find the position of the minimum element among elements . Let this position be . If  then let's increase  and continue the algorithm. Otherwise, we need to move the element from the position  to the position  and then set .Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tcin >> a[j];\n\t\t\t--a[j];\n\t\t}\n\t\tint pos = 0;\n\t\twhile (pos < n) {\n\t\t\tint nxt = min_element(a.begin() + pos, a.end()) - a.begin();\n\t\t\tint el = a[nxt];\n\t\t\ta.erase(a.begin() + nxt);\n\t\t\ta.insert(a.begin() + pos, el);\n\t\t\tif (pos == nxt) pos = nxt + 1;\n\t\t\telse pos = nxt;\n\t\t}\n\t\tfor (auto it : a) cout << it + 1 << \" \";\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}