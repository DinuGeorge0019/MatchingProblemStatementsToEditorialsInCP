{"link": "https://codeforces.com//contest/1593/problem/B", "problemId": "1142162", "shortId": "1593B", "contest_number": "1593", "name": "B. Make it Divisible by 25", "statement": "It is given a positive integer . In  move, one can select any single digit and remove it (i.e. one selects some position in the number and removes the digit located at this position). The operation cannot be performed if only one digit remains. If the resulting number contains leading zeroes, they are automatically removed.E.g. if one removes from the number  the -rd digit, the resulting number will be . If one removes from the number  the first digit, the resulting number will be  (the  zeroes going next to the first digit are automatically removed).What is the minimum number of steps to get a number such that it is divisible by  and ? It is guaranteed that, for each  occurring in the input, the answer exists. It is guaranteed that the number  has no leading zeros.", "input": "The first line contains one integer  () \u2014 the number of test cases. Then  test cases follow. Each test case consists of one line containing one integer  (). It is guaranteed that, for each  occurring in the input, the answer exists. It is guaranteed that the number  has no leading zeros.", "output": "For each test case output on a separate line an integer  () \u2014 the minimum number of steps to get a number such that it is divisible by  and positive.", "tutorial": "A number is divisible by  if and only if its last two digits represent one of the following strings: \"\", \"\", \"\", \"\".Let's solve for each string the following subtask: what is the minimum number of characters to be deleted so that the string becomes a suffix of the number. Then, choosing the minimum of the answers for all subtasks, we solve the whole problem.Let's solve the subtask for a string \"\" where '' and '' are digits. We can do it using the following algorithm: let's delete the last digit of the number until it is equal to '', then the second to last digit of the number until it is equal to ''. If it is not possible, then this subtask has no solution (i.e. its result will not affect the answer).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string subseqs[] = { \"00\", \"25\", \"50\", \"75\" };\n\nconst int INF = 100;\n\nint solve(string& s, string& t)\n{\n\tint sptr = s.length() - 1;\n\n\tint ans = 0;\n\twhile (sptr >= 0 && s[sptr] != t[1])\n\t{\n\t\tsptr--;\n\t\tans++;\n\t}\n\n\tif (sptr < 0) return INF;\n\n\tsptr--;\n\n\twhile (sptr >= 0 && s[sptr] != t[0])\n\t{\n\t\tsptr--;\n\t\tans++;\n\t}\n\n\treturn sptr < 0 ? INF : ans;\n}\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\n\twhile (t--)\n\t{\n\t\tstring n;\n\t\tcin >> n;\n\t\t\n\t\tint ans = INF;\n\t\tfor (auto e : subseqs)\n\t\t\tans = min(ans, solve(n, e));\n\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}