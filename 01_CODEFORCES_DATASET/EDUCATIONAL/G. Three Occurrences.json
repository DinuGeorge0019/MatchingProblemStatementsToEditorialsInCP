{"link": "https://codeforces.com//contest/1418/problem/G", "problemId": "727429", "shortId": "1418G", "contest_number": "1418", "name": "G. Three Occurrences", "statement": "You are given an array  consisting of  integers. We denote the subarray  as the array  ().A subarray is considered  if every integer that occurs in this subarray occurs there . For example, the array  has three good subarrays:  ;  ;  . Calculate the number of good subarrays of the given array .", "input": "The first line contains one integer  (). The second line contains  integers , , ...,  ().", "output": "Print one integer \u2014 the number of good subarrays of the array .", "tutorial": "Let's consider two solutions: a non-deterministic and a deterministic one.The random solution goes like that.Let's assign a random integer to each value from  to  (to value, not to a position). Let the value of the subarray be the trit-wise sum of the assigned integers of all values on it. Trit-wise is the analogue of bit-wise sum (xor) but in ternary system. So adding up the same integer three times trit-wise is always equal to zero. Thus, if the value on a subarray is zero then each value appears on it a multiple of three times. How to count the number of such subarrays? Process the array from left to right and store the prefix trit-wise sums in a map. The number of the valid subarrays that end in the current position is the number of occurrences of the current prefix trit-wise sum in a map. The current sum should be added to the map afterwards.However, that's not what the problem asks us to find. Let's consider another problem: count the number of subarray such that each number appears no more than three times. This can be done with two pointers. Process the array from left to right and for each number store the positions it occurred on. If some number appears at least four times than the left pointer should be moved to the next position after the fourth-to-last position. The number of valid subarrays the end in the current position is the distance to the left pointer.Let's combine these problems: maintain the pointer to only the valid positions and remove the prefix trit-wise sums from the map as you increase the pointer. That way the map will only store the valid sums, and they can be added to answer as they are.Assume you use  trits. I guess the probability of the collision is the same as two vectors (out of ) colliding in a -dimensional space with their coordinates being from  to . That will be about  when  (according to birthday paradox) \u2014 and way less if we increase .Overall complexity: .The deterministic solution (a.k.a. the boring one) goes like that.Let's again process the array from left to right. Let the current position be the right border of the segment. Each number makes some constraints on where the left border might be. More specifically, it's two possible segments: between its last occurrence and the current position and between its fourth-to-last occurrence and its third-to-last one. Let's actually invert these segments. Bad segments are from the beginning of the array to the fourth-to-last occurrence, then from the second-to-last occurrence to the last one. So the valid left borders are in such positions that are covered by zero bad segments.Let's keep track of them in a segment tree. Add  on the bad subarrays. Now you have to count the number of  values in a segtree. That's a pretty common problem. As we know that no values can go below ,  should be a minimum element on the segment. So we can store a pair of (minimum on segment, number of minimums on segment). At the end the second value is the number of zeros if the first value is zero.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n\nconst int N = 60;\n\ntypedef array<int, N> num;\n\nnum operator ^(const num &a, const num &b){\n    num c;\n    forn(i, N){\n        c[i] = a[i] + b[i];\n        if (c[i] >= 3) c[i] -= 3;\n    }\n    return c;\n}\n\nmt19937 rnd(42);\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    vector<int> a(n);\n    forn(i, n){\n        scanf(\"%d\", &a[i]);\n        --a[i];\n    }\n    \n    vector<num> nums(n);\n    forn(i, n) forn(j, N) nums[i][j] = rnd() % 3;\n    \n    vector<vector<int>> pos(n);\n    vector<num> pr(1);\n    map<num, int> cnt;\n    cnt[pr[0]] = 1;\n    int cur = 0;\n    long long ans = 0;\n    forn(i, n){\n        pr.push_back(pr.back() ^ nums[a[i]]);\n        pos[a[i]].push_back(i);\n        if (pos[a[i]].size() >= 4){\n            while (cur <= pos[a[i]][int(pos[a[i]].size()) - 4]){\n                --cnt[pr[cur]];\n                ++cur;\n            }\n        }\n        ans += cnt[pr.back()];\n        ++cnt[pr.back()];\n    }\n    \n    printf(\"%lld\\n\", ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}