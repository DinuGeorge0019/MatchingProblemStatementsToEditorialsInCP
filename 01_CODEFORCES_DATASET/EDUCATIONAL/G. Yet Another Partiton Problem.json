{"link": "https://codeforces.com//contest/1175/problem/G", "problemId": "354219", "shortId": "1175G", "contest_number": "1175", "name": "G. Yet Another Partiton Problem", "statement": "You are given array . You need to split it into  subsegments (so every element is included in exactly one subsegment).The weight of a subsegment  is equal to . The weight of a partition is a total weight of all its segments.Find the partition of minimal weight.", "input": "The first line contains two integers  and  (, ) \u2014 the length of the array  and the number of subsegments in the partition. The second line contains  integers  () \u2014 the array .", "output": "Print single integer \u2014 the minimal weight among all possible partitions.", "tutorial": "Important note: the author solution is using both linear Convex hull trick and persistent Li Chao tree. As mentioned in commentaries, applying the Divide-and-Conquer technique can help get rid of Li Chao tree. More about both structures you can read in this article.Let's try to write standard dp we can come up with (arrays will be 0-indexed). Let  be the minimal weight if we splitted prefix of length  in  subsegments. Then we can calculate it as:  [1]. Maximums on segments are inconvenient, let's try to group segments  by the value of . So, we can find such sequence of borders , where for each  . In other words,  and  is the closest from the left position, where . Note, that we can maintain this sequence with stack of maximums.Ok, then for each interval  equation [1] transforms to: Why did we use variables  and ? Because there are two problems:  is needed because we iterate over  and can't recalculate everything;  is needed because sequence  is changing over time, so do the . But what we can already see: we can maintain for each segment Convex hull with linear functions \u2014 so we can take  in logarithmic time. Moreover, we can store values  in other Convex hull to take minimum over all segments in logarithmic time.The problems arise when we try modificate structures while iterating . Fortunately, segments  change not at random, but according to stack of maximums. So all we should handle are:   to merge segment on top of the stack  with current segment  (in case when );  to erase segment on top of the stack along with its value ;  to insert new segment on top of the stack along with its value . To handle the third type is easy, since all Convex hulls can insert elements. There will be at most  such operations on a single layer  and we can ask value  in  and insert a line with .To handle the second type is harder, but possible, since we can make Convex hull persistent and store its versions in the stack. Persistent Convex hull \u2014 persistent Li Chao tree. There will be also  operations in total and they cost us .To handle the first type is trickiest part. Note, that all line coefficients of one convex hull are strictly lower than all line coefficients of the other. So, we can use linear Convex hulls to make insertions to back in amortized . But to merge efficiently, we should use Small-to-Large technique, that's why we should be able also push front in , and, moreover, still be able to ask minimum in . And here comes the hack \u2014  in C++, which can push/pop front/back in amortized  and also have random access iterator to make binary search possible. So, each element of every segment will be transfered  times with cost of amortized  on a single layer .In the end, result complexity is . Space complexity is .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) (int)((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<li, li> pt;\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e9);\n\npt operator -(const pt &a, const pt &b) {\n    return {a.x - b.x, a.y - b.y};\n}\nli operator *(const pt &a, const pt &b) {\n    return a.x * b.x + a.y * b.y;\n}\nli operator %(const pt &a, const pt &b) {\n    return a.x * b.y - a.y * b.x;\n}\npt rotate(const pt &p) {\n    return {-p.y, p.x};\n}\n\nstruct LinearHull {\n    deque<pt> pts, vecs;\n\n    void addRight(const pt &l) {\n        while(!vecs.empty() && vecs.back() * (l - pts.back()) < 0) {\n            vecs.pop_back();\n            pts.pop_back();\n        }\n        if(!pts.empty())\n            vecs.push_back(rotate(l - pts.back()));\n        pts.push_back(l);\n    }\n    void addLeft(const pt &l) {\n        while(!vecs.empty() && vecs.front() * (l - pts.front()) < 0) {\n            vecs.pop_front();\n            pts.pop_front();\n        }\n        if(!pts.empty())\n            vecs.push_front(rotate(pts.front() - l));\n        pts.push_front(l);\n    }\n\n    li getMin(const pt &x) {\n        auto it = lower_bound(vecs.begin(), vecs.end(), x, [](const pt &a, const pt &b) {\n            return a % b > 0;\n        });\n        return x * pts[it - vecs.begin()];\n    }\n};\n\ntypedef unique_ptr<LinearHull> pHull;\n\nvoid mergeHulls(pHull &a, pHull &b) {\n    if(sz(b->pts) >= sz(a->pts)) {\n        for(auto &p : a->pts)\n            b->addRight(p);\n    } else {\n        for(auto it = b->pts.rbegin(); it != b->pts.rend(); it++)\n            a->addLeft(*it);\n        swap(a, b);\n    }\n}\n\nconst int M = 1000 * 1000 + 555;\nint szn = 0;\nstruct node {\n    pt line;\n    node *l, *r;\n\n    node() : line(), l(nullptr), r(nullptr) {}\n    node(pt line, node *l, node *r) : line(move(line)), l(l), r(r) {}\n} nodes[M];\n\ntypedef node* tree;\n\ntree getNode(const pt &line, tree l, tree r) {\n    assert(szn < M);\n    nodes[szn] = node(line, l, r);\n    return &nodes[szn++];\n}\ntree copy(tree v) {\n    if(v == nullptr) return v;\n    return getNode(v->line, v->l, v->r);\n}\n\nli f(const pt &line, int x) {\n    return line * pt{x, 1};\n}\n\ntree addLine(tree v, int l, int r, pt line) {\n    if(!v)\n        return getNode(line, nullptr, nullptr);\n    int mid = (l + r) >> 1;\n    bool lf = f(line, l) < f(v->line, l);\n    bool md = f(line, mid) < f(v->line, mid);\n\n    if(md)\n        swap(v->line, line);\n\n    if(l + 1 == r)\n        return v;\n    else if(lf != md)\n        v->l = addLine(copy(v->l), l, mid, line);\n    else\n        v->r = addLine(copy(v->r), mid, r, line);\n    return v;\n}\n\nli getMin(tree v, int l, int r, int x) {\n    if(!v) return INF64;\n    if(l + 1 == r)\n        return f(v->line, x);\n    int mid = (l + r) >> 1;\n\n    if(x < mid)\n        return min(f(v->line, x), getMin(v->l, l, mid, x));\n    else\n        return min(f(v->line, x), getMin(v->r, mid, r, x));\n}\n\nint n, k;\nvector<li> a;\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    a.resize(n);\n\n    fore(i, 0, n)\n        cin >> a[i];\n    return true;\n}\n\nstruct state {\n    int pos;\n    pHull hull;\n    tree v;\n\n    state() : pos(-1), hull(nullptr), v(nullptr) {}\n};\n\nvector<li> d[2];\n\ninline void solve() {\n    int maxn = (int)*max_element(a.begin(), a.end()) + 3;\n    fore(k, 0, 2)\n        d[k].resize(n + 1, INF64);\n\n    d[0][0] = 0;\n    fore(_k, 1, k + 1) {\n        szn = 0;\n\n        int ck = _k & 1;\n        int nk = ck ^ 1;\n\n        vector< state > st;\n\n        fore(i, 0, sz(d[ck])) {\n            d[ck][i] = INF64;\n            if(!st.empty())\n                d[ck][i] = getMin(st.back().v, 0, maxn, i);\n\n            if(i >= sz(a))\n                continue;\n\n            state curVal;\n            curVal.pos = i;\n            curVal.hull = make_unique<LinearHull>();\n            curVal.hull->addRight({-i, d[nk][i]});\n            curVal.v = nullptr;\n\n            while(!st.empty() && a[st.back().pos] < a[i]) {\n                mergeHulls(st.back().hull, curVal.hull);\n                st.pop_back();\n            }\n            if(!st.empty())\n                curVal.v = st.back().v;\n\n            li val = curVal.hull->getMin({a[i], 1});\n            curVal.v = addLine(copy(curVal.v), 0, maxn, {a[i], val});\n\n            st.push_back(move(curVal));\n        }\n    }\n    cout << d[k & 1][n] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(15);\n\n    if(read()) {\n        solve();\n\n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}