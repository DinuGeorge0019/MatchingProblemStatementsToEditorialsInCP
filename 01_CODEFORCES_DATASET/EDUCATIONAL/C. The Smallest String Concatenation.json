{"link": "https://codeforces.com//contest/632/problem/C", "problemId": "50145", "shortId": "632C", "contest_number": "632", "name": "C. The Smallest String Concatenation", "statement": "You're given a list of  strings . You'd like to concatenate them together in some order such that the resulting string would be lexicographically smallest.Given the list of strings, output the lexicographically smallest concatenation.", "input": "The first line contains integer  \u2014 the number of strings (). Each of the next  lines contains one string  () consisting of only lowercase English letters. The sum of string lengths will not exceed .", "output": "Print the only string  \u2014 the lexicographically smallest string concatenation.", "tutorial": "Let's sort all the strings by comparator  and concatenate them. Let's prove that it's the optimal answer. Let that operator be transitive (so if ). Consider an optimal answer with two strings in reverse order by that operator. Because of the transitivity of operator we can assume that pair of strings are neighbouring. But then we can swap them and get the better answer.\nLet's prove the transitivity of operator. Consider the strings as the -base numbers. Then the relation  equivalent to . The last is simply the relation between real numbers. So we proved the transitivity of the relation .\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define nfor(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\ntemplate<typename A, typename B> inline ostream& operator<< (ostream& out, const pair<A, B>& p) { return out << \"(\" << p.x << \", \" << p.y << \")\"; }\ntemplate<typename T> inline ostream& operator<< (ostream& out, const vector<T>& a) { out << \"[\"; forn(i, sz(a)) { if (i) out << ','; out << ' ' << a[i]; } return out << \" ]\"; } \ntemplate<typename T> inline ostream& operator<< (ostream& out, const set<T>& a) { return out << vector<T>(all(a)); }\n\u00a0\ninline ld gett() { return clock() / ld(CLOCKS_PER_SEC); }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nconst int N = 500500, L = 111;\n\u00a0\nint n;\nstring a[N];\n\u00a0\nbool read() {\n\u00a0 \u00a0 if (!(cin >> n)) return false;\n\u00a0 \u00a0 forn(i, n) {\n\u00a0 \u00a0 \u00a0 \u00a0 static char buf[L];\n\u00a0 \u00a0 \u00a0 \u00a0 assert(scanf(\"%s\", buf) == 1);\n\u00a0 \u00a0 \u00a0 \u00a0 a[i] = string(buf);\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return true;\n}\n\u00a0\ninline bool cmp(const string& a, const string& b) {\n\u00a0 \u00a0 return a + b < b + a;\n}\n\u00a0\nvoid solve() {\n\u00a0 \u00a0 sort(a, a + n, cmp);\n\u00a0 \u00a0 string ans = accumulate(a, a + n, string());\n\u00a0 \u00a0 puts(ans.c_str());\n}\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 ld stime = gett();\n\u00a0 \u00a0 \u00a0 \u00a0 solve();\n\u00a0 \u00a0 \u00a0 \u00a0 cerr << \"Time: \" << gett() - stime << endl;\n\u00a0 \u00a0 \u00a0 \u00a0 //break;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}