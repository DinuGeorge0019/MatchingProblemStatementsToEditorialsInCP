{"link": "https://codeforces.com//contest/1622/problem/D", "problemId": "1242580", "shortId": "1622D", "contest_number": "1622", "name": "D. Shuffle", "statement": "You are given a binary string (i.\u2009e. a string consisting of characters  and/or )  of length . You can perform the following operation with the string  : choose a substring (a contiguous subsequence) of  having   characters  in it, and shuffle it (reorder the characters in the substring as you wish).Calculate the number of different strings which can be obtained from  by performing this operation at most once.", "input": "The first line contains two integers  and  (; ). The second line contains the string  of length , consisting of characters  and/or .", "output": "Print one integer \u2014 the number of different strings which can be obtained from  by performing the described operation at most once. Since the answer can be large, output it modulo .", "tutorial": "We could iterate on the substrings we want to shuffle and try to count the number of ways to reorder their characters, but, unfortunately, there's no easy way to take care of the fact that shuffling different substrings may yield the same result.Instead, we will iterate on the first and the last character that are changed. Let these characters be  and . First of all, let's check that they can belong to the same substring we can shuffle \u2014 it is the case if the string contains at least  characters , and the substring from the -th character to the -th character contains at most  characters .Then, after we've fixed the first and the last characters that are changed, we have to calculate the number of ways to shuffle the characters between them (including them) so that both of these characters are changed. Let's calculate  and  \u2014 the number of characters  and  respectively in the substring. Then, we need to modify these two values: for example, if the -th character is , then since it is the first changed character, it should become , so we need to put  there and decrease  by one. The same for the -th character. Let  and  be the values of  and  after we take care of the fact that the -th and the -th character are fixed. The remaining characters can be in any order, so the number of ways to arrang them is .We can add up these values for all pairs () such that we can shuffle a substring containing these two characters. We won't be counting any string twice because we ensure that  is the first changed character, and  is the last changed character. Don't forget to add  to the answer \u2014 the string we didn't count is the original one.This solution works in , but the problem is solvable in .", "solution": "#include <bits/stdc++.h>     \n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    return x;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    int k;\n    cin >> k;\n    string s;\n    cin >> s;\n    vector<int> p(n + 1);\n    for(int i = 0; i < n; i++) p[i + 1] = p[i] + (s[i] - '0');\n    vector<vector<int>> C(n + 1);\n    for(int i = 0; i <= n; i++)\n    {\n        C[i].resize(i + 1);\n        C[i][0] = C[i][i] = 1;\n        for(int j = 1; j < i; j++)\n            C[i][j] = add(C[i - 1][j], C[i - 1][j - 1]);\n    }\n    int ans = 1;\n    for(int i = 0; i < n; i++)\n        for(int j = i + 1; j < n; j++)\n        {\n            int cnt = j + 1 - i;\n            int cnt1 = p[j + 1] - p[i];\n            if(cnt1 > k || p[n] < k) continue;\n            cnt -= 2;\n            if(s[i] == '0') cnt1--;\n            if(s[j] == '0') cnt1--;\n            if(cnt1 <= cnt && cnt1 >= 0 && cnt >= 0)\n                ans = add(ans, C[cnt][cnt1]);\n        }\n    cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}