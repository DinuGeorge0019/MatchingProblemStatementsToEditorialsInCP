{"link": "https://codeforces.com//contest/803/problem/G", "problemId": "104512", "shortId": "803G", "contest_number": "803", "name": "G. Periodic RMQ Problem", "statement": "You are given an array  consisting of positive integers and  queries to this array. There are two types of queries:       \u2014 for each index  such that  set .     \u2014 find the minimum among such  that . We decided that this problem is too easy. So the array  is given in a compressed form: there is an array  consisting of  elements and a number  in the input, and before all queries  is equal to the concatenation of  arrays  (so the size of  is ).", "input": "The first line contains two integers  and  (, ). The second line contains  integers \u2014 elements of the array  (). The third line contains one integer  (). Then  lines follow, each representing a query. Each query is given either as     \u2014 set all elements in the segment from  till  (including borders) to  (, ) or as    \u2014 find the minimum among all elements in the segment from  till  ().", "output": "For each query of type  print the answer to this query \u2014 the minimum on the corresponding segment.", "tutorial": "Most of the solutions used the fact that we can read all the queries, compress them and process after the compression using simple segment tree. But there is also an online solution:Let's build a sparse table on array  to answer queries on segments that are not modified in . To process modification segments, we will use implicit segment tree and lazy propagation technique. We do not build the whole segment tree; instead, in the beginning we have only one node for segment , and if some modification query accesses some node, but does not modify the complete segment this node maintains, only then we create the children of this node. So, the leaves of the segment tree are the nodes such that their segments are completely set to some value or not modified at all. Since each modification query affects only  nodes, the resulting complexity will be .", "solution": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int INF = (int)1e9 + 5;\n\nstruct Node\n{\n    int l, r;\n    int val;\n    int toPush;\n\n    Node() : l(), r(), val(INF), toPush(-1) {}\n    Node(int _l, int _r) : l(_l), r(_r), val(INF), toPush(-1) {}\n};\n\nconst int N = 1 << 18;\nNode tree[2 * N];\nint a[N];\nint n, k, m;\nint q[N][4];\nint xs[N];\nint xsSz;\n\nvoid build()\n{\n    for (int i = 0; i < N; i++)\n        tree[N + i] = Node(i, i + 1);\n    for (int i = N - 1; i > 0; i--)\n        tree[i] = Node(tree[2 * i].l, tree[2 * i + 1].r);\n    return;\n}\n\nvoid push(int v)\n{\n    if (v >= N) throw;\n    if (tree[v].toPush == -1) return;\n    for (int u = 2 * v; u < 2 * v + 2; u++)\n    {\n        tree[u].val = tree[v].toPush;\n        tree[u].toPush = tree[v].toPush;\n    }\n    tree[v].toPush = -1;\n    return;\n}\nvoid update(int v)\n{\n    if (v >= N) throw;\n    tree[v].val = min(tree[2 * v].val, tree[2 * v + 1].val);\n    return;\n}\n\nvoid setOnSegm(int v, int l, int r, int x)\n{\n    if (l <= tree[v].l && tree[v].r <= r)\n    {\n        tree[v].val = tree[v].toPush = x;\n        return;\n    }\n    if (l >= tree[v].r || tree[v].l >= r) return;\n    push(v);\n    setOnSegm(2 * v, l, r, x);\n    setOnSegm(2 * v + 1, l, r, x);\n    update(v);\n    return;\n}\n\nint getMin(int v, int l, int r)\n{\n    if (l <= tree[v].l && tree[v].r <= r)\n        return tree[v].val;\n    if (l >= tree[v].r || tree[v].l >= r)\n        return INF;\n    push(v);\n    return min(getMin(2 * v, l, r), getMin(2 * v + 1, l, r));\n}\n\nint getCyclicMin(int l, int r)\n{\n    if (r - l >= n)\n        return getMin(1, 0, n);\n    l %= n;\n    r %= n;\n    if (l < r)\n        return getMin(1, l, r);\n    else\n        return min(getMin(1, l, n), getMin(1, 0, r));\n}\n\nvoid read()\n{\n    scanf(\"%d%d\", &n, &k);\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\", &a[i]);\n    build();\n    for (int i = 0; i < n; i++)\n        setOnSegm(1, i, i + 1, a[i]);\n    scanf(\"%d\", &m);\n    xsSz = 0;\n    xs[xsSz++] = 0;\n    xs[xsSz++] = n * k;\n    for (int i = 0; i < m; i++)\n    {\n        scanf(\"%d%d%d\", &q[i][0], &q[i][1], &q[i][2]);\n        if (q[i][0] == 1)\n            scanf(\"%d\", &q[i][3]);\n        q[i][1]--;\n        xs[xsSz++] = q[i][1];\n        xs[xsSz++] = q[i][2];\n    }\n    sort(xs, xs + xsSz);\n    xsSz = unique(xs, xs + xsSz) - xs;\n    for (int i = 0; i < m; i++)\n        for (int j = 1; j < 3; j++)\n            q[i][j] = lower_bound(xs, xs + xsSz, q[i][j]) - xs;\n    for (int i = 0; i < xsSz - 1; i++)\n        a[i] = getCyclicMin(xs[i], xs[i + 1]);\n    build();\n    n = xsSz - 1;\n    for (int i = 0; i < n; i++)\n        setOnSegm(1, i, i + 1, a[i]);\n    return;\n}\n\nint main()\n{\n//    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n\n    read();\n    for (int i = 0; i < m; i++)\n    {\n        if (q[i][0] == 1)\n            setOnSegm(1, q[i][1], q[i][2], q[i][3]);\n        else\n            printf(\"%d\\n\", getMin(1, q[i][1], q[i][2]));\n    }\n\n    return 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}