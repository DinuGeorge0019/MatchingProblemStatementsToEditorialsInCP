{"link": "https://codeforces.com//contest/1000/problem/C", "problemId": "193656", "shortId": "1000C", "contest_number": "1000", "name": "C. Covered Points Count", "statement": "You are given  segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.Your task is the following: for every , calculate the number of points with integer coordinates such that the number of segments that cover these points equals . A segment with endpoints  and  covers point  if and only if .", "input": "The first line of the input contains one integer  () \u2014 the number of segments. The next  lines contain segments. The -th line contains a pair of integers  () \u2014 the endpoints of the -th segment.", "output": "Print  space separated integers , where  is equal to the number of points such that the number of segments that cover these points equals to .", "tutorial": "This problem with small coordinates can be solved using partial sums and some easy counting. Let's carry an array , where  will be equal to the number of segments that cover the point with coordinate . How to calculate  in ?For each segment () let's add  to  and  to . Now build on this array prefix sums and notice that  equals the number of segments that cover the point with coordinate . Then  will be equal to . All the answers can be calculated in  in total. So the total complexity of this solution is .But in our problem it is too slow to build an entire array . So what should we do? It is obvious that if any coordinate  is not equals some  or some  then . So we do not need carry all the positions explicitly. Let's carry all  and  in some logarithmic data structure or let's use the coordinate compression method.The coordinate compression method allows us to transform the set of big sparse objects to the set of small compressed objects maintaining the relative order. In our problems let's make the following things: push all  and  in vector , sort this vector, keep only unique values and then use the position of elements in vector  instead of original value (any position can be found in  by binary search or standard methods as  in C++).So the first part of the solution works in . Answer can be calculated using almost the same approach as in solution to this problem with small coordinates. But now we know that between two adjacent elements  and  there is exactly  points with answer equals to . So if we will iterate over all pairs of the adjacent elements  and  and add  to the , we will calculate all the answers in .So the total complexity of the solution is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<pair<long long, long long>> a(n);\n\tvector<long long> cval;\n\tfor (auto &i : a) {\n\t\tscanf(\"%lld %lld\", &i.first, &i.second);\n\t\tcval.push_back(i.first);\n\t\tcval.push_back(i.second + 1);\n\t\t\n\t}\n\tsort(cval.begin(), cval.end());\n\tcval.resize(unique(cval.begin(), cval.end()) - cval.begin());\n\t\n\tvector<int> cnt(2 * n);\n\tfor (auto &i : a) {\n\t\tint posl = lower_bound(cval.begin(), cval.end(), i.first) - cval.begin();\n\t\tint posr = lower_bound(cval.begin(), cval.end(), i.second + 1) - cval.begin();\n\t\t++cnt[posl];\n\t\t--cnt[posr];\n\t}\n\tfor (int i = 1; i < 2 * n; ++i)\n\t\tcnt[i] += cnt[i - 1];\n\t\t\n\tvector<long long> ans(n + 1);\n\tfor (int i = 1; i < 2 * n; ++i)\n\t\tans[cnt[i - 1]] += cval[i] - cval[i - 1];\n\t\n\tfor (int i = 1; i <= n; ++i)\n\t\tprintf(\"%lld \", ans[i]);\n\tputs(\"\");\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}