{"link": "https://codeforces.com//contest/1238/problem/F", "problemId": "434110", "shortId": "1238F", "contest_number": "1238", "name": "F. The Maximum Subtree", "statement": "Assume that you have  one-dimensional segments  (each segment is denoted by two integers \u2014 its endpoints). Then you can build the following graph on these segments. The graph consists of  vertexes, and there is an edge between the -th and the -th vertexes () if and only if the segments  and  intersect (there exists at least one point that belongs to both of them).For example, if , then the resulting graph is the following:  A tree of size  is good if it is possible to choose  one-dimensional segments so that the graph built on these segments coincides with this tree.You are given a tree, you have to find its good subtree with maximum possible size. Recall that a subtree is a connected subgraph of a tree.Note that you have to answer  independent queries.", "input": "The first line contains one integer  () \u2014 the number of the queries.  The first line of each query contains one integer  () \u2014 the number of vertices in the tree. Each of the next  lines contains two integers  and  () denoting an edge between vertices  and . It is guaranteed that the given graph is a tree. It is guaranteed that the sum of all  does not exceed .", "output": "For each query print one integer \u2014 the maximum size of a good subtree of the given tree.", "tutorial": "At first let's understand which trees are good. For this, let's consider some vertex  (we denote its segment as ) which is not a leaf. Also let's consider some adjacent vertex  (we denote its segment as ) which also is not leaf. It is claimed that segment  can't be inside segment  (it's means ) and vice versa. It's true because if segment  is inside the segment  then some vertex  adjacent with  also will be adjacent with . So any non-leaf vertex can be adjacent with at most  non-leaf vertexes. Therefore good tree is a path with a leafs adjacent to this path.So all the have to do it's find the such subtree of maximum size. We can do it by subtree dynamic programming.At first, let chose the root of the tree \u2014 some not leaf vertex. Let  be the answer for the subtree with root in  and dp_{v, 1} be the answer for the subtree with root in  if we already took  and its parent to the answer.It can be calculated as follows:   ;  , there  is a first maximum of all , and  is a second maximum, and  is a degree of vertex ;  . ", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 99;\n\nint n;\nvector <int> g[N];\nint d[N];\nint dp[N][2];\n\nvoid dfs(int v, int p){\n\tvector <int> d1;\n\tdp[v][1] = d[v] - 1;\n\tfor(auto to : g[v]){\n\t\tif(to == p) continue;\n\t\tdfs(to, v);\n\t\tdp[v][0] = max(dp[v][0], dp[to][0]);\n\t\tif(g[to].size() > 1){\n\t\t\td1.push_back(dp[to][1]);\n\t\t\tdp[v][1] = max(dp[v][1], d[v] + dp[to][1] - 1);\t\n\t\t}\n\t}\n\n\tsort(d1.rbegin(), d1.rend());\n\tint x = d[v] + 1;\n\tfor(int i = 0; i < 2; ++i)\n\t\tif(i < d1.size())\n\t\t\tx += d1[i];\n    dp[v][0] = max(dp[v][0], x);\n}\n\nint main() {\t\n    int q;\n    scanf(\"%d\", &q);\n    for(int qc = 0; qc < q; ++qc){\n    \tscanf(\"%d\", &n);\n    \tfor(int i = 0; i < n; ++i){\n    \t    g[i].clear();\n    \t    d[i] = 0;\n    \t    dp[i][0] = dp[i][1] = 0;\n    \t}\n    \tfor(int i = 0; i < n - 1; ++i){\n    \t\tint u, v;\n    \t\tscanf(\"%d %d\", &u, &v);\n    \t\t--u, --v;\n    \t\tg[u].push_back(v), g[v].push_back(u);\n    \t}\n    \n        if(n <= 2){\n            printf(\"%d\\n\", n);\n            continue;\n        }\n        \n    \tfor(int v = 0; v < n; ++v){\n    \t\t//d[v] = 1;\n    \t\t//for(auto to : g[v])\t\n    \t\t//\td[v] += g[to].size() == 1;\n    \t\td[v] = g[v].size();\n    \t}\n        \n        int r = -1;\n        for(int v = 0; v < n; ++v)\n            if(g[v].size() != 1)\n                r = v;\n                \n    \tdfs(r, r);\n    \tprintf(\"%d\\n\", dp[r][0]);\n    }\n\treturn 0;\n}                             \t\n", "interactive": false, "noSolution": false, "noTutorial": false}