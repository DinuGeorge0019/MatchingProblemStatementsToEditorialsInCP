{"link": "https://codeforces.com//contest/818/problem/E", "problemId": "112249", "shortId": "818E", "contest_number": "818", "name": "E. Card Game Again", "statement": "Vova again tries to play some computer card game.The rules of deck creation in this game are simple. Vova is given an existing deck of  cards and a magic number . The order of the cards in the deck is fixed. Each card has a number written on it; number  is written on the -th card in the deck.After receiving the deck and the magic number, Vova removes  (possibly ) cards from the top of the deck,  (possibly ) cards from the bottom of the deck, and the rest of the deck is his new deck (Vova has to leave at least one card in the deck after removing cards). So Vova's new deck actually contains cards , , ... ,  from the original deck.Vova's new deck is considered  iff the product of all numbers written on the cards in his new deck is divisible by . So Vova received a deck (possibly not a  one) and a number , and now he wonders, how many ways are there to choose  and  so the deck he will get after removing  cards from the top and  cards from the bottom is ?", "input": "The first line contains two integers  and  (, ). The second line contains  integers , , ...,  () \u2014 the numbers written on the cards.", "output": "Print the number of ways to choose  and  so the resulting deck is .", "tutorial": "Let's use two pointers.Firstly you need to learn to factorize any number in no more than . We don't actually need any of their prime divisors except for those that are presented in . So let's factorize  in . After that check for the maximum power of each useful prime will work in  for each number.Now notice that if some segment  has its product divisible by  then all segments  for () will also have products divisible by .Now we have to find the smallest  for each  out there. That's where two pointers kick in. Let's maintain the current product of the segment in factorized form (only useful primes), as in normal form its enormous. The power of some prime in this form is the sum of powers of this prime in all the numbers in the segment. We firstly move the left border of the segment one step to the right and then keep moving the right border to the right until power of at least one prime number in the product is smaller than in . It means that it is not divisible by . Moving the left border means subtracting all the powers of useful primes of number  from the product and moving the right border is adding all the powers of useful primes of .The first time we reach such a segment, we add () to answer (consider  -indexed).Overall complexity: , where  is up to .", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 101010\ntypedef long long LL;\nint n , k , a[ N ] , t[ N ];\nbool p[ N ];\nvoid init(){\n  cin >> n >> k;\n  for( int i = 0 ; i < n ; i ++ )\n    cin >> a[ i ];\n}\nint g[ N ];\nvoid go( int pp ){\n  int nd = 0;\n  while( k % pp == 0 )\n    nd ++, k /= pp;\n  for( int i = 0 ; i < n ; i ++ ){\n    g[ i ] = 0;\n    while( a[ i ] % pp == 0 )\n      g[ i ] ++, a[ i ] /= pp;\n  }\n  for( int i = 0 , j = -1 , c = 0 ; i < n ; i ++ ){\n    while( j < n and c < nd ) c += g[ ++ j ];\n    t[ i ] = max( t[ i ] , j );\n    c -= g[ i ];\n  }\n}\nvoid solve(){\n  if( k == 1 ){\n    cout << (LL)( n + 1 ) * n / 2 << endl;\n    return;\n  }\n  for( int i = 2 ; i < N ; i ++ ) if( !p[ i ] ){\n    if( k % i == 0 ) go( i );\n    for( int j = i ; j < N ; j += i )\n      p[ j ] = true;\n  }\n  if( k > 1 ) go( k );\n  LL ans = 0;\n  for( int i = 0 ; i < n ; i ++ )\n    ans += n - t[ i ];\n  cout << ans << endl;\n}\nint main(){\n  init();\n  solve();\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}