{"link": "https://codeforces.com//contest/1140/problem/E", "problemId": "317588", "shortId": "1140E", "contest_number": "1140", "name": "E. Palindrome-less Arrays", "statement": "Let's denote that some array  is  if it contains a subarray  of odd length more than  ( and  is odd) such that  .If an array is not bad, it is .Now you are given an array . Some elements are replaced by . Calculate the number of good arrays you can obtain by replacing each  with some integer from  to .Since the answer can be large, print it modulo .", "input": "The first line contains two integers  and  () \u2014 the length of array  and the size of \"alphabet\", i.\u2009e., the upper bound on the numbers you may use to replace . The second line contains  integers  ( or ) \u2014 the array .", "output": "Print one integer \u2014 the number of good arrays you can get, modulo .", "tutorial": "At first, \"array contains a palindromic subarray of length \" is equivalent to \"array contains a palindromic subarray of length \". So we need to calculate number of arrays without palindromes of length . It's equivalent to finding arrays where  for all appropriate .Note, that  and  have same parity, so all odd and all even positions in array are independent, and answer is the product of the number of ways to choose numbers for odd positions, and the number of ways to choose numbers for even positions.In terms of same parity our condition morphs to  and we need to calculate all ways to replace ()-s in such way that all pairs of consecutive elements are different.To calculate it let's look at sequences of consecutive ()-s. They will look like  with  ()-s, where  and  are positive (case where  is empty can be considered as , case with empty  is solved the same way).In the end we need to find a way to calculate the number of those sequences. There are only two fundamental types of sequences:  (same value from both ends) and  (). Exact values of  and  don't really matter.Let's find a way to calculate both values (name them  and ) for  consecutive ()-s in  time. Base values: .Let's try to choose value of  in the middle of sequence: if , then we can split sequence in two sequences of length  and  and .If  then just iterate over value of last , then  and .Resulting complexity is .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\nconst int MOD = 998244353;\nint norm(int a) {\n    while(a >= MOD) a -= MOD;\n    while(a < 0) a += MOD;\n    return a;\n}\nint mul(int a, int b) {\n    return int(a * 1ll * b % MOD);\n}\n\nint n, k;\nvector<int> a;\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    a.resize(n);\n    fore(i, 0, n)\n        cin >> a[i];\n    return true;\n}\n\npair<int, int> calc(int len) {\n    if(len == 0) return {0, 1};\n    if(len & 1) {\n        auto res = calc(len >> 1);\n        return {norm(mul(res.x, res.x) + mul(k - 1, mul(res.y, res.y))),\n                norm(mul(2, mul(res.x, res.y)) + mul(k - 2, mul(res.y, res.y)))};\n    }\n    auto res = calc(len - 1);\n    return {mul(k - 1, res.y), norm(res.x + mul(k - 2, res.y))};\n}\n\nvector<int> curArray;\n\nint calcSeg(int l, int r) {\n    if(r >= sz(curArray)) {\n        int len = r - l - 1, cf = 1;\n        if(l < 0)\n            len--, cf = k;\n        if(len == 0) return cf;\n\n        auto res = calc(len - 1);\n        return mul(cf, norm(res.x + mul(k - 1, res.y)));\n    }\n    if(l < 0) {\n        if(r - l == 1) return 1;\n        auto res = calc(r - l - 2);\n        return norm(res.x + mul(k - 1, res.y));\n    }\n    auto res = calc(r - l - 1);\n    return curArray[l] == curArray[r] ? res.x : res.y;\n}\n\ninline void solve() {\n    int ans = 1;\n    fore(k, 0, 2) {\n        curArray.clear();\n        for(int i = 0; 2 * i + k < n; i++)\n            curArray.push_back(a[2 * i + k]);\n\n        int lst = -1;\n        fore(i, 0, sz(curArray)){\n            if(curArray[i] == -1) continue;\n            ans = mul(ans, calcSeg(lst, i));\n            lst = i;\n        }\n        ans = mul(ans, calcSeg(lst, sz(curArray)));\n    }\n    cout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(15);\n\n    if(read()) {\n        solve();\n\n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}