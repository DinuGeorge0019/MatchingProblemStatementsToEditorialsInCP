{"link": "https://codeforces.com//contest/946/problem/G", "problemId": "162812", "shortId": "946G", "contest_number": "946", "name": "G. Almost Increasing Array", "statement": "We call an array  if we can erase not more than one element from it so that the array becomes strictly increasing (that is, every element is striclty greater than every element before it).You are given an array  consisting of  elements. You are allowed to replace any element with any integer number (and you may do so any number of times you need). What is the minimum number of replacements you have to perform in order to make the array ?", "input": "The first line contains one integer  () \u2014 the number of elements in . The second line contains  integers , , ...,  () \u2014 the array .", "output": "Print the minimum number of replaces you have to perform so that  is .", "tutorial": "If the problem was to make the array strictly increasing, then we could use the following approach: for every element subtract its index from it, find the longest non-decreasing subsequence, and change every element not belonging to this sequence. In this problem we can use a similar technique.Let's iterate on the element we will remove after changing everything we need (let's call it ). For every  we will subtract  from , and for every  we will subtract  from . Let's maintain the longest non-decreasing subsequence ending in every element on prefix, and the longest non-decreasing subsequence starting in every element on suffix (this can be done by a lot of different techniques, for example, two segment trees and rollbacking, which is used in our model solution). Then we need to somehow merge these sequences. The easiest way to do it is to consider only the subsequence ending in element  (since if we will need to consider the subsequence ending in some index less than , we would check this possibility choosing other value of ) and use some data structure (BIT, segment tree or something similar) to find the longest subsequence that can be appended to the one we fixed. After checking if we need to delete element , we add it to the data structure on prefix, remove element  from the data structure on suffix, check if we have to remove element  and so on.Model solution: https://pastebin.com/BiaFgYx6", "solution": "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\nconst int N=2e5+10;\nint n,a[N];\n\nint al[N],ar[N];\nPII hl[N];\nint solve() {\n    REP1(i,1,n) a[i]+=n-i+1;\n    dump(VI(a+1,a+n+1));\n    REP1(i,0,n) al[i]=INT_MAX;\n    REP1(i,1,n) {\n        int p=upper_bound(al,al+n+1,a[i])-al;\n        hl[i]={p,al[p]};\n        al[p]=a[i];\n    }\n    int mx=lower_bound(al,al+n+1,INT_MAX)-al;\n    for ( int i=n; i>=1; i-- ) {\n        int p=hl[i].first,v=hl[i].second;\n        al[p]=v;\n        int pr=upper_bound(ar,ar+n+1,v-1,greater<int>())-ar;\n        dump(i,p,v,VI(al,al+n+1),VI(ar,ar+n+1),pr);\n        chkmax(mx,p+pr);\n\n        if ( i>1 ) {\n            int z=hl[i-1].first;\n            int zr=upper_bound(ar,ar+n+1,a[i-1]-1,greater<int>())-ar;\n            dump(z,zr,a[i-1]-1);\n            chkmax(mx,z+1+zr);\n        }\n\n        int q=upper_bound(ar,ar+n+1,a[i],greater<int>())-ar;\n        int ql=upper_bound(al,al+n+1,a[i]+1)-al;\n        chkmax(mx,q+ql);\n        ar[q]=a[i];\n    }\n    return max(0,n-1-mx);\n}\n\nvoid main() {\n    R(n);\n    REP1(i,1,n) R(a[i]);\n    // int slow_ans=slow();\n    int ans=solve();\n    W(ans);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n", "interactive": false, "noSolution": false, "noTutorial": false}