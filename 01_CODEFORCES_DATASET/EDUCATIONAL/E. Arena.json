{"link": "https://codeforces.com//contest/1606/problem/E", "problemId": "1163616", "shortId": "1606E", "contest_number": "1606", "name": "E. Arena", "statement": "There are  heroes fighting in the arena. Initially, the -th hero has  health points.The fight in the arena takes place in several rounds. At the beginning of each round, each alive hero deals  damage to all other heroes. Hits of all heroes occur simultaneously. Heroes whose health is less than  at the end of the round are considered killed.If exactly  hero remains alive after a certain round, then he is declared the winner. Otherwise, there is no winner.Your task is to calculate the number of ways to choose the initial health points for each hero , where , so that there is no winner of the fight. The number of ways can be very large, so print it modulo . Two ways are considered different if at least one hero has a different amount of health. For example,  and  are different.", "input": "The only line contains two integers  and  ().", "output": "Print one integer\u00a0\u2014 the number of ways to choose the initial health points for each hero , where , so that there is no winner of the fight, taken modulo . ", "tutorial": "Let's calculate the following dynamic programming \u00a0\u2014 the number of ways to choose the initial health if there are  heroes still alive, and they already received  damage. Let's iterate over \u00a0\u2014 the number of heroes that will survive after the next round. Then we have to make a transition to the state , where  (the minimum of the maximum allowed health and  plus the damage done in this round). It remains to understand with what coefficient we should make this transition in dynamic programming. This coefficient is equal to \u00a0\u2014 the number of ways to choose which of the  living heroes will die in this round multiplied by the number of ways to choose health for these  heroes (because their health is greater than  so that they are still alive at the moment, but not more than  so that they are guaranteed to die in this round). Of course, we don't make any transitions from the states  where , since they represent the fights that have already finished.The answer is the sum of all  for every .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 505;\nconst int MOD = 998244353;\n\nint n, x;\nint c[N][N], dp[N][N];\n\nint add(int x, int y) {\n  x += y;\n  if (x >= MOD) x -= MOD;\n  return x;\n}\n\nint mul(int x, int y) {\n  return x * 1ll * y % MOD;\n}\n\nint main() {\n  cin >> n >> x;\n  for (int i = 0; i <= n; ++i) {\n    c[i][0] = c[i][i] = 1;\n    for (int j = 1; j < i; ++j) \n      c[i][j] = add(c[i - 1][j], c[i - 1][j - 1]);\n  }\n  dp[n][0] = 1;\n  for (int i = n; i > 1; i--) {\n    for (int j = 0; j < x; ++j) {\n      if (!dp[i][j]) continue;\n      int pw = 1, nj = min(x, j + i - 1);\n      for (int k = i; k >= 0; k--) {\n        dp[k][nj] = add(dp[k][nj], mul(dp[i][j], mul(c[i][k], pw)));\n        pw = mul(pw, nj - j);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i <= x; ++i)\n    ans = add(ans, dp[0][i]);\n  cout << ans << endl;\n} ", "interactive": false, "noSolution": false, "noTutorial": false}