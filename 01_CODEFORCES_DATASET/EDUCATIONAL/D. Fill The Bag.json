{"link": "https://codeforces.com//contest/1303/problem/D", "problemId": "538603", "shortId": "1303D", "contest_number": "1303", "name": "D. Fill The Bag", "statement": "You have a bag of size . Also you have  boxes. The size of -th box is , where each  is an integer non-negative power of two.You can divide boxes into two parts of equal size. Your goal is to fill the bag completely.For example, if  and  then you have to divide the box of size  into two parts of size , and then divide the box of size . So you can fill the bag with boxes of size ,  and .Calculate the minimum number of divisions required to fill the bag of size .", "input": "The first line contains one integer  () \u2014 the number of test cases. The first line of each test case contains two integers  and  () \u2014 the size of bag and the number of boxes, respectively. The second line of each test case contains  integers  () \u2014 the sizes of boxes. It is guaranteed that each  is a power of two. It is also guaranteed that sum of all  over all test cases does not exceed .", "output": "For each test case print one integer \u2014 the minimum number of divisions required to fill the bag of size  (or , if it is impossible).", "tutorial": "If , then the answer is , because the just can divide all boxes to size  and then fill the bag. Otherwise the answer is .If the answer is , let's calculate the minimum number of divisions. Let's consider all boxes from small to large. Presume that now we consider boxes of size . Then there are three cases:   if in binary representation of  the -th bit is equal to , then we don't need boxes of size  and we can merge it into boxes of size ;  if in binary representation of  the -th bit is equal to  and we have at most one box of size , then we have to put it box in the bag and then merge the remaining boxes of size  into boxes of size ;  if in binary representation of  the -th bit is equal to  and we have not boxes of size , then we have to divide the large box into box of size  (let's presume that it's box of size ). After that we just continue this algorithm with box of size . ", "solution": "from math import log2\n\nfor t in range(int(input())):\n    n, m = map(int, input().split())\n    c = [0] * 61\n    s = 0\n    for x in map(int, input().split()):\n        c[int(log2(x))] += 1\n        s += x\n\n    if s < n:\n        print(-1)\n        continue\n\n    i, res = 0, 0\n    while i < 60:\n        if (1<<i)&n != 0:\n            if c[i] > 0:\n                c[i] -= 1\n            else:\n                while i < 60 and c[i] == 0:\n                    i += 1\n                    res += 1\n                c[i] -= 1\n                continue\n        c[i + 1] += c[i] // 2\n        i += 1\n\n    print(res)", "interactive": false, "noSolution": false, "noTutorial": false}