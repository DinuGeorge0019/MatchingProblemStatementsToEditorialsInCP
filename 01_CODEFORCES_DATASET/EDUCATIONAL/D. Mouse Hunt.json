{"link": "https://codeforces.com//contest/1027/problem/D", "problemId": "209491", "shortId": "1027D", "contest_number": "1027", "name": "D. Mouse Hunt", "statement": "Medicine faculty of Berland State University has just finished their admission campaign. As usual, about  of applicants are girls and majority of them are going to live in the university dormitory for the next  (hopefully) years.The dormitory consists of  rooms and a single mouse! Girls decided to set mouse traps in some rooms to get rid of the horrible monster. Setting a trap in room number  costs  burles. Rooms are numbered from  to .Mouse doesn't sit in place all the time, it constantly runs. If it is in room  in second  then it will run to room  in second  without visiting any other rooms inbetween ( means that mouse won't leave room ). It's second  in the start. If the mouse is in some room with a mouse trap in it, then the mouse get caught into this trap.That would have been so easy if the girls actually knew where the mouse at. Unfortunately, that's not the case, mouse can be in any room from  to  at second .What it the minimal total amount of burles girls can spend to set the traps in order to guarantee that the mouse will eventually be caught no matter the room it started from?", "input": "The first line contains as single integers  () \u2014 the number of rooms in the dormitory. The second line contains  integers  () \u2014  is the cost of setting the trap in room number . The third line contains  integers  () \u2014  is the room the mouse will run to the next second after being in room .", "output": "Print a single integer \u2014 the minimal total amount of burles girls can spend to set the traps in order to guarantee that the mouse will eventually be caught no matter the room it started from.", "tutorial": "Mouse jumps on a cycle at some point, no matter the starting vertex, thus it's always the most profitable to set traps on cycles. The structure of the graph implies that there are no intersecting cycles. Moreover, mouse will visit each vertex of the cycle, so it's enough to set exactly one trap on each cycle. The only thing left is to find the cheapest vertex of each cycle. This can be done by a simple dfs.Overall complexity: .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define forn(i, n) fore(i, 0, n)\n\n#define mp make_pair\n#define pb push_back\n\n#define sz(a) int((a).size())\n#define all(a) (a).begin(), (a).end()\n#define sqr(a) ((a) * (a))\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<li, li> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    forn(i, sz(v)) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9;\n\nint n;\nvector<int> a, c;\n\ninline bool read() {\n    if(!(cin >> n))\n        return false;\n    c.assign(n, 0);\n    a.assign(n, 0);\n\n    forn(i, n)\n        assert(scanf(\"%d\", &c[i]) == 1);\n    forn(i, n) {\n        assert(scanf(\"%d\", &a[i]) == 1);\n        a[i]--;\n    }\n    return true;\n}\n\nvector< vector<int> > cycles;\n\nvector<char> used;\nvector<int> path;\n\nvoid dfs(int v) {\n    path.push_back(v);\n    used[v] = 1;\n\n    int to = a[v];\n    if(used[to] != 2) {\n        if(used[to] == 1) {\n            cycles.emplace_back();\n\n            int id = sz(path) - 1;\n            while(path[id] != to)\n                cycles.back().push_back(path[id--]);\n            cycles.back().push_back(to);\n        } else\n            dfs(to);\n    }\n    path.pop_back();\n    used[v] = 2;\n}\n\ninline void solve() {\n    used.assign(n, 0);\n\n    forn(i, n) {\n        if (!used[i])\n            dfs(i);\n    }\n\n    li ans = 0;\n    for(auto &cur : cycles) {\n        int mn = c[cur[0]];\n        for(int v : cur)\n            mn = min(mn, c[v]);\n        ans += mn;\n    }\n    cout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n\n    if(read()) {\n        solve();\n\n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}