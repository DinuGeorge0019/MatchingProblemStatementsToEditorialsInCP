{"link": "https://codeforces.com//contest/946/problem/E", "problemId": "162810", "shortId": "946E", "contest_number": "946", "name": "E. Largest Beautiful Number", "statement": ".Let's call a positive integer   if its decimal representation without leading zeroes contains even number of digits, and there exists a permutation of this representation which is palindromic. For example,  is a beautiful number, since it contains  digits, and there exists a palindromic permutation .Given a positive integer , find the largest beautiful number which is less than .", "input": "The first line contains one integer  () \u2014 the number of testcases you have to solve. Then  lines follow, each representing one testcase and containing one string which is the decimal representation of number . It is guaranteed that this string has even length, contains no leading zeroes, and there exists at least one beautiful number less than . The sum of lengths of  over all testcases doesn't exceed .", "output": "For each testcase print one line containing the largest beautiful number which is less than  (it is guaranteed that the answer exists).", "tutorial": "This is pretty typical problem on greedy construction: you are asked to build lexicographically maximal string. In the majority of cases it's done like this. Imagine you've built some prefix of length  with all numbers equal to the prefix of length  of the original string. You are also sure there exists some suffix for it that will give proper beautiful number.Now you have two options: you either put  if possible and proceed to the same task of longer prefix or you put the smaller number and fill the entire suffix with the maximum possible beautiful number you can obtain.Now you should learn how to check if any valid suffix exists. It means at least the smallest possible beautiful number with current prefix is smaller than . It's built like this. Let  be the number of digits which currently have odd number of occurences. You put all zeroes but the last  digits and then output these odd occurence number digits in increasing order. The first part can be checked with partial sums on the number of zeroes on segment in the original string and the second part has its length not greater than  and can be checked naively. Overall complexity: .", "solution": "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\nconst int N=2e5+10;\nchar s[N],z[N];\nint n;\n\nbool solve( int p, array<int,10> c ) {\n    c[z[p]-'0']++;\n    dump(p,z,c);\n    {\n        int odd=0;\n        REP(i,10) if ( c[i]%2==1 ) odd++;\n        if ( odd>n-p-1 ) return 0;\n    }\n    REP1(i,p+1,n-1) {\n        int odd=0;\n        REP(j,10) if ( c[j]%2==1 ) odd++;\n        dump(i,odd,n-i);\n        if ( odd==n-i ) {\n            int o=9;\n            while ( o>=0 && c[o]%2==0 ) o--;\n            dump(o,c[o]);\n            assert(o>=0 && c[o]%2==1);\n            c[o]++;\n            z[i]=o+'0';\n        } else if ( odd<n-i ) {\n            c[9]++;\n            z[i]='9';\n        } else assert(0);\n    }\n    return 1;\n}\n\nbool solve( int p ) {\n    REP(i,p) z[i]=s[i];\n    array<int,10> c={};\n    REP(i,p) c[z[i]-'0']++;\n    for ( char d=s[p]-1; d>='0'; d-- ) {\n        if ( d=='0' && p==0 ) continue;\n        dump(d);\n        z[p]=d;\n        if ( solve(p,c) ) return 1;\n    }\n    return 0;\n}\n\nvoid solve() {\n    for ( int i=n-1; i>=0 && i>=n-15; i-- ) {\n        if ( solve(i) ) return;\n    }\n    assert(n>=4);\n    REP(i,n-2) z[i]='9';\n    z[n-2]=0;\n}\n\nvoid main() {\n    int t;\n    R(t);\n    while ( t-- ) {\n        R(s);\n        n=strlen(s);\n        REP(i,n+1) z[i]=0;\n        solve();\n        W(z);\n        int c[10]={};\n        int m=strlen(z);\n        REP(i,m) c[z[i]-'0']++;\n        REP(i,10) assert(c[i]%2==0);\n    }\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n", "interactive": false, "noSolution": false, "noTutorial": false}