{"link": "https://codeforces.com//contest/1260/problem/D", "problemId": "482536", "shortId": "1260D", "contest_number": "1260", "name": "D. A Game with Traps", "statement": "You are playing a computer game, where you lead a party of  soldiers. Each soldier is characterised by his agility .The level you are trying to get through can be represented as a straight line segment from point  (where you and your squad is initially located) to point  (where the boss is located).The level is filled with  traps. Each trap is represented by three numbers ,  and .  is the location of the trap, and  is the danger level of the trap: whenever a soldier with agility lower than  steps on a trap (that is, moves to the point ), he gets instantly killed. Fortunately, you can disarm traps: if you move to the point , you disarm this trap, and it no longer poses any danger to your soldiers. Traps don't affect you, only your soldiers.You have  seconds to complete the level \u2014 that is, to bring some soldiers from your squad to the boss. Before the level starts, you choose which soldiers will be coming with you, and which soldiers won't be. After that, you have to bring  to the boss. To do so, you may perform the following actions:  if your location is , you may move to  or . This action consumes one second;  if your location is  and the location of your squad is , you may move to  or to  with your squad in one second. You may not perform this action if it puts some soldier in danger (i.\u2009e. the point your squad is moving into contains a non-disarmed trap with  greater than agility of some soldier from the squad). This action consumes one second;  if your location is  and there is a trap  with , you may disarm this trap. This action is done instantly (it consumes no time). Note that after each action both your coordinate and the coordinate of your squad should be integers.You have to choose the maximum number of soldiers such that they all can be brought from the point  to the point  (where the boss waits) in no more than  seconds.", "input": "The first line contains four integers , ,  and  (, ) \u2014 the number of soldiers, the number of integer points between the squad and the boss, the number of traps and the maximum number of seconds you may spend to bring the squad to the boss, respectively. The second line contains  integers , , ...,  (), where  is the agility of the -th soldier. Then  lines follow, containing the descriptions of traps. Each line contains three numbers ,  and  (, ) \u2014 the location of the trap, the location where the trap can be disarmed, and its danger level, respectively.", "output": "Print one integer \u2014 the maximum number of soldiers you may choose so that you may bring them all to the boss in no more than  seconds.", "tutorial": "When we fix a set of soldiers, we can determine a set of traps that may affect our squad: these are the traps with danger level greater than the lowest agility value. So we can use binary search on minimum possible agility of a soldier that we can choose.How should we actually bring our soldiers to the boss? Each trap that can affect our squad can be actually treated as a segment  such that our squad cannot move to  until we move to  and disarm this trap. We should walk through such segments for three times: the first time we walk forwards without our squad to disarm the trap, the second time we walk backwards to return to our squad, and the third time we walk forwards with our squad. So the total time we have to spend can be calculated as , where  is the number of unit segments belonging to at least one trap-segment \u2014 and it can be calculated with event processing algorithms or with segment union.Time complexity is  or , but it is possible to write a solution in  without binary search.", "solution": "#define _CRT_SECURE_NO_WARNINGS\n\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\n#define x first\n#define y second\n\n\nint m, n, k, t;\nvector<int> l, r, d, a;\n\nbool can(int x)\n{\n\tint mn = int(1e9);\n\tfor (int i = 0; i < x; i++)\n\t\tmn = min(mn, a[i]);\n\tvector<pt> segm;\n\tfor (int i = 0; i < k; i++)\n\t\tif (d[i] > mn)\n\t\t\tsegm.push_back(make_pair(l[i], r[i]));\n\tint req_time = 0;\n\tsort(segm.begin(), segm.end());\n\tint lastr = 0;\n\tfor (auto s : segm)\n\t{\n\t\tif (s.x <= lastr)\n\t\t{\n\t\t\treq_time += max(0, s.y - lastr);\n\t\t\tlastr = max(s.y, lastr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treq_time += s.y - s.x + 1;\n\t\t\tlastr = s.y;\n\t\t}\n\t}\n\treq_time = 2 * req_time + n + 1;\n\treturn req_time <= t;\n}\n\nint main()\n{\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%d %d %d %d\", &m, &n, &k, &t);\n\ta.resize(m);\n\tfor (int i = 0; i < m; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tsort(a.begin(), a.end());\n\treverse(a.begin(), a.end());\n\tl.resize(k);\n\tr.resize(k);\n\td.resize(k);\n\tfor (int i = 0; i < k; i++)\n\t\tscanf(\"%d %d %d\", &l[i], &r[i], &d[i]);\n\n\tint lf = 0;\n\tint rg = m + 1;\n\twhile (rg - lf > 1)\n\t{\n\t\tint mid = (lf + rg) / 2;\n\t\tif (can(mid))\n\t\t\tlf = mid;\n\t\telse\n\t\t\trg = mid;\n\t}\n\tprintf(\"%d\\n\", lf);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}