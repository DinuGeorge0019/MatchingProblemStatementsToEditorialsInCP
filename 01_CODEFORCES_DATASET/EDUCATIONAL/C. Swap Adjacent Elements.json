{"link": "https://codeforces.com//contest/920/problem/C", "problemId": "152863", "shortId": "920C", "contest_number": "920", "name": "C. Swap Adjacent Elements", "statement": "You have an array  consisting of  integers. Each integer from  to  appears exactly once in this array.For some indices  () it is possible to swap -th element with -th, for other indices it is not possible. You may perform any number of swapping operations any order. There is no limit on the number of times you swap -th element with -th (if the position is not forbidden).Can you make this array sorted in ascending order performing some sequence of swapping operations?", "input": "The first line contains one integer  () \u2014 the number of elements in the array. The second line contains  integers , , ...,  () \u2014 the elements of the array. Each integer from  to  appears exactly once. The third line contains a string of  characters, each character is either  or . If -th character is , then you can swap -th element with -th any number of times, otherwise it is forbidden to swap -th element with -th.", "output": "If it is possible to sort the array in ascending order using any sequence of swaps you are allowed to make, print . Otherwise, print .", "tutorial": "Take a look at some pair  such that  and initial . It means that all the swaps from  to  should be allowed. Then it's easy to notice that it's enough to check only  and  as any other pair can be deducted from this. You can precalc  for each  and prefix sums over the string of allowed swaps to check it in no time.Overall complexity: .", "solution": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint mx[200050];\nint mn[200050];\nint in[200050];\nchar u[200050];\nint main() {\n\tint N, i;\n\tscanf(\"%d\", &N);\n\tfor (i = 1; i <= N; i++) scanf(\"%d\", &in[i]);\n\tfor (i = 1; i <= N; i++) mx[i] = max(mx[i - 1], in[i]);\n\tmn[N + 1] = INF;\n\tfor (i = N; i >= 1; i--) mn[i] = min(mn[i + 1], in[i]);\n\n\tscanf(\"%s\", u + 1);\n\tfor (i = 1; i < N; i++) {\n\t\tif (u[i] == '1') continue;\n\t\tif (mx[i] > mn[i + 1]) return !printf(\"NO\\n\");\n\t}\n\treturn !printf(\"YES\\n\");\n}\n//*/", "interactive": false, "noSolution": false, "noTutorial": false}