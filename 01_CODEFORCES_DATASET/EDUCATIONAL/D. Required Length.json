{"link": "https://codeforces.com//contest/1681/problem/D", "problemId": "1408805", "shortId": "1681D", "contest_number": "1681", "name": "D. Required Length", "statement": "You are given two integer numbers,  and . You may perform several operations with the integer .Each operation you perform is the following one: choose any digit  that occurs in the decimal representation of  at least once, and replace  by .You want to make the length of decimal representation of  (without leading zeroes) equal to . What is the minimum number of operations required to do that?", "input": "The only line of the input contains two integers  and  (; ).", "output": "Print one integer \u2014 the minimum number of operations required to make the length of decimal representation of  (without leading zeroes) equal to , or  if it is impossible.", "tutorial": "One of the possible approaches to this problem is to try multiplying  only by the largest digit in it. Unfortunately, this doesn't work quite well, since it gives WA on one of the examples. That example is too big to consider, but a smaller version of it can prove that this is an incorrect solution: let , . If we multiply  by , we get , and there's no way to obtain a number with  digits using the next action. But, if we multiply  by , we get , which can then be multiplied by  to obtain a -digit number. So, considering only the largest digit is not enough.This implies that we somehow need to consider the options that are not optimal locally, but optimal globally (i.\u2009e. choose a lower digit right now to obtain a higher digit in the future). Let's try to estimate the number of possible integers that can be obtained using these operations to see if we can consider all possible options. The key observation is that each integer we obtain will have the form , since only one-digit primes can be added to the factorization. Since we consider only numbers less than ,  is not greater than ,  is not greater than ,  is not greater than , and  is not greater than , and the number of reachable integers is about  million (note that this is a very generous bound since not all combinations of  yield an integer less than , and not all such integers can be reached with the operations).This allows us to use BFS or dynamic programming to calculate the answer.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{   \n    int n;\n    cin >> n;\n    long long v;\n    cin >> v;\n    queue<long long> q;\n    map<long long, int> dist;\n    dist[v] = 0;\n    q.push(v);\n    while(!q.empty())\n    {\n        long long k = q.front();\n        q.pop();\n        string s = to_string(k);\n        if(s.size() == n)\n        {\n            cout << dist[k] << endl;\n            return 0;\n        }\n        for(auto x : s)\n        {\n            if(x == '0') continue;\n            long long w = k * int(x - '0');\n            if(!dist.count(w))\n            {\n                dist[w] = dist[k] + 1;\n                q.push(w);\n            }\n        }\n    }\n    cout << -1 << endl;\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}