{"link": "https://codeforces.com//contest/884/problem/E", "problemId": "130891", "shortId": "884E", "contest_number": "884", "name": "E. Binary Matrix", "statement": "You are given a matrix of size . Each element of the matrix is either 1 or 0. You have to determine the number of connected components consisting of 1's. Two cells belong to the same component if they have a common border, and both elements in these cells are 1's.", "input": "The first line contains two numbers  and  (, ) \u2014 the number of rows and columns, respectively. It is guaranteed that  is divisible by 4. Then the representation of matrix follows. Each of  next lines contains  one-digit hexadecimal numbers (that is, these numbers can be represented either as digits from  to  or as uppercase Latin letters from  to ). Binary representation of each of these numbers denotes next  elements of the matrix in the corresponding row. For example, if the number  is given, then the corresponding elements are , and if the number is , then the corresponding elements are . Elements are not separated by whitespaces.", "output": "Print the number of connected components consisting of 1's. ", "tutorial": "The main idea is to read and process each row of the matrix separately. To do this, we will use DSU data structure. The answer will be equal to the difference between the number of 1's and the number of  operations in DSU.When processing the row, we will keep the DSU for the previous row. When processing a certain index in the row, we will try to merge it with the element to the left of it and with the element to the top \u2014 that's all we have to check here.You also have to handle the fact that we cannot store the whole DSU since the number of components can be up to , and it's impossible to store all required information for them. So each time we process a row, we have to renumerate all components in this row to ensure that every time we are operating with indices of components not greater than .", "solution": "#include <vector>\n#include <cstdio>\n#include <iterator>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <functional>\n#include <array>\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\nnamespace XX\n{\n    template<typename... Datas>\n    struct UnionFind\n    {\n            struct Node:public Datas...\n            {\n                int _parent = -1;\n                void operator+=(Node& other) { int dummy[] = {(Datas::operator+=(other), 0)...}; }\n            };\n            UnionFind(int size = 0) :_data(size, Node()) {}\n\n            void resize(int size)\n            {\n                _data.resize(size, Node());\n            }\n\n            int size()\n            {\n                return _data.size();\n            }\n\n            Node& operator[](int idx) { return _data[(*this)(idx)]; }\n\n            int operator()(int n)\n            {\n                if(_data[n]._parent < 0)\n                    return n;\n                else\n                    return _data[n]._parent = (*this)(_data[n]._parent);\n            }\n\n            bool operator()(int a, int b)\n            {\n                int pa = (*this)(a), pb = (*this)(b);\n                if(pa == pb)\n                    return false;\n                else\n                {\n                    if(_data[pa]._parent == _data[pb]._parent)\n                        _data[pa]._parent--;\n                    else if(_data[pa]._parent > _data[pb]._parent)\n                        std::swap(pa, pb);\n\n                    _data[pa] += _data[pb];\n                    _data[pb]._parent = pa;\n                    return true;\n                }\n            }\n\n            std::vector<Node> _data;\n    };\n}\n\n\n\n\n\n\n\n\n//alias\n//for union/find\ntemplate<typename... Datas>\nusing UF = XX::UnionFind<Datas...>; \n//RD[L],RDV[L],WT[L],WTV[L] for i/o\nusing RG = Range;\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nconst int R = 1 << 15;\nint last[R];\n\nstruct Data\n{\n    int num = 0;\n    void operator+=(Data&){}\n};\n\nint main()\n{\n    int ans = 0;\n    int N, M;\n    RD(N, M);\n    int now = 0;\n\n    for(int i: RG(N))\n    {\n        int buf[R] = {};\n        int pass[R] = {};\n\n        UF<Data> uf(M + 1);\n        int ex = 0;\n\n        for(int j: RG(M / 4))\n        {\n            char c;\n            RD(c);\n\n            if(c >= 'A')\n                c = c - 'A' + 10;\n            else\n                c -= '0';\n\n //           for(int k: RG(4))\n   //             WT(c >> (3 - k) & 1);\n            for(int k: RG(4))\n                if(c >> (3 - k) & 1)\n                {\n                    int pos = j * 4 + k;\n                    int id;\n                    if(last[pos])\n                        id = last[pos];\n                    else\n                        id = now + ++ex;\n\n                    buf[pos] = id;\n                    pass[id] = true;\n                    if(pos && buf[pos - 1])\n                        uf(buf[pos - 1], buf[pos]);\n                }\n        }\n\n//        WTL();\n\n        int alc = 0;\n        for(int j: RG(1, now + ex + 1))\n            if(!pass[j])\n                ans++;\n            else if(!uf[j].num)\n                uf[j].num = ++alc;\n\n        for(int j: RG(M))\n            if(buf[j])\n                last[j] = uf[buf[j]].num;\n            else\n                last[j] = 0;\n        now = alc;\n\n        //WTVL(last, last + M);\n    }\n\n    ans += now;\n\n    WTL(ans);\n\n\n}\n\n\n\n\n", "interactive": false, "noSolution": false, "noTutorial": false}