{"link": "https://codeforces.com//contest/1476/problem/C", "problemId": "881704", "shortId": "1476C", "contest_number": "1476", "name": "C. Longest Simple Cycle", "statement": "You have  chains, the -th chain consists of  vertices. Vertices in each chain are numbered independently from  to  along the chain. In other words, the -th chain is the undirected graph with  vertices and  edges connecting the -th and the -th vertices for each .Now you decided to unite chains in one graph in the following way:   the first chain is skipped;  the -st vertex of the -th chain is connected by an edge with the -th vertex of the -th chain;  the last (-th) vertex of the -th chain is connected by an edge with the -th vertex of the -th chain.    Calculate the length of the longest simple cycle in the resulting graph.A  is a chain where the first and last vertices are connected as well. If you travel along the simple cycle, each vertex of this cycle will be visited exactly once.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains the single integer  ()\u00a0\u2014 the number of chains you have. The second line of each test case contains  integers  ()\u00a0\u2014 the number of vertices in the corresponding chains. The third line of each test case contains  integers  (; ). The fourth line of each test case contains  integers  (; ). Both  and  are equal to , they aren't used in graph building and given just for index consistency. It's guaranteed that the sum of  over all test cases doesn't exceed .", "output": "For each test case, print the length of the longest simple cycle.", "tutorial": "Suppose, we've built the graph and chosen any simple cycle. Due to the nature of the graph, any simple cycle right part is part of one of the chains. So, let's for each chain calculate the longest simple path with its right part on this chain and denote it as .Obviously, . Now, let's look at chain . If we go along the cycle in both ways, we will step to vertices  and  of the previous chain. If  then we closed cycle and it's the only possible cycle, so .Otherwise, we can either go from  and  and meet each other closing the cycle with part of the -th chain between -th and -th vertices\u00a0\u2014 this part has  edges and our cycle will have length .But if we decide to go in different ways, then we will meet the first and the last vertices of the -th chain. After that, we'll go to the -th and the -th vertices of -th chain and will make almost the same choice.But, instead of recurrently solving the same problem, we can note that, in fact, we took a cycle that ends at the -th chain, erased the part between vertices  and , and merged it with our -th chain part, so the length of this merged cycle will be equal to . Since we maximize  we just choose, what part:  or  is longer and take it.As a result, we can iterate from left to right, calculate all  and print the maximum among them.", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long li;\n\nint main() {\n  int t;\n  cin >> t;\n\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> c(n), a(n), b(n);\n    for (int i = 0; i < n; i++)\n      cin >> c[i];\n    for (int i = 0; i < n; i++)\n      cin >> a[i];\n    for (int i = 0; i < n; i++)\n      cin >> b[i];\n    \n    li ans = 0;\n    li lstLen = 0;\n    for (int i = 1; i < n; i++) {\n      li curLen = c[i] + 1ll + abs(a[i] - b[i]);\n      if (a[i] != b[i])\n        curLen = max(curLen, c[i] + 1ll + lstLen - abs(a[i] - b[i]));\n      ans = max(ans, curLen);\n      lstLen = curLen;  \n    }\n    cout << ans << endl;\n  }\n  return 0;\n};", "interactive": false, "noSolution": false, "noTutorial": false}