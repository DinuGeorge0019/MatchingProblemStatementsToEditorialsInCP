{"link": "https://codeforces.com//contest/946/problem/F", "problemId": "162811", "shortId": "946F", "contest_number": "946", "name": "F. Fibonacci String Subsequences", "statement": "You are given a binary string  (each character of this string is either  or ).Let's denote the cost of string  as the number of occurences of  in . For example, if  is  and  is , then the cost of  is .Let's also denote the Fibonacci strings sequence as follows:  is ;  is ;  if , where  means the concatenation of two strings.Your task is to calculate the sum of costs of all subsequences of the string . Since answer may be large, calculate it modulo .", "input": "The first line contains two integers  and  (, ) \u2014 the length of  and the index of a Fibonacci string you are interested in, respectively. The second line contains  \u2014 a string consisting of  characters. Each of these characters is either  or .", "output": "Print the only integer \u2014 the sum of costs of all subsequences of the string , taken modulo . ", "tutorial": "If  was not really large, then we could run the following dynamic programming solution:Let  be the number of ways to process first  characters of  so that the suffix of the subsequence of length  matches the prefix of  with length . This is not really different from a usual approach with dynamic programming on KMP (constraints in this problem allow us to build KMP automaton naively without the help of any fast prefix-function algorithm). However, the length of  is really large.Let's consider the traversions we make in dynamic programming. Let  be the KMP automaton matrix (that is, let  be the new value of prefix-function if the previous value was  and we added a character ). Then from the state , if the following character is , we make traversions to  and to . This actually leads to rewriting traversions as a matrix. Let  be the vector such that its -th element is equal to . Then advancing from  to , if -th character is , can be represented as follows: , where  can be filled with the help of KMP automaton: for every  we add  to , and also add  to . The same approach can be used to form matrix  that denotes adding character , and if we want to add the string , we can actually represent its matrix as .This matrix multiplication approach will run in , but the problem is that it doesn't give us the answer. To obtain it, we may add an auxiliary state  to the dynamic programming, add  to it each time we traverse to state , multiply it by  each time we add a character, and rewrite it into matrix form.Model solution: https://pastebin.com/ctSVxmnD", "solution": "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\n// {{{ ModInt\ntemplate<int _MOD>\nstruct ModInt {\n    static const auto MOD = _MOD;\n    template<class T> using integral_only = typename enable_if<is_integral<T>::value>::type;\n\n    int x;\n    constexpr ModInt() : x() {}\n    template<class T, integral_only<T>* = nullptr>\n    ModInt(T _x) {\n        x = _x % MOD;\n        if (x < 0) x += MOD;\n    }\n    ModInt operator-() const { return {x == 0 ? 0 : MOD-x}; }\n    ModInt& operator+=(ModInt rhs) {\n        x += rhs.x;\n        if (x >= MOD) x -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt rhs) {\n        x -= rhs.x;\n        if (x < 0) x += MOD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt rhs) {\n        x = (long long)x * rhs.x % MOD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt rhs) {\n        return *this *= rhs.inv();\n    }\n    ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n    ModInt inv() const {\n        // should work for non-prime MOD if gcd(x, MOD) = 1\n        int a = x, b = MOD, u = 1, v = 0;\n        while (b != 0) {\n            int t = a / b;\n            a -= t * b;\n            u -= t * v;\n            swap(a, b);\n            swap(u, v);\n        }\n        return u;\n    }\n    template<class T, integral_only<T>* = nullptr>\n    ModInt pow(T e) {\n        ModInt r = 1, p = *this;\n        while (e) {\n            if (e & 1) r *= p;\n            p *= p;\n            e >>= 1;\n        }\n        return r;\n    }\n    bool operator==(ModInt rhs) const { return x == rhs.x; }\n    bool operator!=(ModInt rhs) const { return x != rhs.x; }\n    bool operator<(ModInt rhs) const { return x < rhs.x; }\n    bool operator<=(ModInt rhs) const { return x <= rhs.x; }\n    bool operator>(ModInt rhs) const { return x > rhs.x; }\n    bool operator>=(ModInt rhs) const { return x >= rhs.x; }\n    friend string to_string(ModInt i) { return to_string(i.x); }\n    friend ostream& operator<<(ostream &os, ModInt i) { return os << i.x; }\n};\n// }}}\n\nconst int MOD = 1e9 + 7;\nusing mint = ModInt<MOD>;\n\nconst int N=110;\n\nstruct M {\n    mint x[N][N];\n    const mint* operator[]( int i ) const { return x[i]; }\n    mint* operator[]( int i ) { return x[i]; }\n};\n\nint n;\n\n#ifdef SHIK\nostream& operator<<( ostream &os, const M &a ) {\n    vector<vector<mint>> v(n+1,vector<mint>(n+1));\n    REP(i,n+1) REP(j,n+1) v[i][j]=a[i][j];\n    return os<<v;\n}\n#endif\n\nM operator*( const M &a, const M &b ) {\n    M c;\n    REP(i,n+1) REP(j,n+1) {\n        mint s;\n        REP(k,n+1) s+=a[i][k]*b[k][j];\n        c[i][j]=s;\n    }\n    return c;\n}\n\nint m;\nchar s[N];\nM dp[N];\nvoid main() {\n    R(n,m,s);\n    dp[0][0][0]=dp[0][n][n]=dp[1][0][0]=dp[1][n][n]=2;\n    REP1(i,1,n-1) dp[0][i][i]=dp[1][i][i]=1;\n    REP(i,n) if ( s[i]=='0' ) dp[0][i][i+1]=1;\n    REP(i,n) if ( s[i]=='1' ) dp[1][i][i+1]=1;\n    REP1(i,2,m) dp[i]=dp[i-1]*dp[i-2];\n    // REP1(i,0,m) dump(i,dp[i]);\n    mint ans=dp[m][0][n];\n    W(ans);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n", "interactive": false, "noSolution": false, "noTutorial": false}