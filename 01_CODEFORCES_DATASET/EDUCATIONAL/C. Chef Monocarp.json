{"link": "https://codeforces.com//contest/1437/problem/C", "problemId": "775841", "shortId": "1437C", "contest_number": "1437", "name": "C. Chef Monocarp", "statement": "Chef Monocarp has just put  dishes into an oven. He knows that the -th dish has its optimal cooking time equal to  minutes.At any  minute  Monocarp can put  dish out of the oven. If the -th dish is put out at some minute , then its unpleasant value is \u00a0\u2014 the absolute difference between  and . Once the dish is out of the oven, it can't go back in.Monocarp should put all the dishes out of the oven. What is the minimum total unpleasant value Monocarp can obtain?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. Then  testcases follow. The first line of the testcase contains a single integer  ()\u00a0\u2014 the number of dishes in the oven. The second line of the testcase contains  integers  ()\u00a0\u2014 the optimal cooking time for each dish. The sum of  over all  testcases doesn't exceed .", "output": "Print a single integer for each testcase\u00a0\u2014 the minimum total unpleasant value Monocarp can obtain when he puts out all the dishes out of the oven. Remember that Monocarp can only put the dishes out at positive integer minutes and no more than one dish at any minute.", "tutorial": "There are a lot of solutions for the problem. Let's start with the easiest one.Sort the dishes in the non-decreasing order of their optimal time. I claim that there is an optimal answer such that the times  for each dish go in the increasing order. That's not too hard to prove (something along the lines of if there are two dishes  and  such that  and , then  is always greater than ).So we can use dynamic programming to solve the task. Let  be the minimum total unpleasant value if  dishes are processed and the current minute is . For the transitions you can either put out the current dish  at the current minute  or wait one more minute. Notice that you'll never need more time than  minutes (the actual constraint is even smaller, just consider the case with all dishes times equal to ).So that dp works in .The other possible solution is matching. Let's build the following graph. The left partition is  vertices corresponding to dishes. The right partition is  vertices corresponding to minutes (as we saw in previous solution  is always enough). Now add the edges between all dishes and all minutes with the cost of their absolute different. Finally, find the minimum cost maximum matching. That can be done with MCMF or Hungarian algorithm.Both should pass pretty easily.There's also a solution in  involving the slope trick.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nvoid solve(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> t(n);\n\tforn(i, n){\n\t\tscanf(\"%d\", &t[i]);\n\t\t--t[i];\n\t}\n\tsort(t.begin(), t.end());\n\tvector<vector<int>> dp(n + 1, vector<int>(2 * n, INF));\n\tdp[0][0] = 0;\n\tforn(i, n + 1) forn(j, 2 * n - 1) if (dp[i][j] < INF){\n\t\tif (i < n) dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + abs(t[i] - j));\n\t\tdp[i][j + 1] = min(dp[i][j + 1], dp[i][j]);\n\t}\n\tprintf(\"%d\\n\", dp[n][2 * n - 1]);\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d\", &q);\n\tforn(_, q) solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}