{"link": "https://codeforces.com//contest/1373/problem/G", "problemId": "657376", "shortId": "1373G", "contest_number": "1373", "name": "G. Pawns", "statement": "You are given a chessboard consisting of  rows and  columns. Rows are numbered from bottom to top from  to . Columns are numbered from left to right from  to . The cell at the intersection of the -th column and the -th row is denoted as . Furthermore, the -th column is a special column. Initially, the board is empty. There are  changes to the board. During the -th change one pawn is added or removed from the board. The current board is good if we can move all pawns to the special column by the followings rules:  Pawn in the cell  can be moved to the cell ,  or ;  You can make as many such moves as you like;  Pawns can not be moved outside the chessboard;  Each cell can not contain more than one pawn. The current board may not always be good. To fix it, you can add new rows to the board. New rows are added at the top, i.\u2009e. they will have numbers .After each of  changes, print one integer \u2014 the minimum number of rows which you have to add to make the board good.", "input": "The first line contains three integers ,  and  () \u2014 the size of the board, the index of the special column and the number of changes respectively. Then  lines follow. The -th line contains two integers  and  () \u2014 the index of the column and the index of the row respectively. If there is no pawn in the cell , then you add a pawn to this cell, otherwise \u2014 you remove the pawn from this cell.", "output": "After each change print one integer \u2014 the minimum number of rows which you have to add to make the board good.", "tutorial": "For each pawn with initial position  there exists a minimum index of row  such that the pawn can reach the cell , but cannot reach the cell . It's easy to see that . In the resulting configuration, this pawn can occupy the cell , ,  or any other cell  having .Suppose the board consists of  rows. For each row, the number of rows above it should be not less than the number of pawns that occupy the cells above it (that is, having  greater than the index of that row) \u2014 because, if this condition is not fulfilled, we can't assign each pawn a unique cell. If we denote the number of pawns that should go strictly above the -th row as , then for every row, the condition  must be met.To prove that this condition is sufficient, we may, for example, use Hall's theorem. Okay, now what about finding the minimum  satisfying it? Let's initially set  to , and for each row maintain the value of  \u2014 the minimum number of rows we have to add to our board so that the condition for the row  is met (we also have to maintain this value for  auxiliary rows from  to , since some pawns cannot fit in the initial board at all). Finding the minimum value we have to add to  equals finding the maximum of all these values on some prefix (we don't need to look at the values on some rows with large indices, if there are no pawns after them, so we need a maximum query on the segment , where  is the maximum index  among all pawns); and when a pawn is added or removed, we should add  or  to all values on some suffix. A segment tree with lazy propagation will do the trick, solving the problem for us in .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k;\nint m;\nint t[8 * N];\nint add[8 * N];\nint cnt[2 * N];\n\nvoid push(int v, int l, int r) {\n    if (r - l != 1 && add[v] != 0) {\n        t[v * 2 + 1] += add[v];\n        t[v * 2 + 2] += add[v];\n        add[v * 2 + 1] += add[v];\n        add[v * 2 + 2] += add[v];\n        add[v] = 0;\n    }\n}\n\nvoid upd(int v, int l, int r, int L, int R, int x) {\n    if (L >= R) return;\n    if(l == L && r == R) {\n        t[v] += x;\n        add[v] += x;\n        return;\n    } \n    \n    push(v, l, r);\n    int mid = (l + r) / 2;\n    upd(v * 2 + 1, l, mid, L, min(R, mid), x);\n    upd(v * 2 + 2, mid, r, max(L, mid), R, x);\n    t[v] = max(t[v * 2 + 1], t[v * 2 + 2]);\n}\n\nvoid upd(int l, int r, int x) {\n    upd(0, 0, n + n, l, r, x);\n}\n\nint get(int v, int l, int r, int L, int R) {\n    if (L >= R) return 0;\n    if (l == L && r == R) return t[v];\n    \n    push(v, l, r);\n    int mid = (l + r) >> 1;\n    return max(get(v * 2 + 1, l, mid, L, min(R, mid))\n    \t\t , get(v * 2 + 2, mid, r, max(L, mid), R));\n}\n\nint get(int l, int r) {\n    return get(0, 0, n + n, l, r);\n}\n\nint getAns(set <int> &smx) {\n    if (smx.empty()) return 0;\n    return max(0, get(0, *smx.rbegin() + 1) - n);\n}\n\nvoid build(int v, int l, int r) {\n    if (r - l == 1) {\n        t[v] = l;\n        return;\n    }\n    \n    int mid = (l + r) >> 1;\n    build(v * 2 + 1, l, mid);\n    build(v * 2 + 2, mid, r);\n    t[v] = max(t[v * 2 + 1], t[v * 2 + 2]);\n}\n\nint main(){\n    scanf(\"%d %d %d\", &n, &k, &m);\n    \n    build(0, 0, n + n);\n    set <pair<int, int> > s;\n    set <int> smx;\n    for (int i = 0; i < m; ++i) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        int pos = abs(x - k) + y - 1;\n        pair <int, int> p = make_pair(x, y);\n        if (s.count(p)) {\n            --cnt[pos];\n            if (cnt[pos] == 0) smx.erase(pos);\n            upd(0, pos + 1, -1);\n            s.erase(p);\n        } else {\n            ++cnt[pos];\n            if (cnt[pos] == 1) smx.insert(pos);\n            upd(0, pos + 1, 1);\n            s.insert(p);\n        }\n        \n        printf(\"%d\\n\", getAns(smx));\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}