{"link": "https://codeforces.com//contest/1511/problem/D", "problemId": "955215", "shortId": "1511D", "contest_number": "1511", "name": "D. Min Cost String", "statement": "Let's define the  of a string  as the number of index pairs  and  () such that  and .You are given two positive integers  and . Among all strings with length  that contain only the first  characters of the Latin alphabet, find a string with minimum possible . If there are multiple such strings with minimum  \u2014 find any of them.", "input": "The only line contains two integers  and  ().", "output": "Print the string  such that it consists of  characters, each its character is one of the  first Latin letters, and it has the minimum possible  among all these strings. If there are multiple such strings \u2014 print any of them.", "tutorial": "Consider all possible strings of length  on the alphabet of size  (there are  of them). Let  be the number of occurrences of the -th of them in the string . The cost of the string  by definition is . Now, let's suppose there are two strings  and  such that . Then, if we somehow reduce the number of occurrences of the string  by  and increase the number of occurrences of the string  by , the cost will decrease. So, in the optimal answer all the strings of length  should appear the same number of times (and if it's impossible, the difference in the number of appearances should not be greater than ).Let's suppose that , then our goal is to build a string where each string of length  on the alphabet of  characters appears exactly once. The construction of this string can be modeled using Eulerian cycles: build a directed graph with  vertices, where each vertex represents a character, each arc represents a string of length , and for every pair of vertices , there is an arc from  to  (it's possible that !). Then, by finding the Eulerian cycle in this graph (it always exists since the graph is strongly connected and, for each vertex, its in-degree is equal to its out-degree), we find a string of length  such that all its substrings are different (so each string of length  appears there once as a substring).Okay, what about the cases  and ? Since the string we build for the case  represents a cycle, we can make it \"cyclical\" and repeat the required number of times, then cut last several characters if it's too big. For example, if , , then the string for  is  (it's not the only one, but we can use it). We can expand this string to  (by repeating the last  characters), and delete the last character so its length is .By the way, in this problem, you don't have to implement the algorithm that finds Eulerian cycles. The graph where we want to find the Eulerian cycle has a very special structure, and there are many different constructive ways to find the cycle in it. But if you can't use them, you always can rely on the straightforward solution that explicitly searches for the Eulerian cycle.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, k;\nint cur[26];\nvector<int> path;\n\nvoid dfs(int v) {\n  while (cur[v] < k) {\n    int u = cur[v]++;\n    dfs(u);\n    path.push_back(u);\n  }\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  dfs(0);\n  printf(\"a\");\n  for (int i = 0; i < n - 1; ++i)\n    printf(\"%c\", path[i % path.size()] + 'a');\n}", "interactive": false, "noSolution": false, "noTutorial": false}