{"link": "https://codeforces.com//contest/873/problem/F", "problemId": "127824", "shortId": "873F", "contest_number": "873", "name": "F. Forbidden Indices", "statement": "You are given a string  consisting of  lowercase Latin letters. Some indices in this string are marked as .You want to find a string  such that the value of  is maximum possible, where  is the number of occurences of  in  such that these occurences end in non-forbidden indices. So, for example, if  is ,  is  and index  is forbidden, then  because there are three occurences of  in  (starting in indices ,  and ), but one of them (starting in index ) ends in a forbidden index.Calculate the maximum possible value of  you can get.", "input": "The first line contains an integer number  () \u2014 the length of . The second line contains a string , consisting of  lowercase Latin letters. The third line contains a string , consisting of  characters  and . If -th character in  is , then  is a forbidden index (otherwise  is not forbidden).", "output": "Print the maximum possible value of .", "tutorial": "This problem can be solved with different suffix structures. Model solution uses suffix array.First of all, let's reverse , so for  we will count only occurences that start in non-forbidden indices.Then, if there is at least one non-forbidden index, there are two cases:  , then the best option to choose  is to use a suffix which begins in the leftmost (after reversing ) non-forbidden index.  , then  is the longest common prefix of some two suffixes of . Let's build a suffix array, then calculate the LCP array. Then recall the fact that a LCP of two suffixes is the minimum on the segment of LCP array between these two suffixes, so we can use a common stack algorithm that will for each LCP find the segment of suffixes such that this LCP is a prefix of these suffixes (to do this, for each element of LCP array we find the largest segment such that this element is minimal on that segment), and then we can use prefix sums to find the number of non-forbidden suffixes such that chosen LCP is a prefix of this suffix (and so calculate  easily for each LCP). ", "solution": "#include <bits/stdc++.h>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\ntypedef pair<ll, ll> pll;\n\nstruct node {\n\tint link;\n\tint len;\n\tmap<char, int> to;\n\tint good;\n\tnode() : link(-1), len(0), good(0) {}\n};\n\nvector<node> t;\nint last = 0;\n\nvoid add(char c, int flag) {\n\tint curr = sz(t);\n\tt.pb(node());\n\tt[curr].len = t[last].len + 1;\n\tt[curr].good = flag;\n\tint p = last;\n\twhile (p != -1) {\n\t\tif (!t[p].to.count(c)) {\n\t\t\tt[p].to[c] = curr;\n\t\t\tp = t[p].link;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (p == -1) {\n\t\tt[curr].link = 0;\n\t\tlast = curr;\n\t\treturn;\n\t}\n\tint q = t[p].to[c];\n\tif (t[q].len == t[p].len + 1) {\n\t\tt[curr].link = q;\n\t\tlast = curr;\n\t\treturn;\n\t}\n\tint clone = sz(t);\n\tt.pb(node());\n\tt[clone].to = t[q].to;\n\tt[clone].len = t[p].len + 1;\n\tt[clone].link = t[q].link;\n\twhile (p != -1) {\n\t\tif (t[p].to.count(c) && t[p].to[c] == q) {\n\t\t\tt[p].to[c] = clone;\n\t\t\tp = t[p].link;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tt[q].link = t[curr].link = clone;\n\tlast = curr;\n}\n\nint main() {\n\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\t//ifstream cin(\"input.txt\");\n\t//ofstream cout(\"output.txt\");\n\n\tt.pb(node());\n\tint n;\n\tcin >> n;\n\n\tstring a, b;\n\tcin >> a >> b;\n\tfor (int i = 0; i < n; ++i) {\n\t\tadd(a[i], (b[i] == '0'));\n\t}\n\n\tvector<int> ord;\n\tfor (int i = 1; i < sz(t); ++i) {\n\t\tord.pb(i);\n\t}\n\tsort(all(ord), [&] (int a, int b) {\n\t\treturn t[a].len > t[b].len;\n\t});\n\tfor (int v : ord) {\n\t\tt[t[v].link].good += t[v].good;\n\t}\n\n\tll ans = 0;\n\tfor (int v = 1; v < sz(t); ++v) {\n\t\tans = max(ans, ll(t[v].good) * ll(t[v].len));\n\t}\n\tcout << ans << \"\\n\";\n\n}", "interactive": false, "noSolution": false, "noTutorial": false}