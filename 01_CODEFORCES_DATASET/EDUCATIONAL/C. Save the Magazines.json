{"link": "https://codeforces.com//contest/1743/problem/C", "problemId": "1590318", "shortId": "1743C", "contest_number": "1743", "name": "C. Save the Magazines", "statement": "Monocarp has been collecting rare magazines for quite a while, and now he has decided to sell them. He distributed the magazines between  boxes, arranged in a row. The -th box contains  magazines. Some of the boxes are covered with lids, others are not. Suddenly it started to rain, and now Monocarp has to save as many magazines from the rain as possible. To do this, he can move the lids between boxes as follows: if the -th box was covered with a lid initially, he can either move the lid from the -th box to the box  (if it exists), or keep the lid on the -th box. You may assume that Monocarp can move the lids instantly at the same moment, and no lid can be moved more than once. If a box will be covered with a lid after Monocarp moves the lids, the magazines in it will be safe from the rain; otherwise they will soak.You have to calculate the maximum number of magazines Monocarp can save from the rain.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of the testcases. The first line of each testcase contains a single integer  ()\u00a0\u2014 the number of boxes. The second line contains a string of  characters  and/or . If the -th character is , the -th box is initially covered with a lid. If the -th character is , the -th box is initially not covered. The third line contains a sequence of integers  (), where  is the number of magazines in the -th box. The sum of  over all testcases doesn't exceed .", "output": "For each testcase, print one integer\u00a0\u2014 the maximum number of magazines Monocarp can save from the rain.", "tutorial": "Let's process the boxes from left to right.Consider the first box. If it has a lid, then you can just add the number of magazines in it to the answer and forget about this box. To be exact, proceed to solve the problem with the first box removed.If it doesn't have a lid, then look at the next box. If it doesn't have a lid too, then this box can never be covered. Remove it and proceed further.If the next box has a lid, then look at the next one. Again, if it doesn't have a lid, then these two first boxes are solved independently of everything else. You can cover exactly one of them. Choose the bigger one and remove them both.To propagate the argument, let's derive a pattern. First, there's a box without a lid. Then some number of boxes with lids in a row. Then a box without a lid again. Among the first box and the box with lids, you can choose exactly one to not be covered. However, that can be any one of them. The best box to be left uncovered is the one with the smallest number of magazines in it.Thus, the solution is the following. As long as the first box has a lid, keep removing the first box and adding it to the answer. Then, as long as there are boxes left, take the first box and the largest number of consecutive boxes with lids after it (that number might be zero). On that segment, find the minimum value and the sum. Add the sum minus the minimum to the answer, remove the entire segment.The removals can be done explicitly with a queue or just a reversed vector or implicitly with maintaining a pointer to the first non-removed box.Overall complexity: .", "solution": "for _ in range(int(input())):\n\tn = int(input())\n\ts = '0' + input()\n\ta = [0] + list(map(int, input().split()))\n\tans = 0\n\ti = 0\n\twhile i <= n:\n\t\tmn = a[i]\n\t\tsm = a[i]\n\t\tj = i + 1\n\t\twhile j <= n and s[j] == '1':\n\t\t\tmn = min(mn, a[j])\n\t\t\tsm += a[j]\n\t\t\tj += 1\n\t\tans += sm - mn\n\t\ti = j\n\tprint(ans)", "interactive": false, "noSolution": false, "noTutorial": false}