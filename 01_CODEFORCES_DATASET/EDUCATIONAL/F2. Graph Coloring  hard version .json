{"link": "https://codeforces.com//contest/1792/problem/F2", "problemId": "1749565", "shortId": "1792F2", "contest_number": "1792", "name": "F2. Graph Coloring  hard version ", "statement": "You are given an undirected complete graph on  vertices. A complete graph is a graph where each pair of vertices is connected by an edge. You have to paint the edges of the graph into two colors, red and blue (each edge will have one color).A set of vertices  is  if, for every pair of vertices  such that  and , there exists a path from  to  that goes only through red edges and vertices from . Similarly, a set of vertices  is  if, for every pair of vertices  such that  and , there exists a path from  to  that goes only through blue edges and vertices from .You have to paint the graph in such a way that:  there is at least one red edge;  there is at least one blue edge;  for each set of vertices  such that ,  is either red-connected or blue-connected, but . Calculate the number of ways to paint the graph, and print it modulo .", "input": "The first (and only) line contains one integer  ().", "output": "Print one integer \u2014 the number of ways to paint the graph, taken modulo .", "tutorial": ".Okay, we need more definitions. Here they come:This way, we can transform the formula for  to the following:.Or even this, since :.This is almost the convolution of the sequences  and  (with a bit extra additional operations after the convolution), so, to compute the sequence , we just need to compute the sequences  and , and then calculate their convolution with NTT. All that's left is to multiply every element by the corresponding factorial.But wait, that's not so easy. In order to calculate  and , we need to know . Note that we can ignore the fact that  and  appear in the formula for , since they are multiplied by , so at least we don't have a dependency cycle. Unfortunately, we cannot just straightforwardly use convolution if we don't know the sequences  and .The model solution handles it using the following approach. Let's generate , ,  and  in parallel: on the -th iteration, calculate , then calculate ,  and  using it. And  we will calculate the convolution of the sequences  and .Suppose we want to calculate , and the last time we calculated the convolution of  and  was after the iteration . Back then, we knew all elements from  to  and from  to . So, the -th term in the convolution of  and  contained the sum of  over all  such that  and . So, in order to calculate , we have to pick this value from the convolution and then add the sum of  over all  such that  or , and there are  such values.Suppose we compute the convolution every  iterations. Then the maximum value of  is , and every value of  is calculated in . We also make  convolutions, so the total complexity of this solution will be , which can be transformed into  if we pick .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int LOGN = 18;\nconst int N = (1 << LOGN);\nconst int MOD = 998244353;\nconst int g = 3;\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n\ninline int mul(int a, int b)\n{\n    return (a * 1ll * b) % MOD;\n}\n\ninline int norm(int a) \n{\n    while(a >= MOD)\n        a -= MOD;\n    while(a < 0)\n        a += MOD;\n    return a;\n}\n\ninline int binPow(int a, int k) \n{\n    int ans = 1;\n    while(k > 0) \n    {\n        if(k & 1)\n            ans = mul(ans, a);\n        a = mul(a, a);\n        k >>= 1;\n    }\n    return ans;\n}\n\ninline int inv(int a) \n{\n    return binPow(a, MOD - 2);\n}\n\nvector<int> w[LOGN];\nvector<int> iw[LOGN];\nvector<int> rv[LOGN];\n\nvoid precalc() \n{\n    int wb = binPow(g, (MOD - 1) / (1 << LOGN));\n    \n    for(int st = 0; st < LOGN; st++) \n    {\n        w[st].assign(1 << st, 1);\n        iw[st].assign(1 << st, 1);\n        \n        int bw = binPow(wb, 1 << (LOGN - st - 1));\n        int ibw = inv(bw);\n        \n        int cw = 1;\n        int icw = 1;\n        \n        for(int k = 0; k < (1 << st); k++) \n        {\n            w[st][k] = cw;\n            iw[st][k] = icw;\n            \n            cw = mul(cw, bw);\n            icw = mul(icw, ibw);\n        }\n        \n        rv[st].assign(1 << st, 0);\n        \n        if(st == 0) \n        {\n            rv[st][0] = 0;\n            continue;\n        }\n        int h = (1 << (st - 1));\n        for(int k = 0; k < (1 << st); k++)\n            rv[st][k] = (rv[st - 1][k & (h - 1)] << 1) | (k >= h);\n    }\n}\n\ninline void fft(int a[N], int n, int ln, bool inverse) \n{   \n    for(int i = 0; i < n; i++) \n    {\n        int ni = rv[ln][i];\n        if(i < ni)\n            swap(a[i], a[ni]);\n    }\n    \n    for(int st = 0; (1 << st) < n; st++) \n    {\n        int len = (1 << st);\n        for(int k = 0; k < n; k += (len << 1)) \n        {\n            for(int pos = k; pos < k + len; pos++) \n            {\n                int l = a[pos];\n                int r = mul(a[pos + len], (inverse ? iw[st][pos - k] : w[st][pos - k]));\n                \n                a[pos] = norm(l + r);\n                a[pos + len] = norm(l - r);\n            }\n        }\n    }\n    \n    if(inverse) \n    {\n        int in = inv(n);\n        for(int i = 0; i < n; i++)\n            a[i] = mul(a[i], in);\n    }\n}\n\nint aa[N], bb[N], cc[N];\n\nvector<int> multiply(vector<int> a, vector<int> b) \n{\n    int sza = a.size();\n    int szb = b.size();\n    int n = 1, ln = 0;\n    while(n < (sza + szb))\n        n <<= 1, ln++;\n    for(int i = 0; i < n; i++)\n        aa[i] = (i < sza ? a[i] : 0);\n    for(int i = 0; i < n; i++)\n        bb[i] = (i < szb ? b[i] : 0);\n        \n    fft(aa, n, ln, false);\n    fft(bb, n, ln, false);\n    \n    for(int i = 0; i < n; i++)\n        cc[i] = mul(aa[i], bb[i]);\n        \n    fft(cc, n, ln, true);\n    \n    int szc = n;\n    vector<int> c(szc);\n    szc = n;\n    for(int i = 0; i < n; i++)\n        c[i] = cc[i];\n    return c;\n}                    \n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> fact(n + 1);\n    fact[0] = 1;\n    for(int i = 0; i < n; i++)\n        fact[i + 1] = mul(fact[i], i + 1);\n    precalc();\n    vector<int> A = {0, 1, 2};\n    vector<int> B = {0, 1, 1};\n    vector<int> C = {0, 1, 1};\n    vector<int> D = {0, 1, 1};\n    vector<int> conv;\n    const int K = 2000;\n    int last_conv = -1e9;\n    while(A.size() <= n)\n    {\n        int cur = A.size();\n        if(cur - last_conv >= K)\n        {\n            last_conv = cur - 1;\n            conv = multiply(C, D);\n        }\n        /*for(auto x : conv) cerr << x << \" \";\n        cerr << endl;*/\n        int val_A;\n        if(last_conv * 2 >= cur)\n        {\n            val_A = conv[cur];\n            // [cur - last_conv, last_conv] are already used\n            for(int i = 1; i < (cur - last_conv); i++)\n            {\n                val_A = norm(val_A + mul(C[i], D[cur - i]));\n            }\n            for(int i = last_conv + 1; i < cur; i++)\n            {\n                val_A = norm(val_A + mul(C[i], D[cur - i]));\n            }\n        }\n        else\n        {\n            val_A = 0;\n            for(int i = 1; i <= cur - 1; i++)\n            {\n                val_A = norm(val_A + mul(C[i], D[cur - i]));\n            }\n        }\n        val_A = mul(val_A, fact[cur - 1]);\n        val_A = mul(val_A, 2);\n        A.push_back(val_A);\n        B.push_back(mul(val_A, inv(2)));\n        C.push_back(mul(val_A, inv(fact[cur])));\n        D.push_back(mul(B.back(), inv(fact[cur - 1])));\n    }\n    cout << norm(A[n] - 2) << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}