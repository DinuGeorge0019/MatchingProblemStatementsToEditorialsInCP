{"link": "https://codeforces.com//contest/1027/problem/E", "problemId": "209492", "shortId": "1027E", "contest_number": "1027", "name": "E. Inverse Coloring", "statement": "You are given a square board, consisting of  rows and  columns. Each tile in it should be colored either white or black.Let's call some coloring  if each pair of adjacent rows are either the same or different in every position. The same condition should be held for the columns as well.Let's call some coloring  if it is  and there is no  of the single color, consisting of at least  tiles.Your task is to count the number of  colorings of the board of the given size.Since the answer can be very large, print it modulo .", "input": "A single line contains two integers  and  (, ) \u2014 the number of rows and columns of the board and the maximum number of tiles inside the rectangle of the single color, respectively.", "output": "Print a single integer \u2014 the number of  colorings of the board of the given size modulo .", "tutorial": "You can notice that every coloring can be encoded by the two binary strings of length . You firstly generate one string to put as a first row and then use the second string to mark if you put the first string as it is or inverting each color.That way, you can also guess that the area of maximum rectangle of a single color you will get in you coloring is the product of maximum lengths of segments of a single color in both of the strings.Let's consider the following dynamic programming solution: is the number of binary strings of length , such the current last segment of a single color has length  and the maximum segment of a single color has length .The transitions are:   +=  \u2014 color the new tile the same as the previous one;   +=  \u2014 color the new tile the opposite from the previous one. The starting state is .Let's sum the values of this dp to an array  \u2014 the number of binary strings of length  such that the maximum segment of a single color in them has length . You can also do another dp to calculate this not in  but in  using some partial sums in it.Finally, you iterate over the first side of the resulting rectangle (the maximum length of segment of a single color in a first binary string) and multiply the number of ways to get it by the total number of ways to get the second side of the resulting rectangle, so that the area doesn't .Overall complexity:  or .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 500 + 7;\nconst int MOD = 998244353;\n\nint n, k;\nint dp[2][N][N];\nint cnt[N];\nint pr[N];\n\nvoid add(int &a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &k);\n    \n    dp[0][0][0] = 1;\n    forn(ii, n){\n        int i = ii & 1;\n        int ni = i ^ 1;\n        memset(dp[ni], 0, sizeof(dp[ni]));\n        forn(j, n + 1){\n            forn(k, n + 1){\n                add(dp[ni][j + 1][max(j + 1, k)], dp[i][j][k]);\n                add(dp[ni][1][max(1, k)], dp[i][j][k]);\n            }\n        }\n    }\n    \n    forn(i, n + 1)\n        forn(j, n + 1)\n            add(cnt[i], dp[n & 1][j][i]);\n    \n    forn(i, n + 1){\n        add(pr[i + 1], pr[i]);\n        add(pr[i + 1], cnt[i]);\n    }\n    \n    int ans = 0;\n    for (int i = 1; i <= n; ++i)\n        add(ans, cnt[i] * (long long)(pr[min(n + 1, (k - 1) / i + 1)]) % MOD);\n    \n    ans = (ans * (long long)((MOD + 1) / 2)) % MOD;\n    printf(\"%d\\n\", ans);\n    \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}