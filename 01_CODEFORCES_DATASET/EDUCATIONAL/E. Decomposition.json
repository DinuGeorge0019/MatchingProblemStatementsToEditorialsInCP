{"link": "https://codeforces.com//contest/1766/problem/E", "problemId": "1690150", "shortId": "1766E", "contest_number": "1766", "name": "E. Decomposition", "statement": "For a sequence of integers , let's define its  as follows:Process the sequence from the first element to the last one, maintaining the list of its subsequences. When you process the element , append it to the end of the  subsequence in the list such that the bitwise AND of its last element and  is greater than . If there is no such subsequence in the list, create a new subsequence with only one element  and append it to the end of the list of subsequences.For example, let's analyze the decomposition of the sequence :  processing element , the list of subsequences is empty. There is no subsequence to append  to, so we create a new subsequence ;  processing element , the list of subsequences is . Since the bitwise AND of  and  is , the element is appended to the first subsequence;  processing element , the list of subsequences is . Since the bitwise AND of  and  is , the element is appended to the first subsequence;  processing element , the list of subsequences is . There is no subsequence to append  to, so we create a new subsequence ;  processing element , the list of subsequences is . There is no subsequence to append  to, so we create a new subsequence ;  processing element , the list of subsequences is . Since the bitwise AND of  and  is , the element is appended to the first subsequence;  processing element , the list of subsequences is . Since the bitwise AND of  and  is , the element is appended to the first subsequence;  processing element , the list of subsequences is . The element  cannot be appended to any of the first two subsequences, but can be appended to the third one. The resulting list of subsequences is .Let  be the number of subsequences the sequence  is decomposed into..You are given a sequence , where each element is an integer from  to . Let  be the sequence . You have to calculate .", "input": "The first line contains one integer  (). The second line contains  integers  ().", "output": "Print one integer, which should be equal to .", "tutorial": "Let's assume that we don't have any zeroes in our array. We'll deal with them later.The key observation is that the number of sequences in the decomposition is not more than . To prove this, we can use the fact that each element  will be appended to the first subsequence in the decomposition; so, if the second/third subsequence in the decomposition ends with the number  or , all such numbers can be appended to that subsequence, thus they won't create any new subsequences. So, if we consider the combination of the last elements in the subsequences of the decomposition, there are only  such combinations (even less in practice).Okay, now let's try to use the fact that the number of such combinations is small. There are many ways to abuse it, but, in my opinion, the most straightforward one (and also a bit slow, but fast enough to easily pass the time limit) is to run the following dynamic programming: , where  is the index of the element we are processing, and  is the vector representing the combination of last elements of subsequences in the decomposition.But it's not clear what do we store in this dynamic programming. The model solution stores  (i.\u2009e. we will consider the number of subsequences added while processing the elements ). So, our dynamic programming automatically sums up the answers for all possible right borders of the segment we decompose. Transitions in this dynamic programming is easy: we need to see how does the element  alter the state of decomposition  (let it change it to ), take the value of , and if the element  forms a new subsequence, let's account for it by increasing  by , because this increase will affect  different right endpoints of the segment we decompose.And now it's easy to see how to add zeroes to our solution. We can just assume they don't change the state of decomposition, they simply add a new subsequence which won't take any other elements. So, in our transitions, processing  means that , but the size of decomposition increases.To actually get the answer to the problem, we need to consider all possible starting points of the segment, so we sum up  (where  is the empty vector) for all .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300043;\n\nint n;\nint v[N];\nmap<vector<int>, long long> dp[N];\n\npair<int, vector<int>> go(vector<int> a, int x)\n{\n    if(x == 0)\n        return {1, a};\n    else\n    {\n        bool f = false;\n        for(int i = 0; i < a.size() && !f; i++)\n            if((a[i] & x) > 0)\n            {\n                f = true;\n                a[i] = x;\n            }\n        int c = 0;\n        if(!f)\n        {\n            c = 1;\n            a.push_back(x);\n        }\n        return {c, a};\n    }\n}\n\nlong long calc(int i, vector<int> a)\n{\n    if(i == n) return 0ll;\n    if(dp[i].count(a)) return dp[i][a];\n    auto p = go(a, v[i]);\n    return (dp[i][a] = p.first * 1ll * (n - i) + calc(i + 1, p.second));\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++) scanf(\"%d\", &v[i]);\n    long long ans = 0;\n    for(int i = 0; i < n; i++)\n        ans += calc(i, vector<int>(0));\n    printf(\"%lld\\n\", ans);    \n}", "interactive": false, "noSolution": false, "noTutorial": false}