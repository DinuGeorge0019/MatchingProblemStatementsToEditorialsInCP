{"link": "https://codeforces.com//contest/1117/problem/C", "problemId": "300043", "shortId": "1117C", "contest_number": "1117", "name": "C. Magic Ship", "statement": "You a captain of a ship. Initially you are standing in a point  (obviously, all positions in the sea can be described by cartesian plane) and you want to travel to a point . You know the weather forecast \u2014 the string  of length , consisting only of letters , ,  and . The letter corresponds to a direction of wind. Moreover, the forecast is periodic, e.g. the first day wind blows to the side , the second day \u2014 , the -th day \u2014  and -th day \u2014  again and so on. Ship coordinates change the following way:  if wind blows the direction , then the ship moves from  to ;  if wind blows the direction , then the ship moves from  to ;  if wind blows the direction , then the ship moves from  to ;  if wind blows the direction , then the ship moves from  to . The ship can also either go one of the four directions or stay in place each day. If it goes then it's exactly 1 unit of distance. Transpositions of the ship and the wind add up. If the ship stays in place, then only the direction of wind counts. For example, if wind blows the direction  and the ship moves the direction , then from point  it will move to the point , and if it goes the direction , then it will move to the point .You task is to determine the minimal number of days required for the ship to reach the point .", "input": "The first line contains two integers  () \u2014 the initial coordinates of the ship. The second line contains two integers  () \u2014 the coordinates of the destination point. It is guaranteed that the initial coordinates and destination point coordinates are different. The third line contains a single integer  () \u2014 the length of the string . The fourth line contains the string  itself, consisting only of letters , ,  and .", "output": "The only line should contain the minimal number of days required for the ship to reach the point . If it's impossible then print \"\".", "tutorial": "Note, that if we can reach the destination in  days, so we can reach it in  days, since we can stay in the destination point by moving to the opposite to the wind direction. So, we can binary search the answer.To check the possibility to reach the destination point  in  days we should at first look at the position  the wind moves ship to. Now we can calculate where we can go: since each day we can move in one of four directions or not move at all, we can reach any point  with Manhattan distance . So we need to check that .To calculate  we can note, that there were  full cycles and  extra days. So it can be calculated with  time using prefix sums.Finally, about borders of binary search: to reach the destination point we need to move closer at least by one (it terms of Manhattan distance) from the full cycle of the wind. So, if answer exists then it doesn't exceed .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\nconst int N = 100009;\n\npair<int, int> st, fi;\nint n;\nstring s;\n\nstring mv = \"UDLR\";\nint dx[] = {0, 0, -1, 1};\nint dy[] = {1, -1, 0, 0};\n\npair<int, int> d[N];\n\nint main(){\n\tcin >> st.x >> st.y >> fi.x >> fi.y;\n\tcin >> n >> s;\t\t\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint id = -1;\n\t\tfor(int j = 0; j < 4; ++j)\n\t\t\tif(mv[j] == s[i])\n\t\t\t\tid = j;\n\t\tassert(id != -1);\n\t\td[i + 1] = make_pair(d[i].x + dx[id], d[i].y + dy[id]);\n\t}\n\n\tlong long l = 0, r = 1e18;\n\twhile(r - l > 1){\n\t\tlong long mid = (l + r) / 2;\n\t\tlong long cnt = mid / n, rem = mid % n;\n\t\tlong long x = st.x + d[rem].x + cnt *  1LL * d[n].x;\n\t\tlong long y = st.y + d[rem].y + cnt *  1LL * d[n].y;\n\t\tlong long dist = abs(x - fi.x) + abs(y - fi.y);\n\t\tif(dist <= mid)\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\t\n\t} \n\n\tif(r > 5e17) r = -1;\n\tcout << r << endl;\n\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}