{"link": "https://codeforces.com//contest/1809/problem/B", "problemId": "1839362", "shortId": "1809B", "contest_number": "1809", "name": "B. Points on Plane", "statement": "You are given a two-dimensional plane, and you need to place  chips on it. You can place a chip only at a point with integer coordinates. The cost of placing a chip at the point  is equal to  (where  is the absolute value of ).The cost of placing  chips is equal to the  among the costs of each chip.You need to place  chips on the plane in such a way that the Euclidean distance between each pair of chips is  than , and the cost is the minimum possible.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. Next  cases follow. The first and only line of each test case contains one integer  ()\u00a0\u2014 the number of chips you need to place.", "output": "For each test case, print a single integer\u00a0\u2014 the minimum cost to place  chips if the distance between each pair of chips must be strictly greater than .", "tutorial": "Suppose, the answer is . What's the maximum number of chips we can place? Firstly, the allowed points  to place chips are such that . We can group them by -coordinate: for  there is only one , for  possible  are ; for  possible  are in segment  and so on. For  possible  are in . The negative -s are the same.Let's calculate the maximum number of chips we can place at each \"row\": for  it's ; for  there are three -s, but since we can't place chips at the neighboring -s, we can place at most  chips; for  we have  places, but can place only  chips; for  we have  places, but can occupy only  points.In total, for  we can place at most  chips. Analogically, for  we can place at most  chips.In total, we can place at most  chips with cost at most . Note that  can actually be reached since the distance between chips on the different rows is greater than . So, to solve our task, it's enough to find minimum  such that  that can be done with Binary Search.Or we can calculate . Note that  can lose precision, since  is cast to  before taking the square root (for example,  transforms to  when converted to ). So you should either cast  to  (that consists of  bits in some C++ compilers) or check value  as a possible answer.", "solution": "fun main() {\n    repeat(readln().toInt()) {\n        val n = readln().toLong()\n        var l = (-1).toLong()\n        var r = 1e9.toLong()\n        while (r - l > 1) {\n            val mid = (l + r) / 2\n            if (mid * mid >= n)\n                r = mid\n            else\n                l = mid\n        }\n        println(r - 1)\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}