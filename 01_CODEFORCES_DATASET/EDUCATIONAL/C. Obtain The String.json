{"link": "https://codeforces.com//contest/1295/problem/C", "problemId": "526702", "shortId": "1295C", "contest_number": "1295", "name": "C. Obtain The String", "statement": "You are given two strings  and  consisting of lowercase Latin letters. Also you have a string  which is initially empty. You want string  to be equal to string . You can perform the following operation to achieve this: append any subsequence of  at the end of string . A subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements. For example, if , , you may turn  into following strings in one operation:    (if we choose subsequence );   (if we choose subsequence );   (if we choose subsequence ). Note that after this operation string  doesn't change.Calculate the minimum number of such operations to turn string  into string . ", "input": "The first line contains the integer  () \u2014 the number of test cases. The first line of each testcase contains one string  () consisting of lowercase Latin letters. The second line of each testcase contains one string  () consisting of lowercase Latin letters. It is guaranteed that the total length of all strings  and  in the input does not exceed .", "output": "For each testcase, print one integer \u2014 the minimum number of operations to turn string  into string . If it's impossible print .", "tutorial": "The answer is  when in string  there is a character that is not in string .Otherwise let's precalculate the following array  = minimum index  from  to  such that  (if there is no such index then ).Now we can solve this problem by simple greed. Presume that now , and last taken symbol in  is . Then there are two options:   if , then , ;  if , then  and  ( is equal to  initially); ", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = int(2e5) + 99;\nconst int INF = int(1e9) + 99;\n\nint tc;\nstring s, t;\nint nxt[N][26];\n\nint main() {\n    cin >> tc;\n    while(tc--){\n        cin >> s >> t;\n        for(int i = 0; i < s.size() + 5; ++i)\n            for(int j = 0; j < 26; ++j)\n                nxt[i][j] = INF;\n    \t\n        for(int i = int(s.size()) - 1; i >= 0; --i){\n            for(int j = 0; j < 26; ++j)\n                nxt[i][j] = nxt[i + 1][j];\n            nxt[i][s[i] - 'a'] = i;\n        }    \n    \n        int res = 1, pos = 0;\n        for(int i = 0; i < t.size(); ++i){\n            if(pos == s.size()){\n                pos = 0;\n                ++res;\n            }\n            if(nxt[pos][t[i] - 'a'] == INF){\n                pos = 0; \n                ++res;\n    \t\t}\n    \t\tif(nxt[pos][t[i] - 'a'] == INF && pos == 0){\n                res = INF;\n                break;\n            }    \n            pos = nxt[pos][t[i] - 'a'] + 1;\n            \n        }\n    \n        if(res >= INF) cout << -1 << endl;\n        else cout << res << endl;\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}