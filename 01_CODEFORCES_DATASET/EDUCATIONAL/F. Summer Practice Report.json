{"link": "https://codeforces.com//contest/1076/problem/F", "problemId": "253930", "shortId": "1076F", "contest_number": "1076", "name": "F. Summer Practice Report", "statement": "Vova has taken his summer practice this year and now he should write a report on how it went.Vova has already drawn all the tables and wrote down all the formulas. Moreover, he has already decided that the report will consist of exactly  pages and the -th page will include  tables and  formulas. The pages are numbered from  to .Vova fills the pages one after another, he can't go filling page  before finishing page  and he can't skip pages. However, if he draws  than  tables in a row or writes  than  formulas in a row then he will get bored. Vova wants to rearrange tables and formulas in each page in such a way that he doesn't get bored in the process. Vova can't move some table or some formula to another page.Note that the count doesn't reset on the start of the new page. For example, if the page ends with  tables and the next page starts with  tables, then it's counted as  tables in a row.Help Vova to determine if he can rearrange tables and formulas on each page in such a way that there is no more than  tables in a row and no more than  formulas in a row.", "input": "The first line contains two integers  and  (, ). The second line contains  integers  () \u2014 the number of tables on the -th page. The third line contains  integers  () \u2014 the number of formulas on the -th page.", "output": "Print \"\" if Vova can rearrange tables and formulas on each page in such a way that there is no more than  tables in a row and no more than  formulas in a row. Otherwise print \"\".", "tutorial": "Let's intruduce the following dynamic programming approach. ,  is the smallest number of elements of type  page  can end with. If we learn to recalculate it, the answer will be \"\" if  or . I will try to prove it on the fly.Let's look into the constructing of each page from the following perspective. I'll consider the cases when the current page ends with tables and the previous page ends with either tables or formulas. Let's write down all the tables and then put formulas as separators to them. I will call number of tables on the end of the previous page , the number of formulas on the end of the previous page , the number on tables on the current page  and the number of formulas on the current page . In the case with tables on the end of the previous page the smallest number of separators you can have is . Moreover, if you have , you can put one of the formulas right before the end of the page, ending it with  table. The only case is when there are too many separators.  should be less or equal to  (you can put up to  separators before each table).The case with formulas on the end of the previous page isn't that different. The smallest number of separators is  and the limit to the number of separators is  (you can't put  separators before the first table as in the first case, the maximum number to that position is determined by the previous page).Now let's take a look at resulting expressions. You can notice that lowering  can only decrease the lower bound on the number of separators and lowering  can only increase the upper bound on the number of separators. That shows that minimizing the values in  is always profitable.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\ntypedef long long li;\n\nconst int N = 300 * 1000 + 13;\nconst int INF = 1e9;\n\nint dp[N][2];\n\nint n, k;\nint a[N], b[N];\n\nint get(int pa, int pb, int a, int b){\n\tint ans = INF;\n\t\n\tif (pa <= k){\n\t\tint tot = pa + a;\n\t\tint cnt = (tot + k - 1) / k - 1;\n\t\tif (b == cnt)\n\t\t\tans = min(ans, tot - cnt * k);\n\t\telse if (b > cnt && b <= a * li(k))\n\t\t\tans = min(ans, 1);\n\t}\n\t\n\tif (pb <= k){\n\t\tint cnt = (a + k - 1) / k - 1;\n\t\tif (b == cnt)\n\t\t\tans = min(ans, a - cnt * k);\n\t\telse if (b > cnt && b <= (a - 1) * li(k) + (k - pb))\n\t\t\tans = min(ans, 1);\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tforn(i, n) scanf(\"%d\", &a[i]);\n\tforn(i, n) scanf(\"%d\", &b[i]);\n\t\n\tforn(i, N) forn(j, 2) dp[i][j] = INF;\n\tdp[0][0] = 0;\n\tdp[0][1] = 0;\n\tforn(i, n){\n\t\tdp[i + 1][0] = get(dp[i][0], dp[i][1], a[i], b[i]);\n\t\tdp[i + 1][1] = get(dp[i][1], dp[i][0], b[i], a[i]);\n\t}\n\t\n\tputs(dp[n][0] <= k || dp[n][1] <= k ? \"YES\" : \"NO\");\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}