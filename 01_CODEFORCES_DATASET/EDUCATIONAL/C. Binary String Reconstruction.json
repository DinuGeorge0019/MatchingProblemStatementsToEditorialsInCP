{"link": "https://codeforces.com//contest/1400/problem/C", "problemId": "709185", "shortId": "1400C", "contest_number": "1400", "name": "C. Binary String Reconstruction", "statement": "Consider the following process. You have a binary string (a string where each character is either  or )  of length  and an integer . You build a new binary string  consisting of  characters. The -th character of  is chosen as follows:  if the character  exists and is equal to , then  is  (formally, if  and  , then  );  if the character  exists and is equal to , then  is  (formally, if  and  , then  );  if both of the aforementioned conditions are false, then  is . You are given the integer  and the resulting string . Reconstruct the original string .", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case consists of two lines. The first line contains the resulting string  (, each character of  is either  or ). The second line contains one integer  (). The total length of all strings  in the input does not exceed .", "output": "For each test case, print the answer on a separate line as follows:   if no string  can produce the string  at the end of the process, print ;  otherwise, print the binary string  consisting of  characters. If there are multiple answers, print any of them. ", "tutorial": "Note that  means \"either  or ,\" whereas  means \"both  and .\" We can greedily solve this by starting out our string  with all 1's, then marking  and  as 0 whenever we are forced to because . Then we can simply check whether all of the  conditions are valid to confirm. Code: 90915688\n", "solution": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    string S;\n    int X;\n    cin >> S >> X;\n    int N = int(S.size());\n    string W(N, '1');\n\n    for (int i = 0; i < N; i++)\n        if (S[i] == '0') {\n            if (i - X >= 0)\n                W[i - X] = '0';\n\n            if (i + X < N)\n                W[i + X] = '0';\n        }\n\n    for (int i = 0; i < N; i++) {\n        bool one = false;\n        one = one || (i - X >= 0 && W[i - X] == '1');\n        one = one || (i + X < N && W[i + X] == '1');\n\n        if (S[i] != one + '0') {\n            cout << -1 << '\\n';\n            return;\n        }\n    }\n\n    cout << W << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}