{"link": "https://codeforces.com//contest/954/problem/G", "problemId": "167344", "shortId": "954G", "contest_number": "954", "name": "G. Castle Defense", "statement": "Today you are going to lead a group of elven archers to defend the castle that is attacked by an army of angry orcs. Three sides of the castle are protected by impassable mountains and the remaining side is occupied by a long wall that is split into  sections. At this moment there are exactly  archers located at the -th section of this wall. You know that archer who stands at section  can shoot orcs that attack section located at distance not exceeding , that is all such sections  that . In particular,  means that archers are only capable of shooting at orcs who attack section .Denote as  of section  the total number of archers who can shoot at the orcs attacking this section.  of the defense plan is the minimum value of defense level of individual wall section.There is a little time left till the attack so you can't redistribute archers that are already located at the wall. However, there is a reserve of  archers that you can distribute among wall sections in arbitrary way. You would like to achieve maximum possible reliability of the defence plan.", "input": "The first line of the input contains three integers ,  and  (, , )\u00a0\u2014 the number of sections of the wall, the maximum distance to other section archers can still shoot and the number of archers yet to be distributed along the wall. The second line contains  integers  ()\u00a0\u2014 the current number of archers at each section.", "output": "Print one integer\u00a0\u2014 the maximum possible value of defense plan reliability, i.e. the maximum possible value of minimum defense level if we distribute  additional archers optimally.", "tutorial": "Firstly, if we may obtain reliability at least , then we may obtain reliability not less than  with the same number of archers. So we may use binary search and check whether we may obtain reliability at least .How can we check it? Let's find the leftmost section such that its defense level is less than . Let its index be . We obviously have to add some archers controlling this section, and since every section to the left of it is already controlled, the best option where to add archers is the section with index . After we added enough archers, we move to next section such that its defense level is less than  and do the same. If we run out of archers without protecting all the sections, then it's impossible to obtain reliability .To do checking in , we may use prefix sums or \"sliding window\" technique.", "solution": "#include<bits/stdc++.h>\n#define ll long long\n#define MN 500000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,a[MN+5],r;ll K,s[MN+5];\nll Solve(ll mn)\n{\n\tll sum=0,now=0;\n\tfor(int i=1;i<=n;++i) s[i]=a[i];\n\tfor(int i=1;i<=r;++i) now+=s[i];\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tnow+=i+r>n?0:s[i+r];\n\t\tnow-=i-r-1<1?0:s[i-r-1];\n\t\tif(now<mn) \n\t\t\ts[min(n,i+r)]+=mn-now,\n\t\t\tsum=min(sum+mn-now,(ll)2e18),now=mn;\n\t}\n\treturn sum;\n}\nint main()\n{\n\tn=read();r=read();cin>>K;\n\tfor(int i=1;i<=n;++i) a[i]=read();\n\tll l=0,r=2e18,mid,res;\n\twhile(l<=r)\n\t{\n\t\tmid=l+r>>1;\n\t\tif(Solve(mid)<=K) res=mid,l=mid+1;\n\t\telse r=mid-1;\t\n\t}\n\tcout<<res;\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}