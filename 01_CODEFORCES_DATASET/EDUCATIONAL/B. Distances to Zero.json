{"link": "https://codeforces.com//contest/803/problem/B", "problemId": "104507", "shortId": "803B", "contest_number": "803", "name": "B. Distances to Zero", "statement": "You are given the array of integer numbers . For each element find the distance to the nearest zero (to the element which equals to zero). There is at least one zero element in the given array.", "input": "The first line contains integer  () \u2014 length of the array . The second line contains integer elements of the array separated by single spaces ().", "output": "Print the sequence , where  is the difference of indices between  and nearest  such that . It is possible that .", "tutorial": "Let's divide the solution into two parts: firstly check the closest zero to the left and then the closest zero to the right. After that we can take minimum of these numbers. Initialize distance with infinity. Iterate over array from left to right. If value in current position is  then set distance to , otherwise increase distance by . On each step write value of distance to the answer array.Do the same thing but going from right to left. This will find closest zero to the right. Now you should write minimum of current value of distance and value that's already in answer array.Finally you should retrieve the answer from distances.Overall complexity: .", "solution": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = (int)1e6 + 7;\nint n;\nint a[N];\nint b[N];\n\nint main()\n{\n//    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\", &a[i]);\n    for (int i = 0; i < n; i++)\n        b[i] = n;\n    int lst = -n;\n    for (int i = 0; i < n; i++)\n    {\n        if (a[i] == 0)\n            lst = i;\n        b[i] = min(b[i], i - lst);\n    }\n    lst = 2 * n;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (a[i] == 0) lst = i;\n        b[i] = min(b[i], lst - i);\n    }\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", b[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}