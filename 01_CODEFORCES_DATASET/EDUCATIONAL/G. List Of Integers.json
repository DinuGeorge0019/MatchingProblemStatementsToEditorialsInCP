{"link": "https://codeforces.com//contest/920/problem/G", "problemId": "152867", "shortId": "920G", "contest_number": "920", "name": "G. List Of Integers", "statement": "Let's denote as  an infinite sequence of integers  such that  and  (where  is the greatest common divisor of two integer numbers), sorted in ascending order. The elements of  are -indexed; for example, ,  and  are the first, the second and the third elements of , respectively.You have to process  queries. Each query is denoted by three integers ,  and , and the answer to this query is -th element of .", "input": "The first line contains one integer  () \u2014 the number of queries to process. Then  lines follow. -th line contains three integers ,  and  for -th query ().", "output": "Print  integers, where -th integer is the answer to -th query.", "tutorial": "Let's use binary searching to find the answer. Denote as  the number of positive integers  such that  and ; the answer is the smallest integer  such that . We may use, for example,  as the right border of segment where we use binary searching; although the answers are a lot smaller than this number, for  it is obvious that  will be really large for any  from .How can we calculate  fastly? Let's factorize  and use inclusion-exclusion. Let  be a subset of the set of prime divisors of , and  be the product of all numbers from . For each possible subset , we have to add  to the result (since there are exactly  integers from  divisible by every prime from ). Since any number from  has at most  prime divisors, there are at most  subsets to process.", "solution": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nbool pchk[1000050];\nvector <int> Vp;\n\nvector <int> Vl[1000050];\n\nvector <pll> Vu;\nll getcnt(ll t) {\n\tll rv = 0;\n\tfor (auto it : Vu) rv += (t / it.first) * it.second;\n\treturn rv;\n}\nint main() {\n\tint i, j;\n\tfor (i = 2; i <= 1000000; i++) {\n\t\tif (pchk[i]) continue;\n\t\tVp.push_back(i);\n\t\tfor (j = 2 * i; j <= 1000000; j += i) pchk[j] = true;\n\t\tfor (j = i; j <= 1000000; j += i) Vl[j].push_back(i);\n\t}\n\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--) {\n\t\tll X, P, K;\n\t\tscanf(\"%lld %lld %lld\", &X, &P, &K);\n\n\t\tVu.clear();\n\t\tint n = Vl[P].size();\n\t\tfor (i = 0; i < (1 << n); i++) {\n\t\t\tll v = 1, c = 0;\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tif (i & (1 << j)) {\n\t\t\t\t\tv *= Vl[P][j];\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c % 2 == 0) Vu.emplace_back(v, 1);\n\t\t\telse Vu.emplace_back(v, -1);\n\t\t}\n\t\tll c = getcnt(X);\n\t\tll st = X + 1, en = 1e11, mi, rv = en + 1;\n\t\twhile (st <= en) {\n\t\t\tmi = (st + en) / 2;\n\t\t\tll c2 = getcnt(mi) - c;\n\t\t\tif (c2 >= K) {\n\t\t\t\trv = mi;\n\t\t\t\ten = mi - 1;\n\t\t\t}\n\t\t\telse st = mi + 1;\n\t\t}\n\t\tprintf(\"%lld\\n\", rv);\n\t}\n\treturn 0;\n}\n//*/", "interactive": false, "noSolution": false, "noTutorial": false}