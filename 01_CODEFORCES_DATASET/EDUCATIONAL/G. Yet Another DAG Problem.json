{"link": "https://codeforces.com//contest/1430/problem/G", "problemId": "755159", "shortId": "1430G", "contest_number": "1430", "name": "G. Yet Another DAG Problem", "statement": "You are given a directed acyclic graph (a directed graph that does not contain cycles) of  vertices and  arcs. The -th arc leads from the vertex  to the vertex  and has the weight .Your task is to select an integer  for each vertex , and then write a number  on each arcs  such that . You must select the numbers so that:  all  are positive;  the value of the expression  is the lowest possible. It can be shown that for any directed acyclic graph with non-negative , such a way to choose numbers exists.", "input": "The first line contains two integers  and  (; ). Then  lines follow, the -th of them contains three integers ,  and  (, , ) \u2014 the description of the -th arc. It is guaranteed that the lines describe  arcs of a directed acyclic graph without multiple arcs between the same pair of vertices.", "output": "Print  integers , , ...,  (), which must be written on the vertices so that all  are positive, and the value of the expression  is the lowest possible. If there are several answers, print any of them. It can be shown that the answer always exists, and at least one of the optimal answers satisfies the constraints .", "tutorial": "The key observation in this problem is that the values of  should form a contiguous segment of integers. For example, suppose there exists a value  such that there is at least one , there is at least one , but no . We can decrease all values of  that are greater than  by , so the answer will still be valid, but the value of  will decrease. So, the values of  form a contiguous segment of integers. We can always assume that this segment is , since subtracting the same value from each  does not change anything.The other observation we need is that we can rewrite the expression we have to minimize as follows: , where  is the signed sum of weights of all arcs incident to the vertex  (the weights of all arcs leading from  are taken with positive sign, and the weights of all arcs leading to  are taken with negative sign). These two observations lead us to a bitmask dynamic programming solution: let  be the minimum value of , if we assigned the values from  to the vertices from . A naive way to calculate this dynamic programming is to iterate on the submask of , check that choosing the integer  for each vertex from that submask doesn't ruin anything (for each vertex that belongs to this submask, all vertices that are reachable from it should have , so they should belong to , but not to the submask we iterate on), and update the dynamic programming value. But this solution is , and, depending on your implementation, this might be too slow.It's possible to speed this up to  in a way similar to how profile dp can be optimized from  to : we won't iterate on the submask; instead, we will try to add the vertices one by one, and we should be able to add a vertex to the mask only if all vertices that are reachable from it already belong to the mask. There is a possibility that we add two vertices connected by an arc with the same value of , so, for a fixed value of , we should consider assigning it to vertices in topological sorting order (that way, if one vertex is reachable from another, it will be considered later, so we won't add both of those with the same value of ).", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst int N = 18;\nconst int M = (1 << N);\nconst li INF64 = li(1e18);\n\nint n, m;\nvector<int> g[N];\nli sum[N];\nint need_mask[N];\nli dp[N + 1][N + 1][M];\nbool p[N + 1][N + 1][M];\n\nvector<int> order;       \nvector<int> used;\n\nvoid dfs(int x, bool build_topo)\n{\n    if(used[x])\n    \treturn;\n    used[x] = 1;\n    for(auto y : g[x])\n    \tdfs(y, build_topo);\n    if(build_topo)\n    \torder.push_back(x);\n}\n\nint main()\n{\n\tcin >> n >> m;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t \tint x, y, w;\n\t \tcin >> x >> y >> w;\n\t \t--x;\n\t \t--y;\n\t \tsum[x] += w;\n\t \tsum[y] -= w;\n\t \tg[x].push_back(y);\n\t}\n\tused.resize(n);\n\tfor(int i = 0; i < n; i++)\n\t\tdfs(i, true);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t \tused = vector<int>(n, 0);\n\t \tdfs(i, false);\n\t \tfor(int j = 0; j < n; j++)\n\t \t\tif(j != i && used[j] == 1)\n\t \t\t\tneed_mask[i] |= (1 << j);\t\t\n\t}\n\tfor(int i = 0; i <= n; i++)\n\t\tfor(int j = 0; j <= n; j++)\n\t\t\tfor(int k = 0; k < (1 << n); k++)\n\t\t\t\tdp[i][j][k] = INF64;\n\tdp[0][0][0] = 0;\n\treverse(order.begin(), order.end());\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j <= n; j++)\n\t\t\tfor(int k = 0; k < (1 << n); k++)\n\t\t\t{\n\t\t\t \tif(dp[i][j][k] > INF64 / 2)\n\t\t\t \t\tcontinue;\n\t\t\t \tif(j == n)\n\t\t\t \t{\n\t\t\t \t \tif(dp[i + 1][0][k] > dp[i][j][k])\n\t\t\t \t \t{\n\t\t\t \t \t \tdp[i + 1][0][k] = dp[i][j][k];\n\t\t\t \t \t \tp[i + 1][0][k] = false;\n\t\t\t \t \t}\n\t\t\t \t}\n\t\t\t \telse\n\t\t\t \t{\n\t\t\t \t\tint v = order[j];\n\t\t\t \t\tli add = sum[v] * i;\n\t\t\t \t\tif(dp[i][j + 1][k] > dp[i][j][k])\n\t\t\t \t\t{\n\t\t\t \t\t \tdp[i][j + 1][k] = dp[i][j][k];\n\t\t\t \t\t \tp[i][j + 1][k] = false;\n\t\t\t \t\t}\n\t\t\t \t\tif(((k & (1 << v)) == 0) && ((need_mask[v] & k) == need_mask[v]))\n\t\t\t \t\t{\n\t\t\t \t\t \tint nk = k | (1 << v);\n\t\t\t \t\t \tif(dp[i][j + 1][nk] > dp[i][j][k] + add)\n\t\t\t \t\t \t{\n\t\t\t \t\t \t \tdp[i][j + 1][nk] = dp[i][j][k] + add;\n\t\t\t \t\t \t \tp[i][j + 1][nk] = true;\n\t\t\t \t\t \t}\n\t\t\t\t \t}\n\t\t\t\t}\n\t\t\t}\n\tvector<int> ans(n);\n\tint i = n;\n\tint j = 0;\n\tint k = (1 << n) - 1;\n\twhile(i > 0 || j > 0 || k > 0)\n\t{\n\t \tif(j == 0)\n\t \t{\n\t \t \tj = n;\n\t \t \ti--;\n\t \t}\n\t \telse\n\t \t{\n\t \t \tif(p[i][j][k])\n\t \t \t{\n\t \t \t \tint v = order[j - 1];\n\t \t \t \tans[v] = i;\n\t \t \t \tk ^= (1 << v);\n\t \t\t}\n\t \t\tj--;\n\t \t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\tcout << ans[i] << \" \\n\"[i == n - 1];\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}