{"link": "https://codeforces.com//contest/985/problem/E", "problemId": "184586", "shortId": "985E", "contest_number": "985", "name": "E. Pencils and Boxes", "statement": "Mishka received a gift of multicolored pencils for his birthday! Unfortunately he lives in a monochrome world, where everything is of the same color and only saturation differs. This pack can be represented as a sequence  of  integer numbers \u2014 saturation of the color of each pencil. Now Mishka wants to put all the mess in the pack in order. He has an infinite number of empty boxes to do this. He would like to fill some boxes in such a way that:  Each pencil belongs to  one box;  Each non-empty box has at least  pencils in it;  If pencils  and  belong to the same box, then , where  means absolute value of . Note that the opposite is optional, there can be pencils  and  such that  and they belong to different boxes. Help Mishka to determine if it's possible to distribute all the pencils into boxes. Print \"\" if there exists such a distribution. Otherwise print \"\".", "input": "The first line contains three integer numbers ,  and  (, ) \u2014 the number of pencils, minimal size of any non-empty box and maximal difference in saturation between any pair of pencils in the same box, respectively. The second line contains  integer numbers  () \u2014 saturation of color of each pencil.", "output": "Print \"\" if it's possible to distribute all the pencils into boxes and satisfy all the conditions. Otherwise print \"\".", "tutorial": "At first you need to sort the sequence. Then if there exists some answer, there also exists an answer such that every box in it contains some segment of pencils.Now it's pretty standard dp approach. Let  be  if it's possible to distribute the first  pencils into boxes correctly,  otherwise,  initially. Now you can come up with straightforward  implementation. Let's iterate over every  and set  to  if for some  ,  and .Now we should optimize it a bit. Notice that the second and the third conditions actually form some segment of indices. You need to check if there is at least one  value on this segment. This can be maintained with two pointers, set, BIT, segment tree. Anything you can code to get update in point and sum/max on segment queries. Overall complexity: .", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define forn(i, n) for(int i = 0; i < int(n); i++) \n\nconst int N = 500 * 1000 + 13;\n\nint f[N];\n\nvoid upd(int x){\n    for (int i = x; i < N; i |= i + 1)\n        ++f[i];\n}\n\nint sum(int x){\n    int res = 0;\n    for (int i = x; i >= 0; i = (i & (i + 1)) - 1)\n        res += f[i];\n    return res;\n}\n\nint get(int l, int r){\n\tif (l > r) return 0;\n\treturn sum(r) - sum(l - 1);\n}\n\nint main(){\n\tint n, k, dif;\n\tscanf(\"%d%d%d\", &n, &k, &dif);\n\tvector<int> a(n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\tsort(a.begin(), a.end());\n\t\n\tvector<int> dp(n + 1, 0);\n\t\n\tdp[0] = 1;\n\tupd(0);\n\t\n\tint l = 0;\n\tforn(i, n){\n\t\twhile (l < i && a[i] - a[l] > dif)\n\t\t\t++l;\n\t\tdp[i + 1] = (get(l, i - k + 1) >= 1);\n\t\tif (dp[i + 1]) upd(i + 1);\n\t}\n\t\n\tputs(dp[n] ? \"YES\" : \"NO\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}