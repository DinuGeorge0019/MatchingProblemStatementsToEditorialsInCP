{"link": "https://codeforces.com//contest/1312/problem/F", "problemId": "557982", "shortId": "1312F", "contest_number": "1312", "name": "F. Attack on Red Kingdom", "statement": "The Red Kingdom is attacked by the White King and the Black King!The Kingdom is guarded by  castles, the -th castle is defended by  soldiers. To conquer the Red Kingdom, the Kings have to eliminate all the defenders. Each day the White King launches an attack on one of the castles. Then, at night, the forces of the Black King attack a castle (possibly the same one). Then the White King attacks a castle, then the Black King, and so on. The first attack is performed by the White King.Each attack must target a castle with  alive defender in it. There are three types of attacks:  a  decreases the number of defenders in the targeted castle by  (or sets it to  if there are already less than  defenders);  an  decreases the number of defenders in the targeted castle by  (or sets it to  if there are already less than  defenders);  a  decreases the number of defenders in the targeted castle by  (or sets it to  if there are already less than  defenders). The  can be launched at any valid target (at any castle with at least one soldier). However, the  cannot be launched if the  had the same type, no matter when and by whom it was launched. The same applies to the . A castle that was not attacked at all can be targeted by any type of attack.The King who launches the last attack will be glorified as the conqueror of the Red Kingdom, so both Kings want to launch the last attack (and they are wise enough to find a strategy that allows them to do it no matter what are the actions of their opponent, if such strategy exists). The White King is leading his first attack, and you are responsible for planning it. Can you calculate the number of possible options for the first attack that allow the White King to launch the last attack? Each option for the first attack is represented by the targeted castle and the type of attack, and two options are different if the targeted castles or the types of attack are different.", "input": "The first line contains one integer  () \u2014 the number of test cases. Then, the test cases follow. Each test case is represented by two lines.  The first line contains four integers , ,  and  (, ).  The second line contains  integers , , ...,  (). It is guaranteed that the sum of values of  over all test cases in the input does not exceed .", "output": "For each test case, print the answer to it: the number of possible options for the first attack of the White King (or , if the Black King can launch the last attack no matter how the White King acts).", "tutorial": "This problem seems like a version of Nim with some forbidden moves, so let's try to apply Sprague-Grundy theory to it.First of all, we may treat each castle as a separate game, compute its Grundy value, and then XOR them to determine who is the winner of the game. When analyzing the state of a castle, we have to know two things: the number of remaining soldiers in it and the type of the last attack performed on it. So, the state of the game can be treated as a pair.We can compute Grundy values for each state in a straightforward way, but the constraints are too large to do it. Instead, we should try to search for a period: five consecutive rows (by row we mean a vector of Grundy values for the same number of remaining soldiers, but different types of last attacks) of Grundy values determine all of the values after them, so as soon as we get the same five rows of Grundy values that we already met, we can determine the period.There are  values stored in these five rows, so the period can be up to  \u2014 but that's a really generous upper bound. Some intuition can help us to prove something like  or  as an upper bound, but it is better to check all cases with brute force and find out that the period is at most .After we've found the period of Grundy values, it's easy to get them in  for any castle. To count the number of winning moves for the first player, we can compute the XOR-sum of all castles, and for each castle check what happens if we make some type of attack on it: if the XOR-sum becomes , then this move is winning.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300043;\nconst int K = 5;\n\nint x, y, z, n;\nlong long a[N];\n\ntypedef vector<vector<int> > state;\nmap<state, int> d;\nint cnt;\nint p;\nvector<vector<int> > state_log;\n\nint mex(const vector<int>& a)\n{\n    for(int i = 0; i < a.size(); i++)\n    {\n        bool f = false;\n        for(auto x : a)\n            if(x == i)\n                f = true;\n        if(!f)\n            return i;\n    }\n    return a.size();\n}\n\nstate go(state s)\n{\n    int f1 = mex({s[0][K - x], s[1][K - y], s[2][K - z]});\n    int f2 = mex({s[0][K - x], s[2][K - z]});\n    int f3 = mex({s[0][K - x], s[1][K - y]});\n    state nw = s;\n    nw[0].push_back(f1);\n    nw[1].push_back(f2);\n    nw[2].push_back(f3);\n    for(int i = 0; i < 3; i++)\n        nw[i].erase(nw[i].begin());\n    return nw;\n}\n\nvoid precalc()\n{\n    d.clear();\n    state cur(3, vector<int>(K, 0));\n    cnt = 0;\n    state_log.clear();\n    while(!d.count(cur))\n    {\n        d[cur] = cnt;\n        state_log.push_back({cur[0].back(), cur[1].back(), cur[2].back()});\n        cur = go(cur);\n        cnt++;\n    }                   \n    p = cnt - d[cur];\n}\n\nint get_grundy(long long x, int t)\n{\n    if(x < cnt)\n        return state_log[x][t];\n    else\n    {\n        int pp = cnt - p;\n        x -= pp;\n        return state_log[pp + (x % p)][t];\n    }\n}\n\nvoid read()\n{\n    scanf(\"%d %d %d %d\", &n, &x, &y, &z);\n    for(int i = 0; i < n; i++)\n        scanf(\"%lld\", &a[i]);\n}                    \n\nint check(int x, int y)\n{\n    return x == y ? 1 : 0;\n}\n\nvoid solve()\n{\n    precalc();\n    int ans = 0;\n    for(int i = 0; i < n; i++)\n        ans ^= get_grundy(a[i], 0);\n    int res = 0;\n    for(int i = 0; i < n; i++)\n    {\n        ans ^= get_grundy(a[i], 0);\n        res += check(ans, get_grundy(max(0ll, a[i] - x), 0));\n        res += check(ans, get_grundy(max(0ll, a[i] - y), 1));\n        res += check(ans, get_grundy(max(0ll, a[i] - z), 2));\n        ans ^= get_grundy(a[i], 0);\n    }\n    printf(\"%d\\n\", res);\n}\n\nint main()\n{\n    int t;\n    scanf(\"%d\", &t);\n    for(int i = 0; i < t; i++)\n    {\n        read();\n        solve();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}