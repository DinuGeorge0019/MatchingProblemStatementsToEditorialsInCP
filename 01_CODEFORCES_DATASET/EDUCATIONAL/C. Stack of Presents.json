{"link": "https://codeforces.com//contest/1279/problem/C", "problemId": "504275", "shortId": "1279C", "contest_number": "1279", "name": "C. Stack of Presents", "statement": "Santa has to send presents to the kids. He has a large stack of  presents, numbered from  to ; the topmost present has number , the next present is , and so on; the bottom present has number . All numbers are distinct.Santa has a list of   presents he has to send: , , ..., . He will send them .To send a present, Santa has to find it in the stack by removing all presents above it, taking this present and returning all removed presents on top of the stack. So, if there are  presents above the present Santa wants to send, it takes him  seconds to do it. Fortunately, Santa can speed the whole process up \u2014 when he returns the presents to the stack, he may reorder them as he wishes (only those which were above the present he wanted to take; the presents below cannot be affected in any way).What is the minimum time required to send all of the presents, provided that Santa knows the whole list of presents he has to send and reorders the presents optimally? Santa cannot change the order of presents or interact with the stack of presents in any other way.Your program has to answer  different test cases.", "input": "The first line contains one integer  () \u2014 the number of test cases. Then the test cases follow, each represented by three lines. The first line contains two integers  and  () \u2014 the number of presents in the stack and the number of presents Santa wants to send, respectively. The second line contains  integers , , ...,  (, all  are unique) \u2014 the order of presents in the stack. The third line contains  integers , , ...,  (, all  are unique) \u2014 the ordered list of presents Santa has to send. The sum of  over all test cases does not exceed .", "output": "For each test case print one integer \u2014 the minimum number of seconds which Santa has to spend sending presents, if he reorders the presents optimally each time he returns them into the stack.", "tutorial": "At first let's precalculate array $$$pos$$$ such that $$$pos_{a_i} = i$$$.Now presume that we have to calculate answer for $$$b_i$$$. Then there are two cases (let's denote $$$lst = \\max\\limits_{1 \\le j < i} pos_{b_j}$$$, initially $$$lst = -1$$$):  if $$$pos_{b_i} > lst$$$ then we have to spend $$$1 + 2 \\cdot (pos_{b_i} - (i - 1))$$$ seconds on it ( second on the gift $$$b_i$$$, $$$pos_{b_i} - (i - 1)$$$ seconds on removing gifts above and $$$pos_{b_i} - (i - 1)$$$ seconds on pushing these gifts);  if $$$pos_{b_i} < lst$$$ then we can reorder gifts by previous actions such that gift $$$b_i$$$ be on the top of stack. So we spend only  second on it. ", "solution": "for t in range(int(input())):\n\tn, m = map(int, input().split())\n\ta = [x - 1 for x in list(map(int, input().split()))]\n\tb = [x - 1 for x in list(map(int, input().split()))]\n\tpos = a[:]\n\tfor i in range(n):\n\t\tpos[a[i]] = i\n\t\n\tlst = -1\n\tres = m\n\tfor i in range(m):\n\t\tif pos[b[i]] > lst:\n\t\t\tres += 2 * (pos[b[i]] - i)\n\t\t\tlst = pos[b[i]]\n\t\n\tprint(res)", "interactive": false, "noSolution": false, "noTutorial": false}