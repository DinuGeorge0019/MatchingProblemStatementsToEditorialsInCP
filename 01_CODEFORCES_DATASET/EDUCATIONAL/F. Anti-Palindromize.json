{"link": "https://codeforces.com//contest/884/problem/F", "problemId": "130892", "shortId": "884F", "contest_number": "884", "name": "F. Anti-Palindromize", "statement": "A string  of length  is called  iff  is even, and for each  () .Ivan has a string  consisting of  lowercase Latin letters;  is even. He wants to form some string  that will be an  permutation of . Also Ivan has denoted the  of index  as , and the  of  as the sum of  among all indices  such that .Help Ivan to determine maximum possible  of  he can get.", "input": "The first line contains one integer  (,  is even) \u2014 the number of characters in . The second line contains the string  itself. It consists of only lowercase Latin letters, and it is guaranteed that its letters can be reordered to form an  string. The third line contains  integer numbers , , ...,  (), where  is the  of index .", "output": "Print one number \u2014 the maximum possible  of .", "tutorial": "This problem has two different solutions: a mincost maxflow approach and a greedy one. We will tell you about the latter.First of all, let . Then find all pairs of indices  such that  (let the number of these pairs be ). It's obvious that we have to replace at least one letter in each of these pairs.For each of these pairs let's replace the letter with lower  with something. Let's analyze the letters we are going to replace. Let  be the number of occurences of letter  that we have to replace. There are two cases:  There is no letter  such that . Then we can replace these letters without involving anything else and get an antipalindromic string with minimal possible cost;  There is a letter  such that . It's obvious that there is at most one such letter. Let's replace some occurences of  with other letters that are to be replaced. Then we will still have some occurences of  that need to be replaced. Let's take one letter from each pair such that both of letters in a pair are not equal to . Among these possibilities choose the required number of letters with minimum values of . Then we can replace remaining occurences of  with these letters. ", "solution": "#include <iterator>\n#include <map>\n#include <functional>\n#include <cstdio>\n#include <array>\n#include <utility>\n#include <vector>\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\n\n//alias\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\nusing RG = Range;\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nchar S[1234];\nint B[5678];\n\nint main()\n{\n    int N;\n    RD(N, S);\n    RDV(B, B + N);\n\n    int sum = 0;\n    for(int i: RG(N))\n        sum += B[i];\n\n    vector<int> cad[2];\n    for(int i: RG(N / 2))\n        cad[S[i] == S[N - 1 - i]].push_back(i);\n    \n    int k = cad[1].size();\n    \n    int alc[26] = {};\n    for(int idx: cad[1])\n        alc[S[idx] - 'a']++;\n    int check = -1;\n    for(int i: RG(26))\n        if(alc[i] > k / 2)\n            check = i;\n\n    for(int idx: cad[1])\n        sum -= min(B[idx], B[N - 1 - idx]);\n\n    if(check == -1)\n    {\n        WTL(sum);\n        return 0;\n    }\n \n    vector<int> cc;\n    for(int idx: cad[0])\n        if(S[idx] - 'a' != check && S[N - 1 - idx] - 'a' != check)\n            cc.push_back(min(B[idx], B[N - 1 - idx]));\n    sort(cc.begin(), cc.end());\n    for(int i: RG(2 * alc[check] - k))\n        sum -= cc[i];\n    WTL(sum);\n\n\n}\n\n\n\n\n", "interactive": false, "noSolution": false, "noTutorial": false}