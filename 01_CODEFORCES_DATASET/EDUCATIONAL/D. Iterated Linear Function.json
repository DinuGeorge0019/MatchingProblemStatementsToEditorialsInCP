{"link": "https://codeforces.com//contest/678/problem/D", "problemId": "62342", "shortId": "678D", "contest_number": "678", "name": "D. Iterated Linear Function", "statement": "Consider a linear function . Let's define  and  for . For the given integer values , ,  and  find the value of  modulo .", "input": "The only line contains four integers , ,  and  () \u2014 the parameters from the problem statement. Note that the given value  can be too large, so you should use -bit integer type to store it. In  you can use the  integer type and in  you can use  integer type.", "output": "Print the only integer  \u2014 the value  modulo .", "tutorial": "The problem can be solved using closed formula: it's need to calculate the sum of geometric progression. The formula can be calculated using binary exponentiation.\nI'll describe more complicated solution, but it's more general. If we have a set of variables and at each step all variables are recalculating from each other using linear function, we can use binary matrix exponentiation. There is only one variable  in our problem. The new variable  is calculating using formula . Consider the matrix  and the vector . Let's multiply  and . Easy to see that we will get the vector . So to make  iterations we should multiply  and   times. We can do that using binary matrix exponentiation, because matrix multiplication is associative.\nAs an exercise try to write down the matrix for the Fibonacci numbers and calculate the -th Fibonacci number in  time. The matrix and the vector is under the spoiler.\n", "solution": "int A, B, x;\nli n;\n\nbool read() {\n\treturn !!(cin >> A >> B >> n >> x);\n}\n\nconst int mod = 1000 * 1000 * 1000 + 7;\n\ninline int add(int a, int b) { return a + b >= mod ? a + b - mod : a + b; }\ninline int mul(int a, int b) { return int(a * 1ll * b % mod); }\ninline void inc(int& a, int b) { a = add(a, b); }\n\nvoid mul(int a[2][2], int b[2][2]) {\n\tstatic int res[2][2];\n\tforn(i, 2)\n\t\tforn(j, 2) {\n\t\t\tres[i][j] = 0;\n\t\t\tforn(k, 2) inc(res[i][j], mul(a[i][k], b[k][j]));\n\t\t}\n\tforn(i, 2) forn(j, 2) a[i][j] = res[i][j];\n}\n\nvoid bin_pow(int a[2][2], li b) {\n\tstatic int res[2][2];\n\tforn(i, 2) forn(j, 2) res[i][j] = i == j;\n\n\twhile (b) {\n\t\tif (b & 1) mul(res, a);\n\t\tmul(a, a);\n\t\tb >>= 1;\n\t}\n\n\tforn(i, 2) forn(j, 2) a[i][j] = res[i][j];\n}\n\nvoid solve() {\n\tint z[2][2] = {\n\t\t{ A, B },\n\t\t{ 0, 1 }\n\t};\n\tbin_pow(z, n);\n\tint result = add(mul(z[0][0], x), z[0][1]);\n\tcout << result << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}