{"link": "https://codeforces.com//contest/1359/problem/D", "problemId": "634675", "shortId": "1359D", "contest_number": "1359", "name": "D. Yet Another Yet Another Task", "statement": "Alice and Bob are playing yet another card game. This time the rules are the following. There are  cards lying in a row in front of them. The -th card has value . First, Alice chooses a non-empty consecutive segment of cards  (). After that Bob removes a single card  from that segment . The score of the game is the total value of the remaining cards on the segment . In particular, if Alice chooses a segment with just one element, then the score after Bob removes the only card is .Alice wants to make the score as big as possible. Bob takes such a card that the score is as small as possible.What segment should Alice choose so that the score is maximum possible? Output the maximum score.", "input": "The first line contains a single integer  () \u2014 the number of cards. The second line contains  integers  () \u2014 the values on the cards.", "output": "Print a single integer \u2014 the final score of the game.", "tutorial": "Alice wants to choose such a segment  that  is maximum possible. There is a well-known problem where you have to find a segment with maximum . That problem is solved with Kadane algorithm. Let's learn how to reduce our problem to that one.Notice that the values in the array are unusually small. Let's iterate over the maximum value on segment. Let  be the current value. If we make all  such that  equal to , then it will never be optimal to take them in a segment. Find the maximum sum subarray in that modified array and update the answer with its .Notice that you can ignore the fact if there is a value exactly equal to  on the maximum sum segment. If there isn't then you'll update the answer with a smaller value than the actual one. Let the actual maximum on the maximum sum segment be some . You can see that for any value between  and  the maximum sum segment will always be that chosen one. Thus, when you reach , you'll update the answer with the correct value.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> a(n);\n\tforn(i, n) scanf(\"%d\", &a[i]);\n\tlong long ans = 0;\n\tforn(mx, 31){\n\t\tlong long cur = 0;\n\t\tlong long best = 0;\n\t\tforn(i, n){\n\t\t\tint val = (a[i] > mx ? -INF : a[i]);\n\t\t\tcur += val;\n\t\t\tbest = min(best, cur);\n\t\t\tans = max(ans, (cur - best) - mx);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}