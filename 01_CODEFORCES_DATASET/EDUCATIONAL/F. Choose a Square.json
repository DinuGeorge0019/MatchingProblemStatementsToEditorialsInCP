{"link": "https://codeforces.com//contest/1221/problem/F", "problemId": "415612", "shortId": "1221F", "contest_number": "1221", "name": "F. Choose a Square", "statement": "Petya recently found a game \"Choose a Square\". In this game, there are  points numbered from  to  on an infinite field. The -th point has coordinates  and cost .You have to choose a square such that its sides are parallel to coordinate axes, the lower left and upper right corners belong to the line , and all corners have integer coordinates.The score you get is the sum of costs of the points covered by the selected square minus the length of the side of the square. Note that the length of the side can be zero.Petya asks you to calculate the maximum possible score in the game that can be achieved by placing exactly one square.", "input": "The first line of the input contains one integer  () \u2014 the number of points on the field. Each of the following  lines contains three integers  () \u2014 coordinates of the -th point and its cost, respectively.", "output": "In the first line print the maximum score Petya can achieve. In the second line print four integers  () separated by spaces \u2014 the coordinates of the lower left and upper right corners of the square which Petya has to select in order to achieve the maximum score.", "tutorial": "Notice that the square () () covers the point () if and only if .Using this fact, let's reformulate the problem the following way: we have to find the segment , such that the sum of the segments fully covered by it is maximal.Let's build a segment tree, the -th of its leaves stores  \u2014 the sum of the segments covered by the segment  . Initially, it's built for some  such that it is to the right of all segments. Other nodes store the maximum in them.Now let's iterate over the values \u200b\u200bof  in descending order. Let there be some segment starting in   with the cost . All the answers  for  won't change because they don't cover that new segment. And the values on the suffix from the position  () will increase by .The only thing left is to learn how to handle the subtraction of the length of the side. That term is  and the thing we are looking for is . Rewrite it in form  and you'll see that you can just subtract  from the value of the -th leaf of the segment tree at the beginning to get the correct result. Surely, you'll need to add that  after you ask the maximum of all the segtree to obtain the answer.You'll probably need to compress the coordinates \u2014 leave only such positions  that there is at least one  or . Implicit segtree might work but neither ML, nor TL are not friendly to it. Also be careful with the case with all points being negative.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\nconst int N = 1000 * 1000 + 13;\n\nint n;\npair<pt, int> a[N];\nvector<int> vals;\nvector<pt> ev[N];\npair<li, int> t[4 * N];\nli add[4 * N];\n\nvoid build(int v, int l, int r) {\n\tif (l == r) {\n\t\tt[v] = mp(-vals[l], l);\n\t\tadd[v] = 0;\n\t\treturn;\n\t}\n\tint m = (l + r) >> 1;\n\tbuild(v * 2 + 1, l, m);\n\tbuild(v * 2 + 2, m + 1, r);\n\tt[v] = max(t[v * 2 + 1], t[v * 2 + 2]);\n}\n\nvoid push(int v, int l, int r) {\n\tif (add[v] == 0) return;\n\tt[v].x += add[v];\n\tif (l != r) {\n\t\tadd[v * 2 + 1] += add[v];\n\t\tadd[v * 2 + 2] += add[v];\n\t}\n\tadd[v] = 0;\n}\n\nvoid upd(int v, int l, int r, int L, int R, int val) {\n\tpush(v, l, r);\n\tif (L > R) return;\n\tif (l == L && r == R) {\n\t\tadd[v] += val;\n\t\tpush(v, l, r);\n\t\treturn;\n\t}\n\tint m = (l + r) >> 1;\n\tupd(v * 2 + 1, l, m, L, min(m, R), val);\n\tupd(v * 2 + 2, m + 1, r, max(m + 1, L), R, val);\n\tt[v] = max(t[v * 2 + 1], t[v * 2 + 2]);\n}\n\npair<li, int> get(int v, int l, int r, int L, int R) {\n\tpush(v, l, r);\n\tif (L > R) return mp(-li(1e18), 0);\n\tif (l == L && r == R) return t[v];\n\tint m = (l + r) >> 1;\n\tauto r1 = get(v * 2 + 1, l, m, L, min(m, R));\n\tauto r2 = get(v * 2 + 2, m + 1, r, max(m + 1, L), R);\n\treturn max(r1, r2);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n) scanf(\"%d%d%d\", &a[i].x.x, &a[i].x.y, &a[i].y);\n\t\n\tforn(i, n) {\n\t\tvals.pb(a[i].x.x);\n\t\tvals.pb(a[i].x.y);\n\t}\n\t\n\tvals.pb(0);\n\tsort(all(vals));\n\tvals.pb(vals.back() + 1);\n\t\n\tvals.resize(unique(all(vals)) - vals.begin());\n\t\n\tforn(i, n) {\n\t\tint x = lower_bound(all(vals), a[i].x.x) - vals.begin();\n\t\tint y = lower_bound(all(vals), a[i].x.y) - vals.begin();\n\t\tev[min(x, y)].pb(mp(max(x, y), a[i].y));\n\t}\n\t\n\tn = sz(vals);\n\t\n\tbuild(0, 0, n - 1);\n\t\n\tli ans = -1;\n\tint ansl = -1, ansr = -1;\n\t\n\tfor (int i = sz(vals) - 1; i >= 0; i--) {\n\t\tfor (auto it : ev[i]) upd(0, 0, n - 1, it.x, n - 1, it.y);\n\t\tauto cur = get(0, 0, n - 1, i, n - 1);\n\t\tif (cur.x + vals[i] > ans) {\n\t\t\tans = cur.x + vals[i];\n\t\t\tansl = vals[i]; ansr = vals[cur.y]; \n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n%d %d %d %d\\n\", ans, ansl, ansl, ansr, ansr);\n\t\n}", "interactive": false, "noSolution": false, "noTutorial": false}