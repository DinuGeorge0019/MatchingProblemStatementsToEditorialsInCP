{"link": "https://codeforces.com//contest/1373/problem/D", "problemId": "657373", "shortId": "1373D", "contest_number": "1373", "name": "D. Maximum Sum on Even Positions", "statement": "You are given an array  consisting of  integers. Indices of the array start from zero (i.\u2009e. the first element is , the second one is , and so on).You can reverse  subarray (continuous subsegment) of this array. Recall that the subarray of  with borders  and  is .Your task is to reverse such a subarray that the sum of elements on  positions of the resulting array is  (i.\u2009e. the sum of elements  for integer  should be maximum possible).You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the length of . The second line of the test case contains  integers  (), where  is the -th element of . It is guaranteed that the sum of  does not exceed  ().", "output": "For each test case, print the answer on the separate line \u2014 the  possible sum of elements on  positions after reversing  subarray (continuous subsegment) of .", "tutorial": "Firstly, we can notice that the reverse of of odd length subarray does nothing because it doesn't change parities of indices of affected elements. Secondly, we can consider the reverse of the subarray of length  as  reverses of subarrays of length  (i.e. it doesn't matter for us how exactly the subarray will be reversed, we can only consider changing parities).Now, there are two ways: the first one is smart and the second one is dynamic programming.Consider the first way. Calculate the initial sum of elements on even positions . Then let's create two arrays  and . There  is  for all  from  to  and  is  for all  from  to . Elements of the first array deonte the profit if we reverse the subarray tarting from the even position, and elemnts of the second array denote the profit if we reverse the subarray starting from the odd position. Now we need to find the subarray with the maximum sum in both arrays (this will maximize overall profit) and add this value to  to get the answer. This problem can be solved easily: consider the sum of the subarray  as the difference of two prefix sums . To maximize it, consider all right borders and minimize the value . Iterate over all positions of the array, maintaining the current prefix sum  and the minimum prefix sum we meet . Update , then update  and then update the answer with the value .And the second way is author's solution and it is dynamic programming. This idea can be transformed to solve such problems in which you need to apply some function to some small number of subsegments (of course, under some constraints on functions). State of our dynamic programming is  where  and .  denotes the answer on the prefix of length  if we didn't start reversing the subarray,  denotes the answer if we started reversing the subarray but didn't end it and  denotes the answer if we ended reversing the subarray. Transitions are pretty easy:  ;  ;  . The value  is just a ternary if statement. If  is true then return  otherwise return .The answer is .Time complexity with both approaches is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tvector<vector<long long>> dp(n + 1, vector<long long>(3));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tdp[i + 1][0] = max(dp[i + 1][0], dp[i][0] + (i & 1 ? 0 : a[i]));\n\t\t\tif (i + 2 <= n) dp[i + 2][1] = max(dp[i + 2][1], max(dp[i][0], dp[i][1]) + (i & 1 ? a[i] : a[i + 1]));\n\t\t\tdp[i + 1][2] = max(dp[i + 1][2], max({dp[i][0], dp[i][1], dp[i][2]}) + (i & 1 ? 0 : a[i]));\n\t\t}\n\t\tcout << max({dp[n][0], dp[n][1], dp[n][2]}) << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}