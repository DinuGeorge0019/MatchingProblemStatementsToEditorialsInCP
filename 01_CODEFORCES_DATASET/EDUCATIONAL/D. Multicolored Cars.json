{"link": "https://codeforces.com//contest/818/problem/D", "problemId": "112248", "shortId": "818D", "contest_number": "818", "name": "D. Multicolored Cars", "statement": "Alice and Bob got very bored during a long car trip so they decided to play a game. From the window they can see cars of different colors running past them. Cars are going one after another.The game rules are like this. Firstly Alice chooses some color , then Bob chooses some color  (). After each car they update the number of cars of their chosen color that have run past them. Let's define this numbers after -th car  and .  If  for every  then the winner is Alice.  If  for every  then the winner is Bob.  Otherwise it's a draw. Bob knows all the colors of cars that they will encounter and order of their appearance. Alice have already chosen her color  and Bob now wants to choose such color  that he will win the game (draw is not a win). Help him find this color.If there are multiple solutions, print any of them. If there is no such color then print .", "input": "The first line contains two integer numbers  and  () \u2013 number of cars and the color chosen by Alice. The second line contains  integer numbers  () \u2014 colors of the cars that Alice and Bob will encounter in the order of their appearance.", "output": "Output such color  () that if Bob chooses it then he will win the game. If there are multiple solutions, print any of them. If there is no such color then print . It is guaranteed that if there exists any solution then there exists solution with ().", "tutorial": "Let's maintain the current availability of colors and the amounts of cars of each color. Firstly color  is never available.When car of some color  () goes, you check if the number of cars of color  past before this one isn't smaller than the number of cars of color . Only after that increment the amount by one. If it was less then set its availability to false.If car of color  goes then simply increment its amount.In the end iterate over all colors and check if it's both available and has higher or equal amount than the amount of cars of color .Okay, why this works? As all the amounts cannot decrease, color  will become not available at some moment when car of color  goes. And this will be encountered either when the new car of color  goes, or in the end of the sequence. Amount of cars of color  doesn't update between this periods. And if there was point when there became more cars of color  than of color  then this inequality will hold until the next moment we will check.Overall complexity: .", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 1000001\nint n , a , x , cnt[ N ];\nbool died[ N ];\nint main(){\n  cin >> n >> a;\n  set< pair<int,int> > S;\n  for( int i = 1 ; i < N ; i ++ )\n    S.insert( { 0 , i } );\n  while( n -- ){\n    cin >> x;\n    if( not died[ x ] ){\n      S.erase( S.find( { cnt[ x ] , x } ) );\n      cnt[ x ] ++;\n      S.insert( { cnt[ x ] , x } );\n    }\n    while( S.size() and S.begin()->first < cnt[ a ] ){\n      died[ S.begin()->second ] = true;\n      S.erase( S.begin() );\n    }\n  }\n  for( auto i : S )\n    if( i.second != a ){\n      cout << i.second << endl;\n      exit(0);\n    }\n  cout << -1 << endl;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}