{"link": "https://codeforces.com//contest/1418/problem/D", "problemId": "727426", "shortId": "1418D", "contest_number": "1418", "name": "D. Trash Problem", "statement": "Vova decided to clean his room. The room can be represented as the coordinate axis . There are  piles of trash in the room, coordinate of the -th pile is the integer . All piles have  coordinates.Let's define a  as the following process. The goal of this process is to collect  the piles in  different  coordinates. To achieve this goal, Vova can do several (possibly, zero) moves. During one move, he can choose some  and move  from  to  or  using his broom. Note that he can't choose how many piles he will move.Also, there are two types of queries:    \u2014 remove a pile of trash from the coordinate . It is guaranteed that there is a pile in the coordinate  at this moment.    \u2014 add a pile of trash to the coordinate . It is guaranteed that there is no pile in the coordinate  at this moment. Note that it is possible that there are zero piles of trash in the room at some moment.Vova wants to know the  number of moves he can spend if he wants to do a  before any queries. He also wants to know this number of moves after applying each query. Queries are applied in the given order. Note that the  doesn't actually happen and doesn't change the state of piles. It is only used to calculate the number of moves.For better understanding, please read the  section below to see an explanation for the first example.", "input": "The first line of the input contains two integers  and  () \u2014 the number of piles in the room before all queries and the number of queries, respectively. The second line of the input contains  distinct integers  (), where  is the coordinate of the -th pile. The next  lines describe queries. The -th query is described with two integers  and  (), where  is  if you need to remove a pile from the coordinate  and is  if you need to add a pile to the coordinate . It is guaranteed that for  there is such pile in the current set of piles and for  there is no such pile in the current set of piles.", "output": "Print  integers: the minimum number of moves Vova needs to do a  before the first query and after each of  queries.", "tutorial": "First, let's understand that if we choose some subset of points , then it does not matter to which point we move it (inside the segment [) because the minimum number of moves will always be the same and it is equal to .Okay, we need to split all points into two subsets and collect all points of the first subset in some point inside it and the same with the second subset. What can we notice? If we sort the points, it's always optimal to choose these subsets as segments. I.e. if the maximum point of the first subset is , the minimum point of the second subset is  and , we can swap them and decrease answers for both subsets.So, we need to cover all the points with two segments with the minimum total length. What is this length? It is .  is the maximum distance between two consecutive points (i.e. . So, we can solve the problem in  without queries. But how to deal with queries?Let's maintain the set which contains all points  and the multiset (set with repetitions) that maintains all gaps between two adjacent points. So, the answer is maximum in the set of points minus minimum in the set of points minus maximum in the multiset of lengths. How do we recalculate these sets between queries?If some point  is removed, let's find the maximum point less than  (let it be ) and the minimum point greater than  (let it be ) in the current set of points. Both these points can be found in a logarithmic time. Then we need to remove  with  from the multiset and add  to the multiset (and, of course, remove  from the set). If some point  is added, then we need to remove  from the multiset and add  with  to the multiset (and add  to the set).So, we can process every query in  time and the total time complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint get(const set<int> &x, const multiset<int> &len) {\n    if (len.empty()) return 0;\n    return *x.rbegin() - *x.begin() - *len.rbegin();\n}\n\nvoid add(int p, set<int> &x, multiset<int> &len) {\n    x.insert(p);\n    auto it = x.find(p);\n    int prv = -1, nxt = -1;\n    if (it != x.begin()) {\n        --it;\n        len.insert(p - *it);\n        prv = *it;\n        ++it;\n    }\n    ++it;\n    if (it != x.end()) {\n        len.insert(*it - p);\n        nxt = *it;\n    }\n    if (prv != -1 && nxt != -1) {\n        len.erase(len.find(nxt - prv));\n    }\n}\n\nvoid rem(int p, set<int> &x, multiset<int> &len) {\n    auto it = x.find(p);\n    int prv = -1, nxt = -1;\n    if (it != x.begin()) {\n        --it;\n        len.erase(len.find(p - *it));\n        prv = *it;\n        ++it;\n    }\n    ++it;\n    if (it != x.end()) {\n        len.erase(len.find(*it - p));\n        nxt = *it;\n    }\n    x.erase(p);\n    if (prv != -1 && nxt != -1) {\n        len.insert(nxt - prv);\n    }\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n//  freopen(\"output.txt\", \"w\", stdout);\n#endif\n    \n    int n, q;\n    cin >> n >> q;\n    set<int> x;\n    multiset<int> len;\n    for (int i = 0; i < n; ++i) {\n        int p;\n        cin >> p;\n        add(p, x, len);\n    }\n    \n    cout << get(x, len) << endl;\n    for (int i = 0; i < q; ++i) {\n        int t, p;\n        cin >> t >> p;\n        if (t == 0) {\n            rem(p, x, len);\n        } else {\n            add(p, x, len);\n        }\n        cout << get(x, len) << endl;\n    }\n    \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}