{"link": "https://codeforces.com//contest/888/problem/F", "problemId": "133219", "shortId": "888F", "contest_number": "888", "name": "F. Connecting Vertices", "statement": "There are  points marked on the plane. The points are situated in such a way that they form a regular polygon (marked points are its vertices, and they are numbered in counter-clockwise order). You can draw  segments, each connecting any two marked points, in such a way that all points have to be connected with each other (directly or indirectly).But there are some restrictions. Firstly, some pairs of points cannot be connected directly and have to be connected undirectly. Secondly, the segments you draw must not intersect in any point apart from the marked points (that is, if any two segments intersect and their intersection is not a marked point, then the picture you have drawn is invalid).How many ways are there to connect all vertices with  segments? Two ways are considered different iff there exist some pair of points such that a segment is drawn between them in the first way of connection, but it is not drawn between these points in the second one. Since the answer might be large, output it modulo .", "input": "The first line contains one number  () \u2014 the number of marked points. Then  lines follow, each containing  elements.  (-th element of line ) is equal to  iff you can connect points  and  directly (otherwise ). It is guaranteed that for any pair of points , and for any point .", "output": "Print the number of ways to connect points modulo .", "tutorial": "We can use dynamic programming to solve this problem, but we need to choose the states we maintain very carefully.One of the approaches might be:  \u2014 the number of ways to connect the vertices between  and  to vertices  or  if  and  are already connected (so there is no possibility to connect any vertex between  and  to some vertex outside).What  values should we access if we, for example, try to connect -th vertex to some vertex ? To get everything connected, we then have to connect vertices from interval  to these two, and vertices from  to ,  or  \u2014 and connections to  from the second interval are difficult to handle. We need to somehow get rid of them, and the solution is to . And vice versa, if we connect something to , then we choose the  index of vertex to be connected with  directly.But that's not all we have to handle. Suppose we have four vertices, and  is already connected to . One of the possibilities to finish it is to connect  to  and  to , but if we process current dynamic programming as it is, we will count it twice (if we choose to connect  to  firstly, or if we connect  to ). To get rid of this problem, we will use a flag that will denote whether we can connect anything to vertex , and if we choose to pick the first connection from , then we don't connect anything to .So the solution is: \u2014 the number of ways to connect the vertices from interval  to  and , and  denotes if we can connect anything to .How to calculate it:  If , then  (there is nothing left to connect);  Otherwise set ;  If , then iterate on vertex  we connect to  and add ;  Iterate on vertex  we connect to  and add . The answer is  (if vertices are -indexed). Vertex  is actually vertex , so don't forget to update the matrix  for it.", "solution": "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nvoid sleep( double sec = 1021 ){\n  clock_t s = clock();\n  while( clock() - s < CLOCKS_PER_SEC * sec );\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 514\nvoid build(){\n\n}\nint n , a[ N ][ N ];\nvoid init(){\n  n = getint();\n  for( int i = 0 ; i < n ; i ++ )\n    for( int j = 0 ; j < n ; j ++ )\n      a[ i ][ j ] = getint();\n}\nint dp[ N ][ N ][ 2 ];\nbool g[ N ][ N ][ 2 ];\nint dp2[ N ][ N ];\nbool g2[ N ][ N ];\nint DP( int l , int r , int bt );\nint DP2( int l , int r ){\n  l %= n; r %= n;\n  if( ( l + 1 ) % n == r ) return 1;\n  if( l == r ) return 1;\n  if( g2[ l ][ r ] ) return dp2[ l ][ r ];\n  int ret = 0;\n  ret = add( DP( r , l + 1 , 0 ) ,\n             DP( r + n - 1 , l , 0 ) );\n  for( int i = l + 1 ; ( i + 1 ) % n != r ; i ++ )\n    ret = add( ret , \n               mul( DP( i , l , 0 ) ,\n                    DP( r , i + 1 , 0 ) ) );\n  g2[ l ][ r ] = true;\n  return dp2[ l ][ r ] = ret;\n}\nint DP( int l , int r , int bt ){\n  l %= n; r %= n;\n  if( l == r ) return 1;\n  if( g[ l ][ r ][ bt ] ) return dp[ l ][ r ][ bt ];\n  int ret = 0;\n  if( bt == 0 ){\n    for( int i = r ; ; i ++ ){\n      if( i % n == l ) break;\n      if( !a[ l % n ][ i % n ] ) continue;\n      ret = add( ret ,\n                 mul( DP( i , r , 0 ) ,\n                      DP( l , i , 1 ) ) );\n    }\n  }else{\n    ret = DP( l + n - 1 , r , 0 );\n    for( int i = r + 1 ; ; i ++ ){\n      if( i % n == l ) break;\n      if( !a[ l % n ][ i % n ] ) continue;\n      ret = add( ret ,\n                 mul( DP( l , i , 1 ) ,\n                      DP2( r , i ) ) );\n    }\n  }\n  g[ l ][ r ][ bt ] = true;\n  //printf( \"%d %d %d : %d\\n\" , l , r , bt , ret );\n  return dp[ l ][ r ][ bt ] = ret;\n}\nvoid solve(){\n  printf( \"%d\\n\" , DP( 0 , 1 , 0 ) );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}