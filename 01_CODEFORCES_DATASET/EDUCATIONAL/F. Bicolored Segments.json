{"link": "https://codeforces.com//contest/1389/problem/F", "problemId": "686127", "shortId": "1389F", "contest_number": "1389", "name": "F. Bicolored Segments", "statement": "You are given  segments . Each segment has one of two colors: the -th segment's color is .Let's call a pair of segments  and   if the following two conditions are met:  ;  the segments  and  intersect, embed or touch, i.\u2009e. there exists an integer  such that  and . Calculate the maximum number of segments that can be selected from the given ones, so that there is no  pair among the selected ones.", "input": "The first line contains a single integer  ()\u00a0\u2014 number of segments. The next  lines contains three integers  ()\u00a0\u2014 description of the -th segment.", "output": "Print the maximum number of segments that can be selected, so that there is no  pair among the selected segments.", "tutorial": "There are two approaches to this problem. Most of the participants of the round got AC by implementing dynamic programming with data structures such as segment tree, but I will describe another solution which is much easier to code.Let's consider a graph where each vertex represents a segment, and two vertices are connected by an edge if the corresponding segments compose a bad pair.Since each bad pair is formed by two segments of different colors, the graph is bipartite. The problem asks us to find the maximum independent set, and in bipartite graphs, the size of the independent set is equal to , where  is the number of vertices, and  is the size of the maximum matching.The only thing that's left is finding the maximum matching. Let's use event processing approach to do it: for each segment, create two events \"the segment begins\" and \"the segment ends\". While processing the events, maintain the currently existing segments in two sets (grouped by their colors and sorted by the time they end). When a segment ends, let's try to match it with some segment of the opposite color \u2014 and it's quite obvious that we should choose a segment with the minimum  to form a pair.Overall, this solution runs in .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(), (a).end()\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000;\n\nint n;\nint l[N], r[N], t[N];\nset<pt> st[2];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n) scanf(\"%d%d%d\", &l[i], &r[i], &t[i]), --t[i];\n\t\n\tvector<pair<int, pt>> ev;\n\tforn(i, n) {\n\t\tev.pb(mp(l[i], mp(0, i)));\n\t\tev.pb(mp(r[i], mp(1, i)));\n\t}\n\n\tsort(all(ev));\n\t\n\tint ans = 0;\n\tfor (auto it : ev) {\n\t\tint i = it.y.y;\n\t\tif (it.y.x) {\n\t\t\tint j = t[i];\n\t\t\tint k = j ^ 1;\n\t\t\tif (st[j].count(mp(r[i], i)) && !st[k].empty()) {\n\t\t\t\t++ans;\n\t\t\t\tst[k].erase(st[k].begin());\n\t\t\t}\n\t\t\tif (st[j].count(mp(r[i], i))) st[t[i]].erase(mp(r[i], i));\n\t\t} else {\n\t\t\tst[t[i]].insert(mp(r[i], i));\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", n - ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}