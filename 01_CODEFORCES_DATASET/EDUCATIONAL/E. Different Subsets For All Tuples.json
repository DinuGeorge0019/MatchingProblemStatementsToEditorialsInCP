{"link": "https://codeforces.com//contest/660/problem/E", "problemId": "54417", "shortId": "660E", "contest_number": "660", "name": "E. Different Subsets For All Tuples", "statement": "For a sequence  of  integers between  and , inclusive, denote  as the number of distinct subsequences of  (including the empty subsequence).You are given two positive integers  and . Let  be the set of all sequences of length  consisting of numbers from  to . Compute the sum  over all  in  modulo .", "input": "The only line contains two integers  and  () \u2014 the number of elements in arrays and the upper bound for elements.", "output": "Print the only integer  \u2014 the desired sum modulo .", "tutorial": "Let's consider some subsequence with the length  (the empty subsequences we will count separately by adding the valye  at the end) and count the number of sequences that contains it. We should do that accurately to not count the same sequence multiple times. Let  be the fixed subsequence. In the original sequence before the element  can be some other elements, but none of them can be equal to  (because we want to count the subsequence exactly one time). So we have  variants for each of the elements before . Similarly between elements  and  can be other elements and we have  choices for each of them. And so on. After the element  can be some elements (suppose there are  such elements) with no additional constraints (so we have  choices for each of them). We fixed the number of elements at the end , so we should distribute  numbers between numbers before , between  and , \\ldots, between  and . Easy to see that we have  choices to do that (it's simply binomial coefficient with allowed repititions). The number of sequences  equals to . So the answer is . Easy to transform the last sum to the sum . Note the last inner sum can be calculating using the formula for parallel summing: . So the answer equals to . Also we can get the closed formula for the last sum to get logarithmic solution, but it is not required in the problem.\n", "solution": "int n, m;\n\nbool read() {\n\treturn !!(cin >> n >> m);\n}\n\nconst int N = 1200300;\n\nconst int mod = 1000 * 1000 * 1000 + 7;\n\nint gcd(int a, int b, int& x, int& y) {\n\tif (!a) {\n\t\tx = 0, y = 1;\n\t\treturn b;\n\t}\n\tint xx, yy, g = gcd(b % a, a, xx, yy);\n\tx = yy - b / a * xx;\n\ty = xx;\n\treturn g;\n}\n\ninline int inv(int a) {\n\tint x, y;\n\tassert(gcd(a, mod, x, y) == 1);\n\tx %= mod;\n\treturn x < 0 ? x + mod : x;\n}\n\ninline int mul(int a, int b) { return int(a * 1ll * b % mod); }\ninline int add(int a, int b) { return a + b >= mod ? a + b - mod : a + b; }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + mod : a - b; }\n\ninline void inc(int& a, int b) { a = add(a, b); }\n\nint fact[N], ifact[N];\n\ninline int C(int n, int k) {\n\tif (k < 0 || k > n) return 0;\n\treturn mul(fact[n], mul(ifact[k], ifact[n - k]));\n}\n\nint pm[N], pm1[N];\n\nvoid solve() {\n\tconst int N = n + 1;\n\n\tfact[0] = 1; fore(i, 1, N) fact[i] = mul(fact[i - 1], i);\n\tforn(i, N) ifact[i] = inv(fact[i]);\n\n\tpm[0] = 1; fore(i, 1, N) pm[i] = mul(pm[i - 1], m);\n\tpm1[0] = 1; fore(i, 1, N) pm1[i] = mul(pm1[i - 1], sub(m, 1));\n\n\tint ans = pm[n];\n\tfore(s, 1, n + 1) {\n\t\tint cur = 1;\n\t\tcur = mul(cur, pm[s]);\n\t\tcur = mul(cur, pm1[n - s]);\n\t\tcur = mul(cur, C(n, s - 1));\n\t\tinc(ans, cur);\n\t}\n\tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}