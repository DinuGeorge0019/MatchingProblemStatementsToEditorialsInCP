{"link": "https://codeforces.com//contest/1132/problem/C", "problemId": "307697", "shortId": "1132C", "contest_number": "1132", "name": "C. Painting the Fence", "statement": "You have a long fence which consists of  sections. Unfortunately, it is not painted, so you decided to hire  painters to paint it. -th painter will paint all sections  such that .Unfortunately, you are on a tight budget, so you may hire only  painters. Obviously, only painters you hire will do their work.You want to maximize the number of painted sections if you choose  painters optimally. A section is considered painted if at least one painter paints it.", "input": "The first line contains two integers  and  () \u2014 the number of sections and the number of painters availible for hire, respectively. Then  lines follow, each describing one of the painters: -th line contains two integers  and  ().", "output": "Print one integer \u2014 maximum number of painted sections if you hire  painters.", "tutorial": "Let  be the number of painters that are painting the -th section.Let's fix the first painter (denote his index as ) we won't take and decrease the numbers of array  in the range which he paints.Then we may new array , such that  is equal to  if and only if , and  otherwise. This array corresponds to segments that are painted by only one painter After that we build prefix sum array  on array : . This should be done in .Now, for each remaining painter we can count the number of sections that are painted only by him. For painter  it will be equal to . Let's denote it as .Finally, find an painter with the minimum value of , denote it as . The answer (if we choose painter  as one of two that won't be hired) will be equal to , where  is the number of elements greater than  in the array  after removing the painter . And, of course, we should do the same for all painters.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5043;\n\nint p1[N];\nint p2[N];\nint p3[N];\nint n, q;\nint l[N], r[N];\n\nint solve(int idx)\n{\n\tmemset(p1, 0, sizeof p1);\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tif(i == idx) continue;\n\t\tp1[l[i]]++;\n\t\tp1[r[i]]--;\n\t}\n\tmemset(p2, 0, sizeof p2);\n\tint c = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tc += p1[i];\n\t\tp2[i] = c;\n\t}\t\n\tmemset(p3, 0, sizeof p3);\n\tfor(int i = 0; i < n; i++)\n\t\tp3[i + 1] = p3[i] + (p2[i] == 1 ? 1 : 0);\n\tint ans = -int(1e9);\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tif(i == idx) continue;\n\t\tans = max(ans, p3[l[i]] - p3[r[i]]);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\tif(p2[i] > 0)\n\t\t\tans++;\n\treturn ans;\n}\n\nint main()\n{\n\tcin >> n >> q;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tcin >> l[i] >> r[i];\n\t\tl[i]--;\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < q; i++)\n\t\tans = max(ans, solve(i));\n\tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}