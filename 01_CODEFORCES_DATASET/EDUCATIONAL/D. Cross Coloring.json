{"link": "https://codeforces.com//contest/1644/problem/D", "problemId": "1306305", "shortId": "1644D", "contest_number": "1644", "name": "D. Cross Coloring", "statement": "There is a sheet of paper that can be represented with a grid of size :  rows and  columns of cells. All cells are colored in white initially. operations have been applied to the sheet. The -th of them can be described as follows:    \u00a0\u2014 choose one of  non-white colors and color the entire row  and the entire column  in it. The new color is applied to each cell, regardless of whether the cell was colored before the operation. The sheet after applying all  operations is called a coloring. Two colorings are different if there exists at least one cell that is colored in different colors.How many different colorings are there? Print the number modulo .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of the testcase contains four integers  and  ()\u00a0\u2014 the size of the sheet, the number of non-white colors and the number of operations. The -th of the following  lines contains a description of the -th operation\u00a0\u2014 two integers  and  (; )\u00a0\u2014 the row and the column the operation is applied to. The sum of  over all testcases doesn't exceed .", "output": "For each testcase, print a single integer\u00a0\u2014 the number of different colorings modulo .", "tutorial": "Let's take a look at a final coloring. Each cell has some color. There exist cells such that there were no operation in their row and their column. They are left white, and they don't affect the answer.All other cells are colored in one of  colors. For each cell  there is a query that has been the last one to color this cell (it covered row , column  or both of them). So all cells that have the same query as the last one will have the same color. Since the color for each query is chosen independently, the number of colorings will be  to the power of the number of queries that have at least one cell belong to them.How to determine if a query has at least one cell. This is true unless one of these things happen afterwards:   both its row and its column are recolored;  all rows are recolored;  all columns are recolored. So the solution is to process the queries backwards. Maintain the set of colored rows and colored columns. For each query, check the conditions. If none hold, multiply the answer by .Overall complexity:  or  per testcase.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\tforn(_, t){\n\t\tint n, m, k, q;\n\t\tscanf(\"%d%d%d%d\", &n, &m, &k, &q);\n\t\tvector<int> xs(q), ys(q);\n\t\tforn(i, q) scanf(\"%d%d\", &xs[i], &ys[i]);\n\t\tint ans = 1;\n\t\tset<int> ux, uy;\n\t\tfor (int i = q - 1; i >= 0; --i){\n\t\t\tbool fl = false;\n\t\t\tif (!ux.count(xs[i])){\n\t\t\t\tux.insert(xs[i]);\n\t\t\t\tfl = true;\n\t\t\t}\n\t\t\tif (!uy.count(ys[i])){\n\t\t\t\tuy.insert(ys[i]);\n\t\t\t\tfl = true;\n\t\t\t}\n\t\t\tif (fl){\n\t\t\t\tans = ans * 1ll * k % MOD;\n\t\t\t}\n\t\t\tif (int(ux.size()) == n || int(uy.size()) == m){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}