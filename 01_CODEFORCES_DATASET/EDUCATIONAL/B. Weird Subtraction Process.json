{"link": "https://codeforces.com//contest/946/problem/B", "problemId": "162807", "shortId": "946B", "contest_number": "946", "name": "B. Weird Subtraction Process", "statement": "You have two variables  and . Consider the following sequence of actions performed with these variables: If  or , end the process. Otherwise, go to step ; If , then set the value of  to , and repeat step . Otherwise, go to step ; If , then set the value of  to , and repeat step . Otherwise, end the process.Initially the values of  and  are positive integers, and so the process will be finite.You have to determine the values of  and  after the process ends.", "input": "The only line of the input contains two integers  and  ().  is the initial value of variable , and  is the initial value of variable .", "output": "Print two integers \u2014 the values of  and  after the end of the process.", "tutorial": "The answer can be calculated very easy by Euclid algorithm (which is described in the problem statement), but all subtractions will be replaced by taking by modulo.", "solution": "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\nvoid main() {\n    LL a,b;\n    R(a,b);\n    while ( 1 ) {\n        if ( a==0 || b==0 ) break;\n        if ( a>=2*b ) {\n            a%=2*b;\n            continue;\n        }\n        if ( b>=2*a ) {\n            b%=2*a;\n            continue;\n        }\n        break;\n    }\n    W(a,b);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n", "interactive": false, "noSolution": false, "noTutorial": false}