{"link": "https://codeforces.com//contest/1009/problem/G", "problemId": "197478", "shortId": "1009G", "contest_number": "1009", "name": "G. Allowed Letters", "statement": "Polycarp has just launched his new startup idea. The niche is pretty free and the key vector of development sounds really promising, so he easily found himself some investors ready to sponsor the company. However, he is yet to name the startup!Actually, Polycarp has already came up with the name but some improvement to it will never hurt. So now he wants to swap letters at some positions in it to obtain the better name. It isn't necessary for letters to be adjacent.In addition, each of the investors has chosen some index in the name and selected a set of letters that can go there. Indices chosen by different investors are pairwise distinct. If some indices aren't chosen by any investor then any letter can go there.Finally, Polycarp is sure that the smallest lexicographically name is the best. (Like why do you think Google decided to become Alphabet?)More formally, you are given a string consisting of lowercase Latin letters from \"\" to \"\". You can swap letters at any positions arbitrary number of times (zero swaps is also possible).What is the smallest lexicographically name you can obtain such that the letter at every position is among the allowed letters?If Polycarp can't produce any valid name then print \"\".", "input": "The first line is the string  () \u2014 the name Polycarp has came up with. The string consists only of lowercase Latin letters from \"\" to \"\". The second line contains a single integer  () \u2014 the number of investors. The -th of the next  lines contain an integer number  and a non-empty string of allowed characters for  (). Each string contains pairwise distinct letters from \"\" to \"\".  are pairwise distinct. If any position of the string doesn't appear in the investors demands then any letter can go in this position.", "output": "If Polycarp can't produce any valid name then print \"\". Otherwise print the smallest lexicographically name Polycarp can obtain by swapping letters in string  such that the letter at every position is among the allowed ones.", "tutorial": "The idea of solution is the following: we build the answer letter-by-letter; when choosing a character for some position, we try all possible characters and check that we can build the suffix after placing this character. But we need to somehow do this checking fast.As in many previous Educational Rounds, in this round some participants' solutions were much easier to write and understand than our own model solution.Let's build a flow network, where we have  vertices representing the characters of the string and  vertices representing the masks of characters. Add directed edges from the source to every node representing some character with capacity equal to the number of such characters in the original string; also add directed edges from every node representing some character to all vertices representing masks where this character is contained (with infinite capacity); and finally, add a directed edge from every \"mask\"-node to the sink with capacity equal to the number of positions where this mask of characters is allowed.If we find maximum flow in this network, we can check that the answer exists, and if it exists, build some answer. Now let's try to build optimal answer by somehow rebuilding the flow in the network.Suppose we are trying to place a character  to position containing mask . To check whether we can do it, we have to try rebuilding the flow in such a way that the edge from vertex corresponding to  to vertex corresponding to  has non-zero flow. If it is already non-zero, then we are done; otherwise we may cancel a unit of flow going through an edge from source to -vertex, then cancel a unit of flow going through an edge from -vertex to sink, decrease the capacity of these two edges by  and check that there exists an augmenting path. If it exists, then returning the capacities back and adding one unit of flow through the path  actually builds some answer where some character  is placed on some position with mask , so we may place it there; otherwise it's impossible.When we finally decided to place  on position , we have to decrease the flow through  and the capacities of edges  and .All this algorithm runs in , where  is the size of the alphabet.Hall's theorem allows us to check that we may build the suffix of the answer much easier.Each time we try to place some character, we need to iterate on all possible subsets of characters we still need to place and check that the number of positions that are suitable for at least one character in a subset is not less than the size of subset (just like in regular Hall's theorem). The key fact here is that if we have, for example,  characters  yet to place, then we don't need to check any subset containing exactly  or  characters , since the number of \"suitable\" positions for this subset won't become larger if we add all remaining characters  to a subset. So the subsets we have to consider are limited by the masks of possible characters, and there will be only  of them.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(a) ((int)(a).size())\n\nstruct edge\n{\n    int y;\n    int c;\n    int f;\n    edge() {};\n    edge(int y, int c, int f) : y(y), c(c), f(f) {};\n};\n\nconst int N = 100;\n\nvector<edge> e;\nvector<int> g[N];\nint edge_num[N][N];\nint char_vertex[6];\nint mask_vertex[N];\nint used[N];\nint cc = 0;\nint s, t;\n\nvoid add_edge(int x, int y, int c)\n{\n    edge_num[x][y] = sz(e);\n    g[x].push_back(sz(e));\n    e.push_back(edge(y, c, 0));\n    edge_num[y][x] = sz(e);\n    g[y].push_back(sz(e));\n    e.push_back(edge(x, 0, 0));\n}\n\nint rem(int num)\n{\n    return e[num].c - e[num].f;\n}\n\nint dfs(int x, int mx)\n{\n    if(x == t) return mx;\n    if(used[x] == cc) return 0;\n    used[x] = cc;\n    for(auto num : g[x])\n    {\n        if(rem(num))\n        {\n            int pushed = dfs(e[num].y, min(mx, rem(num)));\n            if(pushed)\n            {\n                e[num].f += pushed;\n                e[num ^ 1].f -= pushed;\n                return pushed;\n            }\n        }\n    }\n    return 0;\n}\n\nbool check(int ch, int mask)\n{\n    if((mask & (1 << ch)) == 0)\n        return false;\n    int cv = char_vertex[ch];\n    int mv = mask_vertex[mask];\n    int e1 = edge_num[s][cv];\n    int e2 = edge_num[mv][t];\n    if(e[e1].f == 0 || e[e2].f == 0)\n        return false;\n    e[e1].f--;\n    e[e1 ^ 1].f++;\n    vector<int> affected_edges;\n    affected_edges.push_back(e1);\n    for(auto x : g[cv])\n    {\n        if((x & 1) == 0 && e[x].f > 0)\n        {\n            affected_edges.push_back(x);\n            e[x].f--;\n            e[x ^ 1].f++;\n            int y = e[x].y;\n            for(auto x2 : g[y])\n            {\n                if((x2 & 1) == 0)\n                {\n                    affected_edges.push_back(x2);\n                    e[x2].f--;\n                    e[x2 ^ 1].f++;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    if(e[e2].f < e[e2].c)\n    {\n        e[e1].c--;\n        e[e2].c--;\n        return true;\n    }\n    affected_edges.push_back(e2);\n    e[e2].f--;\n    e[e2 ^ 1].f++;\n    for(auto x : g[mv])\n    {\n        if((x & 1) == 1 && e[x].f < 0)\n        {\n            affected_edges.push_back(x ^ 1);\n            e[x].f++;\n            e[x ^ 1].f--;\n            int y = e[x].y;\n            for(auto x2 : g[y])\n            {\n                if((x2 & 1) == 1)\n                {\n                    affected_edges.push_back(x2 ^ 1);\n                    e[x2].f++;\n                    e[x2 ^ 1].f--;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    cc++;\n    e[e1].c--;\n    e[e2].c--;\n    if(dfs(s, 1))\n        return true;\n    else\n    {\n        e[e1].c++;\n        e[e2].c++;\n        for(auto x : affected_edges)\n        {\n            e[x].f++;\n            e[x ^ 1].f--;\n        }\n        return false;\n    }\n}\n\nchar buf[100043];\nstring allowed[100043];\nint allowed_mask[100043];\n\nint main()\n{\n    s = 70;\n    t = 71;\n    scanf(\"%s\", buf);\n    string z = buf;\n    int n = sz(z);\n    int m;\n    scanf(\"%d\", &m);\n    for(int i = 0; i < n; i++)\n    {\n        allowed[i] = \"abcdef\";\n        allowed_mask[i] = 63;\n    }\n    for(int i = 0; i < m; i++)\n    {\n        int idx;\n        scanf(\"%d\", &idx);\n        --idx;\n        scanf(\"%s\", buf);\n        allowed[idx] = buf;\n        allowed_mask[idx] = 0;\n        for(auto x : allowed[idx])\n        {\n            allowed_mask[idx] |= (1 << (x - 'a'));\n        }\n    }\n    for(int i = 0; i < 6; i++)\n        char_vertex[i] = i;\n    for(int i = 0; i < (1 << 6); i++)\n        mask_vertex[i] = i + 6;\n    for(int i = 0; i < (1 << 6); i++)\n        for(int j = 0; j < 6; j++)\n            if(i & (1 << j))\n                add_edge(char_vertex[j], mask_vertex[i], 100000);\n    for(int i = 0; i < 6; i++)\n    {\n        int cnt = 0;\n        for(int j = 0; j < n; j++)\n            if(z[j] == 'a' + i)\n                cnt++;\n        add_edge(s, char_vertex[i], cnt);\n    }\n    for(int i = 0; i < (1 << 6); i++)\n    {\n        int cnt = 0;\n        for(int j = 0; j < n; j++)\n            if(allowed_mask[j] == i)\n                cnt++;\n        add_edge(mask_vertex[i], t, cnt);\n    }\n    int flow = 0;\n    while(true)\n    {\n        cc++;\n        int p = dfs(s, 100000);\n        if(p)\n            flow += p;\n        else\n            break;\n    }\n    if(flow != n)\n    {\n        puts(\"Impossible\");\n        return 0;\n    }\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < 6; j++)\n        {\n            if(check(j, allowed_mask[i]))\n            {\n                printf(\"%c\", j + 'a');\n                break;\n            }\n        }\n    puts(\"\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}