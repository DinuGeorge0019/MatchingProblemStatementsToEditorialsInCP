{"link": "https://codeforces.com//contest/1380/problem/D", "problemId": "670986", "shortId": "1380D", "contest_number": "1380", "name": "D. Berserk And Fireball", "statement": "There are  warriors in a row. The power of the -th warrior is . All powers are pairwise distinct.You have two types of spells which you may cast:   Fireball: you spend  mana and destroy   consecutive warriors;  Berserk: you spend  mana, choose two consecutive warriors, and the warrior with greater power destroys the warrior with smaller power. For example, let the powers of warriors be , and . If you cast Berserk on warriors with powers  and , the resulting sequence of powers becomes . Then, for example, if you cast Fireball on consecutive warriors with powers , the resulting sequence of powers becomes .You want to turn the current sequence of warriors powers  into . Calculate the minimum amount of mana you need to spend on it.", "input": "The first line contains two integers  and  ()\u00a0\u2014 the length of sequence  and the length of sequence  respectively. The second line contains three integers  ()\u00a0\u2014 the cost of fireball, the range of fireball and the cost of berserk respectively. The third line contains  integers  (). It is guaranteed that all integers  are pairwise distinct. The fourth line contains  integers  (). It is guaranteed that all integers  are pairwise distinct.", "output": "Print the minimum amount of mana for turning the sequnce  into , or  if it is impossible.", "tutorial": "The first thing we need to do is to find the occurrences of  in the sequence  \u2014 these are the monsters that have to remain. Since both spells (Fireball and Berserk) affect consecutive monsters, we should treat each subsegment of monsters we have to delete separately.Consider a segment with  monsters we have to delete such that the last monster before it has power , the first monster after the segment has power , and the strongest monster on the segment has power .If , then we have to use Berserk at least  times. Let's make the strongest monster on segment kill some other monster. If , then the strongest monster should also be killed by one of the monsters bounding the segment, so if  and , there is no solution.Okay, now the number of monsters is divisible by . If it is more profitable to use Fireball, we use the required number of Fireballs to kill all of them. Otherwise, we have to kill the maximum possible number of monsters with Berserk and finish the remaining ones with Fireball. If  or , then one of the monsters just outside the segment can kill all the monsters inside the segment; otherwise, the strongest monster should kill adjacent monsters until exactly  remain, and those  monsters are finished with a single Fireball.Now we know what we need to consider when processing a single segment; all that's left is to sum the minimum required mana over all such segments. Since the total length of these segments is at most  and we can process each segment in linear time, we have a solution with complexity .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, m;\nlong long x, k, y;\nint a[N];\nint b[N];\n\nbool upd(int l, int r, long long &res) {\n    if (l > r) return true;\n    bool canDel = false;\n    int mx = *max_element(a + l, a + r + 1);\n    int len = r - l + 1;\n    if (l - 1 >= 0 && a[l - 1] > mx) canDel = true;\n    if (r + 1 < n && a[r + 1] > mx) canDel = true;\n    if (len < k && !canDel) return false;\n    \n    int need = len % k;\n    res += need * y;\n    len -= need;\n    \n    if (y * k >= x) {\n        res += len / k * x;\n    } else if(canDel) {\n        res += len * y;\n    } else {\n        res += (len - k) * y + x;\n    }\n    \n    return true;\n}\n\nint main(){\n    scanf(\"%d %d\", &n, &m);\n    scanf(\"%lld %lld %lld\", &x, &k, &y);\n    for (int i = 0; i < n; ++i) scanf(\"%d\", a + i);\n    for (int i = 0; i < m; ++i) scanf(\"%d\", b + i);\n    \n    long long res = 0;\n    int lst = -1, posa = 0, posb = 0;\n    while (posb < m) {\n        while(posa < n && a[posa] != b[posb]) ++posa;\n        if (posa == n) {\n            puts(\"-1\");\n            return 0;\n        }\n        \n        if (!upd(lst + 1, posa - 1, res)) {\n            puts(\"-1\");\n            return 0;\n        }\n        \n        lst = posa;\n        ++posb;\n    }\n    \n    if (!upd(lst + 1, n - 1, res)) {\n        puts(\"-1\");\n        return 0;\n    }\n    \n    printf(\"%lld\\n\", res);\n    \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}