{"link": "https://codeforces.com//contest/1766/problem/C", "problemId": "1690148", "shortId": "1766C", "contest_number": "1766", "name": "C. Hamiltonian Wall", "statement": "Sir Monocarp Hamilton is planning to paint his wall. The wall can be represented as a grid, consisting of  rows and  columns. Initially, the wall is completely white.Monocarp wants to paint a black picture on the wall. In particular, he wants cell  (the -th cell in the -th row) to be colored black, if  '', and to be left white, if  ''. Additionally, he wants each column to have at least one black cell, so, for each , the following constraint is satisfied: ,  or both of them will be equal to ''.In order for the picture to turn out smooth, Monocarp wants to place down a paint brush in some cell  and move it along the path  so that:   for each ,  and  share a common side;  all black cells appear in the path ;  white cells don't appear in the path. Determine if Monocarp can paint the wall.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains a single integer  ()\u00a0\u2014 the number of columns in the wall. The -th of the next two lines contains a string , consisting of  characters, where each character is either '' or ''.  is '', if the cell  should be colored black, and '', if the cell  should be left white.  The sum of  over all testcases doesn't exceed .", "output": "For each testcase, print \"\" if Monocarp can paint a wall. Otherwise, print \"\".", "tutorial": "Why is there a constraint of each column having at least one black cell? Does the problem change a lot if there were white columns? Well, if such a column was inbetween some black cells, then the answer would be \"\". If it was on the side of the grid, you could remove it and proceed to solve without it. So, that doesn't really change the problem other than removing some casework.Let's try to fix a start. Find a column that has only one black cell in it. If there are no such columns, the answer is immediately \"\". Otherwise, the path will always go through it in known directions: to the left and to the right (if both of them exist). Let's solve the problem separately for the left part of the path and for the right one\u00a0\u2014 find a path that starts to the left of it and covers everything to the left and the same for the right part.Consider the right part.If the next column also has one black cell, then we can determine where to go uniquely. If this cell is on the opposite row, then the answer is \"\". Otherwise, go there and proceed further.Let it have two black cells now. Find the entire two black row rectangle of maximum size that starts there. If there's nothing after it, you can easily traverse it any way you like. Otherwise, you have to traverse it in such a way that you end up in its last column, then go to the right from there. Turns out, there's only one way to achieve that. Go up/down to another row, go right, up/down to another row, right and so on. Now you just have to check if you end up in the correct row.Thus, you can simulate the path to the left and to the right and check if you never get stuck.Overall comlexity:  per testcase.", "solution": "for _ in range(int(input())):\n\tn = int(input())\n\ts = [input() for i in range(2)]\n\tpos = -1\n\tfor i in range(n):\n\t\tif s[0][i] != s[1][i]:\n\t\t\tpos = i\n\tif pos == -1:\n\t\tprint(\"YES\")\n\t\tcontinue\n\tok = True\n\tcur = 0 if s[0][pos] == 'B' else 1\n\tfor i in range(pos + 1, n):\n\t\tif s[cur][i] == 'W':\n\t\t\tok = False\n\t\tif s[cur ^ 1][i] == 'B':\n\t\t\tcur ^= 1\n\tcur = 0 if s[0][pos] == 'B' else 1\n\tfor i in range(pos - 1, -1, -1):\n\t\tif s[cur][i] == 'W':\n\t\t\tok = False\n\t\tif s[cur ^ 1][i] == 'B':\n\t\t\tcur ^= 1\n\tprint(\"YES\" if ok else \"NO\")", "interactive": false, "noSolution": false, "noTutorial": false}