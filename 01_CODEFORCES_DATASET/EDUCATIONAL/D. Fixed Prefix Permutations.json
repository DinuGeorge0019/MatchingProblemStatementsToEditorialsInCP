{"link": "https://codeforces.com//contest/1792/problem/D", "problemId": "1749562", "shortId": "1792D", "contest_number": "1792", "name": "D. Fixed Prefix Permutations", "statement": "You are given  permutations , each of length . Recall that a permutation of length  is a sequence of   integers from  to .Let the beauty of a permutation  be the largest  such that . If , then the beauty is .The product of two permutations  is a permutation  such that .For each  from  to , print the largest beauty of a permutation  over all  from  to  (possibly, ).", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains two integers  and  (; )\u00a0\u2014 the number of permutations and the length of each permutation. The -th of the next  lines contains a permutation \u00a0\u2014  distinct integers from  to . The sum of  doesn't exceed  over all testcases.", "output": "For each testcase, print  integers. The -th value should be equal to the largest beauty of a permutation  over all  ().", "tutorial": "Let's try to solve for one of the given permutations. Let it be some . How to make the answer for it at least ? Well, we have to find another permutation  such that . How about at least ? Well, the same: .Push  to the right side of the equation. . Now think. What does it actually mean for some permutation to be multiplied by ? It stays the same. So the first  elements of  will be equal to the first  elements of .Thus, you have to find a permumtation such that its inverse has the longest common prefix with . This can be done in multiple ways. For example, you can store all inverses in a trie and traverse it with  until you reach a dead end. Or simply push all prefixes of each inverse into a set and iterate over . Alternatively, you can just sort inverses and do lower_bound for  in this list\u00a0\u2014 the permutation with longest common prefix will be either the result or the one before it.Overall complexity:  per testcase.", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define forn(i, n) for(int i = 0; i < int(n); i++) \n\nint get(const vector<int> &a, const vector<int> &b){\n\tint res = 0;\n\twhile (res < int(a.size()) && a[res] == b[res])\n\t\t++res;\n\treturn res;\n}\n\nint main(){\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--){\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tvector<vector<int>> a(n, vector<int>(m));\n\t\tforn(i, n) forn(j, m){\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\t--a[i][j];\n\t\t}\n\t\tvector<vector<int>> b(n, vector<int>(m));\n\t\tforn(i, n) forn(j, m) b[i][a[i][j]] = j;\n\t\tsort(b.begin(), b.end());\n\t\tforn(i, n){\n\t\t\tint j = lower_bound(b.begin(), b.end(), a[i]) - b.begin();\n\t\t\tint ans = 0;\n\t\t\tif (j > 0) ans = max(ans, get(a[i], b[j - 1]));\n\t\t\tif (j < n) ans = max(ans, get(a[i], b[j]));\n\t\t\tprintf(\"%d \", ans);\n\t\t}\n\t\tputs(\"\");\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}