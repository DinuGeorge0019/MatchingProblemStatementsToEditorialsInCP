{"link": "https://codeforces.com//contest/1469/problem/D", "problemId": "847529", "shortId": "1469D", "contest_number": "1469", "name": "D. Ceil Divisions", "statement": "You have an array  where .In one step, you can choose two indices  and  () and set  (ceiling function).Your goal is to make array  consist of  ones and  two in no more than  steps. Note that you don't have to minimize the number of steps.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first and only line of each test case contains the single integer  ()\u00a0\u2014 the length of array . It's guaranteed that the sum of  over test cases doesn't exceed .", "output": "For each test case, print the sequence of operations that will make  as  ones and  two in the following format: firstly, print one integer  ()\u00a0\u2014 the number of operations; next print  pairs of integers  and  (; ) ( may be greater or less than )\u00a0\u2014 the indices of the corresponding operation. It can be proven that for the given constraints it's always possible to find a correct sequence of operations.", "tutorial": "There are many different approaches. We will describe a pretty optimal one.Let's solve the problem recursively. Let's say we need to process segment . If , we don't need to do anything. Otherwise, . Let's find the minimum  such that .The chosen  is convenient because it allows making  equal to  in two divisions (and it's the minimum number of divisions to get rid of ). Now we can, firstly, make all  equal to  in one step (by division on ) and then make  equal to  with two divisions on .As a result, we've spent  operations and can solve our task recursively for . In total, we will spend  and since the segments are like , ,... There will be at most  segments and  operations are enough for .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9;\n\nint n;\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\treturn true;\n}\n\nvoid calc(int n, vector<pt> &ans) {\n\tif (n == 2)\n\t\treturn;\n\t\n\tint y = max(1, (int)sqrt(n) - 1);\n\twhile (y < (n + y - 1) / y)\n\t\ty++;\n\t\n\tfore (pos, y + 1, n)\n\t\tans.emplace_back(pos, n);\n\tans.emplace_back(n, y);\n\tans.emplace_back(n, y);\n\t\n\tcalc(y, ans);\n}\n\ninline void solve() {\n\tvector<pt> ans;\n\tcalc(n, ans);\n\t\n\tcout << sz(ans) << endl;\n\tfor(auto p : ans)\n\t\tcout << p.first << \" \" << p.second << '\\n';\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tint tc; cin >> tc;\n\twhile(tc--) {\n\t\tread();\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}