{"link": "https://codeforces.com//contest/1221/problem/G", "problemId": "415613", "shortId": "1221G", "contest_number": "1221", "name": "G. Graph And Numbers", "statement": "You are given an undirected graph with  vertices and  edges. You have to write a number on each vertex of this graph, each number should be either  or . After that, you write a number on each edge equal to the sum of numbers on vertices incident to that edge.You have to choose the numbers you will write on the vertices so that there is at least one edge with  written on it, at least one edge with  and at least one edge with . How many ways are there to do it? Two ways to choose numbers are different if there exists at least one vertex which has different numbers written on it in these two ways.", "input": "The first line contains two integers  and  (, ) \u2014 the number of vertices and the number of edges, respectively. Then  lines follow, each line contains two numbers  and  (, ) \u2014 the endpoints of the -th edge. It is guaranteed that each pair of vertices is connected by at most one edge.", "output": "Print one integer \u2014 the number of ways to write numbers on all vertices so that there exists at least one edge with  written on it, at least one edge with  and at least one edge with .", "tutorial": "Let  be the number of ways to paint the graph so that all numbers on edges belong to the set . Using inclusion-exclusion we may get that the answer is .Okay, let's analyze everything separatedly.   is , because every number is allowed;   will be analyzed later;   is , where  is the number of connected components \u2014 in each component we have to use the same number;   is , where  is the number of isolated vertices \u2014 every non-isolated vertex should have number  on it, and all isolated vertices may have any numbers;  , since these cases are symmetric;   is the number of bipartite colorings of the graph. It is  if the graph contains an odd cycle, or  if it is bipartite;  , since these cases are symmetric;   is  if there are no edges in the graph, otherwise it is . So, the only thing left to consider is . Actually, it is easier to calculate  \u2014 it is the number of independent sets of this graph. This problem is NP-complete, but when , we may apply meet-in-the-middle technique as follows:  divide all vertices into two sets  and  of roughly equal size;  for , find all its independent subsets, and for each such subset, find which vertices from  can be added to it without breaking its independency;  for each subset of , find the number of independent subsets of  such that no vertex from chosen subset of  is adjacent to any vertex from chosen subset of  (you may use subset DP and OR-convolution here);  find all independent subsets of , and for every such subset, add the number of subsets of  that can be merged with it so the resulting set is independent. The most time-consuming part is counting all independent sets, so the time complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 40;\nconst int M = 20;\n\nlong long incident_mask[N];\nvector<int> g[N];\nint n, m;\nlong long ans = 0;\nlong long cntmask[1 << M];\n\nlong long binpow(long long x, long long y)\n{\n\tlong long z = 1;\n\twhile(y > 0)\n\t{\n\t\tif(y % 2 == 1) z *= x;\n\t\tx *= x;\n\t\ty /= 2;\n\t}\n\treturn z;\n}\n\nint used[N];\n\nvoid dfs(int x, int c)\n{\n\tif(used[x])\n\t\treturn;\n\tused[x] = c;\n\tfor(auto y : g[x])\n\t\tdfs(y, 3 - c);\n}\n\nlong long countIsolated()\n{\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tif(g[i].empty())\n\t\t\tans++;\n\treturn ans;\n}\n\nlong long countComponents()\n{\n\tmemset(used, 0, sizeof used);\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tif(!used[i])\n\t\t{\n\t\t\tans++;\n\t\t\tdfs(i, 1);\n\t\t}\n\treturn ans;\n}\n\nbool bipartite()\n{\n\tmemset(used, 0, sizeof used);\n\tfor(int i = 0; i < n; i++)\n\t\tif(!used[i])\n\t\t\tdfs(i, 1);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(auto j : g[i])\n\t\t\tif(used[i] == used[j])\n\t\t\t\treturn false;\n\treturn true;\n}\n\nlong long countIndependentSets()\n{\n\tint m1 = min(n, 20);\n\tint m2 = n - m1;\n\t//cerr << m1 << \" \" << m2 << endl;\n\tmemset(cntmask, 0, sizeof cntmask);\n\tfor(int i = 0; i < (1 << m1); i++)\n\t{\n\t\tlong long curmask = 0;\n\t\tbool good = true;\n\t\tfor(int j = 0; j < m1; j++)\n\t\t{\n\t\t\tif((i & (1 << j)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif(curmask & (1 << j))\n\t\t\t\tgood = false;\n\t\t\tcurmask |= ((1 << j) | incident_mask[j]);\n\t\t}\n\t\tif(good)\n\t\t{\n\t\t\tcntmask[curmask >> m1]++;\n\t\t}\n\t}\t\n\tfor(int i = 0; i < m2; i++)\n\t\tfor(int j = 0; j < (1 << m2); j++)\n\t\t\tif(j & (1 << i))\n\t\t\t\tcntmask[j] += cntmask[j ^ (1 << i)];\n\tlong long ans = 0;\n\tfor(int i = 0; i < (1 << m2); i++)\n\t{\n\t\tlong long curmask = 0;\n\t\tbool good = true;\n\t\tfor(int j = m1; j < n; j++)\n\t\t{\n\t\t\tif((i & (1 << (j - m1))) == 0)\n\t\t\t\tcontinue;\n\t\t\tif(curmask & (1ll << j))\n\t\t\t\tgood = false;\n\t\t\tcurmask |= (1ll << j) | incident_mask[j];\n\t\t}\n\t\tif(good)\n\t\t{\n\t\t\t//cerr << i << endl;\n\t\t\tans += cntmask[(i ^ ((1 << m2) - 1))];\n\t\t}\n\t}\n\treturn ans;\n}\n\nlong long calc(int mask)\n{\n\tif(mask == 0)\n\t\treturn binpow(2, n);\n\tif(mask == 1 || mask == 4)\n\t\treturn countIndependentSets();\n\tif(mask == 2)\n\t\treturn binpow(2, countComponents());\n\tif(mask == 3 || mask == 6)\n\t\treturn binpow(2, countIsolated());\n\tif(mask == 5)\n\t\treturn (bipartite() ? binpow(2, countComponents()) : 0);\n\tif(mask == 7)\n\t\treturn (m == 0 ? binpow(2, n) : 0);\n\treturn 0;\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t\tincident_mask[x] ^= (1ll << y);\n\t\tincident_mask[y] ^= (1ll << x);\n\t}\n\tfor(int i = 0; i < 8; i++)\n\t{\n\t\t//cerr << i << \" \" << calc(i) << endl;\n\t\tif(__builtin_popcount(i) % 2 == 0)\n\t\t\tans += calc(i);\n\t\telse\n\t\t\tans -= calc(i);\n\t}\n\tcout << ans << endl;\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}