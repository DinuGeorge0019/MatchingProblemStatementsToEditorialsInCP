{"link": "https://codeforces.com//contest/1499/problem/D", "problemId": "928252", "shortId": "1499D", "contest_number": "1499", "name": "D. The Number of Pairs", "statement": "You are given three positive (greater than zero) integers ,  and . You have to find the number of pairs of positive integers  such that equality  holds. Where  is the least common multiple of  and  and  is the greatest common divisor of  and .", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case consists of one line containing three integer ,  and  ().", "output": "For each test case, print one integer \u2014 the number of pairs () such that the above equality holds.", "tutorial": "Let's represent  as  and  as , where  and . By definition , so we can represent  as . Now we can rewrite the equation from the statement as follows: . Since the left-hand side is divisible by , the right-hand side should also be divisible. So we can iterate over  as divisors of . If the right-hand side of  is not divisible by  then we can skip such .  (let's denote as ). If  has some prime divisor  then exactly one of  and  should be divisible by  because  ( and  have no common divisors). So there are  pairs of  and  for current value of .We can precalculate the minimum prime divisor for each number up to  (the maximum value of  that you may need) in  using Eratosthenes sieve. Now we can solve the problem in  for each testcase, but that's not fast enough. To speed up this approach, we can precalculate the number of prime divisors for each number up to . Let's denote  as the minimum prime divisor of  and  as the number of prime divisors of . Then  plus  if . Now, to solve the problem, we only need to iterate over the divisors of , so the time complexity is  per testcase.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e7 + 13;\n\nint main() {\n  vector<int> mind(N, -1), val(N);\n  mind[1] = 1;\n  for (int i = 2; i < N; ++i) if (mind[i] == -1)\n    for (int j = i; j < N; j += i) if (mind[j] == -1)\n      mind[j] = i;\n  for (int i = 2; i < N; ++i) {\n    int j = i / mind[i];\n    val[i] = val[j] + (mind[i] != mind[j]);\n  }\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int c, d, x;\n    scanf(\"%d%d%d\", &c, &d, &x);\n    int ans = 0;\n    for (int i = 1; i * i <= x; ++i) {\n      if (x % i != 0) continue;\n      int k1 = x / i + d; \n      if (k1 % c == 0) ans += 1 << val[k1 / c];\n      if (i * i == x) continue;\n      int k2 = i + d;\n      if (k2 % c == 0) ans += 1 << val[k2 / c]; \n    }\n    printf(\"%d\\n\", ans);\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}