{"link": "https://codeforces.com//contest/1709/problem/E", "problemId": "1473248", "shortId": "1709E", "contest_number": "1709", "name": "E. XOR Tree", "statement": "You are given a tree consisting of  vertices. A number is written on each vertex; the number on vertex  is equal to .Recall that a simple path is a path that visits each vertex at most once. Let the  of the path be the bitwise XOR of the values written on vertices it consists of. Let's say that a tree is  if no simple path has weight .You can apply the following operation any number of times (possibly, zero): select a vertex of the tree and replace the value written on it with an arbitrary positive integer. What is the minimum number of times you have to apply this operation in order to make the tree ?", "input": "The first line contains one integer  ()\u00a0\u2014 the number of vertices. The second line contains  integers , , ...,  ()\u00a0\u2014 the numbers written on vertices. Then  lines follow, each containing two integers  and  () denoting an edge connecting vertex  with vertex . It is guaranteed that these edges form a tree.", "output": "Print a single integer\u00a0\u2014 the minimum number of times you have to apply the operation in order to make the tree .", "tutorial": "To begin with, we note that there are no restrictions on the values that can be written on the vertices, so we can use numbers of the form  for the -th replacement. Then, if we replaced the value of a vertex, then no path passing through this vertex has weight .Let's root the tree at the vertex number . We can use a greedy approach: consider some vertex  such that it is the LCA for two vertices  and , the path between which has XOR equal to . Among such vertices , pick one with the maximum distance from the root. We need to change at least one vertex on the path . It turns out that changing the vertex  is always no worse than changing any other vertex  on this path, because all the remaining bad paths that pass through the vertex  also pass through the vertex  (that's why we have chosen the deepest LCA). This means that in order to solve the problem, it is necessary to quickly find the deepest LCA of some bad path.For the convenience of solving the problem, let's denote the XOR on the path  as , where  is XOR on the path from the root to the vertex . For all vertices , let's maintain a set of values , such that  belongs to the subtree of . Let's use the small-to-large method to obtain such sets. Also, during the union of sets, we can check if there is a bad path in this subtree, i.\u2009e. if two values in the sets we merge have the same XOR as the value written on the current vertex (because that's when the XOR on path is ). If such a path exists, then we have to change the value of the vertex  and mark that the vertices of this subtree cannot be the ends of a bad path anymore \u2014 that means we just clear the set instead of pulling it up the tree.This solution works in .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\nint n;\nint a[N], b[N];\nvector<int> g[N];\nset<int> vals[N];\n\nvoid init(int v, int p) {\n  b[v] = a[v];\n  if (p != -1) b[v] ^= b[p];\n  for (int u : g[v]) if (u != p)\n    init(u, v);\n}\n\nint ans;\n\nvoid calc(int v, int p) {\n  bool bad = false;\n  vals[v].insert(b[v]);\n  for (int u : g[v]) if (u != p) {\n    calc(u, v);\n    if (vals[v].size() < vals[u].size()) vals[v].swap(vals[u]);\n    for (int x : vals[u]) bad |= vals[v].count(x ^ a[v]);\n    for (int x : vals[u]) vals[v].insert(x);\n    vals[u].clear();\n  }\n  if (bad) {\n    ans += 1;\n    vals[v].clear();\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> n;\n  for (int i = 0; i < n; ++i) cin >> a[i];\n  for (int i = 0; i < n - 1; ++i) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  init(0, -1);\n  calc(0, -1);\n  cout << ans << '\\n';\n} ", "interactive": false, "noSolution": false, "noTutorial": false}