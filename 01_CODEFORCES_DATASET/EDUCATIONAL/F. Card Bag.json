{"link": "https://codeforces.com//contest/1156/problem/F", "problemId": "338453", "shortId": "1156F", "contest_number": "1156", "name": "F. Card Bag", "statement": "You have a bag which contains  cards. There is a number written on each card; the number on -th card is .You are playing the following game. During each turn, you choose and remove a random card from the bag (all cards that are still left inside the bag are chosen equiprobably). Nothing else happens during the first turn \u2014 but during the next turns, after removing a card (let the number on it be ), you compare it with the card that was removed during the previous turn (let the number on it be ). Possible outcomes are:   if , the game ends and you lose;  if , the game ends and you win;  if , the game continues. If there are no cards left in the bag, you lose. You have to calculate the probability of winning in this game. It can be shown that it is in the form of  where  and  are non-negative integers and , . Output the value of .", "input": "The first line contains one integer  () \u2014 the number of cards in the bag. The second live contains  integers  () \u2014 the -th integer is the number written on the -th card. ", "output": "Print one integer \u2014 the probability of winning in this game modulo .", "tutorial": "Let's solve the problem by dynamic programming.Let  be the probability of winning if the last taken card has number  on it and the number of taken cards is .We win immediately next turn if we take card with number  on it. The probability of this is , where  is number of cards with .Also we can win if we take a greater card next turn.We take a card with number  with probability , with number  \u2014 with probability , and so on. The probability of winning in this case will be  and  respectively. So the probability of winning for  is ) = ).Therefore, all we need is to maintain the sum  while calculating our dynamic programming.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int N = 5005;\n\nvoid upd(int &a, int b){\n    a += b;\n    a %= MOD;\n}\n\nint mul(int a, int b){\n    return (a * 1LL * b) % MOD;\n}\n\nint bp(int a, int n){\n    int res = 1;\n    for(; n > 0; n >>= 1){\n        if(n & 1) res = mul(res, a);\n        a = mul(a, a);\n    }\n    return res;\n}\n\nint getInv(int a){\n    int ia = bp(a, MOD - 2);\n    assert(mul(a, ia) == 1);\n    return ia;\n}\n\nint n;\nint cnt[N];\nint suf[N];\nint dp[N][N];\nint sum[N][N];\nint inv[N];\n\nint main(){\n    for(int i = 1; i < N; ++i)\n        inv[i] = getInv(i);\n        \n    cin >> n;\n    for(int i = 0; i < n; ++i){\n        int x;\n        cin >> x;\n        ++cnt[x];\n    }\n    cnt[0] = 1;\n    for(int i = N - 2; i >= 0; --i)\n        suf[i] = suf[i + 1] + cnt[i];\n        \n    for(int x = n; x >= 0; --x)\n        for(int y = n; y >= 0; --y){\n            if(cnt[x] == 0){\n                upd(sum[x][y], sum[x + 1][y]);\n                continue;\n            }\n            int s = n - y;\n            if(s <= 0){\n                upd(sum[x][y], sum[x + 1][y]);\n                continue;\n            }\n            \n            upd(dp[x][y], mul(cnt[x] - 1, inv[s]));\n            upd(dp[x][y], mul(sum[x + 1][y + 1], inv[s]));\n            \n            upd(sum[x][y], sum[x + 1][y]);\n            upd(sum[x][y], mul(cnt[x], dp[x][y]));\n        }\n    \n    cout << dp[0][0] << endl;\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}