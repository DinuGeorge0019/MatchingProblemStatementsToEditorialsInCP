{"link": "https://codeforces.com//contest/1093/problem/G", "problemId": "270228", "shortId": "1093G", "contest_number": "1093", "name": "G. Multidimensional Queries", "statement": "You are given an array  of  points in -dimensional space. Let the distance between two points  and  be  (it is also known as Manhattan distance).You have to process  queries of the following two types:     ...  \u2014 set -th element of  to the point ;    \u2014 find the maximum distance between two points  and , where .", "input": "The first line contains two numbers  and  (, ) \u2014 the number of elements in  and the number of dimensions of the space, respectively. Then  lines follow, each containing  integers , , ...,  () \u2014 the coordinates of -th point. The next line contains one integer  () \u2014 the number of queries. Then  lines follow, each denoting a query. There are two types of queries:      ...  (, ) \u2014 set -th element of  to the point ;    () \u2014 find the maximum distance between two points  and , where . ", "output": "Print the answer for each query of the second type.", "tutorial": "Let's rewrite the formula of distance between two points as follows:, where  if , otherwise .Consider what will happen if we change some  to the opposite value. The result of this formula obviously won't increase, so we may try all possible values of  and pick maximum result.This allows us to consider every option to set values of  (there are  such options) separately, and when we fix a set of values of , find two points that maximize the distance if it is expressed with fixed . To do so, we have to find the point having maximum  and having minimum .So actually our problem is reduced to the following: we have  arrays, we want to process some queries in the form \"change an element of some array\" and \"find maximum and minimum on some segment of some array\". This can be done simply by building a segment tree over each array, and then we will get the solution having  time complexity.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\nconst int INF = int(1e9);\n\nint T[4 * N][32];\nint A[4 * N][5];\nint n, k;\n\nvoid build(int v, int l, int r)\n{\n\tif(l == r - 1)\n\t{\n\t\tfor(int i = 0; i < (1 << k); i++)\n\t\t{\n\t\t\tint cur = 0;\n\t\t\tfor(int j = 0; j < k; j++)\n\t\t\t\tif(i & (1 << j))\n\t\t\t\t\tcur += A[l][j];\n\t\t\t\telse\n\t\t\t\t\tcur -= A[l][j];\n\t\t\tT[v][i] = cur;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint m = (l + r) / 2;\n\t\tbuild(v * 2 + 1, l, m);\n\t\tbuild(v * 2 + 2, m, r);\n\t\tfor(int i = 0; i < (1 << k); i++)\n\t\t\tT[v][i] = min(T[v * 2 + 1][i], T[v * 2 + 2][i]);\n\t}\n}\n\nint query(int v, int l, int r, int L, int R, int x)\n{\n\tif(L >= R) return INF;\n\tif(L == l && R == r)\n\t\treturn T[v][x];\n\tint m = (l + r) / 2;\n\treturn min(query(v * 2 + 1, l, m, L, min(R, m), x), query(v * 2 + 2, m, r, max(L, m), R, x));\n}\n\nvoid upd(int v, int l, int r, int z)\n{\n\tif(l == r - 1)\n\t{\n\t\tfor(int i = 0; i < (1 << k); i++)\n\t\t{\n\t\t\tint cur = 0;\n\t\t\tfor(int j = 0; j < k; j++)\n\t\t\t\tif(i & (1 << j))\n\t\t\t\t\tcur += A[l][j];\n\t\t\t\telse\n\t\t\t\t\tcur -= A[l][j];\n\t\t\tT[v][i] = cur;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint m = (l + r) / 2;\n\t\tif(z < m)\n\t\t\tupd(v * 2 + 1, l, m, z);\n\t\telse\n\t\t\tupd(v * 2 + 2, m, r, z);\n\t\tfor(int i = 0; i < (1 << k); i++)\n\t\t\tT[v][i] = min(T[v * 2 + 1][i], T[v * 2 + 2][i]);\n\t}\n}\n\nint main() \n{ \n\tscanf(\"%d %d\", &n, &k);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < k; j++)\n\t\t{\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t}\n\t}\n\tint q;\n\tscanf(\"%d\", &q);\n\tbuild(0, 0, n);\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif(t == 1)\n\t\t{\n\t\t\tint z;\n\t\t\tscanf(\"%d\", &z);\n\t\t\t--z;\n\t\t\tfor(int j = 0; j < k; j++)\n\t\t\t\tscanf(\"%d\", &A[z][j]);\n\t\t\tupd(0, 0, n, z);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint ans = 0;\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\t--l;\n\t\t\tfor(int i = 0; i < (1 << (k - 1)); i++)\n\t\t\t{\n\t\t\t\tint x = query(0, 0, n, l, r, i);\n\t\t\t\tint y = query(0, 0, n, l, r, ((1 << k) - 1) ^ i);\n\t\t\t\tans = max(ans, abs(x + y));\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}