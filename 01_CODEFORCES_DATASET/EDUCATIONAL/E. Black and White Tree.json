{"link": "https://codeforces.com//contest/1626/problem/E", "problemId": "1263151", "shortId": "1626E", "contest_number": "1626", "name": "E. Black and White Tree", "statement": "You are given a tree consisting of  vertices. Some of the vertices (at least two) are black, all the other vertices are white.You place a chip on one of the vertices of the tree, and then perform the following operations:  let the current vertex where the chip is located is . You choose a black vertex , and then move the chip along the first edge on the simple path from  to . You are not allowed to choose the same black vertex  in two operations in a row (i.\u2009e., for every two consecutive operations, the chosen black vertex should be different).You end your operations when the chip moves to the black vertex (if it is initially placed in a black vertex, you don't perform the operations at all), or when the number of performed operations exceeds .For every vertex , you have to determine if there exists a (possibly empty) sequence of operations that moves the chip to some black vertex, if the chip is initially placed on the vertex .", "input": "The first line contains one integer  () \u2014 the number of vertices in the tree. The second line contains  integers  (), where  means that the -th vertex is white, and  means that the -th vertex is black. At least two values of  are equal to . Then  lines follow, each of them contains two integers  and  (; ) \u2014 the endpoints of some edge. These edges form a tree.", "output": "Print  integers. The -th integer should be equal to  if there exists a (possibly empty) sequence of operations that moves the chip to some black vertex if it is placed on the vertex , and  if no such sequence of operations exists.", "tutorial": "I think there are some ways to solve this problem with casework, but let's try to come up with an intuitive and easy-to-implement approach.It's always possible to move closer to some black vertex, no matter in which vertex you are currently and which black vertex was used in the previous operation. However, sometimes if you try to move along an edge, you immediately get forced back. Let's analyze when we can move without being forced back.We can move along the edge  so that our next action is not moving back if:  either  is black (there is no next action);  or, if we remove the edge between  and , the number of black vertices in 's component is at least  (we can use one of them to go from  to , and another one to continue our path). Note that the cases  and  may be different (sometimes it will be possible to move in one direction, and impossible to move in the opposite direction).Let's treat this possible move  as an arc in a directed graph. We can find all such arcs if we can answer the queries of the type \"count black vertices in a subtree of some vertex\", and this can be done by rooting the tree and calculating this information for each subtree with DFS.Now, if there is a way from some vertex  to some black vertex along these arcs, the answer for the vertex  is . How can we find all such vertices? Let's transpose the graph (change the direction of each arc to opposite), now we need to find all vertices reachable from black ones \u2014 which is easily done with multisource BFS or DFS.The complexity of this solution is .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300043;\n\nvector<int> g[N];\nint cnt[N];\nint c[N];\nvector<int> g2[N];\nint par[N];\nint used[N];\n\nvoid dfs(int x, int p = -1)\n{\n    par[x] = p;\n    for(auto y : g[x])\n        if(y != p)\n        {\n            dfs(y, x);\n            cnt[x] += cnt[y];\n        }\n    cnt[x] += c[x];\n}   \n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++) scanf(\"%d\", &c[i]);\n    for(int i = 1; i < n; i++)\n    {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        --x;\n        --y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(0);\n    for(int i = 0; i < n; i++)\n        for(auto j : g[i])\n        {\n            if(i == par[j])\n            {\n                if(c[i] == 1 || cnt[0] - cnt[j] > 1)\n                    g2[i].push_back(j);\n            }\n            else\n            {\n                if(c[i] == 1 || cnt[i] > 1)\n                    g2[i].push_back(j);\n            }\n        }\n    queue<int> q;\n    for(int i = 0; i < n; i++)\n    {\n        if(c[i] == 1)\n        {\n            q.push(i);\n            used[i] = 1;\n        }\n    }\n    while(!q.empty())\n    {\n        int k = q.front();\n        q.pop();\n        for(auto y : g2[k])\n            if(used[y] == 0)\n            {\n                used[y] = 1;\n                q.push(y);\n            }\n    }\n    for(int i = 0; i < n; i++)\n        printf(\"%d \", used[i]);\n    puts(\"\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}