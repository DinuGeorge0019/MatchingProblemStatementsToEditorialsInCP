{"link": "https://codeforces.com//contest/1671/problem/C", "problemId": "1376217", "shortId": "1671C", "contest_number": "1671", "name": "C. Dolce Vita", "statement": "Turbulent times are coming, so you decided to buy sugar in advance. There are  shops around that sell sugar: the -th shop sells one pack of sugar for  coins, but only  each day. So in order to buy several packs, you need to visit several shops.Another problem is that prices are increasing each day: during the first day the cost is , during the second day cost is , during the third day\u00a0\u2014  and so on for each shop .On the contrary, your everyday budget is only  coins. In other words, each day you go and buy as many packs as possible with total cost not exceeding . Note that if you don't spend some amount of coins during a day, you can't use these coins during the next days.Eventually, the cost for each pack will exceed , and you won't be able to buy even a single pack. So, how many packs will you be able to buy till that moment in total?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. Next  cases follow. The first line of each test case contains two integers  and  (; )\u00a0\u2014 the number of shops and your everyday budget. The second line of each test case contains  integers  ()\u00a0\u2014 the initial cost of one pack in each shop. It's guaranteed that the total sum of  doesn't exceed .", "output": "For each test case, print one integer\u00a0\u2014 the total number of packs you will be able to buy until prices exceed your everyday budget.", "tutorial": "Firstly, note that if we want to buy as many packs as possible, then it's optimal to buy the cheapest packs. In other words, if we sort all packs, we'll always buy a prefix of array .Next, note that each day we buy some number of packs , so, instead of iterating through the days, we can iterate through the number of packs  and for each  calculate the number of days we'll buy exactly  packs. Since the prices increasing and at day  the price is , then exists last day  such that as days  we could buy  packs and at days  we can't. And we can find  as maximum possible integer solution to inequation  or .We can calculate all  using prefix sums  in linear time. As a result, we buy    packs in days ;  in total;   packs in days ;  in total;   packs in days ;  in total and so on. The resulting complexity is  because of sort.", "solution": "fun main() {\n    repeat(readLine()!!.toInt()) {\n        val (n, x) = readLine()!!.split(' ').map { it.toInt() }\n        val a = readLine()!!.split(' ').map { it.toInt() }.sorted()\n\n        var sum = a.sumOf { it.toLong() }\n        var prevDay = -1L\n        var ans = 0L\n        for (i in n - 1 downTo 0) {\n            val curDay = if (x - sum >= 0) (x - sum) / (i + 1) else -1\n            ans += (i + 1) * (curDay - prevDay)\n            prevDay = curDay\n            sum -= a[i]\n        }\n        println(ans)\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}