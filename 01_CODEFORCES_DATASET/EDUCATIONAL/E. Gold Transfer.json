{"link": "https://codeforces.com//contest/1535/problem/E", "problemId": "1005286", "shortId": "1535E", "contest_number": "1535", "name": "E. Gold Transfer", "statement": "You are given a rooted tree. Each vertex contains  tons of gold, which costs  per one ton. Initially, the tree consists only a root numbered  with  tons of gold and price  per ton.There are  queries. Each query has one of two types:   Add vertex  (where  is an index of query) as a son to some vertex ; vertex  will have  tons of gold with  per ton. It's guaranteed that .  For a given vertex  consider the simple path from  to the root. We need to purchase  tons of gold from vertices on this path, spending the minimum amount of money. If there isn't enough gold on the path, . If we buy  tons of gold in some vertex  the remaining amount of gold in it decreases by  (of course, we can't buy more gold that vertex has at the moment). For each query of the second type, calculate the resulting amount of gold we bought and the amount of money we should spend.Note that you should solve the problem in  mode. It means that you can't read the whole input at once. You can read each query only after writing the answer for the last query, so don't forget to flush output after printing answers. You can use functions like  in  and  in  or similar after each writing in your program. In standard (if you don't tweak I/O),  flushes  in  and  in  (or  in ) makes automatic flush as well. ", "input": "The first line contains three integers ,  and  (; )\u00a0\u2014 the number of queries, the amount of gold in the root and its price. Next  lines contain descriptions of queries; The -th query has one of two types:    \"   \" (; ): add vertex  as a son to vertex . The vertex  will have  tons of gold with price  per one ton. It's guaranteed that  exists and . \"  \" (; ): buy  tons of gold from vertices on path from  to  spending the minimum amount of money. If there isn't enough gold, we buy as much as we can. It's guaranteed that vertex  exist.  It's guaranteed that there is at least one query of the second type.", "output": "For each query of the second type, print the resulting amount of gold we bought and the minimum amount of money we should spend.", "tutorial": "Note, that  for each vertex . So if we consider a path from some vertex  to , the closer you are to , the cheaper the cost. In other words, it's always optimal to choose the highest vertex on the path with .Suppose we can find such vertex  for a given . How many times we will repeat this search operation? If we need to buy  tons and  has  tons, then it's optimal to buy  tons in . After we buy  tons, either  becomes  or  becomes .Since for each vertex ,  can become equal to zero at most once, and since after  is zero we stop buying, then there will be  searches in total. The next question is how to find  efficiently for a given ?Consider the path from  to some vertex . Since we prefer to buy from higher vertices, all empty vertices on this path will form some prefix of it (possibly, empty prefix). So we can make some sort of binary search to find the first non-empty vertex . But instead of binary search we will use binary lifting technique.If we know for each  () which vertex  on the path from  to  on distance  from  then we can efficiently jump up the path. Let's firstly jump at distance : if  then we jump too high\u00a0\u2014 let's not jump. But if  then we can safely jump (or ). Now we know that we don't need a second  jump, so we try  jump and so on.In other words, using binary lifting we can find the highest vertex  with  in  steps. Also, we can calculate array  for vertex  right after we add vertex  to the tree, since  and .The resulting complexity is .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int LOG = 20;\n\nint q;\nvector<int> a, c;\nvector<int> p[LOG];\n\nint main() {\n\tcin >> q;\n\ta.resize(q + 1);\n\tc.resize(q + 1);\n\t\n\tfore (lg, 0, LOG)\n\t\tp[lg].resize(q + 1);\n\n\tfore (lg, 0, LOG)\n\t\tp[lg][0] = 0;\n\tcin >> a[0] >> c[0];\n\t\n\tfore (id, 1, q + 1) {\n\t\tint tp; cin >> tp;\n\t\tif (tp == 1) {\n\t\t\tint pr; cin >> pr;\n\t\t\tcin >> a[id] >> c[id];\n\t\t\t\n\t\t\tp[0][id] = pr;\n\t\t\tfore (lg, 1, LOG)\n\t\t\t\tp[lg][id] = p[lg - 1][p[lg - 1][id]];\n\t\t} \n\t\telse {\n\t\t\tint v, w;\n\t\t\tcin >> v >> w;\n\t\t\t\n\t\t\tint ansR = 0;\n\t\t\tli ansS = 0;\n\t\t\t\n\t\t\twhile (w > 0 && a[v] > 0) {\n\t\t\t\tint u = v;\n\t\t\t\tfor (int lg = LOG - 1; lg >= 0; lg--) {\n\t\t\t\t\tif (a[p[lg][u]] > 0)\n\t\t\t\t\t\tu = p[lg][u];\n\t\t\t\t}\n\t\t\t\tint mn = min(a[u], w);\n\t\t\t\ta[u] -= mn;\n\t\t\t\tw -= mn;\n\t\t\t\t\n\t\t\t\tansR += mn;\n\t\t\t\tansS += mn * 1ll * c[u];\n\t\t\t}\n\t\t\tcout << ansR << \" \" << ansS << endl;\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}