{"link": "https://codeforces.com//contest/1739/problem/C", "problemId": "1559865", "shortId": "1739C", "contest_number": "1739", "name": "C. Card Game", "statement": "Consider a game with  cards ( is even). Each card has a number written on it, between  and . All numbers on the cards are different. We say that a card with number  is stronger than a card with number  if .Two players, Alex and Boris, play this game. In the beginning, each of them receives exactly  cards, so each card belongs to exactly one player. Then, they take turns. Alex goes first, then Boris, then Alex again, and so on.On a player's turn, he must play  of his cards. Then, if the opponent doesn't have any cards  than the card played, the opponent loses, and the game ends. Otherwise, the opponent has to play a stronger card (exactly one card as well). These two cards are removed from the game, and the turn ends. If there are no cards left, the game ends in a draw; otherwise it's the opponent's turn.Consider all possible ways to distribute the cards between two players, so that each of them receives exactly half of the cards. You have to calculate three numbers:  the number of ways to distribute the cards so that Alex wins;  the number of ways to distribute the cards so that Boris wins;  the number of ways to distribute the cards so that the game ends in a draw. You may assume that both players play optimally (i.\u2009e. if a player can win no matter how his opponent plays, he wins). Two ways to distribute the cards are different if there is at least one card such that, in one of these ways, it is given to Alex, and in the other way, it is given to Boris.For example, suppose , Alex receives the cards , and Boris receives the cards . Then the game may go as follows:  if Alex plays the card , then Boris has to respond with the card . Then, Alex's turn ends, and Boris' turn starts. Boris has only one card left, which is ; he plays it, and Alex responds with the card . So, the game ends in a draw;  if Alex plays the card , then Boris has to respond with the card . Then, Alex's turn ends, and Boris' turn starts. Boris has only one card left, which is ; he plays it, and Alex responds with the card . So, the game ends in a draw. So, in this case, the game ends in a draw.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. Then,  lines follow. The -th line contains one  integer  ().", "output": "For each test case, print three integers:   the number of ways to distribute the cards so that Alex wins;  the number of ways to distribute the cards so that Boris wins;  the number of ways to distribute the cards so that the game ends in a draw.  .", "tutorial": "The example tests suggest that there is only one possible distribution with a draw. Let's find out why it is so. We will use a process similar to induction/recursion to distribute the cards between the two players so that the game ends in a draw:  suppose Alex receives the card . Then he wins since he can play it immediately. So, for the game to result in a draw, Boris must receive the card .  suppose Boris receives the card . Then he wins since he also has the card , he can use it to answer any first move of Alex, and then win the game by playing . So, for the game to result in a draw, Alex must receive the card .  suppose Boris receives the card . Then he wins since he also has the card : if Alex plays the card , Boris responds with  and then plays ; if Alex plays some other card, Boris responds with  and the plays . So, for the game to result in a draw, Alex must receive the card .  and so on. In fact, if Alex receives the card  and Boris receives the card , Alex must play the card  or something equivalent to it on the first move, and Boris must respond with the card , so we can consider the game without these two cards with the roles swapped.So, if we consider the distribution of cards as a string with characters  and , where  denotes the card belonging to Alex, and  denotes the card belonging to Boris, and the -th character of the string represents the card , the only possible distribution for the draw is  But there's more to this string representation of the distribution of cards: the first character that is different from this pattern denotes the winner; if the first different character is  in the draw distribution and  in the distribution we consider, the winner is Boris; otherwise, the winner is Alex.This may lead us to the following ways to count the number of possible distributions which win/lose for Alex:  we can use dynamic programming of the form , where  is the number of characters  we used,  is the number of characters  we used, and  is ,  or  depending on whether our string coincides with the draw string (), differs from it in a way that Alex wins (), or differs from it in a way that Boris wins (); the actual value of  must be the number of ways to reach this state of dynamic programming. The answer then is stored in the states of the form .  or we can use combinatorics: let's iterate on the length of the prefix that is common in the draw string and in the string representing the distribution of cards, and then count the number of ways to distribute the remaining characters with a binomial coefficient. To calculate the binomial coefficients, we can use one of the following methods: Pascal's triangle, precalculating factorials and modular inverses to then, or calculating factorials with big integers in Java or Python. ", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nlong long dp[65][65][3];\n\nvoid solve(int n)\n{\n    memset(dp, 0, sizeof dp);\n    int k = n / 2;\n    dp[0][0][2] = 1;\n    for(int i = 0; i <= k; i++)\n        for(int j = 0; j <= k; j++)\n            for(int t = 0; t <= 2; t++)\n            {\n                int turn = (i + j) % 4;\n                if (turn == 0 || turn == 3)\n                {\n                    if(i < k) dp[i + 1][j][t == 2 ? 0 : t] += dp[i][j][t];\n                    if(j < k) dp[i][j + 1][t] += dp[i][j][t];\n                }\n                else\n                {\n                    if(i < k) dp[i + 1][j][t] += dp[i][j][t];\n                    if(j < k) dp[i][j + 1][t == 2 ? 1 : t] += dp[i][j][t];\n                }\n            }\n    for(int i = 0; i < 3; i++)\n        cout << dp[k][k][i] % 998244353 << \" \";\n    cout << endl;\n}\n\nint main()\n{\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; i++)\n    {\n        int n;\n        cin >> n;\n        solve(n);\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}