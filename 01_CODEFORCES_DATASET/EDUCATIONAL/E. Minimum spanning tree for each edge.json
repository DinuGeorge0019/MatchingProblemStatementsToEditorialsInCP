{"link": "https://codeforces.com//contest/609/problem/E", "problemId": "43548", "shortId": "609E", "contest_number": "609", "name": "E. Minimum spanning tree for each edge", "statement": "Connected undirected weighted graph without self-loops and multiple edges is given. Graph contains  vertices and  edges.For each edge  find the minimal possible weight of the spanning tree that contains the edge .The weight of the spanning tree is the sum of weights of all edges included in spanning tree.", "input": "First line contains two integers  and  () \u2014 the number of vertices and edges in graph. Each of the next  lines contains three integers  () \u2014 the endpoints of the -th edge and its weight.", "output": "Print  lines. -th line should contain the minimal possible weight of the spanning tree that contains -th edge. The edges are numbered from  to  in order of their appearing in input.", "tutorial": "This problem was prepared by dalex.\nLet's build any MST with any fast algorithm (for example with Kruskal's algorithm). For all edges in MST the answer is the weight of the MST. Let's consider any other edge (x,\u2009y). There is exactly one path between x and y in the MST. Let's remove mostly heavy edge on this path and add edge (x,\u2009y). Resulting tree is the MST contaning edge (x,\u2009y) (this can be proven by Tarjan criterion).\nLet's fix some root in the MST (for example the vertex 1). To find the most heavy edge on the path from x to y we can firstly find the heaviest edge on the path from x to l\u2009=\u2009lca(x,\u2009y) and then on the path from y to l, where l is the lowest common ancestor of vertices x and y. To find l we can use binary lifting method. During calculation of l we also can maintain the weight of the heaviest edge.\nOf course this problem also can be solved with difficult data structures, for example with Heavy-light decomposition method or with Linkcut trees.\nComplexity: O(mlogn).\nIt's very strange but I can't find any articles with Tarjan criterion on English (although there are articles on Russian), so here it is:\nSome spanning tree is minimal if and only if the weight of any other edge (x,\u2009y) (not from spanning tree) is not less than the weight of the heaviest edge on the path from x to y in spanning tree.\n", "solution": "/*\nTake me back\nBack to the scene\nIt's coming back\nI remember her screams\n\nThe fear in her eye\nThe night she died\nIt left me empty\nHollow inside\n\nDead to the world\nI see only black\nThere's blood on my hands\n\nDead to the world\nI see only black\nThe blood of the dead\n\nFeelings deep inside\nI don't understand\nCan't fall asleep at night\nI try and wake in fright\n\nTouch of her skin\nNext to mine\nWarm and wet\nDeep inside\n\nDead to the world\nI see only black\nThere's blood on my hands\n\nDead to the world\nI see only black\nThe blood of the dead\n\nI wrapped my hands around her neck\nSqueezing out her breath\nEyes rolled back in her head\nClawing at my skin\nI know now it's not my fault\nShe was asking for it\n\nMemories\nCame back to me\nIn the night\n\nI hear her screams\nWaiting\nIn the grave\nCalling out\n\nCome to me\nI hear her screaming\nWaiting in the grave\nCalling out but she's buried\n\nWaiting in the grave\nCome to me\nI hear her screaming\nWaiting\n\nI wrapped my hands around her neck\nSqueezing out her breath\nEyes rolled back in her head\nClawing at my skin\nI know now it's not my fault\nShe was asking for it\n\nMemories\nCame back to me\nIn the night\n\nI hear her screams\nWaiting\nIn the grave\nCalling out\n\nI remember her screams\nThe night she died\nI left her empty\nHollow inside\n\nDead to the world\nI see only black\nThere's blood on my hands\n\nDead to the world\nI see only black\nThe blood of the dead\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1234567891\n#define bsize 512\n\nconst int N = 210000;\n\nconst int l = 17;\n\nusing namespace std;\n\nint n, m;\nvector<pair<int, int> > g[N];\nvector<pair<int, pair<int, int> > > edges, edges2,mst;\nint w[N];\nlong long COST;\nint timer;\nint up[N][l + 1];\nint bedge[N][l + 1];\nint tin[N];\nint tout[N];\nint dep[N];\n\nvoid dfs(int v, int p = 1,int pcost=0)\n{\n\ttin[v] = timer;\n\t++timer;\n\tup[v][0] = p;\n\tbedge[v][0] = pcost;\n\tfor (int i = 1; i <= l; i++)\n\t{\n\t\tup[v][i] = up[up[v][i - 1]][i - 1];\n\t\tbedge[v][i] = max(bedge[v][i - 1], bedge[up[v][i-1]][i - 1]);\n\t}\n\tfor (int i = 0; i < g[v].size(); i++)\n\t{\n\t\tint to = g[v][i].first;\n\t\tint cost = g[v][i].second;\n\t\tif (to == p)\n\t\t\tcontinue;\n\t\tdep[to] = dep[v] + 1;\n\t\tdfs(to, v, cost);\n\t}\n\ttout[v] = timer;\n\t++timer;\n}\n\nbool upper(int a, int b)\n{\n\treturn (tin[a] <= tin[b] && tout[a] >= tout[b]);\n}\n\nint lca(int a, int b)\n{\n\tif (upper(a, b))\n\t\treturn a;\n\tif (upper(b, a))\n\t\treturn b;\n\tfor (int i = l; i >= 0; --i)\n\t{\n\t\tif (!upper(up[a][i], b))\n\t\t\ta = up[a][i];\n\t}\n\treturn up[a][0];\n}\n\nint get(int x)\n{\n\tif (x == w[x])\n\t\treturn x;\n\treturn w[x] = get(w[x]);\n}\n\nvoid merge(int a, int b)\n{\n\tif (rand() % 2)\n\t\tswap(a, b);\n\ta = get(a);\n\tb = get(b);\n\tw[a] = b;\n}\n\nint get_best(int v, int span)\n{\n\tint ret = 0;\n\tfor (int i = l; i >= 0; --i)\n\t{\n\t\tif (span&(1 << i))\n\t\t{\n\t\t\tret = max(ret, bedge[v][i]);\n\t\t\tv = up[v][i];\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\t//freopen(\"beavers.in\",\"r\",stdin);\n\t//freopen(\"beavers.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\",\"r\",stdin);\n\t//freopen(\"F:/output.txt\",\"w\",stdout);\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tedges.push_back(make_pair(c, make_pair(a, b)));\n\t\tedges2.push_back(make_pair(c, make_pair(a, b)));\n\t}\n\n\tsort(edges.begin(), edges.end());\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tw[i] = i;\n\t}\n\n\tfor (int i = 0; i < edges.size(); i++)\n\t{\n\t\tint a, b, c;\n\t\ta = edges[i].second.first;\n\t\tb = edges[i].second.second;\n\t\tint ta, tb;\n\t\tc = edges[i].first;\n\t\tta = get(a);\n\t\ttb = get(b);\n\t\tif (ta == tb)\n\t\t\tcontinue;\n\t\tmerge(ta, tb);\n\t\tmst.push_back(make_pair(c, make_pair(a, b)));\n\t\tCOST += c;\n\t}\n\n\tfor (int i = 0; i < mst.size(); i++)\n\t{\n\t\tint v1 = mst[i].second.first;\n\t\tint v2 = mst[i].second.second;\n\t\tint cost = mst[i].first;\n\t\tg[v1].push_back(make_pair(v2, cost));\n\t\tg[v2].push_back(make_pair(v1, cost));\n\t}\n\t\n\tdfs(1);\n\n\tfor (int i = 0; i < edges2.size(); i++)\n\t{\n\t\tint v1 = edges2[i].second.first;\n\t\tint v2 = edges2[i].second.second;\n\t\tint L = lca(v1, v2);\n\t\tint bst = 0;\n\t\tbst = max(bst, get_best(v1, dep[v1] - dep[L]));\n\t\tbst = max(bst, get_best(v2, dep[v2] - dep[L]));\n\t\tcout << COST + edges2[i].first - bst << \"\\n\";\n\t}\n\n\tcin.get();cin.get();\n\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}