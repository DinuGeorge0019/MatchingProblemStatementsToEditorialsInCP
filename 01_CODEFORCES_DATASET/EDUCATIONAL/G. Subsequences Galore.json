{"link": "https://codeforces.com//contest/1620/problem/G", "problemId": "1233294", "shortId": "1620G", "contest_number": "1620", "name": "G. Subsequences Galore", "statement": "For a sequence of strings , let's define the function  as the number of different strings () that are subsequences of  string .  (i.\u2009e. the number of such strings for an empty sequence is ).You are given a sequence of strings . Every string in this sequence consists of lowercase Latin letters and is  (i.\u2009e., each string begins with several (maybe zero) characters , then several (maybe zero) characters , ..., ends with several (maybe zero) characters ).For each of  subsequences of , calculate the value of the function  modulo .", "input": "The first line contains one integer  () \u2014 the number of strings. Then  lines follow. The -th line contains the string  (), consisting of lowercase Latin letters. Each string  is sorted.", "output": "Since printing up to  integers would be really slow, you should do the following: For each of the  subsequences (which we denote as ), calculate , take it modulo , then multiply it by . Print the XOR of all  integers you get. The indices  in the description of each subsequences are -indexed (i.\u2009e. are from  to ).", "tutorial": "For a string , let's define its  as the mask of  bits, where -th bit is  if and only if  is a subsequence of . Let's suppose we somehow calculate the number of strings for each , and we denote this as  for a mask . How can we use this information to find ? Suppose this set of strings is represented by a mask , then the strings which are  included in  are the strings such that their characteristic mask has bitwise AND with  equal to , i.\u2009e. these characteristic masks are submasks of . We can use SOS DP to calculate these sums of  over submasks in .The only problem is how to calculate  for every mask. Let's analyze when a string is a subsequence of a sorted string . The subsequence should be sorted as well, and the number of occurrences of every character in a subsequence should not exceed the number of occurrences of that character in . So, if there are  characters  in ,  characters  in , and so on, then the number of its subsequences is .What about subsequences of every string from a set? These conditions on the number of occurrences should apply to every string in the set, so, for each character, we can calculate the minimum number of occurrences of this character in each string of the set, add , and multiply these numbers to get the number of strings that are subsequences of each string in a set.These values can be calculated in  for all  subsequences of  using recursive approach. Can these numbers be used as ? Not so fast. Unfortunately, these values (let's call them ) are the numbers of subsequences of the chosen sets of strings, but we have no information about the strings that are not included in the chosen set of strings. To handle it, we can use the following equation: , where  means that  is a submask of . To transform the values of  into the values of , we can flip all bits in the masks (so  is the sum of  over all submasks of ), apply inverse SOS DP (also known as Mobius transformation), and then flip all bits in the masks again. So, we found a way to calculate all values of  in , and we have already discussed what to do with them in the first paragraph of the editorial.The overall complexity of the solution is .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 23;\nconst int A = 26;\nconst int S = 20043;\nint n;\nstring inp[N];\nchar buf[S];\nint cnt[N][A];\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    return x;\n}\n\nint sub(int x, int y)\n{\n    return add(x, -y);\n}\n\nint mul(int x, int y)\n{\n    return (x * 1ll * y) % MOD;\n}\n\nvoid flip_all(vector<int>& a)\n{\n    int msk = (1 << n) - 1;\n    for(int i = 0; i < (1 << (n - 1)); i++)\n        swap(a[i], a[i ^ msk]);\n}\n\nint val[S];\nint* where[S];\nint cur = 0;\n\nvoid change(int& x, int y)\n{\n    where[cur] = &x;\n    val[cur] = x;\n    x = y;\n    cur++;\n}\n\nvoid rollback()\n{\n    --cur;\n    (*where[cur]) = val[cur];\n}\n\nvoid zeta_transform(vector<int>& a)\n{\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < (1 << n); j++)\n            if((j & (1 << i)) == 0)\n                a[j ^ (1 << i)] = add(a[j ^ (1 << i)], a[j]);\n    }\n}                     \n\nvoid mobius_transform(vector<int>& a)\n{\n    for(int i = n - 1; i >= 0; i--)\n    {\n        for(int j = (1 << n) - 1; j >= 0; j--)\n            if((j & (1 << i)) != 0)\n                a[j] = sub(a[j], a[j ^ (1 << i)]);\n    }\n}\n\nint cur_max[A];\nvector<int> mask_cnt;\n\nvoid rec(int depth, int mask)\n{\n    if(depth == n)\n    {\n        mask_cnt[mask] = 1;\n        for(int i = 0; i < A; i++)\n            mask_cnt[mask] = mul(mask_cnt[mask], cur_max[i] + 1);\n    }\n    else\n    {\n        int state = cur;\n        for(int i = 0; i < A; i++)\n            change(cur_max[i], min(cur_max[i], cnt[depth][i]));\n        rec(depth + 1, mask + (1 << depth));\n        while(state != cur) rollback();\n        rec(depth + 1, mask);\n    }   \n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%s\", buf);\n        inp[i] = buf;\n        for(auto x : inp[i])\n            cnt[i][x - 'a']++;\n    }\n\n    for(int i = 0; i < A; i++)\n        cur_max[i] = S;\n    mask_cnt.resize(1 << n);\n    rec(0, 0);\n    flip_all(mask_cnt);\n    mobius_transform(mask_cnt);\n    flip_all(mask_cnt);\n    int sum = 0;\n    for(int i = 0; i < (1 << n); i++) sum = add(sum, mask_cnt[i]);\n    zeta_transform(mask_cnt);\n    vector<int> res(1 << n);\n    for(int i = 0; i < (1 << n); i++)\n        res[i] = sub(sum, mask_cnt[((1 << n) - 1) ^ i]);\n\n    long long ans = 0;\n\n    for(int i = 0; i < (1 << n); i++)\n    {\n        int c = 0, s = 0;\n        for(int j = 0; j < n; j++)\n        {\n            if(i & (1 << j))\n            {\n                c++;\n                s += j + 1;\n            }   \n        }\n        ans ^= res[i] * 1ll * c * 1ll * s;\n    }\n\n    //for(int i = 0; i < (1 << n); i++) printf(\"%d\\n\", res[i]);\n    printf(\"%lld\\n\", ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}