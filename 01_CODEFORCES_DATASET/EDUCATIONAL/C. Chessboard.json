{"link": "https://codeforces.com//contest/961/problem/C", "problemId": "171414", "shortId": "961C", "contest_number": "961", "name": "C. Chessboard", "statement": "Magnus decided to play a classic chess game. Though what he saw in his locker shocked him! His favourite chessboard got broken into  pieces, each of size  by ,  is . And what's even worse, some squares were of wrong color. -th square of the -th row of -th piece of the board has color ;  being black and  being white. Now Magnus wants to change color of some squares in such a way that he recolors minimum number of squares and obtained pieces form a valid chessboard. Every square has its color different to each of the neightbouring by side squares in a valid board. Its size should be  by . You are allowed to move pieces but .", "input": "The first line contains  integer   \u2014 the size of all pieces of the board.  Then  segments follow, each describes one piece of the board. Each consists of  lines of  characters; -th one of -th line is equal to  if the square is black initially and  otherwise. Segments are separated by an empty line.", "output": "Print one number \u2014 minimum number of squares Magnus should recolor to be able to obtain a valid chessboard.", "tutorial": "Since  is odd, exactly  pieces of the board will have upper left corner colored black (and exactly  \u2014 white). Let's check every option to choose two pieces of the board so their upper left corners will be painted white when we assemble the board, calculate the number of board cells that have to be recolored, and find the minimum of this value among all possible choices.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 109;\n\nint n;\nstring a[4][N];\n\nint main() {\n\tcin >> n;\n\tfor(int k = 0; k < 4; ++k)\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> a[k][i];\n\t\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t    a[k][i][j] -= '0';\n\t\t}\n\t\n\tvector <int> v;\n\tfor(int k = 0; k < 4; ++k){\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tif((i + j) % 2 != a[k][i][j])\n\t\t\t\t\t++sum;\n\t\tv.push_back(sum);\n\t}\n\t\n\tint res = int(1e9);\n\tvector <int> perm;\n\tfor(int k = 0; k < 4; ++k) perm.push_back(k);\n\tdo{\n\t\tint sum = 0;\n\t\tfor(int k = 0; k < 4; ++k){\n\t\t\tint id = perm[k];\n\t\t\tif(k & 1)\n\t\t\t\tsum += v[id];\n\t\t\telse\n\t\t\t\tsum += n * n - v[id];\n\t\t}\n\t\t\n\t\tres = min(res, sum);\n\t}while(next_permutation(perm.begin(), perm.end()));\n\n\tcout << res << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}