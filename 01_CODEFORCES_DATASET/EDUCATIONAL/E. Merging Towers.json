{"link": "https://codeforces.com//contest/1380/problem/E", "problemId": "670987", "shortId": "1380E", "contest_number": "1380", "name": "E. Merging Towers", "statement": "You have a set of  discs, the -th disc has radius . Initially, these discs are split among  towers: each tower contains at least one disc, and the discs in each tower are sorted in descending order of their radii from bottom to top.You would like to assemble one tower containing all of those discs. To do so, you may choose two different towers  and  (each containing at least one disc), take several (possibly all) top discs from the tower  and put them on top of the tower  in the same order, as long as the top disc of tower  is bigger than each of the discs you move. You may perform this operation any number of times.For example, if you have two towers containing discs  and  (in order from bottom to top), there are only two possible operations:  move disc  from the first tower to the second tower, so the towers are  and ;  move discs  from the first tower to the second tower, so the towers are  and . Let the  of some set of towers be the minimum number of operations required to assemble one tower containing all of the discs. For example, the  of the set of towers  is : you may move the disc  to the second tower, and then move both discs from the second tower to the first tower.You are given  queries. Each query is denoted by two numbers  and , and means \"merge the towers  and \" (that is, take all discs from these two towers and assemble a new tower containing all of them in descending order of their radii from top to bottom). The resulting tower gets index .For each , calculate the  of the set of towers after the first  queries are performed.", "input": "The first line of the input contains two integers  and  () \u2014 the number of discs and the number of towers, respectively. The second line contains  integers , , ...,  (), where  is the index of the tower disc  belongs to. Each value from  to  appears in this sequence at least once. Then  lines follow, denoting the queries. Each query is represented by two integers  and  (, ), meaning that, during the -th query, the towers with indices  and  are merged ( and  are chosen in such a way that these towers exist before the -th query).", "output": "Print  integers. The -th integer (-indexed) should be equal to the difficulty of the set of towers after the first  queries are performed.", "tutorial": "First of all, let's try to find a simple way to evaluate the difficulty of a given set of towers. I claim that the difficulty is equal to the number of pairs of discs  that belong to different towers.  during each operation we can \"merge\" at most one such pair: if we move discs to the tower with disk  on top of it, only the pair  can be affected;  we can always take the first several  discs belonging to the same tower and move them to the tower containing disc , thus merging exactly one pair in exactly one operation.After that, there are two main approaches: LCA and small-to-large merging. The model solution uses LCA, so I'll describe it.For each pair , we have to find the first moment these discs belong to the same tower. To do so, let's build a rooted tree on  vertices. The vertices  to  will be the leaves of the tree and will represent the original towers. The vertex  will represent the tower created during the -th query and will have two children \u2014 the vertices representing the towers we merge during the -th query. The vertex  is the root.Now, if some vertex  is an ancestor of vertex , it means that the tower represented by vertex  contains all the discs from the tower represented by vertex . So, to find the first tower containing two discs  and , we have to find the lowest common ancestor of the vertices representing the towers  and . The easiest way to do it is to implement something like binary lifting, which allows us to solve the problem in .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\nconst int L = 20;\n\nvector<int> g[2 * N];\nint p[2 * N];\nint up[2 * N][L];\nint idx[N];\nint psum[N];\nint cur[N];\nint tin[2 * N];\nint tout[2 * N];\nint T = 0;\n\nvoid dfs(int x, int y)\n{\n\ttin[x] = T++;\n\tp[x] = y;\n\tup[x][0] = y;\n\tfor(int i = 1; i < L; i++)\n\t\tup[x][i] = up[up[x][i - 1]][i - 1];\n\tfor(auto z : g[x])\n\t\tdfs(z, x);\n\ttout[x] = T++;\n}\n\nbool is_ancestor(int x, int y)\n{\n\treturn tin[x] <= tin[y] && tout[x] >= tout[y];\n}\n\nint lca(int x, int y)\n{\n\tif(is_ancestor(x, y))\n\t\treturn x;\n\tfor(int i = L - 1; i >= 0; i--)\n\t\tif(!is_ancestor(up[x][i], y))\n\t\t\tx = up[x][i];\n\treturn p[x];\n}\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &idx[i]);\n\t\tidx[i]--;\n\t}\n\tfor(int i = 0; i < m; i++)\n\t\tcur[i] = i;\n\tfor(int i = 0; i < m - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tint nidx = m + i;\n\t\tg[nidx].push_back(cur[x]);\n\t\tg[nidx].push_back(cur[y]);\n\t\tcur[x] = nidx;\n\t}\n\tint root = m * 2 - 2;\n\tdfs(root, root);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint t = lca(idx[i], idx[i + 1]);\n\t\tif(t < m)\n\t\t\tpsum[0]++;\n\t\telse\n\t\t\tpsum[t - m + 1]++;\n\t}\n\tfor(int i = 0; i < m - 1; i++)\n\t\tpsum[i + 1] += psum[i];\n\tfor(int i = 0; i < m; i++)\n\t\tprintf(\"%d\\n\", n - 1 - psum[i]);\n}", "interactive": false, "noSolution": false, "noTutorial": false}