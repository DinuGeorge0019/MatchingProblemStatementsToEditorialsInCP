{"link": "https://codeforces.com//contest/1082/problem/E", "problemId": "64167", "shortId": "1082E", "contest_number": "1082", "name": "E. Increasing Frequency", "statement": "You are given array  of length . You can choose one segment  () and integer value  (positive, negative or even zero) and change  by  each (i.e.  for each ).What is the maximum possible number of elements with value  that can be obtained after one such operation?", "input": "The first line contains two integers  and  (, ) \u2014 the length of array and the value  to obtain. The second line contains  integers  () \u2014 array .", "output": "Print one integer \u2014 the maximum possible number of elements with value  which can be obtained after performing operation described above.", "tutorial": "Let  be a number of occurrences of number  in subsegment .The given task is equivalent to choosing  and value  such that  is maximum possible. But with some transformations  so we need to maximize .Key observation is the next: if we fix some value  then we can shrink each segment between consecutive occurrences of  in one element with weight equal to . Then we need just to find subsegment with maximal sum \u2014 the standard task which can be solved in .Finally, total complexity is .", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\nconst int INF = int(1e9);\n\nint n, c;\nvector<int> a;\n\ninline bool read() {\n\tif(!(cin >> n >> c))\n\t\treturn false;\n\ta.assign(n, 0);\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\nvector<int> cntC;\n\nint getCnt(int l, int r) {\n\treturn cntC[r] - cntC[l];\n}\n\nvector< vector<int> > segs;\nvector<int> lst;\n\nint maxSegment(const vector<int> &s) {\n\tint mx = -INF;\n\t\n\tint bal = 0;\n\tfore(i, 0, sz(s)) {\n\t\tbal = max(0, bal + s[i]);\n\t\tmx = max(mx, bal);\n\t}\n\treturn mx;\n}\n\ninline void solve() {\n\tcntC.assign(n + 1, 0);\n\tfore(i, 0, n)\n\t\tcntC[i + 1] = cntC[i] + (a[i] == c);\n\t\n\tint cntDif = *max_element(a.begin(), a.end()) + 1;\n\tsegs.assign(cntDif, vector<int>());\n\tlst.assign(cntDif, -1);\n\t\n\tfore(i, 0, n) {\n\t\tsegs[a[i]].push_back(-getCnt(lst[a[i]] + 1, i));\n\t\tlst[a[i]] = i;\n\t\tsegs[a[i]].push_back(1);\n\t}\n\tfore(v, 0, cntDif)\n\t\tsegs[v].push_back(-getCnt(lst[v] + 1, n));\n\t\t\n\tint ans = 0;\n\tfore(v, 0, cntDif) {\n\t\tif(v == c) continue;\n\t\tans = max(ans, maxSegment(segs[v]));\n\t}\n\t\n\tcout << getCnt(0, n) + ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}