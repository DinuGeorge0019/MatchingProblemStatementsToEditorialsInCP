{"link": "https://codeforces.com//contest/1620/problem/F", "problemId": "1233293", "shortId": "1620F", "contest_number": "1620", "name": "F. Bipartite Array", "statement": "You are given a permutation  consisting of  integers  (a permutation is an array where each element from  to  occurs exactly once).Let's call an array   if the following undirected graph is bipartite:  the graph consists of  vertices;  two vertices  and  are connected by an edge if  and . Your task is to find a  array of integers  of size , such that  or , or report that no such array exists. If there are multiple answers, print any of them.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains a single integer  ()\u00a0\u2014 the size of the permutation. The second line contains  integers . The sum of  over all test cases doesn't exceed .", "output": "For each test case, print the answer in the following format. If such an array  does not exist, print \"\" in a single line. Otherwise, print \"\" in the first line and  integers\u00a0\u2014 array  in the second line.", "tutorial": "To begin with, let's understand that an array is bipartite if and only if there is no decreasing subsequence of length  in the array.Now we can write dynamic programming : is there an array  of length  such that  is the maximum last element of a decreasing subsequence of length , and  is the maximum last element of a subsequence of length . Note that .Let's consider all possible transitions from the state  if we are trying to put the number  on the -th position, where :  if , then the new state will be ;  if , then the new state will be ;  if , then such a transition is not valid, because a decreasing subsequence of length  is formed in the array. With a naive implementation, such dynamic programming works in .We can note that for fixed values of  and  ( and ) it is enough for us to store only the minimum available value of  (). So, we can write dynamic programming , which is defined similarly to the above, but now instead of being Boolean, stores the minimum value of  (or infinity if the state is not valid).We have speeded up our solution to , but it is still too slow.To speed up the solution even more, we have to look at the transitions in dynamics and notice that for a fixed , either  or  is always equal to . So we can rewrite our dynamic programming in the following form\u00a0\u2014 . Here, the  flag says which of the numbers  and  is equal to , and the  flag is responsible for the sign of , and the minimum value of  or  is stored in the value itself (depending on ).Thus, we got a solution with a linear running time.In fact, this solution can be simplified if we see the following relation: the number we use on position  is not less than  and not greater than . This allows us to get rid of one of the states in our dynamic programming altogether, so we get an easier solution. This optimization wasn't required to get AC, but the code becomes shorter.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int INF = 1e9;\nconst int N = 1000 * 1000 + 13;\n\nint n;\nint p[N], a[N];\nint dp[N][2][2];\npair<int, int> pr[N][2][2];\n\nvoid solve() {\n  scanf(\"%d\", &n);\n  forn(i, n) scanf(\"%d\", &p[i]);\n  forn(i, n) forn(pos, 2) forn(sg, 2)\n    dp[i][pos][sg] = INF;\n  dp[0][0][0] = dp[0][0][1] = -INF;\n  \n  forn(i, n - 1) forn(pos, 2) forn(sg, 2) if (dp[i][pos][sg] != INF) {\n    forn(nsg, 2) {\n      int x = sg ? -p[i] : p[i];\n      int y = dp[i][pos][sg];\n      if (pos) swap(x, y);\n      int z = nsg ? -p[i + 1] : p[i + 1];\n      if (z > x) {\n        if (dp[i + 1][0][nsg] > y) {\n          dp[i + 1][0][nsg] = y;\n          pr[i + 1][0][nsg] = make_pair(pos, sg);\n        }\n      } else if (z > y)  {\n        if (dp[i + 1][1][nsg] > x) {\n          dp[i + 1][1][nsg] = x;\n          pr[i + 1][1][nsg] = make_pair(pos, sg);\n        }\n      }\n    }\n  }\n  \n  int pos = -1, sg = -1;\n  forn(j, 2) forn(k, 2) if (dp[n - 1][j][k] != INF) \n    pos = j, sg = k;\n  if (pos == -1) {\n    puts(\"NO\");\n    return;\n  }\n  for (int i = n - 1; i >= 0; i--) {\n    a[i] = sg ? -p[i] : p[i];\n    tie(pos, sg) = pr[i][pos][sg];\n  }\n  \n  puts(\"YES\");\n  forn(i, n) printf(\"%d \", a[i]);\n  puts(\"\");\n}\n\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) solve();\n} ", "interactive": false, "noSolution": false, "noTutorial": false}