{"link": "https://codeforces.com//contest/1312/problem/D", "problemId": "557980", "shortId": "1312D", "contest_number": "1312", "name": "D. Count the Arrays", "statement": "Your task is to calculate the number of arrays such that:  each array contains  elements;  each element is an integer from  to ;  for each array, there is  one pair of equal elements;  for each array , there exists an index  such that the array is  before the -th element and  after it (formally, it means that , if , and , if ). ", "input": "The first line contains two integers  and  ().", "output": "Print one integer \u2014 the number of arrays that meet all of the aforementioned conditions, taken modulo .", "tutorial": "First of all, there will be exactly  distinct elements in our array. Let's choose them, there are  ways to do that.After that, there should be exactly one element that appears twice. There are  elements to choose from, but are all of them eligible? If we duplicate the maximum element, there will be no way to meet the fourth condition. So we should multiply the current answer by , not .And finally, some elements will appear earlier than the maximum in our array, and some \u2014 later. The duplicated element will appear on both sides, but all other elements should appear either to the left or to the right, so there are  ways to choose their positions.Thus the answer is . Note that you have to precompute all factorials and use their inverse elements to calculate .Note that there is a tricky case when : some binpow implementations go into infinite loop trying to compute , so you may have to handle it specifically.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    return x;\n}\n\nint mul(int x, int y)\n{\n    return (x * 1ll * y) % MOD;\n}\n\nint binpow(int x, int y)\n{\n    int z = 1;\n    while(y)\n    {\n        if(y & 1) z = mul(z, x);\n        x = mul(x, x);\n        y >>= 1;\n    }\n    return z;\n}\n\nint inv(int x)\n{\n    return binpow(x, MOD - 2);\n}\n\nint divide(int x, int y)\n{\n    return mul(x, inv(y));\n}\n\nint fact[N];\n\nvoid precalc()\n{\n    fact[0] = 1;\n    for(int i = 1; i < N; i++)\n        fact[i] = mul(fact[i - 1], i);\n}\n\nint C(int n, int k)\n{\n    return divide(fact[n], mul(fact[k], fact[n - k]));\n}\n\nint main() \n{\n    precalc();\n    int n, m;\n    cin >> n >> m;\n    int ans = 0;\n    if(n > 2)\n        ans = mul(C(m, n - 1), mul(n - 2, binpow(2, n - 3)));\n    cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}