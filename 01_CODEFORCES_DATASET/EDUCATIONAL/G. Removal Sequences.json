{"link": "https://codeforces.com//contest/1795/problem/G", "problemId": "1785703", "shortId": "1795G", "contest_number": "1795", "name": "G. Removal Sequences", "statement": "You are given a simple undirected graph, consisting of  vertices and  edges. The vertices are numbered from  to . The -th vertex has a value  written on it.You will be removing vertices from that graph. You are allowed to remove vertex  only if its degree is equal to . When a vertex is removed, all edges incident to it are also removed, thus, decreasing the degree of adjacent non-removed vertices.A valid sequence of removals is a permutation   such that the -th vertex to be removed is , and every removal is allowed.A pair  of vertices is  if there exist two valid sequences of removals such that  is removed before  in one of them and  is removed before  in the other one.Count the number of  pairs  such that .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains two integers  and  (; )\u00a0\u2014 the number of vertices and the number of edges of the graph. The second line contains  integers  ()\u00a0\u2014 the degree requirements for each removal. Each of the next  lines contains two integers  and  (; )\u00a0\u2014 the description of an edge. The graph doesn't contain any self-loops or multiple edges. The sum of  over all testcases doesn't exceed . The sum of  over all testcases doesn't exceed . ", "output": "For each testcase, print a single integer\u00a0\u2014 the number of  pairs of vertices.", "tutorial": "Let's consider what the sequence of removals looks like in general. We will base some intuition on a fact that at least one valid sequence is guaranteed to exist.Remove all vertices that have their degree correct from the start at once. There surely be such vertices, since a valid sequence would have to start with some of them.Notice that there can't be any adjacent vertices among them. If there were, we wouldn't be able to remove such a pair regardless of the order we choose, since removing one of them makes another one's degree too low.Now remove the vertices that just got their degrees correct from removing the first layer. Once again, these must exist (if the graph is not empty yet), because otherwise any valid sequence would get stuck.Process until nothing is left.This algorithm is basically a bfs, and you can implement it like one.Note that each vertex becomes available to be removed only after a certain subset of its neighbours is removed. No matter what order you choose to remove the vertices in, these vertices will always be the same.Huh, so for each vertex, some of its neighbours have to be removed before it, and the rest have to be removed after it (since otherwise, the degree of that vertex will become too low). That actually means that our graph is not as undirected as it seemed. We can direct each edge from a vertex that is removed before the other.This makes a valid sequence of removals just a topological sort of that directed graph. So a pair is nice if there exist two topological orders such that  and  go one before another in them.We can make a bold but perfectly reasonable guess about all nice pairs. A pair is nice if neither of  and  are reachable from each other.The necessity of this condition is obvious. Let's show sufficiency.Let's show the construction such that  goes before . To remove , we first have to remove all vertices that have edges to . To remove them, we have to remove vertices with edge to them. And so on. Basically, to remove , we have to remove all vertices that are reachable from  on the transposed directed graph. Since  is not reachable from , it doesn't have to be removed before . So we can first remove all the required vertices, then remove , then continue removing vertices until we are able to remove .By switching  and  in the description of that construction, we can obtain the construction for  before .Thus, we reduced the problem to a rather well-known one. Calculate the number of reachable pairs of vertices in a directed graph.As far as I know, it's not known to be solvable in sub-quadratic time. And we are not given a specific graph. Yes, it's obviously acyclic, but turns out every acyclic graph can be made into a test for this problem. You just have to make  equal to the number of the outgoing edges for each .Somehow we are still given  vertices and edges.If you are more familiar with that problem, you might know that you can use bitset to solve it. In particular, let  be a bitset such that  if  if reachable from . Then you can initialize  for all vertices and propagate the knowledge in reverse topological order by applying  for all edges .Unfortunately, that requires  memory, and  bits is over a gigabyte.Let's use of my favorite tricks to make a solution with  memory and the same complexity. Man, I love that trick. Process vertices in batches of . Let's calculate which vertices can reach vertices from  to . The algorithm is basically the same. For each vertex, store a smaller bitset of size  (also known as an unsigned long long). Initialize the bitset for  vertices from the batch and propagate the same way for all  vertices. Now just add up the number of ones in each bitset (__builtin_popcountll). Proceed to the next batch.That makes it  iterations of a  algorithm. This might require some constant optimizations. In particular, I suggest not to use dfs inside the iteration, since the recursion makes it really slow. You might iterate over a vertex in reverse topological order and its outgoing edges. Or, which is way faster, unroll that graph into a list of edges and iterate over it directly.", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define forn(i, n) for(int i = 0; i < int(n); i++) \n\ntypedef unsigned long long uli;\n\nint main(){\n    int t;\n    scanf(\"%d\", &t);\n    while (t--){\n        int n, m;\n        scanf(\"%d%d\", &n, &m);\n        vector<int> a(n);\n        forn(i, n) scanf(\"%d\", &a[i]);\n        vector<vector<int>> g(n);\n        forn(i, m){\n            int v, u;\n            scanf(\"%d%d\", &v, &u);\n            --v, --u;\n            g[v].push_back(u);\n            g[u].push_back(v);\n        }\n        vector<char> rem(n);\n        vector<int> d(n);\n        forn(i, n) d[i] = g[i].size();\n        queue<int> q;\n        forn(i, n) if (a[i] == d[i]) q.push(i);\n        vector<pair<int, int>> ord;\n        while (!q.empty()){\n            int v = q.front();\n            q.pop();\n            rem[v] = true;\n            for (int u : g[v]) if (!rem[u]){\n                --d[u];\n                ord.push_back({v, u});\n                if (d[u] == a[u])\n                    q.push(u);\n            }\n        }\n        reverse(ord.begin(), ord.end());\n        vector<uli> mask(n);\n        long long ans = n * 1ll * (n + 1) / 2;\n        for (int l = 0; l < n; l += 64){\n            int r = min(n, l + 64);\n            for (int i = l; i < r; ++i)\n                mask[i] = 1ull << (i - l);\n            for (const pair<int, int> &it : ord)\n                mask[it.first] |= mask[it.second];\n            forn(i, n){\n                ans -= __builtin_popcountll(mask[i]);\n                mask[i] = 0;\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}