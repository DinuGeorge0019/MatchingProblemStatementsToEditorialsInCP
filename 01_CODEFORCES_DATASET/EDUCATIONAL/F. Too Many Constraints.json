{"link": "https://codeforces.com//contest/1697/problem/F", "problemId": "1427645", "shortId": "1697F", "contest_number": "1697", "name": "F. Too Many Constraints", "statement": "You are asked to build an array , consisting of  integers, each element should be from  to .The array should be non-decreasing ( for all  from  to ). You are also given additional constraints on it. Each constraint is of one of three following types:   :   be equal to ;  :  should be less than or equal to ;  :  should be greater than or equal to . Build any non-decreasing array that satisfies all constraints or report that no such array exists.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains three integers  and  (; ; ). The -th of the next  lines contains a description of a constraint. Each constraint is of one of three following types:     (; ):   be equal to ;   (; ):  should be less than or equal to ;   (; ):  should be greater than or equal to .  The sum of  over all testcases doesn't exceed . The sum of  over all testcases doesn't exceed .", "output": "For each testcase, determine if there exists a non-decreasing array that satisfies all conditions. If there is no such array, then print . Otherwise, print any valid array\u00a0\u2014  integers from  to .", "tutorial": "Imagine there were no constraints of the second or the third types. Then it would be possible to solve the problem with some greedy algorithm. Unfortunately, when both these constraints are present, it's not immediately clear how to adapt the greedy.Dynamic programming is probably also out of question, because you can't maintain all possible cuts between equal values on each prefix.Thus, let's try to make a graph problem out of this. Who knows, maybe a flow or something else could work.Create  nodes for each position. Let the -th of them on the -th position represent the condition of kind \"is  equal to ?\". Then all constraints can be described as edges on this graph. Binary variables, restrictive edges. Surely, this is 2-SAT.Connect the pairs of values that satisfy each constraint. Add the edges between the adjacent positions to enforce the restriction on the non-decreasing order. Prohibit each position to be assigned to multiple values. Force each position to be assigned at least one value. Huh, it's not that easy. That's where the 2-SAT idea fails. We want the conditions of form . But that is not allowed, since 2-SAT has to have two variables in a clause.That's where the main idea of the problem comes up. Instead of making our nodes  represent , let's make them  and try building the graph again.If , then all nodes  for  will be true, and the rest will be false. So if  is false, then  is false. That will enforce the validity of the nodes themselves.First, the order. If  is true, then  is true.The first type of constraints.  is basically the same as ( or ). For our conditions, it's rather ((not ) or ).The second type of constraints. . Let  be greater than or equal to some . Then, for this constraint to hold,  should be no greater than . Thus, if  is true, then  should be false. Same for  and  swapped.The third type of constraints is similar. . Let  be less than or equal to some . Then, for this constraint to hold,  should be greater than or equal to . Thus, if  is false, then  should be true. Same for  and  swapped.And that's it. Solve the 2-SAT and restore the answer. I can advise making not  but actually  nodes for  and force the values to be between  and . That will simplify the checks while adding the constraints.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nstruct constraint{\n\tint tp, i, j, x;\n};\n\nvector<vector<int>> g, tg;\nvector<char> used;\nvector<int> clr, ord;\n\nvoid ts(int v){\n\tused[v] = true;\n\tfor (int u : g[v]) if (!used[u])\n\t\tts(u);\n\tord.push_back(v);\n}\n\nvoid dfs(int v, int k){\n\tclr[v] = k;\n\tfor (int u : tg[v]) if (clr[u] == -1)\n\t\tdfs(u, k);\n}\n\nvoid either(int x, int y){\n\tg[x ^ 1].push_back(y);\n\tg[y ^ 1].push_back(x);\n\ttg[y].push_back(x ^ 1);\n\ttg[x].push_back(y ^ 1);\n}\n\nvoid implies(int x, int y){\n\teither(x ^ 1, y);\n}\n\nvoid must(int x){\n\teither(x, x);\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\tforn(_, t){\n\t\tint n, m, k;\n\t\tscanf(\"%d%d%d\", &n, &m, &k);\n\t\tvector<constraint> c(m);\n\t\tforn(i, m){\n\t\t\tscanf(\"%d%d\", &c[i].tp, &c[i].i);\n\t\t\tif (c[i].tp != 1) scanf(\"%d\", &c[i].j);\n\t\t\tscanf(\"%d\", &c[i].x);\n\t\t\t--c[i].i, --c[i].j;\n\t\t}\n\t\tint vts = n * (k + 2);\n\t\tg.assign(2 * vts, vector<int>());\n\t\ttg.assign(2 * vts, vector<int>());\n\t\tforn(i, n){\n\t\t\tforn(j, (k + 2) - 1)\n\t\t\t\timplies(2 * (i * (k + 2) + j + 1) + 1, 2 * (i * (k + 2) + j) + 1);\n\t\t\tmust(2 * (i * (k + 2) + 1) + 1);\n\t\t\tmust(2 * (i * (k + 2) + k + 1));\n\t\t}\n\t\tforn(i, n - 1) forn(j, k + 2){\n\t\t\timplies(2 * (i * (k + 2) + j) + 1, 2 * ((i + 1) * (k + 2) + j) + 1);\n\t\t}\n\t\tforn(i, m){\n\t\t\tif (c[i].tp == 1)\n\t\t\t\teither(2 * (c[i].i * (k + 2) + c[i].x + 1) + 1, 2 * (c[i].i * (k + 2) + c[i].x));\n\t\t\telse if (c[i].tp == 2){\n\t\t\t\tfor (int a = max(1, c[i].x - k); a <= min(k, c[i].x - 1); ++a){\n\t\t\t\t\timplies(2 * (c[i].i * (k + 2) + a) + 1, 2 * (c[i].j * (k + 2) + (c[i].x - a) + 1));\n\t\t\t\t\timplies(2 * (c[i].j * (k + 2) + a) + 1, 2 * (c[i].i * (k + 2) + (c[i].x - a) + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor (int a = max(1, c[i].x - k); a <= min(k, c[i].x - 1); ++a){\n\t\t\t\t\timplies(2 * (c[i].i * (k + 2) + a + 1), 2 * (c[i].j * (k + 2) + (c[i].x - a)) + 1);\n\t\t\t\t\timplies(2 * (c[i].j * (k + 2) + a + 1), 2 * (c[i].i * (k + 2) + (c[i].x - a)) + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tused.assign(2 * vts, 0);\n\t\tord.clear();\n\t\tforn(i, used.size()) if (!used[i]) ts(i);\n\t\treverse(ord.begin(), ord.end());\n\t\tclr.assign(2 * vts, -1);\n\t\tint cc = 0;\n\t\tfor (int v : ord) if (clr[v] == -1){\n\t\t\tdfs(v, cc);\n\t\t\t++cc;\n\t\t}\n\t\tvector<int> vals(vts);\n\t\tbool ans = true;\n\t\tforn(i, vts){\n\t\t\tif (clr[2 * i] == clr[2 * i + 1]){\n\t\t\t\tans = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvals[i] = (clr[2 * i] < clr[2 * i + 1]);\n\t\t}\n\t\tif (!ans){\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tforn(i, n){\n\t\t\tint lst = 0;\n\t\t\tforn(j, k + 2) if (vals[i * (k + 2) + j])\n\t\t\t\tlst = j;\n\t\t\tprintf(\"%d \", lst);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}