{"link": "https://codeforces.com//contest/1606/problem/C", "problemId": "1163614", "shortId": "1606C", "contest_number": "1606", "name": "C. Banknotes", "statement": "In Berland,  different types of banknotes are used. Banknotes of the -th type have denomination  burles (burles are the currency used in Berland); the denomination of banknotes of the first type is exactly .Let's denote  as the minimum number of banknotes required to represent exactly  burles. For example, if the denominations of banknotes used in Berland are ,  and , then :  banknotes with denomination of  burle and  banknotes with denomination of  burles can be used to represent exactly  burles, and there's no way to do it with fewer banknotes.For a given integer , find the minimum positive number of burles  that cannot be represented with  or fewer banknotes (that is, ).", "input": "The first line contains a single integer  ()\u00a0\u2014 number of test cases. The first line of each test case contains two integers  and  (). The next line contains  integers  ().", "output": "For each test case, print one integer\u00a0\u2014 the minimum positive number of burles  that cannot be represented with  or fewer banknotes.", "tutorial": "First of all, let's find out how to calculate . This can be done greedily, let's iterate from the higher denominations to the lower ones, the number of banknotes of -th type is equal to  (the value of  here changes to reflect that we have already taken some banknotes; that is, we subtract  from  each time, which is the same as taking  modulo ). We can see that after we process the -th type of banknotes, the condition  holds, which means that the number of banknotes of -th type does not exceed  (except in the case of ).Now we can find the minimum number  such that . Let  be the number of banknotes that still remains to take, initially equal to  (because we want  to be at least ). Let's iterate from the lower denominations to the highest ones, the number of banknotes of -th type we take should be equal to \u00a0\u2014 the minimum of how many we need to take and how many we are allowed to take, so as not to break the minimality of the function .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    k += 1;\n    vector<int> a(n);\n    for (int& x : a) {\n      cin >> x;\n      int cur = 1;\n      while (x--) cur *= 10;\n      x = cur;\n    }\n    long long res = 0;\n    for (int i = 0; i < n; i++) {\n      int cnt = k;\n      if (i + 1 < n) cnt = min(cnt, a[i + 1] / a[i] - 1);\n      res += a[i] * 1LL * cnt;\n      k -= cnt;\n    }\n    cout << res << '\\n';\n  }\n} ", "interactive": false, "noSolution": false, "noTutorial": false}