{"link": "https://codeforces.com//contest/1743/problem/D", "problemId": "1590319", "shortId": "1743D", "contest_number": "1743", "name": "D. Problem with Random Tests", "statement": "You are given a string  consisting of  characters. Each character of  is either  or .A substring of  is a contiguous subsequence of its characters.You have to choose two substrings of  (possibly intersecting, possibly the same, possibly non-intersecting \u2014 just any two substrings). After choosing them, you calculate the value of the chosen pair of substrings as follows:  let  be the first substring,  be the second chosen substring, and  be the integer such that  is its binary representation (for example, if  is , );  the value is the  of  and . Calculate the maximum possible value you can get, and print it .", "input": "The first line contains one integer  \u2014 the number of characters in . The second line contains  itself, consisting of exactly  characters  and/or . . This problem has exactly  tests. Tests from  to  are the examples; tests from  to  are generated randomly. In tests from  to , ; in tests from  to , ; in tests from  to , .  ", "output": "Print the maximum possible value you can get .", "tutorial": "The first observation we need is that we can choose two prefixes of  as the substrings used in forming the results. This can be proved easily: suppose we chose a substring which does not contain the leftmost character of ; if we expand it to the left, the answer won't become worse. So, it is optimal to choose two prefixes of  as the substrings.Furthermore, one of these prefixes must be  itself: if the leftmost index of  is , the length of the answer won't exceed , but the only way to have a  in the -th bit of the answer is to choose a prefix of  where the -th character (from the right) is ; and there is only one such prefix of , which is  itself.So, now we can solve the problem in  \u2014 try to combine all prefixes of  with  itself, and choose the one that yields the best answer. To speed this up, we need to somehow cut down on the number of prefixes of  we check.Let's look at the first block of 's in . The next character after this block is ; since we take  as one of the substring, in order to get  instead of  in the corresponding position of the answer, we need to choose a prefix which has  in that position. This  represents one of the 's from the first block of 's, since only one of them can shift to that position. So, we need to check only the prefixes such that, by using them, we shift some character  from the first block to the position of the first  after this block. Since the tests are random, the expected length of the first block of 's is  (furthermore, even the probabiliy that its length is  or bigger is about ), so the expected number of prefixes we need to check is also . Thus, the expected runtime of our solution is .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nchar buf[1000043];\n\nstring normalize(const string& v)\n{\n    int cnt = 0;\n    while(cnt < v.size() && v[cnt] == '0') cnt++;\n    if(cnt == v.size()) return \"0\";\n    return v.substr(cnt, int(v.size()) - cnt);\n}\n\nstring operator |(const string& a, const string& b)\n{\n    int sz = max(a.size(), b.size());\n    string ans(sz, '0');\n    for(int i = 0; i < a.size(); i++)\n        if(a[i] == '1') ans[i + sz - int(a.size())] = '1';\n    for(int i = 0; i < b.size(); i++)\n        if(b[i] == '1') ans[i + sz - int(b.size())] = '1';    \n    return normalize(ans);\n}\n\nbool better(const string& a, const string& b)\n{\n    if(a.size() != b.size()) return a.size() > b.size();\n    return a > b;\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    string s;\n    scanf(\"%s\", buf);\n    s = buf;\n    string ans = s | s;\n    int pos1 = s.find(\"1\");\n    if(pos1 != string::npos)\n    {\n        int pos2 = s.find(\"0\", pos1);\n        if(pos2 != string::npos)\n        {\n            int cur = pos1;\n            int not_needed = 0;\n            while(true)\n            {                \n                if(cur == n || (s[cur] == '1' && cur > pos2)) break;\n                string nw = s | s.substr(pos1, n - pos1 - not_needed);\n                if(better(nw, ans)) ans = nw;\n                cur++;\n                not_needed++;\n            }\n        }\n    }\n    puts(ans.c_str());\n}", "interactive": false, "noSolution": false, "noTutorial": false}