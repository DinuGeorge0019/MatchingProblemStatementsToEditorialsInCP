{"link": "https://codeforces.com//contest/1082/problem/F", "problemId": "64168", "shortId": "1082F", "contest_number": "1082", "name": "F. Speed Dial", "statement": "Polycarp's phone book contains  phone numbers, each of them is described by  \u2014 the number itself and  \u2014 the number of times Polycarp dials it in daily.Polycarp has just bought a brand new phone with an amazing  feature! More precisely,  buttons on it can have a number assigned to it (not necessary from the phone book). To enter some number Polycarp can press one of these  buttons and then finish the number using usual digit buttons (entering a number with only digit buttons is also possible). button can only be used when no digits are entered. No button can have its number reassigned.What is the minimal total number of  Polycarp can achieve after he assigns numbers to  buttons and enters each of the numbers from his phone book the given number of times in an optimal way?", "input": "The first line contains two integers  and  (, ) \u2014 the amount of numbers in Polycarp's phone book and the number of  buttons his new phone has. The -th of the next  lines contain a string  and an integer  , where  is a non-empty string of digits from  to  inclusive (the -th number), and  is the amount of times it will be dialed, respectively. It is guaranteed that the total length of all phone numbers will not exceed .", "output": "Print a single integer \u2014 the minimal total number of  Polycarp can achieve after he assigns numbers to  buttons and enters each of the numbers from his phone book the given number of times in an optimal way.", "tutorial": "The first thing to come to one's mind is dynamic programming on a trie. The most naive of the solutions take , where  is the total length of strings.I'll introduce the faster approach.Let  be the solution for subtree of the vertex  with  buttons remaining and  is the closest ancestor vertex with the button used in it.This dp will be recalced via the other dp.Let  be the same thing as  but only  first children of  is taken into consideration and  doesn't have a button in it.Give  buttons to the current child, then update  with  + . will then have two options:  for  having button in it and  for  not having button in it. has  transitions and  states. has  total transitions and also  states.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 500 + 7;\nconst int M = 11;\nconst int INF = 1e9;\n\nstruct node{\n\tint nxt[10];\n\tint cnt;\n\tnode(){\n\t\tmemset(nxt, -1, sizeof(nxt));\n\t\tcnt = 0;\n\t}\n};\n\nnode trie[N];\nint cnt;\nint h[N];\n\nvoid add(string s, int m){\n\tint cur = 0;\n\tforn(i, s.size()){\n\t\tint c = s[i] - '0';\n\t\tif (trie[cur].nxt[c] == -1){\n\t\t\ttrie[cur].nxt[c] = cnt;\n\t\t\th[cnt] = h[cur] + 1;\n\t\t\t++cnt;\n\t\t}\n\t\tcur = trie[cur].nxt[c];\n\t}\n\ttrie[cur].cnt += m;\n}\n\nint n, k;\n\nint dp[N][M][N];\nint dp2[N][M][N][M];\n\nint calc(int x, int rem, int k){\n\tif (dp[x][rem][k] != -1)\n\t\treturn dp[x][rem][k];\n\t\n\tvector<int> ch;\n\tforn(i, 10) if (trie[x].nxt[i] != -1)\n\t\tch.push_back(trie[x].nxt[i]);\n\t\n\tdp[x][rem][k] = INF;\n\tif (rem > 0)\n\t\tdp[x][rem][k] = min(dp[x][rem][k], calc(x, rem - 1, x));\n\t\n\tdp2[x][rem][k][ch.size()] = 0;\n\tfor (int i = int(ch.size()) - 1; i >= 0; --i) forn(z, rem + 1)\n\t\tdp2[x][rem][k][i] = min(dp2[x][rem][k][i], calc(ch[i], z, k) + dp2[x][rem - z][k][i + 1]);\n\t\n\tdp[x][rem][k] = min(dp[x][rem][k], dp2[x][rem][k][0] + (h[x] - h[k]) * trie[x].cnt);\n\t\n\treturn dp[x][rem][k];\n}\n\nint main() {\n\ttrie[0] = node();\n\tcnt = 1;\n\t\n\tcin >> n >> k;\n\tforn(i, n){\n\t\tstring s;\n\t\tint m;\n\t\tcin >> s >> m;\n\t\tadd(s, m);\n\t}\n\t\n\tmemset(dp, -1, sizeof(dp));\n\t\n\tforn(i, N) forn(j, M) forn(l, N) forn(t, M)\n\t\tdp2[i][j][l][t] = INF;\n\t\n\tint ans = calc(0, k, 0);\n\t\n\tcout << ans << endl;\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}