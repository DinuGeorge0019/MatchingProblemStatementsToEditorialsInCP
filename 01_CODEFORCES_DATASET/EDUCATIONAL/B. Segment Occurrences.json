{"link": "https://codeforces.com//contest/1016/problem/B", "problemId": "204437", "shortId": "1016B", "contest_number": "1016", "name": "B. Segment Occurrences", "statement": "You are given two strings  and , both consisting only of lowercase Latin letters.The substring  is the string which is obtained by taking characters  without changing the order.Each of the occurrences of string  in a string  is a position  () such that  ( is the length of string ).You are asked  queries: for the -th query you are required to calculate the number of occurrences of string  in a substring .", "input": "The first line contains three integer numbers ,  and  (, ) \u2014 the length of string , the length of string  and the number of queries, respectively. The second line is a string  (), consisting only of lowercase Latin letters. The third line is a string  (), consisting only of lowercase Latin letters. Each of the next  lines contains two integer numbers  and  () \u2014 the arguments for the -th query.", "output": "Print  lines \u2014 the -th line should contain the answer to the -th query, that is the number of occurrences of string  in a substring .", "tutorial": "Let's take a look at a naive approach: for each query  you iterate over positions  and check if . Okay, this is obviously . Now we notice that there are only  positions for  to start from, we can calculate if there is an occurrence of  starting in this position beforehand in . Thus, we transition to  solution. Finally, we calculate a partial sum array over this occurrence check array and answer each query in .Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 1000 + 7;\n\nint pr[N];\nbool ok[N];\n\nint main() {\n\tint n, m, q;\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tstring s, t;\n\tstatic char buf[N];\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tscanf(\"%s\", buf);\n\tt = buf;\n\t\n\tpr[0] = 0;\n\tforn(i, n - m + 1){\n\t\tbool fl = true;\n\t\tforn(j, m)\n\t\t\tif (s[i + j] != t[j])\n\t\t\t\tfl = false;\n\t\tok[i] = fl;\n\t\tpr[i + 1] = pr[i] + ok[i];\n\t}\n\tfor (int i = max(0, n - m + 1); i < n; ++i){\n\t\tpr[i + 1] = pr[i];\n\t}\n\t\n\tforn(i, q){\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\t--l, r -= m - 1;\n\t\tprintf(\"%d\\n\", r >= l ? pr[r] - pr[l] : 0);\n\t}\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}