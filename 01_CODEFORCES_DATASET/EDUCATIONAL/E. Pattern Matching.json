{"link": "https://codeforces.com//contest/1476/problem/E", "problemId": "881706", "shortId": "1476E", "contest_number": "1476", "name": "E. Pattern Matching", "statement": "You are given  patterns  and  strings . Each pattern  consists of  characters that are either lowercase Latin letters or wildcard characters (denoted by underscores). All patterns are pairwise distinct. Each string  consists of  lowercase Latin letters.A string  matches a pattern  if for each  from  to  either  is a wildcard character or .You are asked to rearrange the patterns in such a way that the first pattern the -th string matches is . You are allowed to leave the order of the patterns unchanged.Can you perform such a rearrangement? If you can, then print any valid order.", "input": "The first line contains three integers ,  and  (, )\u00a0\u2014 the number of patterns, the number of strings and the length of each pattern and string. Each of the next  lines contains a pattern\u00a0\u2014  characters that are either lowercase Latin letters or underscores. All patterns are pairwise distinct. Each of the next  lines contains a string\u00a0\u2014  lowercase Latin letters, and an integer  ()\u00a0\u2014 the index of the first pattern the corresponding string should match.", "output": "Print \"\" if there is no way to rearrange the patterns in such a way that the first pattern that the -th string matches is . Otherwise, print \"\" in the first line. The second line should contain  distinct integers from  to \u00a0\u2014 the order of the patterns. If there are multiple answers, print any of them.", "tutorial": "Let's write down the indices of the pattern that the -th string matches. If  is not among these, then the answer is . Otherwise, all the patterns except  should go in the resulting ordering after .Consider that as a graph. Let's add an edge from  to each of the matches. If you add the edges for all the strings, then the topological ordering of the graph will give you the valid result. If the graph has any cycles in it (you can't topsort it), then there is no answer.To find all the patterns we can use the fact that  is rather small. Consider all the  binary masks of length . Each mask can correspond to a set of positions in the string that are replaced with wildcards. Now, if there is a pattern that is exactly equal to the string with the fixed set of positions replaced by wildcards, then that pattern is a match.To search for an exact match, you can either store all patterns in a map beforehand (or in a sorted array) or build a trie of them. The second version is faster by a factor of  but both solutions should pass easily.Overall complexity:  or .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nstruct pattern{\n  string s;\n  int i;\n};\n\nbool operator <(const pattern &a, const pattern &b){\n  return a.s < b.s;\n}\n\nvector<vector<int>> g;\nvector<int> used, ord;\nbool cyc;\n\nvoid ts(int v){\n  used[v] = 1;\n  for (int u : g[v]){\n    if (used[u] == 0)\n      ts(u);\n    else if (used[u] == 1)\n      cyc = true;\n    if (cyc)\n      return;\n  }\n  used[v] = 2;\n  ord.push_back(v);\n}\n\nint main() {\n    cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<pattern> p(n);\n  g.assign(n, vector<int>());\n  forn(i, n){\n    cin >> p[i].s;\n    p[i].i = i;\n  }\n  sort(p.begin(), p.end());\n  pattern nw;\n  nw.s = string(k, '_');\n  forn(i, m){\n    string cur;\n    int mt;\n    cin >> cur >> mt;\n    --mt;\n    bool ok = false;\n    forn(mask, 1 << k){\n      forn(j, k)\n        nw.s[j] = ((mask >> j) & 1 ? cur[j] : '_');\n      auto it = lower_bound(p.begin(), p.end(), nw);\n      if (it != p.end() && it->s == nw.s){\n        if (it->i != mt)\n          g[mt].push_back(it->i);\n        else\n          ok = true;\n      }\n    }\n    if (!ok){\n      puts(\"NO\");\n      return 0;\n    }\n  }\n  used.assign(n, 0);\n  cyc = false;\n  ord.clear();\n  forn(i, n) if (!used[i]){\n    ts(i);\n    if (cyc){\n      cout << \"NO\\n\";\n      return 0;\n    }\n  }\n  reverse(ord.begin(), ord.end());\n  cout << \"YES\\n\";\n  forn(i, n)\n    cout << ord[i] + 1 << \" \";\n  cout << \"\\n\";\n  return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}