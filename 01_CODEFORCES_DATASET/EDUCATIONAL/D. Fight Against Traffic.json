{"link": "https://codeforces.com//contest/954/problem/D", "problemId": "167341", "shortId": "954D", "contest_number": "954", "name": "D. Fight Against Traffic", "statement": "Little town Nsk consists of  junctions connected by  bidirectional roads. Each road connects two distinct junctions and no two roads connect the same pair of junctions. It is possible to get from any junction to any other junction by these roads. The distance between two junctions is equal to the minimum possible number of roads on a path between them.In order to improve the transportation system, the city council asks mayor to build one new road. The problem is that the mayor has just bought a wonderful new car and he really enjoys a ride from his home, located near junction  to work located near junction . Thus, he wants to build a new road in such a way that the distance between these two junctions won't decrease. You are assigned a task to compute the number of pairs of junctions that are not connected by the road, such that if the new road between these two junctions is built the distance between  and  won't decrease.", "input": "The firt line of the input contains integers , ,  and  (, , , )\u00a0\u2014 the number of junctions and the number of roads in Nsk, as well as the indices of junctions where mayors home and work are located respectively. The -th of the following  lines contains two integers  and  (, ), meaning that this road connects junctions  and  directly. It is guaranteed that there is a path between any two junctions and no two roads connect the same pair of junctions.", "output": "Print one integer\u00a0\u2014 the number of pairs of junctions not connected by a direct road, such that building a road between these two junctions won't decrease the distance between junctions  and .", "tutorial": "Let's use bfs to calculate the smallest distances to all vertices from the vertex  and from the vertex . These will be  and  for all . is the the current smallest distance between  and . What you need is to iterate over all pairs  and check if the edge between them doesn't exist and neither  nor  is smaller than .Overall complexity: .", "solution": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MN 1005\nusing namespace std;\nstruct edge{int nex,to;}e[MN<<1];\nint hr[MN],dep[2][MN],q[MN];\nint hd,tl,S,T,pin,n,m,ans;\nbool mp[MN][MN];\n\ninline int read()\n{\n\tint n=0,f=1; char c=getchar();\n\twhile (c<'0' || c>'9') {if(c=='-')f=-1; c=getchar();}\n\twhile (c>='0' && c<='9') {n=n*10+c-'0'; c=getchar();}\n\treturn n*f;\n}\ninline void ins(int x,int y) {e[++pin]=(edge){hr[x],y}; hr[x]=pin;}\n\nvoid bfs(int SS,int g)\n{\n//\tmemset(u,0,sizeof(dep));\n\tregister int i,x;\n\tfor (dep[g][q[hd=tl=1]=SS]=1;hd<=tl;++hd)\n\t\tfor (x=q[hd],i=hr[x];i;i=e[i].nex)\n\t\t\tif (!dep[g][e[i].to])\n\t\t\t\tdep[g][e[i].to]=dep[g][x]+1,q[++tl]=e[i].to;\n}\n\nint main()\n{\n\tregister int i,j,x,y;\n\tn=read(); m=read(); S=read(); T=read();\n\tfor (i=1;i<=m;++i)\n\t\tx=read(),y=read(),\n\t\tins(x,y),ins(y,x),\n\t\tmp[x][y]=mp[y][x]=true;\n\tbfs(S,0); bfs(T,1);\n\tfor (i=1;i<=n;++i) --dep[0][i],--dep[1][i];\n\tfor (i=1;i<n;++i)\n\t\tfor (j=i+1;j<=n;++j)\n\t\t\tif (!mp[i][j])\n\t\t\t\tif (min(dep[0][i]+dep[1][j]+1,dep[1][i]+dep[0][j]+1)>=dep[0][T]) ++ans;\n\tprintf(\"%d\",ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}