{"link": "https://codeforces.com//contest/1716/problem/E", "problemId": "1494204", "shortId": "1716E", "contest_number": "1716", "name": "E. Swap and Maximum Block", "statement": "You are given an array of length . The elements of the array are numbered from  to .You have to process  queries to this array. In the -th query, you will be given an integer  (). To process the query, you should do the following:  for every  , do the following: if the -th element was already swapped with some other element , skip it; otherwise, swap  and ;  after that, print the maximum sum over all contiguous subsegments of the array (including the empty subsegment). For example, if the array  is , and , the query is processed as follows:  the -st element wasn't swapped yet, so we swap it with the -rd element;  the -nd element wasn't swapped yet, so we swap it with the -th element;  the -rd element was swapped already;  the -th element was swapped already;  the -th element wasn't swapped yet, so we swap it with the -th element;  the -th element wasn't swapped yet, so we swap it with the -th element. So, the array becomes . The subsegment with the maximum sum is , and the answer to the query is .Note that the queries actually , i.\u2009e. after a query is performed, the array does not return to its original state, and the next query will be applied to the modified array.", "input": "The first line contains one integer  (). The second line contains  integers  (). The third line contains one integer  (). Then  lines follow, the -th of them contains one integer  () describing the -th query.", "output": "For each query, print one integer\u00a0\u2014 the maximum sum over all contiguous subsegments of the array (including the empty subsegment) after processing the query.", "tutorial": "Let's carefully analyze the operation denoted in the query. Since the length of the array is always divisible by , every element will be swapped with some other element. The elements can be split into two groups\u00a0\u2014 the ones whose positions increase by , and the ones whose positions decrease by .Let's find some trait of the elements which will allow us to distinguish the elements of one group from the elements of the other group. The first  elements will be shifted to the right, the next  elements will be shifted to the left, the next  elements will be shifted to the right, etc. If we look at the binary representations of integers , then we can see that the first  elements have  in the -th bit, the next  elements have  in the -th bit, the next  elements have  in the -th bit, and so on. So, if we consider the positions of elements as -indexed, then the operation can be described as follows: \"Let the position of the element be . If the -th bit in  is ,  gets increased by , otherwise  gets decreased by \". What does it look like? Actually, it is just  (where  denotes XOR).So, each query can be represented as \"swap  with  for some integer \". The combination of two queries can also be represented with a single query; in fact, the state of the array can be denoted as the XOR of all  from the previous queries.Now, let's try to solve the following problem: for every , calculate the maximum sum of subsegment if every element  is swapped with . To solve this problem, we can use a segment tree.First of all, we need to understand how to solve the problem of finding the maximum sum on subsegment using a segment tree. To do this, we should store the following four values in each vertex of the segment tree:  \u00a0\u2014 the sum of elements on the segment denoted by the vertex;  \u00a0\u2014 the maximum sum of elements on the prefix of the segment denoted by the vertex;  \u00a0\u2014 the maximum sum of elements on the suffix of the segment denoted by the vertex;  \u00a0\u2014 the answer on the segment. If some vertex of the segment tree has two children, these values for it can be easily calculated using the values from the children. So, we can \"glue\" two segments represented by the vertices together, creating a new vertex representing the concatenation of these segments.Okay, but how do we apply XOR to this? For every vertex of the segment tree, let's create several versions; the -th version of the vertex  represents the segment corresponding to this vertex if we apply swapping query with  to it. For a vertex  representing the segment of length , we can use the following relation to get all its versions (here, we denote  as the -th version of , and  and  as the children of ):  if , then ;  else ; The function  here denotes the \"glueing together\" of two vertices we described above.Now let's try to analyze how many versions of each vertex we need. For the root, we will need all  versions. For its children, we need only  versions. For the children of the children of the root, we need only  versions, and so on; so, overall, the total number of versions is only , and each version can be constructed in , so the solution works in .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;     \nconst int K = 18;\n\nstruct node\n{\n    long long sum, pref, suff, ans;\n    \n    node(const node& l, const node& r)\n    {                                                                                          \n        sum = l.sum + r.sum;\n        pref = max(l.pref, l.sum + r.pref);\n        suff = max(r.suff, r.sum + l.suff);\n        ans = max(max(l.ans, r.ans), l.suff + r.pref);\n    }\n\n    node(int x)\n    {\n        sum = x;\n        pref = suff = ans = max(x, 0);\n    }\n\n    node() {};\n};\n\nint a[1 << K];\nvector<node> tree[2 << K];  \n\nvoid build(int v, int l, int r)\n{\n    tree[v].resize(r - l);\n    if(l == r - 1)\n    {\n        tree[v][0] = node(a[l]);  \n    }\n    else\n    {\n        int m = (l + r) / 2;\n        build(v * 2 + 1, l, m);\n        build(v * 2 + 2, m, r);\n        for(int i = 0; i < m - l; i++)\n        {\n            tree[v][i] = node(tree[v * 2 + 1][i], tree[v * 2 + 2][i]);\n            tree[v][i + (m - l)] = node(tree[v * 2 + 2][i], tree[v * 2 + 1][i]);    \n        }\n    }\n}\n\nint main()\n{            \n    int n;\n    scanf(\"%d\", &n);\n    int m = (1 << n);\n    for(int i = 0; i < m; i++)\n    {\n        scanf(\"%d\", &a[i]);\n    }\n    build(0, 0, m);\n    int q;\n    scanf(\"%d\", &q);\n    int cur = 0;\n    for(int i = 0; i < q; i++)\n    {\n        int x;\n        scanf(\"%d\", &x);\n        cur ^= (1 << x);\n        printf(\"%lld\\n\", tree[0][cur].ans);\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}