{"link": "https://codeforces.com//contest/1093/problem/E", "problemId": "270226", "shortId": "1093E", "contest_number": "1093", "name": "E. Intersection of Permutations", "statement": "You are given two permutations  and , both consisting of  elements. Permutation of  elements is such a integer sequence that each value from  to  appears exactly once in it.You are asked to perform two types of queries with them:   \u2014 calculate the number of values which appear in both segment  of positions in permutation  and segment  of positions in permutation ;   \u2014 swap values on positions  and  in permutation . Print the answer for each query of the first type.It is guaranteed that there will be at least one query of the first type in the input.", "input": "The first line contains two integers  and  (, ) \u2014 the number of elements in both permutations and the number of queries. The second line contains  integers  () \u2014 permutation . It is guaranteed that each value from  to  appears in  exactly once. The third line contains  integers  () \u2014 permutation . It is guaranteed that each value from  to  appears in  exactly once. Each of the next  lines contains the description of a certain query. These are either:    (, );   (, ). ", "output": "Print the answers for the queries of the first type, each answer in the new line \u2014 the number of values which appear in both segment  of positions in permutation  and segment  of positions in permutation .", "tutorial": "At first, time limit was not that tight for the problem. We didn't want any sqrt, bitset or straight up  solution to pass (and it's close to none to pass). Jury solution works faster than twice the time limit so we decided 6 seconds is alright.The task is purely about implementation. You renumerate numbers in permutations so that the queries are  and then have the structure to make update in point and sum on rectangle. Renumeration in my case was making the first permutation into identity one and changing the numbers in second appropriately. You can choose the structure you want, I'll tell about the one I use when the queries are offline. For online the common technique is having  BITs, each with treap in it (ordered_set template from pbds is usually enough). For offline you can precalculate the values to fall into each BIT beforehand and do BIT on these values inside. Preprocess all the update and get queries , adding  into all the BITs  will fall into. Then sort them and leave only unique occurrences.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\nint n, m;\nint a[N], b[N], pos[N];\n\nvector<int> f[N];\nvector<int> vals[N];\n\nvoid addupd(int x, int y){\n\tfor (int i = x; i < N; i |= i + 1)\n\t\tvals[i].push_back(y);\n}\n\nvoid addget(int x, int y){\n\tif (x < 0 || y < 0) return;\n\tfor (int i = x; i >= 0; i = (i & (i + 1)) - 1)\n\t\tvals[i].push_back(y);\n}\n\nvoid upd(int x, int y, int val){\n\tfor (int i = x; i < N; i |= i + 1)\n\t\tfor (int j = lower_bound(vals[i].begin(), vals[i].end(), y) - vals[i].begin(); j < int(f[i].size()); j |= j + 1)\n\t\t\tf[i][j] += val;\n}\n\nint get(int x, int y){\n\tif (x < 0 || y < 0) return 0;\n\tint res = 0;\n\tfor (int i = x; i >= 0; i = (i & (i + 1)) - 1)\n\t\tfor (int j = lower_bound(vals[i].begin(), vals[i].end(), y) - vals[i].begin(); j >= 0; j = (j & (j + 1)) - 1)\n\t\t\tres += f[i][j];\n\treturn res;\n}\n\nstruct query{\n\tint t, la, ra, lb, rb;\n\tquery(){};\n};\n\nquery q[N];\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tforn(i, n){\n\t\tscanf(\"%d\", &a[i]);\n\t\t--a[i];\n\t\tpos[a[i]] = i;\n\t}\n\t\n\tforn(i, n){\n\t\tscanf(\"%d\", &b[i]);\n\t\t--b[i];\n\t\tb[i] = pos[b[i]];\n\t}\n\t\n\tforn(i, m){\n\t\tscanf(\"%d\", &q[i].t);\n\t\tif (q[i].t == 1){\n\t\t\tscanf(\"%d%d%d%d\", &q[i].la, &q[i].ra, &q[i].lb, &q[i].rb);\n\t\t\t--q[i].la, --q[i].ra, --q[i].lb, --q[i].rb;\n\t\t}\n\t\telse{\n\t\t\tscanf(\"%d%d\", &q[i].lb, &q[i].rb);\n\t\t\t--q[i].lb, --q[i].rb;\n\t\t}\n\t}\n\t\n\tvector<int> tmp(b, b + n);\n\t\n\tforn(i, n) addupd(i, b[i]);\n\tforn(i, m){\n\t\tif (q[i].t == 1){\n\t\t\taddget(q[i].rb, q[i].ra);\n\t\t\taddget(q[i].lb - 1, q[i].ra);\n\t\t\taddget(q[i].rb, q[i].la - 1);\n\t\t\taddget(q[i].lb - 1, q[i].la - 1);\n\t\t}\n\t\telse{\n\t\t\taddupd(q[i].lb, b[q[i].lb]);\n\t\t\taddupd(q[i].rb, b[q[i].rb]);\n\t\t\tswap(b[q[i].lb], b[q[i].rb]);\n\t\t\taddupd(q[i].lb, b[q[i].lb]);\n\t\t\taddupd(q[i].rb, b[q[i].rb]);\n\t\t}\n\t}\n\t\n\tforn(i, n) b[i] = tmp[i];\n\t\n\tforn(i, N){\n\t\tsort(vals[i].begin(), vals[i].end());\n\t\tvals[i].resize(unique(vals[i].begin(), vals[i].end()) - vals[i].begin());\n\t\tf[i].resize(vals[i].size(), 0);\n\t}\n\t\n\tforn(i, n)\n\t\tupd(i, b[i], 1);\n\t\n\tforn(i, m){\n\t\tif (q[i].t == 1){\n\t\t\tint res = 0;\n\t\t\tres += get(q[i].rb, q[i].ra);\n\t\t\tres -= get(q[i].lb - 1, q[i].ra);\n\t\t\tres -= get(q[i].rb, q[i].la - 1);\n\t\t\tres += get(q[i].lb - 1, q[i].la - 1);\n\t\t\tprintf(\"%d\\n\", res);\n\t\t}\n\t\telse{\n\t\t\tupd(q[i].lb, b[q[i].lb], -1);\n\t\t\tupd(q[i].rb, b[q[i].rb], -1);\n\t\t\tswap(b[q[i].lb], b[q[i].rb]);\n\t\t\tupd(q[i].lb, b[q[i].lb], 1);\n\t\t\tupd(q[i].rb, b[q[i].rb], 1);\n\t\t}\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}