{"link": "https://codeforces.com//contest/1359/problem/E", "problemId": "634676", "shortId": "1359E", "contest_number": "1359", "name": "E. Modular Stability", "statement": "We define  as the remainder of division of  by  ( operator in C++ or Java,  operator in Pascal).Let's call an array of positive integers   if for every permutation  of integers from  to , and for every non-negative integer , the following condition is met:  That is, for each non-negative integer , the value of  does not change if we reorder the elements of the array .For two given integers  and , calculate the number of  arrays  such that .", "input": "The only line contains two integers  and  ().", "output": "Print one integer \u2014 the number of  arrays  such that . Since the answer may be large, print it modulo .", "tutorial": "We claim that the array is stable if and only if all elements are divisible by its minimum. The proof of this fact will be at the end of the editorial.To calculate the number of stable arrays now, we need to iterate on the minimum in the array and choose the remaining elements so that they are multiples of it. If the minimum is , then the resulting elements should be divisible by . There are  such numbers between  and , and we have to choose  elements out of  (since  is already chosen). The number of ways to do it can be calculated by precomputing factorials modulo , since it is a binomial coefficient.On the one hand, since , if all elements in the array are divisible by some element, nothing depends on the order of these elements.On the other hand, suppose there exists an element  such that it is not divisible by . Let's take  and two following reorders of the array :  and . For the first array, we get , which is non-zero; and for the second array, , so the result is zero.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 500043;\nconst int MOD = 998244353;\n\nint fact[N];\n\nint add(int x, int y)\n{\n\tx += y;\n\twhile(x >= MOD) x -= MOD;\n\twhile(x < 0) x += MOD;\n\treturn x;\n}\n\nint mul(int x, int y)\n{\n\treturn (x * 1ll * y) % MOD;\n}\n\nint binpow(int x, int y)\n{\n\tint z = 1;\n\twhile(y > 0)\n\t{\n\t\tif(y % 2 == 1)\n\t\t\tz = mul(z, x);\n\t\tx = mul(x, x);\n\t\ty /= 2;\n\t}\n\treturn z;\n}\n\nint inv(int x)\n{\n\treturn binpow(x, MOD - 2);\n}\n\nint divide(int x, int y)\n{\n\treturn mul(x, inv(y));\n}\n\nvoid precalc()\n{\n\tfact[0] = 1;\n\tfor(int i = 1; i < N; i++)\n\t\tfact[i] = mul(i, fact[i - 1]);\n}\n\nint C(int n, int k)\n{\n\tif(k > n) return 0;\n\treturn divide(fact[n], mul(fact[n - k], fact[k]));\n}\n\nint main()\n{\n\tint n, k;\n\tcin >> n >> k;\n\tint ans = 0;\n\tprecalc();\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint d = n / i;\n\t\tans = add(ans, C(d - 1, k - 1));\n\t}\n\tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}