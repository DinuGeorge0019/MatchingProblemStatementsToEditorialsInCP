{"link": "https://codeforces.com//contest/1657/problem/F", "problemId": "1339156", "shortId": "1657F", "contest_number": "1657", "name": "F. Words on Tree", "statement": "You are given a tree consisting of  vertices, and  triples , where  and  are integers from  to , and  is a string .You want to write a lowercase Latin letter on each vertex in such a way that, for each of  given triples, at least one of the following conditions holds:  if you write out the letters on the vertices on the simple path from  to  in the order they appear on this path, you get the string ;  if you write out the letters on the vertices on the simple path from  to  in the order they appear on this path, you get the string . Find any possible way to write a letter on each vertex to meet these constraints, or report that it is impossible.", "input": "The first line contains two integers  and  (; ) \u2014 the number of vertices in the tree and the number of triples, respectively. Then  lines follow; the -th of them contains two integers  and  (; ) \u2014 the endpoints of the -th edge. These edges form a tree. Then  lines follow; the -th of them contains two integers  and , and a string  consisting of lowercase Latin letters. The length of  is equal to the number of vertices on the simple path between  and . Additional constraint on the input: .", "output": "If there is no way to meet the conditions on all triples, print . Otherwise, print  in the first line, and a string of  lowercase Latin letters in the second line; the -th character of the string should be the letter you write on the -th vertex. If there are multiple answers, print any of them.", "tutorial": "Let's design a naive solution first. For each of the given triples, we have two options: either write the string on the tree in the order from  to , or in reverse order. Some options conflict with each other. So, we can treat this problem as an instance of 2-SAT: create a variable for each of the given strings, which is true if the string is not reversed, and false if it is reversed; find all conflicting pairs of options and then run the usual algorithm for solving 2-SAT.Unfortunately, the number of conflicting pairs can be up to , so we need to improve this solution. Let's introduce a variable for each vertex of the tree which will define the character we write on it. At first, it looks like we can't use these variables in 2-SAT, since the number of possible characters is , not . But if a vertex is covered by at least one path in a triple, then there are only two possible characters we can write in this vertex: either the character which will land on this position if we write the string from  to , or the character on the opposite position in the string . And, obviously, if a vertex is not covered by any triple, we can write any character on it.Okay, now for each vertex , we have two options for a character:  and . Let the variable  be true if we write  on vertex , and false if we write . Also, for each triple , let's introduce a variable  which is true if the string  is written from  to , and false if it is written in reversed order. If the vertex  is the -th one on the path from  to , then we should add the following constraints in our 2-SAT:  if , we need a constraint \"NOT  OR NOT \";  if , we need a constraint \" OR NOT \";  if , we need a constraint \"NOT  OR \";  if , we need a constraint \" OR \". Thus, we add at most  constraints in our 2-SAT. The only thing we haven't discussed is how to actually restore each path from  to ; this can be done either with any fast algorithm that finds LCA, or by searching for LCA \"naively\" by ascending from one of those vertices until we arrive at the ancestor of another vertex; this approach will visit at most  vertices.Overall, this solution runs in .", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n \nvector<vector<int>> t;\nvector<int> p, h;\n \nvoid init(int v){\n\tfor (int u : t[v]) if (u != p[v]){\n\t\tp[u] = v;\n\t\th[u] = h[v] + 1;\n\t\tinit(u);\n\t}\n}\n \nvector<int> get_path(int v, int u){\n\tvector<int> l, r;\n\twhile (v != u){\n\t\tif (h[v] > h[u]){\n\t\t\tl.push_back(v);\n\t\t\tv = p[v];\n\t\t}\n\t\telse{\n\t\t\tr.push_back(u);\n\t\t\tu = p[u];\n\t\t}\n\t}\n\tl.push_back(v);\n\twhile (!r.empty()){\n\t\tl.push_back(r.back());\n\t\tr.pop_back();\n\t}\n\treturn l;\n}\n \nvector<vector<int>> g, tg;\n \nvoid add_edge(int v, bool vx, int u, bool vy){\n\t// (val[v] == vx) -> (val[u] == vy)\n\tg[v * 2 + vx].push_back(u * 2 + vy);\n\ttg[u * 2 + vy].push_back(v * 2 + vx);\n\tg[u * 2 + !vy].push_back(v * 2 + !vx);\n\ttg[v * 2 + !vx].push_back(u * 2 + !vy);\n}\n \nvector<int> ord;\nvector<char> used;\n \nvoid ts(int v){\n\tused[v] = true;\n\tfor (int u : g[v]) if (!used[u])\n\t\tts(u);\n\tord.push_back(v);\n}\n \nvector<int> clr;\nint k;\n \nvoid dfs(int v){\n\tclr[v] = k;\n\tfor (int u : tg[v]) if (clr[u] == -1)\n\t\tdfs(u);\n}\n \nint main(){\n\tcin.tie(0);\n\tiostream::sync_with_stdio(false);\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tt.resize(n);\n\tp.resize(n);\n\th.resize(n);\n\tp[0] = -1;\n\tforn(i, n - 1){\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\t--v, --u;\n\t\tt[v].push_back(u);\n\t\tt[u].push_back(v);\n\t}\n\tinit(0);\n\t\n\tvector<vector<int>> paths(m);\n\tvector<string> s(m);\n\t\n\tvector<pair<char, char>> opts(n, make_pair(-1, -1));\n\tforn(i, m){\n\t\tint v, u;\n\t\tcin >> v >> u >> s[i];\n\t\t--v, --u;\n\t\tpaths[i] = get_path(v, u);\n\t\tint k = s[i].size();\n\t\tassert(int(paths[i].size()) == k);\n\t\tforn(j, k) opts[paths[i][j]] = {s[i][j], s[i][k - j - 1]};\n\t}\n\t\n\tint nm = (n + m) * 2;\n\tg.resize(nm);\n\ttg.resize(nm);\n\tforn(i, m){\n\t\tint k = s[i].size();\n\t\tforn(j, k){\n\t\t\tint v = paths[i][j];\n\t\t\tchar c = s[i][j], rc = s[i][k - j - 1];\n\t\t\tchar d = opts[v].first, rd = opts[v].second;\n\t\t\tif (d != c) add_edge(v, false, n + i, true);\n\t\t\tif (d != rc) add_edge(v, false, n + i, false);\n\t\t\tif (rd != c) add_edge(v, true, n + i, true);\n\t\t\tif (rd != rc) add_edge(v, true, n + i, false);\n\t\t}\n\t}\n\t\n\tused.resize(nm);\n\tforn(i, nm) if (!used[i]) ts(i);\n\tclr.resize(nm, -1);\n\treverse(ord.begin(), ord.end());\n\tfor (int v : ord) if (clr[v] == -1){\n\t\tdfs(v);\n\t\t++k;\n\t}\n\tforn(i, nm) if (clr[i] == clr[i ^ 1]){\n\t\tcout << \"NO\\n\";\n\t\treturn 0;\n\t}\n\t\n\tcout << \"YES\\n\";\n\tfor (int i = 0; i < 2 * n; i += 2){\n\t\tif (opts[i / 2].first == -1)\n\t\t\tcout << 'a';\n\t\telse if (clr[i] > clr[i ^ 1])\n\t\t\tcout << opts[i / 2].first;\n\t\telse\n\t\t\tcout << opts[i / 2].second;\n\t}\n\tcout << \"\\n\";\n}", "interactive": false, "noSolution": false, "noTutorial": false}