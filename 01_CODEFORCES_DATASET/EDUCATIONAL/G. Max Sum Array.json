{"link": "https://codeforces.com//contest/1612/problem/G", "problemId": "1198241", "shortId": "1612G", "contest_number": "1612", "name": "G. Max Sum Array", "statement": "You are given an array . An array  is constructed in such a way that it consists of integers , and for each , there are exactly  occurrences of integer  in . So, the number of elements in  is exactly .Let's define for such array  the value  as In other words,  is the total sum of distances between all pairs of equal elements.Your task is to calculate the maximum possible value of  and the number of arrays yielding the maximum possible value of . Two arrays are considered different, if elements at some position differ.", "input": "The first line contains a single integer  ()\u00a0\u2014 the size of the array . The second line contains  integers  ()\u00a0\u2014 the array .", "output": "Print two integers\u00a0\u2014 the maximum possible value of  and the number of arrays  with such value. Since both answers may be too large, print them modulo .", "tutorial": "Firstly, let's prove that at first and last positions of  the most frequent elements should be placed (but not necessary the same). WLOG, let's prove that  for any . By contradiction, let's  be the smallest index such that . What happens if we swap them? Since  is the first such index then there are no  for , so \"contribution\" of  will increase by exactly . From the other side, contribution of  consists of two parts: pairs with elements from  and from . For all elements from  decrease will be equal to  and from elements in  .So, the total decrease  after moving  to position  equal to . The total difference in such case is equal to . So, our placement is not optimal\u00a0\u2014 contradiction.Let's suggest that there is exactly one  with maximum . According to what we proved earlier, both  and  must be equal to . Contribution of the first and last elements will be equal to:  for pair  and for each element  () with  we add  for pairs  and . So, the total contribution of  is equal to .Note that this contribution is independent of positions of other  in the array , so that's why we can cut first and last elements of  and solve the task recursively.Unfortunately, in the initial task we may have several  with maximum . But we in the similar manner can prove that the first (and last)  elements  should be some permutation of . Now, let's prove that any permutation of first and last  elements is optimal.Suppose, positions of  are  () and  (). Then the contribution of  is equal to . The total contribution of all  is     . This contribution doesn't depend on chosen  and , so any permutation of first  elements and any permutation of last  elements give optimal answer.As a result, the algorithm is following:   Find all maximums  in .  If  then any permutation of remaining elements has  (there are  such permutations).  Otherwise, add  to the total balance, and multiply the number of variants by .  Cut prefix and suffix by making  for each  (obviously, ) and repeat the whole process. We can implement the algorithm fast if we keep the number of  equal to each  from  to  (). So the total complexity is .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \" \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    fore(i, 0, sz(v)) {\n        if(i) out << \" \";\n        out << v[i];\n    }\n    return out;\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int MOD = int(1e9) + 7;\n\nint norm(int a) {\n    while (a >= MOD)\n        a -= MOD;\n    while (a < 0)\n        a += MOD;\n    return a;\n}\nint mul(int a, int b) {\n    return int(a * 1ll * b % MOD);\n}\n\nconst int MX = int(1e6) + 55;\nint n;\nli total;\nint cnt[MX];\n\ninline bool read() {\n    if(!(cin >> n))\n        return false;\n    total = 0;\n    fore (i, 0, n) {\n        int k; cin >> k;\n        cnt[k]++;\n        total += k;\n    }\n    return true;\n}\n\nint fact[MX];\n\ninline void solve() {\n    fact[0] = 1;\n    fore (i, 1, MX)\n        fact[i] = mul(fact[i - 1], i);\n    \n    int ansSum = 0;\n    int ansCnt = 1;\n    \n    for (int lvl = MX - 1; lvl > 1; lvl--) {\n        ansCnt = mul(ansCnt, mul(fact[cnt[lvl]], fact[cnt[lvl]]));\n        \n        //each color gives (lvl - 1) * (r_i - l_i)\n        // or (lvl - 1) * (sum r_i - sum l_i)\n        // l_i is permutation of [0,..., cnt[lvl]), so sum l_i = (cnt[lvl] - 1) * cnt[lvl] / 2\n        // r_i is permutation of [total - cnt[lvl],..., total), so sum = cnt[lvl] * (total - cnt[lvl]) + (cnt[lvl] - 1) * cnt[lvl] / 2\n        \n        ansSum = norm(ansSum + mul(mul(lvl - 1, cnt[lvl]), (total - cnt[lvl]) % MOD));\n        \n        total -= 2 * cnt[lvl];\n        cnt[lvl - 2] += cnt[lvl];\n    }\n    \n    ansCnt = mul(ansCnt, fact[cnt[1]]);\n    \n    cout << ansSum << \" \" << ansCnt << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}