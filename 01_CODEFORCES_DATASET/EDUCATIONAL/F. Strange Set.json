{"link": "https://codeforces.com//contest/1473/problem/F", "problemId": "864974", "shortId": "1473F", "contest_number": "1473", "name": "F. Strange Set", "statement": "You are given an integer  and two sequences  and .Let's call a set of integers  such that  , if, for every element  of , the following condition is met: for every , if  divides , then  is also included in . An empty set is always .The  of the set  is . You have to calculate the maximum possible  of a  set.", "input": "The first line contains one integer  (). The second line contains  integers  (). The third line contains  integers  ().", "output": "Print one integer \u2014 the maximum  of a  set.", "tutorial": "We will model the problem as the minimum cut in a flow network.Build a network as follows: create a source node , a sink node , and a vertex for every number from  to . Let's say that we are going to find the minimum - cut in this network, and the vertices belonging to the same cut part with  represent the numbers that are taken into the answer.Using the edges of the network, we should model these constraints:  taking an element  that depends on another element  should force us to take  as well;  taking an element  with  should add  to our score;  taking an element  with  should subtract  from our score. Constraint  can be modeled in the following way: for every pair  such that element  depends on element  ( and ), add a directed edge with infinite capacity from  to . That way, if  is taken and  is not, the value of the cut will be infinite because of this edge, and this cut cannot be minimum.Constraint  is modeled in the following way: for every  such that , add a directed edge with capacity  from  to . That way, if we  take some element  with  into the answer,  is added to the value of the cut.And for constraint , for every  such that , add a directed edge with capacity  from  to . That way, if we take some element  with ,  is added to the value of the cut.It's now easy to see that the answer is , since it is exactly the sum of elements that were taken (for positive elements, we add them all up and then subtract the ones that don't belong to the answer; for negative ones, we just subtract those which belong to the answer). To find a minimum cut, just run maximum flow in this network.There's one caveat though. If, for example, all  are equal (or many  are divisible by many other values in ), this network can contain  edges. To reduce the number of edges, let's see that if for some index  there exist two equal divisors of  to the left of it (let's say that these divisors are  and : ; ; ), then we only need to add an edge from  to , because taking  also should force taking  into the answer. So, for every divisor of , we are interested in only one closest occurrence of this divisor to the left, and we need to add a directed edge only to this occurrence, and ignore all other occurrences. That way, for every vertex , we add at most  edges to other vertices (where  is the number of divisors of ).It can be proven that any maximum flow algorithm that relies on augmenting paths will finish after  iterations in this network, so it won't work longer than , and both  and  are proportional to , so any maximum flow solution will run in .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T>\nstruct dinic {\n    struct edge {\n        int u, rev;\n        T cap, flow;\n    };\n    \n    int n, s, t;\n    T flow;\n    vector<int> lst;\n    vector<int> d;\n    vector<vector<edge>> g;\n    \n    T scaling_lim;\n    bool scaling;\n    \n    dinic() {}\n    \n    dinic(int n, int s, int t, bool scaling = false) : n(n), s(s), t(t), scaling(scaling) {\n        g.resize(n);\n        d.resize(n);\n        lst.resize(n);\n        flow = 0;\n    }\n\n    void add_edge(int v, int u, T cap, bool directed = true) {\n        g[v].push_back({u, g[u].size(), cap, 0});\n        g[u].push_back({v, int(g[v].size()) - 1, directed ? 0 : cap, 0});\n    }\n\n    T dfs(int v, T flow) {\n        if (v == t)\n            return flow;\n        if (flow == 0)\n            return 0;\n        T result = 0;\n        for (; lst[v] < g[v].size(); ++lst[v]) {\n            edge& e = g[v][lst[v]];\n            if (d[e.u] != d[v] + 1)\n                continue;\n            T add = dfs(e.u, min(flow, e.cap - e.flow));\n            if (add > 0) {\n                result += add;\n                flow -= add;\n                e.flow += add;\n                g[e.u][e.rev].flow -= add;\n            }\n            if (flow == 0)\n                break;\n        }\n        return result;\n    }\n\n    bool bfs() {\n        fill(d.begin(), d.end(), -1);\n        queue<int> q({s});\n        d[s] = 0;\n        while (!q.empty() && d[t] == -1) {\n            int v = q.front(); q.pop();\n            for (auto& e : g[v]) {\n                if (d[e.u] == -1 && e.cap - e.flow >= scaling_lim) {\n                    q.push(e.u);\n                    d[e.u] = d[v] + 1;\n                }\n            }\n        }\n        return d[t] != -1;\n    }\n\n    T calc() {\n        T max_lim = numeric_limits<T>::max() / 2 + 1;\n        for (scaling_lim = scaling ? max_lim : 1; scaling_lim > 0; scaling_lim >>= 1) {\n            while (bfs()) {\n                fill(lst.begin(), lst.end(), 0);\n                T add;\n                while((add = dfs(s, numeric_limits<T>::max())) > 0)\n                flow += add;\n            }\n        }   \n        return flow;\n    }\n    \n    vector<bool> min_cut() {\n        vector<bool> res(n);\n        for(int i = 0; i < n; i++) \n            res[i] = (d[i] != -1);\n        return res;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    for(int i = 0; i < n; i++)\n        cin >> a[i];\n    for(int i = 0; i < n; i++)\n        cin >> b[i];\n    int s = n;\n    int t = n + 1;\n    dinic<int> d(n + 2, s, t, true);\n    vector<int> last(101, -1);\n    for(int i = 0; i < n; i++){\n        if(b[i] > 0)\n            d.add_edge(s, i, b[i]);\n        if(b[i] < 0)\n            d.add_edge(i, t, -b[i]);\n        for(int k = 1; k <= 100; k++)\n            if(last[k] != -1 && a[i] % k == 0)\n                d.add_edge(i, last[k], int(1e9));\n        last[a[i]] = i;    \n    }   \n    int sum = 0;\n    for(int i = 0; i < n; i++)\n        sum += max(0, b[i]);\n    cout << sum - d.calc() << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}