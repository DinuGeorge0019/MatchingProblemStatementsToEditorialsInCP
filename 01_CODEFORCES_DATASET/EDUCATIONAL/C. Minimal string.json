{"link": "https://codeforces.com//contest/797/problem/C", "problemId": "103030", "shortId": "797C", "contest_number": "797", "name": "C. Minimal string", "statement": "Petya recieved a gift of a string  with length up to  characters for his birthday. He took two more empty strings  and  and decided to play a game. This game has two possible moves:  Extract the  character of  and append  with this character.  Extract the  character of  and append  with this character. Petya wants to get strings  and  empty and string  lexicographically minimal.You should write a program that will help Petya win the game.", "input": "First line contains non-empty string  (), consisting of lowercase English letters.", "output": "Print resulting string .", "tutorial": "On every step you should maintain minimal alphabetic letter in current string  (this can be done by keeping array of 26 cells with number of times each letter appear in string nd updating it on every step). Let's call string  a stack and use its terms.Now you extract letters from  one by one. Put the letter to the top of the stack. Pop letters from the top of stack and push them to answer while they are less or equal than any letter left in string . After string  becomes empty push all the letters from stack to answer.The answer will be lexicographically minimal. It is obvious if we consider the case when current top of stack is strictly greater than any character from the remaining string , or there is a character in  that is strictly less than current top. If current top is equal to some character then appending answer with the letter from top won't make answer worse.Overall complexity: , where  is the length of the alpabet,  in our case.", "solution": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\n\nconst int N = (int) 1e5 + 5, mod = (int) 0;\nint best[N], q[N];\nint main() {\n\tstring s;\n\tcin >> s;\n\tint n = (int) s.size();\n\tbest[n] = 1e9;\n\tfor (int j = n - 1; j >= 0; --j) {\n\t\ts[j] -= 'a';\n\t\tbest[j] = min(best[j + 1], (int) s[j]);\n\t}\n\tstring res = \"\";\n\tint t = 0;\n\tfor (int j = 0; j < n; ++j) {\n\t\tq[t++] = s[j];\n\t\twhile (t > 0 && q[t - 1] <= best[j + 1]) res += char(q[t - 1] + 'a'), --t;\n\t}\n\tcout << res << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "interactive": false, "noSolution": false, "noTutorial": false}