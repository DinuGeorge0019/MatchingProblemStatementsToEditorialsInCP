{"link": "https://codeforces.com//contest/837/problem/C", "problemId": "116709", "shortId": "837C", "contest_number": "837", "name": "C. Two Seals", "statement": "One very important person has a piece of paper in the form of a rectangle .Also, he has  seals. Each seal leaves an impression on the paper in the form of a rectangle of the size . Each impression must be parallel to the sides of the piece of paper (but seal can be rotated by 90 degrees).A very important person wants to choose two different seals and put them two impressions. Each of the selected seals puts exactly one impression. Impressions should not overlap (but they can touch sides), and the total area occupied by them should be the largest possible. What is the largest area that can be occupied by two seals?", "input": "The first line contains three integer numbers ,  and  (). Each of the next  lines contain two numbers ,  ().", "output": "Print the largest total area that can be occupied by two seals. If you can not select two seals, print .", "tutorial": "If you can place two rectangles in some way (without rotations), then it's always possible to move one of them to the top left corner and stick the other either to the bottom of the first (and push it all the way to the left) or to the right of it (and push it all the way to the top).Now let's try all possible reorderings and rotations for every pair of seals. If there is at least one correct reordering then update the answer.Overall complexity: .", "solution": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:1048576\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\ntypedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 1234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nbool isValid(int a, int b, int c, int d) {\n\tif (a <= c && b <= d) return true;\n\tswap(a, b);\n\treturn a <= c && b <= d;\n}\n\nint in[105][2];\nint main() {\n\tint N, A, B, i, j, k;\n\tscanf(\"%d %d %d\", &N, &A, &B);\n\tfor (i = 1; i <= N; i++) scanf(\"%d %d\", &in[i][0], &in[i][1]);\n\n\tint ans = 0;\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\tfor (k = 1; k < A; k++) if (isValid(in[i][0], in[i][1], k, B) && isValid(in[j][0], in[j][1], A - k, B)) break;\n\t\t\tif (k < A) ans = max(ans, in[i][0] * in[i][1] + in[j][0] * in[j][1]);\n\t\t\tfor (k = 1; k < B; k++) if (isValid(in[i][0], in[i][1], A, k) && isValid(in[j][0], in[j][1], A, B - k)) break;\n\t\t\tif (k < B) ans = max(ans, in[i][0] * in[i][1] + in[j][0] * in[j][1]);\n\t\t}\n\t}\n\treturn !printf(\"%d\\n\", ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}