{"link": "https://codeforces.com//contest/1197/problem/B", "problemId": "376703", "shortId": "1197B", "contest_number": "1197", "name": "B. Pillars", "statement": "There are  pillars aligned in a row and numbered from  to .Initially each pillar contains exactly one disk. The -th pillar contains a disk having radius .You can move these disks from one pillar to another. You can take a disk from pillar  and place it on top of pillar  if all these conditions are met:  there is no other pillar between pillars  and . Formally, it means that ;  pillar  contains  one disk;  either pillar  contains no disks, or the topmost disk on pillar  has radius strictly greater than the radius of the disk you move. When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all  disks on the same pillar simultaneously?", "input": "The first line contains one integer  () \u2014 the number of pillars. The second line contains  integers , , ...,  (), where  is the radius of the disk initially placed on the -th pillar. All numbers  are distinct.", "output": "Print  if it is possible to place all the disks on the same pillar simultaneously, and  otherwise. You may print each letter in any case (, ,  will all be recognized as positive answer, ,  and  will all be recognized as negative answer).", "tutorial": "Suppose we have a disk that is smaller than both of its neighbours. Then it's impossible to collect all the disks on the same pillar: eventually we will put this disk on the same pillar with one of its neighbours, and then we can't put the other neighbouring disk on the same pillar since it is greater than the middle disk.Okay, and what if there is no disk that is strictly smaller than both of its neighbours? Let $$$k$$$ be the index of the largest disk. $$$a_{k - 1} < a_k$$$, that implies $$$a_{k - 2} < a_{k - 1}$$$, and so on. $$$a_{k + 1} < a_k$$$, $$$a_{k + 2} < a_{k + 1}$$$, and so on. It means that the array $$$a$$$ is sorted in ascending until the index $$$k$$$, and after that it is sorted in descending order. If this condition is met, then we can collect all the disks on the pillar $$$k$$$ one by one, starting with the disk having radius $$$n - 1$$$ and ending with the disk having radius $$$1$$$.So the only thing that we need to check is the following condition: array $$$a$$$ is sorted in ascending order until $$$a_k = n$$$, and then it is sorted in descending order.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> a(n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint pos = max_element(a.begin(), a.end()) - a.begin();\n\tbool res = true;\n\tfor(int i = 0; i < pos; i++)\n\t\tres &= (a[i] < a[i + 1]);\n\tfor(int i = pos; i < n - 1; i++)\n\t\tres &= (a[i] > a[i + 1]);\n\n\tif(res)\n\t\tputs(\"YES\");\n\telse\n\t\tputs(\"NO\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}