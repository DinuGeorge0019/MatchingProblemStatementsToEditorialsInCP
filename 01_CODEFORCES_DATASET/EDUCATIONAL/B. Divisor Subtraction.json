{"link": "https://codeforces.com//contest/1076/problem/B", "problemId": "253926", "shortId": "1076B", "contest_number": "1076", "name": "B. Divisor Subtraction", "statement": "You are given an integer number . The following algorithm is applied to it:  if , then end algorithm;  find the smallest  divisor  of ;  subtract  from  and go to step . Determine the number of subtrations the algorithm will make.", "input": "The only line contains a single integer  ().", "output": "Print a single integer \u2014 the number of subtractions the algorithm will make.", "tutorial": "Notice that once the number becomes even, it never stops being even as subtracting  doesn't change parity. Thus, the task is to find the smallest divisor, subtract it and print .Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nlong long get(long long n){\n\tfor (long long i = 2; i * i <= n; ++i)\n\t\tif (n % i == 0)\n\t\t\treturn i;\n\treturn n;\n}\n\nint main() {\n\tlong long n;\n\tscanf(\"%lld\", &n);\n\tlong long cnt = 0;\n\tif (n % 2 != 0){\n\t\tn -= get(n);\n\t\t++cnt;\n\t}\n\tprintf(\"%lld\\n\", cnt + n / 2);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}