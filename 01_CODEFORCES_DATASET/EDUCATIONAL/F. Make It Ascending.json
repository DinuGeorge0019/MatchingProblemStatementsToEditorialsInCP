{"link": "https://codeforces.com//contest/1342/problem/F", "problemId": "604761", "shortId": "1342F", "contest_number": "1342", "name": "F. Make It Ascending", "statement": "You are given an array  consisting of  elements. You may apply several operations (possibly zero) to it.During each operation, you choose two indices  and  (; ), increase  by , and remove the -th element from the array (so the indices of all elements to the right to it decrease by , and  also decreases by ).Your goal is to make the array  strictly ascending. That is, the condition  should hold (where  is the resulting size of the array).Calculate the minimum number of actions required to make the array strictly ascending.", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case consists of two lines. The first line contains one integer  () \u2014 the number of elements in the initial array . The second line contains  integers , , ...,  (). It is guaranteed that:    the number of test cases having  is not greater than ;  the number of test cases having  is not greater than ;  the number of test cases having  is not greater than ;  the number of test cases having  is not greater than ;  the number of test cases having  is not greater than ;  the number of test cases having  is not greater than ;  the number of test cases having  is not greater than ;  the number of test cases having  is not greater than . ", "output": "For each test case, print the answer as follows: In the first line, print  \u2014 the minimum number of operations you have to perform. Then print  lines, each containing two indices  and  for the corresponding operation. Note that the numeration of elements in the array changes after removing elements from it. If there are multiple optimal sequences of operations, print any one of them.", "tutorial": "Suppose we don't have any constraints on the order of elements, the resulting array just should not contain any duplicates. Let's build the result one element after another in ascending order, so each element we create is strictly greater than the previous. To create an element, just use some subset of elements and merge them into new element. This process can be efficiently modeled with the following dynamic programming: $$$dp_{cnt, mask}$$$ is the minimum value of the last element, if we merged all the elements from $$$mask$$$ into $$$cnt$$$ ascending numbers. To model transitions, we simply iterate on the mask of elements that will be merged into a new one, and check if its sum is greater than the last element we created. This runs in $$$O(n3^n)$$$, if we use an efficient way to iterate on all masks that don't intersect with the given mask.Okay, how about maintaining the order? When we create an element by merging some elements of the original array, let's choose some position of an element we use in merging and state that all other elements are added to it. Then, to ensure that the result is ascending, the position of this element should be greater than the position of the element we chose while building the previous number. We can add the position we have chosen for the last element to the states of our dynamic programming, so it becomes $$$dp_{cnt, mask, pos}$$$ \u2014 the minimum value of the last element, if we merged the $$$mask$$$ of elements into $$$cnt$$$ numbers, and the last element originally had index $$$pos$$$ in the array.Using some greedy optimizations (for example, we should not iterate on the position we are choosing to merge \u2014 it can be chosen greedily as the leftmost position after the position of previous element we are taking into consideration), we can make it $$$O(n^2 3^n)$$$, yet with a small constant factor. To restore the answer, we can maintain the previous values of $$$mask$$$ and $$$pos$$$ in each state, since $$$cnt$$$ just increases by $$$1$$$ with each transition.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define sz(a) int((a).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\ntypedef pair<int, int> pt;\n\nconst int INF = 1e9;\nconst int N = 15;\n\nint n;\nint a[N];\nint sum[1 << N];\nint dp[N + 1][1 << N][N + 1];\npt p[N + 1][1 << N][N + 1];\n\nvoid solve() {\n\tscanf(\"%d\", &n);\n\tforn(i, n) scanf(\"%d\", &a[i]);\n\t\n\tforn(mask, 1 << n) {\n\t\tsum[mask] = 0;\n\t\tforn(i, n) if (mask & (1 << i))\n\t\t\tsum[mask] += a[i];\n\t}\t\n\t\n\tforn(cnt, n + 1) forn(mask, 1 << n) forn(pos, n + 1)\n\t\tdp[cnt][mask][pos] = INF;\n\t\n\tdp[0][0][0] = 0;\n\tforn(cnt, n) forn(mask, 1 << n) forn(pos, n) if (dp[cnt][mask][pos] < INF) {\n\t\tint rmask = mask ^ ((1 << n) - 1);\n\t\tfor (int nmask = rmask; nmask; nmask = (nmask - 1) & rmask) {\n\t\t\tif (sum[nmask] <= dp[cnt][mask][pos])\n\t\t\t\tcontinue;\n\t\t\tif ((nmask >> pos) == 0)\n\t\t\t\tcontinue;\n\t\t\tint npos = pos + __builtin_ctz(nmask >> pos) + 1;\n\t\t\tif (dp[cnt + 1][mask | nmask][npos] > sum[nmask]) {\n\t\t\t\tdp[cnt + 1][mask | nmask][npos] = sum[nmask];\n\t\t\t\tp[cnt + 1][mask | nmask][npos] = mp(mask, pos);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint acnt = 0, apos = 0;\n\tforn(cnt, n + 1) forn(pos, n + 1) if (dp[cnt][(1 << n) - 1][pos] < INF)\n\t\tacnt = cnt, apos = pos;\n\t\t\n\tvector<pt> ans;\n\t\n\tint mask = (1 << n) - 1, pos = apos;\n\tfor (int cnt = acnt; cnt > 0; --cnt) {\n\t\tint nmask = p[cnt][mask][pos].x;\n\t\tint npos = p[cnt][mask][pos].y;\n\t\tforn(i, n) if ((nmask ^ mask) & (1 << i))\n\t\t\tif (i != pos - 1) ans.pb(mp(i, pos - 1));\n\t\tmask = nmask, pos = npos;\n\t}\n\t\n\t\n\tprintf(\"%d\\n\", sz(ans));\n\tforn(i, sz(ans)) {\n\t\tint from = ans[i].x;\n\t\tforn(j, i) from -= ans[j].x < ans[i].x;\n\t\tint to = ans[i].y;\n\t\tforn(j, i) to -= ans[j].x < ans[i].y;\n\t\tprintf(\"%d %d\\n\", from + 1, to + 1);\n\t}\n}\t\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\tforn(i, tc) solve();\n\t\t\n}", "interactive": false, "noSolution": false, "noTutorial": false}