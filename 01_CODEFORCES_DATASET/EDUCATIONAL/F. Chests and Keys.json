{"link": "https://codeforces.com//contest/1519/problem/F", "problemId": "971591", "shortId": "1519F", "contest_number": "1519", "name": "F. Chests and Keys", "statement": "Alice and Bob play a game. Alice has got  treasure chests (the -th of which contains  coins) and  keys (the -th of which she can sell Bob for  coins).Firstly, Alice puts some locks on the chests. There are  types of locks, the locks of the -th type can only be opened with the -th key. To put a lock of type  on the -th chest, Alice has to pay  dollars. Alice can put any number of different types of locks on each chest (possibly, zero).Then, Bob buys some of the keys from Alice (possibly none, possibly all of them) and opens each chest he can (he can open a chest if he has the keys for all of the locks on this chest). Bob's profit is the difference between the total number of coins in the opened chests and the total number of coins he spends buying keys from Alice. If Bob's profit is  (greater than zero), he wins the game. Otherwise, Alice wins the game.Alice wants to put some locks on some chests so no matter which keys Bob buys, she always wins (Bob cannot get positive profit). Of course, she wants to spend the minimum possible number of dollars on buying the locks. Help her to determine whether she can win the game at all, and if she can, how many dollars she has to spend on the locks.", "input": "The first line contains two integers  and  ()\u00a0\u2014 the number of chests and the number of keys, respectively. The second line contains  integers  (), where  is the number of coins in the -th chest. The third line contains  integers  (), where  is the number of coins Bob has to spend to buy the -th key from Alice. Then  lines follow. The -th of them contains  integers  (), where  is the number of dollars Alice has to spend to put a lock of the -th type on the -th chest.", "output": "If Alice cannot ensure her victory (no matter which locks she puts on which chests, Bob always has a way to gain positive profit), print . Otherwise, print one integer\u00a0\u2014 the minimum number of dollars Alice has to spend to win the game regardless of Bob's actions.", "tutorial": "Firstly, let's try to find some naive solution for this problem. Let's iterate on the subset of locks Alice puts on the chests. After choosing the subset of locks, how to check whether Bob can gain positive profit? We can iterate on the subset of keys he can buy as well, but in fact, this problem has a polynomial solution. Construct a flow network as follows: each chest and each key represents a vertex; there are  arcs from the source to the vertices representing the chests (each having capacity ),  arcs from the vertices representing the keys to the sink (each having capacity ), and for each chosen lock, an arc from the respective chest-vertex to the respective key-vertex with infinite capacity. If we find the minimum cut from the source to the sink, then Bob's profit is . The reasoning behind this solution is the following one: if Bob takes all the chests and all the keys belonging to the first part of the cut, his profit is equal to the total cost of all chests he has taken, minus the total cost of all keys he has taken, minus infinity if he takes a chest he can't open. And the value of the cut is equal to the total cost of chests he doesn't take, plus the total cost of keys he takes, plus infinity if he can't open some chest he takes (since the arc from this chest-vertex to one of the key-vertices belongs to the cut). So, Bob's profit is , and by minimizing the cut value, we maximize his profit. A minimum cut can be easily found using any maxflow algorithm.Unfortunately, even iterating through all subsets of locks is too slow. To improve this solution, we should look at the minimum cut and its usage a bit more in detail. Notice that Bob can always take no keys and open no chests to get a profit of zero, so Alice's goal is to ensure that it is the best Bob's option. If Bob takes no chests and no keys, it means that the cut divides the network into two parts: the source and all other vertices. And, in terms of flows, it means that the maximum flow in this network  (I highlighted it because it is the key idea of the solution).Here the constraints on ,  and  come in handy. We can use a dynamic programming with the flow over all arcs going from the source as one of the states. One of the ways to implement it is to have  as the state, where  through  are the values of the flow going from the arcs from the source,  is the current vertex in the left part we consider,  is the current vertex in the right part we consider, and  is the flow we already pushed through the arc connecting vertex  of the right part to the sink (and the value we store for this state is the minimum cost Alice has pay to reach this state). There are two basic types of transitions in this dynamic programming: we either skip the arc from  to , or pick it and transfer some flow through it; and no matter what we've chosen, we move to the next vertex of the left part (or to  and increase  by  if we are already considering the -th vertex of the left part). The constraints were loose enough to implement this dp basically in any form (there was no need to compress the states into single integers, for example, which was what the most participants of the round did).", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 6;\nconst int M = 400;\nconst int INF = int(1e9);\n\nint a[N];\nint b[N];\nint c[N][N];\nint n, m;\n\nstruct state\n{\n    vector<int> need;\n    int v2;\n    int v1;\n    int rem;\n    state() {};\n    state(vector<int> need, int v1, int v2, int rem) : need(need), v1(v1), v2(v2), rem(rem) {};\n};\n\nint get_code(const vector<int>& v)\n{\n    int ans = 0;\n    for(int i = 0; i < v.size(); i++)\n        ans = ans * 5 + v[i];\n    return ans;\n}\n\nint get_code(const state& s)\n{\n    int code = get_code(s.need);\n    code = code * 6 + s.v2;\n    code = code * 6 + s.v1;\n    code = code * 5 + s.rem;\n    return code; \n}\n\nvector<int> get_vector(int code, int n)\n{\n    vector<int> res(n);\n    for(int i = n - 1; i >= 0; i--)\n    {\n        res[i] = code % 5;\n        code /= 5;\n    }\n    return res;\n}\n\nstate get_state(int code)\n{\n    int rem = code % 5;\n    code /= 5;\n    int v1 = code % 6;\n    code /= 6;\n    int v2 = code % 6;\n    code /= 6;\n    vector<int> need = get_vector(code, n);\n    return state(need, v1, v2, rem);\n}\n\nconst int Z = 40 * int(1e6);\nint dp[Z];\n\nint main()\n{\n    cin >> n >> m;\n    for(int i = 0; i < n; i++)\n        cin >> a[i];\n    for(int i = 0; i < m; i++)\n        cin >> b[i];\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < m; j++)\n            cin >> c[i][j];\n    for(int i = 0; i < Z; i++)\n        dp[i] = INF;\n    state start(vector<int>(n, 0), 0, 0, 0);\n    int ans = INF;\n    dp[get_code(start)] = 0;\n    for(int i = 0; i < Z; i++)\n    {\n        if(dp[i] == INF) continue;\n        state s = get_state(i);\n        for(int f = 0; f <= 4; f++)\n        {\n            if(s.need[s.v1] + f > a[s.v1] || s.rem + f > b[s.v2])\n                continue;\n            int add = (f == 0 ? 0 : c[s.v1][s.v2]);\n            state nw = s;\n            nw.need[s.v1] += f;\n            nw.rem += f;\n            if(s.v1 == n - 1)\n            {\n                nw.v1 = 0;\n                nw.v2 = s.v2 + 1;\n                nw.rem = 0;\n            }\n            else\n            {\n                nw.v1 = s.v1 + 1;\n            }\n            if(nw.need == vector<int>(a, a + n))\n                ans = min(ans, dp[i] + add);\n            if(nw.v2 < m)\n            {\n                int code = get_code(nw);\n                dp[code] = min(dp[code], dp[i] + add);\n            }\n        }\n    }\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n\n}", "interactive": false, "noSolution": false, "noTutorial": false}