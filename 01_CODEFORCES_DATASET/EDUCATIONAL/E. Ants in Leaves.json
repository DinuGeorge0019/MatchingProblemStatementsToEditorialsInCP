{"link": "https://codeforces.com//contest/622/problem/E", "problemId": "47919", "shortId": "622E", "contest_number": "622", "name": "E. Ants in Leaves", "statement": "Tree is a connected graph without cycles. A leaf of a tree is any vertex connected with exactly one other vertex.You are given a tree with  vertices and a root in the vertex . There is an ant in each leaf of the tree. In one second some ants can simultaneously go to the parent vertex from the vertex they were in. No two ants can be in the same vertex simultaneously except for the root of the tree.Find the minimal time required for all ants to be in the root of the tree. Note that at start the ants are only in the leaves of the tree.", "input": "The first line contains integer  () \u2014 the number of vertices in the tree. Each of the next  lines contains two integers  () \u2014 the ends of the -th edge. It is guaranteed that you are given the correct undirected tree.", "output": "Print the only integer  \u2014 the minimal time required for all ants to be in the root of the tree.", "tutorial": "Easy to see that the answer is equal to the answer over all sons of the root plus one. Now let's solve the problem independently for each son  of the root. Let  be the array of the depths of all leaves in the subtree of the vertex . Let's sort . Statement 1: it's profitable to lift the leaves in order of their appearing in . Statement 2: denote  \u2014 the time of appearing the -th leaf in the vertex , let's consider the leaves  and  then . Statement 3: , where  is the depth of the -th leaf in the subtree of the vertex . The last statement gives us the solution for the problem: we should simply iterate over  from left to right and recalculate the array  by formula from the third statement. All statements can be easily proved and it's recommended to do by yourself to understand better the idea of the solution.\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nconst int N = 500500;\n\u00a0\nint n;\nvector<int> g[N];\n\u00a0\ninline bool read() {\n\u00a0 \u00a0 if (!(cin >> n)) return false;\n\u00a0 \u00a0 forn(i, n) g[i].clear();\n\u00a0 \u00a0 forn(i, n - 1) {\n\u00a0 \u00a0 \u00a0 \u00a0 int x, y;\n\u00a0 \u00a0 \u00a0 \u00a0 assert(scanf(\"%d%d\", &x, &y) == 2);\n\u00a0 \u00a0 \u00a0 \u00a0 x--, y--;\n\u00a0 \u00a0 \u00a0 \u00a0 g[x].pb(y), g[y].pb(x);\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return true;\n}\n\u00a0\nvector<int> z;\n\u00a0\nvoid dfs(int v, int p, int d) {\n\u00a0 \u00a0 int c = 0;\n\u00a0 \u00a0 forn(i, sz(g[v])) {\n\u00a0 \u00a0 \u00a0 \u00a0 int to = g[v][i];\n\u00a0 \u00a0 \u00a0 \u00a0 if (to == p) continue;\n\u00a0 \u00a0 \u00a0 \u00a0 c++;\n\u00a0 \u00a0 \u00a0 \u00a0 dfs(to, v, d + 1);\n\u00a0 \u00a0 }\n\u00a0 \u00a0 if (!c) z.pb(d);\n}\n\u00a0\nint solve(int v, int p) {\n\u00a0 \u00a0 z.clear();\n\u00a0 \u00a0 dfs(v, p, 0);\n\u00a0 \u00a0 sort(all(z));\n\u00a0 \u00a0 forn(i, sz(z)) {\n\u00a0 \u00a0 \u00a0 \u00a0 if (i) z[i] = max(z[i - 1] + 1, z[i]);\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return z.back();\n}\n\u00a0\ninline void solve() {\n\u00a0 \u00a0 int ans = 0;\n\u00a0 \u00a0 forn(i, sz(g[0]))\n\u00a0 \u00a0 \u00a0 \u00a0 ans = max(ans, solve(g[0][i], 0) + 1);\n\u00a0 \u00a0 cout << ans << endl;\n}\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 solve();\n\u00a0 \u00a0 \u00a0 \u00a0 //break;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}