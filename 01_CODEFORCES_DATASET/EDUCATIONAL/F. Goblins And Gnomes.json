{"link": "https://codeforces.com//contest/1525/problem/F", "problemId": "987016", "shortId": "1525F", "contest_number": "1525", "name": "F. Goblins And Gnomes", "statement": "Monocarp plays a computer game called \"Goblins and Gnomes\". In this game, he manages a large underground city of gnomes and defends it from hordes of goblins.The city consists of  halls and  one-directional tunnels connecting them. The structure of tunnels has the following property: if a goblin leaves any hall, he cannot return to that hall. The city will be attacked by  waves of goblins; during the -th wave,  goblins attack the city. Monocarp's goal is to pass all  waves.The -th wave goes as follows: firstly,  goblins appear in some halls of the city and pillage them; . Then, goblins start moving along the tunnels, pillaging all the halls in their path. Goblins are very greedy and cunning, so they choose their paths so that no two goblins pass through the same hall. Among all possible attack plans, they choose a plan which allows them to . After goblins are done pillaging, they leave the city.If all halls are pillaged during the wave \u2014 Monocarp loses the game. Otherwise, the city is restored. If some hall is pillaged during a wave, goblins are still interested in pillaging it during the next waves.Before each wave, Monocarp can spend some time preparing to it. Monocarp doesn't have any strict time limits on his preparations (he decides when to call each wave by himself), but the longer he prepares for a wave, the fewer points he gets for passing it. If Monocarp prepares for the -th wave for  minutes, then he gets  points for passing it (obviously, if he doesn't lose in the process).While preparing for a wave, Monocarp can block tunnels. He can spend one minute to . If Monocarp blocks a tunnel while preparing for a wave, it stays blocked during the next waves as well.Help Monocarp to defend against all  waves of goblins and get the maximum possible amount of points!", "input": "The first line contains three integers ,  and  (; ; )\u00a0\u2014 the number of halls in the city, the number of tunnels and the number of goblin waves, correspondely. Next  lines describe tunnels. The -th line contains two integers  and  (; ). It means that the tunnel goes from hall  to hall . . There is at most one tunnel between each pair of halls. Next  lines describe the scoring system. The -th line contains two integers  and  (; ). If Monocarp prepares for the -th wave for  minutes, then he gets  points for passing it.", "output": "Print the optimal Monocarp's strategy in the following format: At first, print one integer  ()\u00a0\u2014 the number of actions Monocarp will perform. Next, print actions themselves in the order Monocarp performs them. The -th action is described by a single integer  () using the following format:   if  then Monocarp blocks all tunnels going out from the hall ;  if  then Monocarp blocks all tunnels going into the hall ;  if  then Monocarp calls the next goblin wave.  You can't repeat the same block action  several times. Monocarp must survive all waves he calls (goblins shouldn't be able to pillage all halls). Monocarp should call exactly  waves and earn the maximum possible number of points in total. If there are several optimal strategies\u00a0\u2014 print any of them.", "tutorial": "First of all, let's try to solve the following problem: given a DAG, cover its vertices with the minimum number of vertex-disjoint paths. Solving this problem allows us to calculate the number of goblins that can pillage all of the halls when the tunnel network is fixed. This problem is a fairly classical one; since the number of vertices in each path is greater than the number of arcs in it exactly by , we should take the maximum possible number of arcs into our paths. So we can reduce this problem to bipartite maximum matching \u2014 build a bipartite graph where each part consists of  vertices, and for every directed arc  in the original graph, connect the vertex  of the left part to the vertex  in the right part of the bipartite graph. The maximum matching in this graph allows us to pick the maximum number of arcs into the paths of the original problem (the matching ensures that each vertex has at most one chosen ingoing arc and at most one chosen outgoing arc, so the paths are vertex-disjoint). Okay, now we at least can check if the goblin wave can pillage all of the halls.Let's say that the minimum number of goblins required to pillage the original city is . Obviously, in order to pass the -th wave and waves after it, we have to increase this number. In one minute, Monocarp can block all of the tunnels leading to some hall or out of some hall \u2014 and in terms of our reduction to the bipartite matching problem, it means that we remove all edges connected to some vertex of the bipartite graph. Obviously, in one minute, we can increase  by at most , since  is equal to the difference between  and the maximum matching size.It turns out that it's always possible to choose a vertex that belongs to all maximum matchings in the bipartite graph (note that it doesn't work in non-bipartite graphs, but in our problem, it doesn't matter). For the proof of this fact, you can check the last paragraph of the editorial. So, each minute Monocarp prepares for a wave, he increases the maximum number of goblins he can repel by .Now the solution splits into two much easier parts. The first part is finding a sequence in which Monocarp blocks the tunnels, so that each his action reduces the size of the maximum matching by . Since the constraints are small, even a naive approach in  \u2014 always iterate on the vertex we try to remove from the graph and check that removing it is possible by running Kuhn's algorithm \u2014 is fast enough. The second part is to choose when Monocarp calls waves of goblins and when he prepares for them \u2014 this can be easily done with dynamic programming: let  be the maximum Monocarp's score if he has already passed  waves, and the current size of the maximum matching is . The most naive implementation of this dynamic programming runs in , so the whole solution works in .We can improve it to , though it is not needed under these constraints. Instead of finding the vertices to remove from the bipartite graph one-by-one, let's find all of them at once in . Recall that the size of maximum matching in a bipartite graph is equal to the size of its minimum vertex cover, and the minimum vertex cover can be reconstructed after finding the maximum matching. If we remove a vertex from the minimum vertex cover, the size of the minimum vertex cover of the remaining graph is reduced by , so the size of the maximum matching is reduced by  as well. It means that we can always choose to remove a vertex from the minimum vertex cover we found. By the way, it also proves that it's always possible to remove a vertex from a bipartite graph so the size of the maximum matching decreases by  (obviously, if it's not  already).", "solution": "#include <bits/stdc++.h>     \n\nusing namespace std;\n\nconst int N = 543;\nconst long long INF = (long long)(1e18);\n\nstruct Matching\n{\n \tint n1, n2;\n \tvector<set<int>> g;\n \tvector<int> mt, used;\n\n \tvoid init()\n \t{\n \t \tmt = vector<int>(n2, -1);\n \t}\n\n \tint kuhn(int x)\n \t{\n \t \tif(used[x] == 1) return 0;\n \t \tused[x] = 1;\n \t \tfor(auto y : g[x])\n \t \t\tif(mt[y] == -1 || kuhn(mt[y]) == 1)\n \t \t\t{\n \t \t\t \tmt[y] = x;\n \t \t\t \treturn 1;\n \t \t\t}\n \t \treturn 0;\n \t}\n\n \tint calc()\n \t{\n \t \tinit();\n \t \tint sum = 0;\n \t \tfor(int i = 0; i < n1; i++)\n \t \t{\n \t \t\tused = vector<int>(n1, 0);\n \t \t\tsum += kuhn(i);\n \t \t}\n \t \treturn sum;\n \t}\n\n \tvoid remove_vertex(int v, bool right)\n \t{\n \t \tif(right)\n \t \t{\n \t \t\tfor(int i = 0; i < n1; i++)\n \t \t\t\tg[i].erase(v);\n \t \t}\n \t \telse\n \t \t\tg[v].clear();\n \t}\n\n \tvoid add_edge(int x, int y)\n \t{\n \t\tg[x].insert(y);\n \t}\n\n \tMatching() {};\n \tMatching(int n1, int n2) : n1(n1), n2(n2)\n \t{\n \t\tg.resize(n1);\n \t};\n};\n\nint n, m, k;\nlong long dp[N][N];\nint p[N][N];\nvector<int> g[N];\nlong long x[N], y[N];\n\nint main()\n{\n\tcin >> n >> m >> k;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t \tint u, v;\n\t \tcin >> u >> v;\n\t \t--u;\n\t \t--v;\n\t \tg[u].push_back(v);\n\t}\n\tfor(int i = 0; i < k; i++)\n\t\tcin >> x[i] >> y[i];\n\n\tMatching mt(n, n);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(auto j : g[i])\n\t\t\tmt.add_edge(i, j);\n\tint cnt = mt.calc();\n\tint cur = cnt;\n\tvector<int> seq;\n\twhile(cur > 0)\n\t{\n\t\tint idx = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t \tMatching mt2 = mt;\n\t\t \tmt2.remove_vertex(i, false);\n\t\t \tif(mt2.calc() < cur)\n\t\t \t\tidx = i + 1;\n\t\t \tmt2 = mt;\n\t\t \tmt2.remove_vertex(i, true);\n\t\t \tif(mt2.calc() < cur)\n\t\t \t\tidx = -(i + 1);\n\t\t}\n\t\tassert(idx != 0);\n\t\tseq.push_back(idx);\n\t\tmt.remove_vertex(abs(idx) - 1, idx < 0);\n\t\tcur--;\n\t}\t\n\treverse(seq.begin(), seq.end());\n\tfor(int i = 0; i <= k; i++)\n\t\tfor(int j = 0; j <= cnt; j++)\n\t\t\tdp[i][j] = -INF;\n\tdp[0][cnt] = 0;\n\tfor(int i = 0; i < k; i++)\n\t\tfor(int j = 0; j <= cnt; j++)\n\t\t{\n\t\t\tif(dp[i][j] == -INF) continue;\n\t\t\tfor(int z = 0; z <= j; z++)\n\t\t\t{\n\t\t\t\tif(i + 1 + z >= n) continue;\n\t\t\t \tint t = j - z;\n\t\t\t \tlong long add = max(0ll, x[i] - t * y[i]);\n\t\t\t \tif(dp[i + 1][z] < dp[i][j] + add)\n\t\t\t \t{\n\t\t\t \t \tdp[i + 1][z] = dp[i][j] + add;\n\t\t\t \t \tp[i + 1][z] = j;\n\t\t\t \t}\n\t\t\t}\n\t\t}\n\tcur = max_element(dp[k], dp[k] + cnt + 1) - dp[k];\n\tvector<int> res;\n\tfor(int i = k; i > 0; i--)\n\t{\n\t\tres.push_back(0);\n\t\tfor(int j = p[i][cur] - 1; j >= cur; j--)\n\t\t\tres.push_back(seq[j]);\n\t\tcur = p[i][cur];\t\n\t}\n\treverse(res.begin(), res.end());\n\tcout << res.size() << endl;\n\tfor(auto x : res) cout << x << \" \";\n\tcout << endl;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}