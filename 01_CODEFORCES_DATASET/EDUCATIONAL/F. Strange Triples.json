{"link": "https://codeforces.com//contest/1796/problem/F", "problemId": "1802550", "shortId": "1796F", "contest_number": "1796", "name": "F. Strange Triples", "statement": "Let's call a triple of positive integers ()  if the equality  holds, where  is the concatenation of  and  and  is the concatenation of  and . For the purpose of concatenation, the integers are considered without leading zeroes.For example, if ,  and , then the triple is strange, because . But ,  and  is not strange, because .You are given three integers ,  and . Calculate the number of strange triples ), such that ,  and .", "input": "The only line contains three integers ,  and  (; ).", "output": "Print one integer\u00a0\u2014 the number of strange triples ) such that ,  and .", "tutorial": "Let  be the length of number . Then  Let  then  and  and we get  Note that the right part is divisible by , so the left part should as well. Then we can see that  should be divisible by , since . Let's say  then divide both sides by . We get Let's rearrange it and get the following:  Since  is integer, then  should be integer. In other words, we can define  such that  is divisible by  and  is divisible by  and  is .Since  has a very special structure, let's iterate over all lengths  () and all divisors  of  for a fixed . Let's say  and . Then For a fixed  and  we know , but don't know . So, let's just iterate over all possible  () and let's also iterate over all , since  is small (, since  is a divisor of ). Next step is following: let's look at previous equation, but modulo : Since  then there is a  solution to the previous module equation, or: Now we know exact value  and , so now the time to guess  (let's recall that ). Since we fixed , then , or  Let's name the left border as  and right border , so inequality earlier is .But we can make constrains even tighter: note that , but lately, we said that  or . So, , or  should be divisible by .In total, we can iterate  in range  with  , since we are interested only in  divisible by .Now we have enough variables to construct a triple: we know  and , so . If  is already big (), we can skip that candidate. Also, we can calculate  and check that pair  is valid, i.\u00a0e.  is really minimum possible. We can understand it by checking that  (otherwise, we can reduce  by ).Value  can be calculated from one of the formulas above as . After that, we calculate  and check that  is not too big. Value  can be calculated as .At last, we should check that the given triple satisfy all remaining assumptions we made:  is not too big,  is really  and length of calculated  is exactly  we fixed. If it's all fine, then we found a correct triple. It looks like, thanks to all previous checks, the triple we found is unique, but, just for safety, let's push them all in one set to get rid of copies.Calculating complexity is not trivial, but let's note something: the total number of divisors  of  for all  is around . For a fixed pair , we iterate over all  from  to  and for each  we iterate  from  to , but it's easy to prove that the total number of pairs  is at most . Now the last cycle: iteration of  with step  where . If we assume that  is quite small then  is proportional to , and pairs  are something like harmonic series with  complexity. In total, the complexity is around .", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define sz(a) int((a).size())\n\nusing li = long long;\n\nconst int MAXLEN = 5;\n\nvector<int> divs(int x) {\n  vector<int> res;\n  for (int i = 1; i * i <= x; ++i) {\n    if (x % i == 0) {\n      res.push_back(i);\n      if (i * i != x)\n        res.push_back(x / i);\n    }\n  }\n  return res;\n}\n\nint main() {\n  int A, B, N;\n  cin >> A >> B >> N;\n\n  vector<int> pw(10);\n  pw[0] = 1;\n  for (int i = 1; i < 10; ++i) pw[i] = pw[i - 1] * 10;\n  \n  int PW = pw[MAXLEN];\n  set<array<int, 3>> used;\n  \n  vector<int> len(PW);\n  for (int i = 0; i < PW; ++i)\n    len[i] = sz(to_string(i));\n  \n  for (int lenn = 1; lenn <= 9; ++lenn) {\n    int x = pw[lenn] - 1;\n    for (int k2 : divs(x)) {\n      int r = x / k2;\n      for (int d = 1; d < PW; ++d) {\n        for (int lenb = len[d]; lenb <= MAXLEN; ++lenb) {\n          int bg = pw[lenb] - d * li(r) % pw[lenb];\n          int dd = d / __gcd(d, bg);\n          int lb = (pw[lenb - 1] + bg - 1) / bg;\n          int rb = (pw[lenb] - 1) / bg;\n          for (int g = (lb + dd - 1) / dd * dd; g <= rb; g += dd) {\n            int b = bg * g;\n            assert(b % d == 0);\n            if (b >= B || __gcd(b / d, r) != 1) continue;\n            int ag = (d * li(r) + bg) / pw[lenb];\n            li n = b / d * li(k2) * ag;\n            if (n < N && ag * g < A && __gcd(ag, bg) == 1 && sz(to_string(n)) == lenn) \n              used.insert({ag * g, b, n});\n          }\n        }\n      }\n    }\n  }\n  \n  int res = 0;\n  for (auto it : used) {\n    li a = it[0], b = it[1], n = it[2];\n    int lenn = sz(to_string(n));\n    int lenb = sz(to_string(b));\n    res += a * b * pw[lenn] + n * b == a * n * pw[lenb] + a * b;\n  }\n  \n  cout << res << endl;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}