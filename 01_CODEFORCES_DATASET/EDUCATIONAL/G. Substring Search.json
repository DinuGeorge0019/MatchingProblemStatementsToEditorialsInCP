{"link": "https://codeforces.com//contest/1334/problem/G", "problemId": "590687", "shortId": "1334G", "contest_number": "1334", "name": "G. Substring Search", "statement": "You are given a permutation  consisting of exactly  integers from  to  (since it is a permutation, each integer from  to  occurs in  exactly once) and two strings  and  consisting of lowercase Latin letters.A substring  of string  is an  of string  if the following conditions are met:  ;  for each , either , or , where  is the index of character  in Latin alphabet (, , ). For example, if , , , , , then three substrings of  are occurences of  (they are ,  and ).For each substring of  having length equal to , check if it is an  of .", "input": "The first line contains  integers , , ...,  (, all these integers are pairwise distinct). The second line contains one string , and the third line contains one string  () both consisting of lowercase Latin letters.", "output": "Print a string of  characters, each character should be either  or . The -th character should be  if and only if the substring of  starting with the -th character and ending with the -th character (inclusive) is an  of .", "tutorial": "We will run two tests for each substring of  we are interested in. If at least one of them shows that the substring is not an occurence of , we print , otherwise we print .The first test is fairly easy. The given permutation can be decomposed into cycles. Let's replace each character with the index of its cycle (in both strings) and check if each substring of  is equal to  after this replacement (for example, using regular KMP algorithm). If some substring is not equal to  after the replacement, then it is definitely not an occurence.The second test will help us distinguish the characters belonging to the same cycle. Let  be some cycle in our permutation (elements are listed in the order they appear in the cycle, so ). We will replace each character with a complex number in such a way that the case when they match are easily distinguishable from the case when they don't match. One of the ways to do this is to replace  with a complex number having magnitude equal to  and argument equal to  (if this character belongs to ) or to  (if this character belongs to ).How does this replacement help us checking the occurence? If we multiply the numbers for two matching characters, we get a complex number with argument equal to  or to , and its real part will be . In any other case, the real part of the resulting number will be strictly less than , and the difference will be at least . So, if we compute the value of  for the -th substring of  (where  is the number that replaced the character ), we can check if the real part of the result is close to the value we would get if we matched  with itself (and if the difference is big enough, at least one pair of characters didn't match). The only case when this method fails is if we try to match characters from different cycles of the permutation, that's why we needed the first test.Overall, the first test can be done in  using prefix function (or any other linear substring search algorithm), and the second test can be done in , if we compute the aforementioned values for each substring using FFT.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < n; i++)\n#define sz(a) ((int)(a).size())\n\nconst int LOGN = 20;\nconst int N = (1 << LOGN);\n\ntypedef long double ld;\ntypedef long long li;\n\nconst ld PI = acos(-1.0);\n\nstruct comp \n{\n    ld x, y;\n    comp(ld x = .0, ld y = .0) : x(x), y(y) {}\n    inline comp conj() { return comp(x, -y); }\n};\n\ninline comp operator +(const comp &a, const comp &b) \n{\n    return comp(a.x + b.x, a.y + b.y);\n}\n\ninline comp operator -(const comp &a, const comp &b) \n{\n    return comp(a.x - b.x, a.y - b.y);\n}\n\ninline comp operator *(const comp &a, const comp &b) \n{\n    return comp(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\ninline comp operator /(const comp &a, const ld &b) \n{\n    return comp(a.x / b, a.y / b);\n}\n\nvector<comp> w[LOGN];\nvector<int> rv[LOGN];\n\nvoid precalc() \n{\n    for(int st = 0; st < LOGN; st++) \n    {\n        w[st].assign(1 << st, comp());\n        for(int k = 0; k < (1 << st); k++) \n        {\n            double ang = PI / (1 << st) * k;\n            w[st][k] = comp(cos(ang), sin(ang));\n        }\n        \n        rv[st].assign(1 << st, 0);\n        if(st == 0) \n        {\n            rv[st][0] = 0;\n            continue;\n        }\n        int h = (1 << (st - 1));\n        for(int k = 0; k < (1 << st); k++)\n            rv[st][k] = (rv[st - 1][k & (h - 1)] << 1) | (k >= h);\n    }\n}\n\ninline void fft(comp a[N], int n, int ln, bool inv) \n{\n    for(int i = 0; i < n; i++) \n    {\n        int ni = rv[ln][i];\n        if(i < ni)\n            swap(a[i], a[ni]);\n    }\n    \n    for(int st = 0; (1 << st) < n; st++) \n    {\n        int len = (1 << st);\n        for(int k = 0; k < n; k += (len << 1)) \n        {\n            for(int pos = k; pos < k + len; pos++) \n            {\n                comp l = a[pos];\n                comp r = a[pos + len] * (inv ? w[st][pos - k].conj() : w[st][pos - k]);\n                \n                a[pos] = l + r;\n                a[pos + len] = l - r;\n            }\n        }\n    }\n    \n    if(inv) for(int i = 0; i < n; i++)\n        a[i] = a[i] / n;\n}\n\ncomp aa[N];\ncomp bb[N];\ncomp cc[N];\n\ninline void multiply(comp a[N], int sza, comp b[N], int szb, comp c[N], int &szc) \n{\n    int n = 1, ln = 0;\n    while(n < (sza + szb))\n        n <<= 1, ln++;\n    for(int i = 0; i < n; i++)\n        aa[i] = (i < sza ? a[i] : comp());\n    for(int i = 0; i < n; i++)\n        bb[i] = (i < szb ? b[i] : comp());\n        \n    fft(aa, n, ln, false);\n    fft(bb, n, ln, false);\n    \n    for(int i = 0; i < n; i++)\n        cc[i] = aa[i] * bb[i];\n        \n    fft(cc, n, ln, true);\n    \n    szc = n;\n    for(int i = 0; i < n; i++)\n        c[i] = cc[i];\n}\n\ncomp a[N];\ncomp b[N];\ncomp c[N];\n\nvector<int> p_function(const vector<int>& v)\n{\n    int n = v.size();\n    vector<int> p(n);\n    for(int i = 1; i < n; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && v[j] != v[i])\n            j = p[j - 1];\n        if(v[j] == v[i])\n            j++;\n        p[i] = j;   \n    }\n    return p;\n}\n\nint p[26];\nchar buf[N];\nstring s, t;\n\nint main()\n{\n    precalc();                  \n    for(int i = 0; i < 26; i++)\n    {\n        scanf(\"%d\", &p[i]);\n        p[i]--;\n    }\n    scanf(\"%s\", buf);\n    s = buf;\n    scanf(\"%s\", buf);\n    t = buf;\n\n    int n = s.size();\n    int m = t.size();\n    vector<int> color(26, 0);\n    vector<vector<int> > cycles;\n    for(int i = 0; i < 26; i++)\n    {\n        if(color[i])\n            continue;\n        vector<int> cycle;\n        int cc = cycles.size() + 1;\n        int cur = i;\n        while(color[cur] == 0)\n        {\n            cycle.push_back(cur);\n            color[cur] = cc;\n            cur = p[cur];\n        }\n        cycles.push_back(cycle);\n    }\n\n    vector<int> ans(m - n + 1);\n    vector<int> s1, t1;\n    for(int i = 0; i < n; i++)\n        s1.push_back(color[int(s[i] - 'a')]);\n    for(int i = 0; i < m; i++)\n        t1.push_back(color[int(t[i] - 'a')]);\n    vector<int> st = s1;\n    st.push_back(0);\n    for(auto x : t1)\n        st.push_back(x);\n    vector<int> pf = p_function(st);\n    for(int i = 0; i < m - n + 1; i++)\n        if(pf[2 * n + i] == n)\n            ans[i] = 1;\n    map<char, comp> m1, m2;\n    for(auto cur : cycles)\n    {\n        int k = cur.size();\n        for(int i = 0; i < k; i++)\n        {\n            ld ang1 = 2 * PI * i / k;\n            ld ang2 = (PI - 2 * PI * i) / k;\n            m1[char('a' + cur[i])] = comp(cosl(ang1), sinl(ang1));\n            m2[char('a' + cur[i])] = comp(cosl(ang2), sinl(ang2));\n        }\n    }\n\n    ld ideal = 0;\n    for(int i = 0; i < n; i++)\n        ideal += (m1[s[i]] * m2[s[i]]).x;\n    reverse(s.begin(), s.end());\n    for(int i = 0; i < n; i++)                  \n        a[i] = m1[s[i]];                \n    for(int i = 0; i < m; i++)\n        b[i] = m2[t[i]];\n    int szc;\n    multiply(a, n, b, m, c, szc);\n    for(int i = 0; i < m - n + 1; i++)\n        if(fabsl(c[i + n - 1].x - ideal) > 0.01)\n            ans[i] = 0;\n    \n\n    for(int i = 0; i < m - n + 1; i++)\n        printf(\"%d\", ans[i]);\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}