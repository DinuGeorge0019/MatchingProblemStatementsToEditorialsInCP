{"link": "https://codeforces.com//contest/1612/problem/E", "problemId": "1198239", "shortId": "1612E", "contest_number": "1612", "name": "E. Messages", "statement": "Monocarp is a tutor of a group of  students. He communicates with them using a conference in a popular messenger.Today was a busy day for Monocarp \u2014 he was asked to forward a lot of posts and announcements to his group, that's why he had to write a very large number of messages in the conference. Monocarp knows the students in the group he is tutoring quite well, so he understands which message should each student read: Monocarp wants the student  to read the message .Of course, no one's going to read all the messages in the conference. That's why Monocarp decided to pin some of them. Monocarp can pin any number of messages, and if he wants anyone to read some message, he should pin it \u2014 otherwise .Unfortunately, even if a message is pinned, some students may skip it anyway. For each student , Monocarp knows that they will read at most  messages. Suppose Monocarp pins  messages; if , then the -th student will read all the pinned messages; but if , the -th student will choose exactly  random pinned messages (all possible subsets of pinned messages of size  are equiprobable) and read only the chosen messages.Monocarp wants to maximize the expected number of students that read their respective messages (i.e. the number of such indices  that student  reads the message ). Help him to choose how many (and which) messages should he pin!", "input": "The first line contains one integer  () \u2014 the number of students in the conference. Then  lines follow. The -th line contains two integers  and  (; ) \u2014 the index of the message which Monocarp wants the -th student to read and the maximum number of messages the -th student will read, respectively.", "output": "In the first line, print one integer  () \u2014 the number of messages Monocarp should pin. In the second line, print   integers , , ...,  () \u2014 the indices of the messages Monocarp should pin. The messages can be listed in any order. If there are multiple answers, print any of them.", "tutorial": "First of all, let's rewrite the answer using expectation linearity. The expected number of students who read their respective messages is equal to , where  is a random value which is  if the -th student reads the message , and  if the -th student doesn't do it.Let's analyze the expected value of . Suppose Monocarp pins the messages . There are three cases:  if , then the -th student won't read the message , so ;  if  and , then the -th student will definitely read the message , so ;  if  and , then . If we iterate on the number of messages we pin , we can calculate the sum of  for each message (considering that we pin it), sort all of the messages and pick  best of them. So, we have a solution working in .The only thing we need to improve this solution sufficiently is the fact that we don't have to consider the case . Since every  is not greater than , the sum of  for a message in the case  is the same as this sum of  in the case , but multiplied by the coefficient  \u2014 and we pick  best values, their sum multiplied by  is not greater than the sum of  best values. The same holds for  and greater.", "solution": "#include <bits/stdc++.h>     \n\nusing namespace std;\n\nconst int N = 200043;\nconst int K = 20;\nvector<int> idx[N];\nint m[N], k[N];\n\nbool frac_greater(pair<int, int> a, pair<int, int> b)\n{\n    return a.first * b.second > a.second * b.first;\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%d %d\", &m[i], &k[i]);\n        idx[m[i]].push_back(i);\n    }\n\n    vector<int> cert;\n    pair<int, int> ans = {0, 1};\n    for(int i = 1; i <= K; i++)\n    {\n        vector<int> score(N);\n        for(int j = 0; j < n; j++)\n            score[m[j]] += min(i, k[j]);\n        vector<pair<int, int>> aux;\n        for(int j = 0; j < N; j++)\n            aux.push_back(make_pair(score[j], j));\n        sort(aux.rbegin(), aux.rend());\n        pair<int, int> cur_ans = {0, i};\n        vector<int> cur_cert;\n        for(int j = 0; j < i; j++)\n        {\n            cur_ans.first += aux[j].first;\n            cur_cert.push_back(aux[j].second);\n        }\n        if(frac_greater(cur_ans, ans))\n        {\n            ans = cur_ans;\n            cert = cur_cert;\n        }\n    }\n    cout << cert.size() << endl;\n    shuffle(cert.begin(), cert.end(), mt19937(time(NULL)));\n    for(auto x : cert) cout << x << \" \";\n    cout << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}