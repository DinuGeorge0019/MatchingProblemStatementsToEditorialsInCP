{"link": "https://codeforces.com//contest/845/problem/E", "problemId": "119175", "shortId": "845E", "contest_number": "845", "name": "E. Fire in the City", "statement": "The capital of Berland looks like a rectangle of size  of the square blocks of same size.Fire!It is known that  blocks got caught on fire (). Those blocks are centers of ignition. Moreover positions of  of these centers are known and one of these stays unknown. All  positions are distinct.The fire goes the following way: during the zero minute of fire only these  centers of ignition are burning. Every next minute the fire goes to all neighbouring blocks to the one which is burning. You can consider blocks to burn for so long that this time exceeds the time taken in the problem. The neighbouring blocks are those that touch the current block by a side or by a corner.Berland Fire Deparment wants to estimate the minimal time it takes the fire to lighten up the whole city. Remember that the positions of  blocks (centers of ignition) are known and ()-th can be positioned in any other block.Help Berland Fire Department to estimate the minimal time it takes the fire to lighten up the whole city.", "input": "The first line contains three integers ,  and  (, ). Each of the next  lines contain two integers  and  (, ) \u2014 coordinates of the -th center of ignition. It is guaranteed that the locations of all centers of ignition are distinct.", "output": "Print the minimal time it takes the fire to lighten up the whole city (in minutes).", "tutorial": "We can use binary search to find the answer.When binary searching, to check whether the whole city will be lightened up after  minutes, we can use sweep line technique to find the smallest -coordinate of the cell that is not lightened by  centers of ignition (and the smallest -coordinate too). Suppose that  and  are these coordinates; then we can place the last center of ignition at coordinates . Then we can use sweep line again to check whether the city is fully ignited.", "solution": "//package educational.round27;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class E {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), m = ni(), K = ni();\n\t\tint[][] co = new int[K][];\n\t\tfor(int i = 0;i < K;i++){\n\t\t\tco[i] = new int[]{ni()-1, ni()-1};\n\t\t}\n\t\tint low = -1, high = 1000000007;\n\t\twhile(high - low > 1){\n\t\t\tint h = high+low>>1;\n\t\t\tif(ok(h, co, n, m)){\n\t\t\t\thigh = h;\n\t\t\t}else{\n\t\t\t\tlow = h;\n\t\t\t}\n\t\t}\n\t\tout.println(high);\n\t}\n\t\n\tboolean ok(int h, int[][] co, int N, int M)\n\t{\n\t\tint n = co.length;\n\t\tint[][] rs = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\trs[i] = new int[]{\n\t\t\t\t\tMath.max(0, co[i][0]-h), \n\t\t\t\t\tMath.max(0, co[i][1]-h),\n\t\t\t\t\tMath.min(N, co[i][0]+h+1), \n\t\t\t\t\tMath.min(M, co[i][1]+h+1)\n\t\t\t};\n\t\t}\n\t\tint[] imapx;\n\t\t{\n\t\t\tint[] xs = new int[2*n+2];\n\t\t\tint p = 0;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\txs[p++] = rs[i][0];\n\t\t\t\txs[p++] = rs[i][2];\n\t\t\t}\n\t\t\txs[p++] = 0;\n\t\t\txs[p++] = N;\n\t\t\t\n\t\t\timapx = shrinkX(xs);\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\trs[i][0] = xs[2*i];\n\t\t\t\trs[i][2] = xs[2*i+1];\n\t\t\t}\n\t\t}\n\t\tint[] imapy;\n\t\t{\n\t\t\tint[] ys = new int[2*n+2];\n\t\t\tint p = 0;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tys[p++] = rs[i][1];\n\t\t\t\tys[p++] = rs[i][3];\n\t\t\t}\n\t\t\tys[p++] = 0;\n\t\t\tys[p++] = M;\n\t\t\timapy = shrinkX(ys);\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\trs[i][1] = ys[2*i];\n\t\t\t\trs[i][3] = ys[2*i+1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] imos = new int[imapx.length+2][imapy.length+2];\n\t\tfor(int[] r : rs){\n\t\t\timos[r[0]+1][r[1]+1]++;\n\t\t\timos[r[0]+1][r[3]+1]--;\n\t\t\timos[r[2]+1][r[1]+1]--;\n\t\t\timos[r[2]+1][r[3]+1]++;\n\t\t}\n\t\t\n\t\tfor(int i = 1;i < imapx.length+2;i++){\n\t\t\tfor(int j = 1;j < imapy.length+2;j++){\n\t\t\t\timos[i][j] += imos[i-1][j] + imos[i][j-1] - imos[i-1][j-1];\n\t\t\t}\n\t\t}\n//\t\tif(h == 2){\n//\t\t\ttr(imapx);\n//\t\t\ttr(imapy);\n//\t\t\ttr(rs);\n//\t\t\tfor(int[] row : imos){\n//\t\t\t\ttr(row);\n//\t\t\t}\n//\t\t}\n\t\t\n\t\tint minx = Integer.MAX_VALUE;\n\t\tint miny = Integer.MAX_VALUE;\n\t\tint maxx = -1;\n\t\tint maxy = -1;\n\t\tfor(int i = 1;i < imapx.length;i++){\n\t\t\tfor(int j = 1;j < imapy.length;j++){\n\t\t\t\tif(imos[i][j] == 0){\n\t\t\t\t\tminx = Math.min(minx, imapx[i-1]);\n\t\t\t\t\tminy = Math.min(miny, imapy[j-1]);\n\t\t\t\t\tmaxx = Math.max(maxx, imapx[i]-1);\n\t\t\t\t\tmaxy = Math.max(maxy, imapy[j]-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(minx > maxx)return true;\n\t\treturn maxy-miny+1 <= 2*h+1 && maxx-minx+1 <= 2*h+1;\n\t}\n\t\n\tpublic static int[] shrinkX(int[] a) {\n\t\tint n = a.length;\n\t\tlong[] b = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tb[i] = (long) a[i] << 32 | i;\n\t\tArrays.sort(b);\n\t\tint[] ret = new int[n];\n\t\tint p = 0;\n\t\tret[0] = (int) (b[0] >> 32);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i > 0 && (b[i] ^ b[i - 1]) >> 32 != 0) {\n\t\t\t\tp++;\n\t\t\t\tret[p] = (int) (b[i] >> 32);\n\t\t\t}\n\t\t\ta[(int) b[i]] = p;\n\t\t}\n\t\treturn Arrays.copyOf(ret, p + 1);\n\t}\n\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new E().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}