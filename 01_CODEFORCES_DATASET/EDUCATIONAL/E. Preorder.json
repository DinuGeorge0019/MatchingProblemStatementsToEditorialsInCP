{"link": "https://codeforces.com//contest/1671/problem/E", "problemId": "1376219", "shortId": "1671E", "contest_number": "1671", "name": "E. Preorder", "statement": "You are given a rooted tree of  vertices. Every vertex of this tree has either  children, or  children. All leaves of this tree have the same distance from the root, and for every non-leaf vertex, one of its children is the left one, and the other child is the right one. Formally, you are given a .The vertices of the tree are numbered in the following order:  the root has index ;  if a vertex has index , then its left child has index , and its right child has index . Every vertex of the tree has a letter written on it, either  or . Let's define the character on the vertex  as .Let the  of some vertex  be defined in the following way:  if the vertex  is a leaf, then the  of  be consisting of only one character ;  otherwise, the  of  is , where  operator defines concatenation of strings,  is the  of the left child of , and  is the  of the right child of . The  of the tree is the  of its root.You have to calculate the number of different strings that can be obtained as the  of the given tree, if you are allowed to perform the following operation any number of times before constructing the  of the tree:  choose any non-leaf vertex , and swap its children (so, the left child becomes the right one, and vice versa). ", "input": "The first line contains one integer  (). The second line contains a sequence of  characters . Each character is either  or . The characters are  by spaces or anything else.", "output": "Print one integer \u2014 the number of different strings that can be obtained as the  of the given tree, if you can apply any number of operations described in the statement. Since it can be very large, print it modulo .", "tutorial": "In terms of preorder strings, the operation \"swap two children of some vertex\" means \"swap two substrings of equal length in some specific location\". This operation can be inverted by applying it an additional time, so for every positive integer , all of the strings of length  are split into equivalence classes in such a way that two strings from the same class can be transformed into each other, and two strings from different classes cannot. For each vertex, the set of its possible preorder strings is one of these classes.Let's calculate the answer for the problem recursively: let  be the number of preorder strings for the vertex . For a leaf, the number of its preorder strings is . For a vertex  with children  and , one of the two holds:  if the equivalence class for vertex  is different from the equivalence class for vertex , then we have to pick a string from the class of vertex , pick a string from the class of vertex , and choose the order in which we take them. So, ;  if the equivalence class for  is the same as the equivalence class for , then swapping  and  doesn't do anything, so we pick a string from the equivalence class of , and then a string from the equivalence class of . So, . The only thing we don't know is how to determine if two vertices represent the same equivalence class. The model solution uses hashing for this, but there's a much simpler method: for each vertex , let  be the lexicographically smallest string that can be a preorder string of . If a vertex  has children  and , then , and we can calculate these strings recursively since the total length is  \u2014 each of  characters will be present in  strings.", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nmt19937 rnd(42);\n\nconst int MOD = 998244353;\nconst int K = 3;\n\nint add(int x, int y, int mod = MOD)\n{\n    x += y;\n    while(x >= mod) x -= mod;\n    while(x < 0) x += mod;\n    return x;\n}   \n\nint sub(int x, int y, int mod = MOD)\n{\n    return add(x, -y, mod);\n}   \n\nint mul(int x, int y, int mod = MOD)\n{\n    return (x * 1ll * y) % mod;\n}\n\nint binpow(int x, int y, int mod = MOD)\n{\n    int z = 1;\n    while(y > 0)\n    {\n        if(y % 2 == 1) z = mul(z, x, mod);\n        y /= 2;\n        x = mul(x, x, mod);\n    }   \n    return z;\n}\n\nbool prime(int x)\n{\n    for(int i = 2; i * 1ll * i <= x; i++)\n        if(x % i == 0)\n            return false;\n    return true;    \n}   \n\nint get_base()\n{\n    int x = rnd() % 10000 + 4444;\n    while(!prime(x)) x++;\n    return x;\n}   \n\nint get_modulo()\n{\n    int x = rnd() % int(1e9) + int(1e8);\n    while(!prime(x)) x++;\n    return x;\n}   \n\ntypedef array<int, K> hs;\n\nhs base, modulo;\n\nvoid generate_hs()\n{\n    for(int i = 0; i < K; i++)\n    {\n        base[i] = get_base();\n        modulo[i] = get_modulo();\n    }\n}   \n\nhs operator+(const hs& a, const hs& b)\n{\n    hs c;\n    for(int i = 0; i < K; i++)\n    {\n        c[i] = add(a[i], b[i], modulo[i]);    \n    }\n    return c;\n}\n\nhs operator-(const hs& a, const hs& b)\n{\n    hs c;\n    for(int i = 0; i < K; i++)\n    {\n        c[i] = sub(a[i], b[i], modulo[i]);    \n    }\n    return c;\n}\n\nhs operator*(const hs& a, const hs& b)\n{\n    hs c;\n    for(int i = 0; i < K; i++)\n    {\n        c[i] = mul(a[i], b[i], modulo[i]);    \n    }\n    return c;\n}\n\nhs operator^(const hs& a, const hs& b)\n{\n    hs c; \n    for(int i = 0; i < K; i++)\n    {\n        c[i] = binpow(a[i], b[i], modulo[i]);    \n    }\n    return c;\n}\n\nhs char_hash(char c)\n{\n    hs res;\n    for(int i = 0; i < K; i++)\n        res[i] = c - 'A' + 1;\n    return res;\n}\n\nconst int N = 18;\nconst int V = 1 << N;\nstring s;\nchar buf[V + 43];\nint n;\nint ans[V + 43];\nhs vertex_hash[V + 43];\n\nbool is_leaf(int x)\n{\n    return (x * 2 + 1) >= ((1 << n) - 1);\n}\n\nvoid rec(int x)\n{\n    vertex_hash[x] = char_hash(s[x]);\n    ans[x] = 1;\n    if(is_leaf(x)) \n    {\n        return;\n    }\n    rec(x * 2 + 1);\n    rec(x * 2 + 2);\n    vertex_hash[x] = vertex_hash[x] + (base ^ vertex_hash[2 * x + 1]) + (base ^ vertex_hash[2 * x + 2]);\n    ans[x] = mul(ans[2 * x + 1], ans[2 * x + 2]);\n    if(vertex_hash[2 * x + 1] != vertex_hash[2 * x + 2])\n        ans[x] = mul(ans[x], 2);\n}\n \nint main() \n{\n    generate_hs();\n    scanf(\"%d\", &n);\n    scanf(\"%s\", buf);\n    s = buf;\n    rec(0);\n    cout << ans[0] << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}