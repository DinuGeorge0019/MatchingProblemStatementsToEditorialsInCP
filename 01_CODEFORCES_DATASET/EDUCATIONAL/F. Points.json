{"link": "https://codeforces.com//contest/1701/problem/F", "problemId": "1455054", "shortId": "1701F", "contest_number": "1701", "name": "F. Points", "statement": "A triple of points ,  and  on a coordinate line is called  if  and .You are given a set of points on a coordinate line, initially empty. You have to process queries of three types:  add a point;  remove a point;  calculate the number of beautiful triples consisting of points belonging to the set. ", "input": "The first line contains two integers  and  () \u2014 the number of queries and the parameter for defining if a triple is beautiful, respectively. The second line contains  integers  () denoting the queries. The integer  denotes the -th query in the following way:   if the point  belongs to the set, remove it; otherwise, add it;  after adding or removing the point, print the number of beautiful triples. ", "output": "For each query, print one integer \u2014 the number of beautiful triples after processing the respective query.", "tutorial": "We are going to calculate the answer as follows: for every point , let  be the number of points  such that  (i.\u2009e. the number of points that are to the right of  and have distance at most  from it). Then, the number of beautiful triples where  is the leftmost point is . We can sum these values over all points to get the answer; so, the solution should somehow maintain and update the sum of these values efficiently.Let's see what happens when we add a new point or remove an existing point. For all points to the left of it with distance no more than , the value of  increases or decreases by . So, we need some sort of data structure that allows adding/subtracting  on segment and maintains the sum of . This looks like a lazy segment tree, but updating the sum of  can be tricky.One way to do this is to notice that . So maybe we can maintain the sum of  and the sum of  on the segment? It turns out we can. The model solution does this as follows: the leaf of the segment tree corresponding to the position  stores a vector with three values: . The inner nodes store the sums of these vectors in the subtree. We can find a matrix which, when multiplied by , gets the vector , and the inverse matrix to it. Then adding  to  on segment means multiplying all vectors on segment by that matrix, and subtracting  means multiplying by the inverse matrix; and since matrix multiplication is both associative and distributive, the segment tree can handle these queries..Okay, there's only one small issue left: right now our structure can store the sum of  and  over all possible points (we build it on segment , for example), but we only need the sum over  points. One way to handle it is to use a flag for each leaf of the segment tree, and pull the value up from the leaf only if this flag is true. We will need a function that changes the value of this flag for a single leaf, but it's not very different from a function that changes one value in a lazy segment tree.Time complexity of the solution is , where  is the maximum coordinate of the point, although the constant factor of the described approach is fairly large since it involves  matrix multiplications. You can improve the constant factor by getting rid of the matrices, as mentioned earlier.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\nconst int M = 200001;\n\ntypedef array<long long, 3> vec;\ntypedef array<vec, 3> mat;\n\nvec operator+(const vec& a, const vec& b)\n{\n    vec c;\n    for(int i = 0; i < 3; i++) c[i] = a[i] + b[i];\n    return c;\n}\n\nvec operator-(const vec& a, const vec& b)\n{\n    vec c;\n    for(int i = 0; i < 3; i++) c[i] = a[i] - b[i];\n    return c;\n}\n\nvec operator*(const mat& a, const vec& b)\n{\n    vec c;\n    for(int i = 0; i < 3; i++) c[i] = 0;\n    for(int i = 0; i < 3; i++)\n        for(int j = 0; j < 3; j++)\n            c[i] += a[i][j] * b[j];\n    return c;\n}\n\nmat operator*(const mat& a, const mat& b)\n{\n    mat c;\n    for(int i = 0; i < 3; i++)\n        for(int j = 0; j < 3; j++)\n            c[i][j] = 0;\n    for(int i = 0; i < 3; i++)\n        for(int j = 0; j < 3; j++)\n            for(int k = 0; k < 3; k++)\n                c[i][k] += a[i][j] * b[j][k];\n    return c;\n}\n\nmat F = {vec({1, 0, 0}), vec({1, 1, 0}), vec({1, 2, 1})};\nmat B = {vec({1, 0, 0}), vec({-1, 1, 0}), vec({1, -2, 1})};\nmat E = {vec({1, 0, 0}), vec({0, 1, 0}), vec({0, 0, 1})};\n\nvec S = {1, 0, 0};\nvec Z = {0, 0, 0};\n\nvec t[4 * N];\nmat f[4 * N];\nbool active[4 * N];\nbool has[N];\nint d, q;\n\nvec getVal(int v)\n{\n    if(!active[v]) return Z;\n    return f[v] * t[v];\n}\n\nvoid recalc(int v)\n{\n    t[v] = getVal(v * 2 + 1) + getVal(v * 2 + 2);    \n}\n\nvoid build(int v, int l, int r)\n{\n    if(l == r - 1)\n    {\n        f[v] = E;\n        t[v] = S;\n        active[v] = false;                 \n    }\n    else\n    {\n        int m = (l + r) / 2;\n        build(v * 2 + 1, l, m);\n        build(v * 2 + 2, m, r);\n        f[v] = E;\n        recalc(v);\n        active[v] = true;               \n    }\n}\n\nvoid push(int v)\n{\n    if(f[v] == E) return;\n    t[v] = f[v] * t[v];\n    f[v * 2 + 1] = f[v] * f[v * 2 + 1];\n    f[v * 2 + 2] = f[v] * f[v * 2 + 2];\n    f[v] = E;\n}\n\nvoid updSegment(int v, int l, int r, int L, int R, bool adv)\n{\n    if(L >= R) return;\n    if(l == L && r == R)\n    {\n        if(adv) f[v] = F * f[v];\n        else f[v] = B * f[v];\n        return;\n    }\n    push(v);\n    int m = (l + r) / 2;\n    updSegment(v * 2 + 1, l, m, L, min(m, R), adv);\n    updSegment(v * 2 + 2, m, r, max(m, L), R, adv);\n    recalc(v);\n}\n\nvoid setState(int v, int l, int r, int pos, bool val)\n{\n    if(l == r - 1)\n    {   \n        active[v] = val;\n        return;\n    }\n    push(v);\n    int m = (l + r) / 2;\n    if(pos < m)\n        setState(v * 2 + 1, l, m, pos, val);\n    else\n        setState(v * 2 + 2, m, r, pos, val);\n    recalc(v);\n}\n\nvoid addPoint(int x)\n{\n    int lf = max(0, x - d);\n    int rg = x;\n    if(lf < rg)\n        updSegment(0, 0, M, lf, rg, true);\n    setState(0, 0, M, x, true);        \n}\n\nvoid delPoint(int x)\n{\n    int lf = max(0, x - d);\n    int rg = x;\n    if(lf < rg)\n        updSegment(0, 0, M, lf, rg, false);\n    setState(0, 0, M, x, false);        \n}\n\nvoid query(int x)\n{\n    if(has[x])\n    {\n        has[x] = false;\n        delPoint(x);\n    }\n    else\n    {\n        has[x] = true;\n        addPoint(x);\n    }\n    vec res = getVal(0);\n    printf(\"%lld\\n\", (res[2] - res[1]) / 2);\n}\n\nint main()\n{\n    scanf(\"%d %d\", &q, &d);\n    build(0, 0, M);\n    for(int i = 0; i < q; i++)\n    {\n        int x;\n        scanf(\"%d\", &x);\n        query(x);\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}