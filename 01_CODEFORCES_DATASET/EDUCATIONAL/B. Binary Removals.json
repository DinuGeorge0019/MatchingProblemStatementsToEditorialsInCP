{"link": "https://codeforces.com//contest/1499/problem/B", "problemId": "928250", "shortId": "1499B", "contest_number": "1499", "name": "B. Binary Removals", "statement": "You are given a string , consisting only of characters '' or ''. Let  be the length of .You are asked to choose some integer  () and find a sequence  of length  such that:   ;   for all  from  to . The characters at positions  are removed, the remaining characters are concatenated without changing the order. So, in other words, the positions in the sequence  should not be adjacent.Let the resulting string be .  is called sorted if for all  from  to  .Does there exist such a sequence  that the resulting string  is sorted?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. Then the descriptions of  testcases follow. The only line of each testcase contains a string  (). Each character is either '' or ''.", "output": "For each testcase print \"\" if there exists a sequence  such that removing the characters at positions  and concatenating the parts without changing the order produces a sorted string. Otherwise, print \"\". You may print every letter in any case you want (so, for example, the strings , ,  and  are all recognized as positive answer).", "tutorial": "There are several different ways to solve this problem. In my opinion, the two easiest solutions are:  notice that, in the sorted string, there is a prefix of zeroes and a suffix of ones. It means that we can iterate on the prefix (from which we remove all ones), and remove all zeroes from the suffix we obtain. If we try to remove two adjacent characters, then we cannot use this prefix;  if there is a substring  before the substring  in our string, then from both of the substrings, at least one character remains, so if the first occurrence of  is earlier than the last occurrence of , there is no answer. Otherwise, the answer always exists. ", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    string s;\n    cin >> s;\n    int i = s.find(\"11\");\n    int j = s.rfind(\"00\");\n    cout << (i != -1 && j != -1 && i < j ? \"NO\" : \"YES\") << endl;\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}