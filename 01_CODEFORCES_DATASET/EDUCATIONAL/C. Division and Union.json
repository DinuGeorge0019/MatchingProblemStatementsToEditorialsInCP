{"link": "https://codeforces.com//contest/1101/problem/C", "problemId": "281056", "shortId": "1101C", "contest_number": "1101", "name": "C. Division and Union", "statement": "There are  segments  for . You should divide all segments into two  groups in such way that there is no pair of segments from different groups which have at least one common point, or say that it's impossible to do it. Each segment should belong to exactly one group.To optimize testing process you will be given multitest.", "input": "The first line contains one integer  () \u2014 the number of queries. Each query contains description of the set of segments. Queries are independent. First line of each query contains single integer  () \u2014 number of segments. It is guaranteed that  over all queries does not exceed . The next  lines contains two integers ,  per line () \u2014 the -th segment.", "output": "For each query print  integers  () \u2014 for each segment (in the same order as in the input)  equals  if the -th segment will belongs to the first group and  otherwise. If there are multiple answers, you can print any of them. If there is no answer, print .", "tutorial": "Let's prove that division possible if and only if union of all segments has two and more segments. If the union have at least two segments, then we can choose one of them and put all segments it contains in one group and other segments to another group. On the other hand, if we can divide all segments in two groups in such way that there are no pair from different group which intersects, then union of segments from the first group doesn't intersect union of segments from another and union of unions consists of several non-intersecting components.How can it help? If union of segments consits of several segments then exists  such that for any segment  either  or  and both parts are non-empty. Moreover,  equals to one of .It leads us straight to one of possible solutions: sort all segments by  in increasing order and for each  we should check that  (suffix minimum). If we've found such  then all prefix goes to one group and suffix \u2014 to another.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int, int> pt;\n\nint n;\nvector< pair<pt, int> > segs;\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\tsegs.resize(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> segs[i].x.x >> segs[i].x.y;\n\t\tsegs[i].y = i;\n\t}\n\treturn true;\n}\n\nbool cmp(const pair<pt, int> &a, const pair<pt, int> &b) {\n\tif(a.x.y != b.x.y)\n\t\treturn a.x.y < b.x.y;\n\tif(a.x.x != b.x.x)\n\t\treturn a.x.x < b.x.x;\n\treturn a.y < b.y;\n}\n\ninline void solve() {\n\tsort(segs.begin(), segs.end(), cmp);\n\t\n\tint mn = segs[n - 1].x.x;\n\tfor(int i = n - 2; i >= 0; i--) {\n\t\tif(segs[i].x.y < mn) {\n\t\t\tvector<int> ts(n, 2);\n\t\t\tfor(int id = 0; id <= i; id++)\n\t\t\t\tts[segs[id].y] = 1;\n\t\t\t\n\t\t\tfor(int t : ts)\n\t\t\t\tcout << t << ' ';\n\t\t\tcout << '\\n';\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t\tmn = min(mn, segs[i].x.x);\n\t}\n\tcout << -1 << '\\n';\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tint tc;\n\tcin >> tc;\n\t\n\twhile(tc--) {\n\t\tassert(read());\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}