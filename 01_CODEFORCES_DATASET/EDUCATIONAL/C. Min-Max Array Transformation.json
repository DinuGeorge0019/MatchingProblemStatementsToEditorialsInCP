{"link": "https://codeforces.com//contest/1721/problem/C", "problemId": "1521726", "shortId": "1721C", "contest_number": "1721", "name": "C. Min-Max Array Transformation", "statement": "You are given an array , which is sorted in non-descending order. You decided to perform the following steps to create array :   Create an array  consisting of  arbitrary  integers.  Set  for each .  Sort the array  in non-descending order. You are given the resulting array . For each index , calculate what is the minimum and maximum possible value of  you can choose in order to get the given array .Note that the minimum (maximum) -s are  of each other, i.\u00a0e. they can be obtained from different possible arrays .", "input": "The first line contains the single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains a single integer  ()\u00a0\u2014 the length of arrays ,  and . The second line contains  integers  (; )\u00a0\u2014 the array  in non-descending order. The third line contains  integers  (; )\u00a0\u2014 the array  in non-descending order. Additional constraints on the input:    there is at least one way to obtain the array  from the  by choosing an array  consisting of ;  the sum of  doesn't exceed . ", "output": "For each test case, print two lines. In the first line, print  integers , where  is the minimum possible value you can add to . Secondly, print  integers , where  is the maximum possible value you can add to . All  and  values are independent of each other. In other words, for each ,  is just the minimum value among all possible values of .", "tutorial": "For the start, let's note that  for each . Otherwise, there is no way to get  from .Firstly, let's calculate  for each . Since all  then  is always greater or equal than  you get it from. So, the minimum  would come from lowest  that still . Since  is sorted, we can find such  with  in .Let's prove that we can build such  that transforms  to  we found earlier. Let's just make  for ;  for  and . It's easy to see that all  are non-negative, so such  is valid.Now, let's calculate . Suppose, we transform  to  for some . It's not hard to prove that the \"proving\" array  may be constructed in the similar way:  for ;  for  and .In order to build such array , you need  for each . In other words, if there is some position  such that  and  you can't choose  such that . It means that we can iterate  in descending order and just keep track of leftmost  with . Then,  is equal to  (or  if there are no such ).The resulting complexity is  because of the first part. But it can be optimized to  if we use two pointers instead of .", "solution": "fun main() {\n    repeat(readLine()!!.toInt()) {\n        val n = readLine()!!.toInt()\n        val a = readLine()!!.split(' ').map { it.toInt() }\n        val b = readLine()!!.split(' ').map { it.toInt() }\n\n        val indices = (0 until n).sortedBy { a[it] }\n        val mn = Array(n) { 0 }\n        val mx = Array(n) { 0 }\n\n        var lst = n\n        for (i in n - 1 downTo 0) {\n            val pos = indices[i]\n            mn[pos] = lowerBound(b, a[pos])\n            mx[pos] = lst - 1;\n            if (i == mn[pos])\n                lst = i\n\n            mn[pos] = b[mn[pos]] - a[pos]\n            mx[pos] = b[mx[pos]] - a[pos]\n        }\n        println(mn.joinToString(\" \"))\n        println(mx.joinToString(\" \"))\n    }\n}\n\nfun lowerBound(a: List<Int>, v: Int): Int {\n    var l = -1; var r = a.size\n    while (r - l > 1) {\n        val m = (l + r) / 2\n        if (a[m] < v)\n            l = m\n        else\n            r = m\n    }\n    return r\n}", "interactive": false, "noSolution": false, "noTutorial": false}