{"link": "https://codeforces.com//contest/1334/problem/B", "problemId": "590682", "shortId": "1334B", "contest_number": "1334", "name": "B. Middle Class", "statement": "Many years ago Berland was a small country where only  people lived. Each person had some savings: the -th one had  burles.The government considered a person as wealthy if he had at least  burles. To increase the number of wealthy people Berland decided to carry out several reforms. Each reform looked like that:   the government chooses some subset of people (maybe all of them);  the government takes all savings from the chosen people and redistributes the savings among the chosen people equally. For example, consider the savings as list : if the government chose the -st and the -rd persons then it, at first, will take all  burles and after that will return  burles to the chosen people. As a result, the savings will become .A lot of data was lost from that time, so we don't know how many reforms were implemented and to whom. All we can do is ask you to calculate the maximum possible number of wealthy people after several (maybe zero) reforms.", "input": "The first line contains single integer  () \u2014 the number of test cases. Next  lines contain the test cases \u2014 two lines per test case. The first line contains two integers  and  (, ) \u2014 the number of people and the minimum amount of money to be considered as wealthy. The second line contains  integers  () \u2014 the initial savings of each person. It's guaranteed that the total sum of  doesn't exceed .", "output": "Print  integers \u2014 one per test case. For each test case print the maximum possible number of wealthy people after several (maybe zero) reforms.", "tutorial": "In fact, to carry out only one reform is always enough. And it's easy to prove if you make only one reform it's always optimal to take the maximum such  that the average of  maximums in the array  is at least  (i.e. sum greater or equal to ). So the solution is next: sort array  and find the suffix with maximum length  such that the sum on the suffix is at least .===To prove the fact about one reform we can prove another fact: after each reform, the sum of  maximums doesn't increase for each . We'll prove it in two steps.The first step. Let's look at some reform and form an array  from the chosen elements in  in descending order. After the reform we'll get array  where all . Let's just skip the proof and say it's obvious enough that  for any .The second step. Let fix  and divide array  on two parts:  maximums as  and other  elements as . And let's make the same division of  (the array after performing the reform) on  and . So, we need to prove that . Suppose  elements were chosen in the reform:  of them were in  and  now in . If  then we can think like maximum  elements from  elements in  were replaced by the average and other  were replaced by elements from . Since  and any element from  is greater or equal to any element from  then we proved that  when .If  then let's look at  and . The  has  chosen elements and  has , so  and we can prove that  practically in the same way as before. Obviously, if  and  then . Q.E.D.The last step is easy, let's prove that the only reform is enough. The answer after several reforms is clearly equal to  maximums which are at least . But it means that the sum of  maximums is at least , therefore the sum of  maximums in the initial array is at least . So we can make them all at least  by only one reform. ", "solution": "fun main() {\n    val T = readLine()!!.toInt()\n    for (tc in 1..T) {\n        val (n, x) = readLine()!!.split(' ').map { it.toInt() }\n        val a = readLine()!!.split(' ').map { it.toInt() }.sortedDescending()\n\n        var cnt = 0\n        var sum = 0L\n        while (cnt < n && sum + a[cnt] >= (cnt + 1) * x.toLong()) {\n            sum += a[cnt]\n            cnt++\n        }\n        println(cnt)\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}