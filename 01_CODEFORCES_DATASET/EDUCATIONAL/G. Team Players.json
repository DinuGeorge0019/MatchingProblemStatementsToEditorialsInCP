{"link": "https://codeforces.com//contest/985/problem/G", "problemId": "184588", "shortId": "985G", "contest_number": "985", "name": "G. Team Players", "statement": "There are  players numbered from  to  with ranks. The -th player has rank .Players can form teams: the team should consist of three players and  of players in the team should have a conflict. The rank of the team is calculated using the following algorithm: let , ,  be the ranks of players in the team and , then the rank of the team is equal to .You are given information about the pairs of players who  a conflict. Calculate the total sum of ranks over all possible valid teams modulo .", "input": "The first line contains two space-separated integers  and  (, ) \u2014 the number of players and the number of conflicting pairs. The second line contains three space-separated integers ,  and  () \u2014 coefficients for team rank calculation. Each of the next  lines contains two space-separated integers  and  () \u2014 pair of conflicting players. It's guaranteed that each unordered pair of players appears in the input file no more than once.", "output": "Print single integer \u2014 the total sum of ranks over all possible teams modulo .", "tutorial": "Let's solve this task in several steps.At first, let's calculate  \u2014 sum of all triples. For each player  consider three cases:    \u2014 there are exactly  ways to choose triple;   \u2014 there are  ways;   \u2014 there are  ways. At second, let's calculate  \u2014 sum over all triples  such that exists pair  or . To calculate it we need for each  iterate over all neighbors  of . Again some cases:   if  then there are exactly  ways to choose ;  if , there are  ways to choose .  But we calculated some triples twice, so we need to subtract triples  where both  and  exists. It is easy to calculate sorting adjacency lists of all .At third, let's calculate  \u2014 sum over all triple  where exists pair , but pairs  and  are not. .    is a sum of all triples  where pair  exists. It can be calculated while iterating  in increasing order.   is a sum of all triples  where pairs  and  exists. It can be calculated while iterating  and asking sum on segment of adjacency list of  ( with prefix sums for each vertex ).   is a sum of all triples  where pairs  and  exists. It can be calculated while iterating  and asking sum on prefix of adjacency list of  (same ).   is a sum of all triples  where all pairs ,  and  exists. It is modification of calculating number of triangles in graph. It can be done in  and will be explained below. Then result .The algorithm of finding  in the given graph  is following:Let's call vertex  if  and  otherwise. For each heavy vertex  precalculate  \u2014 boolean array of adjacency of vertex . It's cost  of memory and time but memory can be reduced by using bitsets.To calculate number of triangles  let's iterate over . There are two cases:   if  is heavy, then just iterate over all edges  and check  and . This part works with  time since there are  heavy vertices.  if  is light, then iterate over all pair , where  (at first fix , then iterate ). To check existence of edge  consider two more cases:   if  is heavy, just check . It works in .  if  is light, just check in some global array  all neighbors of , check all  with  and uncheck neighbors of . Checking in array  require  time and will be done  times. So it will be  in total.  Similarly, iterating pairs  works with  in total. So comlexity of algorithm and all task is .", "solution": "#include <bits/stdc++.h>\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int(a.size())\n\nusing namespace std;\n\ntypedef unsigned long long uli;\n\nconst int N = 200 * 1000 + 555;\n\nint n, m;\nuli a, b, c;\nvector<int> g[N];\n\ninline bool read() {\n\tif(!(cin >> n >> m))\n\t\treturn false;\n\tassert(cin >> a >> b >> c);\n\tfore(i, 0, m) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\t\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<uli> ps[N];\n\ninline uli getSum(int v, int l, int r) {\n\treturn ps[v][r] - ps[v][l];\n}\n\nconst int MX = 700;\nint id[N];\n\nconst int B = 1111;\nbitset<N> has[B];\nint szh = 0;\n\ninline void solve() {\n\tmemset(id, -1, sizeof id);\n\tszh = 0;\n\tfore(v, 0, n) {\n\t\tsort(g[v].begin(), g[v].end());\n\t\t\n\t\tps[v].assign(sz(g[v]) + 1, 0);\n\t\tfore(i, 0, sz(g[v]))\n\t\t\tps[v][i + 1] = ps[v][i] + g[v][i];\n\t\t\n\t\tif(sz(g[v]) >= MX) {\n\t\t\tassert(szh < B);\n\t\t\tid[v] = szh++;\n\t\t\t\n\t\t\tfor(int to : g[v])\n\t\t\t\thas[id[v]][to] = 1;\n\t\t}\n\t}\n\t\n\tuli all = 0;\n\tfore(v, 0, n) {\n\t\tuli lw = v, gr = n - v - 1;\n\t\tall += a * v * (gr * (gr - 1) / 2);\n\t\tall += b * v * (lw * gr);\n\t\tall += c * v * (lw * (lw - 1) / 2);\n\t}\n\t\n\tuli sub1 = 0;\n\tfore(v, 0, n) {\n\t\tfor(int to : g[v]) {\n\t\t\tif(to > v)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tuli cnt = to;\n\t\t\tuli sum = cnt * (cnt - 1) / 2;\n\t\t\tsub1 += a * sum + cnt * (b * to + c * v);\n\t\t\t\n\t\t\tcnt = v - to - 1;\n\t\t\tsum = (2 * to + cnt + 1) * cnt / 2;\n\t\t\tsub1 += b * sum + cnt * (a * to + c * v);\n\t\t}\n\t\t\n\t\tuli sum = 0;\n\t\tfore(i, 0, sz(g[v])) {\n\t\t\tif(g[v][i] > v)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tuli cnt = i;\n\t\t\tsub1 -= a * sum + cnt * (b * g[v][i] + c * v);\n\t\t\tsum += g[v][i];\n\t\t}\n\t}\n\tall -= sub1;\n\t\n\tuli sub2 = 0;\n\tuli cntE = 0, sumE = 0;\n\tfore(v, 0, n) {\n\t\tsub2 += sumE + cntE * c * v;\n\t\tfor(int to : g[v]) {\n\t\t\tif(to > v)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcntE++;\n\t\t\tsumE += a * to + b * v;\n\t\t}\n\t}\n\t\n\tfore(v, 0, n) {\n\t\tfor(int to : g[v]) {\n\t\t\tif(to > v)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tint pos = int(lower_bound(g[to].begin(), g[to].end(), to) - g[to].begin());\n\t\t\tsub2 -= a * getSum(to, 0, pos) + pos * (b * to + c * v);\n\t\t\t\n\t\t\tint pos2 = int(lower_bound(g[to].begin(), g[to].end(), v) - g[to].begin());\n\t\t\tsub2 -= b * getSum(to, pos, pos2) + (pos2 - pos) * (a * to + c * v);\n\t\t}\n\t}\n\t\n\tvector<char> curh(n + 5, 0);\n\tfore(v, 0, n) {\n\t\tif(id[v] == -1) {\n\t\t\tfore(i2, 0, sz(g[v])) {\n\t\t\t\tint u2 = g[v][i2];\n\t\t\t\tif(u2 > v)\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tif(id[u2] != -1) {\n\t\t\t\t\tfore(i1, 0, i2) {\n\t\t\t\t\t\tint u1 = g[v][i1];\n\t\t\t\t\t\tif(has[id[u2]][u1])\n\t\t\t\t\t\t\tsub2 += a * u1 + b * u2 + c * v;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor(int to : g[u2]) {\n\t\t\t\t\t\tif(to > u2)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcurh[to] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tfore(i1, 0, i2) {\n\t\t\t\t\t\tint u1 = g[v][i1];\n\t\t\t\t\t\tif(curh[u1])\n\t\t\t\t\t\t\tsub2 += a * u1 + b * u2 + c * v;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int to : g[u2]) {\n\t\t\t\t\t\tif(to > u2)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcurh[to] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfore(u2, 0, v) {\n\t\t\t\tif(!has[id[v]][u2])\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int u1 : g[u2]) {\n\t\t\t\t\tif(u1 > u2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(has[id[v]][u1])\n\t\t\t\t\t\tsub2 += a * u1 + b * u2 + c * v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tall -= sub2;\n\tcout << all << endl;\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(10);\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}