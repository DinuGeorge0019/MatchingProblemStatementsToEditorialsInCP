{"link": "https://codeforces.com//contest/1167/problem/G", "problemId": "344636", "shortId": "1167G", "contest_number": "1167", "name": "G. Low Budget Inception", "statement": "So we got bored and decided to take our own guess at how would \"Inception\" production go if the budget for the film had been terribly low.The first scene we remembered was the one that features the whole city bending onto itself:  It feels like it will require high CGI expenses, doesn't it? Luckily, we came up with a similar-looking scene which was a tiny bit cheaper to make.Firstly, forget about 3D, that's hard and expensive! The city is now represented as a number line ().Secondly, the city doesn't have to look natural at all. There are  buildings on the line. Each building is a square .  Lower corners of building  are at integer points  and  of the number line. Also the distance between any two neighbouring buildings  and  doesn't exceed  (). Distance between some neighbouring buildings  and  is calculated from the lower right corner of building  to the lower left corner of building .Finally, curvature of the bend is also really hard to simulate! Let the bend at some integer coordinate  be performed with the following algorithm. Take the ray from  to  and all the buildings which are on this ray and start turning the ray and the buildings counter-clockwise around point . At some angle some building will touch either another building or a part of the line. You have to stop bending there (). The only thing left is to decide what integer point  is the best to start bending around. Fortunately, we've already chosen  candidates to perform the bending.So, can you please help us to calculate terminal angle  for each bend  from our list of candidates?", "input": "The first line contains two integer numbers  and  (, ) \u2014 the number of buildings and the maximum distance between any pair of neighbouring buildings, respectively. The second line contains  integers  (, ) \u2014 coordinates of left corners of corresponding buildings in ascending order. The third line contains single integer  () \u2014 the number of candidates. The fourth line contains  integers  (, ) \u2014 the coordinates of bends you need to calculate terminal angles for in ascending order.", "output": "Print  numbers. For each bend  print terminal angle  (in radians). Your answer is considered correct if its absolute error does not exceed . Formally, let your answer be , and the jury's answer be . Your answer is accepted if and only if .", "tutorial": "Let's solve the problem for a single query at first. There are two possible types of collisions: between two buildings and between a building and a ray. Obviously, if the collision of the second type happens, then it's the building which is the closest to the bend point (from either left or right). The less obvious claim is that among all buildings collisions, the closest is the biggest angle one. Let's boil down some possibilities of colliding buildings. Let two buildings be the same distance  from the bend point . Then they will collide and the collision point will . Two buildings also collide if the left one is  from  and the right one is . Then the point of collision is . And for the opposite case the point of collision is also . These points can be easily proven by checking the distances to upper corners of each building. No other two buildings will collide.Now that we know this, we can transition to solving a problem of checking if there exists such a pair that the distances to  from them differ by at most one. Finding such a pair with minimal  is enough. Obviously, this can be done with some sort of two pointers. However, that's not the intended solution.Let's constuct bitset of 7000 positions to the left of the bend and to the right of the bend. AND of these bitsets will give you the pairs such that the distance  is the same for them. However, you can put 1 in points  and  for each building to the left and  and  for each building to the right. This way AND will give you the exact pairs you need. Use _Find_first to find the closest one.Let collision happen on distance . Then the collision of the first type will have angle  and the collision of the second type will have angle . The answer is the maximum of these two values. Be careful with cases where .How to process lots of queries. Let's just move the bitsets to the right while going through queries in ascending order. Bitsets can be updated in  for each query and only  buildings will be added to them in total.Overall complexity: .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 200 * 1000 + 555;\nconst int D = 7077;\n\nint n, d, m;\nint a[N], qs[N];\n\ninline bool read() {\n\tif(scanf(\"%d%d\", &n, &d) != 2)\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tassert(scanf(\"%d\", &m) == 1);\n\tfore(i, 0, m)\n\t\tscanf(\"%d\", &qs[i]);\n\treturn true;\n}\n\nbitset<D> L, R, cur;\nint dist[N];\nset<int> has;\n\nvoid shiftL(int s, int t, int &uk) {\n\tL <<= t - s;\n\tfor(; uk < n && a[uk] < t; uk++) {\n\t\tif(t - a[uk] - 1 < D)\n\t\t\tL[t - a[uk] - 1] = 1;\n\t\tif(t - a[uk] < D)\n\t\t\tL[t - a[uk]] = 1;\n\t}\n}\n\nvoid shiftR(int s, int t, int &uk) {\n\tR >>= t - s;\n\tif(!has.count(t))\n\t\tR[0] = 0;\n\t\n\tfor(; uk < n && a[uk] < t + D; uk++) {\n\t\tif(a[uk] - t >= 0) {\n\t\t\tR[a[uk] - t] = 1;\n\t\t\tif(a[uk] - t + 1 >= 0)\n\t\t\t\tR[a[uk] - t + 1] = 1;\n\t\t}\n\t}\n}\n\ninline void solve() {\n\tfore(i, 0, m) {\n\t\tdist[i] = INF;\n\t\tint pos = int(lower_bound(a, a + n, qs[i]) - a);\n\t\tif(pos > 0)\n\t\t\tdist[i] = qs[i] - a[pos - 1] - 1;\n\t\tif(pos < n)\n\t\t\tdist[i] = min(dist[i], a[pos] - qs[i]);\n\t}\n\thas = set<int>(a, a + n);\n\t\n\tint uL = 0, uR = 0;\n\tL.reset();\n\tR.reset();\n\tfore(i, 0, m) {\n\t\tshiftL(i > 0 ? qs[i - 1] : -D, qs[i], uL);\n\t\tshiftR(i > 0 ? qs[i - 1] : -D, qs[i], uR);\n\t\t\n\t\tdouble ans = atan2(1, dist[i]);\n\n\t\tcur = L & R;\n\t\tint pos = (int)cur._Find_first();\n\t\tif(pos < D) {\n\t\t\tint ds = pos;\n\t\t\tans = max(ans, 2 * atan2(1, ds));\n\t\t}\n\t\tprintf(\"%.15f\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}