{"link": "https://codeforces.com//contest/1814/problem/E", "problemId": "1867160", "shortId": "1814E", "contest_number": "1814", "name": "E. Chain Chips", "statement": "You are given an undirected graph consisting of  vertices and  edges. The -th edge has weight ; it connects the vertices  and .Initially, each vertex contains a chip. Each chip has an integer written on it; the integer written on the chip in the -th vertex is .In one operation, you can choose a chip (if there are multiple chips in a single vertex, you may choose any one of them) and move it along one of the edges of the graph. The cost of this operation is equal to the weight of the edge.The  of the graph is the minimum cost of a sequence of such operations that meets the following condition:  after all operations are performed, each vertex contains exactly one chip, and the integer on each chip is  to the index of the vertex where that chip is located. You are given  queries of the form:    \u2014 change the weight of the -th edge (the one which connects the vertices  and ) to . After each query, print the  of the graph. Note that you don't actually move any chips; when you compute the cost, the chips are on their initial positions.", "input": "The first line contains one integer  (). The second line contains  integers  (). The third line contains one integer  (). Then  lines follow. The -th of them contains two integers  and  (; ) for the -th query.", "output": "For each query, print one integer \u2014 the  of the graph after the query is performed.", "tutorial": "Let's try to analyze how many times we traverse each edge, in the style of \"Contribution to the Sum\" technique. For each edge, the number of times it is traversed must be even, since for every chip that goes from the part of the graph $$$[1..i]$$$ to the part $$$[i+1..n]$$$, there should be a chip that goes in the opposite direction (the number of chips on vertices $$$[1..n]$$$ should be unchanged).For each vertex, at least one incident edge should be traversed at least twice \u2014 otherwise, the chip from this vertex cannot be moved to any other vertex.We would also like to traverse the edges as rarely as possible. Is it possible to find an answer where, if we traverse any edge, we traverse it only twice? It turns out it is possible. Let's \"split\" the graph into several parts by removing the edges we don't traverse. If we don't break the constraint that each vertex has at least one incident edge which is traversed by some chip, then each part of the graph will contain at least two vertices. And in each part, we can make sure that each edge is traversed only twice as follows: let the part represent the segment $$$[l, r]$$$ of vertices; if we move the chip $$$r$$$ to the vertex $$$l$$$, the chip $$$l$$$ to the vertex $$$l+1$$$, the chip $$$l+1$$$ to the vertex $$$l+2$$$, ..., the chip $$$r-1$$$ to the vertex $$$r$$$, then every edge in that part will be traversed exactly twice.So, we have shown that if we pick a subset of edges which we traverse that meets the constraint on each vertex having an incident traversed edge, then it is enough to traverse each chosen edge only twice. Now the problem becomes the following: choose a subset of edges in such a way that every vertex has at least one incident chosen edge, minimize the total weight of this subset, and print the integer which is double that total weight.Since the structure of the graph is specific, we can run dynamic programming of the form $$$dp_{i,f}$$$ \u2014 the minimum total weight of the subset, if we considered the first $$$i$$$ edges, and $$$f$$$ is $$$0$$$ if we haven't taken the last edge, or $$$1$$$ if we have. Obviously, this dynamic programming works in $$$O(n)$$$, which is too slow because we have to process queries. We will employ a classical technique of storing the dynamic programming in segment tree: build a segment tree on $$$n-1$$$ leaves; in every vertex of the segment tree, we store a $$$2 \\times 2$$$ matrix $$$d$$$; if the segment represented by the node of the segment tree is $$$[l..r]$$$, then the value of $$$d[f_1][f_2]$$$ is the minimum total weight of the subset of edges between $$$l$$$ and $$$r$$$ such that among every pair of adjacent edges, at least one is chosen; $$$f_1$$$ and $$$f_2$$$ represent the status of the first/last edge on the segment, respectively. And when some element changes, we need to recalculate only $$$O(\\log n)$$$ nodes of the segment tree, so this solution works in $$$O(n \\log n + q \\log n)$$$, albeit with a very big constant factor.Implementation note: don't use dynamic-size arrays (like  in C++) to store the values in the matrices, it might slow your solution very seriously. Instead, use static-size arrays.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF = (li)(1e18);\nconst int N = 200043;\n\nstruct data\n{\n\tarray<array<long long, 2>, 2> d;\n\tdata() {\n\t    for(int i = 0; i < 2; i++)\n\t\t\tfor(int j = 0; j < 2; j++)\n\t\t\t\td[i][j] = INF;\n\t};\n\tdata(li x)\n\t{\n\t\tfor(int i = 0; i < 2; i++)\n\t\t\tfor(int j = 0; j < 2; j++)\n\t\t\t\td[i][j] = INF;\n\t\td[0][0] = 0;\n\t\td[1][1] = x;\n\t};\n\tdata(data l, data r)\n\t{\n\t\tfor(int i = 0; i < 2; i++)\n\t\t\tfor(int j = 0; j < 2; j++)\n\t\t\t\td[i][j] = INF;\n\t\tfor(int i = 0; i < 2; i++)\n\t\t\tfor(int j = 0; j < 2; j++)\n\t\t\t\tfor(int k = 0; k < 2; k++)\n\t\t\t\t\tfor(int x = 0; x < 2; x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j == 0 && k == 0) continue;\n\t\t\t\t\t\td[i][x] = min(d[i][x], l.d[i][j] + r.d[k][x]);\n\t\t\t\t\t}\n\t};\n};\n\ndata T[4 * N];\nli a[N];\n\nvoid recalc(int v)\n{\n\tT[v] = data(T[v * 2 + 1], T[v * 2 + 2]);\n}\n\nvoid build(int v, int l, int r)\n{\n\tif(l == r - 1) T[v] = data(a[l]);\n\telse\n\t{\n\t\tint m = (l + r) / 2;\n\t\tbuild(v * 2 + 1, l, m);\n\t\tbuild(v * 2 + 2, m, r);\n\t\trecalc(v);\n\t}\n}\n\nvoid upd(int v, int l, int r, int pos, li val)\n{\n\tif(l == r - 1)\n\t{\n\t\ta[l] = val;\n\t\tT[v] = data(a[l]);\n\t}\n\telse\n\t{\n\t\tint m = (l + r) / 2;\n\t\tif(pos < m)\n\t\t\tupd(v * 2 + 1, l, m, pos, val);\n\t\telse\n\t\t\tupd(v * 2 + 2, m, r, pos, val);\n\t\trecalc(v);\n\t}\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\tbuild(0, 0, n - 1);\n\tint q;\n\tscanf(\"%d\", &q);\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint x;\n\t\tli k;\n\t\tscanf(\"%d %lld\", &x, &k);\n\t\tupd(0, 0, n - 1, x - 1, k);\n\t\tprintf(\"%lld\\n\", T[0].d[1][1] * 2);\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}