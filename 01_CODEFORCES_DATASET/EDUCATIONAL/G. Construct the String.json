{"link": "https://codeforces.com//contest/1366/problem/G", "problemId": "646805", "shortId": "1366G", "contest_number": "1366", "name": "G. Construct the String", "statement": "Let's denote the function  that takes a string  consisting of lowercase Latin letters and dots, and returns a string consisting of lowercase Latin letters as follows:  let  be an empty string;  process the characters of  from left to right. For each character , do the following: if  is a lowercase Latin letter, append  at the end of the string ; otherwise, delete the last character from  (if  is empty before deleting the last character \u2014 the function crashes);  return  as the result of the function. You are given two strings  and . You have to delete the minimum possible number of characters from  so that  (and the function does not crash). Note that you aren't allowed to insert new characters into  or reorder the existing ones.", "input": "The input consists of two lines: the first one contains  \u2014 a string consisting of lowercase Latin letters and dots, the second one contains  \u2014 a string consisting of lowercase Latin letters (). Additional constraint on the input: it is possible to remove some number of characters from  so that .", "output": "Print one integer \u2014 the minimum possible number of characters you have to delete from  so  does not crash and returns  as the result of the function.", "tutorial": "The core idea of the solution is the following dynamic programming:  is the minimum number of characters we have to delete if we considered a subsequence of  first characters of , and it maps to  first characters of .There are three obvious transitions in this dynamic programming:  we can go from  to  by skipping ;  if , we can go from  to ;  if  is a dot, we can go from  to . Unfortunately, these transitions cannot fully handle the case when we want to put some character and then delete it (these transitions don't allow us to do it for any character, only for some specific ones in specific situations). To handle it, suppose we want to take the character  and then delete it, and we model it as follows: there exists the fourth transition from  to  without deleting anything, where  is the length of the shortest substring of  starting from  that becomes empty if we apply the function  to it. This substring can be described as a regular bracket sequence, where opening brackets correspond to letters, and closing brackets \u2014 to dots. We can precalculate this substring for each  in .Why is this transition enough? Suppose we don't want to take some letter from this shortest substring in the optimal answer; since it is the shortest substring meeting these constraints, the number of letters on each prefix of it (excluding the substring itself) is greater than the number of dots, so we can instead skip the first letter and try applying this transition from , so this case is handled. And skipping any dots from this shortest substring is also suboptimal since we have to get rid of the character .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define sz(a) int((a).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i < int(r); ++i)\n\nconst int INF = 1e9;\nconst int N = 10010;\n\nint n, m;\nstring s, t;\nint dp[N][N];\nint nxt[N];\n\nint main() {\n\tcin >> s >> t;\n\tn = sz(s), m = sz(t);\n\t\n\tforn(i, n) if (s[i] != '.') {\n\t\tint bal = 0;\n\t\tnxt[i] = -1;\n\t\tfore(j, i, n) {\n\t\t\tif (s[j] == '.') --bal;\n\t\t\telse ++bal;\n\t\t\tif (bal == 0) {\n\t\t\t\tnxt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforn(i, n + 1) forn(j, m + 1)\n\t\tdp[i][j] = INF;\n\tdp[0][0] = 0;\n\t\n\tforn(i, n) forn(j, m + 1) {\n\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + 1);\n\t\tif (j < m && s[i] == t[j])\n\t\t\tdp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j]);\n\t\tif (s[i] != '.' && nxt[i] != -1)\n\t\t\tdp[nxt[i] + 1][j] = min(dp[nxt[i] + 1][j], dp[i][j]);\n\t}\n\t\n\tcout << dp[n][m] << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}