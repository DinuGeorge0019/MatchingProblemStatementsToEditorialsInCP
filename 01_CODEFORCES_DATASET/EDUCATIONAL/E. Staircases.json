{"link": "https://codeforces.com//contest/1598/problem/E", "problemId": "1138074", "shortId": "1598E", "contest_number": "1598", "name": "E. Staircases", "statement": "You are given a matrix, consisting of  rows and  columns. The rows are numbered top to bottom, the columns are numbered left to right.Each cell of the matrix can be either free or locked.Let's call a path in the matrix  if it:   starts and ends in the free cell;  visits only free cells;  has one of the two following structures:   the second cell is  to the right from the first one, the third cell is  to the bottom from the second one, the fourth cell is  to the right from the third one, and so on;  the second cell is  to the bottom from the first one, the third cell is  to the right from the second one, the fourth cell is  to the bottom from the third one, and so on.  In particular, a path, consisting of a single cell, is considered to be a staircase.Here are some examples of staircases:  Initially all the cells of the matrix are .You have to process  queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.Print the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.", "input": "The first line contains three integers ,  and  (; )\u00a0\u2014 the sizes of the matrix and the number of queries. Each of the next  lines contains two integers  and  (; )\u00a0\u2014 the description of each query.", "output": "Print  integers\u00a0\u2014 the -th value should be equal to the number of different staircases after  queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.", "tutorial": "The solution consist of two main parts: calculate the initial number of staircases and recalculate the number of staircases on query.The constraints were pretty loose, so we'll do the first part in  and the second part in  per query.However, it's worth mentioning that faster is possible. The first part can surely be done in  and can probably be done in . The second part can be done in  per query.It's important to notice is that the only staircase that satisfy the requirements for both types is the staircase that consists of a single cell. Thus, staircases of both types can be calculated almost separately.Let's define \"base\" staircases as the staircases that can't be prolonged further in any direction. There are  of them on the grid.If a staircase consists of at least two cells, it's a part of exactly one  staircase. At the same time, every segment of a  staircase is a valid staircase by itself.Thus, the main idea of calculating the initial answer is the following. Isolate each  staircase and determine its length  (possibly, in ). Add  (the number of segments of length at least ) to the answer. Add extra  one cell staircases afterwards.If you draw the  staircases on the grid, you can easily determine their starting cell. The  staircases, that start by going one cell to the right, start from the first row. The  staircases, that start by going one cell to the bottom, start from the first column. Notice that both types can start from cell .The updates can be handled the following way. The answer always changes by the number of staircases that pass through cell  (if you ignore its state). If the cell becomes free, then these staircases are added to the answer. Otherwise, they are subtracted from it.That can be calculated for two cases as well. Go first down, then right, as far as possible. Let it be  steps. Go first left, then up, as far as possible. Let it be  steps. Then  staircases are added to the answer. Then change the order of steps in both directions to calculate the other type of staircases. Beware of one cell staircases again.To achieve  for precalc, you can calculate the length of each  staircase with a formula. To achieve  per query, you can first enumerate cells in each  staircase separately, then maintain the set of segments of adjacent free cells in it.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main() {\n\tint n, m, q;\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tvector<vector<int>> a(n, vector<int>(m, 1));\n\tlong long ans = 0;\n\tforn(x, n) forn(y, m){\n\t\tif (x == 0){\n\t\t\tfor (int k = 1;; ++k){\n\t\t\t\tint nx = x + k / 2;\n\t\t\t\tint ny = y + (k + 1) / 2;\n\t\t\t\tif (nx == n || ny == m) break;\n\t\t\t\tans += k;\n\t\t\t}\n\t\t}\n\t\tif (y == 0){\n\t\t\tfor (int k = 1;; ++k){\n\t\t\t\tint nx = x + (k + 1) / 2;\n\t\t\t\tint ny = y + k / 2;\n\t\t\t\tif (nx == n || ny == m) break;\n\t\t\t\tans += k;\n\t\t\t}\n\t\t}\n\t}\n\tans += n * m;\n\tforn(i, q){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\t--x, --y;\n\t\tforn(c, 2){\n\t\t\tint l = 1, r = 1;\n\t\t\twhile (true){\n\t\t\t\tint nx = x + (l + c) / 2;\n\t\t\t\tint ny = y + (l + !c) / 2;\n\t\t\t\tif (nx == n || ny == m || a[nx][ny] == 0) break;\n\t\t\t\t++l;\n\t\t\t}\n\t\t\twhile (true){\n\t\t\t\tint nx = x - (r + !c) / 2;\n\t\t\t\tint ny = y - (r + c) / 2;\n\t\t\t\tif (nx < 0 || ny < 0 || a[nx][ny] == 0) break;\n\t\t\t\t++r;\n\t\t\t}\n\t\t\tif (a[x][y] == 0){\n\t\t\t\tans += l * r;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans -= l * r;\n\t\t\t}\n\t\t}\n\t\tans += a[x][y];\n\t\ta[x][y] ^= 1;\n\t\tans -= a[x][y];\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}