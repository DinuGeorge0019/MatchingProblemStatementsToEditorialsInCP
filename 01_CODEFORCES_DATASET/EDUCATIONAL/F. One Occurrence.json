{"link": "https://codeforces.com//contest/1000/problem/F", "problemId": "193659", "shortId": "1000F", "contest_number": "1000", "name": "F. One Occurrence", "statement": "You are given an array  consisting of  integers, and  queries to it. -th query is denoted by two integers  and . For each query, you have to find  integer that occurs  in the subarray of  from index  to index  (a subarray is a contiguous subsegment of an array). For example, if , then for query  the subarray we are interested in is , and possible answers are ,  and ; for query  the subarray we are interested in is , and there is no such element that occurs exactly once.Can you answer all of the queries?", "input": "The first line contains one integer  (). The second line contains  integers  (). The third line contains one integer  (). Then  lines follow, -th line containing two integers  and  representing -th query ().", "output": "Answer the queries as follows: If there is no integer such that it occurs in the subarray from index  to index  exactly once, print . Otherwise print any such integer.", "tutorial": "Suppose all queries have the same right border . Then the answer for the query can be some integer  such that the last occurence of  on the prefix  of the array is inside the segment, but the second to last occurence is outside the segment (or even does not exist). More formally, let  be the maximum index  such that  and  (or  if there is no such ); the answer to the query is some number  such that  and  (and  is the rightmost occurence of  in the segment ). For a fixed right border , we can build a segment tree which for every index  such that  is the rightmost occurence of  on  stores the value of ; and if we query minimum on the segment  in such tree, we can try to find the answer. Let the position of minimum be . If , then  can be the answer; otherwise there is no answer.But this is too slow since we can't afford to build a segment tree for every possible value of . There are two methods how to deal with this problem: you may sort all queries by their right borders and maintain the segment tree while shifting the right border (when going from  to , we have to update the values in the positions  and ), or we may use a persistent segment tree and get an online solution.We tried to eliminate solutions using Mo's algorithm, but in fact it's possible to squeeze some implementations of it into TL. There are two optimizations that might help there. When dividing the elements into blocks, we may sort the first block in the ascending order of right borders, the second \u2014 in descending, the third \u2014 in ascending order again, and so on. And also it's possible to obtain a Mo-based solution with worst case complexity of  if we maintain the set of possible answers using sqrt decomposition on it.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = int(1e9);\nconst int N = 500001;\n\ntypedef pair<int, int> pt;\n\n#define x first\n#define y second\n#define mp make_pair\n\nstruct node\n{\n \tpt val;\n\tnode* l;\n\tnode* r;\n\tnode() : val(mp(INF, 0)), l(NULL), r(NULL) {};\n\tnode(node* l, node* r) \n\t{\n\t \tthis->val = min(l->val, r->val);\n\t\tthis->l = l;\n\t\tthis->r = r;\n\t}\n\tnode(int pos, int val)\n\t{\n\t \tthis->val = mp(val, pos);\n\t\tthis->l = NULL;\n\t\tthis->r = NULL;\n\t}\n};\n\ntypedef node* stree;\n\npt query(stree t, int l, int r, int L, int R)\n{\n \tif(L >= R)\n\t\treturn mp(INF, 0);\n\tif(l == L && r == R)\n\t\treturn t->val;\n\tint mid = (l + r) >> 1;\n\tpt q1 = query(t->l, l, mid, L, min(mid, R));\n\tpt q2 = query(t->r, mid, r, max(mid, L), R);\n\treturn min(q1, q2);\n}\n\nstree update(stree t, int l, int r, int pos, int val)\n{\n \tif(l == r - 1)\n\t\treturn new node(pos, val);\n\telse\n\t{\n\t \tint mid = (l + r) >> 1;\n\t\tif(pos < mid)\n\t\t\treturn new node(update(t->l, l, mid, pos, val), t->r);\n\t\telse\n\t\t\treturn new node(t->l, update(t->r, mid, r, pos, val));\n\t}\n}\n\nstree build(int l, int r)\n{\n \tif(l == r - 1)\n\t\treturn new node(l, INF);\n\telse\n\t{\n\t \tint mid = (l + r) >> 1;\n\t\treturn new node(build(l, mid), build(mid, r));\n\t}\n}\n\nint main()\n{\n \tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> a(n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\n\tvector<int> left(n);\n\tmap<int, int> last;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t \tif(!last.count(a[i]))\n\t\t\tleft[i] = -1;\n\t\telse\n\t\t\tleft[i] = last[a[i]];\n\t\tlast[a[i]] = i;\n\t}\n\n\tvector<stree> T(n + 1);\n\tT[0] = build(0, n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tstree cur = T[i];\n\t\tif(left[i] != -1)\n\t\t\tcur = update(cur, 0, n, left[i], INF);\n\t\tcur = update(cur, 0, n, i, left[i]);\n\t\tT[i + 1] = cur;\t\n\t}                      \n\t\n\tint q;\n\tscanf(\"%d\", &q);\n\tfor(int i = 0; i < q; i++)\n\t{\n\t \tint l, r;\n\t\tscanf(\"%d %d\", &l, &r);\n\t\t--l;\n\t\tpt ans = query(T[r], 0, n, l, r);\n\t\tif(ans.x < l)\n\t\t\tprintf(\"%d\\n\", a[ans.y]);\n\t\telse\n\t\t\tprintf(\"0\\n\");\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}