{"link": "https://codeforces.com//contest/652/problem/F", "problemId": "52873", "shortId": "652F", "contest_number": "652", "name": "F. Ants on a Circle", "statement": " ants are on a circle of length . An ant travels one unit of distance per one unit of time. Initially, the ant number  is located at the position  and is facing in the direction  (which is either  or ). Positions are numbered in counterclockwise order starting from some point. Positions of the all ants are distinct.All the ants move simultaneously, and whenever two ants touch, they will both switch their directions. Note that it is possible for an ant to move in some direction for a half of a unit of time and in opposite direction for another half of a unit of time.Print the positions of the ants after  time units.", "input": "The first line contains three integers ,  and  () \u2014 the number of ants, the length of the circle and the number of time units. Each of the next  lines contains integer  and symbol  ( and  is either  or ) \u2014 the position and the direction of the -th ant at the start. The directions  and  corresponds to the clockwise and counterclockwise directions, respectively. It is guaranteed that all positions  are distinct.", "output": "Print  integers  \u2014 the position of the -th ant after  units of time. The ants are numbered from  to  in order of their appearing in input.", "tutorial": "The first observation: if all the ants are indistinguishable we can consider that there are no collisions and all the ants are passing one through another. So we can easily determine the final positions of all the ants, but we can't say which ant will be in which position.\nThe second observation: the relative order of the ants will be the same all the time.\nSo to solve the problem we should only find the position of one ant after  seconds.\nLet's solve that problem in the following way:\n   Consider the positions of all the ants after  time units. Easy to see that by the first observation all the positions of the ants will left the same, but the order will be different (we will have some cyclic shift of the ants). If we find that cyclic shift  we can apply it  times.   After that we will have only  time units. \nSo the problem now is to model the process for the one ant with  and  time units. Note that in that time interval the fixed ant will have no more than two collisions with each other ant. So if we model the process with ignoring all collisions except the ones that include the fixed ant, we will have no more than  collisions.\nLet's model that process with two queues for the ants going to the left and to the right. Each time we should take the first ant in the queue with opposite direction, process the collision and add that ant to the end of the other queue.\nHint: you will have a problem when the fixed ant can be in two different positions at the end, but it's easy to fix with doing the same with the next ant.\n", "solution": "fore(d, 1, n) {\n    int i = (v - d + n) % n;\n    if (a[i].x.y == 'R') tor.push(mp(i > v ? a[i].x.x - m : a[i].x.x, 0));\n}\nfore(d, 1, n) {\n    int i = (v + d) % n;\n    if (a[i].x.y == 'L') tol.push(mp(i < v ? a[i].x.x + m : a[i].x.x, 0));\n}\n\nli cx = a[v].x.x;\nchar cd = a[v].x.y;\nli curt = 0;\nwhile (t > 0) {\n    if (cd == 'R') {\n       if (tol.empty()) return getPos(cx, cd, t);\n       assert(curt >= tol.front().y);\n       li nx = tol.front().x - (curt - tol.front().y);\n       tol.pop();\n       li d = min((nx - cx + 1) >> 1, t);\n       assert(cx <= nx);\n       cx += d, nx -= d;\n       t -= d;\n       if (cx > nx) {\n         assert((nx - cx) & 1);\n         cx--, nx++;\n       }\n       assert(cx <= nx);\n       cd = 'L';\n       curt += d;\n       assert(nx - m < cx);\n       tor.push(mp(nx - m, curt));\n    } else {\n       if (tor.empty()) return getPos(cx, cd, t);\n       assert(curt >= tor.front().y);\n       li nx = tor.front().x + (curt - tor.front().y);\n       tor.pop();\n       li d = min((cx - nx + 1) >> 1, t);\n       assert(cx >= nx);\n       cx -= d, nx += d;\n       t -= d;\n       if (cx < nx) {\n         assert((cx - nx) & 1);\n         cx++, nx--;\n       }\n       assert(cx >= nx);\n       cd = 'R';\n       curt += d;\n       assert(nx + m > cx);\n       tol.push(mp(nx + m, curt));\n    }\n}\nreturn getPos(cx, cd, 0);", "interactive": false, "noSolution": false, "noTutorial": false}