{"link": "https://codeforces.com//contest/837/problem/F", "problemId": "116712", "shortId": "837F", "contest_number": "837", "name": "F. Prefix Sums", "statement": "Consider the function , where  is an array of  integers, which returns an array  consisting of  integers such that  is equal to the sum of first  elements of array  ().You have an infinite sequence of arrays , where  is given in the input, and for each  . Also you have a positive integer . You have to find minimum possible  such that  contains a number which is larger or equal than .", "input": "The first line contains two integers  and  (, ).  is the size of array . The second line contains  integers  \u2014 the elements of  (). At least two elements of  are positive.", "output": "Print the minimum  such that  contains a number which is larger or equal than .", "tutorial": "Let's delete all zeroes from the beginning of the array; they won't affect the answer. Also we will return an array of  elements when calculating prefix sums (sum of zero elements becomes a zero in the beginning of the array, and so has to be removed).If the size of array is at least , then we will get  after calculating only a few prefix sums, so we can use simple iteration. So now we have to obtain the solution in case array has less than  elements.If we remove zeroes from the beginning of each array, then , where  is a matrix ,  if , otherwise . Then we can use matrix exponentiation to check whether  contains a number which is equal to or greater than , and we can use binary search to find the answer. To avoid overflows, each time we get a number greater than , we can set it to .", "solution": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:1048576\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\ntypedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 3234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nll mymul(ll a, ll b) {\n\tif (a == 0 || b == 0) return 0;\n\tif (LL_INF / b < a) return LL_INF;\n\treturn min(LL_INF, a*b);\n}\n\nll C1[1050][1050];\nll C2[2200050][11];\nll C(ll a, ll b) {\n\tif (a <= 1000) return C1[a][b];\n\t\n\tif (b >= a / 2) b = a - b;\n\n\tif (b == 0) return 1;\n\tif (b == 1) return a;\n\tif (b == 2) return mymul(a, a - 1) / 2;\n\tif (a >= 2200000) return LL_INF;\n\tif (b <= 10) return C2[a][b];\n\telse return LL_INF;\n}\n\nll in[200050];\nint main() {\n\tint i, j;\n\tfor (i = 0; i <= 1000; i++) {\n\t\tC1[i][0] = C1[i][i] = 1;\n\t\tfor (j = 1; j < i; j++) C1[i][j] = min(C1[i - 1][j] + C1[i - 1][j - 1], LL_INF);\n\t}\n\tfor (i = 0; i <= 2200000; i++) {\n\t\tC2[i][0] = 1;\n\t\tif (i <= 10) C2[i][i] = 1;\n\t\tfor (j = 1; j < i && j <= 10; j++) C2[i][j] = min(C2[i - 1][j] + C2[i - 1][j - 1], LL_INF);\n\t}\n\n\tint N;\n\tll K;\n\tscanf(\"%d %lld\", &N, &K);\n\tint st = N;\n\tfor (i = 1; i <= N; i++) {\n\t\tscanf(\"%lld\", &in[i]);\n\t\tif (in[i] >= K) return !printf(\"0\\n\");\n\t\tif (in[i]) st = min(st, i);\n\t}\n\t\n\tll s = 1, e = LL_INF, m, r = LL_INF + 1;\n\tif (st < N - 2) e = 2000000;\n\n\twhile (s <= e) {\n\t\tm = (s + e) / 2;\n\n\t\tll v = 0;\n\t\tfor (i = 1; i <= N; i++) v = min(LL_INF, v + mymul(C(N - i + m - 1, m - 1), in[i]));\n\t\tif (v >= K) {\n\t\t\tr = m;\n\t\t\te = m - 1;\n\t\t}\n\t\telse s = m + 1;\n\t}\n\treturn !printf(\"%lld\\n\", r);\n}", "interactive": false, "noSolution": false, "noTutorial": false}