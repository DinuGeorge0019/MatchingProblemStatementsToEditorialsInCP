{"link": "https://codeforces.com//contest/1795/problem/E", "problemId": "1785701", "shortId": "1795E", "contest_number": "1795", "name": "E. Explosions ", "statement": "You are playing yet another game where you kill monsters using magic spells. There are  cells in the row, numbered from  to . Initially, the -th cell contains the -th monster with  health.You have a basic spell that costs  MP and deals  damage to the monster you choose. You can cast it any number of times. Also, you have a special scroll with \"Explosion\" spell you can use only once. You want to finish killing monsters with explosion, that's why you, firstly, cast the basic spell several times (possibly, zero), and then after that, you cast one \"Explosion\".How does \"Explosion\" spell work? Firstly, you choose the power of the spell: if you pour  MP into it, \"Explosion\" will deal  damage. Secondly, you choose some monster , which will be targeted by the spell. That's what happens next:   if its  health , then he stays alive with health decreased by ;  if , the -th monster dies with an explosion that deals  damage to monsters in the neighboring cells  and , if these cells exist and monsters inside are still alive;  if the damage dealt by the explosion is enough to kill the monster  (or ), i.\u00a0e. the current  (or ), then that monster also dies creating a secondary explosion of power  (or ) that may deals damage to their neighbors, and so on, until the explosions end. Your goal is to kill all the remaining monsters with those \"chaining\" explosions, that's why you need a basic spell to decrease  of some monsters or even kill them beforehand (monsters die when their current health  becomes less or equal to zero). Note that monsters don't move between cells, so, for example, monsters  and  will never become neighbors.What is the minimum total MP you need to kill all monsters in the way you want? The total MP is counted as the sum of the number of basic spells you cast and the power  of explosion scroll you've chosen.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains the single integer  ()\u00a0\u2014 the number of cells in the row, i.\u00a0e. the number of monsters. The second line of each test case contains  integers  ()\u00a0\u2014 the initial health of the monsters. It's guaranteed that the sum of  over all test cases doesn't exceed .", "output": "For each test case, print one integer\u00a0\u2014 the minimum total MP you need to kill all monsters by finishing them with explosion.", "tutorial": "Note that each unit of damage dealt by explosions save us from using one more basic spell. In other words, the more the damage from explosions, the better. So, the answer will be equal to .Note that in order to kill all remaining monsters with the last spell, the array  should have the following structure: there is a monster  we cast the spell onto it and  is strictly increasing in  and strictly decreasing in  (ignoring prefix and suffix of -s).Let's focus on the left part of array  (segment ), since solving the right part is exactly the same. Maximizing the total damage is equivalent to maximizing the sum of  right before the final spell. Note that we can use the straight greedy strategy: to kill the chosen monster  we should use \"Explosion\" spell of power exactly \u00a0\u2014 it's not optimal to make it either more or less powerful.After that, monster  will create an explosion of power . If  we must decrease it to exactly  to continue the chain of explosions of maximum total damage. If  we also decrease it to exactly  and so on. (The general formula is ).This series will stop either if  (or ), or there are no monsters left (), or we met the monster with . The two first cases are easy to check in constant time, so let's look at the last case. Suppose that monster position is equal to , then  or   .That monster  is interesting to us because after death it creates an explosion of damage  that already doesn't depend on  and next calculation is practically the same task: what chain of explosion we can have if we start from . That idea drives us to dp: let  be the maximum damage of chaining explosion we can deal if we start from  and move to the left. For simplicity, let's include  into that total damage.Calculating  is next: let's find the \"first\"  such that . If there are no such  (or if that  is too far from , i.\u00a0e. ), we will set .Now we know that on interval  the damage dealt is the arithmetic progression: for  it's , for  it's , ..., for  it's . In total, . And if such  exists and not too far away, we increase  by  as well.The last question is finding for each  the closest  such that . Note that if we define , we need just need to find last  and that's quite standard task that can be solved with stack.Let's iterate over  and maintain a stack of previous . When we need to find  for the current  let's just look at the top of the stack: if  we found  we wanted, otherwise just pop it and check the new top again and so on, until either we find  or stack becomes empty that would mean that there are no . After processing the -th element, push  on top of the stack.Why it works? Consider some . The element on top of the stack is  (firstly, it's  but we are talking about general case). If  we found what we want. Otherwise,  but it also means that previous elements , that was popped on previous iteration , was greater than . So,  is bigger than  as well, and there were no need to even consider them, i.\u00a0e. popping them out earlier doesn't break anything.Since each element is pushed in the stack once and popped out once, then the complexity is  for all  for  to , or  amortized.The answer for the chosen position  then is  where  is dp we discussed above,  is the same dp but on reversed array  and  because we included  into both  and .Both  and  are calculated in , so the total comlpexity is .", "solution": "import java.util.*\n\nfun main() {\n    repeat(readln().toInt()) {\n        val n = readln().toInt()\n        var h = readln().split(' ').map { it.toInt() }\n\n        val d = Array(2) { LongArray(n) { 0 } }\n        for (tp in 0..1) {\n            val s = Stack<Pair<Int, Int>>()\n\n            for (i in h.indices) {\n                while (s.isNotEmpty() && s.peek().first > h[i] - i)\n                    s.pop()\n                var j = maxOf(-1, i - h[i])\n                if (s.isNotEmpty())\n                    j = maxOf(j, s.peek().second)\n\n                val len = (i - j).toLong()\n                d[tp][i] = len * h[i] - len * (len - 1) / 2\n                if (j >= 0 && len < h[i])\n                    d[tp][i] += d[tp][j]\n\n                s.push(Pair(h[i] - i, i))\n            }\n            h = h.reversed()\n        }\n        d[1] = d[1].reversedArray()\n\n        var ans = 1e18.toLong()\n        val sum = h.fold(0L) { total, it -> total + it }\n        for (i in h.indices) {\n            val cur = sum - d[0][i] - d[1][i] + 2 * h[i]\n            ans = minOf(ans, cur)\n        }\n        println(ans)\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}