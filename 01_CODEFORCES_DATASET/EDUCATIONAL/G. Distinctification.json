{"link": "https://codeforces.com//contest/1051/problem/G", "problemId": "222363", "shortId": "1051G", "contest_number": "1051", "name": "G. Distinctification", "statement": "Suppose you are given a sequence  of  pairs of integers .You can perform the following operations on it:  Choose some position  and   by . That can be performed only if there exists at least one such position  that  and . The cost of this operation is ;  Choose some position  and   by . That can be performed only if there exists at least one such position  that . The cost of this operation is . Each operation can be performed arbitrary number of times (possibly zero).Let  be minimum possible  such that there exists a sequence of operations with total cost , after which all  from  are pairwise distinct. You are given a sequence  consisting of  pairs of integers . All  are pairwise distinct. Let  be the sequence consisting of the first  pairs of . Your task is to calculate the values of .", "input": "The first line contains a single integer  () \u2014 the number of pairs in sequence . Next  lines contain the elements of : -th of the next  lines contains two integers  and  (, ). It is guaranteed that all values of  are pairwise distinct.", "output": "Print  integers \u2014 the -th number should be equal to .", "tutorial": "Let's firstly try to come up with some naive solution.Suppose we have a list  and want to calculate  for it. Let's sort this list, comparing the pairs by their values of , and then process them one-by-one. We will divide this list into some parts (we will call them ) with the following process: when processing the first pair in the sorted order, let's iterate on the next pairs (also in the sorted order) and add them to the first pair's component until the following condition is met: , where  is the index of the first pair we added, and  is the index of the pair we are currently trying to add to 's component (remember that we consider all these pairs in the sorted order).What is the meaning of this condition?  means that the number of pairs between  and  (including these two) is not less that the number of integers in  \u2014 and while this condition is met, we can use the first operation in order to make a pair having  for every . And the first time when the condition  is met, we obviously cannot \"expand\" the segment in such a way. It means that the -value of  will always be greater than -value of , and  won't belong to the same component with  (and will start creating its own component instead).These components we form have one special property. Suppose we \"expanded\" the component so that there are no two equal values of  in it. Then we may reorder the pairs in this component as we wish (to do so, we may \"contract\" the component using the second operation, and then \"expand\" it again). Of course, the best course of action is to sort the pairs in the component by their values of  in descending order. After doing this for every component, we will obtain an optimal configuration such that all values of  are distinct, and it's easy to calculate the answer.Okay, now we need to do it fast. The following will help us:  DSU;  Some implicit logarithmic data structure (the operations we need are \"count the sum of elements less than \" and \"count the number of elements greater than \"; your implementation might use other operations);  Small-to-large merging. DSU will help us maintain the components. A data structre will be built for each component containing the values of  in it; it will help us to maintain the sum of , where  is the optimal index of  in this component. Depending on your implementation, you may or may not need to store the minimum value of  in the component. When inserting some element having  into some component, the elements having  don't change their position, the new element will be added right after them, and the remaining elements will be shifted to the right; so the sum of  can be maintained if we query the number of elements greater than  and the sum of elements less than .Okay, but we still don't know how we create the components and how we determine if two components are to merge. We will keep these components in \"expanded\" form; that is, when processing a pair , let's find the leftmost unoccupied position after  (or , if it is not occupied) and occupy it with the new pair, creating a new component for it. If the newly occupied index is , let's try to merge new component with components occupying  and  (if there are any); to merge two components, do the required operations in DSU and unite the data structures built in these components with small-to-large method.All this works in , the most time-consuming part is merging the data structures.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef long long li;\n\nmt19937 rnd(time(NULL));\n\nstruct node\n{\n\tint x;\n\tint y;\n\tli sum;\n\tint siz;\n\tnode* l;\n\tnode* r;\n\tnode() {};\n\tnode(int x, int y, li sum, int siz, node* l, node* r) : x(x), y(y), sum(sum), siz(siz), l(l), r(r) {};\n};\n\ntypedef node* treap;\ntypedef pair<treap, treap> ptt;\n\nint getSiz(treap t)\n{\n\treturn (t ? t->siz : 0);\n}\n\nli getSum(treap t)\n{\n\treturn (t ? t->sum : 0);\n}\n\ntreap fix(treap t)\n{\n\tif(!t) return t;\n\tt->sum = getSum(t->l) + t->x + getSum(t->r);\n\tt->siz = getSiz(t->l) + 1 + getSiz(t->r);\n\treturn t;\n}\n\nptt split(treap t, int l)\n{\n\tt = fix(t);\n\tif(!t) return make_pair(t, t);\n\tif(t->x < l)\n\t{\n\t\tauto z = split(t->r, l);\n\t\tt->r = z.x;\n\t\treturn make_pair(fix(t), z.y);\n\t}\n\telse\n\t{\n\t\tauto z = split(t->l, l);\n\t\tt->l = z.y;\n\t\treturn make_pair(z.x, fix(t));\n\t}\n}\n\ntreap merge(treap a, treap b)\n{\n\ta = fix(a);\n\tb = fix(b);\n\tif(!a) return b;\n\tif(!b) return a;\n\tif(a->y > b->y)\n\t{\n\t\ta->r = merge(a->r, b);\n\t\treturn fix(a);\n\t}\n\telse\n\t{\n\t\tb->l = merge(a, b->l);\n\t\treturn fix(b);\n\t}\n}\n\nstruct comp\n{\n\tli cur_sum;\n\tint beg;\n\tli treap_sum;\n\ttreap t;\n\t\n\tvoid upd()\n\t{\n\t\tcur_sum = treap_sum + beg * 1ll * getSum(t);\n\t}\n\t\n\tvoid insert(int bi)\n\t{\n\t\tptt p = split(t, bi);\n\t\ttreap_sum += getSum(p.x) + getSiz(p.y) * 1ll * bi;\n\t\tt = merge(p.x, merge(new node(bi, rnd(), bi, 1, NULL, NULL), p.y));\n\t\tupd();\n\t}\n\t\n\tvoid fill_treap(treap t)\n\t{\n\t\tif(!t) return;\n\t\tinsert(t->x);\n\t\tfill_treap(t->l);\n\t\tfill_treap(t->r);\n\t}\n};\n\ncomp merge(comp a, comp b)\n{\n\tif(getSiz(a.t) < getSiz(b.t))\n\t\tswap(a, b);\n\ta.beg = min(a.beg, b.beg);\n\ta.fill_treap(b.t);\n\tdelete b.t;\n\ta.upd();\n\treturn a;\n}\n\nset<int> free_pos;\n\nconst int N = 400043;\n\nint p[N];\nint siz[N];\ncomp cc[N];\n\nli start_sum = 0;\nli end_sum = 0;\n\nint get(int x)\n{\n\treturn (p[x] == x ? x : (p[x] = get(p[x])));\n}\n\nvoid merge(int x, int y)\n{\n\tx = get(x);\n\ty = get(y);\n\tif(x == y) return;\n\tif(siz[x] < siz[y]) swap(x, y);\n\tend_sum -= cc[x].cur_sum;\n\tend_sum -= cc[y].cur_sum;\n\tp[y] = x;\n\tsiz[x] += siz[y];\n\tcc[x] = merge(cc[x], cc[y]);\n\tend_sum += cc[x].cur_sum;\n}\n\nvoid process(int ai, int bi)\n{\n\tstart_sum += ai * 1ll * bi;\n\tint pos = *free_pos.lower_bound(ai);\n\tfree_pos.erase(pos);\n\tsiz[pos] = 1;\n\tp[pos] = pos;\n\tcc[pos].beg = pos;\n\tcc[pos].insert(bi);\n\tend_sum += cc[pos].cur_sum;\n\tif(!free_pos.count(pos - 1))\n\t\tmerge(pos, pos - 1);\n\tif(!free_pos.count(pos + 1))\n\t\tmerge(pos, pos + 1);\n\tprintf(\"%lld\\n\", end_sum - start_sum);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n    int n;\n    scanf(\"%d\", &n);\n  \tfor(int i = 0; i < N; i++)\n  \t\tfree_pos.insert(i);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tprocess(a, b);\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}