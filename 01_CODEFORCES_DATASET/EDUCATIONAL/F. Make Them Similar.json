{"link": "https://codeforces.com//contest/1257/problem/F", "problemId": "470641", "shortId": "1257F", "contest_number": "1257", "name": "F. Make Them Similar", "statement": "Let's call two numbers  if their binary representations contain the same number of digits equal to . For example:   and  are similar (binary representations are  and );   and  are similar (binary representations are  and );   and  are not similar (binary representations are  and );   and  are similar (binary representations are  and ). You are given an array of  integers , , ..., . You may choose a non-negative integer , and then get another array of  integers , , ..., , where  ( denotes bitwise XOR).Is it possible to obtain an array  where all numbers are similar to each other?", "input": "The first line contains one integer  (). The second line contains  integers , , ...,  ().", "output": "If it is impossible to choose  so that all elements in the resulting array are similar to each other, print one integer . Otherwise, print  non-negative integer not exceeding  that can be used as  so that all elements in the resulting array are similar.", "tutorial": "Iterating over all possible values of  and checking them may be too slow (though heavily optimized brute force is difficult to eliminate in this problem), so we need to speed this approach up.The resulting number consists of  bits. Let's use the classical meet-in-the-middle trick: try all  combinations of  lowest bits, try all  combinations of  highest bits, and somehow \"merge\" the results.When we fix a combination of  lowest bits, we fix  lowest bits in every . Suppose that there are  ones among  lowest bits of .Analogically, when we fix a combination of  highest bits, we fix  highest bits in every . Suppose that there are  ones among  highest bits of .We want to find a combination of lowest and highest bits such that  is the same for each . Let's represent each combination of  lowest bits with an -dimensional vector with coordinates . Let's also represent each combination of  highest bits with an -dimensional vector with coordinates . We want to find a combination of lowest bits and a combination of highest bits such that their vectors are opposite. We can do so, for example, by precalculating all vectors for all combinations of  lowest bits, storing them in a map or a trie, iterating on a combination of  highest bits and searching for the opposite vector in the map/trie.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\nconst int N = 143;\nconst int K = 15;\nconst int V = 5000000;\n\nint n;\nli a[N];\nint lst[V];\nmap<int, int> nxt[V];\nint t = 1;\nli a1[N];\nli a2[N];\n\nint get_nxt(int v, int x)\n{\n\tif(!nxt[v].count(x))\n\t\tnxt[v][x] = t++;\n\treturn nxt[v][x];\n}\n\nvoid add(vector<int> diff, int x)\n{\n\tint v = 0;\n\tfor(auto i : diff)\n\t\tv = get_nxt(v, i);\n\tlst[v] = x;\n}\n\nint try_find(vector<int> diff)\n{\n\tint v = 0;\n\tfor(auto i : diff)\n\t{\n\t\tif(!nxt[v].count(i))\n\t\t\treturn -1;\n\t\tv = nxt[v][i];\n\t}\n\treturn lst[v];\n}\n\nvector<int> get_diff(li arr[N], int x)\n{\n\tvector<int> cnt(n);\n\tfor(int i = 0; i < n; i++)\n\t\tcnt[i] = __builtin_popcountll(arr[i] ^ x);\n\tvector<int> diff(n - 1);\n\tfor(int i = 0; i + 1 < n; i++)\n\t\tdiff[i] = cnt[i + 1] - cnt[0];\n\treturn diff;\n}\n\nint main()\n{\n\tcin >> n;\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\t\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\ta1[i] = (a[i] >> K);\n\t\ta2[i] = a[i] ^ (a1[i] << K);\n\t}\n\tfor(int i = 0; i < (1 << K); i++)\n\t{\n\t\tvector<int> d = get_diff(a1, i);\n\t\tadd(d, i);\n\t}\n\tfor(int i = 0; i < (1 << K); i++)\n\t{\n\t\tvector<int> d = get_diff(a2, i);\n\t\tfor(int j = 0; j + 1 < n; j++)\n\t\t\td[j] *= -1;\n\t\tint x = try_find(d);\n\t\tif(x != -1)\n\t\t{\n\t\t\tli res = (li(x) << K) ^ i;\n\t\t\tcout << res << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}