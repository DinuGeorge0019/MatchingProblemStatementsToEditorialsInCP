{"link": "https://codeforces.com//contest/1221/problem/E", "problemId": "415611", "shortId": "1221E", "contest_number": "1221", "name": "E. Game With String", "statement": "Alice and Bob play a game. Initially they have a string , consisting of only characters  and . They take alternating turns, and Alice is moving first. During each turn, the player has to select a contiguous substring consisting only of characters  and replaces each of them with . Alice must select a substing of length , and Bob must select a substring of length . It is guaranteed that .For example, if   and , , then after Alice's move string can turn only into . And if it's Bob's turn and the string  , then after Bob's move the string can turn into ,  or .Whoever is unable to make a move, loses. You have to determine who wins if they both play optimally.You have to answer  independent queries.", "input": "The first line contains one integer  () \u2014 the number of queries. The first line of each query contains two integers  and  (). The second line of each query contains the string  (), consisting of only characters  and . It is guaranteed that sum of all  over all queries not exceed .", "output": "For each test case print  if Alice can win and  otherwise. You may print every letter in any case you want (so, for example, the strings , ,  and  will all be recognized as positive answer).", "tutorial": "At first, let's transform input to a more convenient form. We consider only such subsegments that consist of the symbols  and which cannot be expanded to the right or left. For example, for  we consider segments of length , , , and .Let's divide all such segments into four groups by their length :   ;  ;  ;  . In such a division, each segment belongs to exactly one type.Suppose that the Bob takes the first turn. If there is a segment of second type, then Bob wins, because he always have a spare turn that Alice cannot make. If there is a segment of fourth type then the Bob also wins because he can make the segment of second type by taking turn in this segment of four type. If there are no segments of second and four types, then victory depends on the parity of the number of segments of the third type.But it is true if the Bob takes first turn. If Alice takes first turn then she doesn't want, after her move, there are segments of the second and fourth types. So if initially there is a segment of second type then Alice loses because she can't take turns into segment of second type. If there are two or more segments of four type then Alice also loses, because after her turn at least one such segments remains. If there are only one segment of four type then Alice have to take turn into this segment. Since the length of this segment doesn't exceed , we can iterate over all possible Alice moves. After Alice's move segment of fourth type can be divided into no more than two new segments, let's denote their types as  and . If at least one of these segments of second or fourth type, then it's bad turn for Alice. Otherwise Alice win if remaining number of segment of third type is even (note that  or  also can be the third type). And finally, if initially there are only segments of first or third type, then victory depends on the parity of the number of segments of the third type.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 99;\n\nint t;\nint a, b;\nstring s;\n\nint main() {\n\tcin >> t;\n\tfor(int tc = 0; tc < t; ++tc){\n\t\tcin >> a >> b >> s;\n\t\tvector <int> v;\n\t\tint l = 0;\n\t\twhile(l < s.size()){\n\t\t\tif(s[l] == 'X'){\n\t\t\t\t++l;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint r = l + 1;\n\t\t\twhile(r < s.size() && s[r] == '.') ++r;\n\t\t\tv.push_back(r - l);\n\t\t\tl = r;\n\t\t}\n\t\t\n\t\tbool ok = true;\n\t\tint id = -1;\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < v.size(); ++i){\n\t\t\tif(b <= v[i] && v[i] < a) ok = false;\n\t\t\tif(b + b <= v[i]){\n\t\t\t\tif(id == -1) id = i;\n\t\t\t\telse ok = false;\n\t\t\t}\n\t\t\tif(a <= v[i] && v[i] < b + b) ++cnt; \n\t\t}\n\n\t\tif(!ok){\n\t\t\tcout << \"NO\" << endl;\t\t\t\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(id == -1){\n\t\t\tif(cnt & 1) cout << \"YES\" << endl;\n\t\t\telse cout << \"NO\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tok = false;\n\t\tint sz = v[id];\n\t\tassert(sz >= a);\n\t\tfor(int rem1 = 0; sz - a - rem1 >= 0; ++rem1){\n\t\t\tint rem2 = sz - a - rem1;\n\t\t\tint ncnt = cnt;\n\t\t\tif((rem1 >= b + b) || (b <= rem1 && rem1 < a)) continue;\n\t\t\tif((rem2 >= b + b) || (b <= rem2 && rem2 < a)) continue;\n\n\t\t\tif(rem1 >= a) ++ncnt;\n\t\t\tif(rem2 >= a) ++ncnt;\n\t\t\tif(ncnt % 2 == 0) ok = true;\n\t\t}\n\t\t\n\t\tif(ok) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}                             \t\n\n\n\n\n\n", "interactive": false, "noSolution": false, "noTutorial": false}