{"link": "https://codeforces.com//contest/954/problem/F", "problemId": "167343", "shortId": "954F", "contest_number": "954", "name": "F. Runner's Problem", "statement": "You are running through a rectangular field. This field can be represented as a matrix with  rows and  columns.  denotes a cell belonging to -th row and -th column.You start in  and have to end your path in . From the cell  you may advance to:   \u2014 only if ,  , or   \u2014 only if . However, there are  obstacles blocking your path. -th obstacle is denoted by three integers ,  and , and it forbids entering any cell  such that .You have to calculate the number of different paths from  to , and print it modulo .", "input": "The first line contains two integers  and  (, ) \u2014 the number of obstacles and the number of columns in the matrix, respectively. Then  lines follow, each containing three integers ,  and  (, ) denoting an obstacle blocking every cell  such that . Some cells may be blocked by multiple obstacles.", "output": "Print the number of different paths from  to , taken modulo . If it is impossible to get from  to , then the number of paths is .", "tutorial": "There is a simple dynamic programming solution that works in . Let's try to improve it.Firstly, if there are no obstacles in some column  and we have calculated the number of paths to every cell of the previous column, then we may get the values in column  by multiplying the vector of values in column  by the following matrix:Then we may use binary exponentiation to skip long segments without obstacles in , where  is the length of the segment.Let's try to modify this matrix if we have to forbid some rows. All we need to change is to set every value in -th row to  if -th row is forbidden. So we may skip long segments not only if they don't contain any obstacles, but also if the set of forbidden rows doesn't change on this segment.So the solution is the following: divide the whole matrix into  segments by the endpoints of the obstacles, then in every segment the set of forbidden rows doesn't change (so we can skip it using fast matrix exponentiation).", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\ninline ll read()\n{\n    ll x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n#define MN 10000\n#define MOD 1000000007\nstruct P{ll x;int y,z;}p[MN*2+5];\nbool cmp(const P&a,const P&b){return a.x<b.x;}\nstruct mat{int z[3][3];}x,a[8];\ninline mat operator*(const mat&a,const mat&b)\n{\n\tmat c;memset(c.z,0,sizeof(c.z));\n\tfor(int i=0;i<3;++i)for(int j=0;j<3;++j)for(int k=0;k<3;++k)\n\t\tc.z[i][k]=(c.z[i][k]+1LL*a.z[i][j]*b.z[j][k])%MOD;\n\treturn c;\n};\nint u[4];\nint cal(){return (u[1]?4:0)+(u[2]?2:0)+(u[3]?1:0);}\ninline mat pw(mat x,ll y)\n{\n\tmat r;\n\tfor(int i=0;i<3;++i)for(int j=0;j<3;++j)r.z[i][j]=i==j;\n\tfor(;y;y>>=1,x=x*x)if(y&1)r=r*x;\n\treturn r;\n}\nint main()\n{\n\tint n=read(),i,j;ll m=read();\n\tfor(i=1;i<=n;++i)j=read(),p[i]=(P){read(),j,1},p[i+n]=(P){read()+1,j,-1};\n\tsort(p+1,p+n+n+1,cmp);\n\tfor(i=0;i<8;++i)\n\t{\n\t\tif(!(i&4))a[i].z[0][0]=a[i].z[1][0]=1;\n\t\tif(!(i&2))a[i].z[0][1]=a[i].z[1][1]=a[i].z[2][1]=1;\n\t\tif(!(i&1))a[i].z[1][2]=a[i].z[2][2]=1;\n\t}\n\tx.z[0][1]=1;p[0].x=2;\n\tfor(i=1;i<=n+n;++i)x=x*pw(a[cal()],p[i].x-p[i-1].x),u[p[i].y]+=p[i].z;\n\tx=x*pw(a[0],m-p[n+n].x+1);\n\tprintf(\"%d\",x.z[0][1]);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}