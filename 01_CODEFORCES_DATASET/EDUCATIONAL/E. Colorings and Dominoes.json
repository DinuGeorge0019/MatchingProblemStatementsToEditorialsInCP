{"link": "https://codeforces.com//contest/1511/problem/E", "problemId": "955216", "shortId": "1511E", "contest_number": "1511", "name": "E. Colorings and Dominoes", "statement": "You have a large rectangular board which is divided into  cells (the board has  rows and  columns). Each cell is either white or black.You paint each white cell either red or blue. Obviously, the number of different ways to paint them is , where  is the number of white cells.After painting the white cells of the board, you want to place the maximum number of dominoes on it, according to the following rules:  each domino covers two adjacent cells;  each cell is covered by at most one domino;  if a domino is placed horizontally (it covers two adjacent cells in one of the rows), it should cover only red cells;  if a domino is placed vertically (it covers two adjacent cells in one of the columns), it should cover only blue cells. Let the  of the board be the maximum number of dominoes you can place. Calculate the sum of  of the board over all  possible ways to paint it. Since it can be huge, print it modulo .", "input": "The first line contains two integers  and  (; ) \u2014 the number of rows and columns, respectively. Then  lines follow, each line contains a string of  characters. The -th character in the -th string is  if the -th cell in the -th row is black; otherwise, that character is .", "output": "Print one integer \u2014 the sum of  of the board over all  possible ways to paint it, taken modulo .", "tutorial": "There are different solutions to this problem involving combinatorics and/or dynamic programming, but, in my opinion, it's a bit easier to look at the problem from the perspective of probability theory.Let's suppose a coloring is already chosen. Then it can be covered with dominoes greedily: red and blue cells are independent from each other, and, for example, red cells can be analyzed as a set of \"strips\" of them of different length. Let's say that we cover each \"strip\" from left to right, so, in each \"strip\", the first domino covers the cells  and , the second domino \u2014 the cells  and , and so on.Let's calculate the  value of the coloring, that is, the expected value of the coloring if it is chosen randomly. Let it be , then the answer is .By linearity of expectation,  can be calculated as , where  is the set of all places we can use for a domino, and  is the probability that there is a domino in place  in our domino covering (which we construct greedily). Each domino covers two adjacent cells, so we can iterate on pairs of adjacent cells, and for each pair, find the probability that this pair is covered. Let's suppose that we want to cover the cells  and  with a domino. Then:  both of these cells should be red;  the length of the red \"strip\" before these cells should be even (otherwise the cell  will be paired with the cell ). The only thing we need to know in order to calculate the probability of these two conditions being true is the number of white cells before the cell  \u2014 which can be easily maintained. Knowing the number of white cells before , we can either use dynamic programming to calculate the required probability, or do the math on several easy examples and try to notice the pattern: if there are  white cells before the current one, the probability of that pair being covered with a domino (let's call it ) is  (both these cells should be red);  if there is  white cell before the current one, the probability of that pair being covered with a domino (let's call it ) is  (the cells  and  should be red, but the cell before them should not be red);   is  (either the chosen two cells are red and the cell before them is not red, or all four cells are red);   is , and so on. So, knowing the number of white cells before  and , we easily calculate the probability of this pair being covered by a domino. By summing up the probabilities over all pairs of adjacent white cells (don't forget the vertical ones!), we get the average (or expected) value of the coloring. All that's left is to multiply it by .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300043;\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD)\n        x -= MOD;\n    while(x < 0)\n        x += MOD;\n    return x;                         \n}\n\nint sub(int x, int y)\n{\n    return add(x, MOD - y);\n}\n\nint mul(int x, int y)\n{\n    return (x * 1ll * y) % MOD;\n}\n\nint binpow(int x, int y)\n{\n    int z = 1;\n    while(y > 0)\n    {\n        if(y % 2 == 1)\n            z = mul(z, x);\n        x = mul(x, x);\n        y /= 2;\n    }\n    return z;\n}\n\nint inv(int x)\n{\n    return binpow(x, MOD - 2);   \n}\n\nint divide(int x, int y)\n{\n    return mul(x, inv(y));\n}\n\nstring s[N];\nint p[N];\nint n, m;\nchar buf[N];\n\nint main()\n{\n    scanf(\"%d %d\", &n, &m);\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%s\", buf);\n        s[i] = buf;\n    }\n    p[0] = divide(1, 2);\n    for(int i = 1; i < N; i++)\n        if(i % 2 == 1)\n            p[i] = sub(p[i - 1], divide(1, binpow(2, i)));\n        else\n            p[i] = add(p[i - 1], divide(1, binpow(2, i)));\n    int ans = 0;\n    int w = 0;\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < m; j++)\n            if(s[i][j] != '*')\n                w = add(w, 1);\n    for(int i = 0; i < n; i++)\n    {\n        int c = 0;\n        for(int j = 0; j < m; j++)\n        {\n            if(s[i][j] == '*')\n                c = 0;\n            else\n                c++;\n            if(c > 0)\n                ans = add(ans, p[c]);\n        }\n    }\n    for(int j = 0; j < m; j++)\n    {\n        int c = 0;\n        for(int i = 0; i < n; i++)\n        {\n            if(s[i][j] == '*')\n                c = 0;\n            else\n                c++;\n            if(c > 0)\n                ans = add(ans, p[c]);\n        }\n    }\n    ans = mul(ans, binpow(2, w));\n    cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}