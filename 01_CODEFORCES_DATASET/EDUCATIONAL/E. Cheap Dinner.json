{"link": "https://codeforces.com//contest/1487/problem/E", "problemId": "897751", "shortId": "1487E", "contest_number": "1487", "name": "E. Cheap Dinner", "statement": "Ivan wants to have a good dinner. A good dinner should consist of a first course, a second course, a drink, and a dessert.There are  different types of first courses Ivan can buy (the -th of them costs  coins),  different types of second courses (the -th of them costs  coins),  different types of drinks (the -th of them costs  coins) and  different types of desserts (the -th of them costs  coins).Some dishes don't go well with each other. There are  pairs of first courses and second courses that don't go well with each other,  pairs of second courses and drinks, and  pairs of drinks and desserts that don't go well with each other.Ivan wants to buy exactly one first course, one second course, one drink, and one dessert so that they go well with each other, and the total cost of the dinner is the minimum possible. Help him to find the cheapest dinner option!", "input": "The first line contains four integers , ,  and  () \u2014 the number of types of first courses, second courses, drinks and desserts, respectively. Then four lines follow. The first line contains  integers  (), where  is the cost of the -th type of first course. Three next lines denote the costs of second courses, drinks, and desserts in the same way (). The next line contains one integer  ()\u00a0\u2014 the number of pairs of first and second courses that don't go well with each other. Each of the next  lines contains two integers  and  (; ) denoting that the first course number  doesn't go well with the second course number . All these pairs are different. The block of pairs of second dishes and drinks that don't go well with each other is given in the same format. The same for pairs of drinks and desserts that don't go well with each other ().", "output": "If it's impossible to choose a first course, a second course, a drink, and a dessert so that they go well with each other, print . Otherwise, print one integer\u00a0\u2014 the minimum total cost of the dinner.", "tutorial": "The main solution is dynamic programming: let  for every possible dish  be the minimum cost to assemble a prefix of a dinner ending with the dish  (here,  can be a dish of any type: first course, second course, drink, or dessert). Then, the answer to the problem is the minimum value among all desserts.The number of transitions in this dynamic programming is too big, since, for example, when transitioning from first courses to second courses, we need to check ) options. To speed this up, we need some sort of data structure built over the values of  for all first courses  that allows to recalculate  for a second course  quickly. There are two main approaches to this:  build any version of RMQ over the values of dynamic programming for the first courses. Then, when we want to calculate the answer for some second course , sort all types of first courses which don't go well with it, and make several RMQ queries to find the minimum value over all non-forbidden first courses;  store all values of  in a data structure that supports adding an element, deleting an element, and finding the minimum element (this DS should allow duplicate elements as well). When we want to calculate the answer for some second course , remove all values of  corresponding to the first courses that don't go well with it from the data structure, query the minimum in it, and insert the removed elements back. The same approach can be used to advance from second courses to drinks and from drinks to desserts (you can even use the same code in a for-loop with  iterations, so the resulting solution is actually short and simple).", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint main()\n{   \n    vector<int> ns(4);\n    for(int i = 0; i < 4; i++)\n        scanf(\"%d\", &ns[i]);\n    vector<vector<int>> cs(4);\n    for(int i = 0; i < 4; i++)\n    {\n        cs[i].resize(ns[i]);\n        for(int j = 0; j < ns[i]; j++)\n            scanf(\"%d\", &cs[i][j]);\n    }\n    vector<vector<vector<int>>> bad(3);\n    for(int i = 0; i < 3; i++)\n    {\n        bad[i].resize(ns[i + 1]);\n        int m;\n        scanf(\"%d\", &m);\n        for(int j = 0; j < m; j++)\n        {\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            x--;\n            y--;\n            bad[i][y].push_back(x);\n        }\n    }                   \n    vector<vector<int>> dp(4);\n    dp[0] = cs[0];\n    for(int i = 0; i < 3; i++)\n    {\n        dp[i + 1].resize(ns[i + 1]);                \n        multiset<int> s;\n        for(int j = 0; j < ns[i]; j++)\n            s.insert(dp[i][j]);\n        for(int j = 0; j < ns[i + 1]; j++)\n        {\n            for(auto k : bad[i][j])\n                s.erase(s.find(dp[i][k]));\n            if(s.empty())\n                dp[i + 1][j] = int(4e8 + 43);\n            else\n                dp[i + 1][j] = *s.begin() + cs[i + 1][j];\n            for(auto k : bad[i][j])\n                s.insert(dp[i][k]);       \n        }\n    }\n    int ans = *min_element(dp[3].begin(), dp[3].end());\n    if(ans > int(4e8))\n        ans = -1;\n    cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}