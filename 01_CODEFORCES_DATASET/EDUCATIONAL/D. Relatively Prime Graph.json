{"link": "https://codeforces.com//contest/1009/problem/D", "problemId": "197475", "shortId": "1009D", "contest_number": "1009", "name": "D. Relatively Prime Graph", "statement": "Let's call an undirected graph   if and only if for each edge  \u00a0 (the greatest common divisor of  and  is ). If there is no edge between some pair of vertices  and  then the value of  doesn't matter. The vertices are numbered from  to .Construct a  graph with  vertices and  edges such that it is connected and it contains neither self-loops nor multiple edges.If there exists no valid graph with the given number of vertices and edges then output .If there are multiple answers then print any of them.", "input": "The only line contains two integers  and  () \u2014 the number of vertices and the number of edges.", "output": "If there exists no valid graph with the given number of vertices and edges then output . Otherwise print the answer in the following format: The first line should contain the word . The -th of the next  lines should contain the -th edge  of the resulting graph (). For each pair  there can be no more pairs  or . The vertices are numbered from  to . If there are multiple answers then print any of them.", "tutorial": "Even though  is up to , straightforward  solution will work. You iterate for  from  to  in the outer loop, from  to  in the inner loop and check  each time. When  edges are found, you break from both loops.Here is why this work fast enough. The total number of pairs  with  is , where  is Euler's totient function. We also want to substract a single pair . And this sum grows so fast that after about  iteratons  will be greater than  for any .The only thing left is to check that  is big enough to build a connected graph () and small enough to fit all possible edges for given  (the formula above).Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 100000;\n\npair<int, int> ans[N];\n\nint main() {\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tif (m < n - 1) {\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tint cur = 0;\n\t\n\tforn(i, n) for (int j = i + 1; j < n; ++j){\n\t\tif (cur == m)\n\t\t\tbreak;\n\t\tif (__gcd(i + 1, j + 1) == 1)\n\t\t\tans[cur++] = make_pair(j, i);\n\t}\n\t\n\tif (cur != m){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tputs(\"Possible\");\n\tforn(i, m)\n\t\tprintf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n\t\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}