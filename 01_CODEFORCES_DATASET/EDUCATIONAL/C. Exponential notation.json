{"link": "https://codeforces.com//contest/691/problem/C", "problemId": "65088", "shortId": "691C", "contest_number": "691", "name": "C. Exponential notation", "statement": "You are given a positive decimal number .Your task is to convert it to the \"\".Let , where , then in general case the \"\" looks like \"\". If  equals to zero, the part \"\" should be skipped. If  is an integer, it should be written without decimal point. Also there should not be extra zeroes in  and .", "input": "The only line contains the positive decimal number . The length of the line will not exceed . Note that you are given too large number, so you can't use standard built-in data types \"\", \"\" and other.", "output": "Print the only line \u2014 the \"\" of the given number .", "tutorial": "This is an implementation problem. You should do exactly what is written in the problem statement. On my mind the simplest way is to find the position of the first not zero digit and the position of the dot. The difference between that positions is the value of  (if the value is positive you should also decrease it by one).\n", "solution": "string s;\n\nbool read() {\n\treturn !!getline(cin, s);\n}\n\nvoid solve() {\n\tint pos = int(find_if(all(s), [](char c) { return c != '0' && c != '.'; }) - s.begin());;\n\tsize_t dot_pos = s.find('.');\n\tif (dot_pos == string::npos) {\n\t\tdot_pos = s.size();\n\t} else {\n\t\ts.erase(dot_pos, 1);\n\t}\n\n\tint expv = (int) dot_pos - pos;\n\tif (expv > 0) expv--;\n\tforn(t, 2) {\n\t\twhile (s.back() == '0') s.pop_back();\n\t\treverse(all(s));\n\t}\n\tif (sz(s) > 1) s.insert(1, \".\");\n\tif (expv == 0) printf(\"%s\\n\", s.c_str());\n\telse printf(\"%sE%d\\n\", s.c_str(), expv);\n}", "interactive": false, "noSolution": false, "noTutorial": false}