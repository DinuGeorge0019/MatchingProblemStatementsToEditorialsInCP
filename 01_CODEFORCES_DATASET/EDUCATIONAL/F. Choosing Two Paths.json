{"link": "https://codeforces.com//contest/1073/problem/F", "problemId": "243301", "shortId": "1073F", "contest_number": "1073", "name": "F. Choosing Two Paths", "statement": "You are given an undirected unweighted tree consisting of  vertices.An undirected tree is a connected undirected graph with  edges.Your task is to choose two pairs of vertices of this tree (all the chosen vertices )  and  in such a way that neither  nor  belong to the simple path from  to  and vice versa (neither  nor  should not belong to the simple path from  to ).Among all possible ways to choose such pairs you have to choose one with the  between paths from  to  and from  to . And among all such pairs you have to choose one with the  of these two paths.The length of the path is the number of edges in it.The simple path is the path that visits each vertex at most once.", "input": "The first line contains an integer  \u2014 the number of vertices in the tree (). Each of the next  lines describes the edges of the tree. Edge  is denoted by two integers  and , the labels of vertices it connects (, ). It is guaranteed that the given edges form a tree. ", "output": "Print  two pairs of vertices satisfying the conditions described in the problem statement. ", "tutorial": "Firstly, let's call a path from  to  , if  is a leaf,  is a vertex of degree at least  (the number of their neighbors is at least ) and there are no other vertices of degree at least  on this path expect the vertex .The first step of the solution is to remove all the  paths from  to  (but we should not remove the vertex ) and remember for each vertex  the sum of two maximum lengths of  paths which end in the vertex . Let this value for the vertex  be . For example, if for some vertex  there are  good paths with end in it of lengths ,  and  correspondingly, then  will be .Okay, it is easy to see that the maximum intersection of two paths in the answer will be equal to the length of the diameter of the obtained tree. But we can not take  diameter of this tree and call it the answer because of the second constraint: we need to find some diameter from  to  such that the sum  is maximum possible. How do we do that?There is such an awesome (and well-known) fact that the center of a tree belongs to all diameters of this tree. Let's root the tree by the center of a tree (if the length of the diameter is odd (the center of a tree is an edge) then let's root the tree by any end of this edge, it does not matter).There is one case when the length of the diameter is  but it is pretty trivial to handle it.Now our problem is to find two neighbors of the root of the new tree such that in their subtrees are vertices which form some diameter of this tree and the sum of values of these vertices is maximum possible. Let's calculate the vertex with the maximum distance from a root (and with the maximum possible  for equals distances) by simple  for each neighbor of a root. It can be done in  and the last part is to find two maximums of this list, it also can be done in  or , depends on implementation.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\t\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\t\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\t\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\t\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\t\n\tpt ans = calc(path[size(path) / 2]);\n\t\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}