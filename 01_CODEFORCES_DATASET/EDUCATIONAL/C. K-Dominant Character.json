{"link": "https://codeforces.com//contest/888/problem/C", "problemId": "133216", "shortId": "888C", "contest_number": "888", "name": "C. K-Dominant Character", "statement": "You are given a string  consisting of lowercase Latin letters. Character  is called -dominant iff each substring of  with length at least  contains this character .You have to find minimum  such that there exists at least one -dominant character.", "input": "The first line contains string  consisting of lowercase Latin letters ().", "output": "Print one number \u2014 the minimum value of  such that there exists at least one -dominant character.", "tutorial": "At first, notice that the final answer is minimum over answers for each character.The answer for one character can be obtained like this. Write down lengths of segments between two consecutive occurrences of this character, from the first occurrence to the start of the string and from the last to the end of the string. Take maximum of these values. Answer will be this maximum + 1.Overall complexity: .", "solution": "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nvoid sleep( double sec = 1021 ){\n  clock_t s = clock();\n  while( clock() - s < CLOCKS_PER_SEC * sec );\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 101010\nvoid build(){\n\n}\nchar c[ N ];\nint len;\nvoid init(){\n  cin >> c;\n  len = strlen( c );\n}\nint check( char cc ){\n  vector<int> vv;\n  int pre = -1 , mx = 0;\n  for( int i = 0 ; i < len ; i ++ )\n    if( c[ i ] == cc ){\n      mx = max( mx , i - pre );\n      pre = i;\n    }\n  mx = max( mx , len - pre );\n  return mx;\n}\nvoid solve(){\n  int ans = N;\n  for( int i = 0 ; i < 26 ; i ++ )\n    ans = min( ans , check( i + 'a' ) );\n  cout << ans << endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}