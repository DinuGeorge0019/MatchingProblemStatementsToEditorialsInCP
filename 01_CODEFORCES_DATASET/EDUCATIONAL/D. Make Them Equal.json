{"link": "https://codeforces.com//contest/1633/problem/D", "problemId": "1280036", "shortId": "1633D", "contest_number": "1633", "name": "D. Make Them Equal", "statement": "You have an array of integers  of size . Initially, all elements of the array are equal to . You can perform the following operation: choose two integers  () and  (), and then increase the value of  by  (i.e. make ).After performing all operations, you will receive  coins for all such  that .Your task is to determine the maximum number of coins that you can receive by performing no more than  operations.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers  and  ()\u00a0\u2014 the size of the array and the maximum number of operations, respectively. The second line contains  integers  (). The third line contains  integers  (). The sum of  over all test cases does not exceed .", "output": "For each test case, print one integer\u00a0\u2014 the maximum number of coins that you can get by performing no more than  operations.", "tutorial": "Let's calculate \u00a0\u2014 the minimum number of operations to get the number  from . To do this, it is enough to use BFS or dynamic programming. Edges in the graph (transitions in dynamic programming) have the form  for all .Now the problem itself can be reduced to a knapsack problem: there are  items, -th item weighs  and costs , you have to find a set of items with the total weight of no more than  of the maximum cost. This is a standard problem that can be solved in , but it is too slow (although some participants passed all the tests with such a solution). However, we can notice that the values of  should not grow too fast, namely, the maximum value of  for  does not exceed . This means that the maximum possible weight is no more than , and we can limit  to this number (i.\u2009e. make ).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1001;\n\nint main() {\n  vector<int> d(N, N);\n  d[1] = 0;\n  for (int i = 1; i < N; ++i) {\n    for (int x = 1; x <= i; ++x) {\n      int j = i + i / x;\n      if (j < N) d[j] = min(d[j], d[i] + 1);\n    }\n  }\n  \n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    vector<int> b(n), c(n);\n    for (int &x : b) cin >> x;\n    for (int &x : c) cin >> x;\n    int sum = 0;\n    for (int x : b) sum += d[x];\n    k = min(k, sum);\n    vector<int> dp(k + 1, 0);\n    for (int i = 0; i < n; ++i) {\n      for (int j = k - d[b[i]]; j >= 0; j--) {\n        dp[j + d[b[i]]] = max(dp[j + d[b[i]]], dp[j] + c[i]);\n      }\n    }\n    cout << *max_element(dp.begin(), dp.end()) << '\\n';\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}