{"link": "https://codeforces.com//contest/845/problem/D", "problemId": "119174", "shortId": "845D", "contest_number": "845", "name": "D. Driving Test", "statement": "Polycarp has just attempted to pass the driving test. He ran over the straight road with the signs of four types.  speed limit: this sign comes with a positive integer number \u2014 maximal speed of the car after the sign (cancel the action of the previous sign of this type);  overtake is allowed: this sign means that after some car meets it, it can overtake any other car;  no speed limit: this sign cancels speed limit if any (car can move with arbitrary speed after this sign);  no overtake allowed: some car can't overtake any other car after this sign. Polycarp goes past the signs consequentially, each new sign cancels the action of all the previous signs of it's kind (speed limit/overtake). It is possible that two or more \"no overtake allowed\" signs go one after another with zero \"overtake is allowed\" signs between them. It works with \"no speed limit\" and \"overtake is allowed\" signs as well.In the beginning of the ride overtake is allowed and there is no speed limit.You are given the sequence of events in chronological order \u2014 events which happened to Polycarp during the ride. There are events of following types:  Polycarp changes the speed of his car to specified (this event comes with a positive integer number);  Polycarp's car overtakes the other car;  Polycarp's car goes past the \"speed limit\" sign (this sign comes with a positive integer);  Polycarp's car goes past the \"overtake is allowed\" sign;  Polycarp's car goes past the \"no speed limit\";  Polycarp's car goes past the \"no overtake allowed\"; It is guaranteed that the first event in chronological order is the event of type  (Polycarp changed the speed of his car to specified).After the exam Polycarp can justify his rule violations by telling the driving instructor that he just didn't notice some of the signs. What is the minimal number of signs Polycarp should say he didn't notice, so that he would make no rule violations from his point of view?", "input": "The first line contains one integer number  () \u2014 number of events. Each of the next  lines starts with integer  () \u2014 the type of the event. An integer  () follows in the query of the first and the third type (if it is the query of first type, then it's new speed of Polycarp's car, if it is the query of third type, then it's new speed limit). It is guaranteed that the first event in chronological order is the event of type  (Polycarp changed the speed of his car to specified).", "output": "Print the minimal number of road signs Polycarp should say he didn't notice, so that he would make no rule violations from his point of view.", "tutorial": "Let's notice that you should never say that you didn't notice signs \"no speed limit\" and \"overtake is allowed\". Also if you drive with speed , you don't want to remove signs \"speed limit\" with number greater or equal to .Thus, greedy solution will work. Process all the events in chronological order. We should maintain stack of signs \"speed limit\" and amount of signs \"no overtake allowed\". If we meet sign \"speed limit\", we push its limit to stack, sign \"no overtake allowed\" \u2014 increase , \"no speed limit\" \u2014 clear stack, \"overtake is allowed\" \u2014 assign  to zero. After every event we should check if our speed is fine. While value of sign on the top of the stack is less than current speed, pop it and increase answer. If we overtake someone, we add  to answer and assign  to zero.Overall complexity: .", "solution": "//package educational.round27;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class D {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tlong I = Long.MAX_VALUE;\n//\t\tlong lim = I;\n//\t\tboolean can = true;\n\t\tint nfalse = 0;\n\t\t\n\t\tlong speed = 0;\n\t\t\n\t\tSegmentTreeRMQL st = new SegmentTreeRMQL(200005);\n\t\tint[] imos = new int[200011];\n\t\tint p = 0;\n\t\tint bound = 0;\n\t\t// [bound,]\n\t\t\n\t\tint nvio = 0;\n\t\tfor(int Q = ni();Q > 0;Q--){\n\t\t\tint type = ni();\n\t\t\tif(type == 1){\n\t\t\t\tspeed = nl();\n\t\t\t\tint last = st.lastle(p-1, -speed);\n\t\t\t\t// [last+1,\n\t\t\t\timos[Math.max(bound, last+1)]++;\n\t\t\t\timos[p]--;\n\t\t\t}else if(type == 2){\n\t\t\t\tnvio += nfalse;\n\t\t\t\tnfalse = 0;\n\t\t\t}else if(type == 3){\n\t\t\t\tlong v = nl();\n\t\t\t\tst.update(p++, -v);\n\t\t\t\tif(speed > v){\n\t\t\t\t\timos[p-1]++;\n\t\t\t\t\timos[p]--;\n\t\t\t\t}\n\t\t\t}else if(type == 4){\n//\t\t\t\tcan = true;\n\t\t\t\tnfalse = 0;\n\t\t\t}else if(type == 5){\n\t\t\t\tbound = p;\n\t\t\t}else if(type == 6){\n//\t\t\t\tcan = false;\n\t\t\t\tnfalse++;\n\t\t\t}else{\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < p;i++){\n\t\t\timos[i+1] += imos[i];\n\t\t\tif(imos[i] > 0)nvio++;\n\t\t}\n\t\t\n\t\tout.println(nvio);\n\t}\n\t\n\tpublic static class SegmentTreeRMQL {\n\t\tpublic int M, H, N;\n\t\tpublic long[] st;\n\t\t\n\t\tpublic SegmentTreeRMQL(int n)\n\t\t{\n\t\t\tN = n;\n\t\t\tM = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n\t\t\tH = M>>>1;\n\t\t\tst = new long[M];\n\t\t\tArrays.fill(st, 0, M, Long.MAX_VALUE);\n\t\t}\n\t\t\n\t\tpublic SegmentTreeRMQL(long[] a)\n\t\t{\n\t\t\tN = a.length;\n\t\t\tM = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n\t\t\tH = M>>>1;\n\t\t\tst = new long[M];\n\t\t\tfor(int i = 0;i < N;i++){\n\t\t\t\tst[H+i] = a[i];\n\t\t\t}\n\t\t\tArrays.fill(st, H+N, M, Long.MAX_VALUE);\n\t\t\tfor(int i = H-1;i >= 1;i--)propagate(i);\n\t\t}\n\t\t\n\t\tpublic void update(int pos, long x)\n\t\t{\n\t\t\tst[H+pos] = x;\n\t\t\tfor(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);\n\t\t}\n\t\t\n\t\tprivate void propagate(int i)\n\t\t{\n\t\t\tst[i] = Math.min(st[2*i], st[2*i+1]);\n\t\t}\n\t\t\n\t\tpublic long minx(int l, int r){\n\t\t\tlong min = Long.MAX_VALUE;\n\t\t\tif(l >= r)return min;\n\t\t\twhile(l != 0){\n\t\t\t\tint f = l&-l;\n\t\t\t\tif(l+f > r)break;\n\t\t\t\tlong v = st[(H+l)/f];\n\t\t\t\tif(v < min)min = v;\n\t\t\t\tl += f;\n\t\t\t}\n\t\t\t\n\t\t\twhile(l < r){\n\t\t\t\tint f = r&-r;\n\t\t\t\tlong v = st[(H+r)/f-1];\n\t\t\t\tif(v < min)min = v;\n\t\t\t\tr -= f;\n\t\t\t}\n\t\t\treturn min;\n\t\t}\n\t\t\n\t\tpublic long min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}\n\t\t\n\t\tprivate long min(int l, int r, int cl, int cr, int cur)\n\t\t{\n\t\t\tif(l <= cl && cr <= r){\n\t\t\t\treturn st[cur];\n\t\t\t}else{\n\t\t\t\tint mid = cl+cr>>>1;\n\t\t\t\tlong ret = Long.MAX_VALUE;\n\t\t\t\tif(cl < r && l < mid){\n\t\t\t\t\tret = Math.min(ret, min(l, r, cl, mid, 2*cur));\n\t\t\t\t}\n\t\t\t\tif(mid < r && l < cr){\n\t\t\t\t\tret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int firstle(int l, long v) {\n\t\t\tint cur = H+l;\n\t\t\twhile(true){\n\t\t\t\tif(st[cur] <= v){\n\t\t\t\t\tif(cur < H){\n\t\t\t\t\t\tcur = 2*cur;\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn cur-H;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcur++;\n\t\t\t\t\tif((cur&cur-1) == 0)return -1;\n\t\t\t\t\tif((cur&1)==0)cur>>>=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int lastle(int l, long v) {\n\t\t\tint cur = H+l;\n\t\t\twhile(true){\n\t\t\t\tif(st[cur] <= v){\n\t\t\t\t\tif(cur < H){\n\t\t\t\t\t\tcur = 2*cur+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn cur-H;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif((cur&cur-1) == 0)return -1;\n\t\t\t\t\tcur--;\n\t\t\t\t\tif((cur&1)==1)cur>>>=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new D().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}