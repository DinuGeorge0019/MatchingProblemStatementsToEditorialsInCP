{"link": "https://codeforces.com//contest/1380/problem/G", "problemId": "670989", "shortId": "1380G", "contest_number": "1380", "name": "G. Circular Dungeon", "statement": "You are creating a level for a video game. The level consists of  rooms placed in a circle. The rooms are numbered  through . Each room contains exactly one exit: completing the -th room allows you to go the -th room (and completing the -th room allows you to go the -st room).You are given the description of the multiset of  chests: the -th chest has treasure value .Each chest can be of one of two types:   regular chest\u00a0\u2014 when a player enters a room with this chest, he grabs the treasure and proceeds to the next room;  mimic chest\u00a0\u2014 when a player enters a room with this chest, the chest eats him alive, and he loses. The player starts in a random room with each room having an equal probability of being chosen. The players earnings is equal to the total value of treasure chests he'd collected before he lost.You are allowed to choose the order the chests go into the rooms. For each  from  to  place the chests into the rooms in such a way that:  each room contains  one chest;    chests are mimics;  the expected value of players earnings is  possible. Please note that for each  the placement is chosen independently.It can be shown that it is in the form of  where  and  are non-negative integers and . Report the values of .", "input": "The first contains a single integer  ()\u00a0\u2014 the number of rooms and the number of chests. The second line contains  integers  ()\u00a0\u2014 the treasure values of each chest.", "output": "Print  integers\u00a0\u2014 the \u00a0-th value should be equal to the minimum possible expected value of players earnings if the chests are placed into the rooms in some order and exactly  of the chests are mimics. It can be shown that it is in the form of  where  and  are non-negative integers and . Report the values of .", "tutorial": "At first, let's say that the expected value is equal to the average of total earnings over all positions and is equal to the sum of earnings over all positions divided by . So we can trasition to minimizing the sum.Let's learn how to solve the task for some fixed . Fix some arrangement and rotate the rooms so that the last room contains a mimic. So now you have  regular chests, then a single mimic,  regular chests, single mimic, ,  regular chests, single mimic. All  and .Take a look at some of these intervals of length . The last chest in the interval is taken from  starting positions, the second-to-last is taken  times and so on.Now let's find the optimal way to choose . Fix some values of . Take a look at the smallest of these values and the largest of them. Let the values be  and . If they differ by at least  (), then the smaller result can always be achieved by moving a regular chest from the larger one to the smaller one. ProofConsider two sequences of coefficients for both intervals:  and .However, if you remove one chest, then they will be equal to  and .If you only consider the difference between the numbers of both sequences, then you can see that only coefficient  got removed and coefficient  was added. So you can rearrange the chests in such a way that all chests are assigned to the same value and only the chest that was assigned to  becomes assigned to , thus decreasing the total value.Now we have all  set now. The only thing left is to assign chests optimally. Write down the union of all the coefficient sequences from all the intervals  and sort them in the non-decreasing order. It's easy to show that the chests should be sorted in the non-increasing order (really classical thing, you can try proving that by showing that any other arrangement can easily be improved once again).That allows us to write a solution in . Sort all the chests in the beginning, after that for some  multiply the value of the -th chest by  and sum up the results.Finally, let's speed this up with prefix sums. Notice that the first  values are multiplied by , the second  values \u2014 by  and so on. If  is not divisible by , then the last block just has length smaller than . Thus, we can calculate the answer for some  in . And that's equal to  = .Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\tif (a < 0)\n\t\ta += MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * 1ll * b % MOD;\n}\n\nint binpow(int a, int b){\n\tint res = 1;\n\twhile (b){\n\t\tif (b & 1)\n\t\t\tres = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nvector<int> pr;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> c(n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &c[i]);\n\tsort(c.begin(), c.end(), greater<int>());\n\tpr.push_back(0);\n\tforn(i, n)\n\t\tpr.push_back(add(pr.back(), c[i]));\n\t\n\tint invn = binpow(n, MOD - 2);\n\tfor (int k = 1; k <= n; ++k){\n\t\tint ans = 0;\n\t\tfor (int i = 0, j = 0; i < n; i += k, ++j)\n\t\t\tans = add(ans, mul(j, add(pr[min(n, i + k)], -pr[i])));\n\t\tprintf(\"%d \", mul(ans, invn));\n\t}\n\tputs(\"\");\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}