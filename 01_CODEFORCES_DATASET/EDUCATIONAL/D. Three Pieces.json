{"link": "https://codeforces.com//contest/1065/problem/D", "problemId": "235281", "shortId": "1065D", "contest_number": "1065", "name": "D. Three Pieces", "statement": "You stumbled upon a new kind of chess puzzles. The chessboard you are given is not necesserily , but it still is . Each square has some number written on it, all the numbers are from  to  and all the numbers are pairwise distinct. The -th square in the -th row has a number  written on it.In your chess set you have only three pieces: a knight, a bishop and a rook. At first, you put one of them on the square with the number  (you can choose which one). Then you want to reach square  (possibly passing through some other squares in process), then square  and so on until you reach square . In one step you are allowed to either make a valid move with the current piece or replace it with some other piece. .A knight can move to a square that is two squares away horizontally and one square vertically, or two squares vertically and one square horizontally. A bishop moves diagonally. A rook moves horizontally or vertically. The move should be performed to a different square from the one a piece is currently standing on.You want to minimize the number of steps of the whole traversal. Among all the paths to have the same number of steps you want to choose the one with the lowest number of piece replacements.What is the path you should take to satisfy all conditions?", "input": "The first line contains a single integer  () \u2014 the size of the chessboard. Each of the next  lines contains  integers  () \u2014 the numbers written on the squares of the -th row of the board. It is guaranteed that all  are pairwise distinct.", "output": "The only line should contain two integers \u2014 the number of steps in the best answer and the number of replacement moves in it.", "tutorial": "There are a lot of different solutions for the problem. Most of them have the similar structure.The first part is to find the shortest distance between the states  and , where  and  are the coordinates of the square and  is the current piece. This can be done with 0-1 bfs, Floyd or Dijkstra. Just represent the triple as a single integer by transforming it to  and do everything on that graph.The second part is to write some dp to go from -th square with piece  to -th square with piece . The value of this  is a pair (moves, replacements). It is easy to see that you can always choose the minimum of two such pairs while updating.Overall complexity may vary. We believe,  is achievable. However, the particular solution I coded works in .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n    return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2,  2,  1, -1, -2};\nint dy[] = { 1,  2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n    return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, n){\n        scanf(\"%d\", &a[i][j]);\n        --a[i][j];\n        pos[a[i][j]] = mp(i, j);\n    }\n    \n    forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n    forn(i, M) dist[i][i] = mp(0, 0);\n    \n    forn(x, n) forn(y, n){\n        forn(i, 8){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (in(nx, ny))\n                dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n        }\n        \n        for (int i = -n + 1; i <= n - 1; ++i){\n            int nx = x + i;\n            int ny = y + i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n            ny = y - i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n        }\n        \n        forn(i, n){\n            int nx = x;\n            int ny = i;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n            nx = i;\n            ny = y;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n        }\n        \n        forn(i, 3) forn(j, 3){\n            if (i != j){\n                dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n            }\n        }\n    }\n    \n    forn(k, M) forn(i, M) forn(j, M)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    \n    forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n    dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n    forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n    \n    pt ans = mp(INF, INF);\n    ans = min(ans, dp[n * n - 1][0]);\n    ans = min(ans, dp[n * n - 1][1]);\n    ans = min(ans, dp[n * n - 1][2]);\n    \n    printf(\"%d %d\\n\", ans.x, ans.y);\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}