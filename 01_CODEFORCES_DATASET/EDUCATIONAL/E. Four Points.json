{"link": "https://codeforces.com//contest/1455/problem/E", "problemId": "815718", "shortId": "1455E", "contest_number": "1455", "name": "E. Four Points", "statement": "You are given four different integer points , ,  and  on  grid.In one step you can choose one of the points  and move it in one of four directions by one. In other words, if you have chosen point  you can move it to , ,  or .Your goal to move points in such a way that they will form a square with sides parallel to  and  axes (a square with side  is allowed).What is the minimum number of steps you need to make such a square?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. Each test case consists of four lines. Each line contains two integers  and  ()\u00a0\u2014 coordinates of one of the points . All points are different in one test case.", "output": "For each test case, print the single integer\u00a0\u2014 the minimum number of steps to make a square.", "tutorial": "Let's discuss two approaches to this problem. Firstly, let's think that we choose not four destination points but four lines on which sides of the square lie. It's two vertical lines with coordinates  and  and two horizontal lines  and  (of course, ). is to note that   either both  and  coincide with some -s and  coincide with one of   or both  and  coincide with some -s and  coincide with one .  Since we know the side of the square (from  or ) and one point  It's easy to construct other points of the square and find the minimum total distance by iterating all permutations. This approach needs around  operations and work around one second if written accurately. is more clever and faster. Let's assign a role for each point \u00a0\u2014 which vertex of the final square this  will be: left-bottom, left-top, right-bottom or right-top. There will be  such assignments. For simplicity let's say that the left-bottom vertex is , left-top is , right-bottom is  and right-top is .If we rewrite our total distance formulas, we can note that instead of summing the distance between points, we can sum the distance from lines to the points which should lie on it. In other words, we can calculate the answer as Let's look at the left side . If  then the total distance is always  and  has it's optimal segment of values. Analogically,  also has it's optimal segment of values .Since we can choose  as any value in its segment and  as any value in its segment then the possible distance  (the side of the square) also forms a segment of possible values (let's name it as ) and can be calculated with pretty easy formula.On the other hand, we can do the same with horizontal sides and compute the segment of optimal side length  in the same manner.Now, if  and  intersects then we can choose such side length  that lies in both  and  and optimal for both vertical sides and horizontal sides. Otherwise, without loss of generality,  and if we choose  we need to pay extra \"fee\" since we out of \u00a0\u2014 it means that the chosen  is greater than optimal , so we need to choose, for example,  outside . And we need to pay  for each step outside of this segment.In other words, the answer for a fixed permutation is ", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<li, li> pt;\n\nconst li INF64 = li(1e18);\n\npt p[4];\n\ninline bool read() {\n\tfore (i, 0, 4) {\n\t\tif(!(cin >> p[i].x >> p[i].y))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\ninline void solve() {\n\tli ans = INF64;\n\tfore (st, 0, 2) {\n\t\tfore (idx1, 0, 4) fore (idx2, 0, 4) fore (idy1, 0, 4) {\n\t\t\tli x1 = p[idx1].x;\n\t\t\tli x2 = p[idx2].x;\n\t\t\tli y1 = p[idy1].y;\n\t\t\t\n\t\t\tif (x1 > x2)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tfor (int k = -1; k <= 1; k += 2) {\n\t\t\t\tli y2 = y1 + k * abs(x1 - x2);\n\t\t\t\t\n\t\t\t\tvector<pt> fp = { {x1, y1}, {x2, y1}, {x2, y2}, {x1, y2} };\n\t\t\t\tsort(fp.begin(), fp.end());\n\t\t\t\t\n\t\t\t\tdo {\n\t\t\t\t\tli cur = 0;\n\t\t\t\t\tfore (i, 0, 4)\n\t\t\t\t\t\tcur += abs(fp[i].x - p[i].x) + abs(fp[i].y - p[i].y);\n\t\t\t\t\t\t\n\t\t\t\t\tans = min(ans, cur);\n\t\t\t\t} while(next_permutation(fp.begin(), fp.end()));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfore (i, 0, 4)\n\t\t\tswap(p[i].x, p[i].y);\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tint t;\n\tcin >> t;\n\t\n\twhile(t--) {\n\t\tassert(read());\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}