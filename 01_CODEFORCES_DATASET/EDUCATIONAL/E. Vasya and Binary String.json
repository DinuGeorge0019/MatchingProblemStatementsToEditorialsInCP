{"link": "https://codeforces.com//contest/1107/problem/E", "problemId": "288738", "shortId": "1107E", "contest_number": "1107", "name": "E. Vasya and Binary String", "statement": "Vasya has a string  of length  consisting only of digits  and . Also he has an array  of length . Vasya performs the following operation until the string becomes empty: choose some  substring of , erase it from the string and glue together the remaining parts (any of them can be empty). For example, if he erases substring  from string  he will get the string . Vasya gets  points for erasing substring of length .Vasya wants to maximize his total points, so help him with this! ", "input": "The first line contains one integer  () \u2014 the length of string . The second line contains string , consisting only of digits  and . The third line contains  integers  (), where  is the number of points for erasing the substring of length .", "output": "Print one integer \u2014 the maximum total points Vasya can get.", "tutorial": "We set up a DP on (start index, end index, number of consecutive digits matching our start index). In other words, the current string we are solving is the substring from start index to end index, plus some number of additional digits (all equal to S[start]) added as a prefix to our substring.\nWe then have two choices from any given state:\n   Cash in on our consecutive digits at the start and recurse on .   Pick an index  such that S[start] = S[i], and collapse everything between those two indices in order to merge them together for an even larger prefix. This results in a score of , and we can loop over all  to take the maximum. \nThe runtime is , with a very good constant factor. Code: 49036191\nDoes anybody have ?\n", "solution": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int N_MAX = 205;\n\nint N;\nstring S;\nvector<long long> A;\nlong long dp[N_MAX][N_MAX][N_MAX];\n\nlong long solve(int start, int end, int prefix) {\n    if (end - start <= 0)\n        return 0;\n\n    if (end - start == 1)\n        return A[prefix];\n\n    long long &answer = dp[start][end][prefix];\n\n    if (answer != 0)\n        return answer;\n\n    answer = A[prefix] + solve(start + 1, end, 1);\n\n    for (int i = start + 1; i < end; i++)\n        if (S[i] == S[start])\n            answer = max(answer, solve(start + 1, i, 1) + solve(i, end, prefix + 1));\n\n    return answer;\n}\n\nint main() {\n    cin >> N >> S;\n    A.assign(N + 1, 0);\n\n    for (int i = 1; i <= N; i++)\n        cin >> A[i];\n\n    cout << solve(0, N, 1) << '\\n';\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}