{"link": "https://codeforces.com//contest/1680/problem/F", "problemId": "1398260", "shortId": "1680F", "contest_number": "1680", "name": "F. Lenient Vertex Cover", "statement": "You are given a simple connected undirected graph, consisting of  vertices and  edges. The vertices are numbered from  to .A vertex cover of a graph is a set of vertices such that each edge has at least one of its endpoints in the set.Let's call a  vertex cover such a vertex cover that  edge in it has both endpoints in the set.Find a  vertex cover of a graph or report that there is none. If there are multiple answers, then print any of them.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains two integers  and  (; )\u00a0\u2014 the number of vertices and the number of edges of the graph. Each of the next  lines contains two integers  and  (; )\u00a0\u2014 the descriptions of the edges. For each testcase, the graph is connected and doesn't have multiple edges. The sum of  over all testcases doesn't exceed . The sum of  over all testcases doesn't exceed .", "output": "For each testcase, the first line should contain  if a  vertex cover exists, and  otherwise. If it exists, the second line should contain a binary string  of length , where  means that vertex  is in the vertex cover, and  means that vertex  isn't. If there are multiple answers, then print any of them.", "tutorial": "Let's think about why we can't always make a perfect vertex cover\u00a0\u2014 such a vertex cover that each edge has exactly one endpoint in it. Or why the answer can not exist at all.Consider a bamboo. It's always possible to find a perfect vertex cover. Just choose every other vertex in it and account for parity.Make a bamboo into a loop. Now you can see that an even length loop has a perfect vertex cover. An odd length doesn't.That tells us that each odd length loop in a graph will have a bad edge on it. Odd length loops should instantly make you think about bipartite colorings.So we can see that a bipartite graph always has a perfect vertex cover. Just choose one of the parts into a cover, and each edge will have exactly one endpoint in it. At the same time, a non-bipartite graph never has a perfect cover.So our general goal is to remove (basically, mark as bad) at most one edge in such a way that the remaining graph is bipartite.Consider a dfs tree of the graph, colored bipartitely. Every edge in the tree is good (has endpoints in different parts). Every edge outside the tree can be either good or bad. What happens to the tree if we remove an edge?If we remove an edge outside the dfs tree, then nothing happens to it. So if there is no more than one bad edge outside the tree, then we found the answer. That was the easy part.Now what happens if we remove an edge from the tree? The back edges from the subtree of the edge can force the subtree to either remain colored the same or flip all its colors. We don't really care if it remains the same, because we already took care of it in the first part. So let's pretend it always flips the colors.Thus, all edges that go from the subtree upwards above the removed edge, have only one of their endpoints colors changed. Good edges turn bad, bad edges turn good.All other edges don't change.So you should choose such an edge to remove that all bad edges in the graph go from its subtree upwards above that edge and no good edges go from its subtree upwards above that edge.That can be calculated with a dfs. Since all non-tree edges in the dfs tree are back edges, you can simply increment a counter on the bottom vertex, decrement the counter on the top vertex and collect sums from the bottom. The sum in the vertex will tell you the number of edges that start below or in the vertex and end above the vertex.Do this for both kinds of edge and check the conditions for all vertices. Finally, choose such a part to be a vertex cover that the removed edge has both ends in it (if you choose the other part, that edge won't be covered at all).The solution is linear, but the problem still requires a massive time and memory limit only because of recursion in the dfs.Overall complexity:  per testcase.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nvector<vector<int>> g, h;\nvector<int> tin, tout, clr;\nvector<vector<int>> sum(2);\nint T;\n\nint flip;\nint cnt;\n\nbool isp(int v, int u){\n    return tin[v] <= tin[u] && tout[v] >= tout[u];\n}\n\nvoid init(int v){\n    tin[v] = T++;\n    for (int u : g[v]){\n        if (clr[u] == -1){\n            clr[u] = clr[v] ^ 1;\n            h[v].push_back(u);\n            init(u);\n        }\n        else if (tin[u] < tin[v]){\n            int dif = clr[v] ^ clr[u];\n            if (!dif){\n                flip = clr[v] ^ 1;\n                ++cnt;\n            }\n            --sum[dif][u];\n            ++sum[dif][v]; \n        }\n    }\n    tout[v] = T;\n}\n\nint sv;\n\nvoid dfs(int v){\n    for (int u : h[v]){\n        dfs(u);\n        if (sum[0][u] == cnt && sum[1][u] == 1){\n            sv = u;\n            flip = clr[v] ^ 1;\n        }\n        forn(i, 2) sum[i][v] += sum[i][u];\n    }\n}\n\nint main() {\n    cin.tie(0);\n    iostream::sync_with_stdio(false);\n    int t;\n    cin >> t;\n    forn(_, t){\n        int n, m;\n        cin >> n >> m;\n        g.assign(n, vector<int>());\n        h.assign(n, vector<int>());\n        forn(i, m){\n            int v, u;\n            cin >> v >> u;\n            --v, --u;\n            g[v].push_back(u);\n            g[u].push_back(v);\n        }\n        tin.resize(n);\n        tout.resize(n);\n        forn(i, 2) sum[i].assign(n, 0);\n        clr.assign(n, -1);\n        cnt = 0;\n        T = 0;\n        clr[0] = 0;\n        init(0);\n        if (cnt <= 1){\n            cout << \"YES\\n\";\n            forn(v, n) cout << (clr[v] ^ flip);\n            cout << \"\\n\";\n            continue;\n        }\n        sv = -1;\n        dfs(0);\n        if (sv == -1){\n            cout << \"NO\\n\";\n        }\n        else{\n            cout << \"YES\\n\";\n            forn(v, n) cout << (clr[v] ^ isp(sv, v) ^ flip);\n            cout << \"\\n\";\n        }\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}