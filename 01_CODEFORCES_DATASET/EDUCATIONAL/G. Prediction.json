{"link": "https://codeforces.com//contest/1809/problem/G", "problemId": "1839367", "shortId": "1809G", "contest_number": "1809", "name": "G. Prediction", "statement": "Consider a tournament with  participants. The rating of the -th participant is .The tournament will be organized as follows. First of all, organizers will assign each participant an index from  to . All indices will be unique. Let  be the participant who gets the index .Then,  games will be held. In the first game, participants  and  will play. In the second game, the winner of the first game will play against . In the third game, the winner of the second game will play against , and so on \u2014 in the last game, the winner of the -th game will play against .Monocarp wants to predict the results of all  games (of course, he will do the prediction only after the indices of the participants are assigned). He knows for sure that, when two participants with ratings  and  play, and , the participant with the higher rating wins. But if , any of the two participants may win.Among all  ways to assign the indices to participants, calculate the number of ways to do this so that Monocarp can predict the results of   games. Since the answer can be large, print it modulo .", "input": "The first line contains two integers  and  (; ). The second line contains  integers  ().", "output": "Print one integer \u2014 the number of ways to assign the indices to the participants so that Monocarp can predict the results of all  games.", "tutorial": "We need some sort of better criterion other than \"all matches can be predicted\" first. Suppose the ratings of the participants are  in the order of their indices. Then, if all games are predictable, the -th game should be won by the participant with the rating equal to ; and in the -th game, they will play against the participant with rating . So, in order for each game to be predictable, . This is the criterion we will use.So, we will try to count the number of orderings meeting this condition. One very important observation we need to make is that, if we remove several participants with the lowest ratings from the ordering, that ordering still satisfies the condition (for each element, either the prefix before it is removed completely, or the maximum on it is unchanged). So, this allows us to construct the correct ordering by placing the sportsmen from the maximum rating to the minimum rating, and making sure that on every step, the order stays correct.Okay. Let's reverse the ratings array, and try to write the following dynamic programming:  is the number of correct orderings of the first  sportsmen (the  highest-rated sportsmen, since we reversed the ratings array). Let's try to place the next sportsman. We run into the following issue: for some orderings of the first  sportsmen, it is possible to place the next one anywhere (these orderings are where the first sportsman in the ordering doesn't conflict with the sportsman we are trying to place); but for other orderings, some positions might be forbidden. And to keep track of which positions are forbidden, and for which sportsmen, we probably need some additional states for the dynamic programming, which we don't really want to since  states is probably the most we can allow.Okay, so let's avoid this issue entirely. We don't like the orderings where the next sportsman can't be placed anywhere, so let's find a way to \"ignore\" them:  discard the previous definition of . Now, let  is the number of correct orderings of the  highest-rated sportsmen ;  when we place the next sportsman, in case it becomes the first element and conflicts with some of the elements we haven't placed yet, . So, this leads to the following transitions in the dynamic programming:  if we place the -th sportsman on any position other than the first one, there are  ways to do it, and we transition from  to ;  otherwise, if we place the -th sportsman on the first position, let  be the last sportsman \"conflicting\" with the sportsman . Let's try placing all sportsmen from  to  before placing the sportsman . They cannot be placed on the first position (otherwise they will conflict either with each other or with the sportsman ), so the first one can be placed in  ways, the second one \u2014 in  ways, and so on; this product can be easily calculated in  by preparing factorials and inverse factorials. So, then we transition from  to . There is a special case in our dynamic programming. It should start with , but what if the -st sportsman conflicts with someone? Then the ordering of the first  sportsmen is incorrect. In this case, the answer is  since the -st and the -nd sportsmen are conflicting.Overall complexity of this solution is  or  depending on your implementation.", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n    return ((x + y) % MOD + MOD) % MOD;\n}\n\nint mul(int x, int y)\n{\n    return x * 1ll * y % MOD;   \n}\n\nint binpow(int x, int y)\n{\n    int z = 1;\n    while(y)\n    {\n        if(y % 2 == 1) z = mul(z, x);\n        x = mul(x, x);\n        y /= 2;\n    }\n    return z;\n}\n\nint inv(int x)\n{\n    return binpow(x, MOD - 2);    \n}\n\nint divide(int x, int y)\n{\n    return mul(x, inv(y));\n}\n\nint main()\n{\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    vector<int> a(n);\n    for(int i = 0; i < n; i++)    \n        scanf(\"%d\", &a[i]);\n    \n    reverse(a.begin(), a.end());\n\n    vector<int> fact(n + 1);\n    fact[0] = 1;\n    for(int i = 1; i <= n; i++)\n        fact[i] = mul(fact[i - 1], i);\n\n    // for each player, we find the first player which doesn't conflict with them\n    vector<int> first_no_conflict(n);\n    for(int i = 0; i < n; i++)\n    {\n        if(i) first_no_conflict[i] = first_no_conflict[i - 1];\n        while(first_no_conflict[i] < n && a[first_no_conflict[i]] >= a[i] - k)\n            first_no_conflict[i]++;\n    }\n\n    vector<int> dp(n + 1);\n    if(a[0] - a[1] > k) dp[1] = 1;\n    for(int i = 1; i < n; i++)\n    {\n        // first choice: put a[i] on the first position\n        // then we put all which conflict with a[i] on any position other than 1\n        int no_of_conflicting = first_no_conflict[i] - i - 1;\n        // put all conflicting with a[i] on any position other than 1\n        // the first one chooses from i positions, the second - from i+1 positions, and so on\n        // so the number of ways is fact[i + no_of_conflicting - 1] / fact[i - 1]\n        dp[i + no_of_conflicting + 1] = add(dp[i + no_of_conflicting + 1], mul(dp[i], divide(fact[i + no_of_conflicting - 1], fact[i - 1])));\n\n        // second choice: put a[i] on any other position\n        dp[i + 1] = add(dp[i + 1], mul(dp[i], i));\n    }\n\n    printf(\"%d\\n\", dp[n]);\n}", "interactive": false, "noSolution": false, "noTutorial": false}