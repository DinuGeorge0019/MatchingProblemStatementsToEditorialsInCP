{"link": "https://codeforces.com//contest/985/problem/F", "problemId": "184587", "shortId": "985F", "contest_number": "985", "name": "F. Isomorphic Strings", "statement": "You are given a string  of length  consisting of lowercase English letters.For two given strings  and , say  is the set of distinct characters of  and  is the set of distinct characters of . The strings  and  are  if their lengths are equal and there is a one-to-one mapping (bijection)  between  and  for which . Formally:   for any index ,  for any character  there is exactly one character  that ,  for any character  there is exactly one character  that . For example, the strings \"\" and \"\" are isomorphic. Also the strings \"\" and \"\" are isomorphic. The following pairs of strings are not isomorphic: \"\" and \"\", \"\" and \"\".You have to handle  queries characterized by three integers  (). For each query check if two substrings  and  are isomorphic.", "input": "The first line contains two space-separated integers  and  (, ) \u2014 the length of the string  and the number of queries. The second line contains string  consisting of  lowercase English letters. The following  lines contain a single query on each line: ,  and  (, ) \u2014 the description of the pair of the substrings to check.", "output": "For each query in a separate line print \"\" if substrings  and  are isomorphic and \"\" otherwise.", "tutorial": "Yes, authors also implemented hashes.Note that if substrings  and  are isomophic, then position  of first encounter of some character  in  must be position of first encounter of some character  in . More over, if we sort all positions  for all distict characters in  and sort all positions  for , then  must be equal  for any . This observation gives us fact, that .So, to check isomorphism of  and  we need check for each , that positions of all encounters of character  equal to posistions of all encounters of character .To do that we can generate for each character boolean array with checked positions of its encounter and calculate prefix hashes on this arrays. Also we need precalculate order of first encounters  for each suffix of string . To do it fast note that in transition from  to  only  can change its relative order.Result complexity is  with quite big constant from hashing.", "solution": "#include <bits/stdc++.h>\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int(a.size())\n\n#define x first\n#define y second\n\nusing namespace std;\n\nconst int B = 2;\n\ntypedef array<int, B> ht;\n\nht MOD, BASE;\n\ninline int norm(int a, const int &MOD) {\n\twhile(a >= MOD)\n\t\ta -= MOD;\n\twhile(a < 0)\n\t\ta += MOD;\n\treturn a;\n}\n\ninline int mul(int a, int b, const int &MOD) {\n\treturn int(a * 1ll * b % MOD);\n}\n\ninline ht operator +(const ht &a, const ht &b) {\n\tht ans;\n\tfore(i, 0, sz(ans))\n\t\tans[i] = norm(a[i] + b[i], MOD[i]);\n\treturn ans;\n}\n\ninline ht operator -(const ht &a, const ht &b) {\n\tht ans;\n\tfore(i, 0, sz(ans))\n\t\tans[i] = norm(a[i] - b[i], MOD[i]);\n\treturn ans;\n}\n\ninline ht operator *(const ht &a, const ht &b) {\n\tht ans;\n\tfore(i, 0, sz(ans))\n\t\tans[i] = mul(a[i], b[i], MOD[i]);\n\treturn ans;\n}\n\nint CMODS[] = {int(1e9) + 7, int(1e9) + 9, int(1e9) + 21, int(1e9) + 33, int(1e9) + 87, int(1e9) + 93, int(1e9) + 97, int(1e9) + 103};\nint CBASE[] = {1009, 1013, 1019, 1021};\n\nconst int N = 200 * 1000 + 555;\n\nint n, m;\nchar s[N];\nint x[N], y[N], len[N];\n\ninline bool read() {\n\tif(!(cin >> n >> m))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\t\n\tfore(i, 0, m) {\n\t\tassert(scanf(\"%d%d%d\", &x[i], &y[i], &len[i]) == 3);\n\t\tx[i]--, y[i]--;\n\t}\n\treturn true;\n}\nvoid setMods() {\n\tmt19937 rnd;\n\tunsigned int seed = n;\n\tfore(i, 0, n)\n\t\tseed = (seed * 3) + s[i];\n\tfore(i, 0, m) {\n\t\tseed = (seed * 3) + x[i];\n\t\tseed = (seed * 3) + y[i];\n\t\tseed = (seed * 3) + len[i];\n\t}\n\trnd.seed(seed);\n\t\n\tset<int> mids;\n\twhile(sz(mids) < sz(MOD))\n\t\tmids.insert(rnd() % 8);\n\tvector<int> vmids(mids.begin(), mids.end());\n\tfore(i, 0, sz(MOD)) {\n\t\tMOD[i] = CMODS[vmids[i]];\n\t\tBASE[i] = CBASE[i];\n\t}\n}\n\nht pBase[N];\nht ph[27][N];\nvector<int> ord[N];\n\nht getHash(int id, int l, int r) {\n\treturn ph[id][r] - ph[id][l] * pBase[r - l];\n}\n\ninline void solve() {\n\tsetMods();\n\t\n\tpBase[0] = {1, 1};\n\tfore(i, 1, N)\n\t\tpBase[i] = pBase[i - 1] * BASE;\n\t\t\n\tfore(c, 0, 26) {\n\t\tph[c][0] = {0, 0};\n\t\tfore(i, 0, n) {\n\t\t\tint val = (s[i] == c + 'a');\n\t\t\tph[c][i + 1] = ph[c][i] * BASE + ht{val, val};\n\t\t}\n\t}\n\t\n\tvector<int> curOrd(26, 0);\n\tiota(curOrd.begin(), curOrd.end(), 0);\n\tfor(int i = n - 1; i >= 0; i--) {\n\t\tord[i] = curOrd;\n\t\tauto it = find(ord[i].begin(), ord[i].end(), int(s[i] - 'a'));\n\t\tord[i].erase(it);\n\t\tord[i].insert(ord[i].begin(), int(s[i] - 'a'));\n\t\tcurOrd = ord[i];\n\t}\n\t\n\tfore(q, 0, m) {\n\t\tint s1 = x[q], s2 = y[q];\n\t\tbool ok = true;\n\t\t\n\t\tfore(i, 0, 26) {\n\t\t\tif(getHash(ord[s1][i], s1, s1 + len[q]) != \n\t\t\t\tgetHash(ord[s2][i], s2, s2 + len[q])) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tputs(ok ? \"YES\" : \"NO\");\n\t}\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\tif(read()) {\n\t\tsolve();\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}