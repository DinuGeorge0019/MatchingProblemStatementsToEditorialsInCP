{"link": "https://codeforces.com//contest/808/problem/F", "problemId": "106402", "shortId": "808F", "contest_number": "808", "name": "F. Card Game", "statement": "Digital collectible card games have become very popular recently. So Vova decided to try one of these.Vova has  cards in his collection. Each of these cards is characterised by its power , magic number  and level . Vova wants to build a deck with total power not less than , but magic numbers may not allow him to do so \u2014 Vova can't place two cards in a deck if the sum of the magic numbers written on these cards is a prime number. Also Vova cannot use a card if its level is greater than the level of Vova's character.At the moment Vova's character's level is . Help Vova to determine the minimum level he needs to reach in order to build a deck with the required total power.", "input": "The first line contains two integers  and  (, ). Then  lines follow, each of these lines contains three numbers that represent the corresponding card: ,  and  (, , ).", "output": "If Vova won't be able to build a deck with required power, print . Otherwise print the minimum level Vova has to reach in order to build a deck.", "tutorial": "The most tricky part of the problem is how to check if some set of cards allows us to build a deck with the required power (not taking the levels of cards into account).Suppose we have not more than one card with magic number  (if there are multiple cards with this magic number, then we obviously can use only one of these). Then two cards may conflict only if one of them has an odd magic number, and another has an even magic number \u2014 otherwise their sum is even and not less than , so it's not a prime number.This allows us to solve this problem as follows:Construct a bipartite graph: each vertex represents a card, and two vertices are connected by an edge if the corresponding pair of cards can't be put in a deck. Then we have to find the maximum weight of independent set in this graph. This can be solved using maximum flow algorithm: construct a network where source is connected with every \"odd\" vertex (a vertex that represents a card with an odd magic number) by an edge with capacity equal to the power of this card; then connect every \"odd\" vertex to all \"even\" vertices that are conflicting with this vertex by edges with infinite capacities; and then connect every \"even\" vertex to the sink by an edge with capacity equal to the power of the card (all edges have to be directed). Then the maximum power of the deck is equal to , where  is the sum of all powers and  is the minimum cut value between the source and the sink (which is equal to the maximum flow).This allows us to check if we can build a deck of required power using only some set of cards (for example, only cards with level less than or equal to some ).", "solution": "import java.io.*;\nimport java.util.*;\n\npublic class ER21qF {\n\n\tstatic boolean p[];\n\t\n\tpublic static void main(String[] args) {\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\n\t\tinit();\n\t\t\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\n\t\tCard c[] = new Card[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tc[i] = new Card(in.nextInt(), in.nextInt(), in.nextInt());\n\t\t}\n\t\tArrays.sort(c);\n\n\t\tint start = 0, end = n;\n\t\tint best = -1;\n\t\twhile (start < end) {\n\t\t\tint mid = (start + end) >> 1;\n\t\t\tif (P(c, mid + 1) >= k) {\n\t\t\t\tbest = c[mid].l;\n\t\t\t\tend = mid;\n\t\t\t} else {\n\t\t\t\tstart = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tw.println(best);\n\t\tw.close();\n\t}\n\n\tstatic int P(Card c[], int n) {\n\t\tint max1 = 0;\n\t\tArrayList<Integer> tE = new ArrayList<Integer>();\n\t\tArrayList<Integer> tO = new ArrayList<Integer>();\n\t\tArrayList<Integer> pE = new ArrayList<Integer>();\n\t\tArrayList<Integer> pO = new ArrayList<Integer>();\n\t\t\n\t\tArrayList<Integer> t1E = new ArrayList<Integer>();\n\t\tArrayList<Integer> t1O = new ArrayList<Integer>();\n\t\tArrayList<Integer> p1E = new ArrayList<Integer>();\n\t\tArrayList<Integer> p1O = new ArrayList<Integer>();\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (c[i].c == 1) {\n\t\t\t\tmax1 = Math.max(max1, c[i].p);\n\t\t\t} else if (c[i].c % 2 == 0) {\n\t\t\t\tif (!p[c[i].c + 1]) {\n\t\t\t\t\tt1E.add(c[i].c);\n\t\t\t\t\tp1E.add(c[i].p);\n\t\t\t\t}\n\t\t\t\ttE.add(c[i].c);\n\t\t\t\tpE.add(c[i].p);\n\t\t\t} else {\n\t\t\t\tif (!p[c[i].c + 1]) {\n\t\t\t\t\tt1O.add(c[i].c);\n\t\t\t\t\tp1O.add(c[i].p);\n\t\t\t\t}\n\t\t\t\ttO.add(c[i].c);\n\t\t\t\tpO.add(c[i].p);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Math.max(max1 + flow(t1E, t1O, p1E, p1O), flow(tE, tO, pE, pO));\n\t}\n\t\n\t\n\tstatic int flow(ArrayList<Integer> tE, ArrayList<Integer> tO, ArrayList<Integer> pE, ArrayList<Integer> pO) {\n\t\t\n\t\tint tot = 0;\n\t\tfor (int x : pE)\n\t\t\ttot += x;\n\t\tfor (int x : pO)\n\t\t\ttot += x;\n\t\t\n\t\tint n = 2 + tE.size() + tO.size();\n\t\tMF mf = new MF();\n\t\tmf.init(n);\n\t\t\n\t\tfor (int i = 0; i < tE.size(); i++)\n\t\t\tmf.addEdge(0, i + 1, pE.get(i));\n\t\t\n\t\tfor (int i = 0; i < tO.size(); i++)\n\t\t\tmf.addEdge(tE.size() + 1 + i, n - 1, pO.get(i));\n\t\t\n\t\tint inf = (int)1e9;\n\t\tfor (int i = 0; i < tE.size(); i++) {\n\t\t\tfor (int j = 0; j < tO.size(); j++) {\n\t\t\t\tif(p[tE.get(i) + tO.get(j)]) {\n\t\t\t\t\tmf.addEdge(i + 1, tE.size() + 1 + j, inf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn (int)(tot - mf.maxFlow(0, n - 1));\n\t}\n\n\tstatic void init() {\n\t\tp = new boolean[300100];\n\t\tArrays.fill(p, true);\n\t\tp[0] = p[1] = false;\n\t\tfor (int i = 2; i < p.length; i++) {\n\t\t\tif (p[i]) {\n\t\t\t\tfor (int j = i + i; j < p.length; j += i) {\n\t\t\t\t\tp[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Card implements Comparable<Card> {\n\t\tint p, c, l;\n\n\t\tCard(int p, int c, int l) {\n\t\t\tthis.p = p;\n\t\t\tthis.c = c;\n\t\t\tthis.l = l;\n\t\t}\n\n\t\tpublic int compareTo(Card o) {\n\t\t\treturn Integer.compare(l, o.l);\n\t\t}\n\t}\n\n\tstatic public class MF {\n\n\t\t  long[][] cap;\n\n\t\t  public void init(int nodes) {\n\t\t    cap = new long[nodes][nodes];\n\t\t  }\n\n\t\t  public void addEdge(int s, int t, int capacity) {\n\t\t    cap[s][t] = capacity;\n\t\t  }\n\n\t\t  public long maxFlow(int s, int t) {\n\t\t    int n = cap.length;\n\n\t\t    int[] h = new int[n];\n\t\t    h[s] = n - 1;\n\n\t\t    int[] maxh = new int[n];\n\n\t\t    long[][] f = new long[n][n];\n\t\t    long[] e = new long[n];\n\n\t\t    for (int i = 0; i < n; ++i) {\n\t\t      f[s][i] = cap[s][i];\n\t\t      f[i][s] = -f[s][i];\n\t\t      e[i] = cap[s][i];\n\t\t    }\n\n\t\t    for (int sz = 0;;) {\n\t\t      if (sz == 0) {\n\t\t        for (int i = 0; i < n; ++i)\n\t\t          if (i != s && i != t && e[i] > 0) {\n\t\t            if (sz != 0 && h[i] > h[maxh[0]])\n\t\t              sz = 0;\n\t\t            maxh[sz++] = i;\n\t\t          }\n\t\t      }\n\t\t      if (sz == 0)\n\t\t        break;\n\t\t      while (sz != 0) {\n\t\t        int i = maxh[sz - 1];\n\t\t        boolean pushed = false;\n\t\t        for (int j = 0; j < n && e[i] != 0; ++j) {\n\t\t          if (h[i] == h[j] + 1 && cap[i][j] - f[i][j] > 0) {\n\t\t            long df = Math.min(cap[i][j] - f[i][j], e[i]);\n\t\t            f[i][j] += df;\n\t\t            f[j][i] -= df;\n\t\t            e[i] -= df;\n\t\t            e[j] += df;\n\t\t            if (e[i] == 0)\n\t\t              --sz;\n\t\t            pushed = true;\n\t\t          }\n\t\t        }\n\t\t        if (!pushed) {\n\t\t          h[i] = Integer.MAX_VALUE;\n\t\t          for (int j = 0; j < n; ++j)\n\t\t            if (h[i] > h[j] + 1 && cap[i][j] - f[i][j] > 0)\n\t\t              h[i] = h[j] + 1;\n\t\t          if (h[i] > h[maxh[0]]) {\n\t\t            sz = 0;\n\t\t            break;\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\n\t\t    long flow = 0;\n\t\t    for (int i = 0; i < n; i++)\n\t\t      flow += f[s][i];\n\n\t\t    return flow;\n\t\t  }\t  \n\t}\n\t\n\tstatic class InputReader {\n\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\n\t\tpublic InputReader(InputStream st) {\n\t\t\tthis.stream = st;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t}\n\n}", "interactive": false, "noSolution": false, "noTutorial": false}