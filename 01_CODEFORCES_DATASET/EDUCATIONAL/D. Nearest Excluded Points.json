{"link": "https://codeforces.com//contest/1651/problem/D", "problemId": "1324099", "shortId": "1651D", "contest_number": "1651", "name": "D. Nearest Excluded Points", "statement": "You are given  distinct points on a plane. The coordinates of the -th point are .For each point , find the nearest (in terms of Manhattan distance) point with  that is not among the given  points. If there are multiple such points \u2014 you can choose any of them.The Manhattan distance between two points  and  is .", "input": "The first line of the input contains one integer  () \u2014 the number of points in the set. The next  lines describe points. The -th of them contains two integers  and  () \u2014 coordinates of the -th point. It is guaranteed that all points in the input are distinct.", "output": "Print  lines. In the -th line, print the point with  that is not among the given  points and is the nearest (in terms of Manhattan distance) to the -th point from the input. Output coordinates should be in range . It can be shown that any optimal answer meets these constraints. If there are several answers, you can print any of them.", "tutorial": "Firstly, we can find answers for all points that are adjacent to at least one point not from the set. The distance for such points is obviously  (and this is the smallest possible answer we can get). On the next iteration, we can set answers for all points that are adjacent to points with found answers (because they don't have neighbors not from the set, the distance for them is at least ). It doesn't matter which point we will take, so if the point  is adjacent to some point  that have the answer , we can set the answer for the point  as the answer for the point . We can repeat this process until we find answers for all points. In terms of the code, this can be done by breadth first search (BFS). In other words, we set answers for the points that have the distance  and then push these answers to all adjacent points from the set in order of the increasing distance until we find all the answers.Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {-1, 1, 0, 0};\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n//  freopen(\"output.txt\", \"w\", stdout);\n#endif\n    \n    int n;\n    scanf(\"%d\", &n);\n    vector<pair<int, int>> a(n);\n    for (auto &[x, y] : a) scanf(\"%d %d\", &x, &y);\n    \n    set<pair<int, int>> st(a.begin(), a.end());\n    map<pair<int, int>, pair<int, int>> ans;\n    queue<pair<int, int>> q;\n    for (auto [x, y] : a) {\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (st.count({nx, ny})) {\n                continue;\n            }\n            ans[{x, y}] = {nx, ny};\n            q.push({x, y});\n            break;\n        }\n    }\n    \n    while (!q.empty()) {\n        int x = q.front().first, y = q.front().second;\n        q.pop();\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (!st.count({nx, ny}) || ans.count({nx, ny})) {\n                continue;\n            }\n            ans[{nx, ny}] = ans[{x, y}];\n            q.push({nx, ny});\n        }\n    }\n    \n    for (auto [x, y] : a) {\n        auto it = ans[{x, y}];\n        printf(\"%d %d\\n\", it.first, it.second);\n    }\n    \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}