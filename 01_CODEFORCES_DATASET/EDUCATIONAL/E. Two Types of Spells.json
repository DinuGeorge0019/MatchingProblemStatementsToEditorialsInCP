{"link": "https://codeforces.com//contest/1398/problem/E", "problemId": "699505", "shortId": "1398E", "contest_number": "1398", "name": "E. Two Types of Spells", "statement": "Polycarp plays a computer game (yet again). In this game, he fights monsters using magic spells.There are two types of spells:  spell of power  deals  damage to the monster, and  spell of power  deals  damage to the monster and  the damage of the next spell Polycarp casts. Each spell can be cast , but Polycarp can cast them in any order.For example, suppose that Polycarp knows three spells: a fire spell of power , a lightning spell of power , and a lightning spell of power . There are  ways to choose the order in which he casts the spells:  first, second, third. This order deals  damage;  first, third, second. This order deals  damage;  second, first, third. This order deals  damage;  second, third, first. This order deals  damage;  third, first, second. This order deals  damage;  third, second, first. This order deals  damage. Initially, Polycarp knows  spells. His spell set changes  times, each time he either learns a new spell or forgets an already known one. After each change, calculate the maximum possible damage Polycarp may deal using the spells he knows.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of changes to the spell set. Each of the next  lines contains two integers  and  (; ; ) \u2014 the description of the change. If  if equal to , then Polycarp learns (or forgets) a fire spell, otherwise he learns (or forgets) a lightning spell. If , then Polycarp learns a spell of power . Otherwise, Polycarp forgets a spell with power , and it is guaranteed that he knew that spell before the change. It is guaranteed that the powers of all spells Polycarp knows after each change are different (Polycarp never knows two spells with the same power).", "output": "After each change, print the maximum damage Polycarp can deal with his current set of spells.", "tutorial": "Let's solve this problem for fixed set of spells. For example, we have a fireball spells with powers  and lighting spells with powers . We reach the maximum total damage if we can double all  spells with maximum damage. It's possibly iff the set of  largest by power spell (let's denote this set as ) contains at least one fireball spell. Otherwise (if set  contains only lightning spells) the maximum damage reach when we double  largest spells in set  and one largest spell not from set  (if such spell exist).Now how do you solve the original problem when spells are added and removed? All we have to do it maintain the set of  largest by power spells (where  is current number of lightning spells), and change this set by adding or removing one spell. Also you have to maintain the sum of spells power in set this set and the number of fireball spells in this set. You can do it by  in  or  on .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nint n;\nset <int> sDouble;\nlong long sum[2];\nset <int> s[2];\nint cntDouble[2];\n\n// 0: 0 -> 1\n// 1: 1 -> 0\nvoid upd(int id) {\n    assert(s[id].size() > 0);\n    int x = *s[id].rbegin();\n    if (id == 1) x = *s[id].begin();\n    bool d = sDouble.count(x);\n    \n    sum[id] -= x, sum[!id] += x;\n    s[id].erase(x), s[!id].insert(x);\n    cntDouble[id] -= d, cntDouble[!id] += d;\n}\n\n\nint main(){\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        int tp, x;\n        cin >> tp >> x;// tp = 1 if double\n        \n        if (x > 0) {\n            sum[0] += x;\n            s[0].insert(x);\n            cntDouble[0] += tp;\n            if (tp) sDouble.insert(x);\n        } else {\n            x = -x;\n            int id = 0;\n            if (s[1].count(x)) id = 1;\n            else assert(s[0].count(x));\n            \n            sum[id] -= x;\n            s[id].erase(x);\n            cntDouble[id] -= tp;\n            if (tp) { \n                assert(sDouble.count(x));\n                sDouble.erase(x);\n            }\n        }\n        \n        int sumDouble = cntDouble[0] + cntDouble[1];\n        while (s[1].size() < sumDouble) upd(0);\n        while (s[1].size() > sumDouble) upd(1);\n        while (s[1].size() > 0 && s[0].size() > 0 && *s[0].rbegin() > *s[1].begin()) {\n            upd(0);\n            upd(1);\n        }\n        assert(s[1].size() == sumDouble);\n        \n        long long res = sum[0] + sum[1] * 2;\n        if (cntDouble[1] == sumDouble && sumDouble > 0) {\n            res -= *s[1].begin();\n            if (s[0].size() > 0) res += *s[0].rbegin();\n        }\n        cout << res << endl;\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}