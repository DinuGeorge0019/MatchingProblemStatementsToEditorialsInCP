{"link": "https://codeforces.com//contest/1709/problem/F", "problemId": "1473249", "shortId": "1709F", "contest_number": "1709", "name": "F. Multiset of Strings", "statement": "You are given three integers ,  and .Consider all binary strings (i.\u2009e. all strings consisting of characters  and/or ) of length from  to . For every such string , you need to choose an integer  from  to .A multiset of binary strings of length   is considered beautiful if for every binary string  with length from  to , the number of strings in the multiset such that  is their prefix is not exceeding .For example, let , , , , , , and . The multiset of strings  is beautiful, since:  for the string , there are  strings in the multiset such that  is their prefix, and ;  for the string , there is one string in the multiset such that  is its prefix, and ;  for the string , there are  strings in the multiset such that  is their prefix, and ;  for the string , there is one string in the multiset such that  is its prefix, and ;  for the string , there are  strings in the multiset such that  is their prefix, and ;  for the string , there is one string in the multiset such that  is its prefix, and . Now, for the problem itself. You have to calculate the number of ways to choose the integer  for every binary string  of length from  to  in such a way that the  possible size of a beautiful multiset is  .", "input": "The only line of input contains three integers ,  and  (; ).", "output": "Print one integer \u2014 the number of ways to choose the integer  for every binary string  of length from  to  in such a way that the  possible size of a beautiful multiset is  . Since it can be huge, print it modulo .", "tutorial": "First of all, let's visualize the problem in a different way. We have to set some constraints on the number of strings which have some kind of prefix. Let's think about a data structure that would allow us to understand it better. One of the most common data structures to store strings which works with their prefixes and maintains the number of strings with some prefix is a trie; so, we can reformulate this problem using tries.Now the problem is the following one: we have a binary trie of depth ; the leaves of this trie may store strings, and for each vertex except for the root, we can set a constraint on the number of strings stored in the subtree; what is the number of ways to choose these constraints so that the maximum number of strings (possibly with copies) the trie can store is exactly ? To handle it, we can use dynamic programming of the form  \u2014 the number of ways to choose the constraints for the vertex  and its subtree so that the maximum number of strings which can be stored in the subtree is exactly . When calculating , we can iterate on the constraint for the vertex  (let it be ), and the maximum number of strings in the subtrees of  and  (let these be  and ), and make updates of the form \"add  to the value of \". This dynamic programming will work in  or  depending on the implementation, which is too slow.However, we can use the following optimizations to improve the complexity of the solution:  all vertices on the same depth can be treated as equivalent, so we can actually calculate this dynamic programming not for  vertices, but just for ;  when handling transitions from some node's children to that node, let's split these transitions into two steps. The first step is iterating on the number of strings which fit into the subtrees of the children; the second step is iterating on the constraint for the subtree of the node. The first step is actually a convolution: if we don't consider the constraint for the node itself, then the transitions would be something like \"add  to the value of \"; so it can be improved to  with FFT. The second step can be improved to  as well, if we iterate on the minimum between the constraint for the node and the total number of strings which can be stored in the children, and maintain the sum on suffix for the values of dynamic programming. Overall, these optimizations lead to a solution with complexity .", "solution": "    int wh = 0, cnt = 0;\n    for (char c : s) {\n        if (c == '(')cnt++;\n        if (c == ')')cnt--;\n        if (c == '?')wh++;\n        if (cnt + wh == 1) {\n            cnt = 1;\n            wh = 0;\n        }\n    }\n    if (abs(cnt) == wh) YES\n    else NO", "interactive": false, "noSolution": false, "noTutorial": false}