{"link": "https://codeforces.com//contest/1598/problem/F", "problemId": "1138075", "shortId": "1598F", "contest_number": "1598", "name": "F. RBS", "statement": "A bracket sequence is a string containing only characters \"\" and \"\". A regular bracket sequence (or, shortly, an RBS) is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"\" and \"\" between the original characters of the sequence. For example:  bracket sequences \"\" and \"\" are regular (the resulting expressions are: \"\" and \"\");  bracket sequences \"\", \"\" and \"\" are not. Let's denote the concatenation of two strings  and  as . For example, \"\"\u00a0\u00a0\"\"\u00a0\u00a0\"\".You are given  bracket sequences . You can rearrange them in any order (you can rearrange only the strings themselves, but not the characters in them).Your task is to rearrange the strings in such a way that the string  has as many non-empty prefixes that are RBS as possible.", "input": "The first line contains a single integer  (). Then  lines follow, the -th of them contains \u00a0\u2014 a bracket sequence (a string consisting of characters \"\" and/or \"\". All sequences  are non-empty, their total length does not exceed .", "output": "Print one integer\u00a0\u2014 the maximum number of non-empty prefixes that are RBS for the string , if the strings  can be rearranged arbitrarily.", "tutorial": "The constraint  is a clear hint that we need some exponential solution. Of course, we cannot try all  permutations. Let's instead try to design a solution with bitmask dynamic programming.A string is an RBS if its balance (the difference between the number of opening and closing brackets) is , and the balance of its each prefix is non-negative. So, let's introduce the following dynamic programming:  is the greatest number of RBS-prefixes of a string if we considered a mask  of strings , the current balance of the prefix is , and  is a flag that denotes whether there already has been a prefix with negative balance. We can already get rid of one of the states: the current balance is uniquely determined by the mask . So, this dynamic programming will have  states.To perform transitions, we need to find a way to recalculate the value of  and the answer if we append a new string at the end of the current one. Unfortunately, it's too slow to simply simulate the process. Instead, for every string , let's precalculate the value  \u2014 how does the flag and the answer change, if the current flag is , and the current balance is .The resulting flag will be  in one of the following two cases:   it is already ;  the string we append creates a new prefix with non-positive balance. The second case can be checked as follows: let's precalculate the minimum balance of a prefix of ; let it be . If , the flag will be .Calculating how the answer changes is a bit trickier. If the current flag is already , the answer doesn't change. But if it is , the answer will increase by the number of new RBS-prefixes. If the balance before adding the string  is , then we get a new RBS-prefix for every prefix of  such that:  its balance is exactly  (to compensate the balance we already have);  there is no prefix with balance  in  before this prefix. To quickly get the number of prefixes meeting these constraints, we can create a data structure that stores the following information: for every balance , store a sorted vector of positions in  with balance equal to . Then, to calculate the number of prefixes meeting the constraints, we can find the first position in  with balance equal to  by looking at the beginning of the vector for , and then get the number of elements less than this one from the vector for balance  by binary search.These optimizations yield a solution in , although it's possible to improve to  if you precalculate each value of  for every string . ", "solution": "#include <bits/stdc++.h>     \n\nusing namespace std;\n\nconst int INF = int(1e9);\n\nconst int N = 20;\nconst int M = (1 << N);\n\nstruct BracketSeqn\n{\n \tint balance;\n \tint lowestBalance;\n \tvector<int> queryAns;\n\n \tpair<int, bool> go(int x, bool f)\n \t{\n     \tif(f)\n     \t\treturn make_pair(0, true);\n       \telse\n       \t\treturn make_pair(x < queryAns.size() ? queryAns[x] : 0, x + lowestBalance < 0);\n    }\n\n\tBracketSeqn() {};\n\tBracketSeqn(string s)\n\t{\n\t\tvector<int> bal;\n\t\tint cur = 0;\n\t\tint n = s.size();\n\t\tfor(auto x : s)\n\t\t{\n\t\t \tif(x == '(')\n\t\t \t\tcur++;\n\t\t \telse\t\n\t\t \t\tcur--;\n\t\t \tbal.push_back(cur);\t\n\t\t}\n\t\tbalance = bal.back();\n\t\tlowestBalance = min(0, *min_element(bal.begin(), bal.end()));\n\t\tvector<vector<int>> negPos(-lowestBalance + 1);\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t \tif(bal[i] > 0) continue;\n\t\t \tnegPos[-bal[i]].push_back(i);\n\t\t}\n\t\tqueryAns.resize(-lowestBalance + 1);\n\t\tfor(int i = 0; i < queryAns.size(); i++)\n\t\t{\n\t\t \tint lastPos = int(1e9);\n\t\t \tif(i != -lowestBalance)\n\t\t \t\tlastPos = negPos[i + 1][0];\n\t\t \tqueryAns[i] = lower_bound(negPos[i].begin(), negPos[i].end(), lastPos) - negPos[i].begin();\n\t\t}\n\t};\n};\n\nint dp[M][2];\nchar buf[M];\nint total_bal[M];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<BracketSeqn> bs;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t \tscanf(\"%s\", buf);\n\t \tstring s = buf;\n\t \tbs.push_back(BracketSeqn(s));\n\t}\n\tfor(int i = 0; i < (1 << n); i++)               \n\t \tfor(int j = 0; j < n; j++)\n\t \t\tif(i & (1 << j))\n\t \t\t\ttotal_bal[i] += bs[j].balance;\n\tfor(int i = 0; i < (1 << n); i++)\n\t\tfor(int j = 0; j < 2; j++)\n\t\t\tdp[i][j] = -int(1e9);\n\tdp[0][0] = 0;\n\tfor(int i = 0; i < (1 << n); i++)\n\t\tfor(int f = 0; f < 2; f++)\n\t\t{\n\t\t \tif(dp[i][f] < 0) continue;\n\t\t \tfor(int k = 0; k < n; k++)\n\t\t \t{\n\t\t \t \tif(i & (1 << k)) continue;\n\t\t \t \tpair<int, bool> res = bs[k].go(total_bal[i], f);\n\t\t \t \tdp[i ^ (1 << k)][res.second] = max(dp[i ^ (1 << k)][res.second], dp[i][f] + res.first);\n\t\t \t}\n\t\t}\n\tprintf(\"%d\\n\", max(dp[(1 << n) - 1][0], dp[(1 << n) - 1][1]));\n}", "interactive": false, "noSolution": false, "noTutorial": false}