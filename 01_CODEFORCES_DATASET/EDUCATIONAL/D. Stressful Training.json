{"link": "https://codeforces.com//contest/1132/problem/D", "problemId": "307698", "shortId": "1132D", "contest_number": "1132", "name": "D. Stressful Training", "statement": "Berland SU holds yet another training contest for its students today.  students came, each of them brought his laptop. However, it turned out that everyone has forgot their chargers!Let students be numbered from  to . Laptop of the -th student has charge  at the beginning of the contest and it uses  of charge per minute (i.e. if the laptop has  charge at the beginning of some minute, it becomes  charge at the beginning of the next minute). The whole contest lasts for  minutes.Polycarp (the coach of Berland SU) decided to buy a  charger so that all the students would be able to successfully finish the contest. He buys the charger at the same moment the contest starts.Polycarp can choose to buy the charger with any non-negative (zero or positive) integer power output. The power output is chosen before the purchase, it can't be changed afterwards. Let the chosen power output be .  (from the minute contest starts to the last minute of the contest) he can plug the charger into any of the student's laptops and use it for some  number of minutes. If the laptop is using  charge per minute then it will become  per minute while the charger is plugged in. Negative power usage rate means that the laptop's charge is increasing. The charge of any laptop isn't limited, it can become infinitely large. The charger can be plugged in no more than one laptop at the same time.The student successfully finishes the contest if the charge of his laptop never is below zero at the beginning of some minute (from the minute contest starts to the last minute of the contest, zero charge is allowed). The charge of the laptop of the minute the contest ends doesn't matter.Help Polycarp to determine the minimal possible power output the charger should have so that all the students are able to successfully finish the contest. Also report if no such charger exists.", "input": "The first line contains two integers  and  (, ) \u2014 the number of students (and laptops, correspondigly) and the duration of the contest in minutes. The second line contains  integers  () \u2014 the initial charge of each student's laptop. The third line contains  integers  () \u2014 the power usage of each student's laptop.", "output": "Print a single non-negative integer \u2014 the minimal possible power output the charger should have so that all the students are able to successfully finish the contest. If no such charger exists, print .", "tutorial": "The easiest part of the solution is to notice that if the charger of power  works then the charger of power  also works. Thus, binary search is applicable to the problem. is really small and only one laptop can be charged during some minute. It implies that check function can work in something polynomial on  by searching for the right laptop to charge during every minute.I claim that the greedy algorithm works. Find the laptop that gets his charge below zero the first. Charge it for one minute as early as possible. Repeat until you either don't have time to charge the laptop (check returns false) or the contest is over (check returns true).Why greedy works? Well, check any case where check returns false. If some laptop runs out of power then all the minutes up to the current one are used to charge something. Moreover, you can free no minute of these as by doing greedy we charged all laptops as late as possible. Freeing some minute will lead to other laptop dying earlier.One way to implement this is the following. Keep a heap of events (), pop its head, add  to it if the time is greater than the number of charges already made and push it back to heap. That will simulate the entire process in . Unfortunately, this may be too slow on some implementations.Let's try the following linear approach. Maintain not the heap but such an array that -th its cell contains all indices of all the laptops to run out of charge on the beginning of minute . Keep an iterator to the first non-empty position. Pop a single index out of this vector, charge it and push it to the new position. You'll still make  steps and on each step you'll make  instant operations. That will make it  for this simulation.I'm not really sure how to build the maximal answer case, however, I can estimate the upper bound of binary search. You can set  in such a way that it charges every laptop in one minute so that it won't run out of power until the end of the contest. Choose the smallest , the greatest , the greatest  and you'll end up with  total usage. Thus,  will always be enough.Overall complexity: . (or  if you are skillful enough to squeeze it :D).", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst long long INF64 = 1e18;\n\nint n, k;\nlong long a[N];\nint b[N];\nlong long cur[N];\n\nvector<int> qr[N];\n\nbool check(long long x){\n\tforn(i, k) qr[i].clear();\n\tforn(i, n) cur[i] = a[i];\n\tforn(i, n){\n\t\tlong long t = cur[i] / b[i] + 1;\n\t\tcur[i] %= b[i];\n\t\tif (t < k) qr[t].push_back(i);\n\t}\n\t\n\tint lst = 0;\n\tforn(t, k){\n\t\twhile (lst < k && qr[lst].empty())\n\t\t\t++lst;\n\t\tif (lst <= t)\n\t\t\treturn false;\n\t\tif (lst == k)\n\t\t\treturn true;\n\t\tint i = qr[lst].back();\n\t\tif (cur[i] + x < b[i]){\n\t\t\tcur[i] += x;\n\t\t\tcontinue;\n\t\t}\n\t\tqr[lst].pop_back();\n\t\tlong long nt = (cur[i] + x) / b[i];\n\t\tcur[i] = (cur[i] + x) % b[i];\n\t\tif (lst + nt < k)\n\t\t\tqr[lst + nt].push_back(i);\n\t}\n\t\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tforn(i, n) scanf(\"%lld\", &a[i]);\n\tforn(i, n) scanf(\"%d\", &b[i]);\n\tlong long l = 0, r = INF64;\n\twhile (l < r - 1){\n\t\tlong long m = (l + r) / 2;\n\t\tif (check(m))\n\t\t\tr = m;\n\t\telse\n\t\t\tl = m;\n\t}\n\tif (!check(r))\n\t\tputs(\"-1\");\n\telse\n\t\tprintf(\"%lld\\n\", check(l) ? l : r);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}