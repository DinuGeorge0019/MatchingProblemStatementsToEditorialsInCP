{"link": "https://codeforces.com//contest/1657/problem/D", "problemId": "1339154", "shortId": "1657D", "contest_number": "1657", "name": "D. For Gamers. By Gamers.", "statement": "Monocarp is playing a strategy game. In the game, he recruits a squad to fight monsters. Before each battle, Monocarp has  coins to spend on his squad.Before each battle starts, his squad is empty. Monocarp chooses  and recruits no more units of that type than he can recruit with  coins.There are  types of units. Every unit type has three parameters:   \u00a0\u2014 the cost of recruiting one unit of the -th type;  \u00a0\u2014 the damage that one unit of the -th type deals in a second;  \u00a0\u2014 the amount of health of one unit of the -th type. Monocarp has to face  monsters. Every monster has two parameters:   \u00a0\u2014 the damage that the -th monster deals in a second;  \u00a0\u2014 the amount of health the -th monster has. Monocarp has to fight only the -th monster during the -th battle. He wants all his recruited units to stay alive. Both Monocarp's squad and the monster attack continuously (not once per second) and at the same time. Thus, Monocarp wins the battle if and only if his squad kills the monster strictly faster than the monster kills one of his units. The time is compared with no rounding.For each monster, Monocarp wants to know the minimum amount of coins he has to spend to kill that monster. If this amount is greater than , then report that it's impossible to kill that monster.", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the number of types of units and the amount of coins Monocarp has before each battle. The -th of the next  lines contains three integers  and  (; ). The next line contains a single integer  ()\u00a0\u2014 the number of monsters that Monocarp has to face. The -th of the next  lines contains two integers  and  (; ).", "output": "Print  integers. For each monster, print the minimum amount of coins Monocarp has to spend to kill that monster. If this amount is greater than , then print .", "tutorial": "Imagine you are fighting the -th monster, and you fixed the type of units  and their amount .What's the win condition? . Rewrite it as . Notice how we only care about  for both the units and the monster, but not about  and  on their own.Let's call  and  the power of the squad and the monster.You can see that for each cost  we can only leave one unit type of that price that has the largest value of . Let's call it . Now let's learn to determine the maximum power we can obtain for cost exactly . We can iterate over the cost  of one unit and the count  of units in the squad. Since  should not exceed , that will take . Propagate  to be the maximum power for cost exactly .We have the knowledge about cost exactly , but we actually want no more than . Calculate prefix maximums over \u00a0\u2014 that will be the maximum power we can obtain with no more than  coins.For each monster, we just have to find the smallest  such that . Since the array is monotone, we can use binary search.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nint main(){\n\tint n, C;\n\tscanf(\"%d%d\", &n, &C);\n\tvector<long long> bst(C + 1);\n\tforn(i, n){\n\t\tint c, d, h;\n\t\tscanf(\"%d%d%d\", &c, &d, &h);\n\t\tbst[c] = max(bst[c], d * 1ll * h);\n\t}\n\tfor (int c = 1; c <= C; ++c) for (int xc = c; xc <= C; xc += c)\n\t\tbst[xc] = max(bst[xc], bst[c] * (xc / c));\n\tforn(c, C)\n\t\tbst[c + 1] = max(bst[c + 1], bst[c]);\n\tint m;\n\tscanf(\"%d\", &m);\n\tforn(j, m){\n\t\tint D;\n\t\tlong long H;\n\t\tscanf(\"%d%lld\", &D, &H);\n\t\tint mn = upper_bound(bst.begin(), bst.end(), D * H) - bst.begin();\n\t\tif (mn > C) mn = -1;\n\t\tprintf(\"%d \", mn);\n\t}\n\tputs(\"\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}