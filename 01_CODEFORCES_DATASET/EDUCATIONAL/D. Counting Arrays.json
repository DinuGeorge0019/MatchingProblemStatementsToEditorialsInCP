{"link": "https://codeforces.com//contest/1749/problem/D", "problemId": "1596425", "shortId": "1749D", "contest_number": "1749", "name": "D. Counting Arrays", "statement": "Consider an array  of length  with elements numbered from  to . It is possible to remove the -th element of  if , where  denotes the greatest common divisor. After an element is removed, the elements to the right are shifted to the left by one position.An array  with  integers such that  is a  if it is possible to remove all elements of , if you remove the -th element, then the -th, ..., then the -th element. For example, let :   is a removal sequence: when you remove the -st element of the array, the condition  holds, and the array becomes ; when you remove the -st element again, the condition  holds, and the array becomes empty.   is not a removal sequence: when you try to remove the -nd element, the condition  is false. An array is  if it has  removal sequences. For example, the array  is ambiguous: it has removal sequences  and . The array  is not ambiguous: the only removal sequence it has is .You are given two integers  and . You have to calculate the number of  arrays  such that the length of  is from  to  and each  is an integer from  to .", "input": "The only line of the input contains two integers  and  (; ).", "output": "Print one integer \u2014 the number of ambiguous arrays  such that the length of  is from  to  and each  is an integer from  to . Since the answer can be very large, print it modulo .", "tutorial": "We will calculate the answer by subtracting the number of arrays which have only one removal sequence from the total number of arrays. The latter is very simple \u2014 it's just .How do we calculate the number of unambiguous arrays? We can always delete the -st element of an array; so,  is a removal sequence for each array. So, we have to calculate the number of arrays which have no other removal sequences.How do we check if the array has no removal sequences other than ? If, at any time, it's possible to remove some element other than the -st from the array, it creates another removal sequence since we can always complete that sequence.Let's analyze the constraints on each element of the array.  can be any integer from  to .  should be divisible by  (otherwise, we can remove it on the first step).  should be divisible by  (otherwise, we can remove it on the first step) and by  (otherwise, we can remove it on the second step).  should be divisible by  and , but not necessarily by  since an element which is divisible by  already has a common divisor with . And so on \u2014 using induction, we can show that the -th element should be divisible by , where  are all of the primes in . Obviously, the number of such elements is .So, we can easily calculate the number of possible elements for each index of the array, and that allows us to count all unambiguous arrays.", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    return x;\n}   \n\nint sub(int x, int y)\n{\n    return add(x, -y);\n}   \n\nint mul(int x, int y)\n{\n    return (x * 1ll * y) % MOD;\n}\n\nint binpow(int x, int y)\n{\n    int z = 1;\n    while(y)\n    {\n        if(y & 1) z = mul(z, x);\n        x = mul(x, x);\n        y >>= 1;\n    }\n    return z;\n}\n\nbool prime(int x)\n{\n    for(int i = 2; i * 1ll * i <= x; i++)\n        if(x % i == 0)\n            return false;\n    return true;    \n}\n\nint main()\n{\n    int n;\n    long long m;\n    cin >> n >> m;\n    int ans = 0;\n    for(int i = 1; i <= n; i++)\n        ans = add(ans, binpow(m % MOD, i));\n    long long cur = 1;\n    int cnt = 1;\n    for(int i = 1; i <= n; i++)\n    {\n        if(cur > m) continue;\n        if(prime(i)) cur *= i;\n        cnt = mul(cnt, (m / cur) % MOD);\n        ans = sub(ans, cnt);\n    }\n    cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}