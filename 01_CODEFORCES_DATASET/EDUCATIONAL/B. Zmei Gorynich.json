{"link": "https://codeforces.com//contest/1217/problem/B", "problemId": "404644", "shortId": "1217B", "contest_number": "1217", "name": "B. Zmei Gorynich", "statement": "You are fighting with Zmei Gorynich \u2014 a ferocious monster from Slavic myths, a huge dragon-like reptile with multiple heads!   Initially Zmei Gorynich has  heads. You can deal  types of blows. If you deal a blow of the -th type, you decrease the number of Gorynich's heads by , there  is the current number of heads. But if after this blow Zmei Gorynich has at least one head, he grows  new heads. If  then Gorynich is defeated. For example, if , ,  then the number of heads changes to  (you cut  heads off, but then Zmei grows  new ones), but if , ,  then number of heads changes to  and Zmei Gorynich is considered defeated.Calculate the minimum number of blows to defeat Zmei Gorynich!You have to answer  independent queries.", "input": "The first line contains one integer  () \u2013 the number of queries. The first line of each query contains two integers  and  (, ) \u2014 the number of possible types of blows and the number of heads Zmei initially has, respectively. The following  lines of each query contain the descriptions of types of blows you can deal. The -th line contains two integers  and  () \u2014 the description of the -th blow.", "output": "For each query print the minimum number of blows you have to deal to defeat Zmei Gorynich.  If Zmei Gorynuch cannot be defeated print .", "tutorial": "Lets divide all dealing blows into two parts: the last blow and others blows. The last hit should be with maximum value of .The others blows should be with the maximum value of .So, lets denote  as  and  as .Then if  the we can beat Zmei Gorynich with one blow. Otherwise, if , then we cannot defeat Zmei Gorynich. Otherwise (if  and ) the answer is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 105;\n\nint t;\nint n, m;\nint d[N], h[N];\n\nint main() {\n\tcin >> t;\n\tfor(int tc = 0; tc < t; ++tc){\n\t\tcin >> n >> m;\n\t\tint maxDH = -2e9;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> d[i] >> h[i];\n\t\t\tmaxDH = max(maxDH, d[i] - h[i]);\n\t\t}\n\n\t\tint res = 1;\t\n\t\tint maxD = *max_element(d, d + n);\n\t\tm -= maxD;\n\t\tif(m > 0){\n\t\t\tif(maxDH <= 0) res = -1;\n\t\t\telse res += (m + maxDH - 1) / maxDH; \t\n\t\t}\t\n\t\tcout << res << endl;\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}