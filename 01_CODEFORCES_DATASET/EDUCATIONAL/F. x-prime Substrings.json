{"link": "https://codeforces.com//contest/1400/problem/F", "problemId": "709188", "shortId": "1400F", "contest_number": "1400", "name": "F. x-prime Substrings", "statement": "You are given an integer value  and a string  consisting of digits from  to  inclusive.A substring of a string is a contiguous subsequence of that string.Let  be the sum of digits of a substring .Let's call substring   if   ;  there are no values  such that   ;  ;   is divisible by .  You are allowed to erase some characters from the string. If you erase a character, the two resulting parts of the string are concatenated without changing their order.What is the minimum number of characters you should erase from the string so that there are no  substrings in it? If there are no  substrings in the given string , then print .", "input": "The first line contains a string  ().  contains only digits from  to  inclusive. The second line contains an integer  ().", "output": "Print a single integer\u00a0\u2014 the minimum number of characters you should erase from the string so that there are no  substrings in it. If there are no  substrings in the given string , then print .", "tutorial": "The key observation is that since  is only up to 20, there can't be that many different -prime strings total--turns out there are only about 2400 for the worst case of . So we can generate all of them and perform a DP where our state is represented by the longest prefix of any of the strings we currently match. We can do this by building a trie of all of the -prime strings. We then need to be able to transition around in this trie; it turns out this is exactly what Aho-Corasick does for us. In particular, knowing which node of the Aho-Corasick tree we are currently at gives us the full information we need to determine whether or not we will match one of the strings after adding more characters later. This leads to a fairly simple DP: 90977148\n", "solution": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n// This version of aho_corasick uses more memory and depends on a small alphabet, but it provides O(1) suffix links.\ntemplate<char MIN_CHAR = 'a', int ALPHABET = 26>\nstruct aho_corasick {\n    struct node {\n        // suff = the index of the node of the longest strict suffix of the current node that's also in the tree.\n        //   Also see \"blue arcs\" on Wikipedia: https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm\n        // dict = the index of the node of the longest strict suffix of the current node that's in the word list.\n        //   Also see \"green arcs\" on Wikipedia.\n        // depth = normal trie depth (root is 0). Can be removed to save memory.\n        // word_index = the index of the *first* word ending at this node. -1 if none.\n        // word_count = the total number of words ending at this node. Used in count_total_matches().\n        // link = the trie connections and/or suffix connections from this node.\n        int suff = -1, dict = -1, depth = 0;\n        int word_index = -1, word_count = 0;\n        int link[ALPHABET];\n\n        node() {\n            fill(link, link + ALPHABET, -1);\n        }\n\n        int& operator[](char c) {\n            return link[c - MIN_CHAR];\n        }\n    };\n\n    vector<node> nodes;\n    int W;\n    vector<int> word_location;\n    vector<int> word_indices_by_depth;\n    vector<int> defer;\n\n    aho_corasick(const vector<string> &words = {}) {\n        if (!words.empty())\n            build(words);\n    }\n\n    // Builds the adj list based on suffix parents. Often we want to perform DP and/or queries on this tree.\n    vector<vector<int>> build_suffix_adj() const {\n        vector<vector<int>> adj(nodes.size());\n\n        for (int i = 1; i < int(nodes.size()); i++)\n            adj[nodes[i].suff].push_back(i);\n\n        return adj;\n    }\n\n    int get_or_add_child(int current, char c) {\n        if (nodes[current][c] >= 0)\n            return nodes[current][c];\n\n        int index = int(nodes.size());\n        nodes[current][c] = index;\n        nodes.emplace_back();\n        nodes.back().depth = nodes[current].depth + 1;\n        return index;\n    }\n\n    int add_word(const string &word, int word_index) {\n        assert(!nodes.empty());\n        int current = 0;\n\n        for (char c : word)\n            current = get_or_add_child(current, c);\n\n        if (nodes[current].word_index < 0)\n            nodes[current].word_index = word_index;\n\n        nodes[current].word_count++;\n        return current;\n    }\n\n    // Returns where in the trie we should end up after starting at `location` and adding char `c`. Runs in O(1).\n    int get_suffix_link(int location, char c) const {\n        if (location >= 0)\n            location = nodes[location].link[c - MIN_CHAR];\n\n        return max(location, 0);\n    }\n\n    void build(const vector<string> &words) {\n        nodes = {node()};\n        W = int(words.size());\n        word_location.resize(W);\n        defer.resize(W);\n        int max_depth = 0;\n\n        for (int i = 0; i < W; i++) {\n            word_location[i] = add_word(words[i], i);\n            max_depth = max(max_depth, int(words[i].size()));\n            defer[i] = nodes[word_location[i]].word_index;\n        }\n\n        // Create a list of word indices in decreasing order of depth, in linear time via counting sort.\n        word_indices_by_depth.resize(W);\n        vector<int> depth_freq(max_depth + 1, 0);\n\n        for (int i = 0; i < W; i++)\n            depth_freq[words[i].size()]++;\n\n        for (int i = max_depth - 1; i >= 0; i--)\n            depth_freq[i] += depth_freq[i + 1];\n\n        for (int i = 0; i < W; i++)\n            word_indices_by_depth[--depth_freq[words[i].size()]] = i;\n\n        // Solve suffix parents by traversing in order of depth (BFS order).\n        vector<int> q = {0};\n\n        for (int i = 0; i < int(q.size()); i++) {\n            int current = q[i];\n\n            for (char c = MIN_CHAR; c < MIN_CHAR + ALPHABET; c++) {\n                int &index = nodes[current][c];\n\n                if (index >= 0) {\n                    // Find index's suffix parent by traversing suffix parents of current until one of them has a child c.\n                    int suffix_parent = get_suffix_link(nodes[current].suff, c);\n                    nodes[index].suff = suffix_parent;\n                    nodes[index].word_count += nodes[suffix_parent].word_count;\n                    nodes[index].dict = nodes[suffix_parent].word_index < 0 ? nodes[suffix_parent].dict : suffix_parent;\n                    q.push_back(index);\n                } else {\n                    index = get_suffix_link(nodes[current].suff, c);\n                }\n            }\n        }\n    }\n\n    // Counts the number of matches of each word in O(text length + num words).\n    vector<int> count_matches(const string &text) const {\n        vector<int> matches(W, 0);\n        int current = 0;\n\n        for (char c : text) {\n            current = get_suffix_link(current, c);\n            int dict_node = nodes[current].word_index < 0 ? nodes[current].dict : current;\n\n            if (dict_node >= 0)\n                matches[nodes[dict_node].word_index]++;\n        }\n\n        // Iterate in decreasing order of depth.\n        for (int word_index : word_indices_by_depth) {\n            int location = word_location[word_index];\n            int dict_node = nodes[location].dict;\n\n            if (dict_node >= 0)\n                matches[nodes[dict_node].word_index] += matches[word_index];\n        }\n\n        for (int i = 0; i < W; i++)\n            matches[i] = matches[defer[i]];\n\n        return matches;\n    }\n\n    // Counts the number of matches over all words at each ending position in `text` in O(text length).\n    vector<int> count_matches_by_position(const string &text) const {\n        vector<int> matches(text.size());\n        int current = 0;\n\n        for (int i = 0; i < int(text.size()); i++) {\n            current = get_suffix_link(current, text[i]);\n            matches[i] = nodes[current].word_count;\n        }\n\n        return matches;\n    }\n\n    // Counts the total number of matches of all words within `text` in O(text length).\n    int64_t count_total_matches(const string &text) const {\n        int64_t matches = 0;\n        int current = 0;\n\n        for (char c : text) {\n            current = get_suffix_link(current, c);\n            matches += nodes[current].word_count;\n        }\n\n        return matches;\n    }\n};\n\n\nconst int INF = 1e9 + 5;\n\nint N, X;\nstring S;\nvector<string> prime;\naho_corasick<'1', 9> AC;\n\nbool check(string str) {\n    int n = int(str.size());\n\n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n\n        for (int j = i; j < n; j++) {\n            sum += str[j] - '0';\n\n            if (sum < X && X % sum == 0)\n                return false;\n        }\n    }\n\n    return true;\n}\n\nvoid generate(string str, int sum) {\n    if (sum > X)\n        return;\n\n    if (sum == X) {\n        if (check(str))\n            prime.push_back(str);\n\n        return;\n    }\n\n    for (int d = 1; d <= 9 && sum + d <= X; d++)\n        generate(str + char(d + '0'), sum + d);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    cin >> S >> X;\n    N = int(S.size());\n    generate(\"\", 0);\n    dbg(prime);\n    AC.build(prime);\n    int ST = int(AC.nodes.size());\n    vector<int> dp(ST, INF);\n    dp[0] = 0;\n\n    for (auto &ch : S) {\n        vector<int> next_dp(ST, INF);\n\n        for (int state = 0; state < ST; state++)\n            if (dp[state] < INF) {\n                next_dp[state] = min(next_dp[state], dp[state] + 1);\n                int transition = AC.get_suffix_link(state, ch);\n\n                if (AC.nodes[transition].word_index < 0)\n                    next_dp[transition] = min(next_dp[transition], dp[state]);\n            }\n\n        swap(dp, next_dp);\n    }\n\n    cout << *min_element(dp.begin(), dp.end()) << '\\n';\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}