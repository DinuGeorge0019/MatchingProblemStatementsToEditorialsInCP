{"link": "https://codeforces.com//contest/1400/problem/E", "problemId": "709187", "shortId": "1400E", "contest_number": "1400", "name": "E. Clear the Multiset", "statement": "You have a multiset containing several integers. Initially, it contains  elements equal to ,  elements equal to , ...,  elements equal to .You may apply two types of operations:  choose two integers  and  (), then remove one occurrence of , one occurrence of , ..., one occurrence of  from the multiset. This operation can be applied only if each number from  to  occurs at least once in the multiset;  choose two integers  and  (), then remove  occurrences of  from the multiset. This operation can be applied only if the multiset contains at least  occurrences of . What is the minimum number of operations required to delete all elements from the multiset?", "input": "The first line contains one integer  (). The second line contains  integers , , ...,  ().", "output": "Print one integer \u2014 the minimum number of operations required to delete all elements from the multiset.", "tutorial": "Notice that we can reorder the operations in any way we want without affecting the result. So let's do all of the first-type operations before the second-type operations. Then it's clear that the number of second-type operations we'll need is the number of nonzero elements left over after the first-type operations. So we just want to choose first-type operations to minimize the number of first-type operations plus the number of nonzero elements left after we're done.\nLet's say we have an array  where  is the minimum value (if there is a tie, you can pick any tied index). I only have a messy proof for this at the moment, but it turns out we only need to consider two options: either take all  second-type operations, or use  first-type operations on the entire array and then recursively solve  and  separately. This leads to a simple  solution: 90999997.\nNote that by using RMQ we can improve this to  or even . The idea is very similar to the solution to problem G here.\n", "solution": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nint N;\nvector<int> A;\n\nint solve(int first, int last) {\n    if (first > last)\n        return 0;\n\n    int outside = max(A[first - 1], A[last + 1]);\n    int min_index = int(min_element(A.begin() + first, A.begin() + last + 1) - A.begin());\n    int minimum = A[min_index];\n    return min(last - first + 1, solve(first, min_index - 1) + solve(min_index + 1, last) + minimum - outside);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    cin >> N;\n    A.assign(N + 2, 0);\n\n    for (int i = 1; i <= N; i++)\n        cin >> A[i];\n\n    cout << solve(1, N) << '\\n';\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}