{"link": "https://codeforces.com//contest/1093/problem/F", "problemId": "270227", "shortId": "1093F", "contest_number": "1093", "name": "F. Vasya and Array", "statement": "Vasya has got an array consisting of  integers, and two integers  and  in addition. All numbers in the array are either between  and  (inclusive), or equal to . The array is good if there is no segment of  consecutive  numbers.Vasya will replace each  with some number from  to  (inclusive) in such a way that the resulting array is good. Tell him the number of ways to do this replacement. Since the answer may be large, print it modulo .", "input": "The first line contains three integers  and  (). The second line contains  numbers \u2014 the array. Each number is either  or between  and  (inclusive).", "output": "Print one integer \u2014 the number of ways to replace each  with some number from  to  (inclusive) so the array is good. The answer may be large, so print it modulo .", "tutorial": "Let's try dynamic programming approach to this problem. Let  be the number of ways to replace all  with numbers from  to  in such a way that array  is good and the last number of that array is .Let .Then initially it's  if  equals to  or . However, we could include incorrect states \u2014 such that segment  consist of the same value. It happens when:  , as we should have at least  elements;  segment  has all its elements either equal to  or . If both of these conditions hold then you should subtract all the bad states from . The number of them is .", "solution": "#include <bits/stdc++.h>\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); ++i)\n#define forn(i, n) fore(i, 0, n)\n#define nfor(i, n) for(int i = int(n) - 1; i >= 0; --i)\n#define for1(i, n) for(int i = 1; i < int(n); ++i)\n\n#define mp make_pair\n#define pb push_back\n#define sz(a) int((a).size())\n#define all(a) (a).begin(), (a).end()\n#define x first\n#define y second\n\n#define correct(x, y, xmax, ymax) ((x) >= 0 && (x) < (xmax) && (y) >= 0 && (y) < (ymax))\n#define max(a, b) ((a > b)? a : b)\n#define min(a, b) ((a < b)? a : b)\n#define abs(a) ((a < 0) ? -a : a)\n#define sqr(a) (a * a)\n\nusing namespace std;\n\nconst int N = int(1e5);\nconst int M = 105;\nconst int MOD = 998244353;\n\nint sum(int a, int b){\n\treturn (a + b) % MOD;\t\n}\n\nint n, k, len;\nint a[N];\nint dp[N][M];\nint sumdp[N];\nint cnt[M][N];\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &k, &len);\n\tforn(i, n){ \t\n\t\tscanf(\"%d\", a + i);\n\t\tif(a[i] != -1) --a[i];\n\t}\n    forn(i, k) \n        forn(j, n)\n            cnt[i][j + 1] = cnt[i][j] + (a[j] == i || a[j] == -1);\n            \n\tforn(i, n){ \n\t\tforn(j, k){\n\t\t\tif(!(a[i] == -1 || a[i] == j))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint add = 1;\n\t\t\tif(i > 0) add = sumdp[i - 1];\n\t\t\tdp[i][j] = add;\n\t\t\t\n\t\t\tbool ok = i + 1 >= len;\n\t\t\tint l = max(0, i - len + 1);\n\t\t\tint r = i + 1;\n\t\t\tok &= (r - l == cnt[j][r] - cnt[j][l]); \n\t\t\tif(!ok) continue;\n\t\t\t\n\t\t\tif(i + 1 == len){\n\t\t\t\tdp[i][j] = sum(dp[i][j], MOD - 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tadd = sum(dp[i - len][j], MOD - sumdp[i - len]);\n\t\t\tdp[i][j] = sum(dp[i][j], add);\n\t\t}\n\t\tforn(j, k) sumdp[i] = sum(sumdp[i], dp[i][j]);\n\t}\n\t\n\tprintf(\"%d\\n\", sumdp[n - 1]);\n\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}