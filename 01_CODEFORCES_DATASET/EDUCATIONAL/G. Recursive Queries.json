{"link": "https://codeforces.com//contest/1117/problem/G", "problemId": "300047", "shortId": "1117G", "contest_number": "1117", "name": "G. Recursive Queries", "statement": "You are given a permutation . You should answer  queries. Each query is a pair , and you should calculate .Let's denote  as the position of the maximum in subsegment .Then  if  or  otherwise.", "input": "The first line contains two integers  and  (, ) \u2014 the size of the permutation  and the number of queries. The second line contains  pairwise distinct integers  (,  for ) \u2014 permutation . The third line contains  integers  \u2014 the first parts of the queries. The fourth line contains  integers  \u2014 the second parts of the queries. It's guaranteed that  for all queries.", "output": "Print  integers \u2014 the values  for the corresponding queries.", "tutorial": "Let's denote  and, analogically, . Then, we can note that . So we can switch to calculating  (and ).Let's  be the closest from the left to  element such that . To calculate  we will look from the other side: we will look at it as the sum of lengths of segments induced by each element from . Each element  ( will add to  value equal to , or a piecewise linear function if we look at  as a variable. And  is a value of a sum of linear functions induced by  in a point .To process it efficiently we can one by one add induced linear functions to the corresponding subsegments using BIT or Segment Tree and if we've added functions induced by  we can calculate answer for all queries which looks like .To calculate  we can just reverse array and all queries.Result time complexity is . Note, that it's still works quite slow, so you should use fast data structures like BIT of iterative segment tree.", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\nint n, q;\nvector<int> a;\nvector< pair<pt, int> > qs;\n\ninline bool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\ta.resize(n);\n\tqs.resize(q);\n\t\n\tfore(i, 0, n)\n\t\tcin >> a[i];\n\tfore(i, 0, q) {\n\t\tcin >> qs[i].x.x;\n\t\tqs[i].x.x--;\n\t}\n\tfore(i, 0, q) {\n\t\tcin >> qs[i].x.y;\n\t\tqs[i].x.y--;\n\t\tqs[i].y = i;\n\t}\n\treturn true;\n}\n\nbool cmp(const pair<pt, int> &a, const pair<pt, int> &b) {\n\tif(a.x.y != b.x.y)\n\t\treturn a.x.y < b.x.y;\n\tif(a.x.x != b.x.x)\n\t\treturn a.x.x < b.x.x;\n\treturn a.y < b.y;\n}\n\ntypedef pair<li, li> func;\nfunc operator +=(func &a, const func &b) {\n\ta.x += b.x, a.y += b.y;\n\treturn a;\n}\n\nvector<func> t;\nvoid add(int l, int r, const func &f) {\n\tfor(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n\t\tif(l & 1) t[l++] += f;\n\t\tif(r & 1) t[--r] += f;\n\t}\n}\nfunc sum(int pos) {\n\tfunc ans(0, 0);\n\tfor(pos += n; pos > 0; pos >>= 1)\n\t\tans += t[pos];\n\treturn ans;\n}\n\ninline void solve() {\n\tvector<li> ans(q, 0);\n\tfore(i, 0, q)\n\t\tans[i] = qs[i].x.y - qs[i].x.x + 1;\n\tfore(_, 0, 2) {\n\t\tvector<int> st;\n\t\tvector<int> lf(n, -1);\n\t\tfore(i, 0, n) {\n\t\t\twhile(!st.empty() && a[st.back()] < a[i])\n\t\t\t\tst.pop_back();\n\t\t\tif(!st.empty())\n\t\t\t\tlf[i] = st.back();\n\t\t\tst.push_back(i);\n\t\t}\n\t\t\n\t\tsort(qs.begin(), qs.end(), cmp);\n\t\tt.assign(2 * n, {0, 0});\n\t\t\n\t\tint uk = 0;\n\t\tfore(i, 0, n) {\n\t\t\tadd(0, lf[i] + 1, {0, i - lf[i] - 1});\n\t\t\tadd(lf[i] + 1, i, {-1, i});\n\t\t\t\n\t\t\twhile(uk < q && qs[uk].x.y == i) {\n\t\t\t\tauto f = sum(qs[uk].x.x);\n\t\t\t\tans[qs[uk].y] += f.x * qs[uk].x.x + f.y;\n\t\t\t\tuk++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treverse(a.begin(), a.end());\n\t\tfor(auto &p : qs) {\n\t\t\tp.x.x = n - 1 - p.x.x;\n\t\t\tp.x.y = n - 1 - p.x.y;\n\t\t\tswap(p.x.x, p.x.y);\n\t\t}\n\t}\n\tfor(auto v : ans)\n\t\tcout << v << ' ';\n\tcout << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}