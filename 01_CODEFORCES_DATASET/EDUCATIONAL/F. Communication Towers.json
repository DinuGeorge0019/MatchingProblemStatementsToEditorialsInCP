{"link": "https://codeforces.com//contest/1814/problem/F", "problemId": "1867161", "shortId": "1814F", "contest_number": "1814", "name": "F. Communication Towers", "statement": "There are  communication towers, numbered from  to , and  bidirectional wires between them. Each tower has a certain set of frequencies that it accepts, the -th of them accepts frequencies from  to .Let's say that a tower  is accessible from a tower , if there exists a frequency  and a sequence of towers , where consecutive towers in the sequence are directly connected by a wire, and each of them accepts frequency . Note that accessibility is not transitive, i.\u2009e if  is accessible from  and  is accessible from , then  may not be accessible from .Your task is to determine the towers that are accessible from the -st tower.", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the number of communication towers and the number of wires, respectively. Then  lines follows, the -th of them contains two integers  and  ()\u00a0\u2014 the boundaries of the acceptable frequencies for the -th tower. Then  lines follows, the -th of them contains two integers  and  (; )\u00a0\u2014 the -th wire that connects towers  and . There are no two wires connecting the same pair of towers.  ", "output": "In a single line, print distinct integers from  to  in ascending order\u00a0\u2014 the indices of the communication towers that are accessible from the -st tower.", "tutorial": "Let's consider the sweep line approach by the value of the variable $$$x$$$; the vertex $$$i$$$ is active from the moment $$$l_i$$$ to the moment $$$r_i$$$. And we have to find vertices that are reachable in the graph of active vertices from the vertex $$$1$$$. So, we rephrased the problem as follows: there are vertices that are active at some moments, and we want to get some information about connectivity during each moment of time. This is a standard offline dynamic connectivity problem which can be solved with a divide-and-conquer approach described here.Now we are able to find the connectivity component of the $$$1$$$-th vertex for each value of $$$x$$$. It remains to understand how to combine answers for all values of $$$x$$$ fast enough. Let's try to visualize the components as vertices of a directed graph. We assign a vertex to each component, and when two components merge, we add two directed edges from the new vertex to the vertices corresponding to the components; and now we can use the reachability information in this graph. Each vertex of the original graph corresponds to one of the sinks in this graph; and sinks that correspond to the vertices of some component are reachable from the vertex corresponding to that component. To restore all the vertex indices later, we will mark all components containing the vertex $$$1$$$ while we run our dynamic connectivity approach. Then the vertex $$$v$$$ (of the original graph) is included in the answer if the vertex representing the component containing only the vertex $$$v$$$ is reachable from any of the marked vertices. Now, all you need to do is run DFS or BFS from all the marked vertices in the component graph.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(a) int((a).size())\n\nconst int N = 200002;\nconst int V = 50 * N;\n\nusing pt = pair<int, int>;\n\nint n, m;\npt a[N];\nvector<pt> t[4 * N];\nint p[N], rk[N], vs[N];\nint cntV;\npt g[V];\nbool ans[V];\n\nvoid upd(int v, int l, int r, int L, int R, pt e) {\n  if (L >= R) return;\n  if (l == L && r == R) {\n    t[v].push_back(e);\n    return;\n  }\n  int m = (l + r) / 2;\n  upd(v * 2 + 1, l, m, L, min(m, R), e);\n  upd(v * 2 + 2, m, r, max(m, L), R, e);\n}\n\nint k;\nint* ptr[V];\nint val[V];\n\nvoid upd(int &a, int b) {\n  ptr[k] = &a;\n  val[k] = a;\n  k += 1;\n  a = b;\n}\n\nint getp(int v) {\n  return p[v] == v ? v : getp(p[v]);\n}\n\nvoid unite(int v, int u) {\n  v = getp(v), u = getp(u);\n  if (v == u) return;\n  if (rk[v] > rk[u]) swap(v, u);\n  upd(p[v], u);\n  g[cntV] = {vs[v], vs[u]};\n  upd(vs[u], cntV++);\n  if (rk[v] == rk[u])\n    upd(rk[u], rk[u] + 1);\n}\n\nvoid solve(int v, int l, int r) {\n  int cur = k;\n  for (auto& [v, u] : t[v]) \n    unite(v, u);\n  if (l + 1 == r) {\n    ans[vs[getp(0)]] = 1;\n  } else {\n    int m = (l + r) / 2;\n    solve(v * 2 + 1, l, m);\n    solve(v * 2 + 2, m, r);\n  }\n  while (k > cur) {\n    k -= 1;\n    (*ptr[k]) = val[k];\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  \n  cin >> n >> m;\n  for (int i = 0; i < n; ++i)\n    cin >> a[i].first >> a[i].second;\n  for (int i = 0; i < m; ++i) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    int L = max(a[x].first, a[y].first);\n    int R = min(a[x].second, a[y].second);\n    upd(0, 0, N, L, R + 1, {x, y});\n  }\n  \n  for (int i = 0; i < n; ++i) {\n    p[i] = i;\n    rk[i] = 1;\n    vs[i] = i;\n    g[i] = {-1, -1};\n  }\n  \n  cntV = n;\n  solve(0, 0, N);\n  \n  queue<int> q;\n  for (int i = 0; i < cntV; ++i) if (ans[i]) \n    q.push(i);\n  \n  while (!q.empty()) {\n    int v = q.front(); q.pop();\n    for (int u : {g[v].first, g[v].second}) {\n      if (u != -1 && !ans[u]) {\n        ans[u] = true;\n        q.push(u);\n      }\n    }\n  }\n  \n  for (int i = 0; i < n; ++i) if (ans[i])\n    cout << i + 1 << ' ';\n}", "interactive": false, "noSolution": false, "noTutorial": false}