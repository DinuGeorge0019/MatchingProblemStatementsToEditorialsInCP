{"link": "https://codeforces.com//contest/1598/problem/G", "problemId": "1138076", "shortId": "1598G", "contest_number": "1598", "name": "G. The Sum of Good Numbers", "statement": "Let's call a positive integer  if there is no digit  in its decimal representation.For an array of a  numbers , one found out that the sum of some two neighboring elements is equal to  (i.e.  for some ).  had turned out to be a  number as well.Then the elements of the array  were written out one after another without separators into one string . For example, if , then .You are given a string  and a number . Your task is to determine the positions in the string that correspond to the adjacent elements of the array that have sum . If there are several possible answers, you can print any of them.", "input": "The first line contains the string  (). The second line contains an integer  (). An additional constraint on the input: the answer always exists, i.e you can always select two adjacent substrings of the string  so that if you convert these substrings to integers, their sum is equal to .", "output": "In the first line, print two integers , , meaning that the first term of the sum () is in the string  from position  to position . In the second line, print two integers , , meaning that the second term of the sum () is in the string  from position  to position .", "tutorial": "Let's denote  as the largest of the terms of the sum, and  is the smaller one.Consider  cases:  or .If , then . So we need to find two consecutive substrings of length  such that if we convert these substrings into integers, their sum is equal to .If , let  be the largest common prefix of  and  if we consider them as strings. Then  or . So it is necessary to check only these two cases, and whether  goes before or after  (in the string ).Thus, we have reduced the number of variants where the substrings for  and  are located to . It remains to consider how to quickly check whether the selected substrings are suitable. To do this, you can use hashes (preferably with several random modules).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int MOD[] = { 597804841, 618557587, 998244353 };\nconst int N = 500 * 1000 + 13;\nconst int K = 3;\n\nusing hs = array<int, K>;\n\nint add(int x, int y, int mod) {\n  x += y;\n  if (x >= mod) x -= mod;\n  if (x < 0) x += mod;\n  return x;\n}\n\nint mul(int x, int y, int mod) {\n  return x * 1LL * y % mod;\n}\n\nhs get(const int& x) {\n  hs c;\n  forn(i, K) c[i] = x;\n  return c;\n}\n\nhs operator +(const hs& a, const hs& b) { \n  hs c;\n  forn(i, K) c[i] = add(a[i], b[i], MOD[i]);\n  return c;\n}\n\nhs operator -(const hs& a, const hs& b) {\n  hs c;\n  forn(i, K) c[i] = add(a[i], -b[i], MOD[i]);\n  return c; \n}\n\nhs operator *(const hs& a, const hs& b) {\n  hs c;\n  forn(i, K) c[i] = mul(a[i], b[i], MOD[i]);\n  return c; \n}\n\nint n, m;\nstring s, sx;\nhs sum[N], pw[N];\n\nhs get(int l, int r) {\n  return sum[r] - sum[l] * pw[r - l];\n}\n\nvector<int> zfunction(const string& s) {\n  int n = s.size();\n  vector<int> z(n);\n  int l = 0, r = 0;\n  for (int i = 1; i < n; ++i) {\n    if (i <= r) z[i] = min(z[i - l], r - i + 1);\n    while (i + z[i] < n && s[z[i]] == s[i + z[i]])\n      ++z[i];\n    if (i + z[i] - 1 > r) {\n      l = i;\n      r = i + z[i] - 1;\n    }\n  }\n  return z;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL); \n  \n  cin >> s >> sx;\n  n = s.size();\n  m = sx.size();\n  \n  pw[0] = get(1);\n  forn(i, N - 1) pw[i + 1] = pw[i] * get(10); \n  sum[0] = get(0);\n  forn(i, n) sum[i + 1] = sum[i] * get(10) + get(s[i] - '0'); \n  hs x = get(0);\n  forn(i, m) x = x * get(10) + get(sx[i] - '0');\n  \n  if (m > 1) for (int i = 0; i + 2 * (m - 1) <= n; ++i) {\n    if (get(i, i + m - 1) + get(i + m - 1, i + 2 * (m - 1)) == x) {\n      cout << i + 1 << ' ' << i + m - 1 << '\\n';\n      cout << i + m << ' ' << i + 2 * (m - 1) << '\\n';\n      return 0;\n    }\n  }\n  \n  auto z = zfunction(sx + \"#\" + s);\n  \n  for (int i = 0; i + m <= n; ++i) {\n    int lcp = z[m + i + 1];\n    for (int len = m - lcp - 1; len <= m - lcp; ++len) {\n      if (len < 1) continue;\n      if (i + m + len <= n && get(i, i + m) + get(i + m, i + m + len) == x) {\n        cout << i + 1 << ' ' << i + m << '\\n';\n        cout << i + m + 1 << ' ' << i + m + len << '\\n';\n        return 0;\n      }\n      if (i >= len && get(i - len, i) + get(i, i + m) == x) {\n        cout << i - len + 1 << ' ' << i << '\\n';\n        cout << i + 1 << ' ' << i + m << '\\n';\n        return 0;\n      }\n    }\n  }\n  \n  assert(false);\n}", "interactive": false, "noSolution": false, "noTutorial": false}