{"link": "https://codeforces.com//contest/1626/problem/F", "problemId": "1263152", "shortId": "1626F", "contest_number": "1626", "name": "F. A Random Code Problem", "statement": "You are given an integer array , and an integer . You perform the following code with it:Your task is to calculate the expected value of the variable  after performing this code.Note that the input is generated according to special rules (see the input format section).", "input": "The only line contains six integers , , , ,  and  (; ; ). The array  in the input is constructed as follows:    is given in the input;  for every  from  to , the value of  can be calculated as . ", "output": "Let the expected value of the variable  after performing the code be . It can be shown that  is an integer. You have to output this integer modulo .", "tutorial": "I think it's easier to approach this problem using combinatorics instead of probability theory methods, so we'll calculate the answer as \"the sum of values of  over all ways to choose the index on each iteration of the loop\".If a number  is chosen on the iteration  of the loop, then it is reduced to the maximum number divisible by  that doesn't exceed the initial value. So, if a number is divisible by all integers from  to , i.\u2009e. divisible by , it won't be changed in the operation. Furthermore, if , then the value of this element won't become less than .It means that we can interpret each number  as , where  and . The part with  will always be added to the variable  when this element is chosen, so let's add  to the answer (which is the contribution of  over all ways to choose the indices in the operations), and work with  instead of .Now all elements of the array are less than . We can use this constraint by writing the following dynamic programming to solve the problem:  is the number of appearances of the integer  in the array  over all ways to choose the indices for the first  iterations.For ,  is just the number of occurrences of each integer in the array . The transitions from  are the following ones:  if this element is chosen in the operation, then it becomes , and we transition to the state ;  otherwise, the element is unchanged, and we transition to the state , multiplying the current value by , which is the number of ways to choose some other element in the operation. How can we use this dynamic programming to get the answer? On the -th iteration, the number of times we choose the integer  is exactly , and the number of ways to use the integers in the next operations is , so we add  to the answer for every such state .This solution runs in time , which may be too slow if not implemented carefully. Fortunately, we have an easy way to optimize it: use  instead of , which divides  by  in the worst case scenario for our solution. We can do this because even if an integer is changed on the -th operation, we are not interested in this change since this is the last operation.", "solution": "#include <bits/stdc++.h>     \n\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int L = 720720;\n\nint add(int x, int y, int m = MOD)\n{\n    x += y;\n    if(x >= m) x -= m;\n    return x;\n}\n\nint mul(int x, int y, int m = MOD)\n{\n    return (x * 1ll * y) % m;\n}\n\nint binpow(int x, int y)\n{\n    int z = 1;\n    while(y > 0)\n    {\n        if(y % 2 == 1) z = mul(z, x);\n        x = mul(x, x);\n        y /= 2;\n    }\n    return z;\n}\n\nint inv(int x)\n{\n    return binpow(x, MOD - 2);\n}\n\nint divide(int x, int y)\n{\n    return mul(x, inv(y));\n}\n\nint main()\n{\n    int n, a0, x, y, k, M;\n    cin >> n >> a0 >> x >> y >> k >> M;\n    vector<int> arr(n);\n    arr[0] = a0;\n    for(int i = 1; i < n; i++)\n        arr[i] = add(mul(arr[i - 1], x, M), y, M);\n    int ans = 0;\n    int total_ways = binpow(n, k);\n    int coeff = mul(divide(total_ways, n), k);\n    vector<vector<int>> dp(k, vector<int>(L));\n    for(int i = 0; i < n; i++)\n    {\n        int p = arr[i] / L;\n        int q = arr[i] % L;\n        dp[0][q]++;\n        ans = add(ans, mul(p, mul(L, coeff)));\n    }\n    int cur_coeff = divide(total_ways, n);\n    for(int i = 1; i <= k; i++)\n    {\n        for(int j = 0; j < L; j++)\n        {\n            int cur = dp[i - 1][j];\n            if(i < k)\n                dp[i][j] = add(dp[i][j], mul(n - 1, cur));\n            ans = add(ans, mul(j, mul(cur, cur_coeff)));\n            if(i < k)\n                dp[i][j - (j % i)] = add(dp[i][j - (j % i)], cur);\n        }\n        cur_coeff = divide(cur_coeff, n);\n    }\n    cout << ans << endl;        \n}", "interactive": false, "noSolution": false, "noTutorial": false}