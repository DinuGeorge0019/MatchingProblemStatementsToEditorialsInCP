{"link": "https://codeforces.com//contest/665/problem/B", "problemId": "55549", "shortId": "665B", "contest_number": "665", "name": "B. Shopping", "statement": "Ayush is a cashier at the shopping center. Recently his department has started a ''\" service which allows users to shop online. The store contains  items.  customers have already used the above service. Each user paid for  items. Let  denote the -th item in the -th person's order.Due to the space limitations all the items are arranged in one single row. When Ayush receives the -th order he will find one by one all the items  () in the row. Let  denote the position of the item  in the row at the moment of its collection. Then Ayush takes time equal to  for the -th customer.When Ayush accesses the -th element he keeps a new stock in the front of the row and takes away the -th element. Thus the values are updating.Your task is to calculate the total time it takes for Ayush to process all the orders.You can assume that the market has endless stock.", "input": "The first line contains three integers ,  and  () \u2014 the number of users, the number of items each user wants to buy and the total number of items at the market. The next line contains  distinct integers  () denoting the initial positions of the items in the store. The items are numbered with integers from  to . Each of the next  lines contains  distinct integers  () \u2014 the order of the -th person.", "output": "Print the only integer  \u2014 the total time needed for Ayush to process all the orders.", "tutorial": "In this problem you should simply do what was written in the problem statement. There are no tricks.\n", "solution": "const int N = 111;\n\nint n, m, k;\nint p[N];\nint a[N][N];\n\nbool read() {\n\tif (!(cin >> n >> m >> k)) return false;\n\tforn(i, k) {\n\t\tassert(scanf(\"%d\", &p[i]) == 1);\n\t\tp[i]--;\n\t}\n\tforn(i, n)\n\t\tforn(j, m) {\n\t\t\tassert(scanf(\"%d\", &a[i][j]) == 1);\n\t\t\ta[i][j]--;\n\t\t}\n\treturn true;\n}\n\nvoid solve() {\n\tint ans = 0;\n\tforn(i, n)\n\t\tforn(j, m) {\n\t\t\tint pos = int(find(p, p + k, a[i][j]) - p);\n\t\t\tans += pos + 1;\n\t\t\tnfor(l, pos) p[l + 1] = p[l];\n\t\t\tp[0] = a[i][j];\n\t\t}\n\tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}