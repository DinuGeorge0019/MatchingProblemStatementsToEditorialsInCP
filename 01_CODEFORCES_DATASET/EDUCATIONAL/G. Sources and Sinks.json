{"link": "https://codeforces.com//contest/1036/problem/G", "problemId": "216423", "shortId": "1036G", "contest_number": "1036", "name": "G. Sources and Sinks", "statement": "You are given an acyclic directed graph, consisting of  vertices and  edges. The graph contains no multiple edges and no self-loops.The vertex is called a  if it has no incoming edges. The vertex is called a  if it has no outgoing edges. These definitions imply that some vertices can be both source and sink.The number of sources in the given graph is equal to the number of sinks in it, and each of these numbers doesn't exceed .The following algorithm is applied to the graph:  if the graph has no sources and sinks then quit;  choose arbitrary source , arbitrary sink , add an edge from  to  to the graph and go to step  (that operation pops  out of sources and  out of sinks). Note that  and  may be the same vertex, then a self-loop is added. At the end you check if the graph becomes strongly connected (that is, any vertex is reachable from any other vertex).Your task is to check that the graph becomes strongly connected no matter the choice of sources and sinks on the second step of the algorithm.", "input": "The first line contains two integers  and  () \u2014 the number of vertices and the number of edges in the graph, respectively. Each of the next  lines contains two integers  (, ) \u2014 the description of the -th edge of the original graph. It is guaranteed that the number of sources and the number of sinks in the graph are the same and they don't exceed . It is guaranteed that the given graph contains no multiple edges. It is guaranteed that the graph contains no cycles.", "output": "Print \"\" if the graph becomes strongly connected no matter the choice of sources and sinks on the second step of the algorithm. Otherwise print \"\".", "tutorial": "Since the graph is acyclic, then for every vertex there exists a path to some sink, and to every vertex there exists a path from some source. So our problem can be reduced to the following: check that after running our algorithm, all vertices from the initial set of sources and sinks belong to the same strongly connected component. Let  be the number of sources (or sinks) in the initial graph.First of all, let's run DFS (or any other graph traversal) from every source to form a set of reachable sinks for every source. This part of solution has complexity of .If  is some set of sources of the original graph, let  be the set of sinks such that every sink from  is reachable from at least one source from . It's easy to see that there exists some set  such that ,  and , then the answer is  \u2014 if we connected the sinks from  with the sources from , then any sink not belonging to  would be unreachable from any sink belonging to . Checking every possible set  can be done in  or in .Let's prove that there is no such set , then the answer is . Let  be an arbitrary sink of the original graph. Also, if  is some set of sinks, let  be the set of sources containing every source directly connected to some sink from . We can use mathematical induction to prove that every source and every sink is reachable from  in the resulting graph:  Initially we state that  is reachable from  (quite obvious);  If there is a set of sinks  reachable from , then either  (and the whole graph is reachable from ), or the number of sinks reachable from  is at least , so some set of  sinks is reachable from . So in fact checking every possible subset of sources is enough.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1000043;\n\nvector<int> g[N];\nvector<int> gt[N];\nvector<int> src;\nvector<int> snk;\nint reach[20];\nint used[N];\n\nvoid dfs(int x)\n{\n    if(used[x]) return;\n    used[x] = 1;\n    for(auto y : g[x]) dfs(y);\n}\n\nint main()\n{\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    for(int i = 0; i < m; i++)\n    {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        --x;\n        --y;\n        g[x].push_back(y);\n        gt[y].push_back(x);\n    }\n    for(int i = 0; i < n; i++)\n    {\n        if(g[i].empty())\n            snk.push_back(i);\n        if(gt[i].empty())\n            src.push_back(i);\n    }\n    int cnt = src.size();\n    for(int i = 0; i < cnt; i++)\n    {\n        memset(used, 0, sizeof used);\n        dfs(src[i]);\n        for(int j = 0; j < cnt; j++)\n            if(used[snk[j]])\n                reach[i] ^= (1 << j);\n    }\n    bool ok = true;\n    for(int mask = 0; mask < (1 << cnt); mask++)\n    {\n        int res = 0;\n        for(int j = 0; j < cnt; j++)\n            if(mask & (1 << j))\n                res |= reach[j];\n        int cnt1 = __builtin_popcount(mask);\n        int cnt2 = __builtin_popcount(res);\n        if(cnt2 < cnt1 || (cnt2 == cnt1 && cnt1 != 0 && cnt1 != cnt))\n            ok = false;\n    }\n    if(!ok)\n        puts(\"NO\");\n    else\n        puts(\"YES\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}