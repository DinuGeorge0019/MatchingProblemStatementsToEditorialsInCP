{"link": "https://codeforces.com//contest/1051/problem/E", "problemId": "222361", "shortId": "1051E", "contest_number": "1051", "name": "E. Vasya and Big Integers", "statement": "Vasya owns three big integers \u2014 . Let's define a partition of  such a sequence of strings  that , where  is a concatanation of strings.  is the -th element of the partition. For example, number  has the following partitions: [\"\", \"\", \"\", \"\", \"\"], [\"\", \"\", \"\"], [\"\", \"\"], [\"\"] and lots of others.Let's call some partition of   if each of its elements .Vasya want to know the number of  partitions of number , which has each of  satisfy the condition . Note that the comparison is the integer comparison, not the string one.Help Vasya to count the amount of partitions of number  such that they match all the given requirements. The result can be rather big, so print it modulo .", "input": "The first line contains a single integer . The second line contains a single integer . The third line contains a single integer . . It is also guaranteed that numbers  .", "output": "Print a single integer \u2014 the amount of partitions of number  such that they match all the given requirements modulo .", "tutorial": "Let's use dynamic programming to solve the problem. Let  be the number of correct partitions for the long integer . It's easy to see that if we have two big integers without leading zeroes, we know the lengths of these integers, and these lengths are not equal, then we can determine which integer is greater in . We will calculate the answers in the following order: . Suppose we want to calculate .Let  be the minimum position such that the number  meets the following condition: .Let  be the maximum position such that the number  meets the following condition .Initially let's consider  \u0438 .  will be less if .  will be less if . To determine which of the numbers  and  is greater let's calculate z-function for the string , where  is any character that doesn't occur in  and . After calculating z-function we can easily find the first non-equal character in  and , and this character will determine which number is greater. To compare  and  we can act the same.All that's left is to set  to the sum of  values from  to . This can be done by maintaining suffix sums.There is a corner case, which applies when . If , then  because we cannot afford any leading zeroes. Otherwise .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(a) (int)(a.size())\n\nconst int N = int(1e6) + 9;\nconst int MOD = 998244353;\n\nint n;\nstring s, l, r;\nint dp[N];\nint sumDP[N];\n\nint sum(int a, int b){\n\ta += b;\n\tif(a >= MOD) a -= MOD;\n\treturn a;\n}\n\nvector <int> z_function(string s){\n\tint n = sz(s);\n\tvector <int> z(n);\n\tfor(int i = 1, l = 0, r = 0; i < n; ++i){\n\t\tif(i <= r)\n\t\t\tz[i] = min(r - i + 1, z[i - l]);\n\t\twhile(i + z[i] < n && s[z[i]] == s[i + z[i]])\n\t\t\t++z[i];\n\t\tif(i + z[i] - 1 > r)\n\t\t\tl = i,  r = i + z[i] - 1;\n\t}\n\treturn z;\n}\n\n//s[pos..] ? t\nchar cmp(vector <int> &zf, string &t, int pos){\n\tint len = sz(t);\n\tassert(pos + len + 1 < sz(zf));\n\tif(sz(s) - pos < len) return '<';\n\t\n\tint x = zf[len + 1 + pos];\n\tassert(x <= len);\n\tif(x == len) return '=';\n\tassert(pos + x < sz(s));\n\tassert(s[pos + x] != t[x]);\n\tif(s[pos + x] < t[x]) return '<';\n\treturn '>';\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n\tcin >> s >> l >> r;\n\tn = int(s.size());\n\tvector <int> zl = z_function(l + \"#\" + s);\n\tvector <int> zr = z_function(r + \"#\" + s);\n\t\n\tsumDP[n] = dp[n] = 1;\n\tfor(int i = n - 1; i >= 0; --i){\n\t\tif(s[i] == '0'){\n\t\t\tif(l == \"0\") dp[i] = dp[i + 1];\t\t\n\t\t\telse dp[i] = 0;\n\t\t\tsumDP[i] = sum(dp[i], sumDP[i + 1]);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint L = sz(l) + i;\n\t\tchar cl = cmp(zl, l, i);\n\t\tif(cl == '<') ++L;\n\t\t\n\t\tint R = sz(r) + i;\n\t\tchar cr = cmp(zr, r, i);\n\t\tif(cr == '>') --R;\n\n\t \tint cur = 0;\n\t \tif(L <= R && L <= n){\n\t \t\tR = min(R, n);\n\t \t\tcur = sumDP[L];\n\t \t\tif(R != n) cur = sum(cur, MOD - sumDP[R + 1]);\n\t \t}\n\t \tdp[i] = cur;\n\t \tsumDP[i] = sum(dp[i], sumDP[i + 1]);\n\t}\n\t\n\tcout << dp[0] << endl;\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}