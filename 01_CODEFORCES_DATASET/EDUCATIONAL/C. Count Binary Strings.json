{"link": "https://codeforces.com//contest/1767/problem/C", "problemId": "1697002", "shortId": "1767C", "contest_number": "1767", "name": "C. Count Binary Strings", "statement": "You are given an integer . You have to calculate the number of binary (consisting of characters  and/or ) strings  meeting the following constraints.For every pair of integers  such that , an integer  is given. It imposes the following constraint on the string :  if , all characters in  should be the same;  if , there should be at least two different characters in ;  if , there are no additional constraints on the string . Count the number of binary strings  of length  meeting the aforementioned constraints. Since the answer can be large, print it modulo .", "input": "The first line contains one integer  (). Then  lines follow. The -th of them contains  integers  ().", "output": "Print one integer \u2014 the number of strings meeting the constraints, taken modulo .", "tutorial": "Suppose we build the string from left to right, and when we place the $$$i$$$-th character, we ensure that all substrings  are valid. What do we need to know in order to calculate the number of different characters in the string ending with the $$$i$$$-th character?Suppose the character $$$s_i$$$ is . Let's try going to the left of it. The string from $$$i$$$ to $$$i$$$ will have the same characters; but if there is at least one character  before the $$$i$$$-th position, the string $$$s_1 s_2 s_3 \\dots s_i$$$ will have two different characters. What about the strings in the middle? The string $$$s_j s_{j+1} \\dots s_i$$$ will contain different characters if and only if there is at least one  in $$$[j, i)$$$ (since $$$s_i$$$ is ), so we are actually interested in the position of the last character  before $$$i$$$.The same logic applies if the character $$$s_i$$$ is : we are only interested in the position of the last  before $$$i$$$, and it is enough to check if all substrings ending with the $$$i$$$-th character are violated.What if when we choose the $$$i$$$-th character, we violate some substring that doesn't end in the $$$i$$$-th position? Well, you could also check that... or you could just ignore it. Actually, it doesn't matter if this happens because it means that the substring that is violated ends in some position $$$k > i$$$; and we will check it when placing the $$$k$$$-th character.So, the solution can be formulated with the following dynamic programming: let $$$dp_{i,j}$$$ be the number of ways to choose the first $$$i$$$ characters of the string so that the last character different from $$$s_i$$$ was $$$s_j$$$ (or $$$j = 0$$$ if there was no such character), and all the constraints on the substrings ending no later than position $$$i$$$ are satisfied. The transitions are simple: you either place the same character as the last one (going from $$$dp_{i,j}$$$ to $$$dp_{i+1,j}$$$), or a different character (going from $$$dp_{i,j}$$$ to $$$dp_{i+1,i}$$$); and when you place a character, you check all the constraints on the substrings ending with the $$$i$$$-th position. Note that the state $$$dp_{1,0}$$$ is actually represented by two strings:  and .This solution works in $$$O(n^3)$$$, although $$$O(n^4)$$$ or $$$O(n^2)$$$ implementations are also possible.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    return x;\n}\n\nint mul(int x, int y)\n{\n    return (x * 1ll * y) % MOD;\n}\n\nconst int N = 143;\nint n;\n\nint a[N][N];\nint dp[N][N];\n\nbool check(int cnt, int last)\n{\n    for(int i = 0; i < cnt; i++)\n    {\n        if(a[i][cnt - 1] == 0) continue;\n        if(a[i][cnt - 1] == 1 && last > i) return false;\n        if(a[i][cnt - 1] == 2 && last <= i) return false;\n    }\n    return true;\n}\n\nint main()\n{\n    cin >> n;\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = i; j < n; j++)\n            cin >> a[i][j];\n    }\n    if(a[0][0] != 2) dp[1][0] = 2;\n    for(int i = 1; i < n; i++)\n        for(int j = 0; j < i; j++)\n            for(int k : vector<int>({j, i}))\n                if(check(i + 1, k))\n                    dp[i + 1][k] = add(dp[i + 1][k], dp[i][j]);\n    int ans = 0;\n    for(int i = 0; i < n; i++)\n        ans = add(ans, dp[n][i]);\n    cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}