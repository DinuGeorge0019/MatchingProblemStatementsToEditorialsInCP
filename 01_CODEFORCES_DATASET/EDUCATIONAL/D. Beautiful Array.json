{"link": "https://codeforces.com//contest/1155/problem/D", "problemId": "334464", "shortId": "1155D", "contest_number": "1155", "name": "D. Beautiful Array", "statement": "You are given an array  consisting of  integers. Beauty of array is the maximum sum of some  of this array (this subarray may be empty). For example, the beauty of the array  is , and the beauty of the array  is .You may choose  of  and multiply all values contained in this subarray by . You want to maximize the beauty of array after applying at most one such operation.", "input": "The first line contains two integers  and  () \u2014 the length of array  and the integer  respectively. The second line contains  integers  () \u2014 the array .", "output": "Print one integer \u2014 the maximum possible beauty of array  after multiplying all values belonging to some consecutive subarray .", "tutorial": "The first intuitive guess one's probably made is multiplying the segment of maximum sum for positive . That thing is correct. Unfortunately, there is no similar strategy for non-positive , simple greedy won't work there.Thus, dynamic programming is our new friend. Let's introduce the following state: , where  is the length of the currently processed prefix,  is the state of maximum sum segment ( is not reached, it'll appear later,  is open, current elements are added to it,  is passed, the segment appeared earlier) and  is the state of segment multiplied by  with the same values. This  will store the maximum segment sum we can achieve.The only base state is  \u2014 the prefix of length  is processed and both segments are not open yet. The rest of values in  are .There are two main transitions. At any moment we can change the state of each segment to the next one without moving to the next position. From state  (not reached) we can go to state  (opened) and from state  we can go to state  (passed). Note that this easily covers the case where optimal segment is empty. We can also move to the next position updating the value of  with correspondance to the current states of segments.The answer will be stored in  \u2014 the state where all the array is processed and both segments are closed.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n\ntypedef long long li;\n\nconst int N = 300 * 1000 + 13;\nconst li INF64 = 1e18;\n\nint n, x;\nint a[N];\n\nli dp[N][3][3];\n\nint main() {\n\tscanf(\"%d%d\", &n, &x);\n\tforn(i, n) scanf(\"%d\", &a[i]);\n\t\n\tforn(i, n + 1) forn(j, 3) forn(k, 3)\n\t\tdp[i][j][k] = -INF64;\n\t\n\tdp[0][0][0] = 0;\n\tforn(i, n + 1) forn(j, 3) forn(k, 3){\n\t\tif (k < 2)\n\t\t\tdp[i][j][k + 1] = max(dp[i][j][k + 1], dp[i][j][k]);\n\t\tif (j < 2)\n\t\t\tdp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k]);\n\t\tif (i < n)\n\t\t\tdp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k] + (j == 1 ? a[i] : 0) * li(k == 1 ? x : 1));\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[n][2][2]);\n}", "interactive": false, "noSolution": false, "noTutorial": false}