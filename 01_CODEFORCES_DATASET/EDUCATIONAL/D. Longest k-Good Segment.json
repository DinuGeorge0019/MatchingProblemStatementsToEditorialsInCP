{"link": "https://codeforces.com//contest/616/problem/D", "problemId": "45347", "shortId": "616D", "contest_number": "616", "name": "D. Longest k-Good Segment", "statement": "The array  with  integers is given. Let's call the sequence of one or more consecutive elements in  . Also let's call the segment - if it contains no more than  different values.Find any longest -good segment.As the input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use  instead of  in C++, prefer to use  instead of  in .", "input": "The first line contains two integers  () \u2014 the number of elements in  and the parameter . The second line contains  integers  () \u2014 the elements of the array .", "output": "Print two integers  () \u2014 the index of the left and the index of the right ends of some -good longest segment. If there are several longest segments you can print any of them. The elements in  are numbered from  to  from left to right.", "tutorial": "This problem is given because on the Codeforces pages we often see questions like \"What is the method of the two pointers?\". This problem is a typical problem that can be solved using two pointers technique.\nLet's find for each left end  the maximal right end  that  is a -good segment. Note if  is a -good segment then  is also a -good segment. So the search of the maximal right end for  we can start from the maximal right end for . The only thing that we should do is to maintain in the array  for each number  the number of it's occurrences in the current segment  and the number of different numbers in . We should move the right end until the segment became bad and then move the left end. Each of the ends ,  will be moved exactly  times.\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nconst int N = 1200300;\n\u00a0\nint n, k;\nint a[N];\n\u00a0\ninline bool read() {\n\u00a0 \u00a0 if (!(cin >> n >> k)) return false;\n\u00a0 \u00a0 forn(i, n) assert(scanf(\"%d\", &a[i]) == 1);\n\u00a0 \u00a0 return true;\n}\n\u00a0\nint cur;\nint cnt[N];\n\u00a0\ninline void add(int x) {\n\u00a0 \u00a0 if (++cnt[x] == 1) cur++;\n}\n\u00a0\ninline void rem(int x) {\n\u00a0 \u00a0 if (--cnt[x] == 0) cur--;\n}\n\u00a0\ninline void solve() {\n\u00a0 \u00a0 cur = 0;\n\u00a0 \u00a0 memset(cnt, 0, sizeof(cnt));\n\u00a0\n\u00a0 \u00a0 int al = -1, ar = -1;\n\u00a0 \u00a0 int p = 0;\n\u00a0 \u00a0 forn(i, n) {\n\u00a0 \u00a0 \u00a0 \u00a0 while (p < n) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 add(a[p]);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (cur > k) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 rem(a[p]);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p++;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 if (ar - al < p - i) al = i, ar = p;\n\u00a0 \u00a0 \u00a0 \u00a0 rem(a[i]);\n\u00a0 \u00a0 \u00a0 \u00a0 //cerr << i << ' ' << p << endl;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 assert(al != -1);\n\u00a0 \u00a0 cout << al + 1 << ' ' << ar << endl;\n}\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 solve();\n\u00a0 \u00a0 \u00a0 \u00a0 //break;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}