{"link": "https://codeforces.com//contest/616/problem/E", "problemId": "45348", "shortId": "616E", "contest_number": "616", "name": "E. Sum of Remainders", "statement": "Calculate the value of the sum:    +    +    + ... +   . As the result can be very large, you should print the value modulo  (the remainder when divided by ).The modulo operator    stands for the remainder after dividing  by . For example    = .", "input": "The only line contains two integers  () \u2014 the parameters of the sum.", "output": "Print integer  \u2014 the value of the required sum modulo .", "tutorial": "Unfortunately my solution for this problem had overflow bug. It was fixed on contest. Even so I hope you enjoyed the problem because I think it's very interesting.\nLet's transform the sum . Note that the last sum can be accumulated to only value , because for  all the values will be equal to .\nNote in the last sum either  or . Let's carefully accumulate both cases. The first sum can be simply calculated by iterating over all . We will accumulate the second sum independently for all different values . Firstly we should determine for which values  we will have the value . Easy to see that for the values  from the interval . Also we can note that the sum of the second factors in  with fixed first factor can be calculaed in constant time \u2014 it's simply a sum of arithmetic progression . So we have solution with complexity .\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nli n, m;\n\u00a0\ninline bool read() {\n\u00a0 \u00a0 return !!(cin >> n >> m);\n}\n\u00a0\nconst li mod = INF + 7;\n\u00a0\ninline void normal(li& a) {\n\u00a0 \u00a0 a %= mod;\n\u00a0 \u00a0 (a < 0) && (a += mod);\n}\n\u00a0\ninline li mul(li a, li b) {\n\u00a0 \u00a0 a %= mod, b %= mod;\n\u00a0 \u00a0 normal(a), normal(b);\n\u00a0 \u00a0 return (a * b) % mod;\n}\n\u00a0\ninline li add(li a, li b) {\n\u00a0 \u00a0 a %= mod, b %= mod;\n\u00a0 \u00a0 normal(a), normal(b);\n\u00a0 \u00a0 return (a + b) % mod;\n}\n\u00a0\ninline li sub(li a, li b) {\n\u00a0 \u00a0 a %= mod, b %= mod;\n\u00a0 \u00a0 normal(a), normal(b);\n\u00a0 \u00a0 a -= b;\n\u00a0 \u00a0 normal(a);\n\u00a0 \u00a0 return a;\n}\n\u00a0\ninline li sum(li n) { return mul(mul(n, n + 1), (mod + 1) / 2); }\ninline li sum(li lf, li rg) { return sub(sum(rg), sum(lf - 1)); }\n\u00a0\ninline li calcDiv(li n, li m) {\n\u00a0 \u00a0 m = min(m, n);\n\u00a0\n\u00a0 \u00a0 li ans = 0;\n\u00a0 \u00a0 li minVal = m;\n\u00a0 \u00a0 for (li i = 1; i * i <= n; i++) {\n\u00a0 \u00a0 \u00a0 \u00a0 li lf = n / (i + 1), rg = n / i;\n\u00a0 \u00a0 \u00a0 \u00a0 rg = min(rg, m);\n\u00a0 \u00a0 \u00a0 \u00a0 if (lf >= rg) continue;\n\u00a0 \u00a0 \u00a0 \u00a0 minVal = lf; // interval (lf, rg]\n\u00a0 \u00a0 \u00a0 \u00a0 ans = add(ans, mul(i, sum(lf + 1, rg)));\n\u00a0 \u00a0 }\n\u00a0 \u00a0 fore(i, 1, minVal + 1) {\n\u00a0 \u00a0 \u00a0 \u00a0 ans = add(ans, mul(n / i, i));\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return ans;\n}\n\u00a0\ninline li calcMod(li n, li m) {\n\u00a0 \u00a0 li ans = mul(n, m);\n\u00a0 \u00a0 ans = sub(ans, calcDiv(n, m));\n\u00a0 \u00a0 return ans;\n}\n\u00a0\ninline void solve() {\n\u00a0 \u00a0 cout << calcMod(n, m) << endl;\n}\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 solve();\n\u00a0 \u00a0 \u00a0 \u00a0 //break;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 cerr << clock() / ld(CLOCKS_PER_SEC) << endl;\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}