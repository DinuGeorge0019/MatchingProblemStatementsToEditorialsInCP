{"link": "https://codeforces.com//contest/1156/problem/D", "problemId": "338451", "shortId": "1156D", "contest_number": "1156", "name": "D. 0-1-Tree", "statement": "You are given a tree (an undirected connected acyclic graph) consisting of  vertices and  edges. A number is written on each edge, each number is either  (let's call such edges -edges) or  (those are -edges).Let's call an ordered pair of vertices  ()  if, while traversing the simple path from  to , we never go through a -edge after going through a -edge. Your task is to calculate the number of  pairs in the tree.", "input": "The first line contains one integer  () \u2014 the number of vertices in the tree. Then  lines follow, each denoting an edge of the tree. Each edge is represented by three integers ,  and  (, , ) \u2014 the vertices connected by this edge and the number written on it, respectively. It is guaranteed that the given edges form a tree.", "output": "Print one integer \u2014 the number of  pairs of vertices.", "tutorial": "Let's divide all valid pairs into three categories: the ones containing only -edges on the path, the ones containing only -edges, and the ones containing both types of edges.To calculate the number of pairs containing only -edges, we may build a forest on the vertices of the original graph and -edges, and choose all pairs of vertices belonging to the same connected components of this forest (we can find all connected components with DSU or any graph traversal algorithm). The same can be done for the pairs containing only -edges.If a path from  to  is valid and contains both types of edges, then there exists a vertex  such that the simple path from  to  goes only through -edges, and the simple path from  to  goes only through -edges. So, let's iterate on this vertex , and choose some other vertex from its component in -graph as , and some other vertex from its component in -graph as , and add the number of ways to choose them to the answer.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint p[2][N];\nint siz[2][N];\n\nint get(int x, int c)\n{\n\tif(p[c][x] == x)\n\t\treturn x;\n\treturn p[c][x] = get(p[c][x], c);\n}\n\nvoid merge(int x, int y, int c)\n{\n\tx = get(x, c);\n\ty = get(y, c);\n\tif(siz[c][x] < siz[c][y])\n\t\tswap(x, y);\n\tp[c][y] = x;\n\tsiz[c][x] += siz[c][y];\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tp[0][i] = p[1][i] = i;\n\t\tsiz[0][i] = siz[1][i] = 1;\n\t}\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y, c;\n\t\tscanf(\"%d %d %d\", &x, &y, &c);\n\t\t--x;\n\t\t--y;\n\t\tmerge(x, y, c);\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(p[0][i] == i)\n\t\t\tans += siz[0][i] * 1ll * (siz[0][i] - 1);\n\t\tif(p[1][i] == i)\n\t\t\tans += siz[1][i] * 1ll * (siz[1][i] - 1);\n\t\tans += (siz[0][get(i, 0)] - 1) * 1ll * (siz[1][get(i, 1)] - 1);\n\t}\n\tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}