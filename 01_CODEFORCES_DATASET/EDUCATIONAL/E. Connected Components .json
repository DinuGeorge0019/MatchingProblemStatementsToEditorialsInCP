{"link": "https://codeforces.com//contest/920/problem/E", "problemId": "152865", "shortId": "920E", "contest_number": "920", "name": "E. Connected Components ", "statement": "You are given an undirected graph consisting of  vertices and  edges. Instead of giving you the edges that exist in the graph, we give you  unordered pairs () such that there is no edge between  and , and if some pair of vertices is not listed in the input, then there is an edge between these vertices.You have to find the number of connected components in the graph and the size of each component. A connected component is a set of vertices  such that for every two vertices from this set there exists at least one path in the graph connecting these vertices, but adding any other vertex to  violates this rule.", "input": "The first line contains two integers  and  (, ). Then  lines follow, each containing a pair of integers  and  (, ) denoting that  between  and . Each pair is listed at most once; () and () are considered the same (so they are never listed in the same test). If some pair of vertices is not listed in the input, then there  an edge between those vertices. ", "output": "Firstly print  \u2014 the number of connected components in this graph. Then print  integers \u2014 the sizes of components. You should output these integers in non-descending order.", "tutorial": "Let  be the set of unvisited vertices. To store it, we will use some data structure that allows us to do the following:   \u2014 insert some value  into the set;   \u2014 delete  from the set;   \u2014 find the smallest integer  from the set such that .For example,  from  allows us to do all these operations fastly. Also we can use this structure to store the adjacency lists.We will use a modified version of depth-first-search. When we are entering a vertex with , we erase it from the set of unvisited vertices. The trick is that in  we will iterate over the set of unvisited vertices using its  function. And we will make not more than  iterations overall because when we skip an unvisited vertex, that means there is no edge from this vertex to the vertex we are currently traversing in , so there will be no more than  skips; and each iteration we don't skip decreases the number of unvisited vertices.", "solution": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nset <pii> Sx;\nvector <int> conn[200050];\n\nbool pchk[200050];\n\nint lc = 1;\nvector <int> Vl[200050];\n\nint r[200050];\nint sz[200050];\nint root(int x) {\n\treturn (x == r[x]) ? x : (r[x] = root(r[x]));\n}\nint main() {\n\tint N, M, i, j;\n\tscanf(\"%d %d\", &N, &M);\n\tfor (i = 1; i <= M; i++) {\n\t\tint t1, t2;\n\t\tscanf(\"%d %d\", &t1, &t2);\n\t\tSx.emplace(t1, t2);\n\t\tSx.emplace(t2, t1);\n\t\tconn[t1].push_back(t2);\n\t\tconn[t2].push_back(t1);\n\t}\n\n\tint p = 1;\n\tfor (i = 2; i <= N; i++) if (conn[i].size() < conn[p].size()) p = i;\n\tfor (auto it : conn[p]) pchk[it] = true;\n\tfor (i = 1; i <= N; i++) if (!pchk[i]) Vl[1].push_back(i);\n\tfor (i = 1; i <= N; i++) {\n\t\tif (!pchk[i]) continue;\n\t\tlc++;\n\t\tVl[lc].push_back(i);\n\t}\n\n\tfor (i = 1; i <= lc; i++) r[i] = i;\n\tfor (i = 1; i <= lc; i++) {\n\t\tfor (j = i + 1; j <= lc; j++) {\n\t\t\tbool chk = false;\n\t\t\tfor (auto it1 : Vl[i]) {\n\t\t\t\tfor (auto it2 : Vl[j]) {\n\t\t\t\t\tif (Sx.count(pii(it1, it2))) continue;\n\t\t\t\t\tchk = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chk) r[root(i)] = root(j);\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (i = 1; i <= lc; i++) sz[root(i)] += Vl[i].size();\n\n\tvector <int> Va;\n\tfor (i = 1; i <= lc; i++) if (r[i] == i) Va.push_back(sz[i]);\n\tsort(all(Va));\n\n\tprintf(\"%d\\n\", (int)Va.size());\n\tfor (auto it : Va) printf(\"%d \", it);\n\treturn !printf(\"\\n\");\n}\n//*/", "interactive": false, "noSolution": false, "noTutorial": false}