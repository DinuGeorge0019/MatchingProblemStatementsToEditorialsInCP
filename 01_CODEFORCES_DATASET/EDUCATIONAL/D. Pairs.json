{"link": "https://codeforces.com//contest/1463/problem/D", "problemId": "836004", "shortId": "1463D", "contest_number": "1463", "name": "D. Pairs", "statement": "You have  integers . You have to redistribute these  elements into  pairs. After that, you choose  pairs and take minimum elements from them, and from the other  pairs, you take maximum elements.Your goal is to obtain the set of numbers  as the result of taking elements from the pairs.What is the number of different -s () such that it's possible to obtain the set  if for each  you can choose how to distribute numbers into pairs and from which  pairs choose minimum elements?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains the integer  (). The second line of each test case contains  integers  ()\u00a0\u2014 the set you'd like to get. It's guaranteed that the sum of  over test cases doesn't exceed .", "output": "For each test case, print one number\u00a0\u2014 the number of different -s such that it's possible to obtain the set .", "tutorial": "Let's prove that in the set   minimum elements will be from  pairs where we'll take minimums and analogically  maximums will be from  pairs where we'll take maximums. By contradiction, let's look at two pairs  () and  (), where we will take maximum from  and minimum from  and , if we swap elements  and  and get pair , , the result won't change, but now minimum from pair  will be less than maximum from . So we can always make pairs in such a way that the chosen minimum from any pair will be less than the chosen maximum from any other pair.Let's make set  as all elements which are not in . In the same way, we can prove that  minimums of  are from pairs where we took maximums and  maximums are from pairs where we took minimums.Let's say  and  are sorted. Now we've proven that for a fixed  we should pair  with  and  with . It's not hard to prove that it's optimal to pair , , ...,  and in the same way , , ..., .For a fixed  we can just check that constructed pairs are valid. But what happens if we move from  to ? If for  all  was valid then for  all pairs  will be valid as well. And on contrary, if at least one pair  wasn't valid then for  the pair  won't be valid as well.Due to monotony we can find the maximum valid  just checking only pairs  and in the same way we can find maximum  (minimum ) such that all pairs  are valid. That's why all valid -s form a segment, and we need to find its borders.We can find a maximum  (maximum ) with either binary search or with two pointers and print the length of the segment. Time complexity is either  or .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\nconst int INF = int(1e9);\n\nint n;\nvector<int> b;\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\tb.resize(n);\n\tfore (i, 0, n)\n\t\tcin >> b[i];\n\treturn true;\n}\n\nbool ok(const vector<int> &a, const vector<int> &b, int cnt) {\n\tfore (i, 0, cnt) {\n\t\tif (a[i] >= b[sz(b) - cnt + i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\ninline void solve() {\n\tvector<int> nb;\n\tfore (i, 1, 2 * n + 1) {\n\t\tif (!binary_search(b.begin(), b.end(), i))\n\t\t\tnb.push_back(i);\n\t}\n\t\n\tint mx[2] = {-1, -1};\n\tfore (k, 0, 2) {\n\t\tint lf = 0, rg = n + 1;\n\t\twhile (rg - lf > 1) {\n\t\t\tint mid = (lf + rg) / 2;\n\t\t\tif (ok(b, nb, mid))\n\t\t\t\tlf = mid;\n\t\t\telse\n\t\t\t\trg = mid;\n\t\t}\n\t\tmx[k] = lf;\n\t\tif (!ok(nb, b, n - lf)) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn;\n\t\t}\n\t\tswap(b, nb);\n\t}\n\t\n\tassert(n - mx[1] <= mx[0]);\n\tcout << mx[0] - (n - mx[1]) + 1 << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tint t; cin >> t;\n\twhile(t--) {\n\t    read();\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}