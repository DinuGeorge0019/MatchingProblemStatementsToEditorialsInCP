{"link": "https://codeforces.com//contest/888/problem/B", "problemId": "133215", "shortId": "888B", "contest_number": "888", "name": "B. Buggy Robot", "statement": "Ivan has a robot which is situated on an infinite grid. Initially the robot is standing in the starting cell . The robot can process commands. There are four types of commands it can perform:   \u2014 move from the cell  to ;   \u2014 move from  to ;   \u2014 move from  to ;   \u2014 move from  to . Ivan entered a sequence of  commands, and the robot processed it. After this sequence the robot ended up in the starting cell , but Ivan doubts that the sequence is such that after performing it correctly the robot ends up in the same cell. He thinks that some commands were ignored by robot. To acknowledge whether the robot is severely bugged, he needs to calculate the maximum possible number of commands that were performed correctly. Help Ivan to do the calculations!", "input": "The first line contains one number  \u2014 the length of sequence of commands entered by Ivan (). The second line contains the sequence itself \u2014 a string consisting of  characters. Each character can be , ,  or .", "output": "Print the maximum possible number of commands from the sequence the robot could perform to end up in the starting cell.", "tutorial": "Consider the final cell after original path. It has some distance  to  and  to . That means the path included at least  and  in corresponding directions. Let's remove just these minimal numbers of moves.Finally, the answer will be , where  are distances from the final cell of the original path to .Overall complexity: .", "solution": "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nvoid sleep( double sec = 1021 ){\n  clock_t s = clock();\n  while( clock() - s < CLOCKS_PER_SEC * sec );\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nvoid build(){\n\n}\n#define N 111\nchar c[ N ];\nint n;\nvoid init(){\n  cin >> n >> c;\n}\nvoid solve(){\n  int a = 0 , b = 0;\n  for( int i = 0 ; c[ i ] ; i ++ )\n    if( c[ i ] == 'L' ) a ++;\n    else if( c[ i ] == 'R' ) a --;\n    else if( c[ i ] == 'D' ) b ++;\n    else b --;\n  cout << n - ( abs( a ) + abs( b ) ) << endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}