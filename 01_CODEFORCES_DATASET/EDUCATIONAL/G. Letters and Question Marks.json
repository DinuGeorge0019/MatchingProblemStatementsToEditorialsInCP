{"link": "https://codeforces.com//contest/1327/problem/G", "problemId": "571330", "shortId": "1327G", "contest_number": "1327", "name": "G. Letters and Question Marks", "statement": "You are given a string  and an array of strings . Each string  consists of lowercase Latin letters from  to ;  consists of lowercase Latin letters from  to  and  question marks.Each string  has its cost  \u2014 an integer number. The value of some string  is calculated as , where  is the number of occurences of string  in  as a substring. For example, .You have to replace all question marks in  with  lowercase Latin letters from  to  so the value of  is maximum possible.", "input": "The first line contains one integer  () \u2014 the number of strings in the array . Then  lines follow, each containing one string  (consisting of lowercase Latin letters from  to ) and one integer  (, ). The sum of lengths of all strings  does not exceed . The last line contains one string  () consisting of lowercase Latin letters from  to  and question marks. The number of question marks in  is not greater than .", "output": "Print one integer \u2014 the maximum value of  after replacing all question marks with  lowercase Latin letters from  to .", "tutorial": "Suppose we want to calculate the value of some already fixed string (we should be able to do so at least to solve the test cases without question marks). How can we do it? We can use some substring searching algorithms to calculate , but a better solution is to build an Aho-Corasick automaton over the array , and then for each node calculate the sum of costs of all strings ending in that node (these are the strings represented by that node and the strings represented by other nodes reachable by suffix links). After that, process  by the automaton and calculate the sum of the aforementioned values over all states that were reached. Building an Aho-Corasick automaton can be done in , and processing the string  \u2014 in .Okay, what if we've got some question marks in our string? The first solution that comes to mind is to calculate  \u2014 we processed  first positions in , used a  of characters for question marks, and the current state of the automaton is ; then  denotes the maximum value of first  characters of  we could have got. But it's , where  and  is the size of the alphabet, which is too slow.To speed it up, we can see that there are only  positions in our string where we actually choose something in our dynamic programming. All substrings not containing question marks can be skipped in  as follows: for each substring of  bounded by two question marks (or bounded by one question mark and one of the ends of ) and each state of the automaton , we may precalculate the resulting state of the automaton and the change to the value of the string, if we process this substring by the automaton with the initial state . This precalculation is done in  overall, and using this, we may skip the states of dynamic programming such that  is not a position with a question mark, so our complexity becomes .A note about the model solution: it's a bit more complicated because we wanted to increase the constraints to , but then we decided that it would be too complicated to code, so the main function still contains some parts of the code that were used to improve its complexity. We will post a clearer version of the model solution soon.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 8000043;\nconst int K = 15;\nconst int M = 1043;\n\nint k;\nchar buf[N], buf2[M];\nvector<string> t;\nvector<int> c;\nstring s;\n\nmap<char, int> nxt[M];\nint lnk[M];\nint p[M];\nchar pchar[M];\nmap<char, int> go[M];\nint term[M];\nint ts = 1;\nint A[M][K];\nint F[M][K];\nint dp[M];\n\nint get_nxt(int x, char c)\n{\n    if(!nxt[x].count(c))\n    {\n        p[ts] = x;\n        pchar[ts] = c;\n        nxt[x][c] = ts++;\n    }\n    return nxt[x][c];\n}\n\nvoid add_string(int i)\n{\n    int cur = 0;\n    for(auto x : t[i])\n    {\n        cur = get_nxt(cur, x);\n    }\n    term[cur] += c[i];\n}\n\nint get_go(int x, char c);\n\nint get_lnk(int x)\n{\n    if(lnk[x] != -1)\n        return lnk[x];\n    if(x == 0 || p[x] == 0)\n        return lnk[x] = 0;\n    return lnk[x] = get_go(get_lnk(p[x]), pchar[x]);\n}\n\nint get_dp(int x)\n{\n    if(dp[x] != -1)\n        return dp[x];\n    dp[x] = term[x];\n    if(get_lnk(x) != x)\n        dp[x] += get_dp(get_lnk(x));\n    return dp[x];\n}\n\nint get_go(int x, char c)\n{\n    if(go[x].count(c))\n        return go[x][c];\n    if(nxt[x].count(c))\n        return go[x][c] = nxt[x][c];\n    if(x == 0)\n        return go[x][c] = 0;\n    return go[x][c] = get_go(get_lnk(x), c);\n}\n\nvoid build_skip(const string& s, vector<int>& sA, vector<long long>& sF)\n{                     \n    sA = vector<int>(ts);\n    for(int i = 0; i < ts; i++)\n        sA[i] = i;\n    sF = vector<long long>(ts);\n    for(auto c : s)\n    {\n        int ci = int(c - 'a');\n        for(int i = 0; i < ts; i++)\n        {\n            sF[i] += F[sA[i]][ci];\n            sA[i] = A[sA[i]][ci];\n        }\n    }\n}\n\nlong long solve(const string& s)\n{\n    long long BAD = (long long)(-1e18);\n\n    vector<int> pos;\n    for(int i = 0; i < s.size(); i++)\n        if(s[i] == '?')\n            pos.push_back(i);\n    int cntQ = pos.size();\n    vector<vector<int> > skip_A(cntQ + 1);\n    vector<vector<long long> > skip_F(cntQ + 1);\n    build_skip(s.substr(0, pos[0]), skip_A[0], skip_F[0]);\n    for(int i = 1; i < cntQ; i++)\n        build_skip(s.substr(pos[i - 1] + 1, pos[i] - pos[i - 1] - 1), skip_A[i], skip_F[i]);\n    build_skip(s.substr(pos.back() + 1, s.size() - pos.back() - 1), skip_A[cntQ], skip_F[cntQ]);\n\n    vector<vector<long long> > dp(1 << (K - 1), vector<long long>(ts, BAD));\n    vector<int> used(1 << K);\n    dp[0][skip_A[0][0]] = skip_F[0][0];\n    queue<int> q;\n    q.push(0);\n    used[0] = 1;\n    long long ans = BAD;\n    while(!q.empty())\n    {\n        int k = q.front();\n        q.pop();\n        int step = __builtin_popcount(k);\n        if(step == cntQ)\n        {\n            for(int i = 0; i < ts; i++)\n                ans = max(ans, dp[k][i]);\n            continue;\n        }\n        for(int i = 0; i < K - 1; i++)\n        {\n            if(k & (1 << i)) continue;\n            int nk = (k ^ (1 << i));\n            if(used[nk] == 0)\n            {\n                used[nk] = 1;\n                q.push(nk);\n            }\n            for(int j = 0; j < ts; j++)\n            {\n                if(dp[k][j] == BAD)\n                    continue;\n                int nj = get_go(j, char('a' + i));\n                int newSt = skip_A[step + 1][nj];\n                long long add = get_dp(nj) + skip_F[step + 1][nj];\n                dp[nk][newSt] = max(dp[nk][newSt], dp[k][j] + add);\n            }\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\", &k);\n    t.resize(k);\n    c.resize(k);\n    for(int i = 0; i < k; i++)\n    {\n        scanf(\"%s %d\", buf2, &c[i]);\n        t[i] = buf2;\n    }    \n    scanf(\"%s\", buf);\n    s = buf;\n\n    for(int i = 0; i < k; i++)\n        add_string(i);\n    for(int i = 0; i < ts; i++)\n    {\n        lnk[i] = -1;\n        dp[i] = -1;\n    }\n    for(int i = 0; i < ts; i++)\n    {\n        get_lnk(i);\n        for(char c = 'a'; c <= 'o'; c++)\n            get_go(i, c);\n    }\n    for(int i = 0; i < ts; i++)\n        get_dp(i);                               \n    for(int i = 0; i < ts; i++)\n    {\n        for(int j = 0; j < K; j++)\n        {\n            A[i][j] = get_go(i, char('a' + j));\n            F[i][j] = dp[A[i][j]];\n        }\n    }   \n    int n = s.size();\n    vector<int> leftQ(n, -1);\n    vector<int> rightQ(n, -1);\n    for(int i = 0; i < n; i++)\n    {\n        if(i != 0)\n            leftQ[i] = leftQ[i - 1];\n        if(s[i] == '?')\n            leftQ[i] = i;\n    }\n    for(int i = n - 1; i >= 0; i--)\n    {\n        if(i != n - 1)\n            rightQ[i] = rightQ[i + 1];\n        if(s[i] == '?')\n            rightQ[i] = i;\n    }\n    vector<int> bad(n, 0);\n    \n    if(leftQ.back() == -1)\n        bad = vector<int>(n, 1);\n\n    long long ans = 0;\n    int curSt = 0;\n    string news = \"\";\n    for(int i = 0; i < n; i++)\n    {\n        int ci = (s[i] == '?' ? 14 : int(s[i] - 'a'));\n        if(bad[i])\n            ans += F[curSt][ci];\n        curSt = A[curSt][ci];\n        if(!bad[i])\n            news.push_back(s[i]);\n        else if(i != 0 && !bad[i - 1])\n            news.push_back('o');\n    }                    \n    if(!news.empty())\n        ans += solve(news);\n    printf(\"%lld\\n\", ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}