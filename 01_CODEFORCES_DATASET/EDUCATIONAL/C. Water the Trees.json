{"link": "https://codeforces.com//contest/1661/problem/C", "problemId": "1361829", "shortId": "1661C", "contest_number": "1661", "name": "C. Water the Trees", "statement": "There are  trees in a park, numbered from  to . The initial height of the -th tree is .You want to water these trees, so they all grow to the  height.The watering process goes as follows. You start watering trees at day . During the -th day you can:   Choose a tree and water it. If the day is odd (e.g. ), then the height of the tree increases by . If the day is even (e.g. ), then the height of the tree increases by .  Or skip a day without watering any tree. Note that you can't water more than one tree in a day. Your task is to determine the  number of days required to water the trees so they grow to the same height.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. The first line of the test case contains one integer  () \u2014 the number of trees. The second line of the test case contains  integers  (), where  is the height of the -th tree. It is guaranteed that the sum of  over all test cases does not exceed  ().", "output": "For each test case, print one integer \u2014 the  number of days required to water the trees, so they grow to the same height.", "tutorial": "The first observation we need to solve this problem: the required height is either  or , where  is the maximum initial height of some tree. We don't need heights greater than , because, for example, if the height is , we can remove some moves and get the answer for the height . The same thing applies to all heights greater than . Why do we even need the height ? In some cases (like ) the answer for the height  is better than the answer for the height  (in this particular case, it is  vs ).Now, we have two ways to solve the problem: either use some gross formulas, or just write a binary search on the answer. I won't consider the solution with formulas (but we have one), so let's assume we use binary search. Let the current answer be . Then let  be the number of  operations we can do and  be the number of  operations we can do. We can use  operations greedily and then just check if the number of  operations is sufficient to grow up the remaining heights.Time complexity:  per test case.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n//  freopen(\"output.txt\", \"w\", stdout);\n#endif\n    \n    int tc;\n    scanf(\"%d\", &tc);\n    while (tc--) {\n        int n;\n        scanf(\"%d\", &n);\n        vector<int> h(n);\n        for (auto &it : h) {\n            scanf(\"%d\", &it);\n        }\n        \n        int mx = *max_element(h.begin(), h.end());\n        long long ans = 1e18;\n        for (auto need : {mx, mx + 1}) {\n            long long l = 0, r = 1e18;\n            long long res = -1;\n            while (l <= r) {\n                long long mid = (l + r) >> 1;\n                long long cnt1 = (mid + 1) / 2, cnt2 = mid - cnt1;\n                long long need1 = 0;\n                for (auto ch : h) {\n                    long long cur = (need - ch) / 2;\n                    if ((need - ch) % 2 == 1) {\n                        ++need1;\n                    }\n                    if (cnt2 >= cur) {\n                        cnt2 -= cur;\n                    } else {\n                        cur -= cnt2;\n                        cnt2 = 0;\n                        need1 += cur * 2;\n                    }\n                }\n                if (need1 <= cnt1) {\n                    res = mid;\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            ans = min(ans, res);\n        }\n        \n        printf(\"%lld\\n\", ans);\n    }\n        \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}