{"link": "https://codeforces.com//contest/1093/problem/C", "problemId": "270224", "shortId": "1093C", "contest_number": "1093", "name": "C. Mishka and the Last Exam", "statement": "Mishka is trying really hard to avoid being kicked out of the university. In particular, he was doing absolutely nothing for the whole semester, miraculously passed some exams so that just one is left.There were  classes of that subject during the semester and on -th class professor mentioned some non-negative integer  to the students. It turned out, the exam was to tell the whole sequence back to the professor. Sounds easy enough for those who attended every class, doesn't it?Obviously Mishka didn't attend any classes. However, professor left some clues on the values of  to help out students like Mishka:    was sorted in non-decreasing order ();   was even;  the following sequence , consisting of  elements, was formed and given out to students: . Professor also mentioned that any sequence , which produces sequence  with the presented technique, will be acceptable.Help Mishka to pass that last exam. Restore any sorted sequence  of non-negative integers, which produces sequence  with the presented technique. It is guaranteed that there exists at least one correct sequence , which produces the given sequence .", "input": "The first line contains a single integer  () \u2014 the length of sequence .  is always even. The second line contains  integers  () \u2014 sequence , where . ", "output": "Print  integers  () in a single line.  should be satisfied.  should be satisfied for all valid .", "tutorial": "Let's present the following greedy approach. The numbers will be restored in pairs ,  and so on. Thus, we can have some limits on the values of the current pair (satisfying the criteria about sort). Initially,  and they are updated with . Let  be minimal possible in the answer. Take  and . That way  was chosen in such a way that both  and  are within the restrictions and  is also minimal possible. If  was any greater than we would move both  limit up and  limit down leaving less freedom for later choices.Overall complexity: .Funnily enough, I coded some naive solution just to test main correct and with restriction of  on numbers it passed all tests in 300 ms at max. After I saw that I guessed why it worked in  but it looked fun nonetheless.", "solution": "n = int(input())\nl, r = 0, 10**18\nb = list(map(int, input().split()))\na = [0 for i in range(n)]\nfor i in range(n // 2):\n\ta[i] = max(l, b[i] - r)\n\ta[-i - 1] = b[i] - a[i]\n\tl, r = a[i], a[-i - 1]\nprint(*a)", "interactive": false, "noSolution": false, "noTutorial": false}