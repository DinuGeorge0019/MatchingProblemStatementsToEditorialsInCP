{"link": "https://codeforces.com//contest/1622/problem/E", "problemId": "1242581", "shortId": "1622E", "contest_number": "1622", "name": "E. Math Test", "statement": "Petya is a math teacher.  of his students has written a test consisting of  questions. For each student, it is known which questions he has answered correctly and which he has not.If the student answers the -th question correctly, he gets  points (otherwise, he gets  points). Moreover, the points for the questions are distributed in such a way that the array  is a permutation of numbers from  to .For the -th student, Petya knows that he expects to get  points for the test. Petya wonders how unexpected the results could be. Petya believes that the  of the results for students is equal to , where  is the number of points that the -th student has got for the test.Your task is to help Petya find such a permutation  for which the  of the results is maximum possible. If there are multiple answers, print any of them.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers  and  (; )\u00a0\u2014 the number of students and the number of questions, respectively. The second line contains  integers  (), where  is the number of points that the -th student expects to get. This is followed by  lines, the -th line contains the string  (), where  is  if the -th student has answered the -th question correctly, and  otherwise. The sum of  for all test cases does not exceed .", "output": "For each test case, print  integers\u00a0\u2014 a permutation  for which the  of the results is maximum possible. If there are multiple answers, print any of them.", "tutorial": "Note that there are only two ways to fix the result of the operation of taking an absolute value in the expression :  or . Since the value of  is small enough that we can iterate over all  options, and choose the one for which the sum is maximum.For each student, let's fix with which sign their total points will contribute to the answer, then  will contribute with the opposite sign. Now, for the question  we can calculate \u00a0\u2014 the coefficient with which  will contribute to the answer. It remains to choose such a permutation  that the sum  is the maximum possible. From here we can see that if  (for some  and ), then  must holds, otherwise we can swap  and , and the answer will increase. This means that we can sort all questions in ascending order by the value in the  array, and assign the value  in the array  to the -th question in ascending order.For some of  options, the permutations we found may be illegal because it can happen that we consider the case that some  evaluates as , but in the best permutation we found for that option, it evaluates as . We can just ignore it because this will never be the case with the option giving the highest possible surprise value \u2014 if this thing happened for some option to choose the signs of , then, if we flip the signs for the students such that the conditions on them are not met in the optimal permutation, we'll get a combination of signs that yields a higher surprise value.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    vector<int> x(n);\n    forn(i, n) scanf(\"%d\", &x[i]);\n    vector<vector<int>> a(n, vector<int>(m));\n    forn(i, n) forn(j, m) scanf(\"%1d\", &a[i][j]);\n    \n    int ans = -1;\n    vector<int> best;\n    forn(mask, 1 << n) {\n      vector<int> val(m);\n      forn(i, n) forn(j, m) if (a[i][j]) val[j] += ((mask >> i) & 1) ? +1 : -1;\n      int res = 0;\n      forn(i, n) res += ((mask >> i) & 1) ? -x[i] : x[i];\n      vector<int> p(m);\n      iota(p.begin(), p.end(), 0);\n      sort(p.begin(), p.end(), [&](int x, int y) { return val[x] < val[y]; });\n      forn(i, m) res += val[p[i]] * (i + 1);\n      if (res > ans) ans = res, best = p;\n    }\n    \n    vector<int> ansPerm(m);\n    forn(i, m) ansPerm[best[i]] = i;\n    forn(i, m) printf(\"%d \", ansPerm[i] + 1);\n    puts(\"\");\n  }\n} ", "interactive": false, "noSolution": false, "noTutorial": false}