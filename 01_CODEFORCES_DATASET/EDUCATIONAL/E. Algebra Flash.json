{"link": "https://codeforces.com//contest/1767/problem/E", "problemId": "1697004", "shortId": "1767E", "contest_number": "1767", "name": "E. Algebra Flash", "statement": "   New gamemode!  Huh, is that it? Slightly disappointed, you boot up the game and click on the new gamemode. It says \"\".There are  platforms, numbered from  to , placed one after another. There are  colors available in the game, numbered from  to . The -th platform is colored .You start on the platform  and want to reach platform . In one move, you can jump from some platform  to platforms  or .All platforms are initially deactivated (including platforms  and ). For each color , you can pay  coins to activate all platforms of that color.You want to activate some platforms so that you could start on an activated platform , jump through some activated platforms and reach an activated platform .What's the smallest amount of coins you can spend to achieve that?", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the number of platforms and the number of colors, respectively. The second line contains  integers  ()\u00a0\u2014 the colors of the platforms. The third line contains  integers  ()\u00a0\u2014 the cost of activating all platforms of each color.", "output": "Print the smallest amount of coins you can spend to activate some platforms so that you could start on an activated platform , jump through some activated platforms and reach an activated platform .", "tutorial": "Imagine we bought some subset of colors. How to check if there exists a path from $$$1$$$ to $$$n$$$?Well, we could write an easy dp. However, it's not immediately obvious where to proceed from that. You can't really implement buying colors inside the dp, because you should somehow know if you bought the current color before, and that's not really viable without storing a lot of information.Let's find another approach. Let's try to deduce when the subset is bad\u00a0\u2014 the path doesn't exist. Trivial cases: $$$c_1$$$ or $$$c_n$$$ aren't bought. Now, if there are two consecutive platforms such that their colors aren't bought, the path doesn't exist. Otherwise, if there are no such platforms, you can show that the path always exists.In particular, that implies that among all pairs of consecutive platforms, at least one color of the pair have to be bought. If the colors of the pair are the same, then it's just that this color have to be bought.The next step is probably hard to get without prior experience. Notice how the condition is similar to a well-known graph problem called \"vertex cover\". That problem is about finding a set of vertices in an undirected graph such that all graph edges have at least one of their endpoints in the set. In particular, our problem would be to find a vertex cover of minimum cost.That problem is known to be NP-hard, thus the constraints. We can't solve it in polynomial time but we'll attempt to it faster than the naive approach in $$$O(2^m \\cdot m^2)$$$.Let's start with this approach anyway. We can iterate over a mask of taken vertices and check if that mask is ok. In order to do that, we iterate over edges and check if at least vertex is taken for each of them.Again, having a bit of prior experience, one could tell from the constraints that the intended solution involves meet-in-the-middle technique.Let's iterate over the mask of taken vertices among vertices from $$$1$$$ to $$$\\frac m 2$$$. Then over the mask of taken vertices from $$$\\frac m 2 + 1$$$ to $$$m$$$. The conditions on edges split them into three groups: the edges that are completely in $$$\\mathit{mask}_1$$$, the edges that are completely in $$$\\mathit{mask}_2$$$ and the edges that have one endpoint in $$$\\mathit{mask}_1$$$ and another endpoint in $$$\\mathit{mask}_2$$$.First two types are easy to check, but how to force the third type to be all good? Consider the vertices that are not taken into $$$\\mathit{mask}_1$$$. All edges that have them as one of the endpoints will turn out bad if we don't take their other endpoints into $$$\\mathit{mask}_2$$$. That gives us a minimal set of constraints for each $$$\\mathit{mask}_1$$$: a mask $$$\\mathit{con}$$$ that includes all vertices from the second half that have edges to at least one of non-taken vertex in $$$\\mathit{mask}_1$$$.Then $$$\\mathit{mask}_2$$$ is good if it has $$$\\mathit{con}$$$ as its submask. Thus, we would want to update the answer with the $$$\\mathit{mask}_1$$$ of the minimum cost such that its $$$\\mathit{con}$$$ is a submask of $$$\\mathit{mask}_2$$$.Finally, let $$$\\mathit{dp}[\\mathit{mask}]$$$ store the minimum cost of some $$$\\mathit{mask}_1$$$ such that its $$$\\mathit{con}$$$ is a submask of $$$\\mathit{mask}$$$. Initialize the $$$\\mathit{dp}$$$ with the exact $$$\\mathit{con}$$$ for each $$$\\mathit{mask}_1$$$. Then push the values of $$$\\mathit{dp}$$$ up by adding any new non-taken bit to each mask.When iterating over $$$\\mathit{mask}_2$$$, check if it's good for edges of the second kind and update the answer with $$$\\mathit{dp}[\\mathit{mask}_2]$$$.Overall complexity: $$$O(2^{m/2} \\cdot m^2)$$$.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\n\nint main() {\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    vector<int> c(n);\n    forn(i, n){\n        scanf(\"%d\", &c[i]);\n        --c[i];\n    }\n    vector<int> x(m);\n    forn(i, m) scanf(\"%d\", &x[i]);\n    \n    vector<long long> g(m);\n    forn(i, n - 1){\n        g[c[i]] |= 1ll << c[i + 1];\n        g[c[i + 1]] |= 1ll << c[i];\n    }\n    g[c[0]] |= 1ll << c[0];\n    g[c[n - 1]] |= 1ll << c[n - 1];\n    \n    int mid = m / 2;\n    vector<int> dp(1 << mid, 1e9);\n    forn(mask, 1 << (m - mid)){\n        long long chk = 0;\n        int tot = 0;\n        forn(i, m - mid){\n            if ((mask >> i) & 1)\n                tot += x[i + mid];\n            else\n                chk |= g[i + mid];\n        }\n        if (((chk >> mid) | mask) != mask)\n            continue;\n        chk &= (1ll << mid) - 1;\n        dp[chk] = min(dp[chk], tot);\n    }\n    forn(i, mid) forn(mask, 1 << mid) if (!((mask >> i) & 1)){\n        dp[mask | (1 << i)] = min(dp[mask | (1 << i)], dp[mask]);\n    }\n    int ans = 1e9;\n    forn(mask, 1 << mid){\n        long long chk = 0;\n        int tot = 0;\n        forn(i, mid){\n            if ((mask >> i) & 1)\n                tot += x[i];\n            else\n                chk |= g[i];\n        }\n        chk &= (1ll << mid) - 1;\n        if ((chk | mask) != mask)\n            continue;\n        ans = min(ans, dp[mask] + tot);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}