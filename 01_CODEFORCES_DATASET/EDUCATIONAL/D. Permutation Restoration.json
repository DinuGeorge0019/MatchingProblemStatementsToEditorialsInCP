{"link": "https://codeforces.com//contest/1701/problem/D", "problemId": "1455052", "shortId": "1701D", "contest_number": "1701", "name": "D. Permutation Restoration", "statement": "Monocarp had a permutation  of  integers , , ...,  (a permutation is an array where each element from  to  occurs exactly once).Then Monocarp calculated an array of integers  of size , where . For example, if the permutation  is , then the array  is equal to .Unfortunately, the Monocarp has lost his permutation, so he wants to restore it. Your task is to find a permutation  that corresponds to the given array . If there are multiple possible permutations, then print any of them. The tests are constructed in such a way that least one suitable permutation exists.", "input": "The first line contains a single integer  ()\u00a0\u2014 number of test cases. The first line of each test case contains a single integer  (). The second line contains  integers  (). Additional constrains on the input:   the sum of  over test cases does not exceed ;  there exists at least one permutation  that would yield this array . ", "output": "For each test case, print  integers\u00a0\u2014 a permutation  that corresponds to the given array . If there are multiple possible permutations, then print any of them.", "tutorial": "We have  for each , we can rewrite this as follows: , or . From here we can see that for each  there is a segment of values that can be assigned to . So we have to match each number from  to  with one of these segments.To solve this problem, we can iterate from  to . Let the current number be , then it can be paired with a segment  without a pair such that  and the right bound is minimum among all such segments (because it will be the first to end among these segments). To do this, it is enough to maintain a set with open segments that have not yet been assigned a pair and choose from it a segment with the minimum right bound. Before running this method, you can sort the segments by their left border so they can be easily added to this set when we go from  to  (we will need to insert all segments that begin with , that's why it's convenient to have them sorted by their left border beforehand).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    for (int& x : b) cin >> x;\n    vector<pair<int, int>> ev(n);\n    for (int i = 0; i < n; ++i)\n      ev[i] = {(i + 1) / (b[i] + 1) + 1, i};\n    sort(ev.begin(), ev.end());\n    set<pair<int, int>> s;\n    int j = 0;\n    for (int i = 1; i <= n; ++i) {\n      while (j < n && ev[j].first == i) {\n        int id = ev[j++].second;\n        s.insert({b[id] ? (id + 1) / b[id] : n, id});\n      }\n      a[s.begin()->second] = i;\n      s.erase(s.begin());\n    }\n    for (int& x : a) cout << x << ' ';\n    cout << '\\n';\n  }\n} ", "interactive": false, "noSolution": false, "noTutorial": false}