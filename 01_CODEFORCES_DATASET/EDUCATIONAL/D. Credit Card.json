{"link": "https://codeforces.com//contest/893/problem/D", "problemId": "135514", "shortId": "893D", "contest_number": "893", "name": "D. Credit Card", "statement": "Recenlty Luba got a credit card and started to use it. Let's consider  consecutive days Luba uses the card.In the  of -th day a transaction  occurs. If , then  bourles are deposited to Luba's account. If , then  bourles are withdrawn. And if , then the amount of money on Luba's account is checked.In the  of any of  days Luba can go to the bank and deposit any  integer amount of burles to her account. But there is a limitation: the amount of money on the account can never exceed .Luba must not exceed this limit, and also she wants that  (the days when ) the amount of money on her account is non-negative. It takes a lot of time to go to the bank, so Luba wants to know the minimum number of days she needs to deposit some money to her account (if it is possible to meet all the requirements). Help her!", "input": "The first line contains two integers ,  (, ) \u2014the number of days and the money limitation. The second line contains  integer numbers  (), where  represents the transaction in -th day.", "output": "Print  if Luba cannot deposit the money to her account in such a way that the requirements are met. Otherwise print the minimum number of days Luba has to deposit money.", "tutorial": "The following greedy solution works. Firstly, deposite money only on days with . Secondly, every time the balance is negative to the day with , refill it to maximal possible value such that it won't go over  later.   Days with  can only lead to invalid state by going over card limit. We can only add money to the balance. Adding zero money in those days won't make invalid states if all were valid previously. Finally, if it's possible to get valid state in every day then it's possible to get it by refilling the same day the check happens. For example, you can make  balance in those days. Then you will never have negative balance there. Though it's not the most optimal way.  Let  be some value you deposite in some day with  to pass all conditions till the next day with . I state that function of number of game's moves dependancy on  is monotonious. Let's check it for some fixed . Define minimum balance you will get on any suffix from now as . Obviously, taking  will make it . If it goes negative then you will need an extra move to finish the game. Thus taking maximal  will lead to the lowest score possible. And last but not least \u2014 realization part. What will be the maximum possible value to deposite? Actually, it's such a value that optimal game after this will lead to maximum balance of  in some day. Thus, you want to check what will be the maximum balance  if you add zero money and take  as . Obviously, if it's negative then output . Naively this still works on  per day and lead to  overall. Notice that by depositing  you increase maximums on each suffix for now by . So, you can calculate it as you will do nothing and add sum  of your 's to get actual value. You store prefix sum of  up to  in . Then take maximum on suffix for every  ( is the maxumum  for  from  to ). .I hope I made it clear enough. :DOverall comlpexity: .", "solution": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << \"\\n\"; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nint main() {\n\tint n = nxt(), d = nxt();\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i] = nxt();\n\t}\n\n\tint ans = 0;\n\tint cur = 0;\n\tint balance = 0;\n\tvector<int> lows(n), rigs(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tbalance += a[i];\n\t\tif (a[i] == 0) {\n\t\t\tlows[i] = -balance;\n\t\t}\n\t\trigs[i] = d - balance;\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tlows[i] = max(lows[i], lows[i - 1]);\n\t}\n\tfor (int i = n - 2; i >= 0; --i) {\n\t\trigs[i] = min(rigs[i], rigs[i + 1]);\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (lows[i] > rigs[i]) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (cur < lows[i]) {\n\t\t\tcur = rigs[i];\n\t\t\t++ans;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}