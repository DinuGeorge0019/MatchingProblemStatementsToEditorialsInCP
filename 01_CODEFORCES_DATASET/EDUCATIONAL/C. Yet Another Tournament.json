{"link": "https://codeforces.com//contest/1783/problem/C", "problemId": "1728812", "shortId": "1783C", "contest_number": "1783", "name": "C. Yet Another Tournament", "statement": "You are participating in Yet Another Tournament. There are  participants: you and  other opponents, numbered from  to .Each two participants will play against each other exactly once. If the opponent  plays against the opponent , he wins if and only if .When the opponent  plays against you, everything becomes a little bit complicated. In order to get a win against opponent , you need to prepare for the match for at least  minutes \u2014 otherwise, you lose to that opponent.You have  minutes in total to prepare for matches, but you can prepare for only one match at one moment. In other words, if you want to win against opponents , you need to spend  minutes for preparation \u2014 and if this number is greater than , you cannot achieve a win against all of these opponents at the same time.The final place of each contestant is equal to the number of contestants with strictly more wins  . For example, if  contestants have  wins each,  contestant has  wins and  contestants have  win each, then the first  participants will get the -st place, the fourth one gets the -th place and two last ones get the -th place.Calculate the minimum possible place (lower is better) you can achieve if you can't prepare for the matches more than  minutes in total.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers  and  (; )\u00a0\u2014 the number of your opponents and the total time you have for preparation. The second line of each test case contains  integers  (), where  is the time you need to prepare in order to win against the -th opponent. It's guaranteed that the total sum of  over all test cases doesn't exceed .", "output": "For each test case, print the minimum possible place you can take if you can prepare for the matches no more than  minutes in total.", "tutorial": "Suppose, at the end, you won  matches, what can be your final place? Look at each opponent  with  (-indexed). Since the -th opponent (-indexed) won  games against the other opponents, even if they win against you, they'll gain  wins in total and can't affect your place (since your place is decided by only opponents who won strictly more matches than you).From the other side, let's look at each opponent  with  (-indexed). Even if they lose to you, they still have  wins (you have only ), so all of them have strictly more wins than you. As a result, there is only one opponent , whose match against you can affect your final place: if you won against them, your place will be , otherwise your place will be .Now, let's compare your possible places if you win  games with places for winning only  games:  wins gives you places  or , while winning  leads you to places  or  that objectively worse.In other words, it's always optimal to win as many matches as possible.How to win the most number of games? It's to choose the easiest opponents. Let's sort array  and find the maximum prefix  with . So, we found maximum number of games  we can win. The last is to check: can we get place , or only .If  contains among  smallest values, then we'll take place . Otherwise, let's try to \"insert\"  in this set, i.\u00a0e. let's erase the biggest among them and insert . If the sum is still lower or equal to , it's success and we get place . Otherwise, our place is .The total complexity is  because of sorting.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (auto &x : a) cin >> x;\n    auto b = a;\n    sort(b.begin(), b.end());\n    int ans = 0;\n    for (int i = 0; i < n && b[i] <= m; ++i) {\n      m -= b[i];\n      ++ans;\n    }\n    if (ans != 0 && ans != n && m + b[ans - 1] >= a[ans]) ++ans;\n    cout << n + 1 - ans << '\\n';\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}