{"link": "https://codeforces.com//contest/1260/problem/F", "problemId": "482538", "shortId": "1260F", "contest_number": "1260", "name": "F. Colored Tree", "statement": "You're given a tree with  vertices. The color of the -th vertex is .The value of the tree is defined as , where  is the number of edges on the shortest path between  and . The color of each vertex is lost, you only remember that  can be any integer from (inclusive). You want to calculate the sum of values of all trees meeting these conditions modulo  (the set of edges is fixed, but each color is unknown, so there are  different trees).", "input": "The first line contains one integer  () \u2014 the number of vertices. Then  lines follow, each line contains two integers  and  () denoting the range of possible colors of vertex . Then  lines follow, each containing two integers  and  (, ) denoting an edge of the tree. It is guaranteed that these edges form a tree.", "output": "Print one integer \u2014 the sum of values of all possible trees, taken modulo .", "tutorial": "Let's set the root as . Define  as the lowest common ancestor of vertices  and ,  as the depth of vertex  . Obviously .The answer we want to calculate is  where  represent all possible colorings of the tree.We can enumerate the color . For a fixed color , we need to calculate Let . Also denote  as a predicate which is true iff .Now our problem is how to maintain this formula while enumerating the color .  can be easily maintained. For , we can add  to all vertices in path  to  (for each existing vertex ), and when new vertex is added, just calculate the sum of vertices on path from  to , minus the contribution of vertex  (because there are  vertices in the path  to ), and multiply it . Similar operation can be used to handle the situation when some vertex disappears. All of this can be done with HLD.Overall it's .", "solution": "#include<bits/stdc++.h>\nusing namespace std;\nint n ;\nconst int maxn = 1e5 + 5;\nconst int mod = 1e9 + 7 ;\nvector<int> E[maxn];\nvector<int> in[maxn] , out[maxn];\nint cm = 0;\nint l[maxn] , dfn = 0 , dep[maxn];\nint g[maxn];\nint siz[maxn] , top[maxn] , h[maxn] , f[maxn];\n///-----segment tree\nstruct seg\n{\n    int l , r;\n    int sum , add ;\n}Node[maxn * 4];\n\nvoid build(int u,int l,int r)\n{\n    Node[u].l = l , Node[u].r = r;\n    Node[u].sum = Node[u].add = 0;\n    if(l == r) return ;\n    build(u<<1 , l , (l + r >> 1));\n    build(u<<1|1 , (l + r >>1) + 1 , r);\n    return ;\n}\nvoid pd(int u)\n{\n    Node[u].sum = (1LL*Node[u].add*(Node[u].r - Node[u].l + 1) + Node[u].sum) % mod ;\n    if(Node[u].l == Node[u].r) {\n        Node[u].add = 0 ;return ;\n    }\n    (Node[u<<1].add += Node[u].add ) %= mod;\n    (Node[u<<1|1].add += Node[u].add ) %= mod;\n    Node[u].add = 0 ; return ;\n}\nvoid modify(int u,int l,int r,int v)\n{\n    if(Node[u].l == l && Node[u].r == r) {\n        (Node[u].add += v ) %= mod;\n        pd(u) ; return ;\n        return ;\n    }\n    pd(u) ;\n    if(Node[u<<1].r >= r) {modify(u<<1 , l , r , v) ; pd(u<<1|1);}\n    else if(Node[u<<1|1].l <= l) {modify(u<<1|1 , l , r , v) ; pd(u<<1) ;}\n    else {\n        modify(u<<1 , l , Node[u<<1].r , v) ;\n        modify(u<<1|1 , Node[u<<1|1].l , r , v);\n    }\n    Node[u].sum = (Node[u<<1].sum + Node[u<<1|1].sum) % mod;\n    return ;\n}\nint query(int u,int l,int r)\n{\n    pd(u) ;\n    if(Node[u].l == l && Node[u].r == r) return Node[u].sum ;\n    if(Node[u<<1].r >= r) return query(u<<1 , l , r) ;\n    else if(Node[u<<1|1].l <= l) return query(u<<1|1 , l , r);\n    else return (query(u<<1 , l , Node[u<<1].r) + query(u<<1|1 , Node[u<<1|1].l , r)) % mod;\n}\n///---segment tree end\nvoid dfs(int fa,int u,int d)\n{\n    f[u] = fa;\n    dep[u] = d;siz[u] = 1;h[u] = -1;\n    for(int i = 0;i < E[u].size();i++) {\n        if(E[u][i] != fa) {\n            dfs(u , E[u][i] , d + 1) ;siz[u] += siz[E[u][i]];\n            if(h[u] == -1 || siz[E[u][i]] > siz[E[u][h[u]]]) h[u] = i;\n        }\n    }\n    return ;\n}\nvoid dfs2(int fa,int u)\n{\n    l[u] = ++dfn;\n    if(h[u] != -1) {\n        top[E[u][h[u]]] = top[u] ;\n        dfs2(u , E[u][h[u]]);\n    }\n    for(int i = 0;i < E[u].size();i++) {\n        if(E[u][i] != fa && i != h[u]) {\n            top[E[u][i]] = E[u][i] ;\n            dfs2(u , E[u][i]) ;\n        }\n    }\n    return ;\n}\nint fpow(int a,int b)\n{\n    int ans = 1;\n    while(b) {\n        if(b & 1) ans = (1LL * ans * a) % mod;\n        a = (1LL * a * a) % mod ;b >>= 1;\n    }\n    return ans;\n}\nvoid add(int u,int v)\n{\n    while(u) {\n        modify(1 , l[top[u]] , l[u] , v) ;\n        u = f[top[u]] ;\n    }\n    return ;\n}\nint cal(int u)\n{\n    int ans = mod - query(1 , 1 , 1);\n    while(u) {\n        ans = (ans + query(1 , l[top[u]] , l[u])) % mod;\n        u = f[top[u]] ;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d\",&n) ;\n    int P = 1;\n    for(int i = 1;i <= n;i++) {\n        int l , r;scanf(\"%d%d\",&l,&r) ;\n        in[l].push_back(i) ;\n        out[r + 1].push_back(i) ; cm = max(cm , r);\n        g[i] = fpow(r - l + 1 , mod - 2) ;\n        P = 1LL * P * (r - l + 1) % mod;\n    }\n    for(int i = 1;i < n;i++) {\n        int u , v;scanf(\"%d%d\",&u,&v) ;\n        E[u].push_back(v) ; E[v].push_back(u) ;\n    }\n    dfs(0 , 1 , 0) ; top[1] = 1;\n    dfs2(0 , 1) ;\n    build(1 , 1 , n) ;\n    int ans = 0 , cur = 0;\n    int d1 = 0 , d2 = 0 , u , d3 = 0;\n    for(int i = 1;i <= cm;i++) {\n        for(int j = 0;j < out[i].size();j++) {\n            u = out[i][j] ;\n            d1 = (d1 - 1LL * dep[u] * g[u] % mod + mod) % mod;\n            d2 = (d2 - g[u] + mod) % mod ;\n            d3 = (d3 - 1LL*dep[u]*g[u] % mod * g[u] % mod + mod) % mod;\n            add(u , mod - g[u]) ;\n            cur = (cur - 1LL * g[u] * cal(u) % mod + mod) % mod;\n        }\n        for(int j = 0;j < in[i].size();j++) {\n            u = in[i][j] ;\n            d1 = (d1 + 1LL * dep[u] * g[u]) % mod;\n            d2 = (d2 + g[u]) % mod;\n            d3 = (d3 + 1LL*dep[u]*g[u]%mod*g[u]) % mod;\n            cur = (cur + 1LL * g[u] * cal(u)) % mod;\n            add(u , g[u]) ;\n        }\n        ans = (ans + 1LL * d1 * d2%mod - 2LL*cur - d3) % mod;\n        ans = (ans + mod) % mod;\n    }\n    ans = 1LL * ans * P % mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}