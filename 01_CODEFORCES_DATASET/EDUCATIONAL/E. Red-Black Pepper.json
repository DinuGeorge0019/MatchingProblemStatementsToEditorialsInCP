{"link": "https://codeforces.com//contest/1728/problem/E", "problemId": "1534226", "shortId": "1728E", "contest_number": "1728", "name": "E. Red-Black Pepper", "statement": "Monocarp is going to host a party for his friends. He prepared  dishes and is about to serve them. First, he has to add some powdered pepper to each of them\u00a0\u2014 otherwise, the dishes will be pretty tasteless.The -th dish has two values  and \u00a0\u2014 its tastiness with red pepper added or black pepper added, respectively. Monocarp won't add both peppers to any dish, won't add any pepper multiple times, and won't leave any dish without the pepper added.Before adding the pepper, Monocarp should first purchase the said pepper in some shop. There are  shops in his local area. The -th of them has packages of red pepper sufficient for  servings and packages of black pepper sufficient for  servings.Monocarp goes to exactly one shop, purchases multiple (possibly, zero) packages of each pepper in such a way that . More formally, if he purchases  red pepper packages and  black pepper packages, then  and  should be non-negative and  should be equal to .For each shop, determine the maximum total tastiness of the dishes after Monocarp buys pepper packages only in this shop and adds the pepper to the dishes. If it's impossible to purchase the packages in the said way, print .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of dishes. The -th of the next  lines contains two integers  and  ()\u00a0\u2014 the tastiness of the -th dish with red pepper added or black pepper added, respectively. The next line contains a single integer  ()\u00a0\u2014 the number of shops. The -th of the next  lines contains two integers  and  ()\u00a0\u2014 the number of servings the red and the black pepper packages are sufficient for in the -th shop, respectively.", "output": "Print  integers. For each shop, print the maximum total tastiness of the dishes after Monocarp buys pepper packages only in this shop and adds the pepper to the dishes. If it's impossible to purchase the packages so that each dish will get the pepper added once and no pepper is left, print .", "tutorial": "Let's start by learning how to answer a query \u00a0\u2014 all red pepper and black pepper options are available.Let's iterate over all options to put the peppers and choose the maximum of them. First, let's use the red pepper for all dishes. Now we want to select some  of them to use black pepper instead of red pepper. Which ones do we choose? When we switch from the red pepper to the black pepper, the total tastiness changes by  for the -th dish. They are completely independent of each other, so we want to choose  largest of these values.Let  be the sequence of values of  in a non-increasing order.Thus,  black peppers will yield the result of . We can answer a query  by looking for a maximum in the sequence.Now consider an arbitrary query. Let  be all options for the amount of available black peppers for the query. Naively, we could iterate over all of them and choose the maximum one.However, notice an interesting thing about the sequence of the answers. By definition, it is non-strictly convex. In particular, one idea that can be extracted from this is the following. Find the position of an arbitrary maximum in this sequence. Then everything to the left of is is non-increasing. Everything to the right of it is non-increasing.Thus, for a query, it's enough to consider only two options: the one closest to the maximum from the left and from the right.Now we only have to learn how to get these options fast enough. For a query  we want to solve what's called a diophantine equation . An arbitrary solution can be obtained by using extended Euclid algorithm. Let it be some . Then we would want to check the answer for  black peppers. The amount of solutions to the equation is either infinite or zero. If it's infinite, all solutions will be of the form  for any integer . Remember that not all the solutions will be in a range .Finally, find the two solutions that are the closest to the maximum, check that they are in the range  and print the best answer of them.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nlong long gcd(long long a, long long b, long long& x, long long& y) {\n\tif (b == 0) {\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tlong long x1, y1;\n\tlong long d = gcd(b, a % b, x1, y1);\n\tx = y1;\n\ty = x1 - y1 * (a / b);\n\treturn d;\n}\n\nbool find_any_solution(long long a, long long b, long long c, long long &x0, long long &y0, long long &g) {\n\tg = gcd(abs(a), abs(b), x0, y0);\n\tif (c % g) {\n\t\treturn false;\n\t}\n\tx0 *= c / g;\n\ty0 *= c / g;\n\tif (a < 0) x0 = -x0;\n\tif (b < 0) y0 = -y0;\n\treturn true;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> a(n), b(n);\n\tforn(i, n) scanf(\"%d%d\", &a[i], &b[i]);\n\tlong long cur = accumulate(b.begin(), b.end(), 0ll);\n\tvector<int> difs(n);\n\tforn(i, n) difs[i] = a[i] - b[i];\n\tsort(difs.begin(), difs.end(), greater<int>());\n\tvector<long long> bst(n + 1);\n\tforn(i, n + 1){\n\t\tbst[i] = cur;\n\t\tif (i < n)\n\t\t\tcur += difs[i];\n\t}\n\tint mx = max_element(bst.begin(), bst.end()) - bst.begin();\n\tint m;\n\tscanf(\"%d\", &m);\n\tforn(_, m){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tlong long x0, y0, g;\n\t\tif (!find_any_solution(x, y, n, x0, y0, g)){\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tlong long l = x * 1ll * y / g;\n\t\tlong long red = x0 * 1ll * x;\n\t\tred = red + (max(0ll, mx - red) + l - 1) / l * l;\n\t\tred = red - max(0ll, red - mx) / l * l;\n\t\tlong long ans = -1;\n\t\tif (red <= n) ans = max(ans, bst[red]);\n\t\tred -= l;\n\t\tif (red >= 0) ans = max(ans, bst[red]);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}