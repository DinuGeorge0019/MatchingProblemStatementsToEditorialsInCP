{"link": "https://codeforces.com//contest/1334/problem/D", "problemId": "590684", "shortId": "1334D", "contest_number": "1334", "name": "D. Minimum Euler Cycle", "statement": "You are given a  graph  with  vertices: each pair of vertices  in  have both directed edges  and ; there are no self-loops.You should find such a cycle in  that visits every directed edge exactly once (allowing for revisiting vertices).We can write such cycle as a list of  vertices  \u2014 a visiting order, where each  occurs exactly once.Find the  such cycle. It's not hard to prove that the cycle always exists.Since the answer can be too large print its  segment, in other words, .", "input": "The first line contains the single integer  () \u2014 the number of test cases. Next  lines contain test cases \u2014 one per line. The first and only line of each test case contains three integers ,  and  (, , ) \u2014 the number of vertices in , and segment of the cycle to print. It's guaranteed that the total sum of  doesn't exceed  and the total sum of  doesn't exceed .", "output": "For each test case print the segment  of the lexicographically smallest cycle that visits every edge exactly once.", "tutorial": "The solution of the problem can be found clearly in constructive way. An example for : (1 2 1 3 1 4 1 5 (2 3 2 4 2 5 (3 4 3 5 (4 5 ()))) 1) where brackets mean that we call here some recursive function .Since on each level of recursion we have only  elements and there  levels then the generation of the certificate is quite easy: if on the currect level of recursion we can skip the whole part \u2014 let's just skip it. Otherwise let's build this part. Anyway, the built part of the cycle will have only  length so the whole algorithm has  complexity.The answer is lexicographically minimum by the construction, since on each level of recursion there is no way to build lexicographically smaller sequence.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\nint n;\nli l, r;\n\ninline bool read() {\n\tif(!(cin >> n >> l >> r))\n\t\treturn false;\n\treturn true;\n}\n\nbool intersect(li l1, li r1, li l2, li r2) {\n\treturn min(r1, r2) > max(l1, l2);\n}\n\nvector<int> ans;\n\nvoid calc(int lf, int rg, li &id) {\n\tif(lf == rg) return;\n\t\n\tif(intersect(l, r, id, id + 2 * (rg - lf))) {\n\t\tfore(to, lf + 1, rg + 1) {\n\t\t\tif(l <= id && id < r)\n\t\t\t\tans.push_back(lf);\n\t\t\tid++;\n\t\t\t\n\t\t\tif(l <= id && id < r)\n\t\t\t\tans.push_back(to);\n\t\t\tid++;\n\t\t}\n\t} else\n\t\tid += 2 * (rg - lf);\n\t\n\tcalc(lf + 1, rg, id);\n\t\n\tif(lf == 0) {\n\t\tif(l <= id && id < r)\n\t\t\tans.push_back(lf);\n\t\tid++;\n\t}\n}\n\ninline void solve() {\n\tans.clear();\n\tli id = 0;\n\tl--;\n\tcalc(0, n - 1, id);\n\t\n\tassert(sz(ans) == r - l);\n\tassert(id == n * li(n - 1) + 1);\n\t\n\tfor(int v : ans)\n\t\tcout << v + 1 << \" \";\n\tcout << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tint tc; cin >> tc;\n\t\n\twhile(tc--) {\n\t\tread();\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}