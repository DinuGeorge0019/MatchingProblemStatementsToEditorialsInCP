{"link": "https://codeforces.com//contest/1342/problem/E", "problemId": "604760", "shortId": "1342E", "contest_number": "1342", "name": "E. Placing Rooks", "statement": "Calculate the number of ways to place  rooks on  chessboard so that both following conditions are met:  each empty cell is under attack;  exactly  pairs of rooks attack each other. An empty cell is under attack if there is at least one rook in the same row or at least one rook in the same column. Two rooks attack each other if they share the same row or column, . For example, there are only two pairs of rooks that attack each other in the following picture:   Two ways to place the rooks are considered different if there exists at least one cell which is empty in one of the ways but contains a rook in another way.The answer might be large, so print it modulo .", "input": "The only line of the input contains two integers  and  (; ).", "output": "Print one integer \u2014 the number of ways to place the rooks, taken modulo .", "tutorial": "If we want to place $$$n$$$ rooks on an $$$n \\times n$$$ chessboard so all empty cells are under attack, then either each row or each column should contain at least one rook. Let's suppose that each row contains at least one rook, and multiply the answer by $$$2$$$ in the end.How to ensure that there are exactly $$$k$$$ pairs of rooks attacking each other? Since each row contains exactly one rook, only the rooks in the same column attack each other \u2014 moreover, if there are $$$x$$$ rooks in a non-empty column, they create $$$(x - 1)$$$ pairs. So our goal is to distribute $$$n$$$ rooks to $$$n - k$$$ columns so that each column contains at least one rook.How to calculate the number of ways to distribute the rooks into $$$c$$$ columns? One of the options is to choose the columns we use (the number of ways to do this is $$${n}\\choose{c}$$$), and then use inclusion-exclusion to ensure that we are counting only the ways where each column contains at least one rook. The formula we will get is something like $$$\\sum \\limits_{i = 0}^{c} (-1)^i {{c}\\choose{i}} (c-i)^n$$$: we want to fix the number of columns that will not contain rooks (that is $$$i$$$), which are these columns (that is $$${c}\\choose{i}$$$), and how many are there ways to distribute the rooks among remaining columns (that is $$$(c-i)^n$$$).Are we done? Almost. We wanted to multiply the answer by $$$2$$$ to count the ways where each column contains at least one rook, but we should not do it if $$$k = 0$$$, because in this case each placement of the rooks has exactly one rook in each row and exactly one rook in each column.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int N = 200043;\n\nint add(int x, int y)\n{\n\treturn (x + y) % MOD;\n}\n\nint sub(int x, int y)\n{\n\treturn add(x, MOD - y);\n}\n\nint mul(int x, int y)\n{\n\treturn (x * 1ll * y) % MOD;\n}\n\nint binpow(int x, int y)\n{\n\tint z = 1;\n\twhile(y > 0)\n\t{\n\t\tif(y % 2 == 1)\n\t\t\tz = mul(z, x);\n\t\tx = mul(x, x);\n\t\ty /= 2;\n\t}\n\treturn z;\n}\n\nint inv(int x)\n{\n\treturn binpow(x, MOD - 2);\n}\n\nint fact[N];\n\nint C(int n, int k)\n{\n\treturn mul(fact[n], inv(mul(fact[k], fact[n - k])));\n}\n\nint main()\n{\n\tint n, k;\n\tcin >> n >> k;\n\t\n\tif(k > n - 1)\n\t{\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tfact[0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tfact[i] = mul(i, fact[i - 1]);\n\tint ans = 0;\n\tint c = n - k;\n\tfor(int i = c; i >= 0; i--)\n\t\tif(i % 2 == c % 2)\n\t\t\tans = add(ans, mul(binpow(i, n), C(c, i)));\n\t\telse\n\t\t\tans = sub(ans, mul(binpow(i, n), C(c, i)));\n\tans = mul(ans, C(n, c));\n\tif(k > 0)\n\t\tans = mul(ans, 2);\n\tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}