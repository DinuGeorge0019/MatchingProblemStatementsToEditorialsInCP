{"link": "https://codeforces.com//contest/1809/problem/E", "problemId": "1839365", "shortId": "1809E", "contest_number": "1809", "name": "E. Two Tanks", "statement": "There are two water tanks, the first one fits  liters of water, the second one fits  liters of water. The first tank has  () liters of water initially, the second tank has  () liters of water initially.You want to perform  operations on them. The -th operation is specified by a single non-zero integer . If , then you try to pour  liters of water from the first tank into the second one. If , you try to pour  liters of water from the second tank to the first one.When you try to pour  liters of water from the tank that has  liters currently available to the tank that can fit  more liters of water, the operation only moves  liters of water.For all pairs of the initial volumes of water  such that  and , calculate the volume of water in the first tank after all operations are performed.", "input": "The first line contains three integers  and  (; )\u00a0\u2014 the number of operations and the capacities of the tanks, respectively. The second line contains  integers  (; )\u00a0\u2014 the volume of water you try to pour in each operation.", "output": "For all pairs of the initial volumes of water  such that  and , calculate the volume of water in the first tank after all operations are performed. Print  lines, each line should contain  integers. The -th value in the -th line should be equal to the answer for  and .", "tutorial": "Consider a naive solution. Iterate over all pairs  and apply all operations. The complexity is . The constraints obviously imply that it's too much. What can we cut from it? Well, surely  will still remain there. Both of  and  also should. So we can probably only hope to turn this  into . Let's try that.Notice that no matter what operations are applied,  never changes. You can also peek at the examples and see that the patterns are suspiciously diagonal-shaped in the matrix. Let's try to solve the problem by fixing  and calculating the answer for all values of .I will call the fixed  variable . Consider case where  and . Here, all  can fit into both  and , so we can avoid caring about one restriction on the operations. We'll think what to do with large volumes later.If there are no operations, the answer for each initial  is  for all  from  to . Now consider an operation  for some . For , nothing changes. Actually, for all  the result of the operation is the same as for . Hmm, but if the result is the same, it will remain the same until the end. Same from the other side. The answers for  and  also get merged together. To me it kind of looks like a primitive form of DSU on these volume states: you merge some prefix of the answers together and merge some suffix of the answers together.If the state was merged to either  or , then it's easy to calculate the actual answer for that state. What happens to the remaining states? Well, since they weren't merged anywhere, the operation for them was applied fully: if  was requested, all  was poured.How to deal with multiple operations then? I propose the following idea. When applying an operation, we only want to know which of the previously non-merged states become merged. Basically, we can squish all previous operations into one: just sum up the signed amounts of water. Since they all were applied fully to the non-merged states, it's completely valid. After the squish, check for the new merges.You can actually study the structure of the answers and see that they go like that:  for some values of  and  such that . It isn't that important, but it makes the code easier. You can basically calculate the length of the merged prefix, the length of the merged suffix, then calculate the answer at the end of the prefix in  and restore all answers from it.We neglected larger values of  earlier, time to return to them. Another kind of limit to each operation is added: when  extra water doesn't fit in another tank. Well, it doesn't change that much. It only makes more prefix/suffix merges. To come up with the exact formulas, I followed these points. Something merges on an operation , when any of these holds:    (not enough water in the first tank);   (not enough space in the second tank);   (not enough water in the second tank);   (not enough space in the first tank). Replace all  with , and you get the constraints for prefix and suffix merges.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main() {\n\tint n, a, b;\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tvector<int> v(n);\n\tforn(i, n) scanf(\"%d\", &v[i]);\n\tvector<vector<int>> ans(a + 1, vector<int>(b + 1));\n\tforn(cd, a + b + 1){\n\t\tint l = max(0, cd - b), r = min(a, cd);\n\t\tint sum = 0;\n\t\tfor (int x : v){\n\t\t\tsum += x;\n\t\t\tl = max({l, sum, cd + sum - b});\n\t\t\tr = min({r, a + sum, sum + cd});\n\t\t}\n\t\tif (l > r) l = r = max(0, cd - b);\n\t\tint res = l;\n\t\tfor (int x : v){\n\t\t\tif (x > 0)\n\t\t\t\tres -= min({res, x, b - (cd - res)});\n\t\t\telse\n\t\t\t\tres += min({cd - res, -x, a - res});\n\t\t}\n\t\tforn(c, cd + 1) if (c <= a && cd - c <= b){\n\t\t\tans[c][cd - c] = (c < l ? res : (c > r ? res + r - l : res + c - l));\n\t\t}\n\t}\n\tforn(i, a + 1){\n\t\tforn(j, b + 1)\n\t\t\tprintf(\"%d \", ans[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}