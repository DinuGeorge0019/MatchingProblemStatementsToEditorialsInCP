{"link": "https://codeforces.com//contest/1278/problem/A", "problemId": "498930", "shortId": "1278A", "contest_number": "1278", "name": "A. Shuffle Hashing", "statement": "Polycarp has built his own web service. Being a modern web service it includes login feature. And that always implies password security problems.Polycarp decided to store the hash of the password, generated by the following algorithm:  take the password , consisting of lowercase Latin letters, and shuffle the letters randomly in it to obtain  ( can still be equal to );  generate two random strings, consisting of lowercase Latin letters,  and  (any of these strings can be empty);  the resulting hash , where addition is string concatenation. For example, let the password  \"\". Then  can be equal to \"\". Random strings  \"\" and  \"\". Then  \"\".Note that no letters could be deleted or added to  to obtain , only the order could be changed.Now Polycarp asks you to help him to implement the password check module. Given the password  and the hash , check that  can be the hash for the password .Your program should answer  independent test cases.", "input": "The first line contains one integer  () \u2014 the number of test cases. The first line of each test case contains a non-empty string , consisting of lowercase Latin letters. The length of  does not exceed . The second line of each test case contains a non-empty string , consisting of lowercase Latin letters. The length of  does not exceed .", "output": "For each test case print the answer to it \u2014 \"\" if the given hash  could be obtained from the given password  or \"\" otherwise.", "tutorial": "The general idea of the solution is to check that string  contains some substring which is a permutation of . The constraints were so low you could do it with any algorithm, even  per test case could pass.The most straightforward way was to iterate over the substring of , sort it and check if it's equal to  sorted. That's .Next you could notice than only substrings of length  matter and shave another  off the complexity to get .After that you might remember that the size of the alphabet is pretty low. And one string is a permutation of another one if the amounts of letters 'a', letters 'b' and so on in them are equal. So you can precalculate array , where  is equal to the amount of the -th letter of the alphabet in . Calculating this array for  substrings will be  each, so that makes it .Then notice how easy it is to recalculate the letter counts going from some substring  to . Just subtract  from the amount of the -th letter and add  to the amount of the -th letter. Comparing two array every time will still lead to , though.The final optimization is to maintain the boolean array  such that  means that  is equal to the current value of  of the substring. You are updating just two values of  on each step, thus only two values of  might change. You want all the  values to be , so keep the number of values  in that array and say \"\" if that number is equal to . That finally makes the solution  per test case.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nstring p, h;\n\nbool read(){\n\tif (!(cin >> p >> h))\n\t\treturn false;\n\treturn true;\n}\n\nvoid solve(){\n\tint n = h.size();\n\tvector<int> cntp(26);\n\tforn(i, p.size())\n\t\t++cntp[p[i] - 'a'];\n\tforn(i, n){\n\t\tvector<int> cnth(26);\n\t\tfor (int j = i; j < n; ++j){\n\t\t\t++cnth[h[j] - 'a'];\n\t\t\tif (cntp == cnth){\n\t\t\t\tputs(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"NO\");\n}\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\tforn(_, tc){\n\t\tread();\n\t\tsolve();\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}