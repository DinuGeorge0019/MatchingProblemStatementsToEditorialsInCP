{"link": "https://codeforces.com//contest/1065/problem/G", "problemId": "235284", "shortId": "1065G", "contest_number": "1065", "name": "G. Fibonacci Suffix", "statement": "Let's denote (yet again) the sequence of Fibonacci strings: ,  , , where the plus sign denotes the concatenation of two strings.Let's denote the  sequence of suffixes of string  as . For example,  is , and  is the following sequence: , , , , . Elements in this sequence are numbered from .Your task is to print  first characters of -th element of . If there are less than  characters in this suffix, then output the whole suffix.", "input": "The only line of the input contains three numbers ,  and  (, ) denoting the index of the Fibonacci string you have to consider, the index of the element of  and the number of characters you have to output, respectively. It is guaranteed that  does not exceed the length of .", "output": "Output  first characters of -th element of , or the whole element if its length is less than .", "tutorial": "Suppose we added all the suffixes of  into a trie. Then we can find -th suffix by descending the trie, checking the sizes of subtrees to choose where to go on each iteration.The model solution actually does that, but computes the sizes of subtrees without building the whole trie. Recall that if we insert all suffixes of a string into the trie, then the size of subtree of some vertex is equal to the number of occurences of the string denoted by this vertex in the original string.Since in our problem the strings are recurrent, we may use prefix automaton to count the number of occurences. To calculate the number of occurences of string  in , let's build prefix function for , and an automaton  which tells the value of prefix function, if the previous value was , and we appended  to the string (the same approach is used in KMP substring search algorithm). Then, let's build another automaton that will help us work with Fibonacci string:  \u2014 what will be the value of prefix function, if we append  to the string? For  and , this automaton can be easily built using  and ; and for , we may build  using the automatons for  and . We also have to keep track of the number of occurences, that can be done with another automaton on fibonacci strings.There is a corner case when we need to stop descending the trie; to handle it, we need to check whether some string is a suffix of , but that can be easily made by checking if .Each step in trie forces us to do up to three (depending on your implementation) queries like \"count the number of occurences of some string in \", so overall the solution works in .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n    return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n    z = (int)(s.size());\n    p[0] = 0;\n    for(int i = 1; i < z; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && s[j] != s[i])\n            j = p[j - 1];\n        if(s[j] == s[i])\n            j++;\n        p[i] = j;\n    }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            if(i < z && s[i] == char('0' + j))\n                A1[i][j] = i + 1;\n            else if(i == 0)\n                A1[i][j] = 0;\n            else\n                A1[i][j] = A1[p[i - 1]][j];\n        }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            A3[i][j] = A1[i][j];\n            A2[i][j] = (A3[i][j] == z ? 1 : 0);\n        }\n    for(int i = 2; i <= n; i++)\n        for(int j = 0; j <= z; j++)\n        {\n            A3[j][i] = A3[A3[j][i - 2]][i - 1];\n            A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n        }\n}\n\nint main()\n{\n    cin >> n >> k >> m;\n    string cur = \"\";\n    for(int i = 0; i < m; i++)\n    {\n        if(cur != \"\") build(cur);\n        li x = 0;\n        if(cur != \"\" && A3[0][n] == i)\n            x = 1;\n        if(k == 1 && x == 1)\n            break;\n        k -= x;\n        build(cur + '0');\n        li x1 = A2[0][n];\n        if(k > x1)\n        {\n            cur += '1';\n            k -= x1;\n        }\n        else\n            cur += '0';\n    }\n    cout << cur << endl;\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}