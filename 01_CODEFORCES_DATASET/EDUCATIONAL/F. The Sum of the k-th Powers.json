{"link": "https://codeforces.com//contest/622/problem/F", "problemId": "47920", "shortId": "622F", "contest_number": "622", "name": "F. The Sum of the k-th Powers", "statement": "There are well-known formulas: , , . Also mathematicians found similar formulas for higher degrees.Find the value of the sum  modulo  (so you should find the remainder after dividing the answer by the value ).", "input": "The only line contains two integers  ().", "output": "Print the only integer  \u2014 the remainder after dividing the value of the sum by the value .", "tutorial": "Statement: the function of the sum is a polynomial of degree  over variable . This statement can be proved by induction (to make step you should take the derivative).\nDenote  the value of the sum for . We can easily calculate the values of  for  from  to  in  time. If  then we already have the answer. Otherwise let's use Lagrange polynomial to get the value of the sum for the given value .\nThe Largange polynomial have the following form: . In our case  and .\nTo calculate  in a linear time we should use that  for all . It's help us because with that property we can recalculate the inner product for  from the inner product for  simply by multiplying by two values and dividing by two values. So we can calculate the sum in linear time over .\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nint n, k;\n\u00a0\ninline bool read() {\n\u00a0 \u00a0 return !!(cin >> n >> k);\n}\n\u00a0\nconst int mod = 1000 * 1000 * 1000 + 7;\n\u00a0\nint gcd(int a, int b, int& x, int& y) {\n\u00a0 \u00a0 if (!a) {\n\u00a0 \u00a0 \u00a0 \u00a0 x = 0, y = 1;\n\u00a0 \u00a0 \u00a0 \u00a0 return b;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 int xx, yy, g = gcd(b % a, a, xx, yy);\n\u00a0 \u00a0 x = yy - b / a * xx;\n\u00a0 \u00a0 y = xx;\n\u00a0 \u00a0 return g;\n}\n\u00a0\ninline int normal(int n) {\n\u00a0 \u00a0 n %= mod;\n\u00a0 \u00a0 (n < 0) && (n += mod);\n\u00a0 \u00a0 return n;\n}\n\u00a0\ninline int inv(int a) {\n\u00a0 \u00a0 int x, y;\n\u00a0 \u00a0 assert(gcd(a, mod, x, y) == 1);\n\u00a0 \u00a0 return normal(x);\n}\n\u00a0\ninline int add(int a, int b) { return a + b >= mod ? a + b - mod : a + b; }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + mod : a - b; }\ninline int mul(int a, int b) { return int(a * 1ll * b % mod); }\ninline int _div(int a, int b) { return mul(a, inv(b)); }\n\u00a0\ninline int binPow(int a, int b) {\n\u00a0 \u00a0 int ans = 1;\n\u00a0 \u00a0 while (b) {\n\u00a0 \u00a0 \u00a0 \u00a0 if (b & 1) ans = mul(ans, a);\n\u00a0 \u00a0 \u00a0 \u00a0 a = mul(a, a);\n\u00a0 \u00a0 \u00a0 \u00a0 b >>= 1;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return ans;\n}\n\u00a0\nint calc(const vector<int>& y, int x) {\n\u00a0 \u00a0 int ans = 0;\n\u00a0 \u00a0 int k = 1;\n\u00a0 \u00a0 fore(j, 1, sz(y)) {\n\u00a0 \u00a0 \u00a0 \u00a0 k = mul(k, normal(x - j));\n\u00a0 \u00a0 \u00a0 \u00a0 k = _div(k, normal(0 - j));\n\u00a0 \u00a0 }\n\u00a0 \u00a0 forn(i, sz(y)) {\n\u00a0 \u00a0 \u00a0 \u00a0 ans = add(ans, mul(y[i], k));\n\u00a0 \u00a0 \u00a0 \u00a0 if (i + 1 >= sz(y)) break;\n\u00a0 \u00a0 \u00a0 \u00a0 k = mul(k, _div(normal(x - i), normal(x - (i + 1))));\n\u00a0 \u00a0 \u00a0 \u00a0 k = mul(k, _div(normal(i - (sz(y) - 1)), normal(i + 1)));\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return ans;\n}\n\u00a0\ninline int solve() {\n\u00a0 \u00a0 vector<int> y;\n\u00a0 \u00a0 int sum = 0;\n\u00a0 \u00a0 y.pb(sum);\n\u00a0 \u00a0 forn(i, k + 1) {\n\u00a0 \u00a0 \u00a0 \u00a0 sum = add(sum, binPow(i + 1, k));\n\u00a0 \u00a0 \u00a0 \u00a0 y.pb(sum);\n\u00a0 \u00a0 }\n\u00a0 \u00a0 if (n < sz(y)) return y[n];\n\u00a0 \u00a0 return calc(y, n);\n}\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 cout << solve() << endl;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}