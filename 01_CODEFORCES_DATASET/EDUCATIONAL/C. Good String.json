{"link": "https://codeforces.com//contest/1389/problem/C", "problemId": "686124", "shortId": "1389C", "contest_number": "1389", "name": "C. Good String", "statement": "Let's call  of some string  as string .Analogically, let's call  of string  as string .Let's say string  is  if its left cyclic shift is equal to its right cyclic shift.You are given string  which consists of digits \u2013.What is the minimum number of characters you need to erase from  to make it good?", "input": "The first line contains single integer  ()\u00a0\u2014 the number of test cases. Next  lines contains test cases\u00a0\u2014 one per line. The first and only line of each test case contains string  (). Each character  is digit \u2013. It's guaranteed that the total length of strings doesn't exceed .", "output": "For each test case, print the minimum number of characters you need to erase from  to make it good.", "tutorial": "Let's analyze when the string is good. Suppose it is .The cyclic shifts of this string are  and . We get the following constraints for a good string: , , , ..., , . If the string has odd length, then all characters should be equal to each other; otherwise, all characters on odd positions should be equal, and all characters on even positions should be equal.Now, since there are only  different types of characters, we can brute force all possible combinations of the first and the second character of the string we want to obtain (there are only  of them) and, for each combination, greedily construct the longest possible subsequence of  beginning with those characters in .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(a) int((a).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nint solve(const string& s, int x, int y) {\n\tint res = 0;\n\tfor (auto c : s) if (c - '0' == x) {\n\t\t++res;\n\t\tswap(x, y);\n\t}\n\tif (x != y && res % 2 == 1)\n\t\t--res;\n\treturn res;\n}\n\nvoid solve() {\n\tstring s;\n\tcin >> s;\n\tint ans = 0;\n\tforn(x, 10) forn(y, 10)\n\t\tans = max(ans, solve(s, x, y));\n\tcout << sz(s) - ans << endl;\n}\n\nint main() {\n\tint T;\n\tcin >> T;\n\twhile (T--) solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}