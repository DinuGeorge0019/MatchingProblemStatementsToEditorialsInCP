{"link": "https://codeforces.com//contest/1574/problem/F", "problemId": "1115679", "shortId": "1574F", "contest_number": "1574", "name": "F. Occurrences", "statement": "A subarray of array  from index  to the index  is the array . The number of occurrences of the array  in the array  is the number of subarrays of  such that they are equal to .You are given  arrays ; the elements of these arrays are integers from  to . You have to build an array  consisting of  integers from  to  in such a way that, for  given subarray , the number of occurrences of  in the array  is  than the number of occurrences of each non-empty subarray of  in . Note that if  doesn't occur in , and no subarray of  occurs in , this condition is still met for .Your task is to calculate the number of different arrays  you can build, and print it modulo .", "input": "The first line contains three integers ,  and  () \u2014 the number of the given arrays, the desired length of the array , and the upper bound on the values in the arrays. Then  lines follow. The -th line represents the array . The first integer in the -th line is  () \u2014 the number of elements in ; then,  integers from  to  follow \u2014 the elements of the array . Additional constraint on the input: ; i.\u2009e., the number of elements in the given arrays in total does not exceed .", "output": "Print one integer \u2014 the number of different arrays  you can build, taken modulo .", "tutorial": "What does the condition \"the number of occurrences of  in the array  is  than the number of occurrences of each non-empty subarray of  in \" mean? First, if  contains two (or more) equal elements, then any occurrence of  introduces at least two occurrences of that element; so any element in  is forbidden (it should not appear in the resulting array). Now let's consider an array  such that every its element is unique. Every element of  should be a part of an occurrence of  in the array . Let's rephrase this condition as follows: .Let's build a directed graph on  vertices, where an arc from vertex  to vertex  means that each occurrence of  should be followed by , and each occurrence of  should be preceded by  (i.\u2009e.  is followed by  in some array ). Let's consider the weakly connected components in this graph. If we have at least one occurrence of some element from a component in , it means that all other elements from this component occur in  as well. Some integers from  and  are \"bad\" in a sense that we cannot uniquely determine which element should follow/precede them (in terms of graph theory, it means that the in-degree or out-degree of a vertex is at least ). Since by picking one element from a component, we will have to use all elements from a component, it means that if a component contains at least one \"bad\" element, the whole component will be \"bad\" \u2014 we cannot use any element from it.If a component is a cycle, no vertex has in-degree or out-degree greater than , but the component is still \"bad\" since, if we include at least one element from , we cannot finish the cycle \u2014 the array  is not infinite, but the cycle is.Okay, the only \"good\" components are chains. When we use an element from a chain in , all elements from this chain will be used in exactly the same order that they were in the chain; so,  should consist of some chains linked together (chains may repeat, and some chains may be absent from ). We can write a solution with dynamic programming: let  be the number of ways to construct an array of length  using these chains. The transitions are as follows: , where  is the number of chains, and  is the length of the -th chain.The number of chains is up to , and the number of states in dynamic programming is , so the solution works in , which is too slow. We can improve it with the following two facts:  all chains of the same length are indistinguishable;  there are  different lengths of chains. So, instead of iterating on the chains themselves in dynamic programming, we will iterate on the lengths of the chains (considering only lengths having at least one chain), and process all chains of the same length as one by introducing a multiplier in our dynamic programming: , where  is the number of chains of length . That way, our dynamic programming will work in  if we skip the values of  with .", "solution": "#include <bits/stdc++.h>     \n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n \tx += y;\n \twhile(x >= MOD) x -= MOD;\n \twhile(x < 0) x += MOD;\n \treturn x;\n}\n\nint mul(int x, int y)\n{\n \treturn (x * 1ll * y) % MOD;\n}\n\nint main()\n{\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tvector<vector<int>> A(n);\n\tvector<int> bad_num(k);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint c;\n\t\tscanf(\"%d\", &c);\n\t\tA[i].resize(c);\n\t\tfor(int j = 0; j < c; j++)\n\t\t{\n\t\t\tscanf(\"%d\", &A[i][j]); \t\n\t\t\tA[i][j]--;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t \tif(set<int>(A[i].begin(), A[i].end()).size() != A[i].size())\n\t \t{\n\t \t \tfor(auto x : A[i])\n\t \t \t\tbad_num[x] = 1;\n\t \t}\n\t}\n\tvector<vector<int>> nxt(k);\n\tvector<vector<int>> prv(k);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j + 1 < A[i].size(); j++)\n\t\t{\n\t\t \tnxt[A[i][j]].push_back(A[i][j + 1]);\n\t\t \tprv[A[i][j + 1]].push_back(A[i][j]);\n\t\t}\n\n\tfor(int i = 0; i < k; i++)\n\t{\n\t    sort(nxt[i].begin(), nxt[i].end());\n\t    sort(prv[i].begin(), prv[i].end());\n\t \tnxt[i].erase(unique(nxt[i].begin(), nxt[i].end()), nxt[i].end());\n\t \tprv[i].erase(unique(prv[i].begin(), prv[i].end()), prv[i].end());\n\t}\n\n\tvector<int> used(k, 0);\n\tvector<int> cnt(k + 1, 0);\n\tfor(int i = 0; i < k; i++)\n\t{\n\t\tif(used[i]) continue;\n\t \tqueue<int> q;\n\t \tvector<int> comp;\n\t \tq.push(i);\n\t \tused[i] = 1;\n\t \twhile(!q.empty())\n\t \t{\n\t \t\tint z = q.front();\n\t \t\tq.pop();\n\t \t\tcomp.push_back(z);\n\t \t \tfor(auto x : nxt[z])\n\t \t \t\tif(!used[x])\n\t \t \t\t{\n\t \t \t\t \tused[x] = 1;\n\t \t \t\t \tq.push(x);\n\t \t \t\t}\n\t \t \tfor(auto x : prv[z])\n\t \t \t\tif(!used[x])\n\t \t \t\t{\n\t \t \t\t \tused[x] = 1;\n\t \t \t\t \tq.push(x);\n\t \t \t\t}\n\t \t}\n\t \tbool bad = false;\n\t \tint cnt_beg = 0;\n\t \tfor(auto x : comp)\n\t \t{\n\t \t \tif(prv[x].empty())\n\t \t \t\tcnt_beg++;\n\t \t \tif(prv[x].size() > 1 || nxt[x].size() > 1 || bad_num[x])\n\t \t \t\tbad = true;\n\t \t}\n\t \tbad |= (cnt_beg == 0);\n\t \tif(!bad)\n\t \t\tcnt[comp.size()]++;\n\t}\n\tvector<int> nonzero;\n\tfor(int i = 1; i <= k; i++)\n\t\tif(cnt[i] > 0)\n\t\t\tnonzero.push_back(i);\n\tvector<int> dp(m + 1, 0);\n\tdp[0] = 1;\n\tfor(int i = 1; i <= m; i++)\n\t\tfor(auto x : nonzero)\n\t\t \tif(x <= i)\n\t\t \t\tdp[i] = add(dp[i], mul(cnt[x], dp[i - x]));\n\n\tprintf(\"%d\\n\", dp[m]);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}