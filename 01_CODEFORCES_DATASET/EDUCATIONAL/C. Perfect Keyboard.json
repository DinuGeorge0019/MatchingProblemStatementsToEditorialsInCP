{"link": "https://codeforces.com//contest/1303/problem/C", "problemId": "538602", "shortId": "1303C", "contest_number": "1303", "name": "C. Perfect Keyboard", "statement": "Polycarp wants to assemble his own keyboard. Layouts with multiple rows are too complicated for him \u2014 his keyboard will consist of only one row, where all  lowercase Latin letters will be arranged in some order.Polycarp uses the same password  on all websites where he is registered (it is bad, but he doesn't care). He wants to assemble a keyboard that will allow to type this password very easily. He doesn't like to move his fingers while typing the password, so, for each pair of adjacent characters in , they should be adjacent on the keyboard. For example, if the password is , then the layout  is perfect, since characters  and  are adjacent on the keyboard, and  and  are adjacent on the keyboard. It is guaranteed that there are no two adjacent equal characters in , so, for example, the password cannot be  (two characters  are adjacent).Can you help Polycarp with choosing the perfect layout of the keyboard, if it is possible?", "input": "The first line contains one integer  () \u2014 the number of test cases. Then  lines follow, each containing one string  () representing the test case.  consists of lowercase Latin letters only. There are no two adjacent equal characters in .", "output": "For each test case, do the following:   if it is impossible to assemble a perfect keyboard, print  (in upper case, );  otherwise, print  (in upper case), and then a string consisting of  lowercase Latin letters \u2014 the perfect layout. Each Latin letter should appear in this string exactly once. If there are multiple answers, print any of them. ", "tutorial": "The problem can be solved using a greedy algorithm. We will maintain the current layout of the keyboard with letters that have already been encountered in the string, and the current position on the layout.If the next letter of the string is already on the layout, it must be adjacent to the current one, otherwise there is no answer.If there was no such letter yet, we can add it to the adjacent free position, if both of them is occupied, then there is no answer.At the end, you have to add letters that were not in the string .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(a) int((a).size())\n#define all(a) (a).begin(), (a).end()\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nvoid solve() {\n    string s;\n    cin >> s;\n\n    vector<bool> used(26);\n    used[s[0] - 'a'] = true;\n    string t(1, s[0]);\n        \n    int pos = 0;\n    for (int i = 1; i < sz(s); i++) {\n        if (used[s[i] - 'a']) {\n            if (pos > 0 && t[pos - 1] == s[i]) {\n                pos--;\n            } else if (pos + 1 < sz(t) && t[pos + 1] == s[i]) {\n                pos++;\n            } else {\n                cout << \"NO\" << endl;\n                return;\n            }\n        } else {\n            if (pos == 0) {\n                t = s[i] + t;\n            } else if (pos == sz(t) - 1) {\n                t += s[i];\n                pos++;\n            } else {\n                cout << \"NO\" << endl;\n                return;\n            }\n        }\n        used[s[i] - 'a'] = true;\n    }\n        \n    forn(i, 26) if (!used[i])\n        t += char(i + 'a');\n    cout << \"YES\" << endl << t << endl;\n}\n\nint main() {\n    int tc;\n    cin >> tc;\n    \n    forn(i, tc) solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}