{"link": "https://codeforces.com//contest/1000/problem/E", "problemId": "193658", "shortId": "1000E", "contest_number": "1000", "name": "E. We Need More Bosses", "statement": "Your friend is developing a computer game. He has already decided how the game world should look like \u2014 it should consist of  locations connected by   passages. The passages are designed in such a way that it should be possible to get from any location to any other location.Of course, some passages should be guarded by the monsters (if you just can go everywhere without any difficulties, then it's not fun, right?). Some crucial passages will be guarded by really fearsome monsters, requiring the hero to prepare for battle and designing his own tactics of defeating them (commonly these kinds of monsters are called ). And your friend wants you to help him place these bosses.The game will start in location  and end in location , but these locations are not chosen yet. After choosing these locations, your friend will place a boss in each passage such that it is impossible to get from  to  without using this passage. Your friend wants to place as much bosses as possible (because more challenges means more fun, right?), so he asks you to help him determine the maximum possible number of bosses, considering that any location can be chosen as  or as .", "input": "The first line contains two integers  and  (, ) \u2014 the number of locations and passages, respectively. Then  lines follow, each containing two integers  and  (, ) describing the endpoints of one of the passages. It is guaranteed that there is no pair of locations directly connected by two or more passages, and that any location is reachable from any other location.", "output": "Print one integer \u2014 the maximum number of bosses your friend can place, considering all possible choices for  and .", "tutorial": "It's quite obvious that we can place bosses only on the bridges of the given graph \u2014 if an edge is not a bridge, then removing it doesn't make the graph disconnected, so there still exists a path between any pair of vertices. And if we fix two vertices  and , and then find some simple path between them, then we will place the bosses on all bridges belonging to this path (since the set of bridges would stay the same no matter which simple path between  and  we choose).If we find bridges in the given graph and compress all 2-edge-connected components (two vertices belong to the same 2-edge-connected component iff there exists a path between these vertices such that there are no bridges on this path) into single vertices, we will obtain a special tree called bridge tree. Every edge of a bridge tree corresponds to a bridge in the original graph (and vice versa). Since we want to find the path with maximum possible number of bridges, we only need to find the diameter of the bridge tree, and this will be the answer to the problem.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 500043;\n\nvector<int> g[N];\nvector<int> t[N];\nint tin[N], tout[N], fup[N];\nint p[N];\nint T = 1;\nint rnk[N];\nvector<pair<int, int> > bridges;\nint st;\nint d[N];\nint n, m;\n\nint get(int x)\n{\n \treturn (p[x] == x ? x : p[x] = get(p[x]));\n}\n\nvoid link(int x, int y)\n{\n \tx = get(x);\n \ty = get(y);\n \tif(x == y) return;\n \tif(rnk[x] > rnk[y])\n \t\tswap(x, y);\n \tp[x] = y;\n \trnk[y] += rnk[x];\t\n}\n\nint dfs(int x, int par = -1)\n{\n\ttin[x] = T++;\n\tfup[x] = tin[x];\n\tfor(auto y : g[x])\n\t{\n\t \tif(tin[y] > 0)\n\t \t{\n\t \t\tif(par != y)\n\t \t\t\tfup[x] = min(fup[x], tin[y]);\n\t \t}\n\t \telse\n\t \t{\n\t \t \tint f = dfs(y, x);\n\t \t \tfup[x] = min(fup[x], f);\n\t \t \tif(f > tin[x])\n\t \t \t\tbridges.push_back(make_pair(x, y));\n\t \t \telse\n\t \t \t\tlink(x, y);\n\t \t}\n\t}\n\ttout[x] = T++;                                      \n\treturn fup[x];\n}      \n\nvoid build()\n{\n \tfor(auto z : bridges)\n \t{\n \t \tint x = get(z.first);\n \t \tint y = get(z.second);\n \t \tst = x;\n \t \tt[x].push_back(y);\n \t \tt[y].push_back(x);\n \t}\n}\n\npair<int, int> bfs(int x)\n{\n\tfor(int i = 0; i < n; i++)\n\t\td[i] = n + 1;\n\td[x] = 0;\n\tqueue<int> q;\n\tq.push(x);\n\tint last = 0;\n\twhile(!q.empty())\n\t{\n\t \tlast = q.front();\n\t \tq.pop();\n\t \tfor(auto y : t[last])\n\t \t\tif(d[y] > d[last] + 1)\n\t \t\t{\n\t \t\t \td[y] = d[last] + 1;\n\t \t\t \tq.push(y);\n\t \t\t}\n\t}\n\treturn make_pair(last, d[last]);\n}\n\nint main()\n{                \n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\trnk[i] = 1, p[i] = i;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t \tint x, y;\n\t \tscanf(\"%d %d\", &x, &y);\n\t \t--x;\n\t \t--y;\n\t \tg[x].push_back(y);\n\t \tg[y].push_back(x);\n\t}\n\tdfs(0);\n\tbuild();\n\tpair<int, int> p1 = bfs(st);\n\tpair<int, int> p2 = bfs(p1.first);\n\tprintf(\"%d\\n\", p2.second);\n}", "interactive": false, "noSolution": false, "noTutorial": false}