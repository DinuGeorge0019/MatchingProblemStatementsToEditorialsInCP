{"link": "https://codeforces.com//contest/990/problem/E", "problemId": "188994", "shortId": "990E", "contest_number": "990", "name": "E. Post Lamps", "statement": "Adilbek's house is located on a street which can be represented as the OX axis. This street is really dark, so Adilbek wants to install some post lamps to illuminate it. Street has  positions to install lamps, they correspond to the integer numbers from  to  on the OX axis. However, some positions are blocked and no post lamp can be placed there.There are post lamps of different types which differ only by their power. When placed in position , post lamp of power  illuminates the segment . The power of each post lamp is always a positive integer number.The post lamp shop provides an infinite amount of lamps of each type from power  to power . Though each customer is only allowed to order post lamps of  type. Post lamps of power  cost  each.What is the minimal total cost of the post lamps of  type Adilbek can buy to illuminate the entire segment  of the street? If some lamps illuminate any other segment of the street, Adilbek does not care, so, for example, he may place a lamp of power  in position  (even though its illumination zone doesn't completely belong to segment ).", "input": "The first line contains three integer numbers ,  and  (, ) \u2014 the length of the segment of the street Adilbek wants to illuminate, the number of the blocked positions and the maximum power of the post lamp available. The second line contains  integer numbers  () \u2014 the blocked positions. The third line contains  integer numbers  () \u2014 the costs of the post lamps.", "output": "Print the minimal total cost of the post lamps of  type Adilbek can buy to illuminate the entire segment  of the street. If illumintaing the entire segment  is impossible, print .", "tutorial": "Let's start with learning how to place lamps of fixed power to cover the segment with the minimal number of them. The following greedy strategy works: find the rightmost non-blocked position that is covered by lamps and place lamp there until either everything is covered or rightmost free position is to the left of the last placed lamp. Initially you only consider  to be covered. Function  \u2014 the minimal number of post lamps to cover segment  is clearly monotonous, thus you want to update states as early as possible.Okay, now you iterate over all  and update the answer with the results multiplied by cost.Now, why will this work fast? You obviously precalculate the rightmost free position for each prefix segment. If there are any free positions to the right of last placed lamp then the rightmost of them will always be the rightmost for the entire prefix segment. Finally, any two consecutive iterations of the algorithm will either move you by  positions or return . This can be easily proven by contradiction.Overall complexity: , as you do about  steps for each  and that is a common series sum.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}