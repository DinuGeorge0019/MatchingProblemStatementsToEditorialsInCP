{"link": "https://codeforces.com//contest/1389/problem/D", "problemId": "686125", "shortId": "1389D", "contest_number": "1389", "name": "D. Segment Intersections", "statement": "You are given two lists of segments  and .Initially, all segments  are equal to  and all segments  are equal to .In one step, you can choose one segment (either from the first or from the second list) and extend it by . In other words, suppose you've chosen segment  then you can transform it either into  or into .Let's define a total intersection  as the sum of lengths of intersections of the corresponding pairs of segments, i.e. . Empty intersection has length  and length of a segment  is equal to .What is the minimum number of steps you need to make  greater or equal to ?", "input": "The first line contains the single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers  and  (; )\u00a0\u2014 the length of lists and the minimum required total intersection. The second line of each test case contains two integers  and  ()\u00a0\u2014 the segment all  are equal to initially. The third line of each test case contains two integers  and  ()\u00a0\u2014 the segment all  are equal to initially. It's guaranteed that the sum of  doesn't exceed .", "output": "Print  integers\u00a0\u2014 one per test case. For each test case, print the minimum number of step you need to make  greater or equal to .", "tutorial": "At first, note that  of segments  and  can be calculated as . If it's negative then segments don't intersect, otherwise it's exactly length of intersection.Now we have two major cases: do segments  and  already intersect or not.If segments intersect then we already have  as the total intersection. Note, that making both segments equal to  in each pair are always optimal since in each step we will increase the total intersection by .After making all segments equal to  we can increase total intersection by  only in two steps: we need to extend both segments in one pair.In result, we can find not a hard formula to calculate the minimum number of steps: we already have  of the total intersection, then we can increase it by at most  using one step per increase, and then to any number using two steps per increase.In the case of non-intersecting  and , we should at first \"invest\" some number of steps in each pair to make them intersect. So let's iterate over the number of segments to \"invest\" . We should make  steps to make segments touch. Now,  segments touch so we can use almost the same formulas for them as in the previous case.The total complexity is  per test case.", "solution": "import kotlin.math.*\n\nfun main() {\n    repeat(readLine()!!.toInt()) {\n        val (n, k) = readLine()!!.split(' ').map { it.toLong() }\n        val (l1, r1) = readLine()!!.split(' ').map { it.toLong() }\n        val (l2, r2) = readLine()!!.split(' ').map { it.toLong() }\n\n        var ans = 1e18.toLong()\n        if (max(l1, l2) <= min(r1, r2)) {\n            val rem = max(0L, k - n * (min(r1, r2) - max(l1, l2)))\n            val maxPossible = n * (abs(l1 - l2) + abs(r1 - r2))\n            ans = min(rem, maxPossible) + max(0L, rem - maxPossible) * 2\n        } else {\n            val invest = max(l1, l2) - min(r1, r2)\n            for (cntInv in 1..n) {\n                var curAns = invest * cntInv\n                val maxPossible = (max(r1, r2) - min(l1, l2)) * cntInv\n                curAns += min(k, maxPossible) + max(0L, k - maxPossible) * 2\n                ans = min(ans, curAns)\n            }\n        }\n        println(ans)\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}