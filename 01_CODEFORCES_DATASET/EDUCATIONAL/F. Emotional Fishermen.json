{"link": "https://codeforces.com//contest/1437/problem/F", "problemId": "775844", "shortId": "1437F", "contest_number": "1437", "name": "F. Emotional Fishermen", "statement": " fishermen have just returned from a fishing vacation. The -th fisherman has caught a fish of weight .Fishermen are going to show off the fish they caught to each other. To do so, they firstly choose an order in which they show their fish (each fisherman shows his fish exactly once, so, formally, the order of showing fish is a permutation of integers from  to ). Then they show the fish they caught according to the chosen order. When a fisherman shows his fish, he might either become happy, become sad, or stay content.Suppose a fisherman shows a fish of weight , and the maximum weight of a previously shown fish is  ( if that fisherman is the first to show his fish). Then:  if , the fisherman becomes happy;  if , the fisherman becomes sad;  if none of these two conditions is met, the fisherman stays content. Let's call an order in which the fishermen show their fish  if, after all fishermen show their fish according to this order, each fisherman becomes either happy or sad. Calculate the number of  orders modulo .", "input": "The first line contains one integer  (). The second line contains  integers , , ...,  ().", "output": "Print one integer \u2014 the number of  orders, taken modulo .", "tutorial": "First of all, sort the fishermen so it is easier to consider them in ascending order.The key observation that allows us to solve the problem is the following: there will be an increasing sequence of happy fishermen, and all other fishermen will be unhappy.Consider the fisherman  which belongs to the increasing sequence. Let's analyze which fisherman will be next to it in the order. It is either a fisherman that will be happy, or a fisherman that will be sad. In the first case, the fish caught by this fisherman must have a size of at least , in the second case \u2014 at most .The first case will be considered later. For the second case, if we know the number of fishermen that were already placed in the order, we know that all of them (except the -th one) belong to the \"sad\" category (that is, the fish of every already placed fisherman, except for the -th one, is at least two times smaller than the fish of the -th fisherman). So, if we have already placed  fishermen, the last happy fisherman was the -th one, and we want to place a sad fisherman, then the number of ways to choose this sad fisherman is exactly , where  is the number of fishermen  such that .If we can handle the first case, this observation will allow us to solve the problem with dynamic programming. Let  be the number of ways to choose  first fishermen in the order so that the -th fisherman is the last happy one. The case when the next fisherman is sad can be handled with a transition to the state  (don't forget to multiply by the number of ways to choose the next sad fisherman, as described earlier). What about the case when the next fisherman is happy? We should iterate on the fisherman  such that  and transition from  to , but this part works in . To get an  solution, we have to speed it up with prefix sums or something like that.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5043;\nconst int MOD = 998244353;\n\nint dp[N][N];\nint pdp[N][N];\nint cntLess[N];\nint lastLess[N];\nint a[N];\nint n;\n\nint add(int x, int y)\n{\n \tx += y;\n \twhile(x >= MOD) x -= MOD;\n \twhile(x < 0) x += MOD;\n \treturn x;\n}\n\nint sub(int x, int y)\n{\n \treturn add(x, MOD - y);\n}\n\nint mul(int x, int y)\n{\n \treturn (x * 1ll * y) % MOD;\n}\n\nint main()\n{\n\tcin >> n;\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tsort(a, a + n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t \tcntLess[i] = 0;\n\t \tlastLess[i] = -1;\n\t \tfor(int j = 0; j < n; j++)\n\t \t\tif(a[j] * 2 <= a[i])\n\t \t\t{\n\t \t\t \tlastLess[i] = j;\n\t \t\t \tcntLess[i]++;\n\t \t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t \tdp[i][1] = 1;\n\t \tpdp[i + 1][1] = add(pdp[i][1], dp[i][1]);\n\t}\n\tfor(int k = 2; k <= n; k++)\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif(cntLess[i] + 1 >= k)\n\t\t \t\tdp[i][k] = add(mul(dp[i][k - 1], add(cntLess[i], sub(2, k))), pdp[lastLess[i] + 1][k - 1]);\n\t\t \telse\n\t\t \t\tdp[i][k] = 0;\n\t\t \t//cerr << i << \" \" << k << \" \" << dp[i][k] << endl;                                \n\t\t \tpdp[i + 1][k] = add(pdp[i][k], dp[i][k]);\n\t\t}\n\n\tcout << dp[n - 1][n] << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}