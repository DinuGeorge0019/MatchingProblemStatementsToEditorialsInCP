{"link": "https://codeforces.com//contest/1721/problem/F", "problemId": "1521729", "shortId": "1721F", "contest_number": "1721", "name": "F. Matching Reduction", "statement": "You are given a bipartite graph with  vertices in the first part,  vertices in the second part, and  edges. The maximum matching in this graph is the maximum possible (by size) subset of edges of this graph such that no vertex is incident to more than one chosen edge.You have to process two types of queries to this graph:   \u2014 remove the  number of vertices from this graph so that the size of the maximum matching gets reduced , and print the vertices that you have removed. Then, find any maximum matching in this graph and print the sum of indices of edges belonging to this matching;   \u2014 query of this type will be asked only after a query of type . As the answer to this query, you have to print the edges forming the maximum matching you have chosen in the previous query. Note that you should solve the problem in  mode. It means that you can't read the whole input at once. You can read each query only after writing the answer for the last query. Use functions  in  and  in  languages after each writing in your program.", "input": "The first line contains four integers , ,  and  (; ; ). Then  lines follow. The -th of them contains two integers  and  (; ) meaning that the -th edge connects the vertex  in the first part and the vertex  in the second part. There are no pairs of vertices that are connected by more than one edge. Then  lines follow. The -th of them contains one integer,  or , denoting the -th query. Additional constraints on queries:   the number of queries of type  won't exceed the size of the maximum matching in the initial graph;  the number of queries of type  won't exceed ;  each query of type  is preceded by a query of type ;  your solution is allowed to read the -th query only after printing the answer for the -th query and flushing the output. ", "output": "For a query of type , print the answer in three lines as follows:   the first line should contain the number of vertices you remove;  the second line should contain the indices of vertices you remove, as follows: if you remove the vertex  from the left part, print ; if you remove the vertex  from the right part, print  (negative index);  the third line should contain the sum of indices of edges in some maximum matching in the resulting graph. The edges are numbered from  to .  For a query of type , print the answer in two lines as follows:   the first line should contain the size of the maximum matching;  the second line should contain the indices of the edges belonging to the maximum matching. Note that the sum of these indices should be equal to the number you printed at the end of the previous query of type ;  After printing the answer to a query, don't forget to flush the output.", "tutorial": "Let's start by finding the maximum matching in the given graph. Since the constraints are pretty big, you need something fast. The model solution converts the matching problem into a flow network and uses Dinic to find the matching in , but something like heavily optimized Kuhn's algorithm can also work.Okay, then what about finding the minimum possible number of vertices to delete in order to reduce the maximum matching? We claim that it is always enough to remove one vertex, and the proof will also provide a way to quickly search for such vertices.Let's recall that the size of the maximum matching is equal to the size of the minimum vertex cover . So, we will try to find a way to reduce the minimum vertex cover by , and it's actually pretty easy \u2014 just remove any vertex belonging to the vertex cover; it's obvious that it reduces the vertex cover by , and the maximum matching by  as well. So, we can find the minimum vertex cover in the graph using the standard algorithm to convert the MM into MVC (or, if you're using Dinic to find the maximum matching, you can represent the minimum vertex cover as the minimum cut problem), and for each query of type , just take a vertex from the vertex cover we found.Now the only thing that's left is discussing how to maintain the structure of the maximum matching in the graph. In fact, it's quite easy:  on the one hand, since we remove the vertices belonging to the minimum vertex cover, every edge (including the edges from the matching) will be incident to one of the vertices we will remove;  on the other hand, due to the definition of the maximum matching, there is no vertex that is incident to two or more edges from the maximum matching;  so, every vertex from the vertex cover has exactly one edge from the maximum matching that is incident to it, and when we remove a vertex, we can simply remove the corresponding edge from the maximum matching. So, the only thing we need to do is to maintain which edge from the matching corresponds to which vertex from the minimum vertex cover, and it will allow us to maintain the structure of the maximum matching \u2014 and since these \"pairs\" don't change when we remove a vertex, it is enough to get this information right after we have constructed the maximum matching in the given graph; we won't need to rebuild it.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 400043;\nconst int INF = int(1e9);\n\nstruct edge\n{\n    int y, c, f;\n    edge() {};\n    edge(int y, int c, int f) : y(y), c(c), f(f) {};\n};\n\nvector<edge> e;\nvector<int> g[N];\nint S, T, V;\nint d[N], lst[N];\nint n1, n2, m, q;\nmap<pair<int, int>, int> es;\n\nvoid add_edge(int x, int y, int c)\n{\n    g[x].push_back(e.size());\n    e.push_back(edge(y, c, 0));\n    g[y].push_back(e.size());\n    e.push_back(edge(x, 0, 0));\n}\n\nint rem(int x)\n{\n    return e[x].c - e[x].f;\n}\n\nbool bfs()\n{\n    for (int i = 0; i < V; i++)\n        d[i] = INF;\n    d[S] = 0;\n    queue<int> q;\n    q.push(S);\n    while (!q.empty())\n    {\n        int k = q.front();\n        q.pop();\n        for (auto y : g[k])\n        {\n            if (rem(y) == 0)\n                continue;\n            int to = e[y].y;\n            if (d[to] > d[k] + 1)\n            {\n                q.push(to);\n                d[to] = d[k] + 1;\n            }\n        }\n    }\n    return d[T] < INF;\n}\n\nint dfs(int x, int mx)\n{\n    if (x == T || mx == 0)\n        return mx;\n    int sum = 0;\n    for (; lst[x] < g[x].size(); lst[x]++)\n    {\n        int num = g[x][lst[x]];\n        int r = rem(num);\n        if (r == 0)\n            continue;\n        int to = e[num].y;\n        if (d[to] != d[x] + 1)\n            continue;\n        int pushed = dfs(to, min(r, mx));\n        if (pushed > 0)\n        {\n            e[num].f += pushed;\n            e[num ^ 1].f -= pushed;\n            sum += pushed;\n            mx -= pushed;\n            if (mx == 0)\n                return sum;\n        }\n    }\n    return sum;\n}\n\nint Dinic()\n{\n    int ans = 0;\n    while (bfs())\n    {\n        for (int i = 0; i < V; i++)\n            lst[i] = 0;\n        int f = 0;\n        do\n        {\n            f = dfs(S, INF);\n            ans += f;\n        } while (f > 0);\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d %d %d %d\", &n1, &n2, &m, &q);\n    S = n1 + n2;\n    T = S + 1;\n    V = T + 1;\n    for (int i = 0; i < m; i++)\n    {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        --x;\n        --y;\n        es[make_pair(x, y)] = i + 1;\n        add_edge(x, n1 + y, 1);\n    }\n    for (int i = 0; i < n1; i++)\n        add_edge(S, i, 1);\n    for (int i = 0; i < n2; i++)\n        add_edge(i + n1, T, 1);\n    Dinic();\n    bfs();\n    vector<int> vertex_cover;\n    map<int, int> index;\n    set<int> matched;\n    long long sum = 0;\n    for (int i = 0; i < n1; i++)\n        if (d[i] == INF)\n        {\n            vertex_cover.push_back(i + 1);\n            for (auto ei : g[i])\n                if (e[ei].f == 1)\n                {\n                    int idx = es[make_pair(i, e[ei].y - n1)];\n                    index[i + 1] = idx;\n                    sum += idx;\n                    matched.insert(idx);\n                }\n        }\n    for (int i = 0; i < n2; i++)\n        if (d[i + n1] != INF)\n        {\n            vertex_cover.push_back(-(i + 1));\n            for (auto ei : g[i + n1])\n                if (e[ei].f == -1)\n                {\n                    int idx = es[make_pair(e[ei].y, i)];\n                    index[-(i + 1)] = idx;\n                    sum += idx;    \n                    matched.insert(idx);\n                }\n        }\n    for (int i = 0; i < q; i++)\n    {\n        int s;\n        scanf(\"%d\", &s);\n        if (s == 1)\n        {\n            puts(\"1\");\n            int v = vertex_cover.back();\n            vertex_cover.pop_back();\n            printf(\"%d\\n\", v);\n            sum -= index[v];\n            matched.erase(index[v]);\n            printf(\"%lld\\n\", sum);\n        }\n        else\n        {\n            printf(\"%d\\n\", (int)matched.size());\n            for(auto x : matched) printf(\"%d \", x);\n            puts(\"\");\n        }   \n        fflush(stdout);\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}