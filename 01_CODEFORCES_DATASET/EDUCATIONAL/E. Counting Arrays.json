{"link": "https://codeforces.com//contest/893/problem/E", "problemId": "135515", "shortId": "893E", "contest_number": "893", "name": "E. Counting Arrays", "statement": "You are given two positive integer numbers  and . An array  is called an  of  iff the following conditions are met:  There are  elements in , and all of them are integer numbers;  . You have to count the number of pairwise distinct arrays that are -factorizations of . Two arrays  and  are considered different iff there exists at least one index  () such that . Since the answer can be very large, print it modulo .", "input": "The first line contains one integer  () \u2014 the number of testcases to solve. Then  lines follow, each containing two integers  and  (). Each of these lines represents a testcase.", "output": "Print  integers. -th integer has to be equal to the number of -factorizations of  modulo .", "tutorial": "Fill the array with ones. Now we should take every prime divisor  of  and distribute  (maximum power of this prime to appear in ) of it into some cells of the array. It is pretty well-known problem, it's equal to . Take product of this values for every prime . This will be the answer if there were no negative numbers. But we should also multiply it by number of ways to select even number of position to put unary minuses \u2014  (like you can fill in  position anyhow and the final one will be determined by parity of current count).To process many queries you should factorize numbers in  (by precalcing the smallest prime divisor of every number up to  with sieve of Eratosthenes), get  in  (by precalcing factorials and inverse factorials) and get  in  (binary exponentiation).Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << \"\\n\"; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 1111111;\nint erat[N];\n\nconst int mod = 1000000007;\nint fact[N];\nint invfact[N];\n\nlong long pw(long long a, long long b) {\n\tlong long res = 1;\n\twhile (b) {\n\t\tif (b & 1ll) {\n\t\t\tres = res * a % mod;\n\t\t}\n\t\tb >>= 1;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nlong long C(int n, int k) {\n\treturn fact[n] * 1ll * invfact[n - k] % mod * invfact[k] % mod;\n}\n\nint main() {\n\tfor (int i = 2; i < N; ++i) {\n\t\tif (erat[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\terat[i] = i;\n\t\tif (1.0 * i * i < N + N) {\n\t\t\tfor (int j = i * i; j < N; j += i) {\n\t\t\t\tif (erat[j] == 0) {\n\t\t\t\t\terat[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfact[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tfact[i] = 1ll * i * fact[i - 1] % mod;\n\t}\n\tinvfact[N - 1] = pw(fact[N - 1], mod - 2);\n\tfor (int i = N - 2; i >= 0; --i) {\n\t\tinvfact[i] = 1ll * invfact[i + 1] * (i + 1) % mod;\n\t}\n\n\tint q = nxt();\n\twhile (q--) {\n\t\tint x = nxt(), y = nxt();\n\t\tlong long ans = 1;\n\t\tint last = 0;\n\t\tint cnt = 0;\n\t\twhile (x > 1) {\n\t\t\tint p = erat[x];\n\t\t\tif (p == last) {\n\t\t\t\t++cnt;\n\t\t\t} else {\n\t\t\t\tans = ans * C(cnt + y - 1, cnt) % mod;\n\t\t\t\tcnt = 1;\n\t\t\t}\n\t\t\tlast = p;\n\t\t\tx /= p;\n\t\t}\n\t\tans = ans * C(cnt + y - 1, cnt) % mod;\n\t\tans = ans * pw(2, y - 1) % mod;\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}