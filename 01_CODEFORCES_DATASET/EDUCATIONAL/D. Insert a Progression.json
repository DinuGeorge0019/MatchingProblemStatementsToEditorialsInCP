{"link": "https://codeforces.com//contest/1671/problem/D", "problemId": "1376218", "shortId": "1671D", "contest_number": "1671", "name": "D. Insert a Progression", "statement": "You are given a sequence of  integers . You are also given  integers .You are asked to insert each of the extra integers into the sequence . Each integer can be inserted at the beginning of the sequence, at the end of the sequence, or between any elements of the sequence.The score of the resulting sequence  is the sum of absolute differences of adjacent elements in it .What is the smallest possible score of the resulting sequence ?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains two integers  and  ()\u00a0\u2014 the length of the sequence and the number of extra integers. The second line of each testcase contains  integers  (). The sum of  over all testcases doesn't exceed .", "output": "For each testcase, print a single integer\u00a0\u2014 the smallest sum of absolute differences of adjacent elements of the sequence after you insert the extra integers into it.", "tutorial": "Observe the cost of inserting a single element. Notice that inserting any value between the minimum of the sequence and the maximum of the sequence is free.Why is this true? The argument is similar to the algorithm of finding some  such that  for a continous function  if you know some  such that  and  such that .As a more general idea, it's free to insert some value  into a segment  such that  and  (WLOG assume ). Let's find the position that is free. If , then you can insert  between  and , since it's free. Otherwise, you can choose an arbitrary position .  will be either between  and  or between  and  (or both of them). Descend into the one that holds to continue the search. Since the lenght decreases, at some point you will reach the segment of length .How does that help? Well, you can insert  somewhere, then insert  somewhere. The rest of insertions will be free.Now it's an algorithmic problem. First, consider all options to insert both  and  between the same pair of elements. Next, assume you insert  somewhere before . Iterate from left to right, maintaning the lowest price to insert . Try to insert  at the current position and  into the cheapest position before it. Then update the lowest price for inserting . After you finish, reverse the sequence and solve the problem again\u00a0\u2014 that will be the same as inserting  before .Overall complexity:  per testcase.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    forn(_, t){\n        int n, x;\n        scanf(\"%d%d\", &n, &x);\n        vector<int> a(n);\n        forn(i, n) scanf(\"%d\", &a[i]);\n        long long ans = 1e18;\n        long long cur = 0;\n        forn(i, n - 1){\n            cur += abs(a[i] - a[i + 1]);\n        }\n        forn(_, 2){\n            long long mn = abs(a[0] - 1);\n            ans = min(ans, cur + abs(a[0] - x) + (x - 1));\n            forn(i, n - 1){\n                ans = min(ans, cur + mn - abs(a[i] - a[i + 1]) + abs(a[i] - x) + abs(a[i + 1] - x));\n                ans = min(ans, cur - abs(a[i] - a[i + 1]) + abs(a[i] - x) + abs(a[i + 1] - 1) + (x - 1));\n                mn = min(mn, 0ll - abs(a[i] - a[i + 1]) + abs(a[i] - 1) + abs(a[i + 1] - 1));\n            }\n            ans = min(ans, cur + mn + abs(a.back() - x));\n            reverse(a.begin(), a.end());\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}