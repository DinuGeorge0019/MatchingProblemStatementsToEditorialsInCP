{"link": "https://codeforces.com//contest/1814/problem/C", "problemId": "1867158", "shortId": "1814C", "contest_number": "1814", "name": "C. Search in Parallel", "statement": "Suppose you have  boxes. The -th box contains infinitely many balls of color . Sometimes you need to get a ball with some specific color; but you're too lazy to do it yourself.You have bought two robots to retrieve the balls for you. Now you have to program them. In order to program the robots, you have to construct two lists  and , where the list  represents the boxes assigned to the first robot, and the list  represents the boxes assigned to the second robot. .When you request a ball with color , the robots work as follows. Each robot looks through the boxes that were assigned to that robot, in the order they appear in the list. The first robot spends  seconds analyzing the contents of a box; the second robot spends . As soon as one of the robots finds the box with balls of color  (and analyzes its contents), the search ends. The search time is the number of seconds from the beginning of the search until one of the robots finishes analyzing the contents of the -th box. If a robot analyzes the contents of all boxes assigned to it, it stops searching.For example, suppose , , , . If you request a ball with color , the following happens:  initially, the first robot starts analyzing the box , and the second robot starts analyzing the box ;  at the end of the -nd second, the first robot finishes analyzing the box . It is not the box you need, so the robot continues with the box ;  at the end of the -rd second, the second robot finishes analyzing the box . It is not the box you need, so the robot continues with the box ;  at the end of the -th second, the first robot finishes analyzing the box . It is not the box you need, so the robot continues with the box ;  at the end of the -th second, the first robot finishes analyzing the box . It is not the box you need, so the robot continues with the box . At the same time, the second robot finishes analyzing the box . It is not the box you need, and the second robot has analyzed all the boxes in its list, so that robot stops searching;  at the end of the -th second, the first robot finishes analyzing the box . It is the box you need, so the search ends;  so, the search time is  seconds. You know that you are going to request a ball of color   times, a ball of color   times, and so on. You want to construct the lists  and  for the robots in such a way that the total search time over all requests is the minimum possible.", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case consists of two lines:    the first line contains three integers , ,  (; );  the second line contains  integers  ().  Additional constraint on the input: the sum of  over all test cases does not exceed .", "output": "For each test case, print two lines. The first line should contain the list , the second line \u2014 the list . Each list has to be printed as follows: first, print the number of elements in it, and then the elements themselves. If there are multiple answers, you may print any of them.", "tutorial": "If the ball of color $$$x$$$ is present in the first list on position $$$i$$$, then it takes $$$i \\cdot t_1$$$ seconds to find it. The same for the second list: if color $$$x$$$ is on position $$$j$$$, it takes $$$j \\cdot t_2$$$ seconds to find it. So, for each position, we have a coefficient which will be multiplied by the number of times it is requested, and the total search time is the sum of these products for all positions.There is a classical problem of the form \"you are given two arrays $$$a_i$$$ and $$$b_i$$$, both of length $$$m$$$, consisting of non-negative integers; permute the elements of $$$a$$$ in such a way that $$$\\sum\\limits_{i=1}^{m} a_i \\cdot b_i$$$ is the minimum possible\". To solve this problem, you have to pair the maximum element of $$$a$$$ with the minimum element of $$$b$$$, the second maximum of $$$a$$$ with the second minimum element of $$$b$$$, and so on.We can reduce our problem to this one. For each of $$$2n$$$ positions in the lists, there is a coefficient; you have to assign the boxes from $$$1$$$ to $$$n$$$ to the positions so that the sum of $$$r_i$$$ multiplied by the coefficients for the positions is the minimum possible. This looks similar, but there are $$$2n$$$ positions and only $$$n$$$ boxes.To resolve this issue, we can try a lot of different approaches. I believe the easiest one is the following: initially, both lists are empty, and when want to add an element to one of these two lists, we choose the list such that the coefficient for the new position (which is $$$s_i \\cdot (1 + cnt_i)$$$, where $$$cnt_i$$$ is the number of elements we already added to the $$$i$$$-th list) is smaller. If for both lists, adding a new element has the same coefficient \u2014 it doesn't matter which one we choose.This greedy approach works because every time we add an element to the list, next time we'll add another one into the same list, the coefficient for that element will be greater.So, the problem can be solved in $$$O(n \\log n)$$$: first, we sort the boxes by the number of times they are requested (in non-ascending order), and then we put them into the two lists greedily, every time choosing the list such that the coefficient for the next element is smaller.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor(int i = 0; i < t; i++)\n\t{\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tvector<int> s(2);\n\t\tfor(int j = 0; j < 2; j++)\n\t\t\tscanf(\"%d\", &s[j]);\n\t\tvector<pair<int, int>> a(n);\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tscanf(\"%d\", &a[j].first);\n\t\t\ta[j].second = j + 1;\n\t\t}\n\t\tsort(a.begin(), a.end());\n\t\treverse(a.begin(), a.end());\n\t\tvector<vector<int>> lists(2);\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tint cost1 = s[0] * (lists[0].size() + 1);\n\t\t\tint cost2 = s[1] * (lists[1].size() + 1);\n\t\t\tif(cost1 < cost2)\n\t\t\t\tlists[0].push_back(a[j].second);\n\t\t\telse\n\t\t\t\tlists[1].push_back(a[j].second);\n\t\t}\n\t\tfor(int j = 0; j < 2; j++)\n\t\t{\n\t\t    cout << lists[j].size();\n\t\t    for(auto x : lists[j]) cout << \" \" << x;\n\t\t    cout << endl;\n\t\t}\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}