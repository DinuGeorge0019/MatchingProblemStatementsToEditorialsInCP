{"link": "https://codeforces.com//contest/1207/problem/G", "problemId": "393977", "shortId": "1207G", "contest_number": "1207", "name": "G. Indie Album", "statement": "Mishka's favourite experimental indie band has recently dropped a new album! Songs of that album share one gimmick. Each name  is one of the following types:   \u2014 a single lowercase Latin letter;   \u2014 name  () with a single lowercase Latin letter appended to its end. Songs are numbered from  to . It's guaranteed that the first song is always of type .Vova is rather interested in the new album but he really doesn't have the time to listen to it entirely. Thus he asks Mishka some questions about it to determine if some song is worth listening to. Questions have the following format:   \u2014 count the number of occurrences of string  in  (the name of the -th song of the album) as a continuous substring,  consists only of lowercase Latin letters. Mishka doesn't question the purpose of that information, yet he struggles to provide it. Can you please help Mishka answer all Vova's questions?", "input": "The first line contains a single integer  () \u2014 the number of songs in the album. Each of the next  lines contains the desciption of the -th song of the album in the following format:    \u2014  is a single lowercase Latin letter;   \u2014  is the name  () with a single lowercase Latin letter appended to its end.  The next line contains a single integer  () \u2014 the number of Vova's questions. Each of the next  lines contains the desciption of the -th Vova's question in the following format:    (, ) \u2014 count the number of occurrences of string  in  (the name of the -th song of the album) as a continuous substring,  consists only of lowercase Latin letters.  .", "output": "For each question print a single integer \u2014 the number of occurrences of the question string  in the name of the -th song of the album as a continuous substring.", "tutorial": "There is a common approach for the problem \"you are given a lot of strings and texts, count the number of occurences of the strings in the texts\" \u2014 build an Aho-Corasick automaton on the given strings and somehow process the texts with it. Let's see if it can handle this problem.The names of the songs can be represented as a tree. We may build an Aho-Corasick on the strings given in the queries, then try to input the names of the album into the automaton character-by-character with DFS on the aforementioned tree (feeding a character to the automaton when we enter a node, and reverting the automaton to the previous state when we leave that node). Suppose that when we are in the vertex corresponding to the -th song, the automaton is in state . If  is a terminal state corresponding to some string from the queries, it means that the string from the query is a suffix of the -th song. But some other strings can also be the suffixes of the same song \u2014 to find all such strings, we can start ascending from the state  to the root of Aho-Corasick automaton using suffix links or dictionary links. Since suffix links can be represented as the edges of some rooted tree, then we can build some data structure on this tree that allows adding an integer to all vertices on the path from the root to the given vertex (for example, we can use Fenwick tree over Euler tour of the tree). Then, to check whether some string  from the query is a suffix of the song , we may add  to all vertices on the path to state , and then check the value in the state corresponding to .Okay, what about counting the occurences of  in ? Let's consider the path from the root to  in the \"song tree\". Every vertex on this path corresponds to some prefix of the song , so we can add  on the path to  state corresponding to some prefix, and then extract the answer from the state corresponding to .In fact, that's all we have to do to obtain a solution. Build an automaton on strings from queries, a tree of suffix links over this automaton, and a data structure on this tree; for each vertex of the song tree, store all queries to it. Then run a DFS on the song tree. When we enter some vertex, input the corresponding character into the automaton and add  to all states from the root of suffix link tree to the current state; when we have to process queries to the current vertex, extract the values from the data structure; and when we leave a vertex, subtract  from all states from the root of suffix link tree to the current state, and revert to the previous state.This solution has complexity of , where  is the total length of all strings in the input.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int AL = 26;\nconst int N = 400 * 1000 + 13;\n\nstruct node{\n    int nxt[AL];\n    node(){\n        memset(nxt, -1, sizeof(nxt));\n    }\n    int& operator [](int x){\n        return nxt[x];\n    }\n};\n\nstruct node_at{\n    int nxt[AL];\n    int p;\n    char pch;\n    int link;\n    int go[AL];\n    node_at(){\n        memset(nxt, -1, sizeof(nxt));\n        memset(go, -1, sizeof(go));\n        link = p = -1;\n    }\n    int& operator [](int x){\n        return nxt[x];\n    }\n};\n\nint cntnm;\nnode trienm[N];\n\nint cntqr;\nnode_at trieqr[N];\n\nint add_string(string s){\n    int v = 0;\n    for (auto it : s){\n        int c = it - 'a';\n        if (trieqr[v][c] == -1){\n            trieqr[cntqr] = node_at();\n            trieqr[cntqr].p = v;\n            trieqr[cntqr].pch = c;\n            trieqr[v][c] = cntqr;\n            ++cntqr;\n        }\n        v = trieqr[v][c];\n    }\n    return v;\n}\n\nint go(int v, int c);\n \nint get_link(int v){\n    if (trieqr[v].link == -1){\n        if (v == 0 || trieqr[v].p == 0)\n            trieqr[v].link = 0;\n        else\n            trieqr[v].link = go(get_link(trieqr[v].p), trieqr[v].pch);\n    }\n    return trieqr[v].link;\n}\n \nint go(int v, int c) {\n    if (trieqr[v].go[c] == -1){\n        if (trieqr[v][c] != -1)\n            trieqr[v].go[c] = trieqr[v][c];\n        else\n            trieqr[v].go[c] = (v == 0 ? 0 : go(get_link(v), c));\n    }\n    return trieqr[v].go[c];\n}\n\nint add_letter(int v, int c){\n    if (trienm[v][c] == -1){\n        trienm[cntnm] = node();\n        trienm[v][c] = cntnm;\n        ++cntnm;\n    }\n    return trienm[v][c];\n}\n\nvector<int> g[N];\nint tin[N], tout[N], T;\n\nvoid dfs_init(int v){\n    tin[v] = T++;\n    for (auto u : g[v])\n        dfs_init(u);\n    tout[v] = T;\n}\n\nint f[N];\n\nvoid upd(int v, int val){\n    for (int i = tin[v]; i < N; i |= i + 1)\n        f[i] += val;\n}\n\nint get(int x){\n    int sum = 0;\n    for (int i = x; i >= 0; i = (i & (i + 1)) - 1)\n        sum += f[i];\n    return sum;\n}\n\nint sum(int v){\n    return get(tout[v] - 1) - get(tin[v] - 1);\n}\n\nint n, m;\nint nm[N], qr[N];\nvector<int> nms[N];\nvector<int> reqs[N];\nint ans[N];\n\nvoid dfs(int v, int cur){\n    upd(cur, 1);\n    for (auto it : nms[v])\n        for (auto q : reqs[it])\n            ans[q] = sum(qr[q]);\n    forn(i, AL) if (trienm[v][i] != -1)\n        dfs(trienm[v][i], go(cur, i));\n    upd(cur, -1);\n}\n\nint main(){\n    cntqr = 0;\n    trieqr[cntqr++] = node_at();\n    \n    cntnm = 0;\n    trienm[cntnm++] = node();\n    \n    char buf[N];\n    scanf(\"%d\", &n);\n    forn(i, n){\n        int t;\n        scanf(\"%d\", &t);\n        if (t == 1){\n            scanf(\"%s\", buf);\n            nm[i] = add_letter(0, buf[0] - 'a');\n        }\n        else{\n            int j;\n            scanf(\"%d%s\", &j, buf);\n            --j;\n            nm[i] = add_letter(nm[j], buf[0] - 'a');\n        }\n        nms[nm[i]].push_back(i);\n    }\n    \n    scanf(\"%d\", &m);\n    forn(i, m){\n        int j;\n        scanf(\"%d%s\", &j, buf);\n        --j;\n        reqs[j].push_back(i);\n        qr[i] = add_string(buf);\n    }\n    \n    for (int v = 1; v < cntqr; ++v)\n        g[get_link(v)].push_back(v);\n    \n    T = 0;\n    dfs_init(0);\n    dfs(0, 0);\n    \n    forn(i, m)\n        printf(\"%d\\n\", ans[i]);\n}", "interactive": false, "noSolution": false, "noTutorial": false}