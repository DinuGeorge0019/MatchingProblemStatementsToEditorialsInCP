{"link": "https://codeforces.com//contest/1076/problem/G", "problemId": "253931", "shortId": "1076G", "contest_number": "1076", "name": "G. Array Game", "statement": "Consider a following game between two players:There is an array , , ..., , consisting of positive integers. Initially a chip is placed into the first cell of the array, and  is decreased by . Players move in turns. Each turn the current player has to do the following: if the index of the cell where the chip is currently placed is , then he or she has to choose an index  such that , move the chip to the cell  and decrease  by . If it's impossible to make a valid move, the current player loses the game.Your task is the following: you are given an array  consisting of  positive integers, and  queries to it. There are two types of queries:     \u2014 for every  increase  by ;     \u2014 tell who is the winner of the game that is played on the subarray of  from index  to index  inclusive. Assume both players choose an optimal strategy.", "input": "The first line contains three integers ,  and  (, ) \u2014 the number of elements in , the parameter described in the game and the number of queries, respectively. The second line contains  integers , , ...,  () \u2014 the elements of array . Then  lines follow, each containing a query. There are two types of queries. The query of the first type is denoted by a line     (, ) and means that for every  you should increase  by . The query of the second type is denoted by a line    () and means that you have to determine who will win the game if it is played on the subarray of  from index  to index  (inclusive). There is at least one query of type .", "output": "For each query of type  print  if the first player wins in the corresponding game, or  if the second player wins.", "tutorial": "Suppose there is only one query, i.\u2009e. we are given some array and we want to know who is the winner if the game is played on this array. One of the obvious solutions is  \u2014 will the current player win if the chip is currently in the cell  and the number in cell  is . We can already see that we don't need to know the exact value of , we only want to know whether it's odd: if there is a cell  such that we can go from  to  and  is a state where current player will lose, then we should go to this cell since our opponent will enter a losing state of the game. Otherwise, we want to force our opponent to move out of cell , and we can do so only if  is odd. So we found a dynamic programming solution with  states, but what is more important is that we can take all the elements in our array modulo .Okay, now let's solve the problem when there are only queries of type  (no modifications). Since when calculating the  values we are interested only in  next cells, and there are only  variants of whether these cells are \"winning\" or \"losing\", we may consider each element of the array as a function that maps a mask of  next states into a new mask of  states if we pushed our new element into the front. For example, if the -th element is even and states , , , ,  are winning, losing, losing, winning and losing respectively, and , then we may consider a mask of next states as ; and then we can check if -th state is winning and push a bit to the front of this mask, discarding the last bit; since new state is winning, we will get a mask of . It allows us to denote two functions  and  \u2014 what will be the resulting mask of next  states, if current mask is  and we push an even or odd element to the front.Okay, what about pushing more than one element? We can just take the composition of their functions! Since a function can be stored as an array of  integers and the composition needs only  time to be calculated, then we can build a segment tree over the elements of the array, and store a composition of all functions on the segment in each node. This allows us to answer queries of type  in .The only thing that's left is additions on segment. Adding an even number is easy: just ignore this query. To be able an odd number, let's store another function in each node of the segment tree which would be the composition of all functions on the segment if we would add  to all elements on the segment (so the elements which were odd become even, and vice versa). This allows us to use lazy propagation: if the query affects the whole node, we may just swap two functions in it and push the query to the children of this node.Overall complexity is . It turns out (we didn't think about it before the contest, but some contestants submitted such solutions) that it can be reduced to  if we will use the distance to closest losing state instead of a mask of winning and losing states.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\ntypedef long long li;\n\nint n, m;\nli a[N];\nint q;\nint f[N * 4];\nvector<int> T[4 * N];\nvector<int> T2[4 * N];\nint mask;\nint cur;\n\nvector<int> combine(const vector<int>& a, const vector<int>& b)\n{\n\tvector<int> c(1 << m);\n\tfor(int i = 0; i < (1 << m); i++)\n\t\tc[i] = b[a[i]];\n\treturn c;\n}\n\nvector<int> init(li x)\n{\n\tvector<int> ans(1 << m);\n\tfor(int i = 0; i < (1 << m); i++)\n\t{\n\t\tif(i != mask || (x & 1) == 0)\n\t\t\tans[i] = ((i << 1) & mask) ^ 1;\n\t\telse\n\t\t\tans[i] = ((i << 1) & mask);\n\t}\t\n\treturn ans;\n}\n\nvoid upd(int v)\n{\n\tT[v] = combine(T[v * 2 + 2], T[v * 2 + 1]);\n\tT2[v] = combine(T2[v * 2 + 2], T2[v * 2 + 1]);\n}\n\nvoid build(int v, int l, int r)\n{\n\tif(l == r - 1)\n\t{\n\t\tT[v] = init(a[l]);\n\t\tT2[v] = init(a[l] ^ 1);\n\t\treturn;\n\t}\n\tint m = (l + r) >> 1;\n\tbuild(v * 2 + 1, l, m);\n\tbuild(v * 2 + 2, m, r);\n\tupd(v);\n}\n\nvoid push(int v, int l, int r)\n{\n\tif(f[v])\n\t{\n\t\tswap(T[v], T2[v]);\n\t\tif(l != r - 1)\n\t\t{\n\t\t\tf[v * 2 + 1] ^= 1;\n\t\t\tf[v * 2 + 2] ^= 1;\n\t\t}\n\t\tf[v] = 0;\n\t}\n}\n\nvector<int> id;\n\nvoid get(int v, int l, int r, int L, int R)\n{\n\tpush(v, l, r);\n\tif(L >= R)\n\t\treturn;\n\tif(l == L && r == R)\n\t{\n\t\tcur = T[v][cur];\n\t}\n\telse\n\t{\n\t\tint m = (l + r) >> 1;\n\t\tget(v * 2 + 2, m, r, max(L, m), R);\n\t\tget(v * 2 + 1, l, m, L, min(R, m));\n\t\tupd(v);\t\n\t}\n}\n\nvoid add(int v, int l, int r, int L, int R)\n{\n\tpush(v, l, r);\n\tif(L >= R)\n\t\treturn;\n\tif(l == L && r == R)\n\t{\n\t\tf[v] ^= 1;\n\t\tpush(v, l, r);\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tint m = (l + r) >> 1;\n\t\tadd(v * 2 + 1, l, m, L, min(R, m));\n\t\tadd(v * 2 + 2, m, r, max(L, m), R);\n\t\tupd(v);\n\t}\n}\n\nint main() \n{ \n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tmask = (1 << m) - 1;\n\tfor(int i = 0; i < (1 << m); i++)\n\t\tid.push_back(i);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%lld\", &a[i]);\n\tbuild(0, 0, n);\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint t, l, r;\n\t\tscanf(\"%d %d %d\", &t, &l, &r);\n\t\t--l;\n\t\tif(t == 1)\n\t\t{\n\t\t\tli d;\n\t\t\tscanf(\"%lld\", &d);\n\t\t\tif(d & 1)\n\t\t\t\tadd(0, 0, n, l, r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcur = mask;\n\t\t\tget(0, 0, n, l, r);\n\t\t\t\n\t\t\tif((cur & 1) == 1)\n\t\t\t\tputs(\"1\");\n\t\t\telse\n\t\t\t\tputs(\"2\");\n\t\t}\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}