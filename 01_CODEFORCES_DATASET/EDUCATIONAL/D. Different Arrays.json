{"link": "https://codeforces.com//contest/1783/problem/D", "problemId": "1728813", "shortId": "1783D", "contest_number": "1783", "name": "D. Different Arrays", "statement": "You are given an array  consisting of  integers.You  perform the sequence of  operations on this array:  during the first operation, you either add  to  and subtract  from , or add  to  and subtract  from ;  during the second operation, you either add  to  and subtract  from , or add  to  and subtract  from ;  ...  during the last operation, you either add  to  and subtract  from , or add  to  and subtract  from . So, during the -th operation, you add the value of  to one of its neighbors, and subtract it from the other neighbor.For example, if you have the array , one of the possible sequences of operations is:  subtract  from  and add it to , so the array becomes ;  subtract  from  and add it to , so the array becomes ;  subtract  from  and add it to , so the array becomes . So, the resulting array is .An array is  if it can be obtained by performing the aforementioned sequence of operations on . You have to calculate the number of reachable arrays, and print it modulo .", "input": "The first line contains one integer  (). The second line contains  integers  ().", "output": "Print one integer \u2014 the number of reachable arrays. Since the answer can be very large, print its remainder modulo .", "tutorial": "One of the key observations to this problem is that, after the first  operations, the first  elements of the array are fixed and cannot be changed afterwards. Also, after the -th operation, the elements on positions from  to  are the same as they were before applying the operations.This allows us to write the following dynamic programming:  \u2014 the number of different prefixes our array can have, if we have performed  operations, the -th element is , and the -th element is . The elements after  are the same as in the original array, and the elements before  won't be changed anymore, so we are interested only in these two elements.Let's analyze the transitions in this dynamic programming. We apply the operation  to the elements ,  and . If we add  to , then we subtract it from , so we transition into state . Otherwise, we transition into state . The element we leave behind is either  or , and if , these two transitions give us different prefixes. But if , we need to make only one of these transitions, because adding or subtracting  actually makes no difference.Okay, now we've got a solution with dynamic programming in , where  is up to  and  is up to . This is too slow. But we can notice that the value of  actually does not affect our transitions at all; we can just discard it, so our dynamic programming becomes , which easily fits into TL.Small implementation note: elements can become negative, and in order to store dynamic programming with negative states in an array, we need to do something about that. I don't recommend using maps (neither ordered nor unordered): you either get an extra log factor, or make your solution susceptible to hacking. Instead, let's say that the value of , where  can be a negative number, will be stored as  in the array, where  is some constant which is greater than the maximum possible  (for example,  in this problem). That way, all array indices will be non-negative.Solution complexity: .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    return x;\n}   \n\nconst int ZERO = 100000;\n\nint dp[2][ZERO * 2];\n\nvoid recalc(int x)\n{\n    for(int i = 0; i < ZERO * 2; i++)\n        dp[1][i] = 0;\n\n    for(int i = 0; i < ZERO * 2; i++)\n    {\n        if(dp[0][i] == 0) continue;\n        int nx = x + i;\n        dp[1][nx] = add(dp[1][nx], dp[0][i]);\n        if(nx != ZERO)\n            dp[1][2 * ZERO - nx] = add(dp[1][2 * ZERO - nx], dp[0][i]);\n    }\n\n    for(int i = 0; i < ZERO * 2; i++)\n        dp[0][i] = dp[1][i];\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; i++)\n        cin >> a[i];\n    dp[0][ZERO] = 1;\n    for(int i = 1; i + 1 < n; i++)\n        recalc(a[i]);\n    int ans = 0;\n    for(int i = 0; i < ZERO * 2; i++)\n        ans = add(ans, dp[0][i]);\n    cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}