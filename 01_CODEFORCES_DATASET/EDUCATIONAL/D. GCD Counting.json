{"link": "https://codeforces.com//contest/1101/problem/D", "problemId": "281057", "shortId": "1101D", "contest_number": "1101", "name": "D. GCD Counting", "statement": "You are given a tree consisting of  vertices. A number is written on each vertex; the number on vertex  is equal to .Let's denote the function  as the greatest common divisor of the numbers written on the vertices belonging to the simple path from vertex  to vertex  (including these two vertices). Also let's denote  as the number of vertices on the simple path between vertices  and , including the endpoints.  for every vertex .Your task is calculate the maximum value of  among such pairs of vertices that .", "input": "The first line contains one integer  \u2014 the number of vertices . The second line contains  integers , , ...,   \u2014 the numbers written on vertices. Then  lines follow, each containing two integers  and   denoting an edge connecting vertex  with vertex . It is guaranteed that these edges form a tree.", "output": "If there is no pair of vertices  such that , print . Otherwise print the maximum value of  among such pairs.", "tutorial": "I know there exists  solution and author of the problem promises to tell it to you (here he explained it). I'd love to tell easier to code and about the same time to work  solution.At first, notice that it is only enough to check the paths such that all vertices on it is divisible by some prime.Let's for each  calculate the path of the maximum length to pass through it. That means that one part of this path goes down to one child of it and another part goes down to another child.For each vertex we will store the lengths of maximum paths through vertices with values divisible by each prime in . That is  memory. To recalc the answer we will store all values of children nodes, sort them and update the answer with two pointers technique.Don't forget about the case of !Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define sqr(a) ((a) * (a))\n#define sz(a) int(a.size())\n#define all(a) a.begin(), a.end()\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate <class A, class B> ostream& operator << (ostream& out, const pair<A, B> &a) {\n\treturn out << \"(\" << a.x << \", \" << a.y << \")\";\n}\n\ntemplate <class A> ostream& operator << (ostream& out, const vector<A> &v) {\n\tout << \"[\";\n\tforn(i, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nmt19937 rnd(time(NULL));\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst int MOD = INF + 7;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n\nconst int N = 200 * 1000 + 13;\n\nint n;\nint a[N];\nvector<int> g[N];\n\nbool read () {\n\tif (scanf(\"%d\", &n) != 1)\n\t\treturn false;\n\tforn(i, n)\n\t\tg[i].clear();\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\tforn(i, n - 1){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\t--x, --y;\n\t\tg[x].pb(y);\n\t\tg[y].pb(x);\n\t}\n\treturn true;\n}\n\nvector<pt> dp[N];\nint ans;\n\nvoid calc(int v, int p = -1){\n\tvector<pt> chd;\n\tfor (auto u : g[v]) if (u != p){\n\t\tcalc(u, v);\n\t\tfor (auto it : dp[u])\n\t\t\tchd.pb(it);\n\t}\n\t\n\tsort(all(chd));\n\tforn(i, sz(chd)){\n\t\tint j = i - 1;\n\t\tint mx1 = 0, mx2 = 0;\n\t\twhile (j + 1 < sz(chd) && chd[j + 1].x == chd[i].x){\n\t\t\t++j;\n\t\t\tif (chd[j].y >= mx1)\n\t\t\t\tmx2 = mx1, mx1 = chd[j].y;\n\t\t\telse if (chd[j].y > mx2)\n\t\t\t\tmx2 = chd[j].y;\n\t\t}\n\t\tif (a[v] % chd[i].x == 0){\n\t\t\tans = max(ans, mx1 + mx2 + 1);\n\t\t\tdp[v].pb(mp(chd[i].x, mx1 + 1));\n\t\t\twhile (a[v] % chd[i].x == 0)\n\t\t\t\ta[v] /= chd[i].x;\n\t\t}\n\t\telse{\n\t\t\tans = max(ans, mx1);\n\t\t}\n\t\ti = j;\n\t}\n\t\n\tfor (int i = 2; i * i <= a[v]; ++i) if (a[v] % i == 0){\n\t\tdp[v].pb(mp(i, 1));\n\t\tans = max(ans, 1);\n\t\twhile (a[v] % i == 0)\n\t\t\ta[v] /= i;\n\t}\n\t\n\tif (a[v] > 1){\n\t\tdp[v].pb(mp(a[v], 1));\n\t\tans = max(ans, 1);\n\t}\n}\n\nvoid solve() {\n\tforn(i, N) dp[i].clear();\n\tans = 0;\n\tcalc(0);\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\t\n\tint tt = clock();\n\t\n#endif\n\t\n\tcerr.precision(15);\n\tcout.precision(15);\n\tcerr << fixed;\n\tcout << fixed;\n\n#ifdef _DEBUG\n\twhile(read()) {\t\n#else\n\tif (read()){\n#endif\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\tcerr << \"TIME = \" << clock() - tt << endl;\n\ttt = clock();\n#endif\n\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}