{"link": "https://codeforces.com//contest/1389/problem/B", "problemId": "686123", "shortId": "1389B", "contest_number": "1389", "name": "B. Array Walk", "statement": "You are given an array , consisting of   integers. Initially you are standing at index  and have a score equal to . You can perform two kinds of moves:   move right\u00a0\u2014 go from your current index  to  and add  to your score. This move can only be performed if .  move left\u00a0\u2014 go from your current index  to  and add  to your score. This move can only be performed if .  You want to perform   moves. Also, there should be no more than  moves to the left among them.What is the maximum score you can achieve?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains three integers  and  (, , )\u00a0\u2014 the number of elements in the array, the total number of moves you should perform and the maximum number of moves to the left you can perform. The second line of each testcase contains  integers  ()\u00a0\u2014 the given array. The sum of  over all testcases does not exceed .", "output": "Print  integers\u00a0\u2014 for each testcase output the maximum score you can achieve if you make exactly  moves in total, no more than  of them are to the left and there are no two or more moves to the left in a row.", "tutorial": "Notice that your final position is determined by the number of moves to the left you make. Let there be exactly  moves to the left, that leaves us with  moves to the right. However, let's interpret this the other way. You have  pairs of moves (right, left) to insert somewhere inside the sequence of  moves to the right.Easy to see that all the positions from  to  will always be visited. And the extra pairs can also increase the score by visiting some positions (, ) for some  from  to .Notice that it's always optimal to choose exactly the same  for all the pairs (right, left). And that  should be such that  is maximum possible.You can implement this idea in a straightforward manner: iterate over  and calculate the sum of values from  to  and the maximum value of  over  from  to .That will lead to a  solution per testcase.You can optimize it to  with prefix sums or with some clever order to iterate over . It's also possible to iterate over the final position and restore the number of left moves required to achieve it.Overall complexity:  or  per testcase.", "solution": "for _ in range(int(input())):\n\tn, k, z = map(int, input().split())\n\ta = [int(x) for x in input().split()]\n\tans = 0\n\ts = 0\n\tmx = 0\n\tfor t in range(z + 1):\n\t\tpos = k - 2 * t\n\t\tif pos < 0:\n\t\t\tcontinue\n\t\tmx = 0\n\t\ts = 0\n\t\tfor i in range(pos + 1):\n\t\t\tif i < n - 1:\n\t\t\t\tmx = max(mx, a[i] + a[i + 1])\n\t\t\ts += a[i]\n\t\tans = max(ans, s + mx * t)\n\tprint(ans)", "interactive": false, "noSolution": false, "noTutorial": false}