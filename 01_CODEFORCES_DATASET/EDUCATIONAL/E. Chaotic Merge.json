{"link": "https://codeforces.com//contest/1499/problem/E", "problemId": "928253", "shortId": "1499E", "contest_number": "1499", "name": "E. Chaotic Merge", "statement": "You are given two strings  and , both consist only of lowercase Latin letters. Let  be the length of string .Let's call a sequence  a merging sequence if it consists of exactly  zeros and exactly  ones in some order.A merge  is produced from a sequence  by the following rules:   if , then remove a letter from the beginning of  and append it to the end of ;  if , then remove a letter from the beginning of  and append it to the end of . Two merging sequences  and  are different if there is some position  such that .Let's call a string   if for all  from  to  .Let  for some  be a substring of consecutive letters of , starting from position  and ending at position  inclusive.Let  be the number of different merging sequences of  and  that produce  merges. Note that only non-empty substrings of  and  are considered.Calculate . Output the answer modulo .", "input": "The first line contains a string  (). The second line contains a string  (). Both strings consist only of lowercase Latin letters.", "output": "Print a single integer\u00a0\u2014 the sum of  over  and  modulo .", "tutorial": "First, let's try to calculate the number of merging sequences just for some fixed pair of strings  and .Imagine we build a merge letter by letter. So far  letters are in the merge already. For the -th letter we can pick a letter from either string  or string  (put a  or a  into the merging sequence, respectively). What constraints our choice? Easy to see that it's only the -th letter of the merge. So we can come up with the following dynamic programming. is the number of merging sequences such that  characters from  are taken,  characters from  are taken and the last character of the merge is .  can be either just a letter (a dimension of size ) or an indicator of a string the last character was taken from ( for string  and  from string ). Since we know how many characters are taken from each string, we can easily decide the last taken character from that indicator. For each transition we can just take a character from either of the strings.The sum of  over all  will be the total number of merging sequences.Now for the substrings. Recall the following definition of a substring:  is a substring of  if you can remove some characters from the beginning of  (possibly, none or all) and some characters from the end of  (possibly, none or all) to get the string .What if we incorporated that definition into our dynamic programming? Let  be the number of merging sequences that end exactly before the -th character of , exactly before the -th character of  and the last character is still .How to remove some characters from the beginning? That actually is the same as attempting to start the merge from every state of dp. So, if we are currently in some state , then we can act as if we have just taken the -th character of  or the -th character of  as the first character of the merge.How to remove some characters from the end? Since  is the number of merging sequences that end exactly there, why not just sum up all the values of dynamic programming into the answer? We will count the sequences that end in all possible positions of both strings.That is almost the answer to the task. The only issue we have is that we forgot the condition that asks us to get a non-empty substring from each string. Well, there are multiple ways to resolve the issue.We can remove bad sequences afterwards: their count is the number of chaotic substrings of  multiplied by all possible empty substrings of  (there are  of them) plus the same thing for  and . These can be counted with two pointers. Alternatively, we can add an extra dimension or two to the dp to indicate if we have ever taken a character from  and from . So we get  with  and  being binary flags that tell if a character from  and from  was ever taken. That way we can only push the states with both flags set to true to the answer.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\tif (a < 0)\n\t\ta += MOD;\n\treturn a;\n}\n\nint main() {\n\tstring s, t;\n\tcin >> s >> t;\n\tint n = s.size(), m = t.size();\n\tvector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(m + 1, vector<int>(2, 0)));\n\tint ans = 0;\n\tforn(i, n + 1) forn(j, m + 1){\n\t\tif (i < n) dp[i + 1][j][0] = add(dp[i + 1][j][0], 1);\n\t\tif (j < m) dp[i][j + 1][1] = add(dp[i][j + 1][1], 1);\n\t\tif (0 < i && i < n && s[i - 1] != s[i]) dp[i + 1][j][0] = add(dp[i + 1][j][0], dp[i][j][0]);\n\t\tif (0 < j && i < n && t[j - 1] != s[i]) dp[i + 1][j][0] = add(dp[i + 1][j][0], dp[i][j][1]);\n\t\tif (0 < i && j < m && s[i - 1] != t[j]) dp[i][j + 1][1] = add(dp[i][j + 1][1], dp[i][j][0]);\n\t\tif (0 < j && j < m && t[j - 1] != t[j]) dp[i][j + 1][1] = add(dp[i][j + 1][1], dp[i][j][1]);\n\t\tans = add(ans, dp[i][j][0]);\n\t\tans = add(ans, dp[i][j][1]);\n\t}\n\tforn(i, n){\n\t\tint j = i;\n\t\twhile (j + 1 < n && s[j] != s[j + 1]) ++j;\n\t\tint len = j - i + 1;\n\t\tint val = (len * 1ll * (len + 1) / 2) % MOD * (m + 1) % MOD;\n\t\tans = add(ans, -val);\n\t\ti = j;\n\t}\n\tforn(i, m){\n\t\tint j = i;\n\t\twhile (j + 1 < m && t[j] != t[j + 1]) ++j;\n\t\tint len = j - i + 1;\n\t\tint val = (len * 1ll * (len + 1) / 2) % MOD * (n + 1) % MOD;\n\t\tans = add(ans, -val);\n\t\ti = j;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}