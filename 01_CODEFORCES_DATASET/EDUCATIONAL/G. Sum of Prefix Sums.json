{"link": "https://codeforces.com//contest/1303/problem/G", "problemId": "538606", "shortId": "1303G", "contest_number": "1303", "name": "G. Sum of Prefix Sums", "statement": "We define the  of an array  as .You are given a tree consisting of  vertices. Each vertex  has an integer  written on it. We define the value of the  path from vertex  to vertex  as follows: consider all vertices appearing on the path from  to , write down all the numbers written on these vertices in the order they appear on the path, and compute the  of the resulting sequence.Your task is to calculate the maximum value over all paths in the tree.", "input": "The first line contains one integer  () \u2014 the number of vertices in the tree. Then  lines follow, representing the edges of the tree. Each line contains two integers  and  (, ), denoting an edge between vertices  and . It is guaranteed that these edges form a tree. The last line contains  integers , , ...,  ().", "output": "Print one integer \u2014 the maximum value over all paths in the tree.", "tutorial": "Let's use centroid decomposition to solve the problem. We need to process all the paths going through each centroid somehow.Consider a path from vertex  to vertex  going through vertex , which is an ancestor of both  and  in the centroid decomposition tree. Suppose the sequence of numbers on path from  to  (including both these vertices) is , and the sequence of numbers on path from  to  (including , but excluding ) is . Let , , and . We can show that the sum of prefix sums of  is equal to .Now, suppose we fix the second part of the path ( and  are fixed), and we want to find the best first part for this second part. Each possible first part is represented by a linear function, and our goal is to find the maximum over all these linear functions in the point , and add  to this maximum. This can be done with the help of convex hull or Li Chao tree.The most difficult part of implementation is how to process each centroid's subtree. It's easy to obtain all \"first parts\" and \"second parts\" of paths going through the centroid, but pairing them up can be complicated \u2014 for each second part, we have to build a convex hull or Li Chao tree on all first parts going to this centroid, excluding those which go through the same child of the centroid as the \"second part\" we are considering. One of the best ways to implement this is the following. Suppose our centroid has  children,  is the set of \"first parts\" going from the -th child of the centroid, and  is the set of \"second parts\" going to the -th child. We will create a new data structure (initially empty), process all second parts from , add all first parts from , process all second parts from , add all first parts from , and so on. After that, we will clear our data structure, process all second parts from , add all first parts from , process all second parts from , add all first parts from , and so on, until we add all first parts from . That way we will consider all possible first parts for each second part we are trying to use.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 150043;\n\ntypedef pair<long long, long long> func;\n\nfunc T[4 * N];\nbool usedT[4 * N];\n\nvoid clear(int v, int l, int r)\n{\n    if(!usedT[v]) return;\n    usedT[v] = false;\n    T[v] = make_pair(0ll, 0ll);\n    if(l < r - 1)\n    {\n        int m = (l + r) / 2;\n        clear(v * 2 + 1, l, m);\n        clear(v * 2 + 2, m, r);\n    }\n}\n\nlong long eval(func f, int x)\n{\n    return f.first * x + f.second;\n}\n\nlong long get(int v, int l, int r, int x)\n{\n    long long ans = eval(T[v], x);\n    if(l < r - 1)\n    {\n        int m = (l + r) / 2;\n        if(m > x)\n            ans = max(ans, get(v * 2 + 1, l, m, x));\n        else\n            ans = max(ans, get(v * 2 + 2, m, r, x));\n    }\n    return ans;\n}\n\nvoid upd(int v, int l, int r, func f)\n{\n    usedT[v] = true;\n    int m = (l + r) / 2;\n    bool need_swap = eval(f, m) > eval(T[v], m);\n    if(need_swap)\n        swap(T[v], f);\n    if(l == r - 1)\n        return;\n    if(eval(f, l) > eval(T[v], l))\n        upd(v * 2 + 1, l, m, f);\n    else\n        upd(v * 2 + 2, m, r, f);\n}\n\nlong long ans = 0;\n\nvoid update_ans(vector<vector<func> > heads, vector<vector<func> > tails)\n{\n    int n = heads.size();\n    for(int i = 0; i < n; i++)\n    {\n        for(auto x : heads[i])\n            ans = max(ans, get(0, 0, N, x.first) + x.second);\n        for(auto x : tails[i])\n            upd(0, 0, N, x);\n    }\n    clear(0, 0, N);\n}\n\nint a[N];\nvector<int> g[N];\nint n;\nbool used[N];\nint siz[N];\n\nvoid dfs1(int x, int p = -1)\n{\n    if(used[x]) return;\n    siz[x] = 1;\n    for(auto to : g[x])\n    {                    \n        if(!used[to] && to != p)\n        {\n            dfs1(to, x);\n            siz[x] += siz[to];\n        }\n    }\n}\n\npair<int, int> c;\nint S = 0;\n\nvoid find_centroid(int x, int p = -1)\n{\n    if(used[x]) return;\n    int mx = 0;\n    for(auto to : g[x])\n    {\n        if(!used[to] && to != p)\n        {\n            find_centroid(to, x);\n            mx = max(mx, siz[to]);\n        }\n    }\n    if(p != -1)\n        mx = max(mx, S - siz[x]);\n    c = min(c, make_pair(mx, x));\n}\n\nvoid dfs_heads(int v, int p, int cnt, long long cursum, long long curadd, vector<func>& sink)\n{\n    if(used[v])\n        return;\n    cnt++;\n    curadd += a[v];\n    cursum += curadd;\n    sink.push_back(make_pair(cnt, cursum));\n    for(auto to : g[v])\n        if(to != p)\n            dfs_heads(to, v, cnt, cursum, curadd, sink);\n}\n\nvoid dfs_tails(int v, int p, int cnt, long long cursum, long long curadd, vector<func>& sink)\n{\n    if(used[v])\n        return;\n    cnt++;\n    curadd += a[v];\n    cursum += a[v] * 1ll * cnt;\n    sink.push_back(make_pair(curadd, cursum));\n    for(auto to : g[v])\n        if(to != p)\n            dfs_tails(to, v, cnt, cursum, curadd, sink);\n}\n\nvoid centroid(int v)\n{\n    if(used[v]) return;\n    dfs1(v);\n    S = siz[v];\n    c = make_pair(int(1e9), -1);\n    find_centroid(v);\n    int C = c.second;\n    used[C] = 1;\n    vector<vector<func> > heads, tails;\n    for(auto to : g[C])\n        if(!used[to])\n        {\n            heads.push_back(vector<func>());\n            dfs_heads(to, C, 1, a[C], a[C], heads.back());\n            tails.push_back(vector<func>());\n            dfs_tails(to, C, 0, 0, 0, tails.back());\n        }\n    heads.push_back(vector<func>({{1, a[C]}}));\n    tails.push_back(vector<func>({{0, 0}}));\n    update_ans(heads, tails);\n    reverse(heads.begin(), heads.end());\n    reverse(tails.begin(), tails.end());\n    update_ans(heads, tails);\n    for(auto to : g[C])\n        centroid(to);\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n - 1; i++)\n    {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        --x;\n        --y;\n        g[x].push_back(y);\n        g[y].push_back(x);    \n    }\n    for(int i = 0; i < n; i++)\n        scanf(\"%d\", &a[i]);\n    centroid(0);\n    printf(\"%lld\\n\", ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}