{"link": "https://codeforces.com//contest/1175/problem/F", "problemId": "354218", "shortId": "1175F", "contest_number": "1175", "name": "F. The Number of Subpermutations", "statement": "You have an array . Let's call some subarray  of this array a  if it contains all integers from  to  exactly once. For example, array  contains  subarrays which are subpermutations: , , , , , .You are asked to calculate the number of subpermutations.", "input": "The first line contains one integer  (). The second line contains  integers  ().  ", "output": "Print the number of subpermutations of the array .", "tutorial": "At first, let's represent permutations in the next form. We assign to all numbers from  to  random 128-bit strings, so the -th number gets the string . Then the permutation of length  can be hashed as , where  is bitwise exclusive OR (for example, ). This representation is convenient because if we have two sets of numbers with a total number of elements equal to  (let's represent them as  and , ), we can easily check whether their union is a permutation of length  (condition  must be hold). Let's denote  as .Now let's iterate over position  such that  and calculate the number of permutations that contain this element. To do it, let's iterate over the right boundary  and suppose, that maximum element of permutation  (and its length at the same time) is one of positions . If it's true, then the subpermutation should be on the positions . And to check that this segment is a subpermutation we should just compare  and .Thus, we will calculate all permutations in which the position of the maximum is to the right of the position of the . To calculate all permutations we need to reverse array  and repeat this algorithm, and then add the number of ones in the array .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<long long, long long> pt;\n\nconst int N = int(3e5) + 99;\nconst pt zero = make_pair(0, 0);\n\nint n;\nint a[N];\npt hsh[N], sumHsh[N];\n\nvoid upd(pt &a, pt b){\n    a.first ^= b.first;\n    a.second ^= b.second;\n}\n\nint calc(int pos){\n\tset <int> sl, sr;\n\tset<pt> s;\n\tint r = pos + 1, l = pos - 1;\n\tpt curr = hsh[0], curl = zero;\n\ts.insert(zero);\n\tsr.insert(0), sl.insert(0);\n\t\n\tint res = 0;\t\n\twhile(r < n && !sr.count(a[r])){\n\t\tsr.insert(a[r]);\n\t\tupd(curr, hsh[a[r]]);\n\t\t++r;\n\n\t\twhile(l >= 0 && !sl.count(a[l]) && a[l] < *sr.rbegin()){\n\t\t\tsl.insert(a[l]);\n\t\t\tupd(curl, hsh[a[l]]);\n\t\t\ts.insert(curl);\n\t\t\t--l;\t\n\t\t}\n\n\t\tpt need = sumHsh[*sr.rbegin()];\n\t\tupd(need, curr);\n\t\tif(s.count(need)) ++res;\n\t}\t\n\n\treturn res;\n}\t\n\nint main() {\n    long long x = 0;\n\tcin >> n;\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> a[i];\n\t\t--a[i];\t\n\t\tx ^= a[i];\n\t}\n\t\n\t\n\tmt19937_64 rnd(time(NULL));\n\tfor(int i = 0; i < N; ++i){\n\t\thsh[i].first = rnd() ^ x;\n\t\thsh[i].second = rnd() ^ x;\n\t\tsumHsh[i] = hsh[i];\n\t\tif(i > 0) upd(sumHsh[i], sumHsh[i - 1]);\n\t}\n\t\n\tint res = 0;\n\t\t\n\tfor(int tc = 0; tc < 2; ++tc){\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(a[i] == 0)\n\t\t\t\tres += calc(i) + (tc == 0);\n\t\treverse(a, a + n);\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n} ", "interactive": false, "noSolution": false, "noTutorial": false}