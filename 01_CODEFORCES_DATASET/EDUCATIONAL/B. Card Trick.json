{"link": "https://codeforces.com//contest/1681/problem/B", "problemId": "1408803", "shortId": "1681B", "contest_number": "1681", "name": "B. Card Trick", "statement": "Monocarp has just learned a new card trick, and can't wait to present it to you. He shows you the entire deck of  cards. You see that the values of cards from the topmost to the bottommost are integers , and all values are different.Then he asks you to shuffle the deck  times. With the -th shuffle, you should take  topmost cards and move them under the remaining  cards without changing the order.And then, using some magic, Monocarp tells you the topmost card of the deck. However, you are not really buying that magic. You tell him that you know the topmost card yourself. Can you surprise Monocarp and tell him the topmost card before he shows it?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains a single integer  ()\u00a0\u2014 the number of cards in the deck. The second line contains  pairwise distinct integers  ()\u00a0\u2014 the values of the cards. The third line contains a single integer  ()\u00a0\u2014 the number of shuffles. The fourth line contains  integers  ()\u00a0\u2014 the amount of cards that are moved on the -th shuffle. The sum of  over all testcases doesn't exceed . The sum of  over all testcases doesn't exceed .", "output": "For each testcase, print a single integer\u00a0\u2014 the value of the card on the top of the deck after the deck is shuffled  times.", "tutorial": "The easiest way to solve to problem is probably to see the resemblense of a shuffle operation to an std::rotate function. So you can obtain the final deck by applying cyclic shifts of the deck by , then  and so on.Since the shifts are cyclic, it doesn't matter if you shift by  or by  or by  for any non-negative . The result will be the same. Thus, you can calculate the sum of rotations you apply, and subtract , until it becomes less than . That is taking it modulo .Finally, after rotating a sequence by some , the -th element of it (-indexed) becomes the first one. Thus, you just want to print the ()-th element of .Overall complexity:  per testcase.", "solution": "for _ in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tm = int(input())\n\tprint(a[sum(map(int, input().split())) % n])", "interactive": false, "noSolution": false, "noTutorial": false}