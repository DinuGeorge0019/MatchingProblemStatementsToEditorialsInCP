{"link": "https://codeforces.com//contest/1473/problem/E", "problemId": "864973", "shortId": "1473E", "contest_number": "1473", "name": "E. Minimum Path", "statement": "You are given a weighted undirected connected graph consisting of  vertices and  edges. It is guaranteed that there are no self-loops or multiple edges in the given graph.Let's define the weight of the path consisting of  edges with indices  as , where  \u2014 weight of the -th edge in the graph.Your task is to find the minimum weight of the path from the -st vertex to the -th vertex for each  ().", "input": "The first line contains two integers  and  (; ) \u2014 the number of vertices and the number of edges in the graph. Following  lines contains three integers  (; ; ) \u2014 endpoints of the -th edge and its weight respectively.", "output": "Print  integers \u2014 the minimum weight of the path from -st vertex to the -th vertex for each  ().", "tutorial": "Let's consider a problem where you can subtract the weight of any edge (not only the maximum one) that belong to the current path and similarly add the weight of any edge (not only the minimum one) that belong to the current path.To solve that problem we can build a new graph where the node can be represented as the following triple (node from the initial graph, flag that some edge has been subtracted, flag that some edge has been added). Now we can run Dijkstra's algorithm to find the length of the shortest paths in such a graph.We can notice that on the shortest path, the maximum weight edge was subtracted and the minimum weight edge was added. Let's assume that this is not the case, and an edge of non-maximum weight was subtracted from the path, then we can reduce the length of the path by choosing an edge of maximum weight. But this is not possible, because we considered the shortest path. Similarly, it is proved that the added edge was of minimal weight.Using this fact, it is not difficult to notice that by solving the modified problem, we have solved the original one.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\nint n, m;\nvector<pair<int, int>> g[N];\nlong long d[N][2][2];\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < m; i++) {\n    int v, u, w;\n    scanf(\"%d%d%d\", &v, &u, &w);\n    --v; --u;\n    g[v].emplace_back(u, w);\n    g[u].emplace_back(v, w);\n  }\n  \n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < 2; k++)\n        d[i][j][k] = (long long)1e18;\n\n  d[0][0][0] = 0;\n  set<pair<long long, array<int, 3>>> q;\n  q.insert({0, {0, 0, 0}});\n\n  while (!q.empty()) {\n    auto [v, mx, mn] = q.begin()->second;\n    q.erase(q.begin());\n    for (auto [u, w] : g[v]) {\n      for (int i = 0; i <= 1 - mx; i++) {\n        for (int j = 0; j <= 1 - mn; j++) {\n          if (d[u][mx | i][mn | j] > d[v][mx][mn] + (1 - i + j) * w) {\n            auto it = q.find({d[u][mx | i][mn | j], {u, mx | i, mn | j}});\n            if (it != q.end())\n              q.erase(it);\n            d[u][mx | i][mn | j] = d[v][mx][mn] + (1 - i + j) * w;\n            q.insert({d[u][mx | i][mn | j], {u, mx | i, mn | j}});\n          }\n        }\n      }\n    }\n  }\n\n  for (int i = 1; i < n; i++) {\n    printf(\"%lld \", d[i][1][1]);\n  }\n  puts(\"\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}