{"link": "https://codeforces.com//contest/1295/problem/F", "problemId": "526705", "shortId": "1295F", "contest_number": "1295", "name": "F. Good Contest", "statement": "An online contest will soon be held on ForceCoders, a large competitive programming platform. The authors have prepared  problems; and since the platform is very popular,  coder from all over the world is going to solve them.For each problem, the authors estimated the number of people who would solve it: for the -th problem, the number of accepted solutions will be between  and , inclusive.The creator of ForceCoders uses different criteria to determine if the contest is good or bad. One of these criteria is the number of inversions in the problem order. An inversion is a pair of problems  such that  is located earlier in the contest (), but the number of accepted solutions for  is  greater.Obviously, both the creator of ForceCoders and the authors of the contest want the contest to be good. Now they want to calculate the probability that there will be  inversions in the problem order, assuming that for each problem , any  number of accepted solutions for it (between  and ) is equally probable, and all these numbers are independent.", "input": "The first line contains one integer  () \u2014 the number of problems in the contest. Then  lines follow, the -th line contains two integers  and  () \u2014 the minimum and maximum number of accepted solutions for the -th problem, respectively.", "output": "The probability that there will be no inversions in the contest can be expressed as an irreducible fraction , where  is coprime with . Print one integer \u2014 the value of , taken modulo , where  is an integer such that   .", "tutorial": "The naive solution is dynamic programming: let  be the probability that the first  problems don't have any inversions, and the -th one got  accepted solutions. Let's somehow speed it up. For convenience, I will modify the variable denoting the maximum number of accepted solutions for each problem: , ; and I will also reverse the problem order, so that we don't want the number of solutions to decrease from problem to problem.We know that , if , and  otherwise. Let's divide the whole segment between  and  into  segments with the values of  and  and analyse the behavior of  values on each such segment.Let . If we consider the behavior of  on some segment we got, we can prove by induction that it is a polynomial of degree not exceeding .All that is left is to carefully calculate and maintain these polynomials on segments. The main thing we will use to calculate the polynomials is interpolation. To transition from  to , we will consider each segment separately, calculate the first several values of  on each segment (we need to calculate the sum  fast, if  is a polynomial, this can also be done with interpolation), and then interpolate it on the whole segment.This is actually slow (we have to interpolate at least  polynomials) and not easy to write. Let's consider a better solution.We will use combinatoric approach: instead of calculating probabilities, we will count all the non-descending sequences  such that , and divide it by the number of all sequences without the non-descending condition (that is just ).Let's again divide  into  segments using the points , , and enumerate these segments from left to right. If there are two neighboring values  and , they either belong to the same segment, or the segment  belongs to is to the right of the segment  belongs to.We could try to write the following dynamic programming solution:  is the number of non-descending prefixes of the sequence such that there are  elements in the prefix, and the last one belongs to segment . It's easy to model transitions from  to  where , but we don't know how to model the transition to .Let's get rid of them altogether! We will introduce an additional constraint in our dynamic programming:  is the number of prefixes of the sequence of length  . The transitions in this dynamic programming are different: we iterate on the number of elements  belonging to the next segment and transition into  (if possible). Calculating the number of ways to take  elements from an interval  in sorted order can be reduced to calculating the number of ways to compose  as the sum of  non-negative summands (order matters). We should be able to calculate binomial coefficients with fairly large  and not so large , but that's not really hard if we use the formula . ", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    return x;\n}\n\nint mul(int x, int y)\n{\n    return (x * 1ll * y) % MOD;\n}\n\nint binpow(int x, int y)\n{\n    int z = 1;\n    while(y)\n    {\n        if(y & 1) z = mul(z, x);\n        x = mul(x, x);\n        y >>= 1;\n    }\n    return z;\n}\n\nint inv(int x)\n{\n    return binpow(x, MOD - 2);\n}\n\nint divide(int x, int y)\n{\n    return mul(x, inv(y));\n}\n\ntypedef vector<int> poly;\n\nvoid norm(poly& p)\n{\n    while(p.size() > 0 && p.back() == 0)\n        p.pop_back();\n}\n\npoly operator +(const poly& a, const poly& b)\n{\n    poly c = a;\n    while(c.size() < b.size()) c.push_back(0);\n    for(int i = 0; i < b.size(); i++) c[i] = add(c[i], b[i]);\n    norm(c);\n    return c;\n}\n\npoly operator +(const poly& a, int b)\n{\n    return a + poly(1, b);\n}\n\npoly operator +(int a, const poly& b)\n{\n    return b + a;\n}\n\npoly operator *(const poly& a, int b)\n{\n    poly c = a;                               \n    for(int i = 0; i < c.size(); i++) c[i] = mul(c[i], b);\n    norm(c);\n    return c;\n}\n\npoly operator /(const poly& a, int b)\n{   \n    return a * inv(b);\n}\n\npoly operator *(const poly& a, const poly& b)\n{\n    poly c(a.size() + b.size() - 1);\n    for(int i = 0; i < a.size(); i++)\n        for(int j = 0; j < b.size(); j++)\n            c[i + j] = add(c[i + j], mul(a[i], b[j]));\n\n    norm(c);\n    return c;\n}\n\npoly interpolate(const vector<int>& x, const vector<int>& y)\n{\n    int n = int(x.size()) - 1;\n    vector<vector<int> > f(n + 1);\n    f[0] = y;\n    for(int i = 1; i <= n; i++)\n        for(int j = 0; j <= n - i; j++)\n            f[i].push_back(divide(add(f[i - 1][j + 1], -f[i - 1][j]), add(x[i + j], -x[j])));\n    \n    poly cur = poly(1, 1);\n    poly res;\n    for(int i = 0; i <= n; i++)\n    {\n        res = res + cur * f[i][0];\n        cur = cur * poly({add(0, -x[i]), 1});\n    }\n\n    return res;\n}\n\nint eval(const poly& a, int x)\n{\n    int res = 0;\n    for(int i = int(a.size()) - 1; i >= 0; i--)\n        res = add(mul(res, x), a[i]);\n    return res;\n}\n\npoly sumFromL(const poly& a, int L, int n)\n{\n    vector<int> x;\n    for(int i = 0; i <= n; i++)\n        x.push_back(L + i);\n    vector<int> y;\n    int cur = 0;\n    for(int i = 0; i <= n; i++)\n    {\n        cur = add(cur, eval(a, x[i]));\n        y.push_back(cur);\n    }\n    return interpolate(x, y);\n}\n\nint sumOverSegment(const poly& a, int L, int R)\n{\n    return eval(sumFromL(a, L, a.size()), R - 1);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> L(n), R(n);\n    for(int i = 0; i < n; i++)\n    {\n        cin >> L[i] >> R[i];\n        R[i]++;\n    }\n    reverse(L.begin(), L.end());\n    reverse(R.begin(), R.end());\n\n    vector<int> coord = {0, MOD - 2};\n    for(int i = 0; i < n; i++)\n    {\n        coord.push_back(L[i]);\n        coord.push_back(R[i]);\n    }\n    sort(coord.begin(), coord.end());\n    coord.erase(unique(coord.begin(), coord.end()), coord.end());\n    vector<int> cL = coord, cR = coord;\n    cL.pop_back();\n    cR.erase(cR.begin());\n    int cnt = coord.size() - 1;\n    vector<poly> cur(cnt);\n    for(int i = 0; i < cnt; i++)\n        if(cL[i] >= L[0] && cR[i] <= R[0])\n            cur[i] = poly(1, inv(R[0] - L[0]));\n    for(int i = 1; i < n; i++)\n    {\n        vector<poly> nxt(cnt);        \n        int curSum = 0;\n        for(int j = 0; j < cnt; j++)\n        {\n            nxt[j] = sumFromL(cur[j], cL[j], i) + curSum;\n            curSum = add(curSum, sumOverSegment(cur[j], cL[j], cR[j]));    \n        }\n        for(int j = 0; j < cnt; j++)\n            nxt[j] = nxt[j] * (cL[j] >= L[i] && cR[j] <= R[i] ? inv(R[i] - L[i]) : 0);\n        cur = nxt;\n    }\n    int ans = 0;\n    for(int i = 0; i < cnt; i++)\n        ans = add(ans, sumOverSegment(cur[i], cL[i], cR[i]));\n\n    cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}