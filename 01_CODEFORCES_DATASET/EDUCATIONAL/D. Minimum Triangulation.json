{"link": "https://codeforces.com//contest/1140/problem/D", "problemId": "317587", "shortId": "1140D", "contest_number": "1140", "name": "D. Minimum Triangulation", "statement": "You are given a regular polygon with  vertices labeled from  to  in counter-clockwise order. The triangulation of a given polygon is a set of triangles such that each vertex of each triangle is a vertex of the initial polygon, there is no pair of triangles such that their intersection has non-zero area, and the total area of all triangles is equal to the area of the given polygon. The weight of a triangulation is the sum of weigths of triangles it consists of, where the weight of a triagle is denoted as the product of labels of its vertices.Calculate the minimum weight among all triangulations of the polygon.", "input": "The first line contains single integer  () \u2014 the number of vertices in the regular polygon.", "output": "Print one integer \u2014 the minimum weight among all triangulations of the given polygon.", "tutorial": "You can use straightforward way and calculate answer with \"l-r-dp\" with .But there is a easier claim: it's optimal to split -gon with diagonals coming from , so answer is .Proof: let's look at the triange which contains edge . Let's name it . If , we can delete this triangle and go to -gon.Otherwise, . Let's look at triangle . It always exists and . Finally, if we change pair of triangles (, ) to (, ), answer will decrease since  and , that's why .Note, that triangle  changes to  and , so repeating this step will eventually lead us to situation .As a result, we can morph any triangulation into one mentioned above and its weight won't increase.", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint n; cin >> n;\n\n\tlong long ans = 0;\n\tfor(int id = 2; id < n; id++)\n\t\tans += 1ll * id * (id + 1);\n\t\n\tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}