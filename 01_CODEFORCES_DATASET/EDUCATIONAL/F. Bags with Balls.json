{"link": "https://codeforces.com//contest/1716/problem/F", "problemId": "1494205", "shortId": "1716F", "contest_number": "1716", "name": "F. Bags with Balls", "statement": "There are  bags, each bag contains  balls with numbers from  to . For every , there is exactly one ball with number  in each bag.You have to take exactly one ball from each bag (all bags are different, so, for example, taking the ball  from the first bag and the ball  from the second bag is not the same as taking the ball  from the first bag and the ball  from the second bag). After that, you calculate the number of balls with  numbers among the ones you have taken. Let the number of these balls be .Your task is to calculate the sum of  over all possible ways to take  balls, one from each bag.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. Each test case consists of one line containing three integers ,  and  (; ).", "output": "For each test case, print one integer\u00a0\u2014 the sum of  over all possible ways to take  balls, one from each bag. Since it can be huge, print it modulo .", "tutorial": "The main idea of this problem is to use a technique similar to \"contribution to the sum\". We will model the value of  as the number of tuples , where each element is an index of a bag from which we have taken an odd ball. Let  be the number of ways to take balls from bags so that all elements from tuple  are indices of bags with odd balls; then, the answer to the problem can be calculated as the sum of  over all possible tuples .First of all, let's obtain a solution in  per test case. We need to answer the following questions while designing a solution to the problem:  How do we calculate  for a given tuple?  How do we group tuples and iterate through them? The first question is not that difficult. Every element from the tuple  should be an index of a bag from which we have taken an odd ball; so, for every bag appearing in the tuple, we can take only a ball with odd number; but for every bag not appearing in the tuple, we can choose any ball. So, if the number of  elements in a tuple is , then  for the tuple can be calculated as .This actually gives as a hint for the answer to the second question: since  depends on the number of distinct elements in the tuple, let's try to group the tuples according to the number of distinct elements in them. So, the answer will be calculated as , where  is the number of tuples with exactly  different elements.How do we calculate ? First of all, if , then  is obviously . Otherwise, we can use the following recurrence: let  be the number of tuples of  elements with  distinct ones; then:  if  and ,  (for a tuple with one element, there are  ways to choose it);  if  and , ;  if  and ,  (there is only one distinct element, and it was already chosen);  if  and ,  (we either add an element which did not belong to the tuple, and there are  ways to choose it, or we add an already existing element, and there are  ways to choose it). Obviously, this recurrence can be calculated in  with dynamic programming, so we get a solution in  per test case.How do we speed this up? Let's change the way we calculate . Instead of considering tuples with values from  to , we will consider only tuples where values are from  to , and the first appearance of a value  is only after the first appearance of the value . So, these tuples actually represent a way to split a set of integers  into several subsets; so they are the Stirling numbers of the second kind, and we can calculate them in  with dynamic programming outside of processing the test cases.How do we calculate  using these values? If we use  distinct integers as the elements of the tuple, there are  ways to choose the first one,  ways to choose the second one, etc.\u00a0\u2014 so , where  is the Stirling number of the second kind for the parameters  and . We can maintain the values of  and  while iterating on  from  to , and that gives us a way to solve the problem in  per test case.Overall complexity:  for precalculation and  per test case.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;   \nconst int N = 2043;\n\nint dp[N][N];\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    return x;\n}   \n\nint sub(int x, int y)\n{\n    return add(x, -y);\n}\n\nint mul(int x, int y)\n{\n    return (x * 1ll * y) % MOD;\n}\n\nint binpow(int x, int y)\n{\n    int z = 1;\n    while(y > 0)\n    {\n        if(y % 2 == 1) z = mul(z, x);\n        x = mul(x, x);\n        y /= 2;\n    }\n    return z;\n}\n\nint inv(int x)\n{\n    return binpow(x, MOD - 2);\n}\n\nint divide(int x, int y)\n{\n    return mul(x, inv(y));\n}\n\nvoid precalc()\n{\n    dp[1][1] = 1;\n    for(int i = 1; i < N - 1; i++)\n        for(int j = 1; j <= i; j++)\n        {\n            dp[i + 1][j] = add(dp[i + 1][j], mul(dp[i][j], j));\n            dp[i + 1][j + 1] = add(dp[i + 1][j + 1], dp[i][j]);\n        }\n}\n\nint solve(int n, int m, int k)\n{\n    int way1 = (m / 2) + (m % 2);\n    int curA = n;\n    int ans = 0;\n    int ways_chosen = way1;\n    int ways_other = binpow(m, n - 1);\n    int invm = inv(m);\n    for(int i = 1; i <= k; i++)\n    {\n        ans = add(ans, mul(mul(curA, dp[k][i]), mul(ways_chosen, ways_other)));\n        curA = mul(curA, sub(n, i));\n        ways_chosen = mul(way1, ways_chosen);\n        ways_other = mul(ways_other, invm);\n    }  \n    return ans;\n}   \n\nint main()\n{\n    int t;\n    cin >> t;\n    precalc();\n    for(int i = 0; i < t; i++)\n    {\n        int n, m, k;\n        cin >> n >> m >> k;\n        cout << solve(n, m, k) << endl;\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}