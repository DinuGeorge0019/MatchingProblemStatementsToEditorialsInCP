{"link": "https://codeforces.com//contest/1743/problem/G", "problemId": "1590322", "shortId": "1743G", "contest_number": "1743", "name": "G. Antifibonacci Cut", "statement": "Let's define the sequence of Fibonacci strings as follows:  is ,  is ,  is  for  ( denotes the concatenation of two strings). So, for example,  is ,  is ,  is .For a given string , let's define  as the number of ways to cut it into several (any number, possibly even just one) strings such that none of these strings are Fibonacci strings. For example, if  is ,  since there are three ways to cut it:    ;    ;      . You are given a sequence of strings . Calculate . Since these values can be huge, print them modulo .", "input": "The first line of the input contains one integer  (). Then,  lines follow. The -th line contains the string  (), consisting of characters  and/or .", "output": "Print  integers, where the -th integer is .", "tutorial": "The first idea that comes to mind is running some sort of dynamic programming:  \u2014 the number of ways to cut the string consisting of the first  characters. When we calculate , we need to take the sum of the previous values of , and then subtract  for every  such that the string from the -th character (inclusive) to the -th character (non-inclusive) is a Fibonacci string. Unfortunately, there are two main issues with this solution: firstly, we cannot store the array  in memory; and secondly, we have to search for the Fibonacci strings ending in a certain index quickly (something like Aho-Corasick could work with a less strict memory limit, but right now we cannot use it).We will try to resolve both of these issues with the following approach: while we process the characters, we will maintain the list of tuples  such that the string from the -th character to the current one is a prefix of some Fibonacci string. How do we maintain them?Every Fibonacci string  (except for ) is a prefix of . So, all Fibonacci strings we are interested in (except for  again) are prefixes of the same long Fibonacci string. Suppose a tuple  represents some index  such that the string from the -th character to the current one is a prefix of that long Fibonacci string. Each time we append a character, we filter this list of tuples by trying to check if this new character matches the next character in the prefix (if it does not, the tuple is discarded). For the tuples that represent the prefixes equal to Fibonacci strings, we need to subtract the value of  from the new  value we are trying to calculate (checking if a prefix is a Fibonacci string is easy, we just need to check its length). How do we check that if we add a character  or , it is still a prefix? There are two ways to do this:  either generate the first  characters of the long Fibonacci string;  or represent the current prefix as the sum of Fibonacci strings  such that for every , the condition  holds (i.\u2009e. the Fibonacci strings we split the current prefix into are arranged in descending order, and there is no pair of equal or adjacent (by index) Fibonacci strings in the split). This representation is very similar to writing an integer in Zeckendorf system. The next character in the prefix depends on whether  belongs to this split: if it belongs, it is the last string in the split, so we need to append  to transform  into ; otherwise, we need to append . Okay, so now we can solve the problem in  time (where  is the total length of the strings in the input, and  is the size of the list of tuples  we discussed earlier). This actually works since it looks like the size of the list of tuples is bounded as . Unfortunately, we don't have a strict mathematical proof of this; we checked this by brute force with  up to , so it definitely works under the constraints of the problem.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    return x;\n}\n\nint sub(int x, int y)\n{\n    return add(x, MOD - y);\n}\n\nint expected(int mask)\n{\n    if(mask & 2) return 0;\n    return 1;\n}\n\nint last_bit(int x)\n{\n    if(x == 0) return -1;\n    return x - (x & (x - 1));\n}\n\nbool go(int& a, int x)\n{\n    if(expected(a) != x)\n    {\n        a = 1 << x;\n        return false;    \n    }\n    a ^= (1 << x);\n    while(true)\n    {\n        int b = last_bit(a);\n        int c = last_bit(a - b);\n        if(c == 2 * b) a += b;\n        else break;\n    }\n    return true;\n}\n\nbool is_fib(int a)\n{\n    return a == last_bit(a);\n}\n\nvector<pair<int, int>> go(const vector<pair<int, int>>& a, int x)\n{\n    vector<pair<int, int>> nw;\n    for(auto b : a)\n    {\n        int cost = b.first;\n        int seqn = b.second;\n        if(go(seqn, x)) nw.push_back(make_pair(cost, seqn));\n    }\n    return nw;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int last = 1, sum = 1;\n    vector<pair<int, int>> w;\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; i++)\n    {\n        string s;\n        cin >> s;\n        for(auto x : s)\n        {\n            int c = x - '0';\n            int ndp = sub(sum, last);\n            w = go(w, c);\n            for(int j = 0; j < w.size(); j++)\n            {\n                if(is_fib(w[j].second))\n                    ndp = sub(ndp, w[j].first);\n            }\n            if(c == 1) w.push_back(make_pair(last, 2));\n            sum = add(sum, ndp);\n            last = ndp;\n            assert(w.size() <= 60);\n        }\n        cout << last << endl;\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}