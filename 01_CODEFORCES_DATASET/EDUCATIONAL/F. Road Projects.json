{"link": "https://codeforces.com//contest/1016/problem/F", "problemId": "204441", "shortId": "1016F", "contest_number": "1016", "name": "F. Road Projects", "statement": "There are  cities in the country of Berland. Some of them are connected by bidirectional roads in such a way that there exists  path, which visits each road no more than once, between every pair of cities. Each road has its own length. Cities are numbered from  to .The travelling time between some cities  and  is the total length of the roads on the shortest path from  to . The two most important cities in Berland are cities  and .The Berland Ministry of Transport decided to build a single new road to decrease the traffic between the most important cities. However, lots of people are used to the current travelling time between the most important cities, so the new road shouldn't change it too much. The new road can only be built between such cities  and  that  and  and  aren't already connected by some road.They came up with  possible projects. Each project is just the length  of the new road.Polycarp works as a head analyst at the Berland Ministry of Transport and it's his job to deal with all those  projects. For the -th project he is required to choose some cities  and  to build the new road of length  between such that the travelling time between the most important cities is . Unfortunately, Polycarp is not a programmer and no analyst in the world is capable to process all projects using only pen and paper. Thus, he asks you to help him to calculate the maximal possible travelling time between the most important cities for each project. Note that the choice of  and  can differ for different projects.", "input": "The first line contains two integers  and  (, ) \u2014 the number of cities and the number of projects, respectively. Each of the next  lines contains three integers ,  and  (, ) \u2014 the description of the -th road. It is guaranteed that there exists  path, which visits each road no more than once, between every pair of cities. Each of the next  lines contains a single integer  () \u2014 the length of the road for the -th project.", "output": "Print  lines, the -th line should contain a single integer \u2014 the maximal possible travelling time between the most important cities for the -th project.", "tutorial": " (editorial by PikMike)Firtsly, we can notice that we get the most profit by placing the edge in a same position, no matter the query. Moreover, once you have calculated the minimum difference you can apply to the shortest path  by adding edge of the weight , you can answer the queries in  each. Let the current shortest distance between  and  be . Then the answer to some query  is . Let's proceed to proofs of the following. Consider any of the optimal positions for the edge of weight . Then weight  will add  to the answer in this position (if the path isn't  already but that is trivial). Let there be another position such that the answer in it is less than the current one. That means that the answer for weight  in it is less by  which is smaller than the first one we got, which leads to contradiction. The second fact can deduced from the first one.Then let me introduce the next bold statement. We root the tree with vertex . Then if there exists such a vertex in that it's not an ancestor of vertex  and the number of vertices in its subtree (inclusive) is greater than  then . That is simple: just put the edge between the parent of this vertex and any of vertices of the subtree, there always be such that the edge doesn't exist yet. That won't change the shortest path, no matter which  it is.Then, we have a graph of the following kind:That is the simple path between  and  and some vetices on it have additional children leaves. Finally, let's proceed to the solution.We want to choose such a pair of vertices that the sum of edge on a path between them, which are also a part of the path between  and  plus the weights of the newly included to shortest path edges (if any) is minimal possible. Let's precalc  \u2014 the sum of weights of edges from vertex  to vertex  and  \u2014 parent of vertex . Let  be the weight of an edge between  and . Then we end up with the four basic cases for these vertices  and  with  having greater or equal number of edges on path to  than : each of the form (whether  belongs to the simple path between  and , whether  belongs to it).   doesn't belong: the answer is ;   belongs,  doesn't: ;  both belongs: . Each of these formulas can be broken down to parts with exacly one of the vertices. Let's call them  and . That means minimizing the result is be the same as minimizing each of the parts.We run depth-first search on vertices which belong to a simple path between  and  inclusive. Maintain the minimum value of  you have already passed by. Try connecting each vertex with this  and also parent of the parent of the current vertex using all the possible formulas and updating  with the resulting value.Finally, after the precalc is finished, asnwer the queries in  with .Overall complexity: . (editorial by BledDest)Let's denote the distance from vertex  to vertex  in the tree as . Similarly, denote the distance from  to  in the tree as .Suppose we try to add a new edge between vertices  and  with length . Then two new paths from  to  are formed: one with length , and another with length . Then the new length of shortest path becomes . So if we find two non-adjacent vertices such that  is maximum possible, then it will always be optimal to add an edge between these two vertices.How can we find this pair of vertices? Firstly, let's suppose that  \u2014 when we pick vertex , we will try to pair it only with vertices  corresponding to the aforementioned constraint. This can be done by sorting vertices by the value of  and then for each vertex  pairing it only with vertices that are later than  in the sorted order.How do we find the best pair for ? The best pair could be just the vertex with maximum possible , but it is not allowed to connect a vertex with itself or its neighbour. To handle it, we may maintain a set of possible vertices , delete all neighbours of  from it, pick a vertex with maximum , and then insert all neighbours of  back into the set.This solution works in  time.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst long long INF64 = (long long)(1e18);\nconst int N = 1000 * 1000 + 13;\n\nint n, m;\nvector<pair<int, int>> g[N];\nlong long d[N];\nint siz[N];\nint tin[N], tout[N], T;\nint pr[N];\n\nvoid calc(int v, int p){\n\tpr[v] = p;\n\ttin[v] = T++;\n\tsiz[v] = 1;\n\tfor (auto it : g[v]){\n\t\tint u = it.first;\n\t\tint w = it.second;\n\t\tif (u == p) continue;\n\t\td[u] = d[v] + w;\n\t\tcalc(u, v);\n\t\tsiz[v] += siz[u];\n\t}\n\ttout[v] = T++;\n}\n\ninline int isp(int v, int u){\n\treturn tin[v] <= tin[u] && tout[v] >= tout[u];\n}\n\nlong long dif;\nlong long mn;\n\nvoid dfs(int v, int p){\n\tdif = min(dif, max(0ll, -(mn - d[v])));\n\tif (p != -1 && pr[p] != -1)\n\t\tdif = min(dif, max(0ll, -(d[pr[p]] - d[v])));\n\t\n\tfor (auto it : g[v]){\n\t\tint u = it.first;\n\t\tint w = it.second;\n\t\tif (u == p) continue;\n\t\tif (!isp(u, n - 1)){\n\t\t\tdif = min(dif, max(0ll, -(mn + w - d[v])));\n\t\t\tmn = max(mn, w + d[v]);\n\t\t\tif (p != -1)\n\t\t\t\tdif = min(dif, max(0ll, -(w - d[v] + d[p])));\n\t\t}\n\t}\n\t\n\tfor (auto it : g[v]){\n\t\tint u = it.first;\n\t\tif (u == p) continue;\n\t\tif (isp(u, n - 1))\n\t\t\tdfs(u, v);\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tforn(i, n - 1){\n\t\tint v, u, w;\n\t\tscanf(\"%d%d%d\", &v, &u, &w);\n\t\t--v, --u;\n\t\tg[v].push_back(make_pair(u, w));\n\t\tg[u].push_back(make_pair(v, w));\n\t}\n\t\n\tT = 0;\n\tcalc(0, -1);\n\t\n\tlong long cur = d[n - 1];\n\tdif = INF64;\n\tmn = -INF64;\n\t\n\tforn(i, n)\n\t\tif (!isp(i, n - 1) && siz[i] > 1)\n\t\t\tdif = 0;\n\t\n\tif (dif > 0)\n\t\tdfs(0, -1);\n\t\n\tforn(i, m){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tprintf(\"%lld\\n\", min(cur, cur - dif + x));\n\t}\n\t\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}