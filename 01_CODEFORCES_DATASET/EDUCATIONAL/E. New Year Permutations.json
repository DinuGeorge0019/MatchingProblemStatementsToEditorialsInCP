{"link": "https://codeforces.com//contest/1279/problem/E", "problemId": "504277", "shortId": "1279E", "contest_number": "1279", "name": "E. New Year Permutations", "statement": ".A permutation of length  is an array of  integers such that every integer from  to  appears in it exactly once. An element  of permutation  is reachable from element  if , or , or , and so on. The  of a permutation  is defined as follows: firstly, we have a permutation , all elements of which are , and an empty list . Then we do the following: while there is at least one  element in , we find the leftmost such element, list all elements that are reachable from it , mark all of these elements, then cyclically shift the list of those elements so that the maximum appears at the first position, and add this list  of . After all elements are marked,  is the result of this decomposition.For example, if we want to build a decomposition of , we do the following:  initially  (bold elements are marked), ;  the leftmost unmarked element is ;  and  are reachable from it, so the list we want to shift is ; there is no need to shift it, since maximum is already the first element;  , ;  the leftmost unmarked element is , the list of reachable elements is ; the maximum is already the first element, so there's no need to shift it;  , ;  the leftmost unmarked element is , the list of reachable elements is ; we have to shift it, so it becomes ;  , ;  all elements are marked, so  is the result. The  of a permutation is defined as follows: we build the decomposition of this permutation; then we sort all lists in decomposition in ascending order of the first elements (we don't swap the elements in these lists, only the lists themselves); then we concatenate the lists into one list which becomes a new permutation. For example, the  of  is built as follows:  the decomposition is ;  after sorting the decomposition, it becomes ;   is the result of the transformation. We call a permutation  if the result of its transformation is the same as the permutation itself. For example,  is a good permutation; and  is bad, since the result of transformation is .Your task is the following: given  and , find the -th (lexicographically) good permutation of length .", "input": "The first line contains one integer  () \u2014 the number of test cases. Then the test cases follow. Each test case is represented by one line containing two integers  and  (, ).", "output": "For each test case, print the answer to it as follows: if the number of good permutations of length  is less than , print one integer ; otherwise, print the -th good permutation on  elements (in lexicographical order).", "tutorial": "Let's calculate $$$cycle_n$$$ \u2014 the number of permutations of length $$$n$$$, which have a maximum at the position $$$1$$$ and consist of exactly one cycle. Each good permutation can be divided into such blocks, so we'll need this value later.It is easy to notice that $$$cycle_n = (n-2)!$$$.Let's calculate the following dynamic programming $$$dp_i$$$ \u2014 the number of good permutations consisting of elements $$$[i, n]$$$.To calculate $$$dp_i$$$, let's iterate over $$$j$$$ \u2014 the maximum element of the first block, it determines the length of this block $$$(j - i + 1)$$$.$$$dp_i = \\sum_{j=i}^n(dp_{j + 1} \\cdot cycle_{j - i - 1})$$$.Now let's use the standard method of lexicographic recovery.We will iterate over which element to put next, it immediately determines the size of the new block and all the elements in it. If the number of permutations starting with such block is at least $$$k$$$, then you need to restore this block entirely and reduce the task to the one without this block. Otherwise, you need to subtract the number of permutations starting on such block from $$$k$$$ and proceed to the next option for the block.We will also use lexicographic recovery to restore the block. You must carefully maintain the current block so that it consists of exactly one cycle. To do this, you can use DSU or explicitly check for a cycle.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define sqr(a) ((a) * (a))\n#define sz(a) int((a).size())\n#define all(a) (a).begin(), (a).end()\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i < int(r); ++i)\n\ntypedef long long li;\ntypedef long double ld;\n\nconst int N = 55;\nconst li INF = 2e18;\n\nint n;\nli k;\n\nli cycl[N], cnt[N];\nbool used[N];\nint ans[N];\n\nli add(li x, li y) {\n\treturn min(INF, x + y);\n}\n\nli mul(li x, li y) {\n\tld t = ld(x) + y;\n\tif (t > INF) return INF;\n\treturn x * y;\n}\n\nvoid solve() {\n\tcin >> n >> k;\n\t--k;\n\n\tcycl[0] = cycl[1] = 1;\n\tfore(i, 2, n + 1) \n\t\tcycl[i] = mul(cycl[i - 1], i - 1);\n\t\t\n\tcnt[n] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tcnt[i] = 0;\n\t\tfore(val, i, n) {\n\t\t\tint len = (val - i) + 1;\n\t\t\tcnt[i] = add(cnt[i], mul(cnt[i + len], cycl[len - 1]));\n\t\t}\n\t}\n\t\n\tif (cnt[0] <= k) {\n\t\tcout << -1 << endl;\n\t\treturn;\n\t}\n\t\n\tmemset(used, 0, sizeof(used));\n\tmemset(ans, -1, sizeof(ans));\n\t\n\tforn(i, n) {\n\t\tfore(val, i, n) {\n\t\t\tint len = (val - i) + 1;\n\t\t\tli cur = mul(cnt[i + len], cycl[len - 1]); \n\t\t\t\n\t\t\tif (cur <= k)  {\n\t\t\t\tk -= cur;\n\t\t\t\tcontinue;\t\n\t\t\t}\n\t\t\t\n\t\t\tans[i] = val;\n\t\t\tused[val] = true;\n\t\t\t\n\t\t\tfor (int j = i + 1; j < i + len; j++) {\n\t\t\t\tint lft = len - (j - i) - 1;\n\t\t\t\tfore(nval, i, val) if (!used[nval] && j != nval) {\n\t\t\t\t\tif (j != i + len - 1) {\n\t\t\t\t\t\tint tmp = ans[nval];\n\t\t\t\t\t\twhile (tmp != -1 && tmp != j) \n\t\t\t\t\t\t\ttmp = ans[tmp];\n\t\t\t\t\t\tif (tmp == j) continue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tli cur = mul(cnt[i + len], cycl[lft]); \n\t\t\t\t\tif (cur <= k) {\n\t\t\t\t\t\tk -= cur;\n\t\t\t\t\t\tcontinue;\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tans[j] = nval;\n\t\t\t\t\tused[nval] = true;\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\ti += len - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tforn(i, n) cout << ans[i] + 1 << ' ';\n\tcout << endl;\n}\n\nint main() {\n\tint tc;\n\tcin >> tc;\n\tforn(i, tc) solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}