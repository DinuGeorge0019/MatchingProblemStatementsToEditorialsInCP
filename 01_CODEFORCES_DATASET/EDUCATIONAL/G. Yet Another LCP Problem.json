{"link": "https://codeforces.com//contest/1073/problem/G", "problemId": "243302", "shortId": "1073G", "contest_number": "1073", "name": "G. Yet Another LCP Problem", "statement": "Let  be the length of the longest common prefix of strings  and . Also let  be the substring of  from index  to index  (inclusive). For example, if  \"\", then  \"\",  \"\".You are given a string  of length  and  queries. Each query is a pair of integer sets  and . Calculate  for each query.", "input": "The first line contains two integers  and  () \u2014 the length of string  and the number of queries, respectively. The second line contains a string  consisting of lowercase Latin letters (). Next  lines contains descriptions of queries \u2014 three lines per query. The first line of each query contains two integers  and  () \u2014 sizes of sets  and  respectively. The second line of each query contains  integers  () \u2014 set . The third line of each query contains  integers  () \u2014 set . It is guaranteed that  and .", "output": "Print  integers \u2014 answers for the queries in the same order queries are given in the input.", "tutorial": "At first, implement your favourite string suffix structure for comparing pair of suffixes lexicographically fast enough. For example, it's a Suffix Array + linear LCP + Sparse Table. Now we can compare two suffixes  and  by finding  and comparing  with .We will process queries online. Let current query be a pair of arrays  () and  (). We will calculate answer in two parts: To calculate the first sum we can sort all  suffixes in lexicographical order and maintain some information for prefixes of . What information we need to maintain? We need some Data Structure which will hold  of suffixes from . When we process some  we need just a total sum of all  in the DS. If , we should add to the DS length of -th suffix. And when we move from  to  we must recalculate some . Since  is sorted, all we need is to set .In fact, this Data Structure is just a . In this  we will hold for each length  number of suffixes with  (we will hold only non-zero values). When we should add some suffix , we manually increase some value by one. Setting  with  can be done with decreasing maximum in  while its more than . It can be proven, that there will be  operations with  for one query. The total sum can be maintained in some global variable, which will be recalculated each time  changes.To calculate the second sum we can just reverse  and run the same algorithm. So total complexity is .", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\t\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\t\t\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\t\t\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\t\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\t\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\t\t\t\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\t\t\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\t\t\t\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}