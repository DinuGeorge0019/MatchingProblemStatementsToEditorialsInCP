{"link": "https://codeforces.com//contest/660/problem/F", "problemId": "54418", "shortId": "660F", "contest_number": "660", "name": "F. Bear and Bowling 4", "statement": "Limak is an old brown bear. He often goes bowling with his friends. Today he feels really good and tries to beat his own record!For rolling a ball one gets a score \u2014 an integer (maybe negative) number of points. Score for the -th roll is multiplied by  and scores are summed up. So, for  rolls with scores , the total score is . The total score is  if there were no rolls.Limak made  rolls and got score  for the -th of them. He wants to maximize his total score and he came up with an interesting idea. He can say that some first rolls were only a warm-up, and that he wasn't focused during the last rolls. More formally, he can cancel any prefix and any suffix of the sequence . It is allowed to cancel all rolls, or to cancel none of them.The total score is calculated as if there were only non-canceled rolls. So, the first non-canceled roll has score multiplied by , the second one has score multiplied by , and so on, till the last non-canceled roll.What maximum total score can Limak get?", "input": "The first line contains a single integer  () \u2014 the total number of rolls made by Limak. The second line contains  integers  ( \u2014 scores for Limak's rolls.", "output": "Print the maximum possible total score after cancelling rolls.", "tutorial": "The key is to use divide and conquer. We need a recursive function f(left, right) that runs f(left, mid) and f(mid+1, right) (where ) and also considers all intervals going through . We will eventually need a convex hull of lines (linear functions) and let's see how to achieve it.\nFor variables  (, ) we will try to write the score of interval  as a linear function. It would be good to get something close to  where  and  depend on , and  depends on  only.\n\nFor each  we should find a linear function  where  should fit the equation :\n\nNow we have a set of linear functions representing all possible left endpoints . For each right endpoint  we should find  and  to fit equation  again. With value of  we can iterate over functions  to find the one maximizing value of . And (still for fixed ) we should add  to get the maximum possible score of interval ending in .\n", "solution": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int nax = 1e6 + 5;\nll ans;\nll t[nax];\n\nstruct Fun {\n\tll a, b;\n\tll getValue(ll x) { return a * x + b; }\n};\n\nvoid rec(int first, int last) {\n\tif(first == last) {\n\t\tans = max(ans, t[first]);\n\t\treturn;\n\t}\n\tint mid = (first + last) / 2;\n\t\n\trec(first, mid); // the left half is [first, mid]\n\trec(mid+1, last); // the right half is [mid+1, last]\n\t\n\t// we must consider all intervals starting in [first,mid] and ending in [mid+1, last]\n\t\n\tvector<Fun> functions;\n\tll sum_so_far = 0; // t[i]+t[i+1]+...+t[mid]\n\tll score_so_far = 0; // t[i]*1 + t[i+1]*2 + ... + t[mid]*(mid-i+1)\n\tfor(int i = mid; i >= first; --i) {\n\t\tsum_so_far += t[i];\n\t\tscore_so_far += sum_so_far;\n\t\tfunctions.push_back(Fun{mid - i + 1, score_so_far});\n\t}\n\t\n\tsum_so_far = 0;\n\tscore_so_far = 0;\n\tfor(int i = mid+1; i <= last; ++i) {\n\t\tsum_so_far += t[i];\n\t\tscore_so_far += t[i] * (i - mid);\n\t\tfor(Fun & f : functions) {\n\t\t\tll score = score_so_far + f.getValue(sum_so_far);\n\t\t\tans = max(ans, score);\n\t\t}\n\t}\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%lld\", &t[i]);\n\trec(1, n);\n\tprintf(\"%lldn\", ans);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}