{"link": "https://codeforces.com//contest/1463/problem/C", "problemId": "836003", "shortId": "1463C", "contest_number": "1463", "name": "C. Busy Robot", "statement": "You have a robot that can move along a number line. At time moment  it stands at point .You give  commands to the robot: at time  seconds you command the robot to go to point . Whenever the robot receives a command, it starts moving towards the point  with the speed of  unit per second, and he stops when he reaches that point. However, while the robot is moving, it  all the other commands that you give him.For example, suppose you give three commands to the robot: at time  move to point , at time  move to point  and at time  move to point . Then the robot stands at  until time , then starts moving towards , ignores the second command, reaches  at time  and immediately starts moving to  to execute the third command. At time  it reaches  and stops there.You call the command  successful, if there is a time moment in the range  (i.\u00a0e. after you give this command and before you give another one, both bounds inclusive; we consider ) when the robot is at point . Count the number of successful commands. Note that it is possible that an ignored command is successful.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The next lines describe the test cases. The first line of a test case contains a single integer  ()\u00a0\u2014 the number of commands. The next  lines describe the commands. The -th of these lines contains two integers  and  (, )\u00a0\u2014 the time and the point of the -th command. The commands are ordered by time, that is,  for all possible . The sum of  over test cases does not exceed .", "output": "For each testcase output a single integer\u00a0\u2014 the number of successful commands.", "tutorial": "The main idea in the problem is not how to solve it but how to code it neatly. I've come up with the following way.Let's store three variables: where is the robot now, what direction does it move (,  or ) and how much time is left until it stops moving.The processing of the commands looks becomes pretty easy. If there is no time left to move then the command is executed, and we tell the robot the direction and the time left for the current command. Then there are two cases: either the robot stops before the next command or after it. However, they can be processed simultaneously.Let  be the minimum of the time left before the robot stops moving and the time before the next command. We sure know that before the next command the robot will visit exactly the segment of positions between the current position and the current position plus direction multiplied by . If the destination for the current command is in this segment, then that command is successful.After the command is processed subtract  from the time left and increase the position by direction multiplied by .Overall complexity:  per testcase.", "solution": "def inside(l, r, x):\n\treturn min(l, r) <= x <= max(l, r)\n\ndef sg(x):\n\treturn -1 if x < 0 else int(x > 0)\n\nfor _ in range(int(input())):\n\tn = int(input())\n\tqs = []\n\tfor i in range(n):\n\t\tqs.append(list(map(int, input().split())))\n\tqs.append([4*10**9, 0])\n\tans = 0\n\tpos, dr, lft = 0, 0, 0\n\tfor i in range(n):\n\t\tt, x = qs[i]\n\t\ttn = qs[i + 1][0]\n\t\tif lft == 0:\n\t\t\tlft = abs(pos - x)\n\t\t\tdr = sg(x - pos)\n\t\ttmp = min(lft, tn - t)\n\t\tif inside(pos, pos + dr * tmp, x):\n\t\t\tans += 1\n\t\tpos += dr * tmp\n\t\tlft -= tmp\n\tprint(ans)", "interactive": false, "noSolution": false, "noTutorial": false}