{"link": "https://codeforces.com//contest/1156/problem/E", "problemId": "338452", "shortId": "1156E", "contest_number": "1156", "name": "E. Special Segments of Permutation", "statement": "You are given a permutation  of  integers , , ...,  (a permutation is an array where each element from  to  occurs exactly once).Let's call some subsegment  of this permutation special if . Please calculate the number of special subsegments.", "input": "The first line contains one integer  (). The second line contains  integers , , ...,  (). All these integers are pairwise distinct.", "output": "Print the number of special subsegments of the given permutation.", "tutorial": "Let's fix the maximum element on segment and iterate on either the elements to the left of it or to the right of it, and if the current maximum is , and the element we found is , check whether the element  can form a special subsegment with  (that is,  is the maximum value on the segment between  and ). That obviously works in , yes?Well, not exactly. If we can precompute the borders of the segment where  is the maximum element (this can be done with some logarithmic data structure, or just by processing the array with a stack forwards and backwards) and always choose to iterate on the smaller part of the segment, it's . Why is it so? Every element will be processed no more than  times because, if we process it in a segment of size , the smaller part of it contains no more than  elements (which we will process later, and the smaller part of this segment contains no more than  elements, and so on). Checking whether the element belongs to the segment we are interested in can be done in  if we precompute inverse permutation for .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint lf[N];\nint rg[N];\nint n;\nint ans = 0;\nint p[N];\nint q[N];\n\nvoid update(int l, int r, int l2, int r2, int sum)\n{\n\tfor(int i = l; i <= r; i++)\n\t{\n\t\tint o = sum - p[i];\n\t\tif(o >= 1 && o <= n && l2 <= q[o] && q[o] <= r2)\n\t\t\tans++;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &p[i]);\n\t\tq[p[i]] = i;\n\t}\n\tstack<pair<int, int> > s;\n\ts.push(make_pair(n + 1, -1));\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\twhile(s.top().first < p[i])\n\t\t\ts.pop();\n\t\tlf[i] = s.top().second;\n\t\ts.push(make_pair(p[i], i));\n\t}\n\twhile(!s.empty())\n\t\ts.pop();\n\ts.push(make_pair(n + 1, n));\n\tfor(int i = n - 1; i >= 0; i--)\n\t{\n\t\twhile(s.top().first < p[i])\n\t\t\ts.pop();\n\t\trg[i] = s.top().second;\n\t\ts.push(make_pair(p[i], i));\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t//\tcerr << i << \" \" << lf[i] << \" \" << rg[i] << endl;\n\t\tint lenl = i - lf[i] - 1;\n\t\tint lenr = rg[i] - i - 1;\n\t\tif(lenl == 0 || lenr == 0)\n\t\t\tcontinue;\n\t\tif(lenl < lenr)\n\t\t\tupdate(lf[i] + 1, i - 1, i + 1, rg[i] - 1, p[i]);\n\t\telse\n\t\t\tupdate(i + 1, rg[i] - 1, lf[i] + 1, i - 1, p[i]);\n\t}\n\tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}