{"link": "https://codeforces.com//contest/1036/problem/E", "problemId": "216421", "shortId": "1036E", "contest_number": "1036", "name": "E. Covered Points", "statement": "You are given  segments on a Cartesian plane. Each segment's endpoints have integer coordinates. Segments can intersect with each other. No two segments lie on the same line.Count the number of distinct points with , which are covered by at least one segment.", "input": "The first line contains a single integer  () \u2014 the number of segments. Each of the next  lines contains four integers  () \u2014 the coordinates of the endpoints ,  () of the -th segment. It is guaranteed that no two segments lie on the same line.", "output": "Print a single integer \u2014 the number of distinct points with integer coordinates, which are covered by at least one segment.", "tutorial": "I won't tell all the small geometric details, just cover some major points.The problem asks you the following thing. Sum up the total number of points covered by each segment and for each unique point subtract the number of segments covering it minus one. Let's reformulate it. For each segment add the number of points covered by it and subtract the number of points covered by it and by some already processed segment.The first part is easy. Segment covers exactly  points with integer coordinates. The proof left to the reader as an exercise.The second part can be done in the following manner. Intersect the segment  with all segments , insert all the points of intersection into set and take its size. You can consider only integer points of intersection and use no floating-point numbers in your program.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 1000 + 7;\n\nstruct seg{\n    int x1, y1, x2, y2;\n    seg(){};\n};\n\nstruct line{\n    long long A, B, C;\n    line(){};\n    line(seg a){\n        A = a.y1 - a.y2;\n        B = a.x2 - a.x1;\n        C = -A * a.x1 - B * a.y1;\n    };\n};\n\nint n;\nseg a[N];\n\nint get(seg a){\n    int dx = a.x1 - a.x2;\n    int dy = a.y1 - a.y2;\n    return __gcd(abs(dx), abs(dy)) + 1;\n}\n\nlong long det(long long a, long long b, long long c, long long d){\n    return a * d - b * c;\n}\n\nbool in(int x, int l, int r){\n    if (l > r) swap(l, r);\n    return (l <= x && x <= r);\n}\n\nbool inter(seg a, seg b, int& x, int& y){\n    line l1(a), l2(b);\n    long long dx = det(l1.C, l1.B, l2.C, l2.B);\n    long long dy = det(l1.A, l1.C, l2.A, l2.C);\n    long long d = det(l1.A, l1.B, l2.A, l2.B);\n    if (d == 0)\n        return false;\n    if (dx % d != 0 || dy % d != 0)\n        return false;\n    x = -dx / d;\n    y = -dy / d;\n    if (!in(x, a.x1, a.x2) || !in(y, a.y1, a.y2))\n        return false;\n    if (!in(x, b.x1, b.x2) || !in(y, b.y1, b.y2))\n        return false;\n    return true;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n)\n        scanf(\"%d%d%d%d\", &a[i].x1, &a[i].y1, &a[i].x2, &a[i].y2);\n    \n    int ans = 0;\n    int x, y;\n    forn(i, n){\n        ans += get(a[i]);\n        set<pair<int, int>> pts;\n        forn(j, i)\n            if (inter(a[i], a[j], x, y))\n                pts.insert({x, y});\n        ans -= pts.size();\n    }\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}