{"link": "https://codeforces.com//contest/1661/problem/F", "problemId": "1361832", "shortId": "1661F", "contest_number": "1661", "name": "F. Teleporters", "statement": "There are  teleporters on a straight line, located in points , , , , ..., . It's possible to teleport from point  to point  if there are teleporters in  of those points, and it costs  energy.You want to install some additional teleporters so that it is possible to get from the point  to the point  (possibly through some other teleporters) spending  than  energy in total. Each teleporter you install must be located in an .What is the minimum number of teleporters you have to install?", "input": "The first line contains one integer  (). The second line contains  integers  (). The third line contains one integer  ().", "output": "Print one integer \u2014 the minimum number of teleporters you have to install so that it is possible to get from  to  spending at most  energy. It can be shown that it's always possible under the constraints from the input format.", "tutorial": "Initial  portals divide the path from  to  into  separate sections. If we place a new portal between two given ones, it only affects the section between these two portals.Let's suppose we want to place  new portals into a section of length . This will divide it into  sections, and it's quite easy to prove that these sections should be roughly equal in size (to prove it, we can show that if the sizes of two sections differ by more than , the longer one can be shortened and the shorter one can be elongated so the sum of squares of their lengths decreases). So, a section of length  should be divided into  sections of length  and  sections of length . Let's denote the total energy cost of a section of length  divided by  new portals as ; since we divide it in roughly equal parts, it's easy to see thatThe key observation that we need to make now is that ; i.\u2009e. if we add more portals to the same section, the energy cost change from adding a new portal doesn't go up. Unfortunately, we can't give a simple, strict proof of this fact, but we have faith and stress (this would be easy to prove if it was possible to place portals in non-integer points, we could just analyze the derivative, but in integer case, it's way more difficult).Okay, what should we do with the fact that  for a section of length ? The main idea of the solution is binary search over the value of ; i.\u2009e., we use binary search to find the minimum possible change that a new portal would give us. Let's say that we want to check that using the portals that give the cost change  is enough; then, for each section, we want to find the number of new portals  such that , but ; we can use another binary search to do that. For a fixed integer , we can calculate not only the number of new portals that we can add if the cost change for each portal should be at least , but also the total cost of the path after these changes; let's denote  as the total cost of the path if we place new portals until the cost change is less than , and  is the number of portals we will place in that case.We have to find the minimum value of  such that . Now, it looks like  is the answer, but this solution gives WA on one of the sample tests. The key observation we are missing is that, for the value , we don't have to add all of the portals that change the answer by ; we might need only some of them. To calculate the answer, let's compute four values:  ;  ;  ;  . If we place  portals and add new portals one by one, until the total cost becomes not greater than , the cost change from each new portal will be equal to  (or just  if we consider the fact that we start using the portals which change the cost by ). So, we can easily calculate how many more additional portals we need to add if we start from  portals and cost .The total complexity of our solution is : we have a binary search over the cost change for each new portal; and for a fixed cost change, to determine the number of portals we place in each section, we run another binary search in every section separately.", "solution": "#include <bits/stdc++.h>     \n\nusing namespace std;\n\nint n;\nvector<int> lens;\n\nlong long sqr(int x)\n{\n    return x * 1ll * x;\n}\n\nlong long eval_split(int len, int k)\n{\n    return sqr(len / k) * (k - len % k) + sqr(len / k + 1) * (len % k);\n}\n\npair<int, long long> eval_segment(int len, long long bound)\n{\n    // only take options with value >= bound\n    if(bound <= 2 || len == 1)\n        return make_pair(len - 1, len);\n    int lf = 0;\n    int rg = len - 1;\n    while(rg - lf > 1)\n    {\n        int mid = (lf + rg) / 2;\n        if(eval_split(len, mid) - eval_split(len, mid + 1) >= bound)\n            lf = mid;\n        else\n            rg = mid;    \n    }\n    return make_pair(lf, eval_split(len, lf + 1));\n}\n\npair<int, long long> eval_full(long long bound)\n{\n    pair<int, long long> ans;\n    for(auto x : lens)\n    {\n        pair<int, long long> cur = eval_segment(x, bound);\n        ans.first += cur.first;\n        ans.second += cur.second;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    int pr = 0;\n    for(int i = 0; i < n; i++)\n    {\n        int x;\n        scanf(\"%d\", &x);\n        lens.push_back(x - pr);\n        pr = x;\n    }\n    long long w;\n    scanf(\"%lld\", &w);\n    long long lf = 0ll;\n    long long rg = (long long)(1e18) + 43;\n    if(eval_full(rg).second <= w)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n    while(rg - lf > 1)\n    {\n        long long mid = (lf + rg) / 2;\n        pair<int, long long> res = eval_full(mid);\n        if(res.second <= w)\n            lf = mid;\n        else\n            rg = mid;\n    }   \n    pair<int, long long> resL = eval_full(lf);\n    pair<int, long long> resR = eval_full(rg);\n    assert(resL.second <= w && resR.second > w);\n    long long change = (resR.second - resL.second) / (resR.first - resL.first);\n    cout << resL.first + (w - resL.second) / change << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}