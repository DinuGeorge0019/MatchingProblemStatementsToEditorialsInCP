{"link": "https://codeforces.com//contest/961/problem/F", "problemId": "171417", "shortId": "961F", "contest_number": "961", "name": "F. k-substrings", "statement": "You are given a string  consisting of  lowercase Latin letters.Let's denote -substring of  as a string . Obviously, , and there are exactly  such substrings.Let's call some string  an  of a string  iff the following conditions are met: ;   is an odd number;   is simultaneously a prefix and a suffix of .For evey -substring () of  you have to calculate the maximum length of its odd proper suprefix.", "input": "The first line contains one integer   \u2014 the length . The second line contains the string  consisting of  lowercase Latin letters.", "output": "Print  integers. -th of them should be equal to maximum length of an odd proper suprefix of -substring of  (or , if there is no such string that is an odd proper suprefix of -substring).", "tutorial": "Let's look at suprefix of fixed -substring: we can't find its maximal length via binary search because this function isn't monotone in general case. But, by fixing not the left border but the center of the prefix, we also fix the center of the corresponding suffix (center of a prefix in position  is tied with the center of the suffix in position ), and, more important, function becomes monotone.So solution is next: iterate over all valid centers of prefix  and try to binary search maximal length  of such substring that its center is in position , and it's equal to the substing with center in .  then can be updated with value . And don't forget to update each  with value .Easy way to check substrings for equality is to use hashes. Harder way is to use string suffix structures (like bundle of Suffix Array + LCP + Sparse Table or Suffix Tree + LCA).Note for SuffArray users: don't forget about changing sort to stable_sort (merge sort) and breaking if all suffixes are different. This optimizations can save you from writing radix (or bucket) sort.", "solution": "#include <bits/stdc++.h>\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int(a.size())\n#define mp make_pair\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int LOGN = 21;\nconst int N = 1000 * 1000 + 555;\n\nint n;\nstring s;\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\t\n\tchar buf[N];\n\tassert(scanf(\"%s\", buf) == 1);\n\ts = buf;\n\treturn true;\n}\n\npair<pt, int> d[N], curP[N];\nint szd = 0;\n\nint cnt[N], szcnt;\nint rdp[N];\n\ninline void radix_sort() {\n\tfore(k, 0, 2) {\n\t\tszcnt = 0;\n\t\tfore(i, 0, szd) {\n\t\t\tint val = k == 0 ? d[i].x.y : d[i].x.x;\n\t\t\twhile(szcnt <= val)\n\t\t\t\tcnt[szcnt++] = 0;\n\t\t\tcnt[val]++;\n\t\t}\n\t\tint sum = 0;\n\t\tfore(i, 0, szcnt) {\n\t\t\trdp[i] = sum;\n\t\t\tsum += cnt[i];\n\t\t}\n\t\t\n\t\tfore(i, 0, szd) {\n\t\t\tint val = k == 0 ? d[i].x.y : d[i].x.x;\n\t\t\tcurP[rdp[val]++] = d[i];\n\t\t}\n\t\tfore(i, 0, szd)\n\t\t\td[i] = curP[i];\n\t}\n}\n\nint c[N], id[N];\nint lcp[N];\n\nint lg[N];\nint st[LOGN][N];\n\nvoid precalc() {\n\ts += '$';\n\tfor(int len = 1; len < 2 * sz(s); len <<= 1) {\n\t\tszd = 0;\n\t\tfore(i, 0, sz(s)) {\n\t\t\tint sh = len >> 1;\n\t\t\td[szd++] = {len == 1 ? mp((int)s[i], 0) : mp(c[i], c[(i + sh) % sz(s)]), i};\n\t\t}\n\t\tradix_sort();\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, szd)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i - 1].x != d[i].x);\n\t\t\n\t\tif(c[d[szd - 1].y] == sz(s) - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, sz(s)) {\n\t\tc[i]--;\n\t\tif(c[i] >= 0) id[c[i]] = i;\n\t}\n\ts.pop_back();\n\t\n\tint l = 0;\n\tfore(i1, 0, n) {\n\t\tl = max(l - 1, 0);\n\t\tif(c[i1] == n - 1)\n\t\t\tcontinue;\n\t\t\n\t\tint i2 = id[c[i1] + 1];\n\t\twhile(i1 + l < n && i2 + l < n && s[i1 + l] == s[i2 + l])\n\t\t\tl++;\n\t\tlcp[c[i1]] = l;\n\t}\n\t\n\tlg[0] = 0;\n\tfore(i, 1, N) {\n\t\tlg[i] = lg[i - 1];\n\t\tif((1 << (lg[i] + 1)) <= i)\n\t\t\tlg[i]++;\n\t}\n\t\n\tfore(pw, 0, LOGN) {\n\t\tif(pw == 0) {\n\t\t\tfore(i, 0, n)\n\t\t\t\tst[pw][i] = lcp[i];\n\t\t\tcontinue;\n\t\t}\n\t\tfore(i, 0, n) {\n\t\t\tst[pw][i] = st[pw - 1][i];\n\t\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\t\tst[pw][i] = min(st[pw][i], st[pw - 1][i + (1 << (pw - 1))]);\n\t\t}\n\t}\n}\n\ninline int getMin(int l, int r) {\n\tif(l >= r) swap(l, r);\n\t\n\tint len = lg[r - l];\n\treturn min(st[len][l], st[len][r - (1 << len)]);\n}\n\ninline bool eq(int i1, int i2, int l) {\n\tif(i1 == i2) return true;\n\treturn getMin(c[i1], c[i2]) >= l;\n}\n\nint l[N], mx[N];\n\ninline void solve() {\n\tprecalc();\n\t\n\tfore(i, 0, n / 2) {\n\t\tint c1 = i, c2 = n - 1 - i;\n\t\tif(s[c1] != s[c2]) {\n\t\t\tl[i] = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tint lf = 0, rg = min(c1, n - 1 - c2) + 1;\n\t\twhile(rg - lf > 1) {\n\t\t\tint mid = (lf + rg) >> 1;\n\t\t\t\n\t\t\tif(eq(c1 - mid, c2 - mid, 2 * mid + 1))\n\t\t\t\tlf = mid;\n\t\t\telse\n\t\t\t\trg = mid;\n\t\t}\n\t\tl[i] = lf;\n\t}\n\t\n\tfore(i, 0, n / 2) {\n\t\tif(l[i] < 0)\n\t\t\tcontinue;\n\t\tmx[i - l[i]] = max(mx[i - l[i]], 2 * l[i] + 1);\n\t}\n\tfore(i, 1, n / 2)\n\t\tmx[i] = max(mx[i], mx[i - 1] - 2);\n\n\tfore(i, 0, (n + 1) / 2) {\n\t\tif(i) printf(\" \");\n\t\tprintf(\"%d\", mx[i] == 0 ? -1 : mx[i]);\n\t}\n\tputs(\"\");\n}\n\nint main(){\n\tif(read()) {\n\t\tsolve();\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}