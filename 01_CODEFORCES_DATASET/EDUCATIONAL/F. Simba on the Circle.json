{"link": "https://codeforces.com//contest/612/problem/F", "problemId": "43955", "shortId": "612F", "contest_number": "612", "name": "F. Simba on the Circle", "statement": "You are given a circular array with  elements. The elements are numbered from some element with values from  to  in clockwise order. The -th cell contains the value . The robot Simba is in cell .Each moment of time the robot is in some of the  cells (at the begin he is in ). In one turn the robot can write out the number written in current cell or move to the adjacent cell in clockwise or counterclockwise direction. To write out the number from the cell Simba doesn't spend any time, but to move to adjacent cell Simba spends one unit of time.Simba wants to write the number from each cell one time, so the numbers will be written in a non decreasing order. Find the least number of time units to write out all numbers.", "input": "The first line contains two integers  and  () \u2014 the number of cells in the circular array and the starting position of Simba. The second line contains  integers  () \u2014 the number written in the -th cell. The numbers are given for cells in order from  to . Some of numbers  can be equal.", "output": "In the first line print the number  \u2014 the least number of time units. Each of the next  lines should contain the direction of robot movement and the number of cells to move in that direction. After that movement the robot writes out the number from the cell in which it turns out. The direction and the number of cells should be printed in the form of  in case of clockwise movement and  in case of counterclockwise movement to  cells (). Note that the sum of absolute values of  should be equal to .", "tutorial": "The author solution for this problem uses dynamic programming. I think that this problem can't be solved by greedy ideas. Let's calculate two dp's: z1i is the answer to the problem if all numbers less than ai are already printed, but the others are not; and z2i is the answer to the problem if all numbers less than or equal to ai are already printed, but the others are not. Let's denote dij \u2014 the least distance between i and j on the circular array and odij is the distance from i to j in clockwise order. Easy to see that z2i\u2009=\u2009minj(zj\u2009+\u2009dij) for all j such that the value aj is the least value greater than ai. Now let's calculate the value z1i. Consider all elements equals to ai (in one of them we are). If there is only one such element then z1i\u2009=\u2009z2i. Otherwise we have two alternatives: to move in clockwise or counterclockwise direction. Let we are moving in clockwise direction, the last element from which we will write out the number would be the nearest to the i element in counterclockwise direction, let's denote it u. Otherwise at last we will write out the number from the nearest to the i element in clockwise direction, let's denote it v. Now z1i\u2009=\u2009min(z2u\u2009+\u2009odiu,\u2009z2v\u2009+\u2009odvi). Easy to see that the answer to the problem is mini(z1i\u2009+\u2009dsi), over all i such that ai is the smallest value in array and s is the start position.\nAdditionally you should restore the answer. To do that, on my mind, the simplest way is to write the recursive realization of dp, test it carefully and then copy it to restore answer (see my code below). Of course, it's possible to restore the answer without copy-paste. For example, you can add to your dp parameter b which means it's need to restore answer or not.\nComplexity: O(n2).\nCode\n", "solution": "/*\nBearing the mark of a demon from hell the dragon is cast onto the earth\nSeeking revenge on the woman of man Satanus unleashes his wrath\nAngels of death are the allies of hate the jackals destroying the cross\n\n[Chorus:]\nFighting with fire the dragon attacks\nBurning the cross and unleashing the powers of hell\nCursed are the mortals who dare to fight with the beast\n\nDemons of hell bear the mark of the beast the sons of the dragon are born\nSummoned to earth armageddon is here to slaughter the christian hordes\nDestroying the temples Jehova has lost the nazarene will fester in hell\n\n[Chorus]\n\nA wrathful attack upon the christian faith the legions of Satan make war\nReplacing the cross with the mark of the beast the kingdoms of Jesu have fell\nDemons of hell armageddon is here preventing the coming of christ\nrelinquish your god now that satan is king the nazarene will never arise\n\nBearing the mark of a demon from hell the dragon is cast onto earth\nSeeking revenge on the woman of man Satanus unleashes his wrath\nAngels of death are the allies of hate the jackals destroying the cross\n\n[Chorus]\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define prev asdfasdgasdg\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 2200;\n\nusing namespace std;\n\nint n, s;\nint ar[N];\nvector<int> v;\nint need_val, need_cnt;\nvector<pair<int, int> > avec;\nvector<int> entries[N];\nint prev[N], nxt[N];\nmap<int, int> mapp;\nint dp[N][2];\npair<int, int> par[N][2];\nint cnt;\n\nvoid remap()\n{\n\tsort(v.begin(), v.end());\n\tcnt = 0;\n\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tif (i>0 && v[i] == v[i - 1])\n\t\t\tcontinue;\n\t\tmapp[v[i]] = cnt;\n\t\t++cnt;\n\t}\n}\n\nint get_dist(int a, int b)\n{\n\ta = abs(a - b);\n\tif (a > n - a)\n\t\ta = n - a;\n\treturn a;\n}\n\nvector<pair<int, int> > qmoves,vec1,vec2;\n\nint eval(int a, int b, int dir)\n{\n\tint have = 0;\n\tint moves = 0;\n\tqmoves.clear();\n\tint moves2 = 0;\n\n\twhile (true)\n\t{\n\t\tif (ar[a] == need_val||a==b)\n\t\t{\n\t\t\tif (ar[a]==need_val)\n\t\t\t\t++have;\n\t\t\tqmoves.push_back(make_pair(moves2, dir));\n\t\t\tmoves2 = 0;\n\t\t}\n\t\tif (a == b)\n\t\t\tbreak;\n\t\t++moves;\n\t\t++moves2;\n\t\ta += dir;\n\t\tif (a < 0)\n\t\t\ta += n;\n\t\tif (a >= n)\n\t\t\ta -= n;\n\t}\n\tif (have < need_cnt)\n\t\treturn 1e9;\n\treturn moves;\n}\n\nvoid show(vector<pair<int, int> > v)\n{\n\tfor (int i = 0; i < v.size(); i++)\n\t\tcout << v[i].first << \" \" << v[i].second << endl;\n\tcout << endl;\n}\n\nint main(){\n\t//freopen(\"beavers.in\",\"r\",stdin);\n\t//freopen(\"beavers.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\",\"r\",stdin);\n\t//freopen(\"F:/output.txt\",\"w\",stdout);\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin >> n >> s;\n\n\t--s;\n\n\tfor (int i = 0; i <n; i++)\n\t{\n\t\tcin >> ar[i];\n\t\tv.push_back(ar[i]);\n\t}\n\n\tremap();\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tar[i] = mapp[ar[i]];\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (entries[ar[i]].size())\n\t\t\tprev[i] = entries[ar[i]].back(),\n\t\t\tnxt[entries[ar[i]].back()] = i,\n\t\t\tprev[entries[ar[i]][0]] = i,\n\t\t\tnxt[i] = entries[ar[i]][0];\n\t\tentries[ar[i]].push_back(i);\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (entries[ar[i]].size() == 1)\n\t\t{\n\t\t\tprev[i] = nxt[i] = i;\n\t\t}\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcout << i << \" \" << prev[i] << \" \" << nxt[i] << \" \" << ar[i] << \" \" << cnt << endl;\n\t}\n\t*/\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdp[i][0] = dp[i][1] = 1e9;\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (ar[i] == 0)\n\t\t{\n\t\t\tdp[i][0] = get_dist(s, i);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < entries[i].size(); j++)// 0 moves\n\t\t{\n\t\t\tint ps = entries[i][j];\n\t\t\tint R = nxt[ps];\n\t\t\tint L = prev[ps];\n\t\t\tif (L == ps)\n\t\t\t{\n\t\t\t\tif (dp[ps][1]>dp[ps][0])\n\t\t\t\t{\n\t\t\t\t\tdp[ps][1] = dp[ps][0];\n\t\t\t\t\tpar[ps][1] = make_pair(ps, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint dist_L;\n\t\t\tif (L < ps)\n\t\t\t\tdist_L = ps - L;\n\t\t\telse\n\t\t\t\tdist_L = ps + n - L;\n\t\t\tint dist_R;\n\t\t\tif (R>ps)\n\t\t\t\tdist_R = R - ps;\n\t\t\telse\n\t\t\t\tdist_R = R + n - ps;\n\n\t\t\tif (dp[L][1] > dp[ps][0] + (n - dist_L))\n\t\t\t{\n\t\t\t\tdp[L][1] = dp[ps][0] + (n - dist_L);\n\t\t\t\tpar[L][1] = make_pair(ps, 0);\n\t\t\t}\n\t\t\tif (dp[R][1] > dp[ps][0] + (n - dist_R))\n\t\t\t{\n\t\t\t\tdp[R][1] = dp[ps][0] + (n - dist_R);\n\t\t\t\tpar[R][1] = make_pair(ps, 0);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < entries[i].size(); j++)\n\t\t{\n\t\t\tint ps = entries[i][j];\n\t\t\tfor (int q = 0; q < entries[i + 1].size(); q++)\n\t\t\t{\n\t\t\t\tint ps2 = entries[i + 1][q];\n\t\t\t\tint D = get_dist(ps2, ps);\n\t\t\t\tif (dp[ps2][0]>dp[ps][1] + D)\n\t\t\t\t{\n\t\t\t\t\tdp[ps2][0] = dp[ps][1] + D;\n\t\t\t\t\tpar[ps2][0] = make_pair(ps, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n//\tcout << dp[0][0] << endl;\n\n\tint qi, qj;\n\n\tint ans = 1e9;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (ar[i] == cnt - 1)\n\t\t{\n\t\t\tif (dp[i][1] < ans)\n\t\t\t{\n\t\t\t\tans = dp[i][1];\n\t\t\t\tqi = i;\n\t\t\t\tqj = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\t//cout << ans << \" \"<<qi<<\" \"<<qj<<endl;\n\n\twhile (ar[qi] != 0 || qj != 0)\n\t{\n\t\tpair<int, int> p2 = par[qi][qj];\n\t\tif (qj == 0 && p2.second == 1)\n\t\t{\n\t\t\tneed_val = -1;\n\t\t\tneed_cnt = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tneed_val = ar[qi];\n\t\t\tneed_cnt = entries[ar[qi]].size();\n\t\t}\n\t\tint cost1 = eval(p2.first, qi,1);\n\t\tvec1 = qmoves;\n\t\tint cost2 = eval(p2.first, qi, -1);\n\t\tvec2 = qmoves;\n\n\t\treverse(vec1.begin(), vec1.end());\n\t\treverse(vec2.begin(), vec2.end());\n\t\t/*\n\t\tshow(vec1);\n\t\tshow(vec2);\n\t\tcout << cost1 << \"!\" << cost2 << endl;\n\t\t*/\n\t\tif (cost1 < cost2)\n\t\t{\n\t\t\tfor (int q = 0; q < vec1.size(); q++)\n\t\t\t{\n\t\t\t\tavec.push_back(vec1[q]);\n\t\t\t}\n\t//\t\tavec.push_back(make_pair(cost1, 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int q = 0; q < vec2.size(); q++)\n\t\t\t{\n\t\t\t\tavec.push_back(vec2[q]);\n\t\t\t}\n//\t\t\tavec.push_back(make_pair(cost2, -1));\n\t\t}\n\t\tqi = p2.first;\n\t\tqj = p2.second;\n\t}\n\t\n//\tcout << qi << \"%\" << qj << \" \"<<dp[qi][qj]<<endl;\n\n\t// 1 move\n\n\tneed_val = -1;\n\tneed_cnt = 0;\n\tint cost1 = eval(s, qi, 1);\n\tvec1 = qmoves;\n\tint cost2 = eval(s, qi, -1);\n\tvec2 = qmoves;\n\treverse(vec1.begin(), vec1.end());\n\treverse(vec2.begin(), vec2.end());\n\t/*\n\tshow(vec1);\n\tshow(vec2);\n\tcout << \"!\" << cost1 << \" \" << cost2 << endl;\n\t*/\n\tif (cost1 < cost2)\n\t{\n\n\t\tfor (int q = 0; q < vec1.size(); q++)\n\t\t{\n\t\t\tavec.push_back(vec1[q]);\n\t\t}\n//\t\tavec.push_back(make_pair(cost1, 1));\n\t}\n\telse\n\t{\n\n\t\tfor (int q = 0; q < vec2.size(); q++)\n\t\t{\n\t\t\tavec.push_back(vec2[q]);\n\t\t}\n//\t\tavec.push_back(make_pair(cost2, -1));\n\t}\n\treverse(avec.begin(), avec.end());\n\n\tfor (int i = 0; i < avec.size(); i++)\n\t{\n\t\tif (i != 0 && avec[i].first == 0)\n\t\t\tcontinue;\n\t\tif (avec[i].second == 1)\n\t\t\tcout << \"+\";\n\t\telse\n\t\t\tcout << \"-\";\n\t\tcout << avec[i].first;\n\t\tcout << endl;\n\t}\n\n\tcin.get(); cin.get();\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}