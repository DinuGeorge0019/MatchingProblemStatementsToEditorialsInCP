{"link": "https://codeforces.com//contest/660/problem/C", "problemId": "54413", "shortId": "660C", "contest_number": "660", "name": "C. Hard Process", "statement": "You are given an array  with  elements. Each element of  is either  or .Let's denote the length of the longest subsegment of consecutive elements in , consisting of only numbers one, as . You can change no more than  zeroes to ones to maximize .", "input": "The first line contains two integers  and  () \u2014 the number of elements in  and the parameter . The second line contains  integers  () \u2014 the elements of .", "output": "On the first line print a non-negative integer  \u2014 the maximal value of  after no more than  changes of zeroes to ones. On the second line print  integers  \u2014 the elements of the array  after the changes. If there are multiple answers, you can print any one of them.", "tutorial": "Let's call the segment  good if it contains no more than  zeroes. Note if segment  is good than the segment  is also good. So we can use the method of two pointers: the first pointer is  and the second is . Let's iterate over  from the left to the right and move  while we can (to do that we should simply maintain the number of zeroes in the current segment).\n", "solution": "const int N = 1200300;\n\nint n, k;\nint a[N];\n\nbool read() {\n\tif (!(cin >> n >> k)) return false;\n\tforn(i, n) assert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\nvoid solve() {\n\tint ansl = 0, ansr = 0;\n\tint j = 0, cnt = 0;\n\tforn(i, n) {\n\t\tif (j < i) {\n\t\t\tj = i;\n\t\t\tcnt = 0;\n\t\t}\n\n\t\twhile (j < n) {\n\t\t\tint ncnt = cnt + !a[j];\n\t\t\tif (ncnt > k) break;\n\t\t\tcnt += !a[j];\n\t\t\tj++;\n\t\t}\n\t\t\n\t\tif (j - i > ansr - ansl)\n\t\t\tansl = i, ansr = j;\n\n\t\tif (cnt > 0) cnt -= !a[i];\n\t}\n\n\tcout << ansr - ansl << endl;\n\tfore(i, ansl, ansr) a[i] = 1;\n\tforn(i, n) {\n\t\tif (i) putchar(' ');\n\t\tprintf(\"%d\", a[i]);\n\t}\n\tputs(\"\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}