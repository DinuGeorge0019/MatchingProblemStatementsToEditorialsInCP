{"link": "https://codeforces.com//contest/1400/problem/A", "problemId": "709183", "shortId": "1400A", "contest_number": "1400", "name": "A. String Similarity", "statement": "A binary string is a string where each character is either  or . Two binary strings  and  of equal length are , if they have the same character in some position (there exists an integer  such that ). For example:   and  are  (they have the same character in position );   and  are ;   and  are ;   and  are not . You are given an integer  and a binary string  consisting of  characters. Let's denote  as the contiguous substring of  starting with -th character and ending with -th character (in other words, ).You have to construct a binary string  of length  which is  to : , , , ..., .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains a single integer  (). The second line of each test case contains the binary string  of length . Each character  is either  or .", "output": "For each test case, print the corresponding binary string  of length . If there are multiple such strings \u2014 print any of them. It can be shown that at least one string  meeting the constraints always exists.", "tutorial": "We just need to make sure our string of  characters matches each of the  substrings in at least one spot. The easiest way to do this is to take every other character from . Code: 90908018\nAnother fun solution: we can generate random strings and check them until we find one that matches everything. This works because the probability of failing to match any particular substring is , so as  gets bigger the probability of failing gets extremely low. Code: 90999219\n", "solution": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int N;\n    string S;\n    cin >> N >> S;\n    string ans;\n\n    for (int i = 0; i < int(S.size()); i += 2)\n        ans += S[i];\n\n    cout << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}