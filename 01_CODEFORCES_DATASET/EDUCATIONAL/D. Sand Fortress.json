{"link": "https://codeforces.com//contest/985/problem/D", "problemId": "184585", "shortId": "985D", "contest_number": "985", "name": "D. Sand Fortress", "statement": "You are going to the beach with the idea to build the greatest sand castle ever in your head! The beach is not as three-dimensional as you could have imagined, it can be decribed as a line of spots to pile up sand pillars. Spots are numbered  through infinity from left to right. Obviously, there is not enough sand on the beach, so you brought  packs of sand with you. Let height  of the sand pillar on some spot  be the number of sand packs you spent on it.  There is a fence of height equal to the height of pillar with  sand packs to the left of the first spot and you should prevent sand from going over it. Finally you ended up with the following conditions to building the castle:  : no sand from the leftmost spot should go over the fence;  For any  : large difference in heights of two neighboring pillars can lead sand to fall down from the higher one to the lower, you really don't want this to happen;  : you want to spend all the sand you brought with you. As you have infinite spots to build, it is always possible to come up with some valid castle structure. Though you want the castle to be as compact as possible. Your task is to calculate the minimum number of spots you can occupy so that all the aforementioned conditions hold.", "input": "The only line contains two integer numbers  and  () \u2014 the number of sand packs you have and the height of the fence, respectively.", "output": "Print the minimum number of spots you can occupy so the all the castle building conditions hold.", "tutorial": "Let's consider the optimal answer to always look like  will be the leftmost position of a pillar with maximum height. We will heavily use the fact that all integers from  to  appear in this sequence to the right of .If you are able to construct any answer, it is easy to rearrange it to this pattern: select the leftmost maximum , sort  in non-decreasing order and  in non-increasing order. Sorted sequence will also be valid.Let a pyramid of height  be such a valid castle that it occupies exactly  consecutive spots and . Exactly  sand packs are required to build it.At first let's solve the problem without even touching the fence. This won't always give the minimal answer but it'll help us further. Given some  you can build the pyramid of height  and get  sand packs left over. This can fit in exactly  pillars (you can place any pillar of height  next to some pillar of the same height). That way we see that . This function is non-increasing, let's show that for any  from  to   is non-positive. =  =  =  =  =  = .       .Now we can show that it is always optimal to push the initial pyramid to the left as far as possible, probably removing some pillars on positions less than . That way the leftmost pillar will have height . The total number of sand packs required to build it is . This pattern will also include all the integers from  to  and will have the minimal width you can achieve. Monotonicity of this function can be proven in the similar manner.Finally, the answer can be calculated using the following algorithm:  Find the maximum  such that , where . Solve the equation or just do the binary search;  Output the width of resulting truncated pyramid plus the minimal number of additional pillars it will take to distribute leftover sand packs. You should also take into consideration the upper bound on  to avoid multiplying huge numbers. It's about , so -bit integer type will be enough for all the calculations.Overall complexity:  or .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\ntypedef long long li;\n\nusing namespace std;\n\nconst int INF = 2e9;\nli n, h;\n\nbool check(li maxh){\n\tli k = min(h, maxh);\n\tli cnt = maxh * maxh - k * (k - 1) / 2;\n\treturn (cnt <= n);\n}\n\nli get(li maxh){\n\tli k = min(h, maxh);\n\tli cnt = maxh * maxh - k * (k - 1) / 2;\n\tli len = (2 * maxh - 1) - (k - 1);\n\tn -= cnt;\n\treturn len + (n + maxh - 1) / maxh;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &h);\n\tli l = 1, r = INF;\n\t\n\twhile (l < r - 1){\n\t\tli m = (l + r) / 2;\n\t\t\n\t\tif (check(m))\n\t\t\tl = m;\n\t\telse\n\t\t\tr = m;\n\t}\n\t\n\tprintf(\"%lld\\n\", check(r) ? get(r) : get(l));\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}