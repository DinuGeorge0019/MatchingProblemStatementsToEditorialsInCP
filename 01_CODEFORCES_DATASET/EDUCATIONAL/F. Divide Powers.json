{"link": "https://codeforces.com//contest/1452/problem/F", "problemId": "802109", "shortId": "1452F", "contest_number": "1452", "name": "F. Divide Powers", "statement": "You are given a multiset of powers of two. More precisely, for each  from  to  exclusive you have  elements equal to .In one operation, you can choose any one element  and divide it into two elements .You should perform  queries. Each query has one of two types:   \"  \"\u00a0\u2014 assign ;  \"  \"\u00a0\u2014 calculate the minimum number of operations you need to make at least  elements with value lower or equal to . Note that all queries of the second type don't change the multiset; that is, you just calculate the minimum number of operations, you don't perform them.", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the size of array  and the number of queries. The second line contains  integers  (). Next  lines contain queries: one per line. Each query has one of two types:    \"  \" (; );  \"  \" (; ).  It's guaranteed that there is at least one query of the second type.", "output": "For each query of the second type, print the minimum number of operations you need to make at least  elements with a value lower or equal to  or  if there is no way to do it.", "tutorial": "Several observations:Generally, we have two types of operations: divide  and either  or . If  then in one division we'll get  element , so we can just keep track of the total possible number of these operations as .If  then if we decide to split whole  to -s then we get  elements  but in  operations, i.\u00a0e. in one division we'll get  elements. So it's preferably to fully split  than . Also, the less \u00a0\u2014 the more profitable each division.As a result, let's act greedy: let's say, we need  more elements . Let's iterate over  in the increasing order.  If  then let's fully split  in  in  operations, decrease , increase a counter of operations  and increase  accordingly.  If  then the situation becomes complicated. We can either don't touch  and try to use preserved operations with small  if , or split  in two -s. Now we spent one operation and get two .   If  then we don't need one of  and can split further only one .  If  then it's optimal to fully split one of  and proceed further with only one  and recalculated ,  and .  In both cases we can solve optimal splitting of  recursively in the same manner as . Since in each step we lower  then we need to check only  cases per each query. Note, that we can treat situation  () in packs for several  with equal , so the first part also works in .The resulting complexity is  per query.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9;\n\nint n, q;\nvector<li> cnt;\n\ninline bool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tcnt.assign(n, 0);\n\tfore (i, 0, n)\n\t\tcin >> cnt[i];\n\treturn true;\n}\n\ninline void solve() {\n\tfore (qs, 0, q) {\n\t\tint tp, pos;\n\t\tli val;\n\t\tcin >> tp >> pos >> val;\n\t\tif (tp == 1) {\n\t\t\tcnt[pos] = val;\n\t\t} else {\n\t\t\tli small = 0, cur = 0;\n\t\t\tfore (i, 0, pos + 1) {\n\t\t\t\tsmall += cnt[i] * ((1ll << i) - 1);\n\t\t\t\tval -= cnt[i];\n\t\t\t}\n\t\t\tif (val <= 0) {\n\t\t\t\tcout << 0 << '\\n';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint id = pos + 1;\n\t\t\twhile (id < n) {\n\t\t\t\tli add = 1ll << (id - pos);\n\t\t\t\tli need = min(val / add, cnt[id]);\n\t\t\t\tcur += need * (add - 1);\n\t\t\t\tval -= need * add;\n\t\t\t\tsmall += need * add * ((1ll << pos) - 1);\n\t\t\t\t\n\t\t\t\tif (need == cnt[id])\n\t\t\t\t\tid++;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (val <= 0) {\n\t\t\t\tcout << cur << '\\n';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (id >= n) {\n\t\t\t\tcout << (val > small ? -1 : cur + val) << '\\n';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tli ans = INF64;\n\t\t\twhile (id > pos) {\n\t\t\t\tif (small >= val)\n\t\t\t\t\tans = min(ans, cur + val);\n\t\t\t\tcur++;\n\t\t\t\tid--;\n\t\t\t\tli add = 1ll << (id - pos);\n\t\t\t\tif (val >= add) {\n\t\t\t\t\tcur += add - 1;\n\t\t\t\t\tval -= add;\n\t\t\t\t\tsmall += add * ((1ll << pos) - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(val <= 0);\n\t\t\tcout << min(ans, cur) << endl;\n\t\t}\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}