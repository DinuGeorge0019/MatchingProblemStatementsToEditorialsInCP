{"link": "https://codeforces.com//contest/616/problem/C", "problemId": "45346", "shortId": "616C", "contest_number": "616", "name": "C. The Labyrinth", "statement": "You are given a rectangular field of  cells. Each cell is either empty or impassable (contains an obstacle). Empty cells are marked with '', impassable cells are marked with ''. Let's call two empty cells  if they share a side.Let's call a  any non-extendible set of cells such that any two of them are connected by the path of adjacent cells. It is a typical well-known definition of a connected component.For each impassable cell  imagine that it is an empty cell (all other cells remain unchanged) and find the size (the number of cells) of the connected component which contains . You should do it for each impassable cell independently.The answer should be printed as a matrix with  rows and  columns. The -th symbol of the -th row should be \"\" if the cell is empty at the start. Otherwise the -th symbol of the -th row should contain the only digit \u2014- the answer modulo . The matrix should be printed without any spaces.To make your output faster it is recommended to build the output as an array of  strings having length  and print it as a sequence of lines. It will be much faster than writing character-by-character.As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use  instead of  in C++, prefer to use  instead of  in .", "input": "The first line contains two integers  () \u2014 the number of rows and columns in the field. Each of the next  lines contains  symbols: \"\" for empty cells, \"\" for impassable cells.", "output": "Print the answer as a matrix as described above. See the examples to precise the format of the output.", "tutorial": "Let's enumerate all the connected components, store their sizes and for each empty cell store the number of it's component. It can be done with a single dfs. Now the answer for some impassable cell is equal to one plus the sizes of all different adjacent connected components. Adjacent means the components of cells adjacent to the current impassable cell (in general case each unpassable cell has four adjacent cells).\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nconst int N = 1010;\n\u00a0\nint n, m;\nchar a[N][N];\n\u00a0\ninline bool read() {\n\u00a0 \u00a0 if (!(cin >> n >> m)) return false;\n\u00a0 \u00a0 forn(i, n) assert(scanf(\"%s\", a[i]) == 1);\n\u00a0 \u00a0 return true;\n}\n\u00a0\nint sz[N * N];\nint tt, num[N][N];\n\u00a0\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, -1, 0, 1 };\n\u00a0\nvoid dfs(int x, int y) {\n\u00a0 \u00a0 sz[tt]++;\n\u00a0 \u00a0 num[x][y] = tt;\n\u00a0\n\u00a0 \u00a0 forn(i, 4) {\n\u00a0 \u00a0 \u00a0 \u00a0 int xx = x + dx[i];\n\u00a0 \u00a0 \u00a0 \u00a0 int yy = y + dy[i];\n\u00a0 \u00a0 \u00a0 \u00a0 if (min(xx, yy) < 0 || xx >= n || yy >= m) continue;\n\u00a0 \u00a0 \u00a0 \u00a0 if (num[xx][yy] != -1 || a[xx][yy] != '.') continue;\n\u00a0 \u00a0 \u00a0 \u00a0 dfs(xx, yy);\n\u00a0 \u00a0 }\n}\n\u00a0\nchar ans[N][N];\n\u00a0\ninline void solve() {\n\u00a0 \u00a0 tt = 0;\n\u00a0 \u00a0 forn(i, n) forn(j, m) num[i][j] = -1;\n\u00a0\n\u00a0 \u00a0 forn(i, n)\n\u00a0 \u00a0 \u00a0 \u00a0 forn(j, m)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (num[i][j] == -1 && a[i][j] == '.') {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 sz[tt] = 0;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dfs(i, j);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 tt++;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0\n#ifdef SU1\n\u00a0 \u00a0 forn(i, n) {\n\u00a0 \u00a0 \u00a0 \u00a0 forn(j, m) cerr << num[i][j] << ' ';\n\u00a0 \u00a0 \u00a0 \u00a0 cerr << endl;\n\u00a0 \u00a0 }\n#endif\n\u00a0\n\u00a0 \u00a0 forn(i, n)\n\u00a0 \u00a0 \u00a0 \u00a0 forn(j, m) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (a[i][j] == '.') {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ans[i][j] = '.';\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 continue;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int cur[4] = { -1, -1, -1, -1 };\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 forn(k, 4) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int x = i + dx[k];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int y = j + dy[k];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (min(x, y) < 0 || x >= n || y >= m) continue;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (a[x][y] != '.') continue;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cur[k] = num[x][y];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 sort(cur, cur + 4);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int szcur = int(unique(cur, cur + 4) - cur);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int ans = 1;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 forn(k, szcur)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (cur[k] != -1)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ans += sz[cur[k]];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ans %= 10;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ::ans[i][j] = char('0' + ans);\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 forn(i, n) puts(ans[i]);\n}\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 solve();\n\u00a0 \u00a0 \u00a0 \u00a0 //break;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}