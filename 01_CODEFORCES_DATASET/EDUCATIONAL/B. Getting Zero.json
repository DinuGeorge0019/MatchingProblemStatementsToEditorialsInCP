{"link": "https://codeforces.com//contest/1661/problem/B", "problemId": "1361828", "shortId": "1661B", "contest_number": "1661", "name": "B. Getting Zero", "statement": "Suppose you have an integer . In one operation, you can:   either set   or set . You are given  integers . What is the minimum number of operations you need to make each  equal to ?", "input": "The first line contains the single integer  ()\u00a0\u2014 the number of integers. The second line contains  integers  ().", "output": "Print  integers. The -th integer should be equal to the minimum number of operations required to make  equal to .", "tutorial": "Note that , so you can make any value equal to  by multiplying it by two  times, since . So, the answer for each value  is at most .Now, let's note that there is always an optimal answer that consists of: at first, add one  times, then multiply by two  times\u00a0\u2014 and  is the minimum answer. In other words, let's just iterate over all  and  and check that . The answer is minimum  among them.To prove that it's optimal to add at first and only then to multiply, note that it's not optimal to add more than once after muptiplying ( can be replaced by ). So there is at most one  between two , but it's not optimal to make even one  since we need to make  divisible by  and  break divisibility.There are many other approaches to this task except this one: for example, since  you can write bfs to find the shortest paths from  to all .", "solution": "fun main() {\n    val n = readLine()!!.toInt()\n    val a = readLine()!!.split(' ').map { it.toInt() }.toIntArray()\n\n    for (v in a) {\n        var ans = 20\n        for (cntAdd in 0..15) {\n            for (cntMul in 0..15) {\n                if (((v + cntAdd) shl cntMul) % 32768 == 0)\n                    ans = minOf(ans, cntAdd + cntMul)\n            }\n        }\n        print(\"$ans \")\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}