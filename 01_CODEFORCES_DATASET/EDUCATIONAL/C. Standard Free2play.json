{"link": "https://codeforces.com//contest/1238/problem/C", "problemId": "434107", "shortId": "1238C", "contest_number": "1238", "name": "C. Standard Free2play", "statement": "You are playing a game where your character should overcome different obstacles. The current problem is to come down from a cliff. The cliff has height , and there is a moving platform on each height  from  to .Each platform is either hidden inside the cliff or moved out. At first, there are  moved out platforms on heights . The platform on height  is moved out (and the character is initially standing there).If you character is standing on some moved out platform on height , then he can pull a special lever, which switches the state of . In other words, the platform you are currently standing on will hide in the cliff and the platform one unit below will change it state: it will hide if it was moved out or move out if it was hidden. In the second case, you will safely land on it. .Your character is quite fragile, so it can safely fall from the height no more than . In other words falling from the platform  to platform  is okay, but falling from  to  (or lower) is certain death. Sometimes it's not possible to come down from the cliff, but you can always buy (for donate currency) several magic crystals. Each magic crystal can be used to change the state of any single platform (except platform on height , which is unaffected by the crystals). After being used, the crystal disappears.What is the minimum number of magic crystal you need to buy to safely land on the  ground level?", "input": "The first line contains one integer  () \u2014 the number of queries. Each query contains two lines and is independent of all other queries. The first line of each query contains two integers  and  (, ) \u2014 the height of the cliff and the number of moved out platforms. The second line contains  integers  () \u2014 the corresponding moved out platforms in the descending order of their heights. The sum of  over all queries does not exceed .", "output": "For each query print one integer \u2014 the minimum number of magic crystals you have to spend to safely come down on the ground level (with height ).", "tutorial": "You are given the input data in compressed format, let's decompress it in binary string, where the -th character is  if the -th platform is hidden and  otherwise. For, example, the third query is .Let's look how our string changes: if we had  then after pulling the lever it becomes  and if we had  then we'd get  (The underlined index is the platform we are currently on). So it looks like we are standing on  and move it to the left until it clashes with the next one. So we can determine that we should look only at subsegments on -s.Now we can note, that the \"good\" string should have all subsegments of ones with even length except two cases: the subsegment that starts from  should have odd length and subsegment, which ends in  can have any length.Now we can say, that the answer is equal to number of subsegments which doesn't match the pattern of the \"good string\", since we can fix each subsegment with one crystal. And we can prove that it's optimal since the only way to fix two subsegments with one crystal is to merge them but it does not help.Finally, we can understand that we have no need in decompressing the input and can determine subsegments of ones straightforwardly.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\nconst int INF = int(1e9);\n\nint h, n;\nvector<int> p;\n\ninline bool read() {\n\tif(!(cin >> h >> n))\n\t\treturn false;\n\tp.resize(n);\n\tfore(i, 0, n)\n\t\tcin >> p[i];\n\treturn true;\n}\n\ninline void solve() {\n\tint ans = 0;\n\t\n\tint lf = 0;\n\tfore(i, 0, n) {\n\t\tif (i > 0 && p[i - 1] > p[i] + 1) {\n\t\t\tif (lf > 0)\n\t\t\t\tans += (i - lf) & 1;\n\t\t\telse\n\t\t\t\tans += 1 - ((i - lf) & 1);\n\t\t\tlf = i;\n\t\t}\n\t}\n\tif (p[n - 1] > 1) {\n\t\tif (lf != 0)\n\t\t\tans += (n - lf) & 1;\n\t\telse\n\t\t\tans += 1 - ((n - lf) & 1);\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tint tc; cin >> tc;\n\twhile(tc--) {\n\t\tread();\n\t\tsolve();\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}