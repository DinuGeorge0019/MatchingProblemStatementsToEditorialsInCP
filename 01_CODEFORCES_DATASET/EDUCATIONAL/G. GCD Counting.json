{"link": "https://codeforces.com//contest/990/problem/G", "problemId": "188996", "shortId": "990G", "contest_number": "990", "name": "G. GCD Counting", "statement": "You are given a tree consisting of  vertices. A number is written on each vertex; the number on vertex  is equal to .Let's denote the function  as the greatest common divisor of the numbers written on the vertices belonging to the simple path from vertex  to vertex  (including these two vertices).For every integer from  to  you have to count the number of pairs   such that  is equal to this number.", "input": "The first line contains one integer  \u2014 the number of vertices . The second line contains  integers , , ...,   \u2014 the numbers written on vertices. Then  lines follow, each containing two integers  and   denoting an edge connecting vertex  with vertex . It is guaranteed that these edges form a tree.", "output": "For every integer  from  to  do the following: if there is no pair  such that  and , don't output anything. Otherwise output two integers:  and the number of aforementioned pairs. You have to consider the values of  in ascending order. See the examples for better understanding.", "tutorial": "Firstly, for every  we can calculate the number of paths such that  is divisible by . We can do it as follows: generate all divisors of numbers  (numbers not exceeding  have at most  divisors, so this will be fast enough), and then for every  analyze the graph containing the vertices that have  as its divisor. Each component of this graph gives us  paths (if its size is ), and this is the only formula we need to calculate the number of paths where  is divisible by  (let this be ).How can we get the answer if we know the values of ? We can use inclusion-exclusion with Mobius function, for example, to prove that ; and then if we want to apply the same technique for finding  with any possible , we could divide all numbers  by  and do the same thing. But it might be too slow, so it's better to rewrite this formula as , because we will do exactly the same when dividing all numbers by .In fact, most contestants have written a much easier version of this solution, so this might be a bit too complicated.This problem can also be solved with centroid decomposition.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n    hd = 0;\n    tl = 0;\n    q[tl++] = x;\n    used[x] = cc;\n    while(hd < tl)\n    {\n        int z = q[hd++];\n        for(auto y : g[z])\n        {\n            if(good[a[y]] == cc && used[y] < cc)\n            {\n                used[y] = cc;\n                q[tl++] = y;\n            }\n        }\n    }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    for(auto x : need_bfs[j])\n\t\t    {\n\t\t        if(used[x] == cc) continue;\n\t\t\t    int z = bfs(x, i);\n\t\t\t    ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t    }\n\t    for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t        ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}