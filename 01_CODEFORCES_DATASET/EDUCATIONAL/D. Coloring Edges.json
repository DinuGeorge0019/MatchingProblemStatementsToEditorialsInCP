{"link": "https://codeforces.com//contest/1217/problem/D", "problemId": "404646", "shortId": "1217D", "contest_number": "1217", "name": "D. Coloring Edges", "statement": "You are given a directed graph with  vertices and  directed edges without self-loops or multiple edges.Let's denote the -coloring of a digraph as following: you color each edge in one of  colors. The -coloring is  if and only if there no cycle formed by edges of same color.Find a good -coloring of given digraph with minimum possible .", "input": "The first line contains two integers  and  (, ) \u2014 the number of vertices and edges in the digraph, respectively. Next  lines contain description of edges \u2014 one per line. Each edge is a pair of integers  and  (, ) \u2014 there is directed edge from  to  in the graph. It is guaranteed that each ordered pair  appears in the list of edges at most once.", "output": "In the first line print single integer  \u2014 the number of used colors in a good -coloring of given graph. In the second line print  integers  (), where  is a color of the -th edge (in order as they are given in the input). If there are multiple answers print any of them (you still have to minimize ).", "tutorial": "Let's run dfs on the graph and color all \"back edges\" ( is back edge if there is a path from  to  by edges from dfs tree) in black and all other edges in white. It can be proven that any cycle will have at least one white edge and at least black edge. Moreover each back edge connected with at least one cycle (path from  to  and  back edge). So the coloring we got is exactly the answer.How to prove that any cycle have at least one edge of both colors? Let's look only at edges from dfs trees. We can always renumerate vertices in such way that index of parent  is bigger than the index of any its child . We can process and assign  with minimal free number after we processed all its children.Now we can note that for any white edge  (not only tree edge) condition  holds (because of properties of dfs: forward edges are obvious; cross edge  becomes cross because dfs at first processed vertex  and  after that, so ). And for each back edge  it's true that . Since any cycle have both  and  situations, profit!", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e6) + 55;\n\nint n, m;\nvector <pair<int, int> > g[N];\nint col[N];\nbool cyc;\nint res[N];\n\nvoid dfs(int v){\n\tcol[v] = 1;\n\tfor(auto p : g[v]){\n\t\tint to = p.first, id = p.second;\n\t\tif(col[to] == 0){\n\t\t\tdfs(to);\n\t\t\tres[id] = 1;\n\t\t}\n\t\telse if(col[to] == 2)\n\t\t\tres[id] = 1;\n\t\telse{\n\t\t\tres[id] = 2;\n\t\t\tcyc = true;\n\t\t}\n\t}\n\tcol[v] = 2;\n}\n\nint main(){\n\tcin >> n >> m;\n\tfor(int i = 0; i < m; ++i){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u, --v;\n\t\tg[u].push_back(make_pair(v, i));\n\t}\n\t\n\tfor(int i = 0; i < n; ++i)\n\t\t\tif(col[i] == 0)\n\t\t\t\tdfs(i);\n\t\t\t\n\tcout << (cyc? 2 : 1) << endl;\n\tfor(int i = 0; i < m; ++i) cout << res[i] << ' ';\n\tcout << endl;\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}