{"link": "https://codeforces.com//contest/1473/problem/D", "problemId": "864972", "shortId": "1473D", "contest_number": "1473", "name": "D. Program", "statement": "You are given a program that consists of  instructions. Initially a single variable  is assigned to . Afterwards, the instructions are of two types:   increase  by ;  decrease  by . You are given  queries of the following format:   query  \u00a0\u2014 how many distinct values is  assigned to if all the instructions between the -th one and the -th one inclusive are ignored and the rest are executed without changing the order? ", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. Then the description of  testcases follows. The first line of each testcase contains two integers  and  ()\u00a0\u2014 the number of instructions in the program and the number of queries. The second line of each testcase contains a program\u00a0\u2014 a string of  characters: each character is either '' or ''\u00a0\u2014 increment and decrement instruction, respectively. Each of the next  lines contains two integers  and  ()\u00a0\u2014 the description of the query. The sum of  over all testcases doesn't exceed . The sum of  over all testcases doesn't exceed . ", "output": "For each testcase print  integers\u00a0\u2014 for each query ,  print the number of distinct values variable  is assigned to if all the instructions between the -th one and the -th one inclusive are ignored and the rest are executed without changing the order.", "tutorial": "The value of  always changes by , thus, the set of values of  is always some contiguous segment. The length of such segment can be determined by just its minimum and maximum values.So we have to solve two separate tasks for each query: find the minimum and the maximum value  gets assigned to. I'll describe only the minimum one.This task, however, can as well be split into two parts: minimum value on a prefix before  and on a suffix after . The prefix is easy\u00a0\u2014 it doesn't get changed by a query, so it can be precalculated beforehand. Minimum value on a prefix of length  is minimum of a minimum value on a prefix of length  and the current value.The suffix minimum is not that trivial. First, in order to precalculate the minimum value on a suffix of length , we have to learn to prepend an instruction to the suffix of length . Consider the graph of values of  over time. What happens to it if the initial value of  is not  but , for example? It just gets shifted by  upwards. That move is actually the same as prepending a '' instruction. So the minimum value for a suffix of length  is a minimum of a minimum value for a suffix of length , increased by the current instruction, and  (the start of the graph).So now we have a minimum value on a suffix after . However, it can't be taken into the answer as it is, because it considers the graph for the suffix to be starting from . And that's not the case. The graph for the suffix starts from the value the prefix ends on. So we can shift the answer for the suffix by the value of  after the prefix. The overall minimum value is just the minimum on a prefix and on a suffix, then.Overall complexity:  per testcase.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\tint t;\n\tcin >> t;\n\tforn(_, t){\n\t\tint n, m;\n\t\tstring s;\n\t\tcin >> n >> m;\n\t\tcin >> s;\n\t\tvector<int> sul(1, 0), sur(1, 0);\n\t\tfor (int i = n - 1; i >= 0; --i){\n\t\t\tint d = s[i] == '+' ? 1 : -1;\n\t\t\tsul.push_back(min(0, sul.back() + d));\n\t\t\tsur.push_back(max(0, sur.back() + d));\n\t\t}\n\t\treverse(sul.begin(), sul.end());\n\t\treverse(sur.begin(), sur.end());\n\t\tvector<int> prl(1, 0), prr(1, 0), pr(1, 0);\n\t\tforn(i, n){\n\t\t\tint d = s[i] == '+' ? 1 : -1;\n\t\t\tpr.push_back(pr.back() + d);\n\t\t\tprl.push_back(min(prl.back(), pr.back()));\n\t\t\tprr.push_back(max(prr.back(), pr.back()));\n\t\t}\n\t\tforn(i, m){\n\t\t\tint l, r;\n\t\t\tcin >> l >> r;\n\t\t\t--l;\n\t\t\tint l1 = prl[l], r1 = prr[l];\n\t\t\tint l2 = sul[r] + pr[l], r2 = sur[r] + pr[l];\n\t\t\tprintf(\"%d\\n\", max(r1, r2) - min(l1, l2) + 1);\n\t\t}\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}