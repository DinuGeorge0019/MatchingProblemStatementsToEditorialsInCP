{"link": "https://codeforces.com//contest/1257/problem/G", "problemId": "470642", "shortId": "1257G", "contest_number": "1257", "name": "G. Divisor Set", "statement": "You are given an integer  represented as a product of  its  divisors . Let  be the set of  positive integer divisors of  (including  and  itself).We call a set of integers   if (and only if) there is no pair ,  such that  and  divides .Find a  subset of  with maximum possible size. Since the answer can be large, print the size of the subset modulo .", "input": "The first line contains the single integer  () \u2014 the number of prime divisors in representation of . The second line contains  integers  () \u2014 the prime factorization of .", "output": "Print the maximum possible size of a  subset modulo .", "tutorial": "The problem consists of two parts: what do we want to calculate and how to calculate it?What do we want to calculate? There are several ways to figure it out. At first, you could have met this problem before and all you need is to remember a solution.At second, you can come up with the solution in a purely theoretical way \u2014 Hasse diagram can help with it greatly. Let's define  as the number of primes in prime factorization of . For example,  and . If you look at Hasse diagram of  you can see that all divisors with  lies on level . If  is divisible by  then  so all divisors on the same level don't divide each other. Moreover, the diagram somehow symmetrical about its middle level and sizes of levels are increasing while moving to the middle. It gives us an idea that the answer is the size of the middle level, i.e. the number of divisors with .The final way is just to brute force the answers for small -s and find the sequence in OEIS with name A096825, where the needed formulas are described.The second step is to calculate the number of divisors with . Suppose we have  distinct primes  and the number of occurences of  is equal to . Then we need to calculate pretty standard knapsack problem where you need to calculate number of ways to choose subset of size  where you can take each  up to  times. Or, formally, number of vectors  with  and .Calculating the answer using  will lead to time limit, so we need to make the following transformation. Let's build for each  a polynomial . Now the answer is just a coefficient before  in product . Note, that the product has degree , so we can multiply polynomials efficiently with integer FFT in the special order to acquire  time complexity.There several ways to choose the order of multiplications. At first, you can, at each step, choose two polynomials with the lowest degree and multiply them. At second, you can use the divide-and-conquer technique by dividing the current segment in two with pretty same total degrees. At third, you can also use D-n-C but divide the segment at halves and, it seems still to be  in total.What about the proof of the solution? Thanks to tyrion__ for the link at the article: https://pure.tue.nl/ws/files/4373475/597494.pdf.The result complexity is  time and  space (if carefully written). Note, that the hidden constant in integer FFT is pretty high and highly depends on the implementation, so it's possible for poor implementations not to pass the time limit.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\nconst int LOGN = 18;\nconst int MOD = 998244353;\nint g = 3;\n\nint mul(int a, int b) {\n\treturn int(a * 1ll * b % MOD);\n}\nint norm(int a) {\n\twhile(a >= MOD) a -= MOD;\n\twhile(a < 0) a += MOD;\n\treturn a;\n}\nint binPow (int a, int k) {\n\tint ans = 1;\n\tfor (; k > 0; k >>= 1) {\n\t\tif (k & 1)\n\t\t\tans = mul(ans, a);\n\t\ta = mul(a, a);\n\t}\n\treturn ans;\n}\nint inv(int a) {\n\treturn binPow(a, MOD - 2);\n}\n\nvector<int> w[LOGN], rv;\nbool precalced = false;\n\nvoid precalc() {\n\tif(precalced)\n\t\treturn;\n\tprecalced = true;\n\t\n    int wb = binPow(g, (MOD - 1) / (1 << LOGN));\n    fore(st, 0, LOGN) {\n        w[st].assign(1 << st, 1);\n\n        int bw = binPow(wb, 1 << (LOGN - st - 1));\n        int cw = 1;\n\n        fore(k, 0, (1 << st)) {\n            w[st][k] = cw;\n            cw = mul(cw, bw);\n        }\n    }\n    \n    rv.assign(1 << LOGN, 0);\n    fore(i, 1, sz(rv))\n\t\trv[i] = (rv[i >> 1] >> 1) | ((i & 1) << (LOGN - 1));\n}\n\nconst int MX = (1 << LOGN) + 3;\n\ninline void fft(int a[MX], int n, bool inverse) {\n\tprecalc();\n\t\n    int ln = __builtin_ctz(n);\n    assert((1 << ln) < MX);\n    assert((1 << ln) == n);\n\n    fore(i, 0, n) {\n        int ni = rv[i] >> (LOGN - ln);\n        if(i < ni) swap(a[i], a[ni]);\n    }\n\n    for(int st = 0; (1 << st) < n; st++) {\n        int len = (1 << st);\n        for(int k = 0; k < n; k += (len << 1)) {\n        \tfore(pos, k, k + len) {\n                int l = a[pos];\n                int r = mul(a[pos + len], w[st][pos - k]);\n\n                a[pos] = norm(l + r);\n                a[pos + len] = norm(l - r);\n            }\n        }\n    }\n    \n    if(inverse) {\n        int in = inv(n);\n        fore(i, 0, n)\n            a[i] = mul(a[i], in);\n        reverse(a + 1, a + n);\n    }\n}\n\nint aa[MX], bb[MX], cc[MX];\n\nvector<int> multiply(const vector<int> &a, const vector<int> &b) {\n\tint ln = 1;\n\twhile(ln < (sz(a) + sz(b)))\n\t\tln <<= 1;\n\t\n\tfore(i, 0, ln)\n\t\taa[i] = (i < sz(a) ? a[i] : 0);\n\tfore(i, 0, ln)\n\t\tbb[i] = (i < sz(b) ? b[i] : 0);\n\t\t\n\tfft(aa, ln, false);\n\tfft(bb, ln, false);\n\t\n\tfore(i, 0, ln)\n\t\tcc[i] = mul(aa[i], bb[i]);\n\tfft(cc, ln, true);\n\t\n\tvector<int> ans(cc, cc + ln);\n\twhile(ans.back() == 0)\n\t\tans.pop_back();\n\treturn ans;\n}\n\nint n;\nvector<int> ps;\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\tps.resize(n);\n\tfore(i, 0, n)\n\t\tcin >> ps[i];\n\treturn true;\n}\n\nstruct cmp {\n\tbool operator ()(const vector<int> &a, const vector<int> &b) {\n\t\treturn sz(a) < sz(b);\n\t}\n};\n\ninline void solve() {\n\tmap<int, int> cnt;\n\tfore (i, 0, n)\n\t\tcnt[ps[i]]++;\n\t\n\tmultiset< vector<int>, cmp > polys;\n\tfor (auto p : cnt)\n\t\tpolys.emplace(p.second + 1, 1);\n\t\n\twhile (sz(polys) > 1) {\n\t\tauto it2 = polys.begin();\n\t\tauto it1 = it2++;\n\t\tpolys.insert(multiply(*it1, *it2));\n\t\t\n\t\tpolys.erase(it1);\n\t\tpolys.erase(it2);\n\t}\n\n\tauto poly = *polys.begin();\n//\tcerr << '[';\n//\tfore(i, 0, sz(poly)) {\n//\t\tif(i) cerr << \", \";\n//\t\tcerr << poly[i];\n//\t}\n//\tcerr << ']' << endl;\n\n\tcout << poly[n / 2] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}