{"link": "https://codeforces.com//contest/628/problem/E", "problemId": "48827", "shortId": "628E", "contest_number": "628", "name": "E. Zbazi in Zeydabad", "statement": "A tourist wants to visit country Zeydabad for Zbazi (a local game in Zeydabad).The country Zeydabad is a rectangular table consisting of  rows and  columns. Each cell on the country is either  or .The tourist knows this country is named Zeydabad because there are lots of ''\"s in the country. A ''\" is a square which anti-diagonal is completely filled with  and its upper and lower rows are also completely filled with . All other cells of a square can be arbitrary.  Note that a ''\" can consist of only one cell (see the examples).So he wants to count the number of ''\"s in the country (a necessary skill for Zbazi).Now your task is to help tourist with counting number of ''\"s.As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use  instead of  in C++, prefer to use  instead of  in .", "input": "The first line contains two integers  () \u2014 the number of rows and columns respectively. Each of the next  lines contains  characters  or  \u2014 the description of Zeydabad.", "output": "Print the only integer  \u2014 the number of ''\"s in Zeydabad.", "tutorial": "Let's precalculate the values  \u2014 the maximal number of letters 'z' to the left, to the right and to the left-down from the position . It's easy to do in  time. Let's fix some cell . Consider the value . It's the maximum size of the square with upper right ceil in . But the number of z-patterns can be less than . Consider some cell  diagonally down-left from  on the distance no more than . The cells  and  forms z-pattern if .\nLet's maintain some data structure for each antidiagonal (it can be described by formula ) that can increment in a point and take the sum on a segment (Fenwick tree will be the best choice for that). Let's iterate over columns  from the right to the left and process the events: we have some cell  for which . In that case we should increment the position  in the tree number  by one. Now we should iterate over the cells  in the current column and add to the answer the value of the sum on the segment from  to  in the tree number  .\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define nfor(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nconst int N = 3030;\n\u00a0\nint n, m;\nchar a[N][N];\n\u00a0\ninline bool read() {\n\u00a0 \u00a0 if (!(cin >> n >> m)) return false;\n\u00a0 \u00a0 assert(gets(a[0]));\n\u00a0 \u00a0 forn(i, n) assert(gets(a[i]));\n\u00a0 \u00a0 return true;\n}\n\u00a0\ninline void inc(int* t, int i, int v) {\n\u00a0 \u00a0 for ( ; i < m; i |= i + 1) t[i] += v;\n}\ninline int sum(int* t, int i) {\n\u00a0 \u00a0 int ans = 0;\n\u00a0 \u00a0 for ( ; i >= 0; i = (i & (i + 1)) - 1)\n\u00a0 \u00a0 \u00a0 \u00a0 ans += t[i];\n\u00a0 \u00a0 return ans;\n}\ninline int sum(int* t, int i, int j) { return sum(t, j) - sum(t, i - 1); }\n\u00a0\nint zl[N][N], zld[N][N], zr[N][N];\nint t[2 * N][N];\nvector<pt> ev[N];\n\u00a0\ninline void solve() {\n\u00a0 \u00a0 nfor(i, n)\n\u00a0 \u00a0 \u00a0 \u00a0 forn(j, m)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (a[i][j] == '.')\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 zl[i][j] = zld[i][j] = 0;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 zl[i][j] = zld[i][j] = 1;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (j > 0) zl[i][j] += zl[i][j - 1];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (j > 0 && i + 1 < n) zld[i][j] += zld[i + 1][j - 1];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 forn(i, n)\n\u00a0 \u00a0 \u00a0 \u00a0 nfor(j, m)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (a[i][j] == '.')\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 zr[i][j] = 0;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 zr[i][j] = 1;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (j + 1 < m) zr[i][j] += zr[i][j + 1];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 forn(j, m) ev[j].clear();\n\u00a0 \u00a0 forn(i, n) forn(j, m) if (zr[i][j]) ev[j + zr[i][j] - 1].pb(pt(i, j));\n\u00a0\n\u00a0 \u00a0 forn(i, n + m) forn(j, m) t[i][j] = 0;\n\u00a0\n\u00a0 \u00a0 li ans = 0;\n\u00a0 \u00a0 nfor(j, m) {\n\u00a0 \u00a0 \u00a0 \u00a0 forn(i, sz(ev[j])) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int x = ev[j][i].x;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int y = ev[j][i].y;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 inc(t[x + y], y, +1);\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 forn(i, n) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int c = min(zl[i][j], zld[i][j]);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (!c) continue;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ans += sum(t[i + j], j - c + 1, j);\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 cout << ans << endl;\n}\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 solve();\n\u00a0 \u00a0 \u00a0 \u00a0 //break;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}