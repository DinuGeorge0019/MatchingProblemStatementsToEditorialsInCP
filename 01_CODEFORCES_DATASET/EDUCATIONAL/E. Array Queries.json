{"link": "https://codeforces.com//contest/797/problem/E", "problemId": "103032", "shortId": "797E", "contest_number": "797", "name": "E. Array Queries", "statement": " is an array of  positive integers, all of which are not greater than .You have to process  queries to this array. Each query is represented by two numbers  and . Several operations are performed in each query; each operation changes  to . There operations are applied until  becomes greater than . The answer to the query is the number of performed operations.", "input": "The first line contains one integer  . The second line contains  integers \u2014 elements of  ( for each  from  to ). The third line containts one integer  . Then  lines follow. Each line contains the values of  and  for corresponding query .", "output": "Print  integers, th integer must be equal to the answer to th query.", "tutorial": "There are two possible solutions in  time.First of them answers each query using simple iteration \u2014 changes  to  for each query until  becomes greater than , as stated in the problem. But it is too slow.Second solution precalculates answers for each  and : if , then , else . But this uses  memory and can be done in  time.Now we can notice that if , then second solution will use only  time and memory, and if , then first solution will do not more than  operations on each query. So we can combine these two solutions.Time complexity: .", "solution": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\n\nconst int N = (int) 1e5 + 5, sq = 330, mod = (int) 0;\nint dp[sq + 2][N], a[N];\nint main() {\n\tios_base::sync_with_stdio(0);\n\tint n;\n\tcin >> n;\n\tfor (int j = 0; j < n; ++j)\n\t\tcin >> a[j];\n\tfor (int jump = 1; jump <= sq; ++jump) {\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tint nxt = j + a[j] + jump;\n\t\t\tif (nxt >= n) {\n\t\t\t\tdp[jump][j] = 1;\n\t\t\t} else {\n\t\t\t\tdp[jump][j] = dp[jump][nxt] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint res = 0, pos, k;\n\t\tcin >> pos >> k;\n\t\t--pos;\n\t\tif (k <= sq) {\n\t\t\tcout << dp[k][pos] << '\\n';\n\t\t\tcontinue;\n\t\t}\n\t\twhile (pos < n) {\n\t\t\t++res;\n\t\t\tpos = pos + a[pos] + k;\n\t\t}\n\t\tcout << res << '\\n';\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "interactive": false, "noSolution": false, "noTutorial": false}