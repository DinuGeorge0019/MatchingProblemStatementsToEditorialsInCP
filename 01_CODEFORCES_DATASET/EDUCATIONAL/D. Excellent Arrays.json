{"link": "https://codeforces.com//contest/1550/problem/D", "problemId": "1045984", "shortId": "1550D", "contest_number": "1550", "name": "D. Excellent Arrays", "statement": "Let's call an integer array   if  for each .Let  be the number of pairs  () such that .Let's say that an array  is  if:    is ;   for each ;   is the maximum possible among all  arrays of size . Given ,  and , calculate the number of  arrays modulo .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases.  The first and only line of each test case contains three integers , , and  (; ; ). It's guaranteed that the sum of  doesn't exceed .", "output": "For each test case, print the number of excellent arrays modulo .", "tutorial": "Firstly, let's learn the structure of good array  with maximum . Suppose, , then   . In other words, we can group  by  and pairs will appear only inside each group. It's easy to prove that if the group has size  then it's optimal to split it in half: one with  and other with . Then the number of pairs inside the group will be equal to .It's also not hard to prove that in this case it's optimal to place all elements inside one group. In other words, it's optimal to make a half of all elements as  and the other half as  for some integer . Then .To achieve maximum  the excellent array should also have this structure. Let . For a fixed  if  is even then we should choose exactly  positions  to set as , but if  is odd, we can choose either  or  positions.Let's analyze what happens with different . Obviously, . While  both  and  are in the segment  for any . In this case we can choose any  as , so there are exactly  ways for even  and  ways for odd .When  then for  (where ) there is only one choice\u00a0\u2014 to set . Analogically, for  (where ) there is only choice to set .What remains is  elements without restrictions, so there are  ways to choose for even  or  ways for odd .Note that it's convenient to say that  if  or , so we don't need extra checks.Lastly, note that we can process all  with one formula and there are only  of  with non-zero number of ways to choose, so we can iterate over all such  straightforwardly.The total complexity is  because of precomputation of factorials and inverse factorials to calculate .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\nconst int MOD = int(1e9) + 7;\n\nint norm(int a) {\n\twhile (a >= MOD)\n\t\ta -= MOD;\n\twhile (a < 0)\n\t\ta += MOD;\n\treturn a;\n}\nint mul(int a, int b) {\n\treturn int(a * 1ll * b % MOD);\n}\nint binPow(int a, int k) {\n\tint ans = 1;\n\twhile (k > 0) {\n\t\tif (k & 1)\n\t\t\tans = mul(ans, a);\n\t\ta = mul(a, a);\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nconst int N = 200 * 1000 + 55;\nint f[N], inf[N];\n\nvoid precalc() {\n\tf[0] = inf[0] = 1;\n\tfore (i, 1, N) {\n\t\tf[i] = mul(f[i - 1], i);\n\t\tinf[i] = binPow(f[i], MOD - 2);\n\t}\n}\n\nint C(int n, int k) {\n\tif (k < 0 || n < k)\n\t\treturn 0;\n\treturn mul(f[n], mul(inf[n - k], inf[k]));\n}\n\nint n, l, r;\n\ninline bool read() {\n\tif(!(cin >> n >> l >> r))\n\t\treturn false;\n\treturn true;\n}\n\ninline void solve() {\n\tint half = n / 2;\n\tint st = min(1 - l, r - n);\n\t\n\tint ans = mul(st, C(n, half));\n\tif (n & 1)\n\t\tans = norm(ans + mul(st, C(n, half + 1)));\n\t\n\tfor (int k = st + 1; ; k++) {\n\t\tint lf = max(1, l + k);\n\t\tint rg = min(n, r - k);\n\t\t\n\t\tif (rg + 1 - lf < 0)\n\t\t\tbreak;\n\t\t\n\t\tans = norm(ans + C(rg + 1 - lf, half - (lf - 1)));\n\t\tif (n & 1)\n\t\t\tans = norm(ans + C(rg + 1 - lf, half + 1 - (lf - 1)));\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tprecalc();\n\tint t; cin >> t;\n\twhile (t--) {\n\t\tread();\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}