{"link": "https://codeforces.com//contest/1140/problem/G", "problemId": "317590", "shortId": "1140G", "contest_number": "1140", "name": "G. Double Tree", "statement": "You are given a special undirected graph. It consists of  vertices numbered from  to . The following properties hold for the graph: there are exactly  edges in the graph:  edges connect vertices having odd numbers with vertices having even numbers,  edges connect vertices having odd numbers with each other, and  edges connect vertices having even numbers with each other;  for each edge  between a pair of vertices with odd numbers, there exists an edge , and vice versa;  for each odd number , there exists an edge ;  the graph is connected; moreover, if we delete all vertices with even numbers from it, and all edges incident to them, the graph will become a tree (the same applies to deleting odd vertices).So, the graph can be represented as two trees having the same structure, and  edges connecting each vertex of the first tree to the corresponding vertex of the second tree.Edges of the graph are weighted. The length of some simple path in the graph is the sum of weights of traversed edges.You are given  queries to this graph; in each query, you are asked to compute the length of the shortest path between some pair of vertices in this graph. Can you answer all of the queries?", "input": "The first line of the input contains one integer  (). The second line contains  integers , , ...,  (). These integers describe the weights of the edges connecting odd vertices with even ones. Then  lines follow. -th line contains four integers , ,  and  (, , ); it describes two edges: one connecting  with  and having weight ; another connecting  with  and having weight . The next line contains one integer  () \u2014 the number of queries. Then  lines follow, -th line contains two integers  and  (, ), describing a query \"compute the length of the shortest path between vertices  and \".", "output": "Print  integers, -th integer should be equal to the answer to the -th query.", "tutorial": "Suppose we want to minimize the number of traversed edges of the second type (edges that connect odd vertices to each other or even vertices to each other), and minimizing the length of the path has lower priority. Then we exactly know the number of edges of the second type we will use to get from one vertex to another; and when building a path, we each time either jump from one \"tree\" to another using an edge of the first type, or use the only edge of the second type that brings us closer to the vertex we want to reach. So, in this case problem can be solved either by binary lifting or by centroid decomposition. The model solution uses the latter: merge the graph into one tree (vertices  and  of the original graph merge into vertex  in the tree), build its centroid decomposition, and for each centroid  and vertex  of its centroid-subtree calculate the length of the shortest path from  and  to  and  using dynamic programming. Then the answer for each pair of vertices  and  may be calculated as follows: find the deepest centroid  controlling the both vertices, and try either shortest path  or shortest path .But this solution won't work in the original problem because sometimes we want to choose an edge of the second type that leads us further from the vertex we want to reach in the merged tree, but allows us to use a cheaper edge of the first type to jump from one tree to another. Let's make this situation impossible! We may change the weights of all edges of the second type so that the weight of edge between  and  becomes the length of the shortest path between  and . This can be done by solving a SSSP problem: build a graph of  vertices, where each vertex  from  to  represents the path between from  and . Add a directed edge with weight equal to  going from vertex  to vertex . And finally, for every pair  such that  and  are connected by edge of weight , and  and  are connected by edge of weight , add an undirected edge connecting  and  in the new graph (its weight should be ). Then the distance from  to  in this graph will be equal to the length of the shortest path from  to  in the original graph.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\n#define x first\n#define y second\n\nconst int N = 600043;\n\nli d1[N];\nli d2[N][2];\nli dist_temp[N][2];\nvector<pair<int, int> > g[N];\nvector<int> qs[N];\nint qq[N][2];\nli ans[N];\nint n;\nint used[N];\nint cnt[N];\nint last[N];\nint cc = 1;\n\nvoid preprocess()\n{\n\tset<pair<li, int> > q;\n\tfor(int i = 0; i < n; i++)\n\t\tq.insert(make_pair(d1[i], i));\n\twhile(!q.empty())\n\t{\n\t\tint k = q.begin()->second;\n\t\tq.erase(q.begin());\n\t\tfor(auto e : g[k])\n\t\t{\n\t\t\tint to = e.first;\n\t\t\tli w = d2[e.second][0] + d2[e.second][1];\n\t\t\tif(d1[to] > w + d1[k])\n\t\t\t{\n\t\t\t\tq.erase(make_pair(d1[to], to));\n\t\t\t\td1[to] = w + d1[k];\n\t\t\t\tq.insert(make_pair(d1[to], to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs1(int x, int p = -1)\n{\n\tif(used[x]) return;\n\tcnt[x] = 1;\n\tfor(auto y : g[x])\n\t{\n\t\tint to = y.first;\n\t\tif(!used[to] && to != p)\n\t\t{\n\t\t\tdfs1(to, x);\n\t\t\tcnt[x] += cnt[to];\n\t\t}\n\t}\n}\n\nvector<int> cur_queries;\npair<int, int> c;\nint S = 0;\n\nvoid find_centroid(int x, int p = -1)\n{\n\tif(used[x])\treturn;\n\tint mx = 0;\n\tfor(auto y : g[x])\n\t{\n\t\tint to = y.first;\n\t\tif(!used[to] && to != p)\n\t\t{\n\t\t\tfind_centroid(to, x);\n\t\t\tmx = max(mx, cnt[to]);\n\t\t}\n\t}\n\tif(p != -1)\n\t\tmx = max(mx, S - cnt[x]);\n\tc = min(c, make_pair(mx, x));\n}\t\n\nvoid dfs2(int x, int p = -1, int e = -1)\n{\n\tif(used[x]) return;\n\tif(p == -1)\n\t{\n\t\tdist_temp[x * 2][0] = dist_temp[x * 2 + 1][1] = 0ll;\n\t\tdist_temp[x * 2][1] = dist_temp[x * 2 + 1][0] = d1[x];\n\t}\n\telse\n\t{\n\t\tfor(int k = 0; k < 2; k++)\n\t\t{\n\t\t\tli& D0 = dist_temp[x * 2][k];\n\t\t\tli& D1 = dist_temp[x * 2 + 1][k];\n\t\t\tD0 = dist_temp[p * 2][k] + d2[e][0];\n\t\t\tD1 = dist_temp[p * 2 + 1][k] + d2[e][1];\n\t\t\tD0 = min(D0, D1 + d1[x]);\n\t\t\tD1 = min(D1, D0 + d1[x]); \n\t\t}\n\t}\n\tfor(auto y : qs[x])\n\t{\n\t\tif(ans[y] != -1) continue;\n\t\tif(last[y] == cc)\n\t\t\tcur_queries.push_back(y);\n\t\telse\n\t\t\tlast[y] = cc;\n\t}\n\tfor(auto y : g[x])\n\t{\n\t\tint to = y.first;\n\t\tif(!used[to] && to != p)\n\t\t\tdfs2(to, x, y.second);\n\t}\n}\n\nvoid centroid(int v)\n{\n\tif(used[v]) return;\n\tdfs1(v);\n\tS = cnt[v];\n\tc = make_pair(int(1e9), -1);\n\tfind_centroid(v);\n\tint C = c.second;\n\tused[C] = 1;\n\tfor(auto y : g[C])\n\t\tcentroid(y.first);\n\tcc++;\n\tcur_queries.clear();\n\tused[C] = 0;\n\tdfs2(C);\n\tfor(auto x : cur_queries)\n\t{\n\t\tint u = qq[x][0];\n\t\tint v = qq[x][1];\n\t\tans[x] = min(dist_temp[u][0] + dist_temp[v][0], dist_temp[u][1] + dist_temp[v][1]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%I64d\", &d1[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tli w1, w2;\n\t\tscanf(\"%d %d %I64d %I64d\", &x, &y, &w1, &w2);\n\t\t--x;\n\t\t--y;\n\t\td2[i][0] = w1;\n\t\td2[i][1] = w2;\n\t\tg[x].push_back(make_pair(y, i));\n\t\tg[y].push_back(make_pair(x, i));\n\t}\n\tint q;\n\tscanf(\"%d\", &q);\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tscanf(\"%d\", &qq[i][0]);\n\t\tscanf(\"%d\", &qq[i][1]);\n\t\t--qq[i][0];\n\t\t--qq[i][1];\n\t\tqs[qq[i][0] / 2].push_back(i);\n\t\tqs[qq[i][1] / 2].push_back(i);\n\t}\n\tpreprocess();\n\tfor(int i = 0; i < q; i++)\n\t\tans[i] = -1;\n\tcentroid(0);\n\tfor(int i = 0; i < q; i++)\n\t\tcout << ans[i] << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}