{"link": "https://codeforces.com//contest/915/problem/G", "problemId": "146474", "shortId": "915G", "contest_number": "915", "name": "G. Coprime Arrays", "statement": "Let's call an array  of size   iff , where  is the greatest common divisor of the arguments.You are given two numbers  and . For each  () you have to determine the number of  arrays  of size  such that for every  () . Since the answers can be very large, you have to calculate them modulo .", "input": "The first line contains two integers  and  () \u2014 the size of the desired arrays and the maximum upper bound on elements, respectively.", "output": "Since printing  numbers may take a lot of time, you have to output the answer in such a way: Let  be the number of  arrays with elements in range , taken modulo . You have to print , taken modulo . Here  denotes bitwise xor operation ( in C++ or Java,  in Pascal).", "tutorial": "For a fixed upper bound , this is a well-known problem that can be solved using inclusion-exclusion:Let's denote by  the number of arrays with elements in range  such that  is divisible by . Obviously, . With the help of inclusion-exclusion formula we can prove that the number of arrays with  is the sum of the following values over all possible sets : , where  is some set of prime numbers (possibly an empty set), and  is the product of all elements in the set.  in this formula denotes the number of arrays such that their  is divisible by every number from set .However, the number of such sets  is infinite, so we need to use the fact that  if . With the help of this fact, we can rewrite the sum over every set  in such a way: , where  is  if there is no any set of prime numbers  such that ,  if this set  exists, and the sign is determined by the size of  ( if  is even, otherwise ).An easier way to denote and calculate  is the following (by the way, it is called M\u00f6bius function):, if there is some prime number p such that . Otherwise , where  is the number of primes in the factorization of .Okay, so we found a solution for one upper bound , it's . How can we calculate it for every  from  to ?Suppose we have calculated all values of  for some  and we want to recalculate them for . The important fact is that these values change (and thus need recalculation) only for the numbers  such that . So if we recalculate only these values  (and each recalculation can be done in  time if we precompute the  for every ), then we will have to do only  recalculations overall.", "solution": "#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, \"/STACK:167772160000\")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(\"%d\", &n);\n#define read2(n, m) scanf(\"%d%d\", &n, &m);\n#define readll(n) scanf(\"%I64d\", &n);\n#define mp make_pair\nconst ll mod = 1000000007;\nconst int maxn = 2100000;\nvector<int>divisors[maxn];\nll power(ll a, ll b) {\n\tll res = 1;\n\twhile (b > 0) {\n\t\tif (b % 2 == 1)\n\t\t\tres = (res*a) % mod;\n\t\tb /= 2;\n\t\ta = (a*a) % mod;\n\t}\n\treturn res;\n}\n\nll multip[maxn];\nll takenIn[maxn];\nbool isPrime[maxn];\nll powers[maxn];\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint n, k; cin >> n >> k;\n\tswap(n, k);\n\tfori1(n)multip[i] = -1;\n\tmultip[1] = 0;\n\tll totalAns = 0;\n\tfori1(n)powers[i] = power(i, k);\n\tfori1(n)isPrime[i] = true;\n\tisPrime[1] = false;\n\tfori1(n) {\n\t\tif (multip[i] == 0)continue;\n\t\tif (isPrime[i])\n\t\t\tmultip[i] *= -1;\n\t\tfor (int j = i * 2; j <= n; j += i) {\n\t\t\tif (isPrime[i] && j % ((ll)i*i) == 0) {\n\t\t\t\tmultip[j] = 0;\n\t\t\t}\n\t\t\t//if(multip[i] != 0)\n\t\t\tdivisors[j].push_back(i);\n\t\t\tif(isPrime[i])\n\t\t\t\tisPrime[j] = false;\n\t\t\tif (isPrime[i])\n\t\t\t\tmultip[j] *= -1;\n\t\t}\n\t}\n\tll curAns = 0;\n\tfori1(n) {\n\t\tfor (auto x : divisors[i]) {\n\t\t\tcurAns -= multip[x] * takenIn[x];\n\t\t\ttakenIn[x] = powers[i/x];\n\t\t\tcurAns += multip[x] * takenIn[x];\n\t\t\tcurAns %= mod;\n\t\t}\n\t\ttakenIn[i] = 1;\n\t\tcurAns += multip[i]*1;\n\t\tll cur = powers[i] - curAns;\n\t\tcur %= mod;\n\t\tcur += mod;\n\t\tcur %= mod;\n\t\tcur ^= i;\n\t\tcur %= mod;\n\t\ttotalAns += cur;\n\t}\n\ttotalAns %= mod;\n\tcout << totalAns;\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}