{"link": "https://codeforces.com//contest/1342/problem/C", "problemId": "604758", "shortId": "1342C", "contest_number": "1342", "name": "C. Yet Another Counting Problem", "statement": "You are given two integers  and , and  queries. The -th query consists of two numbers  and , and the answer to it is the number of integers  such that , and . Calculate the answer for each query.Recall that  is the remainder of the division of  by . For example, , , , .", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. Then the test cases follow. The first line of each test case contains three integers ,  and  (; ). Then  lines follow, each containing two integers  and  () for the corresponding query.", "output": "For each test case, print  integers\u00a0\u2014 the answers to the queries of this test case in the order they appear.", "tutorial": "It's quite easy to see that $$$((ab + x) \\bmod a) \\bmod b = (x \\bmod a) \\bmod b$$$. What does it mean? The property given in the statement holds for $$$x$$$ if and only if it holds for $$$x \\bmod ab$$$. It allows us to answer each testcase in $$$O(ab + q)$$$ as follows: for each number from $$$0$$$ to $$$ab - 1$$$, we may check the given property before processing the queries, and build an array of prefix sums on it to efficiently count the number of integers satisfying the property from the segment $$$[0, y]$$$, where $$$y < ab$$$. Then each query $$$[l, r]$$$ can be divided into two prefix-queries $$$[0, l - 1]$$$ and $$$[0, r]$$$. To answer a prefix query $$$[0, p]$$$ in $$$O(1)$$$, we can calculate the number of \"full segments\" of length $$$ab$$$ inside this prefix (that is $$$\\lfloor \\frac{p}{ab} \\rfloor$$$) and the length of the last segment of numbers that don't belong into a full segment (that is $$$p \\bmod ab$$$). To handle full segments, we multiply the number of integers satisfying the property on one segment by the number of such segments, and to handle the last part of segment, we use prefix sums.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 40043;\n\nint len;\nint p[N];\n\nvoid build(int a, int b)\n{\n\tlen = a * b;\n\tp[0] = 0;\n\tfor(int i = 1; i <= len; i++)\n\t{\n\t\tp[i] = p[i - 1];\n\t\tif((i % a) % b != (i % b) % a)\n\t\t\tp[i]++;\n\t}\n}\n\nlong long query(long long l)\n{\n\tlong long cnt = l / len;\n\tint rem = l % len;\n\treturn p[len] * 1ll * cnt + p[rem]; \n}\n\nlong long query(long long l, long long r)\n{\n\treturn query(r) - query(l - 1);\n}\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\tfor(int i = 0; i < t; i++)\n\t{\n\t\tint a, b, q;\n\t\tcin >> a >> b >> q;\n\t\tbuild(a, b);\n\t\tlong long l, r;\n\t\tfor(int j = 0; j < q; j++)\n\t\t{\n\t\t\tcin >> l >> r;\n\t\t\tcout << query(l, r) << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}