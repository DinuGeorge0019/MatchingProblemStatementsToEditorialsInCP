{"link": "https://codeforces.com//contest/1009/problem/F", "problemId": "197477", "shortId": "1009F", "contest_number": "1009", "name": "F. Dominant Indices", "statement": "You are given a rooted undirected tree consisting of  vertices. Vertex  is the root.Let's denote a  of vertex  as an infinite sequence , where  is the number of vertices  such that both conditions hold:   is an ancestor of ;  the simple path from  to  traverses exactly  edges. The  of a  of vertex  (or, shortly, the  of vertex ) is an index  such that:  for every , ;  for every , . For every vertex in the tree calculate its .", "input": "The first line contains one integer  () \u2014 the number of vertices in a tree. Then  lines follow, each containing two integers  and  (, ). This line denotes an edge of the tree. It is guaranteed that these edges form a tree.", "output": "Output  numbers. -th number should be equal to the  of vertex .", "tutorial": "In this problem we can use small-to-large merging trick (also known as DSU on tree): when building a depth array for a vertex, we firstly build depth arrays recursively for its children, then pull them upwards and merge them with small-to-large technique. In different blogs on this technique it was mentioned that this will require  operations with structures we use to maintain depth arrays overall.However, in this problem we may prove a better estimate: it will require  operations. That's because the size of depth array (if considering only non-zero elements) for a vertex is equal to the height of its subtree, not to the number of vertices in it. To prove that the number of operations is , one can use the intuitive fact that when we merge two depth arrays, all elements of the smaller array are \"destroyed\" in the process, so if the size of smaller array is , then we require  operations to \"destroy\"  elements.The main problem is that we sometimes need to \"pull\" our depth arrays upwards, thus inserting a  to the beginning of the array. Standard arrays don't support this operation, so we need to either use something like  (and the complexity will be ), or keep the depth arrays in reversed order and handle them using  (and then complexity will be ).", "solution": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <vector>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n\n// RJ? No, thanks\n\nusing namespace std;\n\nconst int N = 1000043;\n\nstruct state\n{\n\tvector<int>* a;\n\tint cur_max;\n\tint sz()\n\t{\n\t\treturn a->size();\n\t}\n\tvoid add(int i, int val)\n\t{\n\t\t(*a)[i] += val;\n\t\tif(make_pair((*a)[i], i) > make_pair((*a)[cur_max], cur_max))\n\t\t\tcur_max = i;\n\t}\n};\n\nstate pull(state z)\n{\n\tif(z.sz() == 0)\n\t{\n\t\tstate c;\n\t\tc.a = new vector<int>(1, 1);\n\t\tc.cur_max = 0;\n\t\treturn c;\n\t}\n\telse\n\t{\n\t\tstate c;\n\t\tc.a = z.a;\n\t\tc.cur_max = z.cur_max;\n\t\tc.a->push_back(0);\n\t\tc.add(c.sz() - 1, 1);\n\t\treturn c;\n\t}\n}\n\nstate merge(state a, state b)\n{\n\tif(a.sz() < b.sz())\n\t\tswap(a, b);\n\tstate c;\n\tc.a = a.a;\n\tc.cur_max = a.cur_max;\n\tint as = c.sz();\n\tint bs = b.sz();\n\tfor(int i = 0; i < bs; i++)\n\t\ta.add(as - i - 1, (*(b.a))[bs - i - 1]);\n\treturn a;\n}\n\nstate s[N];\nint ans[N];\nvector<int> g[N];\n\nvoid dfs(int x, int p = -1)\n{\n\ts[x].a = new vector<int>(0);\n\ts[x].cur_max = 0;\n\tfor(auto y : g[x])\n\t\tif(y != p)\n\t\t{\n\t\t\tdfs(y, x);\n\t\t\ts[x] = merge(s[x], s[y]);\n\t\t}\n\ts[x] = pull(s[x]);\n\tans[x] = s[x].sz() - s[x].cur_max - 1;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tdfs(0);\n\tfor(int i = 0; i < n; i++)\n\t\tprintf(\"%d\\n\", ans[i]);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}