{"link": "https://codeforces.com//contest/825/problem/G", "problemId": "114550", "shortId": "825G", "contest_number": "825", "name": "G. Tree Queries", "statement": "You are given a tree consisting of  vertices (numbered from  to ). Initially all vertices are white. You have to process  queries of two different types:    \u2014 change the color of vertex  to black. It is guaranteed that the first query will be of this type.    \u2014 for the vertex , find the minimum index  such that the vertex with index  belongs to the simple path from  to some black vertex (a simple path never visits any vertex more than once). For each query of type  print the answer to it..", "input": "The first line contains two numbers  and  (). Then  lines follow, each line containing two numbers  and  () and representing the edge between vertices  and . It is guaranteed that these edges form a tree. Then  lines follow. Each line contains two integers  and , where  is the type of th query, and  can be used to restore  for this query in this way: you have to keep track of the answer to the last query of type  (let's call this answer , and initially ); then . It is guaranteed that the first query is of type , and there is at least one query of type .", "output": "For each query of type  output the answer to it.", "tutorial": "After the first query make the vertex that we painted black the root of the tree and for each other vertex calculate the minimum index on the path to the root. This can be done by simple DFS.Then suppose we are painting some vertex  black. In can easily proved that for every vertex  and every vertex  that is on a path form  to the root there exists a path from  to some black vertex coming through . So we have to store the minimum index among all vertices  such that  belongs to the path from the root to some black vertex (it is a global value, let's call it ), and the answer to every query of type  is just the minimum of the value we calculated in DFS and . To update  quickly after painting vertex  black, we ascend from  to the root until we arrive to some node that was visited during previous queries (and we stop there because this node and all nodes on the path from it to the root were used to update  in previous queries).This solution works in  time.", "solution": "#ifdef __GNUC__\n#pragma GCC target(\"sse4,avx\")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n#include <memory>\n\ntemplate<class T>\nstruct BinTree1 {\n  size_t size;\n  std::vector<T> t;\n\n  BinTree1(size_t N) :\n      size(N),\n      t(2 * N, init()) {}\n\n  BinTree1(const std::vector<T>& other) :\n      size(other.size()),\n      t(2 * other.size()) {\n      std::copy(other.begin(), other.end(), t.begin() + size);\n      for (size_t i = size; i-- > 1;) {\n          t[i] = combine(t[2 * i], t[2 * i + 1]);\n      }\n  }\n\n  T get(size_t p) {\n      return t[p + size];\n  }\n\n  void modify(size_t p, T value) {\n      p += size;\n      t[p] = value;\n      while (p > 1) {\n          p = p / 2;\n          t[p] = combine(t[2 * p], t[2 * p + 1]);\n      }\n  }\n\n  T query(size_t l, size_t r) {\n      l += size;\n      r += size;\n      T left = init();\n      T right = init();\n      while (l < r) {\n          if (l & 1) {\n              left = combine(left, t[l]);\n              l++;\n          }\n          if (r & 1) {\n              r--;\n              right = combine(t[r], right);\n          }\n          l = l / 2;\n          r = r / 2;\n      }\n      return combine(left, right);\n  }\n\n private:\n  T combine(T left, T right) {\n      return std::min(left, right);\n  }\n\n  T init() {\n      return 1000000000;\n  }\n};\n\nstruct Solution {\n  int n;\n  std::unique_ptr<BinTree1<int>> tree;\n  std::vector<std::vector<int>> graph;\n  std::vector<int> left;\n  std::vector<int> right;\n  std::vector<int> value;\n  int dfs(int v, int prev, int order, int cur) {\n      value[v] = cur;\n      left[v] = order;\n      order++;\n      for (int nv : graph[v]) {\n          if (nv != prev) {\n              order = dfs(nv, v, order, std::min(cur, nv));\n          }\n      }\n      right[v] = order;\n      return order;\n  }\n\n  void init(int root) {\n      left.resize(n);\n      right.resize(n);\n      value.resize(n);\n      dfs(root, -1, 0, root);\n  }\n\n  void run(std::istream& in, std::ostream& out) {\n      int q;\n      in >> n >> q;\n      tree.reset(new BinTree1<int>(n));\n      graph.assign(n, std::vector<int>());\n      for (int i = 0; i < n - 1; i++) {\n          int from, to;\n          in >> from >> to;\n          from--;\n          to--;\n          graph[from].push_back(to);\n          graph[to].push_back(from);\n      }\n      int t, x;\n      in >> t >> x;\n      q--;\n      init(x % n);\n      int last = 0;\n      int minBlack = 1000000000;\n      for (int request = 0; request < q; request++) {\n          in >> t >> x;\n          x = (x + last) % n;\n          if (t == 1) {\n              minBlack = std::min(minBlack, value[x]);\n//              tree->modify(x, value[x]);\n          } else {\n              int res = std::min(value[x], minBlack);\n//              if (left[x] > 0) {\n//                  res = std::min(res, tree->query(0, left[x]));\n//              }\n//              if (right[x] < n) {\n//                  res = std::min(res, tree->query(right[x], n));\n//              }\n              last = res + 1;\n              out << last << std::endl;\n          }\n      }\n  }\n};\n\nint main() {\n    std::cin.sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    Solution().run(std::cin, std::cout);\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}