{"link": "https://codeforces.com//contest/817/problem/E", "problemId": "110091", "shortId": "817E", "contest_number": "817", "name": "E. Choosing The Commander", "statement": "As you might remember from the previous round, Vova is currently playing a strategic game known as Rage of Empires.Vova managed to build a large army, but forgot about the main person in the army - the commander. So he tries to hire a commander, and he wants to choose the person who will be respected by warriors.Each warrior is represented by his personality \u2014 an integer number . Each commander has two characteristics \u2014 his personality  and leadership  (both are integer numbers). Warrior   commander  only if  ( is the bitwise excluding OR of  and ).Initially Vova's army is empty. There are three different types of events that can happen with the army:   \u2014 one warrior with personality  joins Vova's army;   \u2014 one warrior with personality  leaves Vova's army;   \u2014 Vova tries to hire a commander with personality  and leadership . For each event of the third type Vova wants to know how many warriors (counting only those who joined the army and haven't left yet)  the commander he tries to hire.", "input": "The first line contains one integer  () \u2014 the number of events. Then  lines follow. Each line describes the event:    () \u2014 one warrior with personality  joins Vova's army;   () \u2014 one warrior with personality  leaves Vova's army (it is guaranteed that there is at least one such warrior in Vova's army by this moment);   () \u2014 Vova tries to hire a commander with personality  and leadership . There is at least one event of this type. ", "output": "For each event of the third type print one integer \u2014 the number of warriors who  the commander Vova tries to hire in the event.", "tutorial": "Let's use binary trie to store all personalities of warriors (that is, just use the trie data structure on binary representations of all ). For each subtree of this trie you have to maintain the number of 's currently present in this subtree \u2014 when inserting a value of , we increase the sizes of subtrees on the path from the node with  to the root by , and when removing , we decrease the sizes of subtrees on this path by .How can it help us with answering the events of third type? We will descend the trie. When descending, we will try to find the number  in the structure. When we go to some subtree, we determine whether we add the quantity of numbers in the subtree we are not going into by checking if the current bit in  is equal to  (if so, then for all numbers from this subtree their bitwise xor with the current commander's personality is less than ). The answer to the event is the sum of sizes of all subtrees we \"added\" while descending into the trie.", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = (int) 1e8 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << \" = \" << (x) << \", \";\n#define endln cerr << \"\\n\";\n\nconst int maxn = 1e5 + 5;\nconst int logn = 31;\n\nint ptr;\nint nxt[maxn * logn * 5][2];\nint val[maxn * logn * 5];\n\nvoid add(int k) {\n    int st = 0;\n    FORd(i, logn, 0) {\n        int x = bit(k, i);\n        if (!nxt[st][x]) nxt[st][x] = ++ptr;\n        st = nxt[st][x];\n        val[st]++;\n    }\n}\n\nvoid rem(int k) {\n    int st = 0;\n    FORd(i, logn, 0) {\n        int x = bit(k, i);\n        if (!nxt[st][x]) nxt[st][x] = ++ptr;\n        st = nxt[st][x];\n        val[st]--;\n    }\n}\n\nint query(int k, int l) {\n    int res = 0, st = 0;\n    FORd(i, logn, 0) {\n        int x = bit(k, i);\n        int y = bit(l, i);\n        if (y) {\n            if (nxt[st][x]) {\n                res += val[nxt[st][x]];\n            }\n            if (nxt[st][!x]) {\n                st = nxt[st][!x];\n            }\n            else {\n                return res;\n            }\n        }\n        else {\n            if (nxt[st][x]) {\n                st = nxt[st][x];\n            }\n            else {\n                return res;\n            }\n        }\n    }\n    return res;\n}\n\nvoid solve() {\n    int q; cin >> q;\n    while (q--) {\n        int op; cin >> op;\n        if (op == 1) {\n            int p; cin >> p;\n            add(p);\n        }\n        else if (op == 2) {\n            int p; cin >> p;\n            rem(p);\n        }\n        else {\n            int p, l; cin >> p >> l;;\n            cout << query(p, l) << \"\\n\";\n        }\n    }\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(\"in.txt\", \"r\")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(\"in.txt\", \"r\", stdin));\n        //assert(freopen(\"out.txt\", \"w\", stdout));\n    }\n    else {\n        ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    }\n    return 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}