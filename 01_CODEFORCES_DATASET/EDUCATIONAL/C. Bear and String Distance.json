{"link": "https://codeforces.com//contest/628/problem/C", "problemId": "48825", "shortId": "628C", "contest_number": "628", "name": "C. Bear and String Distance", "statement": "Limak is a little polar bear. He likes  strings \u2014 strings of length , consisting of lowercase English letters only.The distance between two letters is defined as the difference between their positions in the alphabet. For example, , and .Also, the distance between two nice strings is defined as the sum of distances of corresponding letters. For example, , and .Limak gives you a nice string  and an integer . He challenges you to find any nice string  that . Find any  satisfying the given conditions, or print \"\" if it's impossible to do so.As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use  instead of  in C++, prefer to use  instead of  in .", "input": "The first line contains two integers  and  (, ). The second line contains a string  of length , consisting of lowercase English letters.", "output": "If there is no string satisfying the given conditions then print \"\" (without the quotes). Otherwise, print any nice string  that .", "tutorial": "There is no solution if the given required distance is too big. Let's think what is the maximum possible distance for the given string . Or the more useful thing \u2014 how to construct a string  to maximize the distance? We can treat each letter separately and replace it with the most distant letter. For example, we should replace 'c' with 'z', and we should replace 'y' with 'a'. To be more precise, for first 13 letters of the alphabet the most distant letter is 'z', and for other letters it is 'a'.\n", "solution": "// Bear and String Distance, by Errichto#include<bits/stdc++.h>using namespace std;\u00a0const int nax = 1e6 + 5;char s[nax];\u00a0int main() {\tint n, k;\tscanf(\"%d%d\", &n, &k);\tscanf(\"%s\", s);\tfor(int i = 0; i < n; ++i) {\t\t// we want to change s[i]\t\tchar best_letter = s[i]; // by default we don't change it at all\t\tint best_distance = 0;\t\tfor(char maybe = 'a'; maybe <= 'z'; ++maybe) {\t\t\tint distance = abs(maybe - s[i]);\t\t\t// we must check if \"distance <= k\" because we don't want to exceed the total distance\t\t\t// among letters with \"distance <= k\" we choose the most distant one\t\t\tif(distance <= k && distance > best_distance) {\t\t\t\tbest_distance = distance;\t\t\t\tbest_letter = maybe;\t\t\t}\t\t}\t\tk -= best_distance; // we decrease the remaining distance\t\ts[i] = best_letter;\t}\tassert(k >= 0);\t// we found a correct s' only if \"k == 0\"\tif(k > 0) puts(\"-1\");\telse printf(\"%s\\n\", s);\treturn 0;}\u00a0", "interactive": false, "noSolution": false, "noTutorial": false}