{"link": "https://codeforces.com//contest/1473/problem/C", "problemId": "864971", "shortId": "1473C", "contest_number": "1473", "name": "C. No More Inversions", "statement": "You have a sequence  with  elements  ().Let's call as inversion in  a pair of indices  such that .Suppose, you have some permutation  of size  and you build a sequence  of size  in the following manner: .Your goal is to find such permutation  that the total number of inversions in  doesn't exceed the total number of inversions in , and  is .Small reminder: the sequence of  integers is called a permutation if it contains all integers from  to  exactly once.Another small reminder: a sequence  is  than another sequence , if either  is a prefix of , or for the first  such that ,  holds (in the first position that these sequences are different,  has smaller number than ).", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first and only line of each test case contains two integers  and  (; )\u00a0\u2014 the length of the sequence  and its maximum. It's guaranteed that the total sum of  over test cases doesn't exceed .", "output": "For each test case, print  integers\u00a0\u2014 the permutation  which maximizes  lexicographically without increasing the total number of inversions. It can be proven that  exists and is unique.", "tutorial": "At first, let's look at sequence : . Let's prove that the number of inversions in  is the same regardless of what  are (the only condition is that  should be distinct).Let's group all elements  by their value\u00a0\u2014 there will be  or  elements in each group. Then we can take any two groups with values  and  and calculate the number of inversions between elements in these groups. It's easy to note that construction will always be like  (or ) and regardless of  or  in both cases there will be exactly two inversions between groups equal to  and to  (or one inversion in the second case). So the total number of inversion will be equal to .Now we can split sequences  and  into two parts. Let , then the first part is elements from segment  and the second is from . Note that the second parts both in  and  are exactly the sequence  described above.The total number of inversions is equal to the sum of inversions in the first part, in the second part, and the inversions with elements from both parts. Note that in  the first and the third components are equal to  and the second component is constant, so in  we must also have  inversions in the first part and  inversion between parts.It means that  must start from . But since the number of inversions in the second part is constant we can set the remaining elements the way we want. And since we want to build lexicographically maximum , we should make the second part as .In the end, optimal  is . The permutation  to make such  is equal to .", "solution": "fun main() {\n    repeat(readLine()!!.toInt()) {\n        val (n, k) = readLine()!!.split(' ').map { it.toInt() }\n\n        for (i in 1 until (k - (n - k)))\n            print(\"$i \")\n        for (i in k downTo (k - (n - k)))\n            print(\"$i \")\n        println(\"\")\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}