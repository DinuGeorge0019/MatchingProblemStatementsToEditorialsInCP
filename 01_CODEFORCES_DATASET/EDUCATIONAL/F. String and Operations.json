{"link": "https://codeforces.com//contest/1455/problem/F", "problemId": "815719", "shortId": "1455F", "contest_number": "1455", "name": "F. String and Operations", "statement": "You are given a string  consisting of  characters. These characters are among the first  lowercase letters of the Latin alphabet. You have to perform  operations with the string.During the -th operation, you take the character that  the -th position, and perform  of the following actions with it:  swap it with the previous character in the string (if it exists). This operation is represented as ;  swap it with the next character in the string (if it exists). This operation is represented as ;  cyclically change it to the previous character in the alphabet ( becomes ,  becomes , and so on;  becomes the -th letter of the Latin alphabet). This operation is represented as ;  cyclically change it to the next character in the alphabet ( becomes ,  becomes , and so on; the -th letter of the Latin alphabet becomes ). This operation is represented as ;  do nothing. This operation is represented as . For example, suppose the initial string is , , and the sequence of operations is . Then the string is transformed as follows:  the first operation is , so we change the underlined letter in  to the next one in the first  Latin letters, which is . The string is now ;  the second operation is , so we swap the underlined letter with the next one in the string . The string is now ;  the third operation is , so we swap the underlined letter with the previous one in the string  (note that this is now the -nd character of the string, but it was initially the -rd one, so the -rd operation is performed to it). The resulting string is ;  the fourth operation is , so we change the underlined letter in  to the previous one in the first  Latin letters, which is . The string is now . The result of performing the sequence of operations is .Given the string  and the value of , find the lexicographically smallest string that can be obtained after applying a sequence of operations to .", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case consists of two lines. The first line contains two integers  and  (; ).  The second line contains a string  consisting of  characters. Each character is one of the  first letters of the Latin alphabet (in lower case).", "output": "For each test case, print one line containing the lexicographically smallest string that can be obtained from  using one sequence of operations.", "tutorial": "The crucial observation that we have to make is that the character that initially occupied the position  cannot occupy the positions to the left of : we can shift some character two positions to the left using a combination of operations , but we can't go any further. So, the prefix of the first  characters of the resulting string can only be affected by the prefix of the first  characters of the initial string.Let's use the following dynamic programming to solve the problem: let  be the  that we can obtain by applying operations to the first  characters (that is,  is the answer to the problem if we consider only  first characters of the original string).The transitions here are a bit tricky. If we apply the operation  or  to the character , then , where  is the character we get when we apply the aforementioned operation to that character.  is a bit more complicated: we have to insert the character  just before the last character of .Modeling that we can apply the operation  is likely the most complex transition in our dynamic programming. First of all, we can't just make an update to  or , since it leads us to a situation where we can still apply some operations to the prefix we have built. Instead, we have to consider the operation we will be able to do with the character . Using another operation  is useless since the result is like performing no operations with those two characters at all, so we have to consider two options for operation with the -th character \u2014  or  (whichever is better), or . In the first case, we update  by appending the resulting two characters to  (the one that we get when we change , and the one that initially was ). In the second case, things are a bit trickier, but still not very complicated: the character that was  moves two positions backward, so it is inserted right before the last character of , and then we append  to the string we get.So, there are four transitions we have to make:  a transition from  to  that models the case when we apply  or  to the -th character;  a transition from  to  that models the case when we apply  to the -th character;  a transition from  to  to model the operations  or ;  a transition from  to  to model the operations . Overall complexity is  but it can be improved to  with some complicated data structures like persistent segment tree with hashes to compare strings and append characters to them in .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 505;\n\nint n, k;\nstring s;\nstring dp[N];\n\nvoid solve() {\n\tcin >> n >> k >> s;\n\tfor (int i = 1; i <= n; i++)\n\t\tdp[i] = char('z' + 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tint c = s[i] - 'a';\n\t\tint nc = min({c, (c + 1) % k, (c + k - 1) % k});\n\t\tdp[i + 1] = min(dp[i + 1], dp[i] + char('a' + nc));\n\t\tif (i > 0) {\n\t\t\tdp[i + 1] = min(dp[i + 1], dp[i - 1] + char('a' + nc) + s[i - 1]);\n\t\t\tdp[i + 1] = min(dp[i + 1], dp[i].substr(0, i - 1) + s[i] + dp[i].back());\n\t\t}\n\t\tif (i > 1) {\n\t\t\tdp[i + 1] = min(dp[i + 1], dp[i - 1].substr(0, i - 2) + s[i] + dp[i - 1].back() + s[i - 1]);\n\t\t}\n\t}\n\tcout << dp[n] << endl;\n}\n\nint main() {\n\tint t;\n\tcin >> t;\n\twhile (t--) solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}