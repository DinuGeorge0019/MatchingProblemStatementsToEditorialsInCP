{"link": "https://codeforces.com//contest/1452/problem/G", "problemId": "802110", "shortId": "1452G", "contest_number": "1452", "name": "G. Game On Tree", "statement": "Alice and Bob are playing a game. They have a tree consisting of  vertices. Initially, Bob has  chips, the -th chip is located in the vertex  (all these vertices are unique). Before the game starts, Alice will place a chip into one of the vertices of the tree.The game consists of turns. Each turn, the following events happen (sequentially, exactly in the following order):  Alice either moves her chip to an adjacent vertex or doesn't move it;  for each Bob's chip, he either moves it to an adjacent vertex or doesn't move it. Note that this choice is done independently for each chip. The game ends when Alice's chip shares the same vertex with one (or multiple) of Bob's chips. Note that Bob's chips may share the same vertex, even though they are in different vertices at the beginning of the game.Alice wants to maximize the number of turns, Bob wants to minimize it. If the game ends in the middle of some turn (Alice moves her chip to a vertex that contains one or multiple Bob's chips), this turn is counted.For each vertex, calculate the number of turns the game will last if Alice places her chip in that vertex.", "input": "The first line contains one integer  () \u2014 the number of vertices in the tree. Then  lines follow, each line contains two integers ,  (; ) that denote the endpoints of an edge. These edges form a tree. The next line contains one integer  () \u2014 the number of Bob's chips. The last line contains  integers , , ...,  (;  if ) \u2014 the vertices where the Bob's chips are initially placed.", "output": "Print  integers. The -th of them should be equal to the number of turns the game will last if Alice initially places her chip in the vertex . If one of Bob's chips is already placed in vertex , then the answer for vertex  is .", "tutorial": "This task was inspired by an older edu task and another task proposed by RockyB.Let's learn to solve the problem for at least one starting vertex for Alice. Let this vertex be . In general, Alice's strategy is basically this: run to some vertex  as fast as possible and stay in it until Bob reaches . Hesitation on a way to this vertex won't be optimal. Visiting the same vertex multiple times won't as well. I guess that can be proven more formally by analyzing the set of possible solutions after each move.What properties should vertex  have for Alice to be able to escape to it? There shouldn't be a way for Bob to catch her midway. However, it's not necessary to check any midway intersections. If Bob can catch her anywhere on a path, she can also follow her to the end (by moving the same path) and catch her at the destination. Thus, this vertex  should be further from any Bob's chips than from .So you can precalculate the distance to the closest Bob's chip  to each vertex . Just push all chips to a queue and run a bfs.We've learned to solve the problem in  for each vertex . Just iterate over all vertices  and take the maximum of  over such of them that have  greater than the distance from  to .Now the solution can go two ways. You can stop thinking here and obtain an  one or think more and get an .The first one goes like that. Notice that the function  if the Alice can make at least  moves from vertex  is monotonous in regard to . So we can binary search the answer. The check query transforms to the following. Consider all vertices with distance less or equal to  from . There should exist at least one vertex  with value  for the check to return true. So at least the maximum value of them should be greater than .That is basically a centroid exercise. Let each centroid store such an array  that  is the maximum value of  over all such  that belong to this centroid's subgraph and are no further than  distance from the centroid. That array can be constructed in  for all centroids in total. You can easily see that the length of this array doesn't exceed the number of vertices in the subgraph of the corresponding centroid that is  be definition.For the query iterate over all centroids  belongs to and check the value from some cell of each one's  array.For the second solution let's reverse the problem. Consider the vertex  Alice escapes to. If there is a starting vertex  no further than  from it, then the answer for  can be updated with . So we can update the subgraph of vertices with distance no more than  with the maximum of their current answer and .The solution will be almost the same centroid. Iterate over all centroids  belongs to and write  into the cell  of each one's array , where  is the distance from  to this centroid. Then build an array of prefix maximums over this array. Finally, for each  collect the best answer over all centroids  belongs to.Overall complexity:  or .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint n;\nvector<vector<int>> g;\n\nvector<int> h, pcd, d;\nvector<vector<int>> st, vals;\nvector<int> a;\n \nint dfs(int v, int s, int &cd, int p = -1){\n\tint sum = 1;\n\tfor (int u : g[v]) if (h[u] == -1 && u != p)\n\t\tsum += dfs(u, s, cd, v);\n\tif (cd == -1 && (2 * sum >= s || p == -1))\n\t\tcd = v;\n\treturn sum;\n}\n \nvoid build(int v, int s, int d, int p = -1){\n\tint cd = -1;\n\tdfs(v, s, cd);\n\th[cd] = d;\n\tpcd[cd] = p;\n\tfor (int u : g[cd]) if (h[u] == -1)\n\t\tbuild(u, s / 2, d + 1, cd);\n}\n\nvector<char> cur;\n\nvoid calcd(int v, int p = -1){\n\tfor (int u : g[v]) if (u != p && cur[u]){\n\t\td[u] = d[v] + 1;\n\t\tcalcd(u, v);\n\t}\n}\n\nvector<vector<int>> dist;\n\nvoid init(){\n\ta.resize(n, -1);\n\tint k;\n\tscanf(\"%d\", &k);\n\tqueue<int> q;\n\tforn(i, k){\n\t\tint v;\n\t\tscanf(\"%d\", &v);\n\t\t--v;\n\t\tq.push(v);\n\t\ta[v] = 0;\n\t}\n\twhile (!q.empty()){\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tfor (int u : g[v]) if (a[u] == -1){\n\t\t\ta[u] = a[v] + 1;\n\t\t\tq.push(u);\n\t\t}\n\t}\n\th.resize(n, -1);\n\tpcd.resize(n);\n\tbuild(0, n, 0);\n\tst.resize(n);\n\tvector<int> nd(n);\n\tforn(v, n){\n\t\tint u = v;\n\t\twhile (u != -1){\n\t\t\tst[u].push_back(v);\n\t\t\tif (pcd[u] != -1)\n\t\t\t\tnd[pcd[u]] = max(nd[pcd[u]], nd[u] + 1);\n\t\t\tu = pcd[u];\n\t\t}\n\t}\n\tcur.resize(n);\n\tvals.resize(n);\n\tdist.resize(n);\n\tvector<int> ord(n);\n\tiota(ord.begin(), ord.end(), 0);\n\tsort(ord.begin(), ord.end(), [&nd](int x, int y){\n\t\treturn nd[x] < nd[y];\n\t});\n\td.resize(n);\n\tfor (int v : ord){\n\t\tfor (int u : st[v]) cur[u] = true;\n\t\td[v] = 0;\n\t\tcalcd(v);\n\t\tint mx = 0;\n\t\tfor (int u : st[v]) mx = max(mx, d[u]);\n\t\tvals[v].resize(mx + 1, 0);\n\t\tfor (int u : st[v]) vals[v][d[u]] = max(vals[v][d[u]], a[u]);\n\t\tforn(j, mx) vals[v][j + 1] = max(vals[v][j + 1], vals[v][j]);\n\t\tfor (int u : st[v]) cur[u] = false;\n\t\tfor (int u : st[v]) dist[u].push_back(d[u]);\n\t}\n}\n\nbool check(int v, int x){\n\tfor (int i = 0, u = v; u != -1; u = pcd[u], ++i)\n\t\tif (x - dist[v][i] >= 0 && vals[u][min(int(vals[u].size()) - 1, x - dist[v][i])] > x)\n\t\t\treturn true;\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tg.resize(n);\n\tforn(i, n - 1){\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tinit();\n\tforn(v, n){\n\t\tint res = 0;\n\t\tint l = 0, r = n;\n\t\twhile (l <= r){\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (check(v, m)){\n\t\t\t\tres = m + 1;\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr = m - 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d \", res);\n\t}\n\tputs(\"\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}