{"link": "https://codeforces.com//contest/710/problem/E", "problemId": "68763", "shortId": "710E", "contest_number": "710", "name": "E. Generate a String", "statement": " wants to generate an input file for some programming competition problem.His input is a string consisting of  letters 'a'. He is too lazy to write a generator so he will manually generate the input in a text editor.Initially, the text editor is empty. It takes him  seconds to insert or delete a letter 'a' from the text file and  seconds to copy the contents of the entire text file, and duplicate it. wants to find the minimum amount of time needed for him to create the input file of exactly  letters 'a'. Help him to determine the amount of time needed to generate the input.", "input": "The only line contains three integers ,  and  (, ) \u2014 the number of letters 'a' in the input file and the parameters from the problem statement.", "output": "Print the only integer  \u2014 the minimum amount of time needed to generate the input file.", "tutorial": "This problem has a simple solution described by participants in the comments.\nMy solution is a little harder. Let's solve it using dynamic programming. Let  be the smallest amount of time needed to get  letters 'a'. Let's consider transitions: the transition for adding one letter 'a' can be simply done. Let's process transitions for multiplying by two and subtraction by one simultaneously: let's decrease the number   times by one right after getting it. Easy to see that such updates never include each other, so we can store them in queue by adding the new update at the tail of the queue and taking the best update from the head.\nThe solution is hard to describe, but it is very simple in the code, so please check it to understand the idea :-)\n", "solution": "int n;\nli x, y;\n\nbool read() {\n\treturn !!(cin >> n >> x >> y);\n}\n\nconst int N = 20 * 1000 * 1000 + 13;\n\nli z[N];\n\nvoid solve() {\n\tforn(i, N) z[i] = LLONG_MAX;\n\n\tlist<pair<li, int>> q;\n\n\tz[0] = 0;\n\tforn(i, n + 1) {\n\t\twhile (!q.empty() && q.front().y < i) q.pop_front();\n\n\t\tif (!q.empty()) z[i] = min(z[i], q.front().x - i * x);\n\t\tassert(z[i] != LLONG_MAX);\n\n\t\tpair<li, int> cur(z[i] + y + 2 * i * x, 2 * i);\n\t\twhile (!q.empty() && q.back().x > cur.x) q.pop_back();\n\t\tq.pb(cur);\n\n\t\tz[i + 1] = min(z[i + 1], z[i] + x);\n\t}\n\n\tcout << z[n] << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}