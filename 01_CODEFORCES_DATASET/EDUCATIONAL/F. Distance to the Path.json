{"link": "https://codeforces.com//contest/1749/problem/F", "problemId": "1596427", "shortId": "1749F", "contest_number": "1749", "name": "F. Distance to the Path", "statement": "You are given a tree consisting of  vertices. Initially, each vertex has a value .You need to perform  queries of two types:   You are given a vertex index . Print the value of the vertex .  You are given two vertex indices  and  and values  and  (). You need to add  to the value of each vertex such that the distance from that vertex to the path from  to  is less than or equal to . The  between two vertices  and  is equal to the number of  on the path from  to . For example, the distance from  to  itself is equal to .The distance from the vertex  to some path from  to  is equal to the minimum among distances from  to any vertex on the path from  to .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of vertices in the tree. Next  lines contain the edges of the tree\u00a0\u2014 one per line. Each line contains two integers  and  (; ) representing one edge of the tree. It's guaranteed that the given edges form a tree. The next line contains a single integer  ()\u00a0\u2014 the number of queries. Next  lines contain the queries\u00a0\u2014 one per line. Each query has one of the following two types:      ()\u00a0\u2014 the query of the first type;       (; ; )\u00a0\u2014 the query of the second type.  Additional constraint on the input: there is at least one query of the first type.", "output": "For each query of the first type, print the value of the corresponding vertex.", "tutorial": "For the purpose of solving the task, let's choose some root in the tree and introduce another operation to the tree: add  to all vertices that are in the subtree of the given vertex  and on the distance  from . For example, if , it's  itself or if  then it's all children of .Let's  be the parent of vertex , ,  and so on (). So, how to perform this operation? Instead of adding  to all vertices in the subtree, we can add  only to the vertex . And when we need to get the answer for some vertex , we will get it from .Of course, since there are different -s, we'll create different arrays  for each possible . So, the answer for the vertex will be equal to .Now, let's discuss how to use the introduced operation to perform the given one. We can make the given operation \"   \" using ours in the following way:   Let's find  using any standard algorithm (binary lifting, for example).  Let's split all affected vertices in three groups: subtrees of path  ( inclusive,  exclusive), subtrees of path  and subtrees of path . Note that in such way all affected vertices belong to at least one group.  Let's look at group of path . The lowest vertices are on distance  from , the next \"level\" are on distance  from , the next \"level\" are on distance  from  and so on. The last \"level\" we'll consider in this group is the vertices in the subtree of the  on distance  from it. In such a way, all we need to do is add  to all  on the path from .  The group of the path  is handled in the same way.  What's left? It's vertices   in subtree of  on distances ;  in subtree of  on distances ;  in subtree of  on distances ;  in subtree of  on distance .  Note that vertices in subtree of  on distance  are included in vertices in subtree of  on distance . Analogically, vertices on distance  from  are included in vertices on distance  from .Moreover, vertices on distance  from  are included in \" from \" that are included in \" from \" and so on. In other words, all we need to proccess are vertices:   in subtree of  on distances  and ,  in subtree of  on distances  and ,  in subtree of  on distances  and .  In total, it's at most  operations: \"add  to some vertex \". As a result, all we need to do is   add  on path from  to some ancestor  of ;  add  in some vertex  (can be done as operation  on path );  ask value in some vertex .  We can do all of these operations in  using Fenwick tree (BIT) on -s and -s (we can get from binary lifting). So the first statement operation will work in  time and the second one\u00a0\u2014 also in .In total, complexity is  time and  space.P.S.: the second operation can be further optimized to , but it's not really necessary.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = int(2e5) + 55;\nconst int LOG = 18;\n\nint n;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n))\n        return false;\n    fore (i, 0, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        \n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    return true;\n}\n\nint p[LOG][N];\nint tin[N], tout[N], T = 0;\n\nvoid build(int v, int pr) {\n    tin[v] = T++;\n    p[0][v] = pr;\n    fore (pw, 1, LOG)\n        p[pw][v] = p[pw - 1][p[pw - 1][v]];\n    \n    for (int to : g[v]) {\n        if (to == pr)\n            continue;\n        build(to, v);\n    }\n    tout[v] = T;\n}\n\nbool inside(int l, int v) {\n    return tin[l] <= tin[v] && tout[v] <= tout[l];\n}\n\nint lca(int u, int v) {\n    if (inside(u, v))\n        return u;\n    if (inside(v, u))\n        return v;\n    \n    for (int pw = LOG - 1; pw >= 0; pw--) {\n        if (!inside(p[pw][u], v))\n            u = p[pw][u];\n    }\n    return p[0][u];\n}\n\nconst int D = 21;\nstruct Fenwick {\n    int n;\n    vector<int> F;\n    void init(int nn) {\n        n = nn;\n        F.assign(n, 0);\n    }\n    \n    void add(int pos, int val) {\n        for (; pos < n; pos |= pos + 1)\n            F[pos] += val;\n    }\n    int sum(int pos) {\n        int ans = 0;\n        for (; pos >= 0; pos = (pos & (pos + 1)) - 1)\n            ans += F[pos];\n        return ans;\n    }\n    int getSum(int l, int r) {\n        return sum(r - 1) - sum(l - 1);\n    }\n};\n\nstruct DS {\n    Fenwick f;\n    void init(int n) {\n        f.init(n);\n    }\n    \n    void addPath(int v, int l, int k) {\n        f.add(tin[v], +k);\n        f.add(tin[l], -k);\n    }\n    int getVertex(int v) {\n        return f.getSum(tin[v], tout[v]);\n    }\n    \n    void addVertex(int v, int k) {\n        f.add(tin[v], +k);\n        if (p[0][v] != v)\n            f.add(tin[p[0][v]], -k);\n    }\n};\n\nDS t[D];\n\ninline void solve() {\n    fore (i, 0, D) {\n        g[n - 1 + i].push_back(n + i);\n        g[n + i].push_back(n - 1 + i);\n    }\n    int root = n + D - 1;\n    \n    build(root, root);\n    fore (i, 0, D)\n        t[i].init(root + 1);\n    \n    int m; cin >> m;\n    fore(_, 0, m) {\n        int tp; cin >> tp;\n        if (tp == 1) {\n            int v; cin >> v;\n            v--;\n            \n            int ans = 0;\n            for (int i = 0, cur = v; i < D; i++, cur = p[0][cur])\n                ans += t[i].getVertex(cur);\n            cout << ans << endl;\n        } \n        else {\n            assert(tp == 2);\n\n            int u, v, k, d;\n            cin >> u >> v >> k >> d;\n            u--, v--;\n            \n            int l = lca(u, v);\n            \n            if (u != l)\n                t[d].addPath(u, l, k);\n            if (v != l)\n                t[d].addPath(v, l, k);\n            \n            for (int i = 0; i <= d; i++, l = p[0][l]) {\n                t[d - i].addVertex(l, k);\n                if (d - i > 0)\n                    t[d - i - 1].addVertex(l, k);\n            }\n        }\n    }\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}