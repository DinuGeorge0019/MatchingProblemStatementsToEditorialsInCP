{"link": "https://codeforces.com//contest/1295/problem/E", "problemId": "526704", "shortId": "1295E", "contest_number": "1295", "name": "E. Permutation Separation", "statement": "You are given a permutation  (an array where each integer from  to  appears exactly once). The weight of the -th element of this permutation is .At first, you separate your permutation into two  sets \u2014 prefix and suffix. More formally, the first set contains elements , the second \u2014 , where .After that, you may move elements between sets. The operation you are allowed to do is to choose some element of the first set and move it to the second set, or vice versa (move from the second set to the first). You have to pay  dollars to move the element .Your goal is to make it so that each element of the first set is less than each element of the second set. Note that if one of the sets is empty, this condition is met.For example, if  and , then the optimal strategy is: separate  into two parts  and  and then move the -element into first set (it costs ). And if , , then the optimal strategy is: separate  into two parts  and , and then move the -element into first set (it costs ), and -element into second set (it also costs ).Calculate the minimum number of dollars you have to spend.", "input": "The first line contains one integer  () \u2014 the length of permutation. The second line contains  integers  (). It's guaranteed that this sequence contains each element from  to  exactly once. The third line contains  integers  ().", "output": "Print one integer \u2014 the minimum number of dollars you have to spend.", "tutorial": "\"All elements in the left set smaller than all elements in the right set\" means that there is such value  that all elements from the first set less than  and all elements from the second set are more or equal to . So let's make a sweep line on  from  to  while trying to maintain all answers for each prefix .Let's maintain for each  the total cost  to make sets \"good\" if we split the permutation  on sets  and  in such way that after transformations all elements in the first set less than . It's easy to see that the total cost is equal to sum of weights  where  and  and  where  and .So what will happen if we increase  by ? Let's define the position of  as . For each  we don't need to move  to the second set anymore, so we should make . On the other hand, for each  we need to move  from the second set to the first one now, so we should make .The answer will be equal to the . It means that we should handle two operations: add some value on the segment and ask minimum on the segment. So we can store all  in pretty standart Segment Tree with \"add on segment\" and \"minimum on segment\" while iterating over . So the total complexity is .", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = int(2e5) + 99;\n\nint n;\nint p[N];\nint rp[N];\nint a[N];\n\nlong long b[N];\nlong long t[4 * N];\nlong long add[4 * N];\n\nvoid build(int v, int l, int r){\n\tif(r - l == 1){\n\t\tt[v] = b[l];\n\t\treturn;\n\t}\n\n\tint mid = (l + r) / 2;\t\n\tbuild(v * 2 + 1, l, mid);\n\tbuild(v * 2 + 2, mid, r);\n\tt[v] = min(t[v * 2 + 1], t[v * 2 + 2]); \n}\n\nvoid push(int v, int l, int r){\n\tif(add[v] != 0){\n\t\tif(r - l > 1)\n\t\t\tfor(int i = v+v+1; i < v+v+3; ++i){\n\t\t\t\tadd[i] += add[v];\n\t\t\t\tt[i] += add[v];\n\t\t\t}\n\t\tadd[v] = 0;\n\t}\n}\n\nvoid upd(int v, int l, int r, int L, int R, int x){\n\tif(L >= R) return;\n\tif(l == L && r == R){\n\t\tadd[v] += x;\n\t\tt[v] += x;\n\t\tpush(v, l, r);\n\t\treturn;\n\t}\n\t\n\tpush(v, l, r);\n\tint mid = (l + r) / 2;\n\tupd(v * 2 + 1, l, mid, L, min(mid, R), x);\n\tupd(v * 2 + 2, mid, r, max(mid, L), R, x);\n\n\tt[v] = min(t[v * 2 + 1], t[v * 2 + 2]);\n}\n\nvoid upd(int l, int r, int x){\n\tupd(0, 0, n, l, r, x);\n}\n\nlong long get(int v, int l, int r, int L, int R){\n\tif(L >= R) return 1e18;\n\n\tpush(v, l, r);\n\tif(l == L && r == R)\n\t\treturn t[v];\n\n\tint mid = (l + r) / 2;\n\treturn min(get(v * 2 + 1, l, mid, L, min(R, mid)), \n\t\t   get(v * 2 + 2, mid, r, max(L, mid), R));\t\t\n}\n\nlong long get(int l, int r){\n\treturn get(0, 0, n, l, r);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%d\", p + i);\n        --p[i];\n        rp[p[i]] = i;\n\t}\n\tfor(int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", a + i);\n\t\n\tb[0] = a[0];\n\tfor(int i = 1; i < n; ++i)\n\t\tb[i] = a[i] + b[i - 1];\n\tbuild(0, 0, n);\n\t\n\tlong long res = get(0, n - 1);\n\t//for(int i = 0; i < n; ++i) cout << get(i, i+1) << ' ';cout << endl;\n\tfor(int i = 0; i < n; ++i){\n\t    int pos = rp[i];\n\t\tupd(pos, n, -a[pos]);\n\t\tupd(0, pos, a[pos]);\n\t\tres = min(res, get(0, n - 1));\n\t\t//for(int i = 0; i < n; ++i) cout << get(i, i+1) << ' ';cout << endl;\n\t}\n\t\n\tcout << res << endl;\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}