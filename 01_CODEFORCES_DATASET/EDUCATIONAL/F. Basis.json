{"link": "https://codeforces.com//contest/1644/problem/F", "problemId": "1306307", "shortId": "1644F", "contest_number": "1644", "name": "F. Basis", "statement": "For an array of integers , let's define  as the number of elements in it.Let's denote two functions:  is a function that takes an array of integers  and a positive integer . The result of this function is the array containing  first elements of the array that you get by replacing each element of  with exactly  copies of that element.For example,  is calculated as follows: first, you replace each element of the array with  copies of it, so you obtain . Then, you take the first  elements of the array you obtained, so the result of the function is .  is a function that takes an array of integers  and two  integers  and . The result of this function is the array  with every element equal to  replaced by , and every element equal to  replaced by .For example, .An array  is a  of the array  if:  either there exists a positive integer  such that ;  or there exist two different integers  and  such that . An array  is an  of the array  if there exists a finite sequence of arrays  () such that  is ,  is , and for every ,  is a parent of ..You are given two integers  and . Your goal is to construct a sequence of arrays  in such a way that:  every array  contains exactly  elements, and all elements are integers from  to ;  for every array  consisting of exactly  integers from  to , the sequence contains at least one array  such that  is an ancestor of . Print the minimum number of arrays in such sequence.", "input": "The only line contains two integers  and  ().", "output": "Print one integer \u2014 the minimum number of elements in a sequence of arrays meeting the constraints. Since the answer can be large, output it modulo .", "tutorial": "First of all, since the second operation changes all occurrences of some number  to other number  and vice versa, then, by using it, we can convert an array into another array if there exists a bijection between elements in the first array and elements in the second array. It can also be shown that , so we can consider that if we want to transform an array into another array, then we first apply the function , then the function .Another relation that helps us is that , it means that every time we apply the function , we can easily rollback the changes. Considering that we have already shown that a sequence of transformations can be reordered so that we apply  only after we've made all operations with the function , let's try to \"rollback\" the second part of transformations, i.\u2009e. for each array, find some  which can be obtained by using the function .Since applying the second operation several times is equal to applying some bijective function to the array, we can treat each array as a partition of the set  into several subsets. So, if we are not allowed to perform the first operation, the answer to the problem is equal to , where  is the number of ways to partition a set of  objects into  non-empty sets (these are known as ). There are many ways to calculate Stirling numbers of the second kind, but in this problem, we will have to use some FFT-related approach which allows getting all Stirling numbers for some value of  in time . For example, you can use the following relation: If we substitute  and , we can see that the sequence of Stirling numbers for some fixed  is just the convolution of sequences  and .For simplicity in the following formulas, let's denote . We now know that this value can be calculated in .Okay, now back to the original problem. Unfortunately, we didn't take the operation  into account. Let's analyze it.The result of function  consists of several blocks of equal elements, and it's easy to see that the lengths of these blocks (except for maybe the last one) should be divisible by . The opposite is also true \u2014 if the lengths of all blocks (except maybe for the last one) are divisible by some integer , then the array can be produced as  for some array .What does it mean? If the greatest common divisor of the lengths of the blocks (except for the last one) is not , the array that we consider can be obtained by applying the function  to some other array. Otherwise, it cannot be obtained in such a way. Now, inclusion-exclusion principle comes to the rescue.Let's define  as the number of arrays that we consider which have the lengths of all their blocks (except maybe for the last one) divisible by . It's easy to see that  (we can compress every  consecutive elements into one). Then, using inclusion exclusion principle, we can see that the answer is,where  is the Mobius function. Using this formula, we can calculate the answer in .. This inclusion-exclusion principle handles the arrays according to the GCD of the blocks that they consist of, except for the last one. But what if the array consists only of one block? These arrays can be counted wrongly, so we should exclude them \u2014 i.\u2009e. use  instead of just  and count the arrays consisting of the same element (if we need any of them in the answer separately).. Depending on the way you implement this,  or  (or both) may be a corner case.", "solution": null, "interactive": false, "noSolution": false, "noTutorial": false}