{"link": "https://codeforces.com//contest/1156/problem/B", "problemId": "338449", "shortId": "1156B", "contest_number": "1156", "name": "B. Ugly Pairs", "statement": "You are given a string, consisting of lowercase Latin letters.A pair of  letters in a string is considered ugly if these letters are also  in a alphabet. For example, string \"\" contains ugly pairs at positions  \u2014 \"\" and  \u2014 \"\". Letters '' and '' aren't considered neighbouring in a alphabet.Can you rearrange the letters of a given string so that there are no ugly pairs? You can choose any order of the letters of the given string but you can't add any new letters or remove the existing ones. You can also leave the order the same.If there are multiple answers, print any of them.You also have to answer  separate queries.", "input": "The first line contains a single integer  () \u2014 the number of queries. Each of the next  lines contains string   \u2014 the string for the next query. It is guaranteed that it contains only lowercase Latin letters. .", "output": "Print  lines. The -th line should contain the answer to the -th query. If the answer for the -th query exists, then print such a rearrangment of letters of the given string that it contains no ugly pairs. You can choose any order of the letters of the given string but you can't add any new letters or remove the existing ones. You can also leave the order the same. If there are multiple answers, print any of them. Otherwise print \"\" for that query.", "tutorial": "To be honest, the solution to this problem is easier to code than to prove.Let's follow the next strategy. Write down all the letters of the string which have odd positions in alphabet (\"\") and even positions in alphabet (\"\"). Sort both of these lists in non-decreasing order. The answer is either concatenation of the lists (odd + even or even + odd) or \"\".Now for the proof part. Let's establish that we don't care about equal letters and leave just a single copy of each letter of the string. Let's check some cases:  There is just a single letter. That's trivial.  There are two letters of the same parity. There is no incorrect arrangement for this.  There are two letters of different parity. If they differ by one then no answer exists. Otherwise any arrangement works.  There are three letters and they are consecutive in alphabet. No answer exists.  There are other types of three letters. Then the one of the different parity can put on the side (e.g. \"\" and \"\"). As the difference between at least one of these letters and that one isn't 1, that arrangement will be ok.  Finally, there are at least 4 letters. It means that the difference between either the smallest odd and the largest even or between the smallest even and the largest odd isn't 1. The only thing you need to do is to implement the check function the most straightforward way possible and check both arrangements.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nbool check(string s){\n\tbool ok = true;\n\tforn(i, int(s.size()) - 1)\n\t\tok &= (abs(s[i] - s[i + 1]) != 1);\n\treturn ok;\n}\n\nint main() {\n\tint T;\n\tscanf(\"%d\", &T);\n\tstatic char buf[120];\n\tforn(_, T){\n\t\tscanf(\"%s\", buf);\n\t\tstring s = buf;\n\t\tstring odd = \"\", even = \"\";\n\t\tforn(i, s.size()){\n\t\t\tif (s[i] % 2 == 0)\n\t\t\t\todd += s[i];\n\t\t\telse\n\t\t\t\teven += s[i];\n\t\t}\n\t\tsort(odd.begin(), odd.end());\n\t\tsort(even.begin(), even.end());\n\t\tif (check(odd + even))\n\t\t\tprintf(\"%s\\n\", (odd + even).c_str());\n\t\telse if (check(even + odd))\n\t\t\tprintf(\"%s\\n\", (even + odd).c_str());\n\t\telse\n\t\t\tputs(\"No answer\");\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}