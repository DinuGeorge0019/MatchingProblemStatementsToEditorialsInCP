{"link": "https://codeforces.com//contest/1555/problem/F", "problemId": "1062145", "shortId": "1555F", "contest_number": "1555", "name": "F. Good Graph", "statement": "You have an undirected graph consisting of  vertices with weighted edges.A simple cycle is a cycle of the graph without repeated vertices. Let the  of the cycle be the XOR of weights of edges it consists of.Let's say the graph is  if all its  cycles have weight . A graph is bad if it's not good.Initially, the graph is empty. Then  queries follow. Each query has the next type:     \u00a0\u2014 add edge between vertices  and  of weight  if it doesn't make the graph bad. For each query print, was the edge added or not.", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the number of vertices and queries. Next  lines contain queries\u00a0\u2014 one per line. Each query contains three integers ,  and  (; ; )\u00a0\u2014 the vertices of the edge and its weight. ", "output": "For each query, print  if the edge was added to the graph, or  otherwise (both case-insensitive).", "tutorial": "Firstly, let's prove that a good graph has one important property: any two of its simple cycles intersect by at most one vertex, i.\u00a0e. there is no edge that belongs to more than one simple cycle (cactus definition, yeah).Let's prove it by showing that if two simple cycles of weight $$$k > 0$$$ intersects (by edges) then they will induce a simple cycle of weight $$$\\neq k$$$. There are two cases:   if cycles intersect by a single path, then we can create a new cycle by merging parts of cycles excluding the intersecting path\u00a0\u2014 it will be simple and will have weight $$$k \\oplus k = 0 \\neq k$$$;  if cycles intersect by more than one path, we can do the next transformation: suppose the common paths are $$$u_1 - v_1$$$, $$$u_2 - v_2$$$, $$$\\dots$$$, and they are ordered in the way how they lie on the first cycle. Let's create a third cycle using two paths from $$$v_1$$$ to $$$u_2$$$: from the first cycle and from the second cycle. It's easy to see that the third cycle is simple, and more over it has only one common path with the second cycle. So, it's either the third cycle has weight not equal to $$$k$$$ or the case $$$1$$$. Okay, let's analyze the edges we try to add. Let's divide all edges in two types:  edges and all other edges (we will name them  edges). Let's name an edge as a  edge if it connects two different components at a moment when we are trying to add it in the graph.It's obvious that we will add all tree edges in the graph, since they can't make it bad (since they don't induce new cycles). But there is a more interesting observation: when we try to add a cycle edge $$$(u, v)$$$, it should induce an only one simple cycle where all other edges are tree edges and these tree edges can't be used in any other cycle.It induces at least one \"all-tree-edge\" cycle, since $$$u$$$ and $$$v$$$ are already connected. It can't induce more than one \"all-tree-edge\" cycle, since it contradicts with  definition, and if it induces a cycle with some other cycle edge, then we can replace that cycle edge with its own tree-edge path: our cycle will become \"all-tree-edge\" cycle, but it will use already used tree edges. In other words, it's enough to consider only one \"all-tree-edge\" cycle induced by any cycle edge.The final trick is to calculate the answer in two steps: at the first step, we will find only tree edges (using DSU) that will form a spanning forest in our graph.The second step is for each cycle edge $$$(u, v)$$$ to calculate the $$$\\operatorname{XOR}$$$ $$$X$$$ on a path between $$$u$$$ and $$$v$$$ in our spanning forest, check that $$$X \\oplus \\text{edge_weight} = 1$$$ and check that none of edges on the path from $$$u$$$ to $$$v$$$ are used in other cycle.Calculating $$$X$$$ is easy: if we precalculate for each vertex $$$v$$$ the $$$\\operatorname{XOR}$$$ on path from $$$v$$$ to root $$$\\mathit{xr}[v]$$$ then $$$X = \\mathit{xr}[u] \\oplus \\mathit{xr}[v]$$$.Checking that none of the edges are used on the path from $$$u$$$ to $$$v$$$ is a bit tricky: if we mark an edge by adding $$$1$$$ to it, then we should be able to take a sum on path and add on path. There are structures that are capable of it (like HLD and other), but let's look closely.Note that we mark each tree edge at most once, so we can manually add $$$1$$$ to each edge, and only asking sum on path should be fast. In other words, we need a data structure (DS) that can add value at edge and take the sum on path\u00a0\u2014 and such DS is a Fenwick tree (BIT) built on Euler tour of tree: it can add value at edge and ask a sum on path from $$$v$$$ to root. So we need to find LCA as well, since sum of path $$$(u, v)$$$ is equal to $$$sum(u) + sum(v) - 2 \\cdot sum(LCA(u, v))$$$.As a result, complexity is $$$O((n + m) \\log(n))$$$ with quite a low constant from LCA and BIT.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \" \";\n\t\tout << v[i];\n\t}\n\treturn out;\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nint n, q;\nvector< array<int, 3> > es;\n\ninline bool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tes.resize(q);\n\tfore (i, 0, q) {\n\t\tcin >> es[i][0] >> es[i][1] >> es[i][2];\n\t\tes[i][0]--;\n\t\tes[i][1]--;\n\t}\n\treturn true;\n}\n\nvector< vector<pt> > g;\n\nconst int LOG = 19;\nvector<int> up[LOG];\nvector<int> tin, tout;\nvector<int> xr;\nint T = 0;\n\nvoid dfs(int v, int p, int curXor) {\n\ttin[v] = T++;\n\txr[v] = curXor;\n\tup[0][v] = p;\n\tfore (pw, 1, LOG)\n\t\tup[pw][v] = up[pw - 1][up[pw - 1][v]];\n\t\n\tfor (auto [to, w] : g[v]) {\n\t\tif (to == p)\n\t\t\tcontinue;\n\t\tdfs(to, v, curXor ^ w);\n\t}\n\ttout[v] = T;\n}\n\nvoid buildLCA() {\n\tfore (pw, 0, LOG)\n\t\tup[pw].resize(n);\n\ttin.assign(n, -1);\n\ttout.assign(n, -1);\n\txr.assign(n, 0);\n\t\n\tT = 0;\n\tfore (v, 0, n) {\n\t\tif (tin[v] != -1)\n\t\t\tcontinue;\n\t\tdfs(v, v, 0);\n\t}\n}\n\nint isPar(int p, int v) {\n\treturn tin[p] <= tin[v] && tout[v] <= tout[p];\n}\n\nint lca(int u, int v) {\n\tif (isPar(u, v)) return u;\n\tif (isPar(v, u)) return v;\n\t\n\tfor (int pw = LOG - 1; pw >= 0; pw--) {\n\t\tif (!isPar(up[pw][v], u))\n\t\t\tv = up[pw][v];\n\t}\n\treturn up[0][v];\n}\n\nvector<int> par, rk;\n\nvoid init(int n) {\n\tpar.assign(n, 0);\n\tiota(par.begin(), par.end(), 0);\n\trk.assign(n, 1);\n}\n\nint top(int v) {\n\tif (par[v] != v)\n\t\treturn par[v] = top(par[v]);\n\treturn v;\n}\n\nbool unite(int u, int v) {\n\tu = top(u);\n\tv = top(v);\n\tif (u == v)\n\t\treturn false;\n\tif (rk[u] < rk[v])\n\t\tswap(u, v);\n\tpar[v] = u;\n\trk[u] += rk[v];\n\treturn true;\n}\n\nvector<int> F;\nvoid inc(int pos, int val) {\n\tfor(; pos < sz(F); pos |= pos + 1)\n\t\tF[pos] += val;\n}\nint sum(int pos) {\n\tint ans = 0;\n\tfor(; pos >= 0; pos = (pos & (pos + 1)) - 1)\n\t\tans += F[pos];\n\treturn ans;\n}\n\nvoid addOnPath(int v, int l) {\n\twhile (v != l) {\n\t\tinc(tin[v], 1);\n\t\tinc(tout[v], -1);\n\t\tv = up[0][v];\n\t}\n}\n\ninline void solve() {\n\tinit(n);\n\tg.resize(n);\n\t\n\tvector<int> ans(q, -1);\n\tfore (i, 0, q) {\n\t\tint u = es[i][0];\n\t\tint v = es[i][1];\n\t\tint x = es[i][2];\n\t\t\n\t\tif (unite(u, v)) {\n\t\t\tans[i] = 1;\n\t\t\tg[u].emplace_back(v, x);\n\t\t\tg[v].emplace_back(u, x);\n\t\t}\n\t}\n\t\n\tbuildLCA();\n\tF.assign(2 * n + 5, 0);\n\t\n\tfore (i, 0, q) {\n\t\tif (ans[i] != -1)\n\t\t\tcontinue;\n\t\t\n\t\tans[i] = 0;\n\t\tint u = es[i][0];\n\t\tint v = es[i][1];\n\t\tint x = es[i][2];\n\t\t\n\t\tint xorPath = xr[u] ^ xr[v];\n\t\tif ((xorPath ^ x) != 1)\n\t\t\tcontinue;\n\t\t\n\t\tint l = lca(u, v);\n\t\tint usedOnPath = sum(tin[u]) + sum(tin[v]) - 2 * sum(tin[l]);\n\t\tif (usedOnPath > 0)\n\t\t\tcontinue;\n\t\t\n\t\tans[i] = 1;\n\t\taddOnPath(u, l);\n\t\taddOnPath(v, l);\n\t}\n\t\n\tfor (int res : ans)\n\t\tcout << (res ? \"YES\" : \"NO\") << '\\n';\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}