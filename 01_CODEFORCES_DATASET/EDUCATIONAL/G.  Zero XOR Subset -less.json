{"link": "https://codeforces.com//contest/1101/problem/G", "problemId": "281060", "shortId": "1101G", "contest_number": "1101", "name": "G.  Zero XOR Subset -less", "statement": "You are given an array  of integer numbers.Your task is to divide the array into the maximum number of segments in such a way that:  each element is contained in  segment;  each segment contains at least one element;  there doesn't exist a non-empty subset of segments such that bitwise XOR of the numbers from them is equal to . Print the maximum number of segments the array can be divided into. Print  if no suitable division exists.", "input": "The first line contains a single integer  () \u2014 the size of the array. The second line contains  integers  ().", "output": "Print the maximum number of segments the array can be divided into while following the given constraints. Print  if no suitable division exists.", "tutorial": "Let's consider some division , , ..., . Represent the XOR sum of the subset via prefix-XOR. Those are , , ..., .I claim that you can collect any subset that is a XOR of an even number of  for pairwise distinct values of . Let's take a look on some prefix of processed segments, where the last segment is taken into subset. The previous taken 's can't be changed, the last taken  can either be eliminated if we also take the current segment (and that segment erases one value and adds one) or added to the answer if we don't take it (but the next taken segment will add two values). You can see that the parity doesn't change.Moreover, you can collect any subset that is a XOR of an odd number of  for pairwise distinct values of . Just forget about  taken into the answer, as its value is . Then all the even subsets which included it will become odd.This way we can collect all subsets of  for some division. Now you just want find the division that produces the maximum number of linearly independent numbers (binary vectors). That is \u2014 the size of the basis of the space of chosen numbers (binary vectors). Now it's time to abuse the fact that adding a number into the set can only increase the size of basis of the space. Thus, adding anything to the maximum set won't change the answer (otherwise the result would be greater than the \"maximum\").Finally, you say that the maximum basis size is equal to the basis size of all the prefix-XOR and easily calculate in .The only corner case is  being  itself. Then for any division the full subset will also give  result. That is the only case with answer .Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int LOGN = 30;\n\nint n;\nint a[N], pr[N];\nint base[LOGN];\n\nvoid try_gauss(int v){\n\tfor(int i = LOGN - 1; i >= 0; i--)\n\t\tif (base[i] != -1 && (v & (1 << i)))\n\t\t\tv ^= base[i];\n\tif (v == 0)\n\t\treturn;\n\tfor(int i = LOGN - 1; i >= 0; i--) if (v & (1 << i)){\n\t\tbase[i] = v;\n\t\treturn;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\tmemset(base, -1, sizeof(base));\n\tforn(i, n){\n\t\tpr[i + 1] = pr[i] ^ a[i];\n\t\ttry_gauss(pr[i + 1]);\n\t}\n\tif (pr[n] == 0){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint siz = 0;\n\tforn(i, LOGN)\n\t\tsiz += (base[i] != -1);\n\tprintf(\"%d\\n\", siz);\n}", "interactive": false, "noSolution": false, "noTutorial": false}