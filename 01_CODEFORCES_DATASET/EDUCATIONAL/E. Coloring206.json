{"link": "https://codeforces.com//contest/1574/problem/E", "problemId": "1115678", "shortId": "1574E", "contest_number": "1574", "name": "E. Coloring", "statement": "A matrix of size , such that each cell of it contains either  or , is considered  if the sum in every contiguous submatrix of size  is exactly , i.\u2009e. every \"square\" of size  contains exactly two 's and exactly two 's.You are given a matrix of size . Initially each cell of this matrix is empty. Let's denote the cell on the intersection of the -th row and the -th column as . You have to process the queries of three types:     \u2014 clear the cell , if there was a number in it;     \u2014 write the number  in the cell , ;     \u2014 write the number  in the cell , . After each query, print the number of ways to fill the empty cells of the matrix so that the resulting matrix is . Since the answers can be large, print them modulo .", "input": "The first line contains three integers ,  and  (; ) \u2014 the number of rows in the matrix, the number of columns, and the number of queries, respectively. Then  lines follow, the -th of them contains three integers , ,  (; ; ) \u2014 the parameters for the -th query.", "output": "For each query, print one integer \u2014 the number of ways to fill the empty cells of the matrix after the respective query, taken modulo .", "tutorial": "For best understanding we replace the matrix with  and  with the matrix with black and white cells.At first let's consider matrix if there are two adjacent horizontal cell with same color (for example cells  and  are black). Then the cells , ,  and  must have the opposite color (white); the cells , ,  and  must have the same color (black) and so on. So, two adjacent horizontal cells generate the  of width two. Reciprocally two adjacent vertical cells generate the  of width two. And if simultaneously there are  and  then the answer is  (because they contradict each other).If there are two cells of same color in the same row with even number of cells between them (for example  and  with four cells between them) then there is the  (because there are always two adjacent cells with same color between them). The same is correct for . Now let's consider how the matrix look if there are the . It look like a chess board of size , but colors of some verticals are inverted. The same is correct if there are the .How we can quickly understand that there are two cells of same color in the same row with even number of cells between them? For this mentally color the matrix in a checkerboard pattern. And then one of this cells has the same color witch cells in chessboard, and the other has the opposite color witch cells in chessboard.For calculating the answer we have maintain to the following values:   The color of each colored cell;  The row and columns containing the cells of same color with even number of cells between them;  And the number of row and columns containing at least one colored cell (for calculating the number of beautiful matrix). ", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int N = 1'000'009;\n\nint sum (int a, int b) {\n    int res = a + b;\n    if (res < 0) res += MOD;\n    if (res >= MOD) res -= MOD;\n    return res;\n}\n\nint n, m, k;\nmap <pair <int, int>, char> c;\nint cntr[N][2], cntc[N][2];\nint cntx[2];\nset <int> badr, badc;\nset<int> ur, uc;\nint p2[N];\n\nvoid upd2(int pos, int col, int add, int cnt[N][2], set <int> &bad, set<int> &u) {\n    cnt[pos][col] += add;\n    assert(cnt[pos][col] >= 0);\n    \n    if (cnt[pos][0] > 0 && cnt[pos][1] > 0){\n        if (!bad.count(pos))\n            bad.insert(pos);\n    } else {\n        if (bad.count(pos))\n            bad.erase(pos);\n    }\n    \n    if (cnt[pos][0] > 0 || cnt[pos][1] > 0){\n        if (!u.count(pos))\n            u.insert(pos);\n    } else {\n        if (u.count(pos))\n            u.erase(pos);\n    }\n}\n\nvoid upd(int x, int y, int t) {\n    int col = (x & 1) ^ (y & 1);\n    if (c.count({x, y})) {\n        int ncol = col ^ c[{x, y}];\n        --cntx[ncol];\n        upd2(x, ncol, -1, cntr, badr, ur);\n        upd2(y, ncol, -1, cntc, badc, uc);\n        c.erase({x, y});\n    }\n    \n    if (t == -1)\n        return;\n        \n    int ncol = col ^ t;\n    ++cntx[ncol];\n    upd2(x, ncol, 1, cntr, badr, ur);\n    upd2(y, ncol, 1, cntc, badc, uc);\n    c[{x, y}] = t;\n}\n\nint main(){\n    p2[0] = 1;\n    for (int i = 1; i < N; ++i)\n        p2[i] = sum(p2[i - 1], p2[i - 1]);\n        \n    scanf(\"%d%d%d\", &n, &m, &k);\n    for (int i = 0; i < k; ++i) {\n        int x, y, t;\n        scanf(\"%d %d %d\", &x, &y, &t);\n        --x, --y;\n        upd(x, y, t);\n        \n        int res = 0;\n        if(badr.size() > 0 && badc.size() > 0) {\n            res = 0;\n        } else if (badr.size() > 0) {\n            assert(m - uc.size() >= 0);\n            res = p2[m - uc.size()];\n        } else if (badc.size() > 0) {\n            assert(n - ur.size() >= 0);\n            res = p2[n - ur.size()];\n        } else {\n            if (ur.size() == 0 && uc.size() == 0)\n                res = sum(sum(p2[n], p2[m]), -2);\n            else {\n                assert(m - uc.size() >= 0);\n                res = sum(res, p2[m - uc.size()]);\n                assert(n - ur.size() >= 0);\n                res = sum(res, p2[n - ur.size()]);\n                if (cntx[0] == 0 || cntx[1] == 0) {\n                    assert(cntx[0] != 0 || cntx[1] != 0);\n                    res = sum(res, -1);\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}