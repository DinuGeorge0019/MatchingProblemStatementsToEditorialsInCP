{"link": "https://codeforces.com//contest/612/problem/C", "problemId": "43951", "shortId": "612C", "contest_number": "612", "name": "C. Replace To Make Regular Bracket Sequence", "statement": "You are given string  consists of opening and closing brackets of four kinds , , , . There are two types of brackets: opening and closing. You can replace any bracket by another of the same type. For example, you can replace  by the bracket , but you can't replace it by  or .The following definition of a regular bracket sequence is well-known, so you can be familiar with it.Let's define a regular bracket sequence (RBS). Empty string is RBS. Let  and  be a RBS then the strings , , ,  are also RBS.For example the string \"\" is RBS, but the strings \"\" and \"\" are not.Determine the least number of replaces to make the string  RBS.", "input": "The only line contains a non empty string , consisting of only opening and closing brackets of four kinds. The length of  does not exceed .", "output": "If it's impossible to get RBS from  print . Otherwise print the least number of replaces needed to get RBS from .", "tutorial": "If we forget about bracket kinds the string s should be RBS, otherwise the answer doesn't exist. If the answer exists each opening bracket matches to exactly one closing bracket and vice verse. Easy to see that if two matching brackets have the same kind we don't need to replace them. In other case we can change the kind of the closing bracket to the kind of the opening. So we can build some answer. Obviously the answer is minimal, because the problems for some pair of matching pairs are independent and can be solved separately.\nThe only technical problem is to find the matching pairs. To do that we should store the stack of opening brackets. Let's iterate from left to right in s and if the bracket is opening, we would simply add it to the stack. Now if the bracket is closing there are three cases: 1) the stack is empty; 2) at the top of the stack is the opening bracket with the same kind as the current closing; 3) the kind of the opening bracket differs from the kind of the closing bracket. In the first case answer doesn't exist, in the second case we should simply remove the opening bracket from the stack and in the third case we should remove the opening bracket from the stack and increase the answer by one.\nComplexity: O(n).\n", "solution": "/*\nHide from the public eye, choose to appear when it suits you\nClaim you're just, killing women and children\nFight, when you choose to fight, hide in a cave when you're hunted\nLike a beast spawned from hell, utilizing fear\n\nChosen by god or a coward insane?\nStand up and show me your face!\n\nSuicidal, in a trance\nA religious army\nFight without a uniform and hide in the crowd\nCall it holy, call it just\nAuthorized by heaven\nLeave your wounded as they die, and call it gods will\n\nRun when its time to pay, fear consequence of your action\nReappear, when you're almost forgotten\nDream of a world in peace, yet you cause pain and destruction\nKill your own, a response of your actions\n\nCaptured in all you lies, fear is in your eyes\nCreature who's gone insane, your war is in vain\nTrapped in a cage of stone, we'll destroy your home\nConsequence of your action\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 210000;\n\nusing namespace std;\n\nstring st;\nstack<char> S;\nint ans;\n\nint get_type(char c)\n{\n\tif (c == '<' || c == '{' || c == '[' || c == '(')\n\t\treturn 1;\n\treturn 2;\n}\n\nbool paired(char a, char b)\n{\n\tif (a == '<'&&b == '>')\n\t\treturn true;\n\tif (a == '('&&b == ')')\n\t\treturn true;\n\tif (a == '['&&b == ']')\n\t\treturn true;\n\tif (a == '{'&&b == '}')\n\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\t//freopen(\"beavers.in\",\"r\",stdin);\n\t//freopen(\"beavers.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\",\"r\",stdin);\n\t//freopen(\"F:/output.txt\",\"w\",stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin >> st;\n\n\tfor (int i = 0; i < st.size(); i++)\n\t{\n\t\tif (get_type(st[i]) == 1)\n\t\t{\n\t\t\tS.push(st[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (S.size() == 0)\n\t\t{\n\t\t\tcout << \"Impossible\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tchar val = S.top();\n\t\tif (!paired(val, st[i]))\n\t\t\t++ans;\n\t\tS.pop();\n\t}\n\n\tif (S.size())\n\t{\n\t\tcout << \"Impossible\" << endl;\n\t\treturn 0;\n\t}\n\telse\n\n\t\tcout << ans << endl;\n\tcin.get(); cin.get();\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}