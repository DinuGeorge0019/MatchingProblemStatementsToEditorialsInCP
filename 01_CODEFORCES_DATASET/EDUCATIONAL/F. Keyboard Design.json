{"link": "https://codeforces.com//contest/1739/problem/F", "problemId": "1559868", "shortId": "1739F", "contest_number": "1739", "name": "F. Keyboard Design", "statement": "Monocarp has a dictionary of  words, consisting of  first letters of the Latin alphabet. The words are numbered from  to . In every pair of adjacent characters in each word, the characters are different. For every word , Monocarp also has an integer  denoting how often he uses this word.Monocarp wants to design a keyboard that would allow him to type some of the words easily. A keyboard can be denoted as a sequence of  first letters of the Latin alphabet, where each letter from  to  appears exactly once.A word can be typed with the keyboard easily if, for every pair of adjacent characters in the word, these characters are adjacent in the keyboard as well. The  of the keyboard is the sum of  over all words  that can be typed easily with it.Help Monocarp to design a keyboard with the maximum possible optimality.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of words. Then,  lines follow. The -th of them contains an integer  () and a string  () denoting the -th word. Each character of  is one of  first letters of Latin alphabet, in lowercase. For every , the -th character of  is different from the -th one. Additional constraint on the input: .", "output": "Print a sequence of  first letters of the Latin alphabet, where each letter from  to  appears exactly once, denoting the optimal keyboard. If there are multiple answers, you may print any of them.", "tutorial": "For each word, let's consider a graph on  vertices where the -th and the -th vertices are connected by an edge iff the -th character of the alphabet is adjacent to the -th character of the alphabet in this string. Obviously, this graph is connected (except for the isolated vertices). If there is a vertex of degree  or more in this graph, or if there is a cycle in this graph, it is impossible to design a keyboard to type the word easily: in the first case, the letter represented by that vertex must have at least three neighbors on the keyboard, but can have only at most two; in the second case, the keyboard must be cyclic (and it is not). So, the word can be typed easily only if the graph representing it consists of one path and several isolated vertices.Let's write the letters along the path we constructed for the word in a single string. For example, for the word , we get edges ,  and  in the graph, so the letters along the path are either  or  (and, obviously, one can be obtained from the other by reversing the string). Let  and  be the two strings we obtain from the word  using this method. Now, we claim that the word  can be typed easily if and only if one of these two strings ( and ) is a substring of the keyboard \u2014 this would mean that every pair of letters that should be on adjacent positions are actually on adjacent positions.Okay, now we construct  and  for each word, and our goal is to find the permutation of the first  characters of Latin alphabet such that the sum of  over all words having either  or  as a substring is the maximum possible. There are two key observations that allow us to solve this problem:   and  cannot be the substrings of the same keyboard (the proof is simple: if  is a substring, its first character must be before its second character; and if  is a substring, its second-to-last character (which is the second character of ) must be before its last character (which is the first character of );  neither  nor  can appear in the keyboard twice (it's obvious since the keyboard is a permutation). So, we can reformulate the problem as follows: let  be the cost of the string  and the cost of the string  as well; find the permutation of the first  characters of the Latin alphabet so that its cost (which is the sum of costs of its substrings) is the maximum possible. To solve this problem, we can store the strings in an Aho-Corasick automaton, and for every state of the automaton, precalculate the total cost of all string ending in this state (that is, the cost of this state and all states reachable from it via the suffix links). Then run a dynamic programming of the form  \u2014 the maximum possible cost of a partial keyboard if we used a  of characters and the Aho-Corasick automaton is currently in the state . This dynamic programming runs in , where  is the size of the alphabet (), and  is the size of the automaton (up to ).", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 10043;\nconst int K = 12;\n\nint tsz = 0;\nint trie[N][K];\nint aut[N][K];\nint lnk[N];\nint p[N];\nint pchar[N];\nint cost[N];\nint ncost[N];\n\nint newNode()\n{\n    lnk[tsz] = -1;\n    ncost[tsz] = -1;\n    cost[tsz] = 0;\n    for(int i = 0; i < K; i++)\n    {\n        trie[tsz][i] = aut[tsz][i] = -1;\n    }\n    return tsz++;\n}\n\nint nxt(int x, int y)\n{                                 \n    if(trie[x][y] == -1) \n    {\n        trie[x][y] = newNode();\n        pchar[trie[x][y]] = y;\n        p[trie[x][y]] = x;\n    }\n    return trie[x][y];\n}\n\nint go(int x, int y);\n\nint get_lnk(int x)\n{\n    if(lnk[x] != -1) return lnk[x];\n    int& d = lnk[x];\n    if(x == 0 || p[x] == 0) return d = 0;\n    return d = go(get_lnk(p[x]), pchar[x]);    \n}\n\nint go(int x, int y)\n{\n    if(aut[x][y] != -1) return aut[x][y];\n    int& d = aut[x][y];\n    if(trie[x][y] != -1) return d = trie[x][y];\n    if(x == 0) return d = 0;\n    return d = go(get_lnk(x), y);\n}\n\nvoid add(string s, int c)\n{\n    int cur = 0;\n    for(auto x : s) cur = nxt(cur, x - 'a');\n    cost[cur] += c;     \n} \n\nint calc(int x)\n{\n    if(ncost[x] != -1) return ncost[x];\n    ncost[x] = cost[x];\n    int y = get_lnk(x);\n    if(y != x) ncost[x] += calc(y);\n    return ncost[x];\n}\n\nint main()\n{\n    int root = newNode();\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; i++)\n    {\n        string s;\n        int x;\n        cin >> x >> s;\n        map<char, set<char>> adj;\n        for(int j = 0; j + 1 < s.size(); j++)\n        {\n            adj[s[j]].insert(s[j + 1]);\n            adj[s[j + 1]].insert(s[j]);\n        }\n        bool bad = false;\n        string res = \"\";\n        char c;\n        for(c = 'a'; c <= 'l'; c++)\n        {\n            if(!adj.count(c)) continue;\n            if(adj[c].size() >= 3)\n                bad = true;\n            if(adj[c].size() == 1)\n                break;\n        }\n        if(c == 'm' || bad) continue;\n        res.push_back(c);\n        while(adj[c].size() > 0)\n        {\n            char d = *adj[c].begin();\n            adj[c].erase(d);\n            adj[d].erase(c);\n            c = d;\n            res.push_back(c);  \n        }\n        bad |= adj.size() != res.size();\n        map<char, int> pos;\n        for(int i = 0; i < res.size(); i++)\n            pos[res[i]] = i;\n        for(int i = 0; i + 1 < s.size(); i++)\n            bad |= abs(pos[s[i]] - pos[s[i + 1]]) > 1;\n        if(bad) continue;\n        add(res, x);\n        reverse(res.begin(), res.end());\n        add(res, x);\n    }  \n    int INF = 1e9;\n    int K = 12;\n    vector<vector<int>> dp(1 << K, vector<int>(tsz + 1, -INF));\n    vector<vector<pair<int, int>>> pdp(1 << K, vector<pair<int, int>>(tsz + 1));\n    dp[0][0] = 0;\n    for(int i = 0; i < (1 << K); i++)\n        for(int j = 0; j <= tsz; j++)\n        {\n            for(int z = 0; z < K; z++)\n            {\n                if(i & (1 << z)) continue;\n                int nstate = go(j, z);\n                int add = calc(nstate);\n                int nmask = i | (1 << z);\n                if(dp[nmask][nstate] < dp[i][j] + add)\n                {\n                    dp[nmask][nstate] = dp[i][j] + add;\n                    pdp[nmask][nstate] = {z, j};\n                }\n            }\n        }\n    string ans = \"\";\n    int curmask = (1 << K) - 1;\n    int curstate = max_element(dp[curmask].begin(), dp[curmask].end()) - dp[curmask].begin();\n    while(curmask != 0)\n    {\n        int cc = pdp[curmask][curstate].first;\n        int ns = pdp[curmask][curstate].second;\n        ans.push_back(char('a' + cc));\n        curmask ^= (1 << cc);\n        curstate = ns;\n    }\n    cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}