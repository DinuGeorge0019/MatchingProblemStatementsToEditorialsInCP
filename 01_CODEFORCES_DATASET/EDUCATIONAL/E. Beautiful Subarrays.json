{"link": "https://codeforces.com//contest/665/problem/E", "problemId": "55555", "shortId": "665E", "contest_number": "665", "name": "E. Beautiful Subarrays", "statement": "One day, ZS the Coder wrote down an array of integers \u2009with elements .A subarray of the array  is a sequence  for some integers  such that . ZS the Coder thinks that a subarray of  is beautiful if the bitwise xor of all the elements in the subarray is at least .Help ZS the Coder find the number of beautiful subarrays of !", "input": "The first line contains two integers  and  () \u2014 the number of elements in the array  and the value of the parameter . The second line contains  integers  () \u2014 the elements of the array .", "output": "Print the only integer  \u2014 the number of beautiful subarrays of the array .", "tutorial": "The sign  is used for the binary operation for bitwise exclusive or.\nLet  be the xor of the first  elements on the prefix of . Then the interval  is beautiful if . Let's iterate over  from  to  and consider the values  as the binary strings. On each iteration we should increase the answer by the value  \u2014 the number of numbers  () so . To do that we can use the trie data structure. Let's store in the trie all the values  for . Besides the structure of the trie we should also store in each vertex the number of leaves in the subtree of that vertex (it can be easily done during adding of each binary string). To calculate the value  let's go down by the trie from the root. Let's accumulate the value  equals to the xor of the prefix of the value  with the already passed in the trie path. Let the current bit in  be equal to  and  be the depth of the current vertex in the trie. If the number  then we can increase  by the number of leaves in vertex , because all the leaves in the subtree of tha vertex correspond to the values  that for sure gives . After that we should go down in the subtree . Otherwise if  then we should simply go down to the subtree  and recalculate the value .\n", "solution": "const int N = 1200300, LOGN = 30, V = N * LOGN;\n\nint n, k;\nint a[N];\n\nbool read() {\n\tif (!(cin >> n >> k)) return false;\n\tforn(i, n) assert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\nint tsz;\nint nt[V][2];\nint cnt[V];\n\nvoid clear() {\n\tforn(i, V) {\n\t\tnt[i][0] = nt[i][1] = -1;\n\t\tcnt[i] = 0;\n\t}\n\ttsz = 1;\n}\n\nvoid add(int x) {\n\tint v = 0;\n\tcnt[v]++;\n\n\tnfor(i, LOGN) {\n\t\tint b = (x >> i) & 1;\n\t\tif (nt[v][b] == -1) {\n\t\t\tassert(tsz < V);\n\t\t\tnt[v][b] = tsz++;\n\t\t}\n\t\tv = nt[v][b];\n\t\tcnt[v]++;\n\t}\n}\n\n\nint calc(int x) {\n\tint v = 0;\n\tint ans = 0;\n\n\tauto getCnt = [](int v) { return v == -1 ? 0 : cnt[v]; };\n\n\tint cur = 0;\n\tnfor(i, LOGN) {\n\t\tif (v == -1) break;\n\t\tint b = (x >> i) & 1;\n\t\tif ((cur | (1 << i)) >= k) {\n\t\t\tans += getCnt(nt[v][b ^ 1]);\n\t\t\tv = nt[v][b];\n\t\t} else {\n\t\t\tv = nt[v][b ^ 1];\n\t\t\tcur |= (1 << i);\n\t\t}\n\t}\n\tif (cur >= k) ans += getCnt(v);\n\treturn ans;\n}\n\nvoid solve() {\n\tclear();\n\n\tadd(0);\n\n\tli ans = 0;\n\tint s = 0;\n\tforn(i, n) {\n\t\ts ^= a[i];\n\t\tli cur = calc(s);\n\t\tans += cur;\n\t\tadd(s);\n\t}\n\tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}