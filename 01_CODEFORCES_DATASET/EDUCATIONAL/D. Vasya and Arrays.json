{"link": "https://codeforces.com//contest/1036/problem/D", "problemId": "216420", "shortId": "1036D", "contest_number": "1036", "name": "D. Vasya and Arrays", "statement": "Vasya has two arrays  and  of lengths  and , respectively.He can perform the following operation arbitrary number of times (possibly zero): he takes some consecutive subsegment of the array and replaces it with a single element, equal to the sum of all elements on this subsegment. For example, from the array  Vasya can obtain array , and from array  Vasya can obtain array .Two arrays  and  are considered equal if and only if they have the same length and for each valid  .Vasya wants to perform some of these operations on array , some on array , in such a way that arrays  and  become equal. Moreover, the lengths of the resulting arrays should be maximal possible.Help Vasya to determine the maximum length of the arrays that he can achieve or output that it is impossible to make arrays  and  equal.", "input": "The first line contains a single integer  \u2014 the length of the first array. The second line contains  integers  \u2014 elements of the array . The third line contains a single integer  \u2014 the length of the second array. The fourth line contains  integers  - elements of the array .", "output": "Print a single integer \u2014 the maximum length of the resulting arrays after some operations were performed on arrays  and  in such a way that they became equal. If there is no way to make array equal, print \"\".", "tutorial": "Let's prove that next greedy solution works: each step we will find prefixes of minimal length of arrays  \u0438  such that its sums are equal and we will cut them forming next block. If we will get valid partition in result so it is an optimal solution, otherwise there is no solution. Since length of prefix proportional to its sum, so prefixes are minimal since its sums are minimal.Let's prove this algorithm: let optimal solution have alternative partition. Since our solution cuts minimal possible prefixes, so (at some step) optimal solution cuts prefix with greater sum (and greater length). But this prefixes in optimal solutions contain smaller prefixes, found by greedy solution, so it can be divided on two parts \u2014 contradiction.So we can keep prefixes and increase one which have smaller sum.Result complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300 * 1000 + 9;\n\nint n, m;\nint a[N], b[N];\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) scanf(\"%d\", a + i);\n    scanf(\"%d\", &m);\n    for(int i = 0; i < m; ++i) scanf(\"%d\", b + i);\n    \n    long long sum = 0;\n    for(int i = 0; i < n; ++i) sum += a[i];\n    for(int i = 0; i < m; ++i) sum -= b[i];\n    if(sum != 0){\n        puts(\"-1\");\n        return 0;\n    }\n    \n    int posa = 0, posb = 0;\n    int res = 0;\n    while(posa < n){\n        ++res;\n        long long suma = a[posa++], sumb = b[posb++];\n                \n        while(suma != sumb){\n            if(suma < sumb) suma += a[posa++];\n            else sumb += b[posb++];\n        }\n    }\n    \n    printf(\"%d\\n\", res);\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}