{"link": "https://codeforces.com//contest/1437/problem/D", "problemId": "775842", "shortId": "1437D", "contest_number": "1437", "name": "D. Minimal Height Tree", "statement": "Monocarp had a tree which consisted of  vertices and was rooted at vertex . He decided to study BFS (Breadth-first search), so he ran BFS on his tree, starting from the root. BFS can be described by the following pseudocode:Monocarp was fascinated by BFS so much that, in the end, he lost his tree. Fortunately, he still has a sequence of vertices, in which order vertices were visited by the BFS algorithm (the array  from the pseudocode). Monocarp knows that each vertex was visited exactly once (since they were put and taken from the queue exactly once). Also, he knows that all children of each vertex were viewed .Monocarp knows that there are many trees (in the general case) with the same visiting order , so he doesn't hope to restore his tree. Monocarp is okay with any tree that . of a tree is the maximum depth of the tree's vertices, and the depth of a vertex is the number of edges in the path from the root to it. For example, the depth of vertex  is , since it's the root, and the depth of all root's children are .Help Monocarp to find any tree with given visiting order  and minimum height.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains a single integer  ()\u00a0\u2014 the number of vertices in the tree. The second line of each test case contains  integers  (; ; )\u00a0\u2014 the order in which the vertices were visited by the BFS algorithm. It's guaranteed that the total sum of  over test cases doesn't exceed .", "output": "For each test case print the minimum possible height of a tree with the given visiting order .", "tutorial": "Due to the nature of BFS, the visiting order consists of several segments: first goes root (has depth ), then all vertices with depth , then all vertices with depth  and so on. Since any vertex of depth  is a child of vertex of depth , then it's optimal to make the number of vertices with depth  as many as possible, then make the number of vertices with depth  as many as possible and so on.Since children of a vertex are viewed in ascending order and form a segment in visiting order then an arbitrary segment of visiting order can be children of the same vertex iff elements in the segments are in ascending order.These two observations lead us to a greedy strategy: , then let's find the maximum  that segment  is in ascending order\u00a0\u2014 they will be the children of  and the only vertices of depth . Next search the maximum  such that segment  is in ascending order\u00a0\u2014 they will be the children of , and so on. It's easy to see that this strategy maximizes the number of vertices of each depth level, so minimize the height of the tree.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nint n;\nvector<int> a;\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\ta.resize(n);\n\tfore (i, 0, n)\n\t\tcin >> a[i];\n\treturn true;\n}\n\ninline void solve() {\n\tvector<int> h(n, INF);\n\th[0] = 0;\n\tint lst = 0;\n\tfore (i, 1, n) {\n\t\tif (i - 1 > 0 && a[i - 1] > a[i])\n\t\t\tlst++;\n\t\th[i] = h[lst] + 1;\n\t}\n\tcout << h[n - 1] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tint tc; cin >> tc;\n\twhile(tc--) {\n\t\tread();\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}