{"link": "https://codeforces.com//contest/961/problem/G", "problemId": "171418", "shortId": "961G", "contest_number": "961", "name": "G. Partitions", "statement": "You are given a set of  elements indexed from  to . The weight of -th element is . The weight of some subset of a given set is denoted as . The weight of some partition  of a given set into  subsets is  (recall that a partition of a given set is a set of its subsets such that every element of the given set belongs to exactly one subset in partition).Calculate the sum of weights of all partitions of a given set into exactly   subsets, and print it modulo . Two partitions are considered different iff there exist two elements  and  such that they belong to the same set in one of the partitions, and to different sets in another partition.", "input": "The first line contains two integers  and  () \u2014 the number of elements and the number of subsets in each partition, respectively. The second line contains  integers  ()\u2014 weights of elements of the set.", "output": "Print one integer \u2014 the sum of weights of all partitions of a given set into   subsets, taken modulo .", "tutorial": "Let's look at some facts. At first, the answer is the sum of weights  taken with some coefficients . So, it's enough to calculate those coefficients.Then  can be calculated by iterating on the size of the subset containing -th element: , where  is the number of partitions of set with  elements into  nonempty subsets with one subset of fixed size  where  belongs.This solution is still quite slow, so the next fact is: if two elements  and  belong to the same subset, then  \"increases\" the coefficient before . So for each element  we can iterate over all elements  which will lie in one subset with . In other words, .  is the number of ways to divide set with  elements into  subsets in such a way that elements  and  wil lie in one subset. can be calculated using Stirling numbers of the second kind: let  be the number of partitions of set with  elements into  non-empty subsets. If  then , else we just merge  and  into one element and let .Final formula is . And the answer is .Counting Stirling numbers can be done with inclusion-exclusion principle or by searching Wiki: .Resulting complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define forn(i, n) fore(i, 0, n)\n\nconst int MOD = int(1e9) + 7;\n\ninline int norm(int a) {\n\twhile(a >= MOD)\n\t\ta -= MOD;\n\twhile(a < 0)\n\t\ta += MOD;\n\treturn a;\n}\n\ninline int mul(int a, int b) {\n\treturn int((a * 1ll * b) % MOD);\n}\n\ninline int binPow(int a, int k) {\n\tint ans = 1;\n\twhile(k > 0) {\n\t\tif(k & 1) ans = mul(ans, a);\n\t\ta = mul(a, a);\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nconst int N = 200 * 1000 + 555;\n\nint f[N], inf[N];\n\nvoid precalc() {\n\tf[0] = inf[0] = 1;\n\tfore(i, 1, N) {\n\t\tf[i] = mul(f[i - 1], i);\n\t\tinf[i] = mul(inf[i - 1], binPow(i, MOD - 2));\n\t}\n}\n\nint n, k, w[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tforn(i, n)\n\t\tcin >> w[i];\n\treturn true;\n}\n\ninline int c(int n, int k) {\n\tif(k > n || n < 0) return 0;\n\tif(k == 0 || n == k) return 1;\n\t\n\treturn mul(f[n], mul(inf[n - k], inf[k]));\n}\n\ninline int s(int n, int k) {\n\tif(n == 0) return k == 0;\n\tif(k == 0) return n == 0;\n\t\n\tint ans = 0, sg[2] = {1, MOD - 1};\n\tforn(cnt, k)\n\t\tans = norm(ans + mul(sg[cnt & 1], mul(c(k, cnt), binPow(k - cnt, n))));\n\treturn mul(ans, inf[k]);\n}\n\ninline void solve() {\n\tint sum = 0;\n\tforn(i, n)\n\t\tsum = norm(sum + w[i]);\n\t\t\n\tint s0 = s(n, k);\n\tint s1 = mul(n - 1, s(n - 1, k));\n\t\n\tcout << mul(sum, norm(s0 + s1)) << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tprecalc();\n\t\n\tassert(read());\n\tsolve();\n\n#ifdef _DEBUG\n\tcerr << \"TIME = \" << clock() << endl;\n#endif\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}