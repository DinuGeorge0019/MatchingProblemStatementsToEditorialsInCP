{"link": "https://codeforces.com//contest/1288/problem/E", "problemId": "516091", "shortId": "1288E", "contest_number": "1288", "name": "E. Messenger Simulator", "statement": "Polycarp is a frequent user of the very popular messenger. He's chatting with his friends all the time. He has  friends, numbered from  to .Recall that a permutation of size  is an array of size  such that each integer from  to  occurs exactly once in this array.So his recent chat list can be represented with a permutation  of size .  is the most recent friend Polycarp talked to,  is the second most recent and so on.Initially, Polycarp's recent chat list  looks like  (in other words, it is an identity permutation).After that he receives  messages, the -th message comes from the friend . And that causes friend  to move to the first position in a permutation, shifting everyone between the first position and the current position of  by . Note that if the friend  is in the first position already then nothing happens.For example, let the recent chat list be :   if he gets messaged by friend , then  becomes ;  if he gets messaged by friend , then  doesn't change ;  if he gets messaged by friend , then  becomes . For each friend consider all position he has been at in the beginning and after receiving each message. Polycarp wants to know what were the minimum and the maximum positions.", "input": "The first line contains two integers  and  () \u2014 the number of Polycarp's friends and the number of received messages, respectively. The second line contains  integers  () \u2014 the descriptions of the received messages.", "output": "Print  pairs of integers. For each friend output the minimum and the maximum positions he has been in the beginning and after receiving each message.", "tutorial": "So I have two slightly different approaches to the problem. There is a straightforward (no brain) one and a bit smarter one.The minimum place is the same in both solutions. For the -th friend it's just  if he never moves and  otherwise.Obtaining the maximum place is trickier.For the first approach, take a look what happens with some friend  after he gets moved to the first position. Or what's more useful \u2014 what happens after he gets moved to the first position and before he gets moved again afterwards (or the queries end). Notice how every other friend is to the right of him initially. Thus, if anyone sends a message, then the position of the friend  increases by one. However, if that friend moves again, nothing changes. That should remind of a well-known problem already. You are just required to count the number of distinct values on some segments. The constraints allow you to do whatever you want: segtree with vectors in nodes, Mo, persistent segtree (I hope ML is not too tight for that).Unfortunately, for each friend we have missed the part before his first move. In that case for each  you need to count the number of distinct values greater than , as only friends with greater index will matter. Luckily, you can do it in a single BIT. Let -th its value be set to zero if the friend  hasn't sent messages and one otherwise. Let's process messages from left to right. If the friend sends a message for the first time, then update the BIT with  in his index and update his answer with the suffix sum of values greater than his index.Finally, there are also friends, who haven't sent messages at all. As we have built the BIT already, the only thing left is to iterate over these friends and update the answers for them with a suffix sum.Overall complexity: //. The attached solutions are  and .The second solution requires a small observation to be made. Notice that for each friend you can only check his position right before his moves and at the end of the messages. That works because the position can decrease only by his move, so it's either increases or stays the same between the moves.So let's learn to simulate the process quickly. The process we are given requires us to move someone to the first position and then shift some friends. Let's not shift! And let's also reverse the list, it's more convenient to append instead of prepending. So initially the list is  and the message moves a friend to the end of the list.Allocate  positions in a BIT, for example. Initially the first  positions are taken, the rest  are free (mark them with ones and zeroes, respectively). For each friend his position in this BIT is known (initially they are , because we reversed the list). On the -th message sent count the number of taken positions to the right of , set  in , update  and set  in .And don't forget to update each friend's maximum after all the messages are sent, that is the number of taken positions to the right of his final one as well.Overall complexity .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define x first \n#define y second\n\nusing namespace std;\n\nconst int N = 300 * 1000 + 13;\nconst int P = 550;\n\ntypedef pair<int, int> pt;\n\nint n;\nint a[N];\nvector<int> pos[N];\npt ans[N];\n\nint cnt[N];\nint tot;\n\nvoid add(int x){\n\t++cnt[x];\n\tif (cnt[x] == 1) ++tot;\n}\n\nvoid rem(int x){\n\tif (cnt[x] == 1) --tot;\n\t--cnt[x];\n}\n\nint f[N];\n\nvoid upd(int x){\n\tfor (int i = x; i >= 0; i = (i & (i + 1)) - 1)\n\t\t++f[i];\n}\n\nint get(int x){\n\tint res = 0;\n\tfor (int i = x; i < N; i |= i + 1)\n\t\tres += f[i];\n\treturn res;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tforn(i, m){\n\t\tscanf(\"%d\", &a[i]);\n\t\t--a[i];\n\t}\n\tforn(i, m){\n\t\tpos[a[i]].push_back(i);\n\t}\n\t\n\tvector<pt> qr;\n\tforn(i, n){\n\t\tfor (int j = 1; j < int(pos[i].size()); ++j)\n\t\t\tqr.push_back(make_pair(pos[i][j - 1] + 1, pos[i][j] - 1));\n\t\tif (!pos[i].empty())\n\t\t\tqr.push_back(make_pair(pos[i].back() + 1, m - 1));\n\t}\n\t\n\tsort(qr.begin(), qr.end(), [](const pt &a, const pt &b){\n\t\tif (a.x / P != b.x / P)\n\t\t\treturn a.x < b.x;\n\t\tif ((a.x / P) & 1)\n\t\t\treturn a.y < b.y;\n\t\treturn a.y > b.y;\n\t});\n\t\n\tforn(i, n) ans[i] = {i, i};\n\tforn(i, m) ans[a[i]].x = 0;\n\t\n\tint L = 0, R = -1;\n\tforn(i, qr.size()){\n\t\tint l = qr[i].x;\n\t\tint r = qr[i].y;\n\t\tif (r < l) continue;\n\t\t\n\t\tint x = a[qr[i].x - 1];\n\t\twhile (L < l) rem(a[L++]);\n\t\twhile (L > l) add(a[--L]);\n\t\twhile (R > r) rem(a[R--]);\n\t\twhile (R < r) add(a[++R]);\n\t\t\n\t\tans[x].y = max(ans[x].y, tot);\n\t}\n\tforn(i, m){\n\t\tif (i == pos[a[i]][0]){\n\t\t\tans[a[i]].y = max(ans[a[i]].y, a[i] + get(a[i]));\n\t\t\tupd(a[i]);\n\t\t}\n\t}\n\tforn(i, n) if (pos[i].empty()){\n\t\tans[i].y = max(ans[i].y, i + get(i));\n\t}\n\t\n\tforn(i, n) printf(\"%d %d\\n\", ans[i].x + 1, ans[i].y + 1);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}