{"link": "https://codeforces.com//contest/825/problem/C", "problemId": "114546", "shortId": "825C", "contest_number": "825", "name": "C. Multi-judge Solving", "statement": "Makes solves problems on Decoforces and lots of other different online judges. Each problem is denoted by its difficulty \u2014 a positive integer number. Difficulties are measured the same across all the judges (the problem with difficulty  on Decoforces is as hard as the problem with difficulty  on any other judge). Makes has chosen  problems to solve on Decoforces with difficulties . He can solve these problems in arbitrary order. Though he can solve problem  with difficulty  only if he had already solved some problem with difficulty  (no matter on what online judge was it).With given conditions it's easy to see that Makes sometimes can't solve all the chosen problems, no matter what order he chooses. So he wants to solve some problems on other judges to finish solving problems from his list. Makes can solve problems on any judge at any time, it isn't necessary to do problems from the chosen list one right after another.Makes doesn't have too much free time, so he asked you to calculate the minimum number of problems he should solve on other judges in order to solve all the chosen problems from Decoforces.", "input": "The first line contains two integer numbers ,  (, ). The second line contains  space-separated integer numbers  ().", "output": "Print minimum number of problems Makes should solve on other judges in order to solve all chosen problems on Decoforces.", "tutorial": "Obviously sorting the tasks by difficulty will always produce the most optimal order of solving. In that case ability to solve some task  will mean ability to solve any task from  to .Now let's maintain the upper limit of difficulty of problem Makes is able to solve. Right after solving some problem  it will be . Initially it's just .Transition from  to  will then look like this. If the upper limit it greater or equal to  then we solve this problem and update the upper limit. Otherwise we will need some problems from other judges. As our goal is to maximize the upper limit, the most optimal task to solve is the hardest possible. So you should solve task with the difficulty of upper limit and update the limit itself. Keep doing it until upper limit becomes grater or equal to .You will require no more then  tasks from the other judges. By algorithm it's easy to see that by solving task with difficulty  we update upper limit with the value . This function produces such a estimate.Overall complexity: .", "solution": "#ifdef __GNUC__\n#pragma GCC target(\"sse4,avx\")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nvoid run(std::istream &in, std::ostream &out) {\n    int n; uint32_t k;\n    in >> n >> k;\n    std::vector<uint32_t> as(n);\n    for (int i = 0; i < n; i++) {\n        in >> as[i];\n    }\n    std::sort(as.begin(), as.end());\n    uint32_t cur = 2 * k;\n    int res = 0;\n    for (uint32_t v : as) {\n        while (v > cur) {\n            res++;\n            cur = cur * 2;\n        }\n        cur = std::max(cur, 2 * v);\n    }\n    out << res << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}