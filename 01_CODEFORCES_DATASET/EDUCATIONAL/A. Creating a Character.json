{"link": "https://codeforces.com//contest/1217/problem/A", "problemId": "404643", "shortId": "1217A", "contest_number": "1217", "name": "A. Creating a Character", "statement": "You play your favourite game yet another time. You chose the character you didn't play before. It has  points of strength and  points of intelligence. Also, at start, the character has  free experience points you can invest either in strength or in intelligence (by investing one point you can either raise strength by  or raise intelligence by ).Since you'd like to make some fun you want to create a jock character, so it has more strength than intelligence points (resulting strength is  than the resulting intelligence).Calculate the number of different character builds you can create (for the purpose of replayability) if you must . Two character builds are different if their strength and/or intellect are different.", "input": "The first line contains the single integer  () \u2014 the number of queries. Next  lines contain descriptions of queries \u2014 one per line. This line contains three integers ,  and  (, ) \u2014 the initial strength and intelligence of the character and the number of free points, respectively.", "output": "Print  integers \u2014 one per query. For each query print the number of different character builds you can create.", "tutorial": "Let  and  be number of free points that we invest in the strength and intelligence respectively. It's obvious that  since we must spend all free points. From the other side we must make .Now we can expess  and put it in the inequality:    Since  must be non negative we can get We can use or write the correct ceiling function that works with negative numerator or use one hack and magic and get  with usual integer division. Let's denote this value as .Since all integer values  from  are good for us, so the number of pairs is equal to .P.S.: Let me explain how to prove that  is equal to . P.P.S.: Interesting fact: the formula above works for all positive  and  thats why it works in our case even though  can be negative.", "solution": "fun main() {\n    val t = readLine()!!.toInt()\n    for (ct in 1..t) {\n        val (str, int, exp) = readLine()!!.split(' ').map { it.toInt() }\n        val minAddStr = maxOf(0, (exp + int - str + 2) / 2)\n        println(maxOf(exp - minAddStr + 1, 0))\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}