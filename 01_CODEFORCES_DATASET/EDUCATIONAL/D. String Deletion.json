{"link": "https://codeforces.com//contest/1430/problem/D", "problemId": "755156", "shortId": "1430D", "contest_number": "1430", "name": "D. String Deletion", "statement": "You have a string  consisting of  characters. Each character is either  or .You can perform operations on the string. Each operation consists of two steps:  select an integer  from  to the length of the string , then delete the character  (the string length gets reduced by , the indices of characters to the right of the deleted one also get reduced by );  if the string  is not empty, delete the maximum length prefix consisting of the same characters (the indices of the remaining characters and the string length get reduced by the length of the deleted prefix). Note that both steps are mandatory in each operation, and their order cannot be changed.For example, if you have a string  , the first operation can be one of the following:  select : we'll get     ;  select : we'll get     ;  select : we'll get     ;  select : we'll get     ;  select : we'll get     ;  select : we'll get     . You finish performing operations when the string  becomes empty. What is the maximum number of operations you can perform?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains a single integer  ()\u00a0\u2014 the length of the string . The second line contains string  of  characters. Each character is either  or . It's guaranteed that the total sum of  over test cases doesn't exceed .", "output": "For each test case, print a single integer\u00a0\u2014 the maximum number of operations you can perform.", "tutorial": "Suppose the string consists of  characters, and each character is different from the adjacent ones (so the string looks like  or ). It's easy to see that we can't make more than  operations (each operation deletes at least two characters, except for the case when the string consists of only one character). And there is an easy way to perform exactly  operations: always choose the last character and delete it.Okay, what about the case when some adjacent characters in the string are equal? It's never optimal to delete a character that's different from both adjacent characters: since the second part of each operation always deletes the left block of equal characters, this action merges two blocks, so they will be deleted in one second part of the operation (which decreases the total number of operations).So, we should always delete a character from a block with at least two equal characters. From which of the blocks, if there are more than one? It's easy to see that we should choose a character from the leftmost such block, since that block is the earliest to be deleted (and if we want to make the same action later, we might be unable to do it).So, the solution is greedy: during each action, we have to find the leftmost block consisting of at least  equal characters, and delete a character from it (or the last character of the string, if there are no such blocks). Since the length of the string is up to  and the number of operations is up to , we should do it efficiently, for example, by storing the eligible blocks in some data structure.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nchar buf[200043];\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor(int tc = 1; tc <= t; tc++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%s\", buf);\n\t\tstring s = buf;\n\t\tqueue<int> q;\n\t\tint cur = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t \tif(i > 0 && s[i] != s[i - 1])\n\t\t \t\tcur++;\n\t\t \tif(i > 0 && s[i] == s[i - 1])\n\t\t \t\tq.push(cur);\n\t\t}\n\t\tint deleted = 0;       \n\t\tint score = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif(q.empty())\n\t\t\t\tbreak;\n\t\t\tq.pop();\n\t\t\tdeleted++;\n\t\t\tscore++;\n\t\t\twhile(!q.empty() && q.front() == i)\n\t\t\t{\n\t\t\t\tq.pop();\n\t\t\t\tdeleted++; \t\n\t\t\t}\n\t\t\tdeleted++;\n\t\t\t//cerr << deleted << endl;\n\t\t}\n\t\tscore += (n - deleted + 1) / 2;\n\t\tprintf(\"%d\\n\", score);\n\t}\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}