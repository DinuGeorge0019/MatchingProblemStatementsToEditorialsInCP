{"link": "https://codeforces.com//contest/1697/problem/E", "problemId": "1427644", "shortId": "1697E", "contest_number": "1697", "name": "E. Coloring", "statement": "You are given  points on the plane, the coordinates of the -th point are . No two points have the same coordinates.The distance between points  and  is defined as .For each point, you have to choose a color, represented by an integer from  to . For every ordered triple of different points , the following constraints should be met:  if ,  and  have the same color, then ;  if  and  have the same color, and the color of  is different from the color of , then  and . Calculate the number of different ways to choose the colors that meet these constraints.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of points. Then  lines follow. The -th of them contains two integers  and  (). No two points have the same coordinates (i.\u2009e. if , then either  or ).", "output": "Print one integer\u00a0\u2014 the number of ways to choose the colors for the points. Since it can be large, print it modulo .", "tutorial": "Let's call a point   if its color does not match the color of any other point. If a point is not isolated, then it has the same color as the points with minimum distance to it (and only these points should have this color).Let's build a directed graph where the arc  means that the point  is one of the closest to the point  (i.\u2009e. ). If there is a path from the vertex  to the vertex , it means that if the vertex  is not isolated, the vertex  should have the same color as vertex .Suppose the set of vertices reachable from  (including  itself) is . Finding  is easy \u2014 just run DFS from the vertex . Let's analyze two cases:  there exists a pair of vertices  such that , , and there is no arc from  to ;  for every pair of vertices  such that  and , there is an arc . Why do we need to analyze these two cases? In the first case, the vertex   be isolated, because painting it and some other vertex into the same color means that every vertex from  will have this color, and it will break the condition in the statement. In the second case, the vertex  may be isolated, or it may have the same color as all vertices in  \u2014 and if it is isolated, then the whole set  should consist of isolated vertices.Let's find all such set of vertices that meet the second case. Each vertex will belong to at most one of these sets; if it doesn't belong to any, it must be isolated, otherwise either the whole its set consists of isolated vertices, or the whole set has the same color. So, for each set, we either use  color or  colors. This allows us to implement a knapsack-like dynamic programming: let  be the number of ways to paint  first sets into  colors, such that the colors are not ordered. After running this dynamic programming, we can get the answer by simple combinatorics: iterate on the number of colors we use in these sets in total, multiply the dynamic programming for it by the (ordered) number of ways to choose these colors from , and then by the number of ways to choose the colors for points that must be isolated.This dynamic programming can even be implemented a bit easier if we treat every vertex that must be isolated as a set of size , and this is the way it's written in the model solution.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 143;\nconst int K = 5;\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    return x;   \n}\n\nint mul(int x, int y)\n{\n    return (x * 1ll * y) % MOD;\n}\n\nint binpow(int x, int y)\n{\n    int z = 1;\n    while(y > 0)\n    {\n        if(y % 2 == 1) z = mul(z, x);\n        x = mul(x, x);\n        y /= 2;\n    }\n    return z;\n}\n\nint fact[N];\nint rfact[N];\n\nint A(int n, int k)\n{\n    return mul(fact[n], rfact[n - k]);\n}\n\nint n;\n\nvector<int> g[N];\nint x[N];\nint y[N];\nint dist[N][N];\nint color[N];\nint dp[N][N];\n\nint cc = 0;\nset<int> pts;\nvector<int> compsize;\n\nvoid dfs1(int i)\n{\n    //cerr << i << endl;\n    if(pts.count(i) == 1) return;\n    pts.insert(i);\n    for(auto v : g[i])\n    {\n        dfs1(v);\n    }\n}\n\nvoid dfs2(int i, int c)\n{\n    if(color[i] == c) return;\n    color[i] = c;\n    for(auto v : g[i])\n        dfs2(v, c);\n}\n\nint main()\n{\n    fact[0] = 1;\n    for(int i = 1; i < N; i++)\n        fact[i] = mul(i, fact[i - 1]);\n    for(int i = 0; i < N; i++)\n        rfact[i] = binpow(fact[i], MOD - 2);\n\n\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%d %d\", &x[i], &y[i]);    \n    }\n    for(int i = 0; i < n; i++)\n    {\n        dist[i][i] = int(1e9);\n        for(int j = 0; j < n; j++)\n            if(i != j)\n                dist[i][j] = abs(x[i] - x[j]) + abs(y[i] - y[j]);\n    }\n    for(int i = 0; i < n; i++)\n    {\n        int d = *min_element(dist[i], dist[i] + n);\n        for(int j = 0; j < n; j++)\n            if(dist[i][j] == d) g[i].push_back(j);    \n    }\n\n    for(int i = 0; i < n; i++)\n    {\n        if(color[i] != 0) continue;\n        cc++;\n        pts.clear();\n        dfs1(i);\n        //cerr << \"!\" << endl; \n        int d = *min_element(dist[i], dist[i] + n);                      \n        set<int> pts2 = pts;\n        bool bad = false;\n        for(auto x : pts)\n            for(auto y : pts2)\n                if(x != y && dist[x][y] != d)\n                    bad = true;\n        if(bad)           \n        {\n            color[i] = cc;\n            compsize.push_back(1);\n        }\n        else\n        {\n            dfs2(i, cc);\n            compsize.push_back(pts.size());\n        }\n    }            \n\n    dp[0][0] = 1;\n    int m = compsize.size();\n    for(int i = 0; i < m; i++)\n        for(int j = 0; j < n; j++)\n        {\n            if(dp[i][j] == 0) continue;\n            dp[i + 1][j + 1] = add(dp[i + 1][j + 1], dp[i][j]);\n            if(compsize[i] != 1)\n            {\n                dp[i + 1][j + compsize[i]] = add(dp[i + 1][j + compsize[i]], dp[i][j]);\n            }\n        }\n    int ans = 0;\n    for(int i = 1; i <= n; i++)\n        ans = add(ans, mul(dp[m][i], A(n, i)));\n    cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}