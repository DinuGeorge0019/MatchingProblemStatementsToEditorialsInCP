{"link": "https://codeforces.com//contest/1051/problem/C", "problemId": "222359", "shortId": "1051C", "contest_number": "1051", "name": "C. Vasya and Multisets", "statement": "Vasya has a multiset  consisting of  integer numbers. Vasya calls some number  nice if it appears in the multiset exactly once. For example, multiset  contains nice numbers  and .Vasya wants to split multiset  into two multisets  and   in such a way that the quantity of nice numbers in multiset  would be the same as the quantity of nice numbers in multiset  (the quantity of numbers to appear exactly once in multiset  and the quantity of numbers to appear exactly once in multiset ).", "input": "The first line contains a single integer . The second line contains  integers  \u2014 the multiset .", "output": "If there exists no split of  to satisfy the given requirements, then print \"\" in the first line. Otherwise print \"\" in the first line. The second line should contain a string, consisting of  characters. -th character should be equal to '' if the -th element of multiset  goes to multiset  and '' if if the -th element of multiset  goes to multiset .  If there exist multiple solutions, then print any of them.", "tutorial": "Write down all the numbers, which appear exactly once, let there be  of them. If  is even, put the first  of them into the first multiset and put the other  into the second multiset. All the other numbers (which appear more than once) also go into the first multiset. The only nice numbers will be the initial , thus the answer is valid.If  is odd and there is no number to appear more than twice, then the answer is \"\", as all the numbers to appear exactly twice don't change the difference of the amounts of the nice numbers at all. If there is a number to appear more than twice (let it be ), then let's firstly add  of the numbers to appear exactly once to the first multiset, add  others of them to the second multiset. Then the first occurrence of  goes to the second multiset and all the other numbers go to the first multiset. It's easy to notice that multisets will contain equal number of the nice numbers after all the partitioning.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 109;\n\nint n;\nint a[N];\nmap<int, int> m;\nset <int> s[2];\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> a[i];\n\t\tm[a[i]]++;\n\t}\n\n\tint pos = 0;\n\tfor(auto p : m)\n\t\tif(p.second == 1){\n\t\t\ts[pos].insert(p.first);\n\t\t\tpos = 1 - pos;\n\t\t}\n\t\t\n\tif(s[0].size() == s[1].size()){\n\t\tstring res(n, 'A');\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(s[1].count(a[i]))\n\t\t\t\tres[i] = 'B';\n\t\t\n\t\tcout << \"YES\" << endl;\n\t\tfor(auto c : res) cout << c;\n\t\tcout << endl;\n\t\treturn 0;\n\t}\n\telse{\n\t\tassert(int(s[0].size()) - 1 == int(s[1].size()));\n\t\tstring res(n, 'A');\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(s[1].count(a[i]))\n\t\t\t\tres[i] = 'B';\n\t\t\n\t\tint id = -1;\n\t\tfor(auto p : m)\n\t\t\tif(p.second >= 3){\n\t\t\t\tid = p.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\tif(id == -1){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tbool flag = false;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(a[i] == id)\n\t\t\t\tif(!flag){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tres[i] = 'B';\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tcout << \"YES\" << endl;\n\t\tfor(auto c : res) cout << c;\n\t\tcout << endl;\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n                             \t", "interactive": false, "noSolution": false, "noTutorial": false}