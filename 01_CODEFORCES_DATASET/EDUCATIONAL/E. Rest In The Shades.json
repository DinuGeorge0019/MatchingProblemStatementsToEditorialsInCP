{"link": "https://codeforces.com//contest/1016/problem/E", "problemId": "204440", "shortId": "1016E", "contest_number": "1016", "name": "E. Rest In The Shades", "statement": "There is a light source on the plane. This source is so small that it can be represented as point. The light source is moving from point  to the   with speed equal to  unit per second. The trajectory of this light source is a straight segment connecting these two points. There is also a fence on  axis represented as  segments  (so the actual coordinates of endpoints of each segment are  and ). The point  is  if segment connecting  and the current position of the light source intersects or touches with any segment of the fence.  You are given  points. For each point calculate total time of this point being in the shade, while the light source is moving from  to the .", "input": "First line contains three space separated integers ,  and  (, ) \u2014 corresponding coordinates of the light source. Second line contains single integer  () \u2014 number of segments in the fence. Next  lines contain two integers per line:  and  (, ) \u2014 segments in the fence in increasing order. Segments don't intersect or touch each other. Next line contains single integer  () \u2014 number of points to check. Next  lines contain two integers per line:  and  () \u2014 points to process.", "output": "Print  lines. The -th line should contain one real number \u2014 total time of the -th point being in the shade, while the light source is moving from  to the . The answer is considered as correct if its absolute of relative error doesn't exceed .", "tutorial": "Let's calculate the answer for a fixed point . If you project with respect of  each segment of the fence to the line containing light source you can see that the answer is the length of intersection of fence projection with segment  of the trajectory light source.  Key idea is the fact that the length of each fence segment is multiplied by the same coefficient .On the other hand, fence segments whose projections lie inside  form a subsegment in the array of segments, so its total length can be obtained with partial sums. And at most two fence segment are included in the answer partially, their positions can be calculated with lower_bound if you project points  and  on  axis. So now you can answer the query with  time (and quite small hidden constant) and resulting complexity is .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<li, li> pt;\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst double EPS = 1e-9;\n\nconst int N = 200 * 1000 + 555;\n\nli sy, a, b;\nint n, q;\npt s[N], p[N];\n\ninline bool read() {\n\tif(!(cin >> sy >> a >> b))\n\t\treturn false;\n\tassert(cin >> n);\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%lld%lld\", &s[i].x, &s[i].y) == 2);\n\tassert(cin >> q);\n\tfore(i, 0, q)\n\t\tassert(scanf(\"%lld%lld\", &p[i].x, &p[i].y) == 2);\n\treturn true;\n}\n\nint getGE(ld x) {\n\tfor(int pos = max(int(lower_bound(s, s + n, pt(li(x), -1)) - s) - 2, 0); pos < n; pos++)\n\t\tif(x <= s[pos].x)\n\t\t\treturn pos;\n\treturn n;\n}\n\nli ps[N];\n\nli getSum(int l, int r) {\n\tli ans = r > 0 ? ps[r - 1] : 0;\n\tans -= l > 0 ? ps[l - 1] : 0;\n\treturn ans;\n}\n\ninline void solve() {\n\tfore(i, 0, n) {\n\t\tps[i] = s[i].y - s[i].x;\n\t\tif(i > 0)\n\t\t\tps[i] += ps[i - 1];\n\t}\n\t\n\tfore(i, 0, q) {\n\t\tld lx = p[i].x + (a - p[i].x) * (ld(p[i].y) / (p[i].y - sy));\n\t\tld rx = p[i].x + (b - p[i].x) * (ld(p[i].y) / (p[i].y - sy));\n\t\t\n\t\tint posL = getGE(lx);\n\t\tint posR = getGE(rx) - 1;\n\t\t\n\t\tld sum = getSum(posL, posR);\n\t\tif(posL > 0)\n\t\t\tsum += max(ld(0.0), s[posL - 1].y - max((ld)s[posL - 1].x, lx));\n\t\tif(posR >= 0)\n\t\t\tsum += max(ld(0.0), min((ld)s[posR].y, rx) - s[posR].x);\n\t\t\n\t\tsum *= ld(p[i].y - sy) / p[i].y;\n\t\tprintf(\"%.15f\\n\", double(sum));\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}