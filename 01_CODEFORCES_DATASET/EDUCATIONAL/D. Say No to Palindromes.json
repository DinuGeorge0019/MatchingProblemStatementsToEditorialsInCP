{"link": "https://codeforces.com//contest/1555/problem/D", "problemId": "1062143", "shortId": "1555D", "contest_number": "1555", "name": "D. Say No to Palindromes", "statement": "Let's call the string  if it does not contain a substring of length at least , which is a palindrome. Recall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first. For example, the strings , , ,  are palindromes, but the strings , ,  are not.Let's define  of a string as the minimum number of operations so that the string becomes beautiful, if in one operation it is allowed to change any character of the string to one of the first  letters of the Latin alphabet (in lowercase).You are given a string  of length , each character of the string is one of the first  letters of the Latin alphabet (in lowercase).You have to answer  queries\u00a0\u2014 calculate the cost of the substring of the string  from -th to -th position, inclusive.", "input": "The first line contains two integers  and  ()\u00a0\u2014 the length of the string  and the number of queries. The second line contains the string , it consists of  characters, each character one of the first  Latin letters. The following  lines contain two integers  and  ()\u00a0\u2014 parameters of the -th query.", "output": "For each query, print a single integer\u00a0\u2014 the cost of the substring of the string  from -th to -th position, inclusive.", "tutorial": "Note that in the beautiful string $$$s_i \\neq s_{i-1}$$$ (because it is a palindrome of length $$$2$$$) and $$$s_i \\neq s_{i-2}$$$ (because it is a palindrome of length $$$3$$$). This means $$$s_i = s_{i-3}$$$, i.e. a beautiful string has the form , up to the permutation of the letters ,  and .For each permutation of the letters ,  and , we will construct a string $$$t$$$, of the form  of length $$$n$$$. Let's define an array $$$a$$$ of length $$$n$$$ as follows: $$$a_i = 0$$$ if $$$s_i = t_i$$$ (i.e. the character at the $$$i$$$-th position does not need to be changed) and $$$a_i = 1$$$ otherwise. Let's build an array $$$pr$$$ of prefix sums of the array $$$a$$$. Now you can process a query of the number of positions that need to be replaced for the current line $$$t$$$ in $$$O(1)$$$.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL); \n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n  vector<vector<int>> pr(6, vector<int>(n + 1));\n  string t = \"abc\";\n  int cur = 0;\n  do {\n    for (int i = 0; i < n; ++i)\n      pr[cur][i + 1] = pr[cur][i] + (s[i] != t[i % 3]);\n    ++cur;\n  } while (next_permutation(t.begin(), t.end()));\n  while (m--) {\n    int l, r;\n    cin >> l >> r;\n    int ans = n;\n    for (int i = 0; i < 6; ++i)\n      ans = min(ans, pr[i][r] - pr[i][l - 1]);\n    cout << ans << \"\\n\";\n  }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}