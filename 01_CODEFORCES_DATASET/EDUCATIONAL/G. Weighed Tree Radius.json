{"link": "https://codeforces.com//contest/1783/problem/G", "problemId": "1728816", "shortId": "1783G", "contest_number": "1783", "name": "G. Weighed Tree Radius", "statement": "You are given a tree of  vertices and  edges. The -th vertex has an initial weight .Let the   from vertex  to vertex  be the number of edges on the path from  to . Note that  and .Let the  distance  from  to  be . Note that  and  if .Analogically to usual distance, let's define the   of vertex  as the greatest weighted distance from  to any other vertex (including  itself), or .Finally, let's define the   of the tree as the minimum eccentricity of any vertex, or .You need to perform  queries of the following form:    \u00a0\u2014 assign . After performing each query, print the radius  of the current tree.", "input": "The first line contains the single integer  ()\u00a0\u2014 the number of vertices in the tree. The second line contains  integers  ()\u00a0\u2014 the initial weights of vertices. Next  lines contain edges of tree. The -th line contains two integers  and  (; )\u00a0\u2014 the corresponding edge. The given edges form a tree. The next line contains the single integer  ()\u00a0\u2014 the number of queries. Next  lines contain queries\u00a0\u2014 one query per line. The -th query contains two integers  and  (; )\u00a0\u2014 a vertex and it's new weight.", "output": "Print  integers\u00a0\u2014 the radius  of the tree after performing each query.", "tutorial": "Firstly, let's define the weight of path  as . On contrary to weighted distances,  and also .Now, let's define the diameter of a tree as path  with maximum . It's okay if diameter may be explicit case . The useful part of such definition is next: our diameter still holds most properties of the usual diameter. Let's look at two of them:   There is a vertex on diameter path  with  and . It's easy to prove after noting the fact that  and  (otherwise, you could choose diameter  or ).  For any vertex  eccentricity . In other words, either  or  has the maximum distance from . (You can also prove it by contradiction). It also means that .  The two properties above give us an easy way to calculate the radius: just maintain diameter , and the answer is a half of it.Now let's look how the diameter changes when we change the weight . If   it's quite easy. The only paths that change weights are the paths ending at . Denote such path as  and note that either  or   . In other words, there will be only three candidates for a new diameter:   path  with ;  path  with ;  path  with . The only thing you need to calculate fast enough is the two distances  and . And since , your task is to calculate .Finally, how to handle decreasing 's? Let's get rid of them using DCP (dynamic connectivity problem) technique. Keep track of each value : each possible value  for some vertex  will be \"active\" on some segment of queries . Since there are only  queries, there will be exactly  such segments for all vertices  in total.Now, all queries becomes \"assign  on some segment of queries \". Note that in that case, the previous value of  was , so you are dealing with only \"increasing value\" queries.Finally, to handle all range queries efficiently, you build a Segment Tree on queries, set all queries and then traverse your Segment Tree while maintaining the current diameter in order to calculate answers for all queries.Each of  queries transforms in  queries to segment tree vertices, and preforming each query asks you to calculate  two times.If you use the usual binary lifting, then your complexity becomes  what is okay. But if you use Sparse Table on Euler tour, you can take  in  and your complexity will be .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \" \";\n\t\tout << v[i];\n\t}\n\treturn out;\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9;\n\nconst int LOG = 18;\nconst int N = int(2e5) + 55;\n\nint n;\nvector<int> a;\nvector<int> g[N];\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\ta.resize(n);\n\tfore (i, 0, n)\n\t\tcin >> a[i];\n\tfore (i, 0, n - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nint p[LOG][N];\nint h[N], tin[N], tout[N], T = 0;\n\nvoid precalcLca(int v, int pr) {\n\ttin[v] = T++;\n\th[v] = 0;\n\tif (pr != v)\n\t\th[v] = h[pr] + 1;\n\tp[0][v] = pr;\n\tfore (pw, 0, LOG - 1)\n\t\tp[pw + 1][v] = p[pw][p[pw][v]];\n\n\tfor (int to : g[v]) {\n\t\tif (to == pr)\n\t\t\tcontinue;\n\t\tprecalcLca(to, v);\n\t}\n\ttout[v] = T;\n}\n\nbool isParent(int l, int v) {\n\treturn tin[l] <= tin[v] && tout[v] <= tout[l];\n}\n\nint lca(int u, int v) {\n\tif (isParent(u, v))\n\t\treturn u;\n\tif (isParent(v, u))\n\t\treturn v;\n\t\n\tfor (int pw = LOG - 1; pw >= 0; pw--) \n\t\tif (!isParent(p[pw][v], u))\n\t\t\tv = p[pw][v];\n\tassert(!isParent(v, u));\n\tassert(isParent(p[0][v], u));\n\treturn p[0][v];\n}\n\nint getFarthest(int s) {\n\tvector<int> used(n, 0);\n\tqueue<int> q;\n\n\tused[s] = 1;\n\tq.push(s);\n\tint v;\n\twhile (!q.empty()) {\n\t\tv = q.front(); \n\t\tq.pop();\n\t\tfor (int to : g[v]) {\n\t\t\tif (used[to])\n\t\t\t\tcontinue;\n\t\t\tused[to] = 1;\n\t\t\tq.push(to);\n\t\t}\n\t}\n\treturn v;\n}\n\nint getDist(int u, int v) {\n\treturn h[u] + h[v] - 2 * h[lca(u, v)];\n}\n\nconst int M = int(2e5);\nvector<pt> ops[4 * M];\n\nvoid setOp(int v, int l, int r, int lf, int rg, const pt &op) {\n\tif (l >= r || lf >= rg) return;\n\tif (l == lf && r == rg) {\n\t\tops[v].push_back(op);\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tif (lf < mid)\n\t\tsetOp(2 * v + 1, l, mid, lf, min(mid, rg), op);\n\tif (rg > mid)\n\t\tsetOp(2 * v + 2, mid, r, max(lf, mid), rg, op);\n}\n\nvoid updDiam(int &s, int &t, int &curD, const pt &op) {\n\tint v = op.x;\n\ta[v] = op.y;\n\n\tint ns = s, nt = t, nD = curD;\n\n\tvector<pt> cds = {{s, v}, {v, t}, {v, v}};\n\tfor (auto &c : cds) {\n\t\tint d1 = getDist(c.x, c.y);\n\t\tif (nD < a[c.x] + d1 + a[c.y]) {\n\t\t\tnD = a[c.x] + d1 + a[c.y];\n\t\t\tns = c.x, nt = c.y;\n\t\t}\n\t}\n\ts = ns;\n\tt = nt;\n\tcurD = nD;\n}\n\nvector<int> ans;\n\nvoid calcDiams(int v, int l, int r, int s, int t, int curD) {\n\tfor (auto &op : ops[v])\n\t\tupdDiam(s, t, curD, op);\n\tif (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tcalcDiams(2 * v + 1, l, mid, s, t, curD);\n\t\tcalcDiams(2 * v + 2, mid, r, s, t, curD);\n\t}\n\telse\n\t\tans[l] = (curD + 1) / 2;\n\t\n\tfor (auto &op : ops[v])\n\t\ta[op.first] = 0;\n}\n\ninline void solve() {\n\tprecalcLca(0, 0);\n\tint s = getFarthest(0);\n\tint t = getFarthest(s);\n\n\tint m;\n\tcin >> m;\n\tvector<int> lst(n, 0);\n\tfore (i, 0, m) {\n\t\tint v, x;\n\t\tcin >> v >> x;\n\t\tv--;\n\n\t\tsetOp(0, 0, m, lst[v], i, {v, a[v]});\n\t\tlst[v] = i;\n\t\ta[v] = x;\n\t}\n\tfore (v, 0, n)\n\t\tsetOp(0, 0, m, lst[v], m, {v, a[v]});\n\n\tans.resize(m, -1);\n\ta.assign(n, 0);\n\tcalcDiams(0, 0, m, s, t, getDist(s, t));\n\n\tfore (i, 0, m)\n\t\tcout << ans[i] << '\\n';\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}