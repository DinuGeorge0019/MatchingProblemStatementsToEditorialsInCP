{"link": "https://codeforces.com//contest/1278/problem/D", "problemId": "498933", "shortId": "1278D", "contest_number": "1278", "name": "D. Segment Tree", "statement": "As the name of the task implies, you are asked to do some work with segments and trees.Recall that a tree is a connected undirected graph such that there is exactly one simple path between every pair of its vertices.You are given  segments ,  for every . It is guaranteed that all segments' endpoints are integers, and all endpoints are unique \u2014 there is no pair of segments such that they start in the same point, end in the same point or one starts in the same point the other one ends.Let's generate a graph with  vertices from these segments. Vertices  and  are connected by an edge if and only if segments  and  intersect and neither of it lies fully inside the other one.For example, pairs  and  will induce the edges but pairs  and  will not.Determine if the resulting graph is a tree or not.", "input": "The first line contains a single integer  () \u2014 the number of segments. The -th of the next  lines contain the description of the -th segment \u2014 two integers  and  (). It is guaranteed that all segments borders are pairwise distinct. ", "output": "Print \"\" if the resulting graph is a tree and \"\" otherwise.", "tutorial": "The main idea of the solution is to find a linear number of intersections of segments.Intersections can be found with sweep line approach. We will maintain a set for the endpoints open segments. When we add a segment, we find all segments which intersect with it \u2014 that is, all segments that end earlier than it. Obviously, if the number of intersections are greater than , then the answer is \"\". So as soon as we find  intersections, we stop our algorithm.After that, it is necessary to check the connectivity of the resulting graph. You can use DFS or DSU to do this.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(), (a).end()\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\ntypedef long long li;\ntypedef pair<li, li> pt;\n\nconst int N = 500010;\n\nint n;\npt a[N];\nvector<int> g[N];\nbool used[N];\n\nvoid dfs(int v, int p = -1) {\n\tused[v] = true;\n\tfor (auto to : g[v]) if (to != p) {\n\t\tif (!used[to])\n\t\t\tdfs(to, v);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n) scanf(\"%d%d\", &a[i].x, &a[i].y);\n\t\n\tvector<pt> evs;\n\tforn(i, n) {\n\t\tevs.pb(mp(a[i].x, i));\n\t\tevs.pb(mp(a[i].y, i));\n\t}\n\t\n\tsort(all(evs));\n\t\n\tint cnt = 0;\n\tset<pt> cur;\n\tfor (auto it : evs) {\n\t\tif (cnt >= n) break;\n\t\tif (cur.count(it)) {\n\t\t\tcur.erase(it);\n\t\t} else {\n\t\t\tint i = it.y;\n\t\t\tint r = a[i].y;\n\t\t\tfor (auto jt : cur) {\n\t\t\t\tif (jt.x > r) break;\n\t\t\t\tint j = jt.y;\n\t\t\t\tg[i].pb(j);\n\t\t\t\tg[j].pb(i);\n\t\t\t\tcnt++;\n\t\t\t\tif (cnt >= n) break;\n\t\t\t}\n\t\t\tcur.insert(mp(a[i].y, i));\n\t\t}\n\t}\n\t\n\tdfs(0);\n\tputs(cnt == n - 1 && count(used, used + n, 1) == n ? \"YES\" : \"NO\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}