{"link": "https://codeforces.com//contest/1327/problem/F", "problemId": "571329", "shortId": "1327F", "contest_number": "1327", "name": "F. AND Segments", "statement": "You are given three integers , ,  and  conditions .Calculate the number of distinct arrays , consisting of  integers such that:    for each ;  bitwise AND of numbers  for each . Two arrays  and  are considered different if there exists such a position  that . The number can be pretty large so print it modulo .", "input": "The first line contains three integers ,  and  (, , ) \u2014 the length of the array , the value such that all numbers in  should be smaller than  and the number of conditions, respectively. Each of the next  lines contains the description of a condition ,  and  (, ) \u2014 the borders of the condition segment and the required bitwise AND value on it.", "output": "Print a single integer \u2014 the number of distinct arrays  that satisfy all the above conditions modulo .", "tutorial": "We will solve the problem for each bit separately, and then multiply the results.Obviously, if the position is covered by a segment with the value , then we have no choice, and we must put  there. For segments with the value , there must be at least one position that they cover and its value is .So we can write the following dynamic programming:  \u2014 the number of arrays such that the last  was exactly at the position , and all -segments to the left of it contain at least one zero.It remains to determine which states  we can update from. The only restriction we have is that there should not be any segment  with the value , such that  and . Since in this case, this segment will not contain any zero values. For each position , we may precalculate the rightmost position  where some segment ending before  begins, and while calculating , we should sum up only the values starting from position . This can be done with prefix sums.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define sz(a) int((a).size())\n#define all(a) (a).begin(), (a).end()\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\ntypedef pair<int, int> pt;\n\nconst int MOD = 998244353;\nconst int N = 500 * 1000 + 13;\n\nint n, k, m;\npair<pt, int> q[N];\n\nint ones[N];\nint mx[N], sum[N];\n\nint add(int x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n    if (x < 0) x += MOD;\n    return x;\n}\n\nint calc(int t) {\n    memset(ones, 0, sizeof(ones));\n    memset(mx, -1, sizeof(mx));\n    \n    forn(i, m) {\n        int l = q[i].x.x, r = q[i].x.y;\n        if (q[i].y & (1 << t)) {\n            ones[l]++;\n            ones[r + 1]--;\n        } else {\n            mx[r] = max(mx[r], l);\n        }\n    }\n    \n    int j = -1;\n    forn(i, n) {\n        int cur = 0;\n        if (!ones[i]) {\n            cur = sum[i];\n            if (j == -1) cur = add(cur, 1);\n            else cur = add(cur, -sum[j]);\n        }\n        \n        sum[i + 1] = add(sum[i], cur);\n        ones[i + 1] += ones[i];\n        j = max(j, mx[i]);\n    }\n    \n    return add(sum[n], j != -1 ? -sum[j] : 1);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &k, &m);\n    forn(i, m) {\n        scanf(\"%d%d%d\", &q[i].x.x, &q[i].x.y, &q[i].y);\n        --q[i].x.x; --q[i].x.y;\n    }\n    \n    int ans = 1;\n    forn(i, k) ans = (ans * 1ll * calc(i)) % MOD;\n    printf(\"%d\\n\", ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}