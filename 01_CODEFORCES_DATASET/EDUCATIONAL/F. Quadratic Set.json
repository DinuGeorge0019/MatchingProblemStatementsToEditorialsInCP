{"link": "https://codeforces.com//contest/1622/problem/F", "problemId": "1242582", "shortId": "1622F", "contest_number": "1622", "name": "F. Quadratic Set", "statement": "Let's call a set of positive integers   if the product of the factorials of its elements is a square of an integer, i.\u2009e. , for some integer .You are given a positive integer .Your task is to find a  subset of a set  of maximum size. If there are multiple answers, print any of them.", "input": "A single line contains a single integer  ().", "output": "In the first line, print a single integer\u00a0\u2014 the size of the maximum subset. In the second line, print the subset itself in an arbitrary order.", "tutorial": "A good start to solve the problem would be to check the answers for small values of . One can see that the answers (the sizes of the maximum subsets) are not much different from  itself, or rather not less than . Let's try to prove that this is true for all .Consider  is even. Let , let's see what the product is equal to if we take all the numbers from  to .From here we can see that for even  the answer is at least , because we can delete  and the product of the remaining factorials will be the square of an integer, for odd  the answer is at least , because we can delete  and .It remains to prove that the answer is at least  for odd . This is easy to do, because the answer for  is not less than the answer for  minus , because we can delete  and solve the task with a smaller  value. Moreover, it can be seen from the previous arguments that the answer  can only be for , and we already know that in this case one of the correct answers is to remove the factorials .It remains to learn how to check whether it is possible to remove  or  numbers so that the remaining product of factorials is the square of an integer.To do this, we can use XOR hashes. Let's assign each prime number a random -bit number. For composite numbers, the hash is equal to the XOR of hashes of all its prime divisors from factorization. Thus, if some prime is included in the number an even number of times, it will not affect the value of the hash, which is what we need. The hash of the product of two numbers is equal to the XOR of the hashes of these numbers. Let's denote the hash function as .Using the above, let's calculate  for all  from  to , as well as  for all  from  to , this is easy to do, because . We will also store a map . Let's calculate the hash  and denote it as . It remains to consider the following cases:  if , then the current product is already the square of an integer;  for an answer of size , we have to check that there exists such a  that . To find such , let's check whether the map contains ;  for an answer of size , we have to check that there are such  and  that . To do this, iterate over , and then check whether map contains ;  otherwise, the answer is , and there is an answer, where all numbers except  are taken. ", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1000 * 1000 + 13;\n\nusing li = unsigned long long;\n\nint pr[N];\nli hs[N], f[N];\nunordered_map<li, int> rf;\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  \n  mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());\n  iota(pr, pr + N, 0);\n  for (int i = 2; i <= n; ++i) if (pr[i] == i) {\n    for (int j = i; j <= n; j += i) pr[j] = min(pr[j], i);\n    hs[i] = rnd();\n  }\n  for (int i = 2; i <= n; ++i) {\n    f[i] = f[i - 1];\n    int x = i;\n    while (x != 1) {\n      f[i] ^= hs[pr[x]];\n      x /= pr[x];\n    }\n    rf[f[i]] = i;\n  }\n  \n  auto solve = [&] (int n) -> vector<int> {\n    li fp = 0;\n    for (int i = 2; i <= n; ++i) fp ^= f[i];\n    if (fp == 0) return {};\n    if (rf.count(fp)) return {rf[fp]};\n    for (int i = 2; i <= n; ++i) {\n        li x = f[i] ^ fp;\n        if (rf.count(x) && rf[x] != i) return {rf[x], i};\n    }\n    return {2, n / 2, n};\n  };\n  \n  auto ans = solve(n);\n  printf(\"%d\\n\", n - (int)ans.size());\n  for (int i = 1; i <= n; ++i)\n    if (find(ans.begin(), ans.end(), i) == ans.end()) printf(\"%d \", i);\n  puts(\"\");\n} ", "interactive": false, "noSolution": false, "noTutorial": false}