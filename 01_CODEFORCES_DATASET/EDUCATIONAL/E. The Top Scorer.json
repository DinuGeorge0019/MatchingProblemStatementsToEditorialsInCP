{"link": "https://codeforces.com//contest/1096/problem/E", "problemId": "275412", "shortId": "1096E", "contest_number": "1096", "name": "E. The Top Scorer", "statement": "Hasan loves playing games and has recently discovered a game called TopScore. In this soccer-like game there are  players doing penalty shoot-outs. Winner is the one who scores the most. They have just finished the game and now are waiting for the result. But there's a tiny problem! The judges have lost the paper of scores! Fortunately they have calculated sum of the scores before they get lost and also for some of the players they have remembered a lower bound on how much they scored. However, the information about the bounds is private, so Hasan only got to know his bound.According to the available data, he knows that his score is at least  and sum of the scores is .Thus the final state of the game can be represented in form of sequence of  integers  () \u2014 player's scores. Hasan is player number , so . Also . Two states are considered different if there exists some position  such that the value of  differs in these states. Help Hasan find the probability of him winning.It can be shown that it is in the form of  where  and  are non-negative integers and , . Report the value of .", "input": "The only line contains three integers ,  and  (, ) \u2014 the number of players, the sum of scores of all players and Hasan's score, respectively.", "output": "Print a single integer \u2014 the probability of Hasan winning. It can be shown that it is in the form of  where  and  are non-negative integers and , . Report the value of .", "tutorial": "An straightforward dp solution is to calculate  {number of states at the end of the game in which no one has scored more than  goals} where  is the number of total goals to be scored and  is the number players in the game. Fix the score of Hasan in the game and by using this dp the rest is easy (also described below). But as long as the time needed to calculate  is  this solution won't fit in the constraints.With a little help from combinatorics, we can calculate the value of mentioned dp function without using recursions.Define  by inclusion-exclusion principle it can be easily seen that the value of  equals to the above . And the complexity of calculation for  is  with a  preprocess for calculating binomial coefficients.This formula is a well-known modification of \"Star and Bars\" problem but with the upper limit on terms.Now we can calculate the answer, firstly fix Hasan's score and number of top-scorers, then use  to calculate each state:  By using modulus arithmetic, the answer can be reported in the requested form.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int N = 10 * 1000 + 7;\nconst int M = 100 + 7;\n\nint fact[N], rfact[N];\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n\tint res = 1;\n\twhile (b){\n\t\tif (b & 1)\n\t\t\tres = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint cnk(int n, int k){\n\tif (n == k) return 1;\n\tif (k < 0 || k > n) return 0;\n\treturn mul(fact[n], mul(rfact[k], rfact[n - k]));\n}\n\nint g(int s, int p, int m){\n\tint res = 0;\n\tforn(i, p + 1)\n\t\tres = add(res, mul(i & 1 ? MOD - 1 : 1, mul(cnk(p, i), cnk(s + p - 1 - i * (m + 1), p - 1))));\n\treturn res;\n}\n\nint inv(int x){\n\treturn mul(rfact[x], fact[x - 1]);\n}\n\nint main() {\n\tfact[0] = 1;\n\tfor (int i = 1; i < N; ++i) fact[i] = mul(fact[i - 1], i);\n\trfact[N - 1] = binpow(fact[N - 1], MOD - 2);\n\tfor (int i = N - 2; i >= 0; --i) rfact[i] = mul(rfact[i + 1], i + 1);\n\t\n\tint p, s, r;\n\tscanf(\"%d%d%d\", &p, &s, &r);\n\t\n\tint Q = cnk(s - r + p - 1, p - 1);\n\tint P = 0;\n\tfor (int t = r; t <= s; ++t) for (int q = 1; q <= p; ++q)\n\t\tP = add(P, mul(mul(cnk(p - 1, q - 1), inv(q)), g(s - q * t, p - q, t - 1)));\n\t\n\tprintf(\"%d\\n\", mul(P, binpow(Q, MOD - 2)));\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}