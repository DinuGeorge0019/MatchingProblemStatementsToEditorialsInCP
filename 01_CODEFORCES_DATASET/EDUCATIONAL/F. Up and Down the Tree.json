{"link": "https://codeforces.com//contest/1065/problem/F", "problemId": "235283", "shortId": "1065F", "contest_number": "1065", "name": "F. Up and Down the Tree", "statement": "You are given a tree with  vertices; its root is vertex . Also there is a token, initially placed in the root. You can move the token to other vertices. Let's assume current vertex of token is , then you make any of the following two possible moves:   move down to any  in subtree of ;  if vertex  is a leaf, then move up to the parent no more than  times. In other words, if  is the depth of vertex  (the depth of the root is ), then you can move to vertex  such that  is an ancestor of  and . Consider that root is not a leaf (even if its degree is ). Calculate the maximum number of different leaves you can visit during one sequence of moves.", "input": "The first line contains two integers  and  () \u2014 the number of vertices in the tree and the restriction on moving up, respectively. The second line contains  integers , where  is the parent of vertex . It is guaranteed that the input represents a valid tree, rooted at .", "output": "Print one integer \u2014 the maximum possible number of different leaves you can visit.", "tutorial": "Let's calculate answer in two steps. At first, let's calculate for each vertex   \u2014 what we can gain if we must return from subtree of  in the end. We need only pair of values: minimal possible depth we can acquire to move up from subtree of  and maximal number of different leaves we can visit. Note, that this two values are independent since we must return from  and if for some child  of  we can return from it, it's profitable to visit  and return. But if we can't return from  so we are prohibited to descent to . So,  (number of visited leaves) is just a sum of all  if . Also note that we can always reorder all children in such way that last visited vertex  will have minimal . So  (minimal possible depth) is a minimum over all .At second, let's calculate  \u2014 maximal number of different leaves we can visit if we don't need to return from subtree of . It can be calculated quite easy using array . We just need to choose child  we will not return from, so from vertex  we will take value  and from other childen (which we can return from) value .Result complexity is .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, v.size()) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    fore(i, 1, n) {\n        int p; assert(scanf(\"%d\", &p) == 1);\n        p--;\n        \n        g[p].push_back(i);\n        g[i].push_back(p);\n    }\n    return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n    drev[v] = pt(INF, 0);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        \n        h[to] = h[v] + 1;\n        calcRev(to, v);\n        \n        if(drev[to].x <= h[v]) {\n            drev[v].x = min(drev[v].x, drev[to].x);\n            drev[v].y += drev[to].y;\n        }\n    }\n    \n    if(p >= 0 && g[v].size() == 1)\n        drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n    d[v] = (p >= 0 && g[v].size() == 1);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        calcAns(to, v);\n        \n        int tmp = drev[v].y;\n        if(drev[to].x <= h[v])\n            tmp -= drev[to].y;\n        \n        d[v] = max(d[v], tmp + d[to]);\n    }\n}\n\ninline void solve() {\n    h[0] = 0;\n    calcRev(0, -1);\n    calcAns(0, -1);\n    cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}