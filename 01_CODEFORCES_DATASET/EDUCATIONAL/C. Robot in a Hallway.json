{"link": "https://codeforces.com//contest/1716/problem/C", "problemId": "1494202", "shortId": "1716C", "contest_number": "1716", "name": "C. Robot in a Hallway", "statement": "There is a grid, consisting of  rows and  columns. The rows are numbered from  to  from top to bottom. The columns are numbered from  to  from left to right.The robot starts in a cell . In one second, it can perform either of two actions:   move into a cell adjacent by a side: up, right, down or left;  remain in the same cell. The robot is not allowed to move outside the grid.Initially, all cells, except for the cell , are locked. Each cell  contains a value \u00a0\u2014 the moment that this cell gets unlocked. The robot can only move into a cell  if at least  seconds have passed before the move.The robot should visit all cells  (cell  is considered entered at the start). It can finish in any cell.What is the fastest the robot can achieve that?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains a single integer  ()\u00a0\u2014 the number of columns of the grid. The -th of the next  lines contains  integers  ()\u00a0\u2014 the moment of time each cell gets unlocked. . If , then cell  is unlocked from the start. The sum of  over all testcases doesn't exceed .", "output": "For each testcase, print a single integer\u00a0\u2014 the minimum amount of seconds that the robot can take to visit all cells without entering any cell twice or more.", "tutorial": "Let's first consider the possible paths across the grid that visit all cells. You can immediately think of two of them. The first one is: go right to the wall, turn into the other row and return. Let's call it a hook. The second one is: go down, go right, go up, go right and so on. Let's call it a snake.Turns out, these two are basically the two extremes of all paths. You can start with a snake and turn into a hook when you wish. You can see that once you move right twice in a row, you can only continue with a hook. And as long as you didn't move right twice, you are just doing a snake.Let's fix some path across the grid. What will its minimum time be? Calculate it iteratively. If you want to enter the next cell, and it's still locked, wait until it isn't. So there are some seconds of waiting (possibly, zero) before each cell.However, why not instead do the following. Let's calculate the sum of waiting time required and wait for that amount of seconds before starting to move. All cells will be visited at the same time as before or even later. Thus, they will surely be unlocked if they were in the original plan.So the goal is to calculate the minimum amount of time required to wait in the start, then add the movement time to it.Once again, the path is fixed. Let the -th cell of the path be . If you start after waiting for  seconds, then you reach the -th cell at time  ( is -indexed). Thus, the -th cell should have . If all cells satisfy this condition, then the path can be done after waiting for  seconds at the start.Let's rewrite it into . So, the condition tells us that  should be greater or equal than this value for all cells. In other words,  should be greater or equal than the maximum of the values over all cells.Study the formula. Imagine we have some path with a known length and want to append a cell to it. That's pretty simple. Just update the maximum with the value with the corresponding cell and increase the length.What if we wanted to prepend a cell to it? Turns out, it's not that hard as well. Every cell in the path gets its value  increased by . From the formula, you can see that this actually decreases the value of each cell by . So the maximum decreases by  as well. The only thing left is to update the maximum with the value of the new first cell. Well, and increase the length again.Finally, let's learn how to choose the best path. We can iterate over the length of the snake part. The hook part is determined uniquely.It's easy to maintain the maximum on the snake. Just append the new cell to the path.How to glue up the hook part to that?Well, actually, realize that the formula allows us to glue up two paths into one. Let path  have length  and maximum  and path  have length  and maximum . To make path  start after path , we just decrease its maximum by . The resulting path has length  and maximum .Let's look closer into what the hooks look like. They start in some column , traverse all the way right, then left up to the same column . If the snake part took both cells in its last column, then that's it. Otherwise, the hook has to take the final cell in the last column\u00a0\u2014 column .If we manage to precalculate something for hooks that start in some column  and end in column , then we will be able to use that. Appending the final cell is not a hard task, since we know its index in the path ().Let  be the waiting time required for a hook that starts in cell  and ends in a cell  as if the path started with the hook (cell  is the first one). can be calculated from . Prepend it with a cell  and append it with a cell .The only thing left is to find the best answer. I found the most convenient to start with a snake of length  (only cell ) and progress it two steps at the time:   update the answer;  progress the snake to the other cell of the current column;  update the answer;  progress the snake into the next column. Overall complexity:  per testcase.", "solution": "INF = 2 * 10**9\n\nfor _ in range(int(input())):\n\tm = int(input())\n\ta = [[int(x) for x in input().split()] for i in range(2)]\n\tsu = [[-INF for j in range(m + 1)] for i in range(2)]\n\tfor i in range(2):\n\t\tfor j in range(m - 1, -1, -1):\n\t\t\tsu[i][j] = max(su[i][j + 1] - 1, a[i][j], a[i ^ 1][j] - (2 * (m - j) - 1))\n\tpr = a[0][0] - 1\n\tans = INF\n\tfor j in range(m):\n\t\tjj = j & 1\n\t\tans = min(ans, max(pr, su[jj][j + 1] - 2 * j - 1, a[jj ^ 1][j] - 2 * m + 1))\n\t\tpr = max(pr, a[jj ^ 1][j] - 2 * j - 1)\n\t\tans = min(ans, max(pr, su[jj ^ 1][j + 1] - 2 * j - 2))\n\t\tif j < m - 1:\n\t\t\tpr = max(pr, a[jj ^ 1][j + 1] - 2 * j - 2)\n\tprint(ans + 2 * m)", "interactive": false, "noSolution": false, "noTutorial": false}