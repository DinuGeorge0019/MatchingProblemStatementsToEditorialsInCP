{"link": "https://codeforces.com//contest/1093/problem/D", "problemId": "270225", "shortId": "1093D", "contest_number": "1093", "name": "D. Beautiful Graph", "statement": "You are given an undirected unweighted graph consisting of  vertices and  edges.You have to write a number on each vertex of the graph. Each number should be ,  or . The graph becomes beautiful if for each edge the sum of numbers on vertices connected by this edge is odd.Calculate the number of possible ways to write numbers ,  and  on vertices so the graph becomes beautiful. Since this number may be large, print it modulo ..The graph does not have any self-loops or multiple edges.", "input": "The first line contains one integer  () \u2014 the number of tests in the input. The first line of each test contains two integers  and  () \u2014 the number of vertices and the number of edges, respectively. Next  lines describe edges: -th line contains two integers ,  () \u2014 indices of vertices connected by -th edge. It is guaranteed that  and .", "output": "For each test print one line, containing one integer \u2014 the number of possible ways to write numbers , ,  on the vertices of given graph so it becomes beautiful. Since answers may be large, print them modulo .", "tutorial": "Let's denote a way to distribute numbers as a . Let's also call the paintings that meet the constraints  paintings (and all other paintings are bad).We can solve the problem for each connected component of the graph independently and multiply the answers. Let's analyze a painting of some connected component. If some vertex has an odd number written on it, then we should write even numbers on all adjacent vertices, and vice versa. So in fact we need to check if the component is bipartite, and if it is, divide it into two parts. The number of good paintings is , where  is the size of the first part, and  is the size of the second part, because we write 's into all vertices of one part, and 's or 's into all vertices of another part.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 999;\nconst int MOD = 998244353;\n\nint n, m;\nvector <int> g[N];\nint p2[N];\nint cnt[2];\nint col[N];\nbool bad;\n\nvoid dfs(int v, int c){\n\tcol[v] = c;\n\t++cnt[c];\n\tfor(auto to : g[v]){\n\t\tif(col[to] == -1) dfs(to, 1 - c);\n\t\tif((col[v] ^ col[to]) == 0)\n\t\t\tbad = true;\n\t}\n}\n\nint main() {\n    p2[0] = 1;\n    for(int i = 1; i < N; ++i)\n    \tp2[i] = (2 * p2[i - 1]) % MOD;\n    \t\n    int tc;\n    scanf(\"%d\", &tc);\n    while(tc--){\n    \tscanf(\"%d%d\", &n, &m);\n    \tfor(int i = 0; i < n; ++i)\n    \t    g[i].clear();\n    \t\n    \tfor(int i = 0; i < m; ++i){\n    \t\tint u, v;\n    \t\tscanf(\"%d %d\", &u, &v);\n    \t\t--u, --v;\n    \t\tg[u].push_back(v);\n    \t\tg[v].push_back(u);\n    \t}\n    \t\n    \tint res = 1;\n    \tfor(int i = 0; i < n; ++i) col[i] = -1;\n    \tfor(int i = 0; i < n; ++i){\n    \t    if(col[i] != -1) continue;\n            bad = false;\n            cnt[0] = cnt[1] = 0;\n            dfs(i, 0);\n    \t    if(bad){\n    \t\t    puts(\"0\");\n    \t\t    break;\n    \t    }\n    \t    int cur = (p2[cnt[0]] + p2[cnt[1]]) % MOD;\n    \t    res = (res * 1LL * cur) % MOD;\n    \t}\n    \t\n    \tif(!bad) printf(\"%d\\n\", res);\n    }\n    \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}